diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0dd4d459af..2c2c8cf386 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,25 @@
+## 1.0.1
+
+### Bug fixes
+
+* Fixed a crash when calling Table.toString() in debugger (#2429).
+* Revised `RealmResults.isLoaded()` description (#2895).
+
+## 1.0.0
+
+No changes since 0.91.1.
+
+## 0.91.1
+
+* Updated Realm Core to 1.0.1.
+
+### Bug fixes
+
+* Fixed a bug when opening a Realm cause a staled memory mapping. Symptoms are error messages like "Bad or incompatible history type", "File format version doesn't match", and "Encrypted interprocess sharing is currently unsupported". 
+
 ## 0.91.0
 
-* Updated Realm Core to 0.100.4.
+* Updated Realm Core to 1.0.0.
 
 ### Breaking changes
 
@@ -10,11 +29,20 @@
 ### Bug fixes
 
 * Calling RealmResults.deleteAllFromRealm() might lead to native crash (#2759).
+* The annotation processor now correctly reports an error if trying to reference interfaces in model classes (#2808).
 * Added null check to `addChangeListener` and `removeChangeListener` in `Realm` and `DynamicRealm` (#2772).
+* Calling `RealmObjectSchema.addPrimaryKey()` adds an index to the primary key field, and calling `RealmObjectSchema.removePrimaryKey()` removes the index from the field (#2832).
+* Log files are not deleted when calling `Realm.deleteRealm()` (#2834).
 
 ### Enhancements
 
-* Upgrading to OpenSSL 1.0.1t (#2749).
+* Upgrading to OpenSSL 1.0.1t. From July 11, 2016, Google Play only accept apps using OpenSSL 1.0.1r or later (https://support.google.com/faqs/answer/6376725, #2749).
+* Added support for automatically copying an initial database from assets using `RealmConfiguration.Builder.assetFile()`.
+* Better error messages when certain file operations fail.
+
+### Credits
+
+* Paweł Surówka (@thesurix) for adding the `RealmConfiguration.Builder.assetFile()`.
 
 ## 0.90.1
 
@@ -288,7 +316,7 @@
 * BREAKING CHANGE: Realm.executeTransaction() now directly throws any RuntimeException instead of wrapping it in a RealmException (#1682).
 * BREAKING CHANGE: RealmQuery.isNull() and RealmQuery.isNotNull() now throw IllegalArgumentException instead of RealmError if the fieldname is a linked field and the last element is a link (#1693).
 * Added Realm.isEmpty().
-* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (standalone, removed, closed, from different Realm) object (#1749).
+* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (unmanaged, removed, closed, from different Realm) object (#1749).
 * Attempting to refresh a Realm while a transaction is in process will now throw an IllegalStateException (#1712).
 * The Realm AAR now also contains the ProGuard configuration (#1767). (Thank you @skyisle)
 * Updated Realm Core to 0.95.
@@ -383,7 +411,7 @@
 * Deprecated Realm.migrateRealmAtPath(). It has been replaced by Realm.migrateRealm(RealmConfiguration).
 * Deprecated Realm.deleteFile(). It has been replaced by Realm.deleteRealm(RealmConfiguration).
 * Deprecated Realm.compactFile(). It has been replaced by Realm.compactRealm(RealmConfiguration).
-* RealmList.add(), RealmList.addAt() and RealmList.set() now copy standalone objects transparently into Realm.
+* RealmList.add(), RealmList.addAt() and RealmList.set() now copy unmanaged objects transparently into Realm.
 * Realm now works with Kotlin (M12+). (Thank you @cypressious)
 * Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
 * Added a check to give a better error message when null is used as value for a primary key.
@@ -471,7 +499,7 @@
 * Added Realm.allObjectsSorted() and RealmQuery.findAllSorted() and extending RealmResults.sort() for multi-field sorting.
 * Added more logging capabilities at the JNI level.
 * Added proper encryption support. NOTE: The key has been increased from 32 bytes to 64 bytes (see example).
-* Added support for standalone objects and custom constructors.
+* Added support for unmanaged objects and custom constructors.
 * Added more precise imports in proxy classes to avoid ambiguous references.
 * Added support for executing a transaction with a closure using Realm.executeTransaction().
 * Added RealmObject.isValid() to test if an object is still accessible.
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index ae1a793a9e..117abc2ef9 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -56,7 +56,7 @@ When writing unit tests, use the following guide lines:
 5) Use the `@RunInLooperThread` rule for any test that depends on Realms notification system. 
 
 6) Input-parameters should be boundary tested. Especially `Null/NotNull`, but also the state of Realm objects like
-   standalone objects, deleted objects, objects from other threads.
+   unmanaged objects, deleted objects, objects from other threads.
 
 7) Unit tests are not required to only have 1 test. It is acceptable to combine multiple tests into one unit test, but
    if it fails, it should be clear why it failed. E.g. you can group related tests with the same setup like negative 
diff --git a/README.md b/README.md
index 9b3af235e5..285431ba15 100644
--- a/README.md
+++ b/README.md
@@ -137,6 +137,10 @@ so each sub-project must be opened in its own window.
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 
+This project adheres to the [Contributor Covenant Code of Conduct](https://realm.io/conduct).
+By participating, you are expected to uphold this code. Please report
+unacceptable behavior to [info@realm.io](mailto:info@realm.io).
+
 ## License
 
 Realm Java is published under the Apache 2.0 license.
diff --git a/build.gradle b/build.gradle
index 15ab62fe4e..cef0f4b666 100644
--- a/build.gradle
+++ b/build.gradle
@@ -172,10 +172,6 @@ task distributionPackage(type:Zip) {
     from('changelog.txt')
     from('LICENSE')
     from('version.txt')
-    from("${buildDir}/outputs/gradle") {
-        include "realm-android-${currentVersion}.jar"
-        into 'gradle'
-    }
     from('realm/realm-library/build/libs') {
         include 'realm-android-${currentVersion}-javadoc.jar'
         into 'docs'
@@ -192,6 +188,19 @@ task distributionPackage(type:Zip) {
     }
 }
 
+task distributionJniUnstrippedPackage(type:Zip) {
+    description = 'Generate native libs package with debug symbols'
+    dependsOn assembleRealm
+
+    group = 'Artifact'
+    archiveName = "realm-java-jni-libs-unstripped-${currentVersion}.zip"
+    destinationDir = file("${buildDir}/outputs/distribution")
+
+    from("realm/realm-jni/build/outputs/jniLibs-unstripped") {
+        include '**/*.so'
+    }
+}
+
 task cleanRealm(type:GradleBuild) {
     description = 'Clean the Realm project'
     group = 'Clean'
@@ -238,7 +247,9 @@ task uploadDistributionPackage(type: Exec) {
     group = 'Release'
     description = 'Upload the distribution package to S3'
     dependsOn distributionPackage
+    dependsOn distributionJniUnstrippedPackage
     commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+    commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-jni-libs-unstripped-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
 }
 
 task createEmptyFile(type: Exec) {
diff --git a/examples/build.gradle b/examples/build.gradle
index c1c2682d7a..f8e6fe2e64 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -13,11 +13,12 @@ allprojects {
         repositories {
             mavenLocal()
             jcenter()
+            maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:1.5.0'
+            classpath 'com.android.tools.build:gradle:2.1.0'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
-            classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+            classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
             classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index 8a9b117667..668f954d24 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -115,7 +115,6 @@ public void execute(Realm realm) {
                 person.setName("Senior Person");
                 person.setAge(99);
                 showStatus(person.getName() + " got older: " + person.getAge());
-                realm.commitTransaction();
             }
         });
 
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 813315c73c..6a94f78e9f 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -52,5 +52,6 @@ android {
 
 dependencies {
     compile "org.jetbrains.kotlin:kotlin-stdlib:${kotlin_version}"
+    compile "org.jetbrains.kotlin:kotlin-reflect:${kotlin_version}"
     compile 'org.jetbrains.anko:anko-sdk15:0.8.2'
 }
diff --git a/examples/newsreaderExample/src/release/AndroidManifest.xml b/examples/newsreaderExample/src/release/AndroidManifest.xml
index d044658dcf..815e4d18c1 100644
--- a/examples/newsreaderExample/src/release/AndroidManifest.xml
+++ b/examples/newsreaderExample/src/release/AndroidManifest.xml
@@ -2,5 +2,5 @@
 <manifest package="io.realm.examples.newsreader"
           xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <application android:name=".DebugNewsReaderApplication"/>
+    <application android:name=".ReleaseNewsReaderApplication"/>
 </manifest>
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
index 31589fd6a9..fcfd43d85e 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
@@ -144,7 +144,7 @@ public Person call(Realm realm) {
 
         // buffer() caches objects until the buffer is full. Due to Realms auto-update of all objects it means
         // that all objects in the cache will contain the same data.
-        // Either avoid using buffer or copy data into an un-managed object.
+        // Either avoid using buffer or copy data into an unmanaged object.
         return personObserver
                 .buffer(2)
                 .subscribe(new Action1<List<Person>>() {
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index dec61401ca..2bcb843bee 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -47,7 +47,7 @@ dependencies {
     compile localGroovy()
     compile "io.realm:realm-transformer:${version}"
     compile 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-    provided 'com.android.tools.build:gradle:1.5.0'
+    provided 'com.android.tools.build:gradle:2.1.0'
 
     testCompile gradleTestKit()
     testCompile 'junit:junit:4.12'
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index e7be7c0de8..432348538b 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -52,7 +52,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.android.tools.build:gradle:2.1.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
@@ -77,7 +77,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.android.tools.build:gradle:2.1.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index c9ee011571..5b98178bea 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -45,7 +45,7 @@ dependencies {
     compile localGroovy()
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
-    provided 'com.android.tools.build:gradle:1.5.0'
+    provided 'com.android.tools.build:gradle:2.1.0'
     compile 'org.javassist:javassist:3.20.0-GA'
 
     testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
diff --git a/realm/build.gradle b/realm/build.gradle
index 589eb622a1..44d2ab9c3f 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -2,14 +2,15 @@ buildscript {
     repositories {
         mavenLocal()
         jcenter()
+        maven { url 'https://jitpack.io' }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
+        classpath 'com.android.tools.build:gradle:2.1.0'
         classpath 'de.undercouch:gradle-download-task:2.0.0'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+        classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 94586963b4..630e56eefe 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -31,8 +31,10 @@
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import io.realm.annotations.Ignore;
@@ -59,11 +61,13 @@
 
     private final List<TypeMirror> validPrimaryKeyTypes;
     private final Types typeUtils;
+    private final Elements elements;
 
     public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
+        elements = env.getElementUtils();
         TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
         validPrimaryKeyTypes = Arrays.asList(
                 stringType,
@@ -112,6 +116,7 @@ public boolean generate() {
 
         if (!categorizeClassElements()) return false;
         if (!checkListTypes()) return  false;
+        if (!checkReferenceTypes()) return  false;
         if (!checkDefaultConstructor()) return false;
         if (!checkForFinalFields()) return false;
         if (!checkForTransientFields()) return false;
@@ -156,15 +161,46 @@ private boolean checkForFinalFields() {
     private boolean checkListTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmList(field)) {
+                // Check for missing generic (default back to Object)
                 if (Utils.getGenericType(field) == null) {
                     Utils.error("No generic type supplied for field", field);
                     return false;
                 }
+
+                // Check that the referenced type is a concrete class and not an interface
+                TypeMirror fieldType = field.asType();
+                List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
+                String genericCanonicalType = typeArguments.get(0).toString();
+                TypeElement typeElement = elements.getTypeElement(genericCanonicalType);
+                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                    Utils.error("Only concrete Realm classes are allowed in RealmLists. Neither " +
+                            "interfaces nor abstract classes can be used.", field);
+                    return false;
+                }
             }
         }
+
         return true;
     }
 
+    private boolean checkReferenceTypes() {
+        for (VariableElement field : fields) {
+            if (Utils.isRealmModel(field)) {
+                // Check that the referenced type is a concrete class and not an interface
+                TypeElement typeElement = elements.getTypeElement(field.asType().toString());
+                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                    Utils.error("Only concrete Realm classes can be referenced in model classes. " +
+                            "Neither interfaces nor abstract classes can be used.", field);
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+
+
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 92354116c2..4e5ecf260a 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -752,18 +752,18 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 .emitStatement("return null")
             .endControlFlow()
             .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-            .emitStatement("%s standaloneObject", className)
+            .emitStatement("%s unmanagedObject", className)
             .beginControlFlow("if (cachedObject != null)")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                 .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
                     .emitStatement("return (%s)cachedObject.object", className)
                 .nextControlFlow("else")
-                    .emitStatement("standaloneObject = (%s)cachedObject.object", className)
+                    .emitStatement("unmanagedObject = (%s)cachedObject.object", className)
                     .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow()
             .nextControlFlow("else")
-                .emitStatement("standaloneObject = new %s()", className)
-                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject))")
+                .emitStatement("unmanagedObject = new %s()", className)
+                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject))")
             .endControlFlow();
 
         for (VariableElement field : metadata.getFields()) {
@@ -775,34 +775,34 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .emitStatement("((%s) standaloneObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
+                    .emitStatement("((%s) unmanagedObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
                                 interfaceName, setter, Utils.getProxyClassSimpleName(field), interfaceName, getter);
             } else if (Utils.isRealmList(field)) {
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
                     .beginControlFlow("if (currentDepth == maxDepth)")
-                        .emitStatement("((%s) standaloneObject).%s(null)", interfaceName, setter)
+                        .emitStatement("((%s) unmanagedObject).%s(null)", interfaceName, setter)
                     .nextControlFlow("else")
                         .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
                                 Utils.getGenericType(field), fieldName, interfaceName, getter)
-                        .emitStatement("RealmList<%1$s> standalone%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
-                        .emitStatement("((%s) standaloneObject).%s(standalone%sList)", interfaceName, setter, fieldName)
+                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
+                        .emitStatement("((%s) unmanagedObject).%s(unmanaged%sList)", interfaceName, setter, fieldName)
                         .emitStatement("int nextDepth = currentDepth + 1")
                         .emitStatement("int size = managed%sList.size()", fieldName)
                         .beginControlFlow("for (int i = 0; i < size; i++)")
                             .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
                                     Utils.getGenericType(field), Utils.getProxyClassSimpleName(field), fieldName)
-                            .emitStatement("standalone%sList.add(item)", fieldName)
+                            .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
                     .endControlFlow();
             } else {
-                writer.emitStatement("((%s) standaloneObject).%s(((%s) realmObject).%s())",
+                writer.emitStatement("((%s) unmanagedObject).%s(((%s) realmObject).%s())",
                         interfaceName, setter, interfaceName, getter);
             }
         }
 
-        writer.emitStatement("return standaloneObject");
+        writer.emitStatement("return unmanagedObject");
         writer.endMethod();
         writer.emitEmptyLine();
     }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 7bea9166ea..d7eff132bd 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -55,6 +55,7 @@
     private JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
     private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
     private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
+    private JavaFileObject customInterface = JavaFileObjects.forResource("some/test/CustomInterface.java");
 
     @Test
     public void compileSimpleFile() {
@@ -443,4 +444,20 @@ public void compileWithRealmModelFieldInReamlModel() {
                 .processedWith(new RealmProcessor())
                 .compilesWithoutError();
     }
+
+    @Test
+    public void compileWithInterfaceForList() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(JavaFileObjects.forResource("some/test/InterfaceList.java"), customInterface))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileWithInterfaceForObject() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(JavaFileObjects.forResource("some/test/InterfaceObjectReference.java"), customInterface))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 5d28d96813..a9645b0ef2 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -661,45 +661,45 @@ public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        AllTypes standaloneObject;
+        AllTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (AllTypes)cachedObject.object;
             } else {
-                standaloneObject = (AllTypes)cachedObject.object;
+                unmanagedObject = (AllTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new AllTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new AllTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
 
         // Deep copy of columnObject
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
 
         // Deep copy of columnRealmList
         if (currentDepth == maxDepth) {
-            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(null);
+            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(null);
         } else {
             RealmList<AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-            RealmList<AllTypes> standalonecolumnRealmListList = new RealmList<AllTypes>();
-            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(standalonecolumnRealmListList);
+            RealmList<AllTypes> unmanagedcolumnRealmListList = new RealmList<AllTypes>();
+            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(unmanagedcolumnRealmListList);
             int nextDepth = currentDepth + 1;
             int size = managedcolumnRealmListList.size();
             for (int i = 0; i < size; i++) {
                 AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
-                standalonecolumnRealmListList.add(item);
+                unmanagedcolumnRealmListList.add(item);
             }
         }
-        return standaloneObject;
+        return unmanagedObject;
     }
 
     static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 468e4c1f51..0fe76e0cbe 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -294,24 +294,24 @@ public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Booleans standaloneObject;
+        Booleans unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (Booleans)cachedObject.object;
             } else {
-                standaloneObject = (Booleans)cachedObject.object;
+                unmanagedObject = (Booleans)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new Booleans();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new Booleans();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
-        return standaloneObject;
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 2001284f7f..266dd5b234 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -1137,43 +1137,43 @@ public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDep
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        NullTypes standaloneObject;
+        NullTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (NullTypes)cachedObject.object;
             } else {
-                standaloneObject = (NullTypes)cachedObject.object;
+                unmanagedObject = (NullTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new NullTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new NullTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
 
         // Deep copy of fieldObjectNull
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
-        return standaloneObject;
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 6cb7a3edc2..22dba1e930 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -216,22 +216,22 @@ public static Simple createDetachedCopy(Simple realmObject, int currentDepth, in
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Simple standaloneObject;
+        Simple unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (Simple)cachedObject.object;
             } else {
-                standaloneObject = (Simple)cachedObject.object;
+                unmanagedObject = (Simple)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new Simple();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new Simple();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((SimpleRealmProxyInterface) standaloneObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
-        ((SimpleRealmProxyInterface) standaloneObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
-        return standaloneObject;
+        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
+        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java b/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
new file mode 100644
index 0000000000..d700a10f8c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+
+// Any interface that extends RealmModel is still a RealmModel interface, so the annotation
+// processor should accept it.
+public interface CustomInterface extends RealmModel {
+}
+
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java
new file mode 100644
index 0000000000..18417d5c58
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class InterfaceList implements CustomInterface {
+    String name;
+    RealmList<CustomInterface> realmList;  // Polymorphism, not yet supported.
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java
new file mode 100644
index 0000000000..1b133f59a5
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class InterfaceObjectReference implements CustomInterface {
+    String name;
+    CustomInterface obj; // Polymorphism, not yet supported.
+}
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
index 7ed718466d..95650090c0 100644
--- a/realm/realm-jni/build.gradle
+++ b/realm/realm-jni/build.gradle
@@ -1,8 +1,8 @@
 import java.security.MessageDigest
 
-ext.coreVersion = '0.100.4'
+ext.coreVersion = '1.0.1'
 // empty or comment out this to disable hash checking
-ext.coreSha256Hash = '076e9ccaa3cea0243cdfca4a1ed3648eb283b82ed8bb26b4e4dcd76ff1e70c73'
+ext.coreSha256Hash = 'e132f5824dc31e683353fb0be91eb45cac702f88f8cee819499a1dfa7936aeac'
 ext.forceDownloadCore =
         project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
 // gcc is default for the NDK. It also produces smaller binaries
@@ -327,7 +327,7 @@ targets.each { target ->
         // Store the unstripped version
         copy {
             from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
-            into "${projectDir}/../build/output/jniLibs-unstripped/${target.abi}"
+            into "${buildDir}/outputs/jniLibs-unstripped/${target.abi}"
             rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
         }
     }
@@ -347,7 +347,6 @@ task clean(type: Delete) {
     delete project.buildDir
 
     delete fileTree(dir: "${projectDir}/../realm-library/src/main/jniLibs/", include: '**/librealm-jni*.so')
-    delete fileTree(dir: "${projectDir}/../build/output/jniLibs-unstripped/", include: '**/librealm-jni*.so')
     delete fileTree(dir: "${projectDir}/src/", include: '**/librealm-jni*-stripped.so')
 
     doLast {
diff --git a/realm/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
index 943c435968..b9ba053379 100644
--- a/realm/realm-jni/src/io_realm_internal_Table.h
+++ b/realm/realm-jni/src/io_realm_internal_Table.h
@@ -797,22 +797,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeHasSameSchema
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
index 85c54e1420..2d6031919f 100644
--- a/realm/realm-jni/src/io_realm_internal_TableView.h
+++ b/realm/realm-jni/src/io_realm_internal_TableView.h
@@ -511,22 +511,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeWhere
diff --git a/realm/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-jni/src/io_realm_internal_table.cpp
index b5680bb491..4bab1930be 100644
--- a/realm/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-jni/src/io_realm_internal_table.cpp
@@ -1512,36 +1512,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong maxRows)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->to_string(ss, S(maxRows));
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong rowIndex)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TBL_AND_ROW_INDEX_VALID(env, table, rowIndex))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->row_to_string(S(rowIndex), ss);
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeEquals(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong nativeTableToComparePtr)
 {
diff --git a/realm/realm-jni/src/io_realm_internal_tableview.cpp b/realm/realm-jni/src/io_realm_internal_tableview.cpp
index 7d5d6451af..516c0e5ee8 100644
--- a/realm/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm/realm-jni/src/io_realm_internal_tableview.cpp
@@ -1027,37 +1027,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong maxRows)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return NULL;
-
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        TV(nativeViewPtr)->to_string(ss, S(maxRows));
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return NULL;
-
-        std::ostringstream ss;
-        TV(nativeViewPtr)->row_to_string(S(rowIndex), ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
     JNIEnv *env, jobject, jlong nativeViewPtr)
 {
diff --git a/realm/realm-library/src/androidTest/assets/asset_file.realm b/realm/realm-library/src/androidTest/assets/asset_file.realm
new file mode 100644
index 0000000000..1539f77dd2
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/asset_file.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 64b050a7ff..d147fd591a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -37,7 +37,7 @@
         MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS
     }
 
-    // Enumerate all current supported collections that can be in un-managed mode.
+    // Enumerate all current supported collections that can be in unmanaged mode.
     protected enum UnManagedCollection {
         UNMANAGED_REALMLIST
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index f6276d7c29..0812e5f972 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -47,7 +47,7 @@
 /**
  * Test class for all methods part of the the {@link RealmCollection} interface.
  * This class only tests collections that are managed by Realm. See {@link UnManagedRealmCollectionTests} for
- * all tests targeting un-managed collections.
+ * all tests targeting unmanaged collections.
  *
  * Methods tested in this class:
  *
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index cc81f71bd2..7fbed86aca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -263,7 +263,7 @@ public void iterator_remove() {
             return;
         }
 
-        // un-managed objects are always invalid, but cannot be GC'ed while we have a reference.
+        // Unmanaged objects are always invalid, but cannot be GC'ed while we have a reference.
         // managed objects should not be deleted (= invalid).
         assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
         assertTrue(obj.isValid());
@@ -286,7 +286,7 @@ public void iterator_deleteManagedObjectIndirectly() {
                 assertEquals(TEST_SIZE - 1, collection.size());
                 break;
 
-            // Un-managed collections are not affected by changes to Realm and RealmResult should maintain a stable
+            // Unmanaged collections are not affected by changes to Realm and RealmResult should maintain a stable
             // view until next time sync_if_needed is called.
             case UNMANAGED_REALMLIST:
             case REALMRESULTS:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index 32cbfc0aaf..4d4665e4d7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -37,7 +37,7 @@
 import static org.junit.Assert.fail;
 
 /**
- * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or un-managed.
+ * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or unmanaged.
  *
  * Methods tested in this class:
  *
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 7932143215..142bf015be 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -328,7 +328,7 @@ public void accessingRealmListOnUnloadedRealmObjectShouldThrow() {
     }
 
     @Test
-    public void standaloneObjectAsyncBehaviour() {
+    public void unmanagedObjectAsyncBehaviour() {
         Dog dog = new Dog();
         dog.setName("Akamaru");
         dog.setAge(10);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index cb720cf374..d799572319 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -16,17 +16,17 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.test.MoreAsserts;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.test.MoreAsserts;
+
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Field;
@@ -41,6 +41,8 @@
 import io.realm.entities.Dog;
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
@@ -764,14 +766,11 @@ public void initialDataTransactionAssetFile() throws IOException {
         Realm.deleteRealm(defaultConfig);
 
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
-        configFactory.copyRealmFromAssets(context, "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        configFactory.copyRealmFromAssets(context, "asset_file.realm", Realm.DEFAULT_REALM_NAME);
         assertTrue(new File(configFactory.getRoot(), Realm.DEFAULT_REALM_NAME).exists());
 
         Realm.Transaction transaction = mock(Realm.Transaction.class);
         RealmConfiguration configuration = configFactory.createConfigurationBuilder()
-                // Just reuse existing file and set right schema
-                .schemaVersion(0)
-                .schema(AllTypes.class)
                 .initialData(transaction)
                 .build();
 
@@ -780,6 +779,83 @@ public void initialDataTransactionAssetFile() throws IOException {
         verify(transaction, never()).execute(realm);
     }
 
+    @Test
+    public void assetFileNullAndEmptyFileName() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, "").build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileWithInMemoryConfig() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm").inMemory().build();
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileFakeFile() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "no_file").build();
+        try {
+            Realm.getInstance(configuration);
+            fail();
+        } catch (RealmIOException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileValidFile() throws IOException {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm")
+                .build();
+        Realm.deleteRealm(configuration);
+
+        File realmFile = new File(configuration.getPath());
+        assertFalse(realmFile.exists());
+
+        realm = Realm.getInstance(configuration);
+        assertTrue(realmFile.exists());
+
+        // Asset file has 10 Owners and 10 Cats, check if data is present
+        assertEquals(10, realm.where(Owner.class).count());
+        assertEquals(10, realm.where(Cat.class).count());
+
+        realm.close();
+
+        // Copy original file to another location
+        configFactory.copyRealmFromAssets(context, "asset_file.realm", "asset_file_copy.realm");
+        File copyFromAsset = new File(configFactory.getRoot(), "asset_file_copy.realm");
+        assertTrue(copyFromAsset.exists());
+
+        Realm.deleteRealm(configuration);
+        assertFalse(realmFile.exists());
+    }
+
     private static class MigrationWithNoEquals implements RealmMigration {
         @Override
         public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index d63d337a74..1230a7c761 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -86,7 +86,7 @@ public void tearDown() throws Exception {
         }
     }
 
-    private RealmList<Dog> createNonManagedDogList() {
+    private RealmList<Dog> createUnmanagedDogList() {
         RealmList<Dog> list = new RealmList<Dog>();
         for (int i = 0; i < TEST_SIZE; i++) {
             list.add(new Dog("Dog " + i));
@@ -106,25 +106,25 @@ public void tearDown() throws Exception {
 
             //noinspection TryWithIdenticalCatches
     /*********************************************************
-     * Un-managed mode tests                                *
+     * Unmanaged mode tests                                *
      *********************************************************/
 
     @Test(expected = IllegalArgumentException.class)
-    public void constructor_nonManaged_null() {
+    public void constructor_unmanaged_null() {
         AllTypes[] args = null;
         //noinspection ConstantConditions
         new RealmList<AllTypes>(args);
     }
 
     @Test
-    public void isValid_nonManagedMode() {
+    public void isValid_unmanagedMode() {
         //noinspection MismatchedQueryAndUpdateOfCollection
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         assertFalse(list.isValid());
     }
 
     @Test
-    public void add_nonManagedMode() {
+    public void add_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object = new AllTypes();
         object.setColumnString("String");
@@ -134,12 +134,12 @@ public void add_nonManagedMode() {
     }
 
     @Test (expected = IllegalArgumentException.class)
-    public void add_nullInNonManagedMode() {
+    public void add_nullInUnmanagedMode() {
         new RealmList<AllTypes>().add(null);
     }
 
     @Test
-    public void add_managedObjectInNonManagedMode() {
+    public void add_managedObjectInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         realm.beginTransaction();
         AllTypes managedAllTypes = realm.createObject(AllTypes.class);
@@ -150,7 +150,7 @@ public void add_managedObjectInNonManagedMode() {
     }
 
     @Test
-    public void add_standaloneObjectAtIndexInNonManagedMode() {
+    public void add_unmanagedObjectAtIndexInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object = new AllTypes();
         object.setColumnString("String");
@@ -160,7 +160,7 @@ public void add_standaloneObjectAtIndexInNonManagedMode() {
     }
 
     @Test
-    public void add_managedObjectAtIndexInNonManagedMode() {
+    public void add_managedObjectAtIndexInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         realm.beginTransaction();
@@ -182,12 +182,12 @@ public void add_objectAtIndexInManagedMode() {
     }
 
     @Test (expected = IllegalArgumentException.class)
-    public void add_nullAtIndexInNonManagedMode() {
+    public void add_nullAtIndexInUnmanagedMode() {
         new RealmList<AllTypes>().add(0, null);
     }
 
     @Test
-    public void set_nonManagedMode() {
+    public void set_unmanagedMode() {
         RealmList<Dog> list = new RealmList<Dog>();
         Dog dog1 = new Dog("dog1");
         Dog dog2 = new Dog("dog2");
@@ -214,7 +214,7 @@ public void set_managedMode() {
     }
 
     @Test
-    public void set_nullInNonManagedMode() {
+    public void set_nullInUnmanagedMode() {
         @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
@@ -223,7 +223,7 @@ public void set_nullInNonManagedMode() {
     }
 
     @Test
-    public void set_managedObjectInNonManagedMode() {
+    public void set_managedObjectInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         realm.beginTransaction();
@@ -235,7 +235,7 @@ public void set_managedObjectInNonManagedMode() {
     }
 
     @Test
-    public void clear_nonManagedMode() {
+    public void clear_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         assertEquals(1, list.size());
@@ -244,7 +244,7 @@ public void clear_nonManagedMode() {
     }
 
     @Test
-    public void remove_nonManagedMode() {
+    public void remove_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object1 = new AllTypes();
         list.add(object1);
@@ -281,8 +281,8 @@ public void move_up() {
 
     // Test move where oldPosition > newPosition
     @Test
-    public void move_downInNonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
+    public void move_downInUnmanagedMode() {
+        RealmList<Dog> dogs = createUnmanagedDogList();
         Dog dog1 = dogs.get(1);
         dogs.move(1, 0);
 
@@ -291,8 +291,8 @@ public void move_downInNonManagedMode() {
 
     // Test move where oldPosition < newPosition
     @Test
-    public void move_upInNonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
+    public void move_upInUnmanagedMode() {
+        RealmList<Dog> dogs = createUnmanagedDogList();
         int oldIndex = TEST_SIZE / 2;
         int newIndex = oldIndex + 1;
         Dog dog = dogs.get(oldIndex);
@@ -371,9 +371,9 @@ public void add_managedObjectToManagedList() {
         assertEquals(1, realm.where(Owner.class).findFirst().getDogs().size());
     }
 
-    // Test that add correctly uses Realm.copyToRealm() on standalone objects.
+    // Test that add correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
-    public void add_nonManagedObjectToManagedList() {
+    public void add_unmanagedObjectToManagedList() {
         realm.beginTransaction();
         CyclicType parent = realm.createObject(CyclicType.class);
         RealmList<CyclicType> children = parent.getObjects();
@@ -382,9 +382,9 @@ public void add_nonManagedObjectToManagedList() {
         assertEquals(1, realm.where(CyclicType.class).findFirst().getObjects().size());
     }
 
-    // Make sure that standalone objects with a primary key are added using copyToRealmOrUpdate
+    // Make sure that unmanaged objects with a primary key are added using copyToRealmOrUpdate
     @Test
-    public void add_nonManagedPrimaryKeyObjectToManagedList() {
+    public void add_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
         realm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
         RealmList<CyclicTypePrimaryKey> children = realm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
@@ -395,9 +395,9 @@ public void add_nonManagedPrimaryKeyObjectToManagedList() {
         assertEquals("new", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
     }
 
-    // Test that set correctly uses Realm.copyToRealm() on standalone objects.
+    // Test that set correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
-    public void set_nonManagedObjectToManagedList() {
+    public void set_unmanagedObjectToManagedList() {
         realm.beginTransaction();
         CyclicType parent = realm.copyToRealm(new CyclicType("Parent"));
         RealmList<CyclicType> children = parent.getObjects();
@@ -413,9 +413,9 @@ public void set_nonManagedObjectToManagedList() {
         assertEquals(5, realm.where(CyclicType.class).count());
     }
 
-    // Test that set correctly uses Realm.copyToRealmOrUpdate() on standalone objects with a primary key.
+    // Test that set correctly uses Realm.copyToRealmOrUpdate() on unmanaged objects with a primary key.
     @Test
-    public void set_nonManagedPrimaryKeyObjectToManagedList() {
+    public void set_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
         CyclicTypePrimaryKey parent = realm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
         RealmList<CyclicTypePrimaryKey> children = parent.getObjects();
@@ -594,7 +594,7 @@ public void removeAll_managedMode_wrongClass() {
 
     @Test
     public void removeAll_unmanaged_wrongClass() {
-        RealmList<Dog> list = createNonManagedDogList();
+        RealmList<Dog> list = createUnmanagedDogList();
         //noinspection SuspiciousMethodCalls
         assertFalse(list.removeAll(Collections.singletonList(new Cat())));
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index b90e014ccd..2c81d4fb9d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -226,6 +226,41 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
+    @Test
+    public void settingPrimaryKeyWithObjectSchema() {
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(AllTypes.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("AnnotationTypes")
+                        .addField("id", long.class)
+                        .addPrimaryKey("id")    // use addPrimaryKey() instead of adding FieldAttribute.PrimaryKey
+                        .addField("indexString", String.class)
+                        .addIndex("indexString") // use addIndex() instead of FieldAttribute.Index
+                        .addField("notIndexString", String.class);
+            }
+        };
+
+        // Create v1 of the Realm
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(AllTypes.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+
+        realm = Realm.getInstance(realmConfig);
+        RealmObjectSchema schema = realm.getSchema().get("AnnotationTypes");
+        assertTrue(schema.hasPrimaryKey());
+        assertTrue(schema.hasIndex("id"));
+        realm.close();
+    }
+
     // adding search index is idempotent
     @Test
     public void addingSearchIndexTwice() throws IOException {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 1485391bab..5bf386836c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -123,15 +123,15 @@ public void copyFromRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class).findAllSorted(AllTypesRealmModel.FIELD_LONG).first();
-        AllTypesRealmModel standaloneObject = realm.copyFromRealm(realmObject);
-        assertArrayEquals(realmObject.columnBinary, standaloneObject.columnBinary);
-        assertEquals(realmObject.columnString, standaloneObject.columnString);
-        assertEquals(realmObject.columnLong, standaloneObject.columnLong);
-        assertEquals(realmObject.columnFloat, standaloneObject.columnFloat, 0.00000000001);
-        assertEquals(realmObject.columnDouble, standaloneObject.columnDouble, 0.00000000001);
-        assertEquals(realmObject.columnBoolean, standaloneObject.columnBoolean);
-        assertEquals(realmObject.columnDate, standaloneObject.columnDate);
-        assertEquals(realmObject.hashCode(), standaloneObject.hashCode());
+        AllTypesRealmModel unmanagedObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.columnBinary, unmanagedObject.columnBinary);
+        assertEquals(realmObject.columnString, unmanagedObject.columnString);
+        assertEquals(realmObject.columnLong, unmanagedObject.columnLong);
+        assertEquals(realmObject.columnFloat, unmanagedObject.columnFloat, 0.00000000001);
+        assertEquals(realmObject.columnDouble, unmanagedObject.columnDouble, 0.00000000001);
+        assertEquals(realmObject.columnBoolean, unmanagedObject.columnBoolean);
+        assertEquals(realmObject.columnDate, unmanagedObject.columnDate);
+        assertEquals(realmObject.hashCode(), unmanagedObject.hashCode());
 
     }
 
@@ -260,7 +260,7 @@ public void invalidModelDefinition() {
     }
 
     // Test the behaviour of a RealmModel, containing a RealmList
-    // of other RealmModel, in managed and un-managed mode
+    // of other RealmModel, in managed and unmanaged mode
     @Test
     public void realmModelWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModels = new RealmList<AllTypesRealmModel>();
@@ -289,7 +289,7 @@ public void realmModelWithRealmListOfRealmModel() {
     }
 
     // Test the behaviour of a RealmModel, containing a RealmList
-    // of RealmObject, in managed and un-managed mode
+    // of RealmObject, in managed and unmanaged mode
     @Test
     public void realmModelWithRealmListOfRealmObject() {
         RealmList<AllTypes> allTypes = new RealmList<AllTypes>();
@@ -318,7 +318,7 @@ public void realmModelWithRealmListOfRealmObject() {
     }
 
     // Test the behaviour of a RealmObject, containing a RealmList
-    // of RealmModel, in managed and un-managed mode
+    // of RealmModel, in managed and unmanaged mode
     @Test
     public void realmObjectWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModel = new RealmList<AllTypesRealmModel>();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 9ce641cb9e..cb9cf3f5c3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -514,9 +514,11 @@ public void setRemovePrimaryKey() {
             schema.addPrimaryKey(fieldName);
             assertTrue(schema.hasPrimaryKey());
             assertTrue(schema.isPrimaryKey(fieldName));
+            assertTrue(schema.hasIndex(fieldName));
             schema.removePrimaryKey();
             assertFalse(schema.hasPrimaryKey());
             assertFalse(schema.isPrimaryKey(fieldName));
+            assertFalse(schema.hasIndex(fieldName));
             schema.removeField(fieldName);
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index fa0d273082..644d3caa34 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -389,7 +389,7 @@ public void equals_afterModification() {
     }
 
     @Test
-    public void equals_standAloneObject() {
+    public void equals_unmanagedObject() {
         realm.beginTransaction();
         CyclicType ct1 = realm.createObject(CyclicType.class);
         ct1.setName("Foo");
@@ -625,15 +625,15 @@ public void setter_link_null() {
     }
 
     @Test
-    public void setter_link_standaloneObject() {
-        CyclicType standalone = new CyclicType();
+    public void setter_link_unmanagedObject() {
+        CyclicType unmanaged = new CyclicType();
 
         realm.beginTransaction();
         try {
             CyclicType target = realm.createObject(CyclicType.class);
 
             try {
-                target.setObject(standalone);
+                target.setObject(unmanaged);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -760,8 +760,8 @@ public void run() {
     }
 
     @Test
-    public void setter_list_withStandaloneObject() {
-        CyclicType standalone = new CyclicType();
+    public void setter_list_withUnmanagedObject() {
+        CyclicType unmanaged = new CyclicType();
 
         realm.beginTransaction();
         try {
@@ -769,7 +769,7 @@ public void setter_list_withStandaloneObject() {
 
             RealmList<CyclicType> list = new RealmList<>();
             list.add(realm.createObject(CyclicType.class));
-            list.add(standalone); // List contains a standalone object
+            list.add(unmanaged); // List contains an unmanaged object
             list.add(realm.createObject(CyclicType.class));
 
             try {
@@ -931,7 +931,7 @@ public void classNameConflictsWithFrameworkClass() {
     }
 
     @Test
-    public void isValid_standaloneObject() {
+    public void isValid_unmanagedObject() {
         AllTypes allTypes = new AllTypes();
         assertFalse(allTypes.isValid());
     }
@@ -1381,18 +1381,18 @@ public void execute(Realm realm) {
 
     @Test
     public void conflictingFieldName_readAndUpdate() {
-        final ConflictingFieldName standalone = new ConflictingFieldName();
-        standalone.setRealm("realm");
-        standalone.setRow("row");
-        standalone.setIsCompleted("isCompleted");
-        standalone.setListeners("listeners");
-        standalone.setPendingQuery("pendingQuery");
-        standalone.setCurrentTableVersion("currentTableVersion");
+        final ConflictingFieldName unmanaged = new ConflictingFieldName();
+        unmanaged.setRealm("realm");
+        unmanaged.setRow("row");
+        unmanaged.setIsCompleted("isCompleted");
+        unmanaged.setListeners("listeners");
+        unmanaged.setPendingQuery("pendingQuery");
+        unmanaged.setCurrentTableVersion("currentTableVersion");
 
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                realm.copyToRealm(standalone);
+                realm.copyToRealm(unmanaged);
             }
         });
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index af6f3f564a..3a31fc86b0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -1237,7 +1237,7 @@ public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
         childObj.setName("Child");
         childObj.setId(1);
 
-        // Parent object is a standalone object
+        // Parent object is an unmanaged object
         CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
         parentObj.setObject(childObj);
 
@@ -1503,7 +1503,7 @@ public void copyToRealmOrUpdate_cyclicObject() {
     }
 
 
-    // Checks that a standalone object with only default values can override data
+    // Checks that an unmanaged object with only default values can override data
     @Test
     public void copyToRealmOrUpdate_defaultValuesOverrideExistingData() {
         realm.executeTransaction(new Realm.Transaction() {
@@ -1884,20 +1884,9 @@ public void setter_updateField() throws Exception {
 
     @Test
     public void deleteRealm() throws InterruptedException {
-        File tempDir = new File(context.getFilesDir(), "delete_test_dir");
-        if (!tempDir.exists()) {
-            assertTrue(tempDir.mkdir());
-        }
-
-        assertTrue(tempDir.isDirectory());
-
-        // Delete all files in the directory
-        File[] files = tempDir.listFiles();
-        if (files != null) {
-            for (File file : files) {
-                assertTrue(file.delete());
-            }
-        }
+        File tempDir = new File(configFactory.getRoot(), "delete_test_dir");
+        File tempDirRenamed = new File(configFactory.getRoot(), "delete_test_dir_2");
+        assertTrue(tempDir.mkdir());
 
         final RealmConfiguration configuration = new RealmConfiguration.Builder(tempDir).build();
 
@@ -1922,14 +1911,15 @@ public void run() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
+        // A core upgrade might change the location of the files
+        assertTrue(tempDir.renameTo(tempDirRenamed));
         readyToCloseLatch.countDown();
+
         realm.close();
         closedLatch.await();
+        // Now we get log files back!
+        assertTrue(tempDirRenamed.renameTo(tempDir));
 
-        // ATTENTION: log, log_a, log_b will be deleted when the other thread close the Realm peacefully. And we force
-        // user to close all Realm instances before deleting. It would be difficult to simulate a case that log files
-        // exist before deletion. Let's keep the case like this for now, we might allow user to delete Realm even there
-        // are instances opened in the future.
         assertTrue(Realm.deleteRealm(configuration));
 
         // Directory should be empty now
@@ -1940,7 +1930,7 @@ public void run() {
     @Test
     public void callMutableMethodOutsideTransaction() throws JSONException, IOException {
 
-        // Prepare standalone object data
+        // Prepare unmanaged object data
         AllTypesPrimaryKey t = new AllTypesPrimaryKey();
         List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
 
@@ -2508,24 +2498,24 @@ public void copyFromRealm_invalidDepthThrows() {
     public void copyFromRealm() {
         populateTestRealm();
         AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
-        AllTypes standaloneObject = realm.copyFromRealm(realmObject);
-        assertArrayEquals(realmObject.getColumnBinary(), standaloneObject.getColumnBinary());
-        assertEquals(realmObject.getColumnString(), standaloneObject.getColumnString());
-        assertEquals(realmObject.getColumnLong(), standaloneObject.getColumnLong());
-        assertEquals(realmObject.getColumnFloat(), standaloneObject.getColumnFloat(), 0.00000000001);
-        assertEquals(realmObject.getColumnDouble(), standaloneObject.getColumnDouble(), 0.00000000001);
-        assertEquals(realmObject.isColumnBoolean(), standaloneObject.isColumnBoolean());
-        assertEquals(realmObject.getColumnDate(), standaloneObject.getColumnDate());
+        AllTypes unmanagedObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.getColumnBinary(), unmanagedObject.getColumnBinary());
+        assertEquals(realmObject.getColumnString(), unmanagedObject.getColumnString());
+        assertEquals(realmObject.getColumnLong(), unmanagedObject.getColumnLong());
+        assertEquals(realmObject.getColumnFloat(), unmanagedObject.getColumnFloat(), 0.00000000001);
+        assertEquals(realmObject.getColumnDouble(), unmanagedObject.getColumnDouble(), 0.00000000001);
+        assertEquals(realmObject.isColumnBoolean(), unmanagedObject.isColumnBoolean());
+        assertEquals(realmObject.getColumnDate(), unmanagedObject.getColumnDate());
     }
 
     @Test
     public void copyFromRealm_newCopyEachTime() {
         populateTestRealm();
         AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
-        AllTypes standaloneObject1 = realm.copyFromRealm(realmObject);
-        AllTypes standaloneObject2 = realm.copyFromRealm(realmObject);
-        assertFalse(standaloneObject1 == standaloneObject2);
-        assertNotSame(standaloneObject1, standaloneObject2);
+        AllTypes unmanagedObject1 = realm.copyFromRealm(realmObject);
+        AllTypes unmanagedObject2 = realm.copyFromRealm(realmObject);
+        assertFalse(unmanagedObject1 == unmanagedObject2);
+        assertNotSame(unmanagedObject1, unmanagedObject2);
     }
 
     // Test that the object graph is copied as it is and no extra copies are made
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index ba83afb0b2..9bb296b348 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -49,11 +49,7 @@ public void testTableToString() {
         t.add("s1", 1, true);
         t.add("s2", 2, false);
 
-        String expected =
-"    stringCol  intCol  boolCol\n" +
-"0:  s1              1     true\n" +
-"1:  s2              2    false\n" ;
-
+        String expected = "The Table contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
         assertEquals(expected, t.toString());
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
index 0f0631baa2..7244f5f252 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -451,4 +451,17 @@ public void primaryKeyTableMigratedWithRightName() throws IOException {
         }
         db.close();
     }
+
+    // Test if toString() returns a correct PrimaryKey field description from a Table
+    public void testTableToStringWithPrimaryKey() {
+        Table t = getTableWithStringPrimaryKey();
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
+
+        t.add("s1", 1, true);
+        t.add("s2", 2, false);
+
+        String expected = "The Table has 'colName' field as a PrimaryKey, and contains 3 columns: colName, intCol, boolCol. And 2 rows.";
+        assertEquals(expected, t.toString());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index fb058944aa..30e75077a3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -375,10 +375,7 @@ public void testViewToString() {
 
         TableView view = t.where().findAll();
 
-        String expected =
-                "    stringCol  intCol  boolCol\n" +
-                        "0:  s1              1     true\n" +
-                        "1:  s2              2    false\n" ;
+        String expected = "The TableView contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
 
         assertEquals(expected, view.toString());
     }
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index a3b1943b4e..07afb45826 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -167,8 +167,8 @@ public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listen
      * Returns an RxJava Observable that monitors changes to this Realm. It will emit the current state
      * when subscribed to. Items will continually be emitted as the Realm is updated -
      * {@code onComplete} will never be called.
-     *
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * <p>
+     * If you would like the {@code asObservable()} to stop emitting items, you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      *
      * <pre>
@@ -302,13 +302,13 @@ public void onCall() {
     }
 
     /**
-     * Starts a transaction, this must be closed with {@link io.realm.Realm#commitTransaction()} or aborted by
+     * Starts a transaction which must be closed by {@link io.realm.Realm#commitTransaction()} or aborted by
      * {@link io.realm.Realm#cancelTransaction()}. Transactions are used to atomically create, update and delete objects
      * within a Realm.
-     * <br>
-     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the realm in the case of
+     * <p>
+     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the Realm in the case of
      * pending updates from other threads.
-     * <br>
+     * <p>
      * Notice: it is not possible to nest transactions. If you start a transaction within a transaction an exception is
      * thrown.
      */
@@ -320,7 +320,7 @@ public void beginTransaction() {
     /**
      * All changes since {@link io.realm.Realm#beginTransaction()} are persisted to disk and the Realm reverts back to
      * being read-only. An event is sent to notify all other Realm instances that a change has occurred. When the event
-     * is received, the other Realms will get their objects and {@link io.realm.RealmResults} updated to reflect the
+     * is received, the other Realms will update their objects and {@link io.realm.RealmResults} to reflect the
      * changes from this commit.
      */
     public void commitTransaction() {
@@ -371,9 +371,9 @@ void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
     /**
      * Reverts all writes (created, updated, or deleted objects) made in the current write transaction and end the
      * transaction.
-     * <br>
+     * <p>
      * The Realm reverts back to read-only.
-     * <br>
+     * <p>
      * Calling this when not in a transaction will throw an exception.
      */
     public void cancelTransaction() {
@@ -593,6 +593,7 @@ static private boolean deletes(String canonicalPath, File rootFolder, String rea
         List<File> filesToDelete = Arrays.asList(
                 new File(rootFolder, realmFileName),
                 new File(rootFolder, realmFileName + ".lock"),
+                // Old core log file naming styles
                 new File(rootFolder, realmFileName + ".log_a"),
                 new File(rootFolder, realmFileName + ".log_b"),
                 new File(rootFolder, realmFileName + ".log"),
@@ -628,9 +629,19 @@ public void onResult(int count) {
                 File realmFolder = configuration.getRealmFolder();
                 String realmFileName = configuration.getRealmFileName();
                 File managementFolder = new File(realmFolder, realmFileName + management);
-                realmDeleted.set(deletes(realmFolder.getPath()+ "/" + realmFileName + management, managementFolder, realmFileName));
-                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
 
+                // delete files in management folder and the folder
+                // there is no subfolders in the management folder
+                File[] files = managementFolder.listFiles();
+                if (files != null) {
+                    for (File file : files) {
+                        realmDeleted.set(realmDeleted.get() && file.delete());
+                    }
+                }
+                realmDeleted.set(realmDeleted.get() && managementFolder.delete());
+
+                // delete specific files in root folder
+                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
             }
         });
 
@@ -639,6 +650,10 @@ public void onResult(int count) {
 
     /**
      * Compacts the Realm file defined by the given configuration.
+     *
+     * @param configuration configuration for the Realm to compact.
+     * @throw IllegalArgumentException if Realm is encrypted.
+     * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
         if (configuration.getEncryptionKey() != null) {
@@ -651,8 +666,8 @@ static boolean compactRealm(final RealmConfiguration configuration) {
     /**
      * Migrates the Realm file defined by the given configuration using the provided migration block.
      *
-     * @param configuration configuration for the Realm that should be migrated
-     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}
+     * @param configuration configuration for the Realm that should be migrated.
+     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
      * @param callback callback for specific Realm type behaviors.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 91abce6f35..ffd4bf796f 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -27,17 +27,17 @@
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
  * done using string based class names instead of class type references.
- *
+ * <p>
  * This is useful during migrations or when working with string-based data like CSV or XML files.
- *
+ * <p>
  * The same {@link io.realm.RealmConfiguration} can be used to open a Realm file in both dynamic and typed mode, but
  * modifying the schema while having both a typed and dynamic version open is highly discouraged and will most likely
  * crash the typed Realm. During migrations only a DynamicRealm will be open.
- *
+ * <p>
  * Dynamic Realms do not enforce schemas or schema versions and {@link RealmMigration} code is not used even if it has
  * been defined in the {@link RealmConfiguration}.
- *
- * This means that the schema is not created or validated until a Realm has been opened in typed mode, so if a Realm
+ * <p>
+ * This means that the schema is not created or validated until a Realm has been opened in typed mode. If a Realm
  * file is opened in dynamic mode first it will not contain any information about classes and fields, and any queries
  * for classes defined by the schema will fail.
  *
@@ -88,7 +88,7 @@ public DynamicRealmObject createObject(String className) {
      * @return the new object. All fields will have default values for their type, except for the
      * primary key field which will have the provided value.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expectd value.
      */
@@ -100,9 +100,9 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     }
 
     /**
-     * Returns a RealmQuery, which can be used to query for the provided class.
+     * Returns a RealmQuery, which can be used to query the provided class.
      *
-     * @param className The class of the object which is to be queried for.
+     * @param className the class of the object which is to be queried.
      * @return a RealmQuery, which can be used to query for specific objects of provided type.
      * @see io.realm.RealmQuery
      * @throws IllegalArgumentException if the class doesn't exist.
@@ -110,7 +110,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
         if (!sharedGroupManager.hasTable(Table.TABLE_PREFIX + className)) {
-            throw new IllegalArgumentException("Class does not exist in the Realm so it cannot be queried: " + className);
+            throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
     }
@@ -121,8 +121,8 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      * <p>
      * The listeners will be executed on every loop of a Handler thread if changes are committed by
      * this or another thread.
-     *
-     * Realm instances are cached pr. thread, so for that reason it is important to
+     * <p>
+     * Realm instances are cached per thread. For that reason it is important to
      * remember to remove listeners again either using {@link #removeChangeListener(RealmChangeListener)}
      * or {@link #removeAllChangeListeners()}. Not doing so can cause memory leaks.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index e9bab17c59..773ad0894f 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -49,7 +49,7 @@ public DynamicRealmObject(RealmModel obj) {
 
         if (!RealmObject.isValid(obj)) {
             throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
-                    "is a standalone object or it was deleted.");
+                    "is an unmanaged object or it was deleted.");
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) obj;
@@ -102,12 +102,13 @@ public DynamicRealmObject(RealmModel obj) {
 
     /**
      * Returns the {@code boolean} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the boolean value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain booleans.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain booleans.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public boolean getBoolean(String fieldName) {
@@ -117,12 +118,13 @@ public boolean getBoolean(String fieldName) {
 
     /**
      * Returns the {@code int} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the int value. Integer values exceeding {@code Integer.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public int getInt(String fieldName) {
@@ -131,12 +133,13 @@ public int getInt(String fieldName) {
 
     /**
      * Returns the {@code short} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the short value. Integer values exceeding {@code Short.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public short getShort(String fieldName) {
@@ -145,12 +148,13 @@ public short getShort(String fieldName) {
 
     /**
      * Returns the {@code long} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the long value. Integer values exceeding {@code Long.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public long getLong(String fieldName) {
@@ -160,12 +164,13 @@ public long getLong(String fieldName) {
 
     /**
      * Returns the {@code byte} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the byte value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public byte getByte(String fieldName) {
@@ -175,12 +180,13 @@ public byte getByte(String fieldName) {
 
     /**
      * Returns the {@code float} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the float value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain floats.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain floats.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public float getFloat(String fieldName) {
@@ -190,12 +196,13 @@ public float getFloat(String fieldName) {
 
     /**
      * Returns the {@code double} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the double value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain doubles.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain doubles.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public double getDouble(String fieldName) {
@@ -208,7 +215,7 @@ public double getDouble(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the byte[] value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain binary data.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain binary data.
      */
     public byte[] getBlob(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -220,7 +227,7 @@ public double getDouble(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the String value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Strings.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Strings.
      */
     public String getString(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -232,7 +239,7 @@ public String getString(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the Date value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Dates.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Dates.
      */
     public Date getDate(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -248,7 +255,7 @@ public Date getDate(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the {@link DynamicRealmObject} representation of the linked object or {@code null} if no object is linked.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain links to other objects.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain links to other objects.
      */
     public DynamicRealmObject getObject(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -266,7 +273,7 @@ public DynamicRealmObject getObject(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the {@link RealmList} data for this field.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain a list of links.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of links.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -280,7 +287,7 @@ public DynamicRealmObject getObject(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return {@code true} if field value is null, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exists.
+     * @throws IllegalArgumentException if field name doesn't exist.
      */
     public boolean isNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -332,13 +339,13 @@ public boolean hasField(String fieldName) {
     }
 
     /**
-     * Set the value for the given field. This method will automatically try to convert numbers and
-     * booleans that are given as {@code String} to their appropriate type. E.g. {@code "10"} will be
-     * converted to {@code 10} if the field type is {@code int}.
-     *
+     * Sets the value for the given field. This method will automatically try to convert numbers and
+     * booleans that are given as {@code String} to their appropriate type. For example {@code "10"} 
+     * will be converted to {@code 10} if the field type is {@code int}.
+     * <p>
      * Using the typed setters will be faster than using this method.
-     *
-     * @throws IllegalArgumentException if field name doesn't exists or if the input value cannot be converted
+     * 
+     * @throws IllegalArgumentException if field name doesn't exist or if the input value cannot be converted
      * to the appropriate input type.
      * @throws NumberFormatException if a String based number cannot be converted properly.
      */
@@ -410,7 +417,7 @@ private void setValue(String fieldName, Object value) {
      *
      * @param fieldName field name to update.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a boolean field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a boolean field.
      */
     public void setBoolean(String fieldName, boolean value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -422,7 +429,7 @@ public void setBoolean(String fieldName, boolean value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setShort(String fieldName, short value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -434,7 +441,7 @@ public void setShort(String fieldName, short value) {
      *
      * @param fieldName field name to update.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setInt(String fieldName, int value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -446,7 +453,7 @@ public void setInt(String fieldName, int value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setLong(String fieldName, long value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -458,7 +465,7 @@ public void setLong(String fieldName, long value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setByte(String fieldName, byte value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -470,7 +477,7 @@ public void setByte(String fieldName, byte value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a float field.
      */
     public void setFloat(String fieldName, float value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -482,7 +489,7 @@ public void setFloat(String fieldName, float value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a double field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a double field.
      */
     public void setDouble(String fieldName, double value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -494,7 +501,7 @@ public void setDouble(String fieldName, double value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a String field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a String field.
      */
     public void setString(String fieldName, String value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -506,7 +513,7 @@ public void setString(String fieldName, String value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a binary field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a binary field.
      */
     public void setBlob(String fieldName, byte[] value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -518,7 +525,7 @@ public void setBlob(String fieldName, byte[] value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a Date field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a Date field.
      */
     public void setDate(String fieldName, Date value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -534,7 +541,7 @@ public void setDate(String fieldName, Date value) {
      *
      * @param fieldName field name.
      * @param value object to link to.
-     * @throws IllegalArgumentException if field name doesn't exists, it doesn't link to other Realm objects, the type
+     * @throws IllegalArgumentException if field name doesn't exist, it doesn't link to other Realm objects, the type
      * of DynamicRealmObject doesn't match or it belongs to a different Realm.
      */
     public void setObject(String fieldName, DynamicRealmObject value) {
@@ -575,7 +582,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
         String tableName = proxyState.getRow$realm().getTable().getName();
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
-            // Standalone lists don't know anything about the types they contain. They might even hold objects of
+            // Unmanaged lists don't know anything about the types they contain. They might even hold objects of
             // multiple types :(, so we have to check each item in the list.
             typeValidated = false;
         } else {
@@ -609,7 +616,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
      * Sets the value to {@code null} for the given field.
      *
      * @param fieldName field name.
-     * @throws IllegalArgumentException if field name doesn't exists, or the field isn't nullable.
+     * @throws IllegalArgumentException if field name doesn't exist, or the field isn't nullable.
      */
     public void setNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -622,7 +629,7 @@ public void setNull(String fieldName) {
     }
 
     /**
-     * Return the type of object. This will normally correspond to the name of a class that is extending
+     * Returns the type of object. This will normally correspond to the name of a class that is extending
      * {@link RealmObject}.
      *
      * @return this objects type.
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 6ef77f81dd..d202599e34 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -149,7 +149,8 @@ void addChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
 
     /**
      * For internal use only.
-     * Sometimes we don't know when to unregister listeners (ex: {@code RealmBaseAdapter}). Using
+     * <p>
+     * Sometimes we don't know when to unregister listeners (e.g., {@code RealmBaseAdapter}). Using
      * a WeakReference the listener doesn't need to be explicitly unregistered.
      *
      * @param listener the change listener.
@@ -600,10 +601,10 @@ private boolean threadContainsAsyncQueries() {
     }
 
     /**
-     * Indicate the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}
-     * empty means no pointer to a valid Row. This will help to caller to decice when to rerun the query.
+     * Indicates the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}.
+     * Empty means no pointer to a valid Row. This will help caller to decide when to rerun the query.
      *
-     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject} {@code false} otherwise.
+     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject}, {@code false} otherwise.
      */
     boolean threadContainsAsyncEmptyRealmObject() {
         boolean isEmpty = true;
@@ -675,11 +676,11 @@ void addToEmptyAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakR
     }
 
     /**
-     * Refreshes all synchronous RealmResults by calling `sync_if_needed` on them. This will cause any backing queries
-     * to be rerun and any deleted objects will be removed from the TableView.
-     *
+     * Refreshes all synchronous RealmResults by calling {@code sync_if_needed} on them. This will cause any backing queries
+     * to rerun and any deleted objects will be removed from the TableView.
+     * <p>
      * WARNING: This will _NOT_ refresh TableViews created from async queries.
-     *
+     * <p>
      * Note this will _not_ notify any registered listeners.
      */
     public void refreshSynchronousTableViews() {
@@ -707,7 +708,7 @@ public boolean isAutoRefreshEnabled() {
     }
 
     /**
-     * Notify the current thread that the Realm has changed. This will also trigger change listener asynchronously.
+     * Notifies the current thread that the Realm has changed. This will also trigger change listener asynchronously.
      */
     public void notifyCurrentThreadRealmChanged() {
         if (realm != null) {
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index f594bdd85a..29376bff76 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -50,7 +50,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or it has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName);
 
@@ -63,7 +63,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName, Sort sortOrder);
 
@@ -79,7 +79,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2);
 
@@ -92,7 +92,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders);
 
@@ -102,7 +102,7 @@
      * @param location the array index identifying the object to be removed.
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     void deleteFromRealm(int location);
 
@@ -111,7 +111,7 @@
      *
      * @return {@code true} if an object was deleted, {@code false} otherwise.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called on the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteFirstFromRealm();
 
@@ -120,7 +120,7 @@
      *
      * @return {@code true} if an object was deleted, {@code false} otherwise.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteLastFromRealm();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index e65203f8d6..fd62a7a6f7 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -71,7 +71,7 @@
  * Realm and should be considered a lightweight operation.
  * <p>
  * For the UI thread this means that opening and closing Realms should occur in either onCreate/onDestroy or
- *  onStart/onStop.
+ * onStart/onStop.
  * <p>
  * Realm instances coordinate their state across threads using the {@link android.os.Handler} mechanism. This also means
  * that Realm instances on threads without a {@link android.os.Looper} cannot receive updates unless {@link #waitForChange()}
@@ -218,7 +218,7 @@ public static void removeDefaultConfiguration() {
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
      * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param columnIndices if this is not  {@code null} value, the {@link BaseRealm#schema#columnIndices} will be
+     * @param columnIndices if this is not  {@code null}, the {@link BaseRealm#schema#columnIndices} will be
      *                      initialized to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from
      *                      the Realm file.
      * @return a {@link Realm} instance.
@@ -313,8 +313,9 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the RealmObject
+     * <p>
+     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject}
      * field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
@@ -365,7 +366,7 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
      * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
      * will be set to the default value for that type.
      *
@@ -420,7 +421,7 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * JSON properties with {@code null} value will map to the default value for the data type in Realm and unknown properties
      * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
      * will be set to the default value for that type.
      *
@@ -488,13 +489,13 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
-     * @return created object or null if no json data was provided.
+     * @return created object or {@code null} if no JSON data was provided.
      * @throws RealmException if the mapping from JSON fails.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
@@ -539,13 +540,13 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
-     * @return created object or null if json string was empty or null.
+     * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if mapping to json failed.
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
@@ -596,15 +597,15 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} value will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
-     * @return created object or null if json string was empty or null.
+     * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if the mapping from JSON failed.
-     * @throws IOException if something was wrong with the input stream.
+     * @throws IOException if something went wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
@@ -685,9 +686,9 @@ private Scanner getFullStringScanner(InputStream in) {
     /**
      * Instantiates and adds a new object to the Realm.
      *
-     * @param clazz the Class of the object to create
-     * @return the new object
-     * @throws RealmException if an object could not be created
+     * @param clazz the Class of the object to create.
+     * @return the new object.
+     * @throws RealmException if an object cannot be created.
      */
     public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
@@ -698,7 +699,7 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Instantiates and adds a new object to the Realm with the primary key value already set.
-     *
+     * <p>
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
      *
@@ -706,7 +707,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expected value.
      */
@@ -720,8 +721,8 @@ private Scanner getFullStringScanner(InputStream in) {
      * Copies a RealmObject to the Realm instance and returns the copy. Any further changes to the original RealmObject
      * will not be reflected in the Realm copy. This is a deep copy, so all referenced objects will be copied. Objects
      * already in this Realm will be ignored.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in this and child objects will be
      * set to their default value if not provided.
      *
      * @param object the {@link io.realm.RealmObject} to copy to the Realm.
@@ -736,10 +737,10 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or creates
-     * a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects will be
+     * a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects will be
      * either copied or updated.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the object and child objects will be
      * set to their default value if not provided.
      *
      * @param object {@link io.realm.RealmObject} to copy or update.
@@ -756,10 +757,10 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Copies a collection of RealmObjects to the Realm instance and returns their copy. Any further changes to the
-     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy, so all referenced objects
+     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy i.e., all referenced objects
      * will be copied. Objects already in this Realm will be ignored.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
      *
      * @param objects the RealmObjects to copy to the Realm.
@@ -782,10 +783,10 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
-     * creates a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects
+     * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects
      * will be either copied or updated.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
      *
      * @param objects a list of objects to update or copy into Realm.
@@ -807,17 +808,17 @@ private Scanner getFullStringScanner(InputStream in) {
     }
 
     /**
-     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * Makes an unmanaged in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
      * referenced objects.
-     *
-     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmModel)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects,
      * and can potentially override changes made by other threads.
      *
-     * @param realmObjects RealmObjects to copy
+     * @param realmObjects RealmObjects to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of managed RealmObjects.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
@@ -828,12 +829,12 @@ private Scanner getFullStringScanner(InputStream in) {
     }
 
     /**
-     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * Makes an unmanaged in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
      * referenced objects up to the defined depth.
-     *
-     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(Iterable)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects
      * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
@@ -854,28 +855,28 @@ private Scanner getFullStringScanner(InputStream in) {
             return new ArrayList<E>(0);
         }
 
-        ArrayList<E> standaloneObjects = new ArrayList<E>();
+        ArrayList<E> unmanagedObjects = new ArrayList<E>();
         Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
-            standaloneObjects.add(createDetachedCopy(object, maxDepth, listCache));
+            unmanagedObjects.add(createDetachedCopy(object, maxDepth, listCache));
         }
 
-        return standaloneObjects;
+        return unmanagedObjects;
     }
 
     /**
-     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * Makes an unmanaged in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
      * all referenced objects.
-     *
-     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using 
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
      *
-     * @param realmObject {@link RealmObject} to copy
+     * @param realmObject {@link RealmObject} to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
@@ -886,18 +887,18 @@ private Scanner getFullStringScanner(InputStream in) {
     }
 
     /**
-     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * Makes an unmanaged in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
      * all referenced objects up to the defined depth.
-     *
-     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using 
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed. 
      * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being 
      * reached. This can also potentially override changes made by other threads.
      *
-     * @param realmObject {@link RealmObject} to copy
+     * @param realmObject {@link RealmObject} to copy.
      * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
      * {@code 0}.
      * @param <E> type of object.
@@ -929,8 +930,8 @@ private Scanner getFullStringScanner(InputStream in) {
      * <p>
      * The listeners will be executed on every loop of a Handler thread if
      * the current thread or other threads committed changes to the Realm.
-     *
-     * Realm instances are per-thread singletons and cached, so listeners should be
+     * <p>
+     * Realm instances are per thread singletons and cached, so listeners should be
      * removed manually even if calling {@link #close()}. Otherwise there is a
      * risk of memory leaks.
      *
@@ -1005,7 +1006,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * Similar to {@link #executeTransactionAsync(Transaction)}, but also accepts an OnError callback.
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @param onError callback invoked when the transaction failed.
+     * @param onError callback invoked when the transaction fails.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
@@ -1023,7 +1024,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @param onSuccess callback invoked when the transaction succeeds.
-     * @param onError callback invoked when the transaction failed.
+     * @param onError callback invoked when the transaction fails.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
@@ -1226,7 +1227,7 @@ public void migrationComplete() {
 
     /**
      * Deletes the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
-     * The Realm must be unused and closed before calling this method.
+     * All Realm instances must be closed before calling this method.
      *
      * @param configuration a {@link RealmConfiguration}.
      * @return {@code false} if a file could not be deleted. The failing file will be logged.
@@ -1276,7 +1277,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
      * Returns the default Realm module. This module contains all Realm classes in the current project, but not those
      * from library or project dependencies. Realm classes in these should be exposed using their own module.
      *
-     * @return the default Realm module or null if no default module exists.
+     * @return the default Realm module or {@code null} if no default module exists.
      * @throws RealmException if unable to create an instance of the module.
      * @see io.realm.RealmConfiguration.Builder#modules(Object, Object...)
      */
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 35b554dc21..824f7fb7ed 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -15,11 +15,16 @@
  */
 package io.realm;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.Map;
 
+import io.realm.exceptions.RealmIOException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.log.RealmLog;
 
@@ -102,6 +107,8 @@ private RealmCache(RealmConfiguration config) {
             cache = new RealmCache(configuration);
             // The new cache should be added to the map later.
             isCacheInMap = false;
+
+            copyAssetFileIfNeeded(configuration);
         } else {
             // Throw the exception if validation failed.
             cache.validateConfiguration(configuration);
@@ -113,6 +120,7 @@ private RealmCache(RealmConfiguration config) {
             // Create a new local Realm instance
             BaseRealm realm;
 
+
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
                 realm = Realm.createInstance(configuration, cache.typedColumnIndices);
@@ -266,7 +274,7 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
         callback.onResult(totalRefCount);
     }
 
-    /**
+   /**
      * Runs the callback function with synchronization on {@class RealmCache}.
      *
      * @param callback the callback will be executed.
@@ -274,4 +282,53 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
     static synchronized void invokeWithLock(Callback0 callback) {
         callback.onCall();
     }
+
+    /**
+     * Copies Realm database file from Android asset directory to the directory given in the {@link RealmConfiguration}.
+     * Copy is performed only at the first time when there is no Realm database file.
+     *
+     * @param configuration configuration object for Realm instance.
+     * @throws IOException if copying the file fails.
+     */
+    private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
+        if (configuration.hasAssetFile()) {
+            File realmFile = new File(configuration.getRealmFolder(), configuration.getRealmFileName());
+            if (realmFile.exists()) {
+                return;
+            }
+
+            InputStream inputStream = null;
+            FileOutputStream outputStream = null;
+            try {
+                inputStream = configuration.getAssetFile();
+                if (inputStream == null) {
+                    throw new RealmIOException("Invalid input stream to asset file.");
+                }
+
+                outputStream = new FileOutputStream(realmFile);
+                byte[] buf = new byte[4096];
+                int bytesRead;
+                while ((bytesRead = inputStream.read(buf)) > -1) {
+                    outputStream.write(buf, 0, bytesRead);
+                }
+            } catch (IOException e) {
+                throw new RealmIOException("Could not resolve the path to the Realm asset file.", e);
+            } finally {
+                if (inputStream != null) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException e) {
+                        // Ignore this exception because any significant errors should already have been handled
+                    }
+                }
+                if (outputStream != null) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException e) {
+                        throw new RealmIOException("Invalid output stream to " + realmFile.getPath(), e);
+                    }
+                }
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
index 00be5c6f83..2e8e7ff7c1 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -22,10 +22,8 @@
  * <p>
  * When registered against a {@code Realm} you'll get notified when a Realm instance has been updated.
  * Register against a {@code RealmResults} or {@code RealmObject} to only get notified about changes to them.
- *
  * <p>
  * Realm instances on a thread without an {@link android.os.Looper} cannot register a RealmChangeListener.
- *
  * <p>
  * All {@link io.realm.RealmObject} and {@link io.realm.RealmResults} will automatically contain their new values when
  * the {@link #onChange(Object)} method is called. Normally this means that it isn't necessary to query again for those
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 7c4328c8d8..6278272dc2 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -24,7 +24,7 @@
 /**
  * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
  * collections and the behavior that they will have in all implementations of {@code RealmCollection}s.
- *
+ * <p>
  * Realm collections are "live" views to the underlying data. This means that they automatically will be kept up to
  * date. As a consequence, using methods like {@link Collections#unmodifiableCollection(Collection)} will not prevent
  * a collection from being modified.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 6b978ecc78..a398f90992 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -17,8 +17,12 @@
 package io.realm;
 
 import android.content.Context;
+import android.text.TextUtils;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
@@ -38,21 +42,23 @@
 
 /**
  * A RealmConfiguration is used to setup a specific Realm instance.
- *
+ * <p>
  * Instances of a RealmConfiguration can only created by using the {@link io.realm.RealmConfiguration.Builder} and calling
  * its {@link io.realm.RealmConfiguration.Builder#build()} method.
- *
+ * <p>
  * A commonly used RealmConfiguration can easily be accessed by first saving it as
  * {@link Realm#setDefaultConfiguration(RealmConfiguration)} and then using {@link io.realm.Realm#getDefaultInstance()}.
- *
+ * <p>
  * A minimal configuration can be created using:
- *
+ * <p>
  * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
- *
+ * <p>
  * This will create a RealmConfiguration with the following properties.
- * - Realm file is called "default.realm"
- * - It is saved in Context.getFilesDir()
- * - It has its schema version set to 0.
+ * <ul>
+ * <li>Realm file is called "default.realm"</li>
+ * <li>It is saved in Context.getFilesDir()</li>
+ * <li>It has its schema version set to 0.</li>
+ * </ul>
  */
 public final class RealmConfiguration {
 
@@ -81,6 +87,7 @@
     private final File realmFolder;
     private final String realmFileName;
     private final String canonicalPath;
+    private final String assetFilePath;
     private final byte[] key;
     private final long schemaVersion;
     private final RealmMigration migration;
@@ -89,11 +96,13 @@
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
+    private final WeakReference<Context> contextWeakRef;
 
     private RealmConfiguration(Builder builder) {
         this.realmFolder = builder.folder;
         this.realmFileName = builder.fileName;
         this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
+        this.assetFilePath = builder.assetFilePath;
         this.key = builder.key;
         this.schemaVersion = builder.schemaVersion;
         this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
@@ -102,6 +111,7 @@ private RealmConfiguration(Builder builder) {
         this.schemaMediator = createSchemaMediator(builder);
         this.rxObservableFactory = builder.rxFactory;
         this.initialDataTransaction = builder.initialDataTransaction;
+        this.contextWeakRef = builder.contextWeakRef;
     }
 
     public File getRealmFolder() {
@@ -150,6 +160,30 @@ RealmProxyMediator getSchemaMediator() {
         return initialDataTransaction;
     }
 
+    /**
+     * Indicates if there is available asset file for copy action.
+     *
+     * @return {@code true} if there is asset file, {@code false} otherwise.
+     */
+    boolean hasAssetFile() {
+        return !TextUtils.isEmpty(assetFilePath);
+    }
+
+    /**
+     * Returns input stream object to the Realm asset file.
+     *
+     * @return input stream to the asset file.
+     * @throws IOException if copying the file fails.
+     */
+    InputStream getAssetFile() throws IOException {
+        Context context = contextWeakRef.get();
+        if (context != null) {
+            return context.getAssets().open(assetFilePath);
+        } else {
+            throw new IllegalArgumentException("Context should not be null. Use Application Context instead of Activity Context.");
+        }
+    }
+
     /**
      * Returns the unmodifiable {@link Set} of model classes that make up the schema for this Realm.
      *
@@ -294,7 +328,7 @@ public String toString() {
     /**
      * Checks if RxJava is can be loaded.
      *
-     * @return true if RxJava dependency exist.
+     * @return {@code true} if RxJava dependency exist, {@code false} otherwise.
      */
     private static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
@@ -314,6 +348,7 @@ private static synchronized boolean isRxJavaAvailable() {
     public static final class Builder {
         private File folder;
         private String fileName;
+        private String assetFilePath;
         private byte[] key;
         private long schemaVersion;
         private RealmMigration migration;
@@ -321,6 +356,7 @@ private static synchronized boolean isRxJavaAvailable() {
         private SharedGroup.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
+        private WeakReference<Context> contextWeakRef;
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
 
@@ -328,8 +364,8 @@ private static synchronized boolean isRxJavaAvailable() {
          * Creates an instance of the Builder for the RealmConfiguration.
          * The Realm file will be saved in the provided folder.
          *
-         * @param folder Folder to save Realm file in. Folder must be writable.
-         * @throws IllegalArgumentException if folder doesn't exists or isn't writable.
+         * @param folder the folder to save Realm file in. Folder must be writable.
+         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
          */
         public Builder(File folder) {
             RealmCore.loadLibrary();
@@ -338,12 +374,12 @@ public Builder(File folder) {
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
-         *
-         * This will use the apps own internal directory for storing the Realm file. This does not require any
+         * <p>
+         * This will use the app's own internal directory for storing the Realm file. This does not require any
          * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
          * change depending on vendor implementations of Android.
          *
-         * @param context Android context.
+         * @param context an Android context.
          */
         public Builder(Context context) {
             if (context == null) {
@@ -405,7 +441,7 @@ public Builder encryptionKey(byte[] key) {
         /**
          * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
          * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
-         *
+         * <p>
          * If no migration code is provided, Realm will throw a
          * {@link io.realm.exceptions.RealmMigrationNeededException}.
          *
@@ -453,20 +489,25 @@ public Builder deleteRealmIfMigrationNeeded() {
          * reference to the in-memory Realm object with the specific name as long as you want the data to last.
          */
         public Builder inMemory() {
+            if (!TextUtils.isEmpty(assetFilePath)) {
+                throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
+            }
+
             this.durability = SharedGroup.Durability.MEM_ONLY;
+
             return this;
         }
 
         /**
          * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
          * current schema for this Realm with the schema defined by the provided modules.
-         *
+         * <p>
          * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
          * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
          * dependency is thus done using the following code:
-         *
+         * <p>
          * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
-         *
+         * <p>
          * @param baseModule the first Realm module (required).
          * @param additionalModules the additional Realm modules
          * @throws IllegalArgumentException if any of the modules doesn't have the {@link RealmModule} annotation.
@@ -506,6 +547,34 @@ public Builder initialData(Realm.Transaction transaction) {
             return this;
         }
 
+        /**
+         * Copies the Realm file from the given asset file path.
+         * <p>
+         * When opening the Realm for the first time, instead of creating an empty file,
+         * the Realm file will be copied from the provided assets file and used instead.
+         * <p>
+         * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
+         *
+         * @param context Android application context.
+         * @param assetFile path to the asset database file.
+         */
+        public Builder assetFile(Context context, final String assetFile) {
+            if (context == null) {
+                throw new IllegalArgumentException("A non-null Context must be provided");
+            }
+            if (TextUtils.isEmpty(assetFile)) {
+                throw new IllegalArgumentException("A non-empty asset file path must be provided");
+            }
+            if (durability == SharedGroup.Durability.MEM_ONLY) {
+                throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
+            }
+
+            this.contextWeakRef = new WeakReference<>(context);
+            this.assetFilePath = assetFile;
+
+            return this;
+        }
+
         private void addModule(Object module) {
             if (module != null) {
                 checkModule(module);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index ac3f1e6af3..7bff1ed043 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -23,7 +23,7 @@
 
 /**
  * List of the types used by Realm's underlying storage engine.
- *
+ * <p>
  * Normally there is no reason to interact with the underlying Realm types as Realm will automatically
  * convert between normal Java types and the Realm types. However it is possible to access these
  * types through a {@link DynamicRealmObject}.
@@ -64,7 +64,7 @@
     /**
      * Returns the native value representing this type.
      *
-     * @return The value used by the underlying storage engine to represent this type.
+     * @return the value used by the underlying storage engine to represent this type.
      */
     public int getNativeValue() {
         return nativeValue;
@@ -72,7 +72,7 @@ public int getNativeValue() {
 
     /**
      * Checks if the given Java object can be converted to the underlying Realm type.
-     * @param obj Object to test compatibility on.
+     * @param obj object to test compatibility on.
      * @return {@code true} if object can be converted to the Realm type, {@code false} otherwise.
      */
     public boolean isValid(Object obj) {
@@ -104,8 +104,8 @@ public boolean isValid(Object obj) {
     /**
      * Converts the underlying value used by the storage engine to the proper Realm type.
      *
-     * @param value Value to convert
-     * @return The corresponding Realm type.
+     * @param value the value to convert
+     * @return the corresponding Realm type.
      * @throws IllegalArgumentException if value isn't valid.
      */
     public static RealmFieldType fromNativeValue(int value) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index c7d66424d0..ee9e96291a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -39,9 +39,9 @@
  * Only Realm can create managed RealmLists. Managed RealmLists will automatically update the content whenever the
  * underlying Realm is updated, and can only be accessed using the getter of a {@link io.realm.RealmObject}.
  * <p>
- * Non-managed RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
+ * Unmanaged RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
  * useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class.
- * Non-managed elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
+ * Unmanaged elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
  * <p>
  * {@link RealmList} can contain more elements than {@code Integer.MAX_VALUE}.
  * In that case, you can access only first {@code Integer.MAX_VALUE} elements in it.
@@ -60,25 +60,25 @@
     protected String className;
     protected LinkView view;
     protected BaseRealm realm;
-    private List<E> nonManagedList;
+    private List<E> unmanagedList;
 
     /**
      * Creates a RealmList in non-managed mode, where the elements are not controlled by a Realm.
      * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible to query
      * the objects in this state.
      * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist it's elements in Realm.
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
      */
     public RealmList() {
         managedMode = false;
-        nonManagedList = new ArrayList<E>();
+        unmanagedList = new ArrayList<E>();
     }
 
     /**
      * Creates a RealmList in non-managed mode with an initial list of elements.
      * A RealmList in non-managed mode function as a {@link java.util.ArrayList} and it is not possible to query the
      * objects in this state.
-     *
+     * <p>
      * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all non-managed elements in Realm.
      *
      * @param objects initial objects in the list.
@@ -88,16 +88,16 @@ public RealmList(E... objects) {
             throw new IllegalArgumentException("The objects argument cannot be null");
         }
         managedMode = false;
-        nonManagedList = new ArrayList<E>(objects.length);
-        Collections.addAll(nonManagedList, objects);
+        unmanagedList = new ArrayList<E>(objects.length);
+        Collections.addAll(unmanagedList, objects);
     }
 
     /**
      * Creates a RealmList from a LinkView, so its elements are managed by Realm.
      *
-     * @param clazz type of elements in the Array
-     * @param linkView  backing LinkView
-     * @param realm reference to Realm containing the data
+     * @param clazz type of elements in the Array.
+     * @param linkView  backing LinkView.
+     * @param realm reference to Realm containing the data.
      */
     RealmList(Class<E> clazz, LinkView linkView, BaseRealm realm) {
         this.managedMode = true;
@@ -114,10 +114,10 @@ public RealmList(E... objects) {
     }
 
     /**
-     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e. the {@link io.realm.Realm}
+     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e., the {@link io.realm.Realm}
      * instance hasn't been closed.
      *
-     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an un-managed list.
+     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an unmanaged list.
      */
     public boolean isValid() {
         //noinspection SimplifiableIfStatement
@@ -136,11 +136,11 @@ private boolean isAttached() {
      * element at the specified location. If the location is equal to the size of this List, the object is added at the
      * end.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
@@ -161,7 +161,7 @@ public void add(int location, E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.insert(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
-            nonManagedList.add(location, object);
+            unmanagedList.add(location, object);
         }
         modCount++;
     }
@@ -169,17 +169,17 @@ public void add(int location, E object) {
     /**
      * Adds the specified object at the end of this List.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
      *
      * @param object the object to add.
-     * @return always true
+     * @return always {@code true}.
      * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
      */
     @Override
@@ -190,7 +190,7 @@ public boolean add(E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.add(proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
-            nonManagedList.add(object);
+            unmanagedList.add(object);
         }
         modCount++;
         return true;
@@ -199,11 +199,11 @@ public boolean add(E object) {
     /**
      * Replaces the element at the specified location in this list with the specified object.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed.
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed.
      * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
      * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
@@ -224,12 +224,12 @@ public E set(int location, E object) {
             view.set(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
             return oldObject;
         } else {
-            oldObject = nonManagedList.set(location, object);
+            oldObject = unmanagedList.set(location, object);
         }
         return oldObject;
     }
 
-    // Transparently copies a standalone object or managed object from another Realm to the Realm backing this RealmList.
+    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
     private E copyToRealmIfNeeded(E object) {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
@@ -276,7 +276,7 @@ private E copyToRealmIfNeeded(E object) {
 
     /**
      * Moves an object from one position to another, while maintaining a fixed sized list.
-     * RealmObjects will be shifted so no null values are introduced.
+     * RealmObjects will be shifted so no {@code null} values are introduced.
      *
      * @param oldPos index of RealmObject to move.
      * @param newPos target position. If newPos &lt; oldPos the object at the location will be shifted to the right. If
@@ -291,11 +291,11 @@ public void move(int oldPos, int newPos) {
         } else {
             checkIndex(oldPos);
             checkIndex(newPos);
-            E object = nonManagedList.remove(oldPos);
+            E object = unmanagedList.remove(oldPos);
             if (newPos > oldPos) {
-                nonManagedList.add(newPos - 1, object);
+                unmanagedList.add(newPos - 1, object);
             } else {
-                nonManagedList.add(newPos, object);
+                unmanagedList.add(newPos, object);
             }
         }
     }
@@ -314,7 +314,7 @@ public void clear() {
             checkValidView();
             view.clear();
         } else {
-            nonManagedList.clear();
+            unmanagedList.clear();
         }
         modCount++;
     }
@@ -335,7 +335,7 @@ public E remove(int location) {
             removedItem = get(location);
             view.remove(location);
         } else {
-            removedItem = nonManagedList.remove(location);
+            removedItem = unmanagedList.remove(location);
         }
         modCount++;
         return removedItem;
@@ -343,8 +343,8 @@ public E remove(int location) {
 
     /**
      * Removes one instance of the specified object from this {@code Collection} if one
-     * is contained . This implementation iterates over this
-     * {@code Collection} and tests for each element {@code e} returned by the iterator,
+     * is contained. This implementation iterates over this
+     * {@code Collection} and tests each element {@code e} returned by the iterator,
      * whether {@code e} is equal to the given object. If {@code object != null}
      * then this test is performed using {@code object.equals(e)}, otherwise
      * using {@code object == null}. If an element equal to the given object is
@@ -372,7 +372,7 @@ public boolean remove(Object object) {
      * elements in the passed {@code Collection} can be found in this {@code Collection}
      * anymore.
      * <p>
-     * This implementation iterates over this {@code Collection} and tests for each
+     * This implementation iterates over the {@code Collection} and tests each
      * element {@code e} returned by the iterator, whether it is contained in
      * the specified {@code Collection}. If this test is positive, then the {@code
      * remove} method is called on the iterator.
@@ -441,15 +441,12 @@ public E get(int location) {
             long rowIndex = view.getTargetRowIndex(location);
             return realm.get(clazz, className, rowIndex);
         } else {
-            return nonManagedList.get(location);
+            return unmanagedList.get(location);
         }
     }
 
     /**
-     * Finds the first object.
-     *
-     * @return the first object or {@code null} if the list is empty.
-     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * {@inheritDoc}
      */
     public E first() {
         if (managedMode) {
@@ -457,17 +454,14 @@ public E first() {
             if (!view.isEmpty()) {
                 return get(0);
             }
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(0);
+        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+            return unmanagedList.get(0);
         }
         throw new IndexOutOfBoundsException("The list is empty.");
     }
 
     /**
-     * Finds the last object.
-     *
-     * @return the last object or {@code null} if the list is empty.
-     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * {@inheritDoc}
      */
     public E last() {
         if (managedMode) {
@@ -475,8 +469,8 @@ public E last() {
             if (!view.isEmpty()) {
                 return get((int) view.size() - 1);
             }
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(nonManagedList.size() - 1);
+        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+            return unmanagedList.get(unmanagedList.size() - 1);
         }
         throw new IndexOutOfBoundsException("The list is empty.");
     }
@@ -548,7 +542,7 @@ public int size() {
             long size = view.size();
             return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
         } else {
-            return nonManagedList.size();
+            return unmanagedList.size();
         }
     }
 
@@ -664,7 +658,7 @@ public boolean deleteAllFromRealm() {
      */
     @Override
     public boolean isLoaded() {
-        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+        return true; // Managed RealmLists are always loaded, Unmanaged RealmLists return true pr. the contract.
     }
 
     /**
@@ -672,14 +666,14 @@ public boolean isLoaded() {
      */
     @Override
     public boolean load() {
-        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+        return true; // Managed RealmLists are always loaded, Unmanaged RealmLists return true pr. the contract.
     }
 
     /**
-     * Returns true if the list contains the specified element when attached to a Realm. This
+     * Returns {@code true} if the list contains the specified element when attached to a Realm. This
      * method will query the native Realm underlying storage engine to quickly find the specified element.
-     *
-     * If this list is not attached to a Realm the default {@link List#contains(Object)}
+     * <p>
+     * If the list is not attached to a Realm, the default {@link List#contains(Object)}
      * implementation will occur.
      *
      * @param object the element whose presence in this list is to be tested.
@@ -697,7 +691,7 @@ public boolean contains(Object object) {
                 }
             }
         } else {
-            contains = nonManagedList.contains(object);
+            contains = unmanagedList.contains(object);
         }
         return contains;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmMigration.java b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
index 70ec9df868..5140a3bf6a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmMigration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
@@ -18,12 +18,12 @@
 
 /**
  * The RealmMigration class is used to perform the migration of one Realm schema to another.
- * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}, so any
- * changes to these classes will require a migration.
- *
+ * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}
+ * or implement {@link io.realm.RealmModel}, so any changes to these classes will require a migration.
+ * <p>
  * To support migrations from any previous schemaVersion to the newest, the following pattern is recommended when
  * writing a migration:
- *
+ * <p>
  * <pre>
  * {@code
  * public class CustomMigration implements RealmMigration {
@@ -48,7 +48,7 @@
  * }
  * }
  * </pre>
- *
+ * <p>
  * During development when RealmObject classes can change frequently, it is possible to use
  * {@link io.realm.Realm#deleteRealm(RealmConfiguration)}. This will delete the database file and eliminate the need for
  * any migrations.
@@ -61,7 +61,7 @@
 
     /**
      * This method will be called if a migration is needed. The entire method is wrapped in a
-     * write transaction so it is possible to create/change or delete any existing objects
+     * write transaction so it is possible to create, update or delete any existing objects
      * without wrapping it in your own transaction.
      *
      * @param realm the Realm schema on which to perform the migration.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmModel.java b/realm/realm-library/src/main/java/io/realm/RealmModel.java
index 8fbf94f3ac..0c4c8a1046 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmModel.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmModel.java
@@ -21,7 +21,7 @@
 
 /**
  * Interface for marking classes as RealmObjects, it can be used instead of extending {@link RealmObject}.
- *
+ * <p>
  * All helper methods available to classes that extend RealmObject are instead available as static methods:
  *
  * <pre>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 84332e4377..8a91e74e77 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -25,7 +25,7 @@
 import rx.Observable;
 
 /**
- * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then 
+ * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then
  * create your objects within a Realm, and use your custom subclasses instead of using the RealmObject class directly.
  * <p>
  * An annotation processor will create a proxy class for your RealmObject subclass.
@@ -49,7 +49,8 @@
  * within a Realm.
  * <p>
  * The only restriction a RealmObject has is that fields are not allowed to be final, transient' or volatile.
- * Any method as well as public fields are allowed.
+ * Any method as well as public fields are allowed. When providing custom constructors, a public constructor with
+ * no arguments must be declared and be empty.
  * <p>
  * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and don't require either a
  * getter or setter.
@@ -78,7 +79,7 @@
     public final void deleteFromRealm() {
         deleteFromRealm(this);
     }
-    
+
     /**
      * Deletes the object from the Realm it is currently associated with.
      * <p>
@@ -110,10 +111,10 @@ public final void deleteFromRealm() {
 
 
     /**
-     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
-     *
-     * <p>Note that this can be used to check the validity of certain conditions such as being null
+     * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * <p>
+     * Note that this can be used to check the validity of certain conditions such as being {@code null}
      * when observed.
      * <pre>
      * {@code
@@ -123,7 +124,7 @@ public final void deleteFromRealm() {
      * }
      * </pre>
      *
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
      * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
     public final boolean isValid() {
@@ -131,11 +132,11 @@ public final boolean isValid() {
     }
 
     /**
-     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
+     * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
      *
      * @param object RealmObject to check validity for.
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
      */
     public static <E extends RealmModel> boolean isValid(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -150,7 +151,7 @@ public final boolean isValid() {
     /**
      * Determines if the current RealmObject is obtained synchronously or asynchronously (from a worker thread).
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
      * progress.
@@ -162,7 +163,7 @@ public final boolean isLoaded() {
     /**
      * Determines if the RealmObject is obtained synchronously or asynchronously (from a worker thread).
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @param object RealmObject to check.
      * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
@@ -180,7 +181,8 @@ public final boolean isLoaded() {
 
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     * <p>
+     * Note: This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
@@ -190,7 +192,8 @@ public final boolean load() {
 
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     * <p>
+     * Note: This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @param object RealmObject to force load.
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
@@ -214,7 +217,7 @@ public final boolean load() {
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      */
     public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
         RealmObject.addChangeListener((E) this, listener);
@@ -226,7 +229,7 @@ public final boolean load() {
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      * @throws IllegalStateException if you try to add a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
@@ -276,7 +279,7 @@ public final void removeChangeListener(RealmChangeListener listener) {
      * @param object RealmObject to remove listener from.
      * @param listener the instance to be removed.
      * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener listener) {
@@ -314,7 +317,7 @@ public final void removeChangeListeners() {
             proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
             proxy.realmGet$proxyState().getListeners$realm().clear();
         } else {
-            throw new IllegalArgumentException("Cannot remove listeners from this un-managed RealmObject (created outside of Realm)");
+            throw new IllegalArgumentException("Cannot remove listeners from this unmanaged RealmObject (created outside of Realm)");
         }
     }
 
@@ -322,10 +325,10 @@ public final void removeChangeListeners() {
      * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continually be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
-     *
-     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * <p>
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
-     *
+     * <p>
      * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      *
@@ -338,7 +341,8 @@ public final void removeChangeListeners() {
      * }
      * </pre>
      *
-     * <p>Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
      * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
      * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
      * instead.
@@ -357,10 +361,10 @@ public final void removeChangeListeners() {
      * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continuously be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
-     *
-     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * <p>
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
-     *
+     * <p>
      * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
      * emit only the first item by using the {@code first()} operator:
      *
@@ -396,7 +400,7 @@ public final void removeChangeListeners() {
             }
         } else {
             // TODO Is this true? Should we just return Observable.just(object) ?
-            throw new IllegalArgumentException("Cannot create Observables from un-managed RealmObjects");
+            throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 7a3d006452..17870df854 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -88,8 +88,10 @@
     /**
      * Returns the name of the RealmObject class being represented by this schema.
      * <p>
-     * When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.
-     * When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.
+     * <ul>
+     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
+     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
+     * </ul>
      *
      * @return the name of the RealmObject class represented by this schema.
      */
@@ -115,7 +117,7 @@ public RealmObjectSchema setClassName(String className) {
 
     /**
      * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See {@link RealmObject}
-     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.
+     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.,
      * {@code Integer.class} instead of {@code int.class}.
      * <p>
      * To add fields that reference other RealmObjects or RealmLists use {@link #addRealmObjectField(String, RealmObjectSchema)}
@@ -292,7 +294,7 @@ public RealmObjectSchema removeIndex(String fieldName) {
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
-     * annotation on the field.
+     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field as well.
      *
      * @param fieldName field to set as primary key.
      * @return the updated schema.
@@ -306,12 +308,17 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
             throw new IllegalStateException("A primary key is already defined");
         }
         table.setPrimaryKey(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
         return this;
     }
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
-     * annotation from the class.
+     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from the field as well.
      *
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
@@ -320,13 +327,17 @@ public RealmObjectSchema removePrimaryKey() {
         if (!table.hasPrimaryKey()) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
+        long columnIndex = table.getPrimaryKey();
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
         table.setPrimaryKey("");
         return this;
     }
 
     /**
-     * Sets a field to be required, i.e. not allowed to hold {@code null values}. This is equivalent to switching
-     * between boxed types and their primitive variant e.g. {@code Integer} to {@code int}.
+     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
+     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
      *
      * @param fieldName name of field in the class.
      * @param required  {@code true} if field should be required, {@code false} otherwise.
@@ -362,8 +373,8 @@ public RealmObjectSchema setRequired(String fieldName, boolean required) {
     }
 
     /**
-     * Sets a field to be nullable, i.e. it should be able to hold {@code null values}. This is equivalent to switching
-     * between primitive types and their boxed variant e.g. {@code int} to {@code Integer}.
+     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
+     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
      *
      * @param fieldName name of field in the class.
      * @param nullable  {@code true} if field should be nullable, {@code false} otherwise.
@@ -376,7 +387,7 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
     }
 
     /**
-     * Checks if a given field is required, i.e. is not allowed to contain {@code null} values.
+     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
      * @return {@code true} if it is required, {@code false} otherwise.
@@ -389,7 +400,7 @@ public boolean isRequired(String fieldName) {
     }
 
     /**
-     * Checks if a given field is nullable, i.e. is allowed to contain {@code null} values.
+     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
      * @return {@code true} if it is required, {@code false} otherwise.
@@ -553,10 +564,10 @@ private void checkEmpty(String str) {
 
     /**
      * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned
+     * each field is returned.
      *
      * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes Legal field type for the last field in a linked field
+     * @param validColumnTypes valid field type for the last field in a linked field
      * @return list of column indices.
      */
     // TODO: consider another caching strategy so linked classes are included in the cache.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 4abc7ad514..da083799ed 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -43,7 +43,7 @@
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
- * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}
+ * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}.
  * <p>
  * The input to many of the query functions take a field name as String. Note that this is not type safe. If a 
  * RealmObject class is refactored care has to be taken to not break any queries.
@@ -98,9 +98,9 @@
     }
 
     /**
-     * Creates a query from a existing {@link RealmResults}.
+     * Creates a query from an existing {@link RealmResults}.
      *
-     * @param queryResults   a existing @{link io.realm.RealmResults} to query against.
+     * @param queryResults   an existing @{link io.realm.RealmResults} to query against.
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
@@ -115,9 +115,9 @@
     }
 
     /**
-     * Creates a query from a existing {@link RealmList}.
+     * Creates a query from an existing {@link RealmList}.
      *
-     * @param list   a existing @{link io.realm.RealmList} to query against.
+     * @param list   an existing @{link io.realm.RealmList} to query against.
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
@@ -183,7 +183,7 @@ private RealmQuery(BaseRealm realm, LinkView view, String className) {
     }
 
     /**
-     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't been
+     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e., the {@link io.realm.Realm} instance hasn't been
      * closed and any parent {@link io.realm.RealmResults} is still valid.
      *
      * @return {@code true} if still valid to use, {@code false} otherwise.
@@ -201,9 +201,9 @@ public boolean isValid() {
 
     /**
      * Tests if a field is {@code null}. Only works for nullable fields.
-     *
+     * <p>
      * For link queries, if any part of the link path is {@code null} the whole path is considered to be {@code null}
-     * e.g. {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
+     * e.g., {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
      * {@code linkField.stringField} is {@code null}.
      *
      * @param fieldName the field name.
@@ -254,7 +254,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the value to compare with.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -422,7 +422,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the value to compare with.
-     * @param casing     How casing is handled. {@link Case#INSENSITIVE} works only for the English locale characters.
+     * @param casing     how casing is handled. {@link Case#INSENSITIVE} works only for the Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -960,7 +960,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return The query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -987,7 +987,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -1014,7 +1014,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or field type.
      */
@@ -1069,7 +1069,7 @@ public boolean isValid() {
     }
 
     /**
-     * Condition that find values that are considered "empty", i.e. an empty list, the 0-length string or byte array.
+     * Condition that finds values that are considered "empty" i.e., an empty list, the 0-length string or byte array.
      *
      * @param fieldName the field to compare.
      * @return the query object.
@@ -1083,7 +1083,7 @@ public boolean isValid() {
     }
 
     /**
-     * Condition that find values that are considered "Not-empty", i.e. a list, a string or a byte array with not-empty values.
+     * Condition that finds values that are considered "Not-empty" i.e., a list, a string or a byte array with not-empty values.
      *
      * @param fieldName the field to compare.
      * @return the query object.
@@ -1103,7 +1103,7 @@ public boolean isValid() {
      *
      * @param fieldName the field name.
      * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinct(String fieldName) {
@@ -1131,7 +1131,7 @@ public boolean isValid() {
      * @return immediately a {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
      * query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinctAsync(String fieldName) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 9fb6639d21..dbbf002956 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -54,7 +54,7 @@
  * A RealmResults object cannot be passed between different threads.
  * <p>
  * Notice that a RealmResults is never {@code null} not even in the case where it contains no objects. You should always
- * use the size() method to check if a RealmResults is empty or not.
+ * use the {@link RealmResults#size()} method to check if a RealmResults is empty or not.
  * <p>
  * If a RealmResults is built on RealmList through {@link RealmList#where()}, it will become empty when the source
  * RealmList gets deleted.
@@ -217,7 +217,7 @@ public E first() {
         if (size() > 0) {
             return get(0);
         } else {
-            throw new IndexOutOfBoundsException("No results was found.");
+            throw new IndexOutOfBoundsException("No results were found.");
         }
     }
 
@@ -230,7 +230,7 @@ public E last() {
         if (size > 0) {
             return get(size - 1);
         } else {
-            throw new IndexOutOfBoundsException("No results was found.");
+            throw new IndexOutOfBoundsException("No results were found.");
         }
     }
 
@@ -851,12 +851,11 @@ void setPendingQuery(Future<Long> pendingQuery) {
     }
 
     /**
-     * Returns {@code true} if the results are not yet loaded, {@code false} if they are still loading. Synchronous
+     * Returns {@code false} if the results are not yet loaded, {@code true} if they are loaded. Synchronous
      * query methods like findAll() will always return {@code true}, while asynchronous query methods like
      * findAllAsync() will return {@code false} until the results are available.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
      *
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is still
+     * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
      * running.
      */
     public boolean isLoaded() {
@@ -869,7 +868,7 @@ public boolean isLoaded() {
      * the query completes.
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise. {@code true} will always
-     *         be returned for standalone objects.
+     *         be returned for unmanaged objects.
      */
     public boolean load() {
         //noinspection SimplifiableIfStatement
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index aca535075f..d7624d66f0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -30,8 +30,8 @@
 /**
  * Class for interacting with the Realm schema using a dynamic API. This makes it possible
  * to add, delete and change the classes in the Realm.
- *
- * All changes must happen inside a write transaction for that Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
  *
  * @see io.realm.RealmMigration
  */
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
index b465159945..ae187baff1 100644
--- a/realm/realm-library/src/main/java/io/realm/Sort.java
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -33,7 +33,7 @@
 
     /**
      * Returns the value for this setting that is used by the underlying query engine.
-     * @return The value used by the underlying query engine to indicate this value.
+     * @return the value used by the underlying query engine to indicate this value.
      */
     public boolean getValue() {
         return value;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index e2700ee8cd..a3e0778864 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -99,7 +99,7 @@
      * @param object the object to copy properties from.
      * @param update {@code true} if object has a primary key and should try to update already existing data,
      * {@code false} otherwise.
-     * @param cache the cache for mapping between standalone objects and their {@link RealmObjectProxy} representation.
+     * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
      * @return the managed Realm object.
      */
     public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
@@ -129,13 +129,13 @@
     public abstract <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
 
     /**
-     * Creates a deep standalone copy of a RealmObject. This is a deep copy so all links will be copied as well.
+     * Creates a deep unmanaged copy of a RealmObject. This is a deep copy so all links will be copied as well.
      * The depth can be restricted to a maximum depth after which all links will be turned into null values instead.
      *
      * @param realmObject RealmObject to copy. It must be a valid object.
      * @param maxDepth restrict the depth of the copy to this level. The root object is depth {@code 0}.
-     * @param cache cache used to make sure standalone objects are reused correctly.
-     * @return a standalone copy of the given object.
+     * @param cache cache used to make sure unmanaged objects are reused correctly.
+     * @return an unmanaged copy of the given object.
      */
     public abstract <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index e5b32ae2df..4494e72783 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -1380,17 +1380,34 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, INFINITE);
-    }
+        long columnCount = getColumnCount();
+        String name = getName();
+        StringBuilder stringBuilder = new StringBuilder("The Table ");
+        if (name != null && !name.isEmpty()) {
+            stringBuilder.append(getName());
+            stringBuilder.append(" ");
+        }
+        if (hasPrimaryKey()) {
+            String pkFieldName = getColumnName(getPrimaryKey());
+            stringBuilder.append("has \'" + pkFieldName + "\' field as a PrimaryKey, and ");
+        }
+        stringBuilder.append("contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
+
+        return stringBuilder.toString();
     }
 
     @Override
@@ -1537,8 +1554,6 @@ public static String tableNameToClassName(String tableName) {
     private native String nativeGetName(long nativeTablePtr);
     private native void nativeOptimize(long nativeTablePtr);
     private native String nativeToJson(long nativeTablePtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
     private native long nativeVersion(long nativeTablePtr);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 32ebc23ed3..bcd596e6c2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -334,10 +334,6 @@
 
     String toString();
 
-    String toString(long maxRows);
-
-    String rowToString(long rowIndex);
-
     TableQuery where();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index 6928abda3a..efcf5ff2c0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -724,17 +724,24 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, 500);
-    }
+        long columnCount = getColumnCount();
+        StringBuilder stringBuilder = new StringBuilder("The TableView contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
+
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        return stringBuilder.toString();
     }
 
     @Override
@@ -896,8 +903,6 @@ public long syncIfNeeded() {
     private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
     private native long createNativeTableView(Table table, long nativeTablePtr);
     private native String nativeToJson(long nativeViewPtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
     private native long nativeWhere(long nativeViewPtr);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
     private native long nativeDistinct(long nativeViewPtr, long columnIndex);
diff --git a/version.txt b/version.txt
index 222360a331..5902d52cce 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.91.0-SNAPSHOT
+1.1.0-SNAPSHOT
