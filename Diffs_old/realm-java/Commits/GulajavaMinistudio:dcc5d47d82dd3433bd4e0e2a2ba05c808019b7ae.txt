diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3c0ea33a2c..6bbe4fb953 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,7 +4,8 @@
 
 ### Enhancements
 
-* Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore' annotation (#4279).
+* [ObjectServer] Added support for `SyncUser.isAdmin()` (#4353).
+* Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore` annotation (#4279).
 
 ### Bug Fixes
 
@@ -17,6 +18,8 @@
 * `equals()` and `hashCode()` of managed `RealmObject`s that come from linking objects don't work correctly (#4487).
 * Field name was missing in exception message when `null` was set to required field (#4484).
 * Now throws `IllegalStateException` when a getter of linking objects is called against deleted or not yet loaded `RealmObject`s (#4499).
+* `NullPointerException` caused by local transaction inside the listener of `findFirstAsync()`'s results (#4495).
+* Native crash when adding listeners to `RealmObject` after removing listeners from the same `RealmObject` before (#4502).
 
 ### Internal
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index b49618fab1..24bd82fda5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -632,9 +632,9 @@ public void onChange(AllTypes object) {
     @RunTestInLooperThread
     public void findFirstAsync_forceLoad() throws Throwable {
         final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-        Realm Realm = looperThread.realm;
-        populateTestRealm(Realm, 10);
-        final AllTypes realmResults = Realm.where(AllTypes.class)
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+        final AllTypes realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 9)
                 .findFirstAsync();
 
@@ -657,6 +657,38 @@ public void onChange(RealmModel object, ObjectChangeSet changeSet) {
         looperThread.testComplete();
     }
 
+    // For issue https://github.com/realm/realm-java/issues/4495
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_twoListenersOnSameInvalidObjectsCauseNPE() {
+        final Realm realm = looperThread.realm;
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        final AtomicBoolean firstListenerCalled = new AtomicBoolean(false);
+
+        allTypes.addChangeListener(new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes element) {
+                allTypes.removeChangeListener(this);
+                assertFalse(firstListenerCalled.getAndSet(true));
+                if (!element.isValid()) {
+                    realm.beginTransaction();
+                    realm.createObject(AllTypes.class);
+                    realm.commitTransaction();
+                }
+            }
+        });
+
+        allTypes.addChangeListener(new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes element) {
+                allTypes.removeChangeListener(this);
+                assertTrue(firstListenerCalled.get());
+                assertFalse(element.isValid());
+                looperThread.testComplete();
+            }
+        });
+    }
+
     // **************************************
     // *** 'findAllSorted' async queries  ***
     // **************************************
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 54d4e674df..d92e76a252 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -1790,6 +1790,35 @@ public void onChange(Dog object, ObjectChangeSet changeSet) {
         looperThread.testComplete();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners_thenAdd() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setAge(13);
+        realm.commitTransaction();
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object) {
+                fail();
+            }
+        });
+        dog.removeAllChangeListeners();
+
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog dog) {
+                assertEquals(14, dog.getAge());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        dog.setAge(14);
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void removeChangeListener_throwOnUnmanagedObject() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 4c4069a9e8..6eefd9023f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -1138,6 +1138,33 @@ public void run() {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners_thenAdd() {
+        final Realm realm = looperThread.realm;
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+
+        collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                fail();
+            }
+        });
+        collection.removeAllChangeListeners();
+
+        collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                assertEquals(1, results.size());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
     @Test
     public void deleteAndDeleteAll() {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 0f4fa8b0b9..fe69cfff36 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -40,8 +40,10 @@
 import io.realm.rule.RunInLooperThread;
 import io.realm.util.SyncTestUtils;
 
+import static io.realm.util.SyncTestUtils.createTestAdminUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -117,7 +119,7 @@ public AuthenticateResponse answer(InvocationOnMock invocationOnMock) throws Thr
     private AuthenticateResponse getNewRandomUser() {
         String identity = UUID.randomUUID().toString();
         String userTokenValue = UUID.randomUUID().toString();
-        return SyncTestUtils.createLoginResponse(userTokenValue, identity, Long.MAX_VALUE);
+        return SyncTestUtils.createLoginResponse(userTokenValue, identity, Long.MAX_VALUE, false);
     }
 
     // Test that current user is cleared if it is logged out
@@ -155,6 +157,27 @@ public void all_validUsers() {
         assertTrue(users.entrySet().iterator().next().getValue().isValid());
     }
 
+    @Test
+    public void isAdmin() {
+        SyncUser user1 = createTestUser();
+        assertFalse(user1.isAdmin());
+
+        SyncUser user2 = createTestAdminUser();
+        assertTrue(user2.isAdmin());
+    }
+
+    @Test
+    public void isAdmin_allUsers() {
+        UserStore userStore = SyncManager.getUserStore();
+        SyncUser user = SyncTestUtils.createTestAdminUser();
+        assertTrue(user.isAdmin());
+        userStore.put(user);
+
+        Map <String, SyncUser> users = SyncUser.all();
+        assertEquals(1, users.size());
+        assertTrue(users.entrySet().iterator().next().getValue().isAdmin());
+    }
+
     // Tests that the user store returns the last user to login
     /* FIXME: This test fails because of wrong JSON string.
     @Test
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index de368019a5..20228694a1 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -24,7 +24,6 @@
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
-import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.objectserver.ObjectServerUser;
@@ -42,27 +41,32 @@ public static SyncUser createRandomTestUser() {
                 UUID.randomUUID().toString(),
                 UUID.randomUUID().toString(),
                 DEFAULT_AUTH_URL,
-                Long.MAX_VALUE);
+                Long.MAX_VALUE,
+                false);
+    }
+
+    public static SyncUser createTestAdminUser() {
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
     }
 
     public static SyncUser createTestUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createTestUser(long expires) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  DEFAULT_AUTH_URL, expires);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  DEFAULT_AUTH_URL, expires, false);
     }
 
     public static SyncUser createTestUser(String authUrl) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  authUrl, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  authUrl, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createNamedTestUser(String userIdentifier) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
-    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String userIdentifier, String authUrl, long expires) {
-        Token userToken = new Token(userTokenValue, userIdentifier, null, expires, null);
+    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String userIdentifier, String authUrl, long expires, boolean isAdmin) {
+        Token userToken = new Token(userTokenValue, userIdentifier, null, expires, null, isAdmin);
         Token accessToken = new Token(realmTokenValue, userIdentifier, "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
         ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
 
@@ -84,12 +88,12 @@ public static SyncUser createTestUser(String userTokenValue, String realmTokenVa
     }
 
     public static AuthenticateResponse createLoginResponse(long expires) {
-        return createLoginResponse(USER_TOKEN, "JohnDoe", expires);
+        return createLoginResponse(USER_TOKEN, "JohnDoe", expires, false);
     }
 
-    public static AuthenticateResponse createLoginResponse(String userTokenValue, String userIdentity, long expires) {
+    public static AuthenticateResponse createLoginResponse(String userTokenValue, String userIdentity, long expires, boolean isAdmin) {
         try {
-            Token userToken = new Token(userTokenValue, userIdentity, null, expires, null);
+            Token userToken = new Token(userTokenValue, userIdentity, null, expires, null, isAdmin);
             JSONObject response = new JSONObject();
             response.put("refresh_token", userToken.toJson());
             return AuthenticateResponse.from(response.toString());
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index 313a2d169b..148c0c8914 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -59,16 +59,17 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetUser(JNIEnv*
 }
 
 JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser(JNIEnv* env, jclass,
-                                                                                 jstring identity, jstring jsonToken,
-                                                                                 jstring url)
+                                                                                 jstring identity, jstring json_token,
+                                                                                 jstring url, jboolean is_admin)
 {
     TR_ENTER()
     try {
         JStringAccessor user_identity(env, identity);    // throws
-        JStringAccessor user_json_token(env, jsonToken); // throws
+        JStringAccessor user_json_token(env, json_token); // throws
         JStringAccessor auth_url(env, url);              // throws
 
-        SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url));
+        SyncUser::TokenType token_type = (is_admin) ? SyncUser::TokenType::Admin : SyncUser::TokenType::Normal;
+        SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url), token_type);
     }
     CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index 142e64d0c4..b584438ada 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -35,7 +35,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName(
                                                                                 jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex)) {
-        return NULL;
+        return nullptr;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetColumnName(env, obj, nativeRowPtr, columnIndex);
@@ -82,7 +82,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean(JN
                                                                               jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool)) {
-        return 0;
+        return JNI_FALSE;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetBoolean(env, obj, nativeRowPtr, columnIndex);
@@ -122,7 +122,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString(JNIE
                                                                             jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String)) {
-        return 0;
+        return nullptr;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetString(env, obj, nativeRowPtr, columnIndex);
@@ -133,7 +133,7 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArra
                                                                                   jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary)) {
-        return 0;
+        return nullptr;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
@@ -153,7 +153,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink(JN
                                                                               jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link)) {
-        return 0;
+        return JNI_FALSE;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeIsNullLink(env, obj, nativeRowPtr, columnIndex);
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index 95c3fa24c5..62887708c9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -189,7 +189,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStartListening(JNIE
         // The wrapper pointer will be used in the callback. But it should never become an invalid pointer when the
         // notification block gets called. This should be guaranteed by the Object Store that after the notification
         // token is destroyed, the block shouldn't be called.
-        wrapper->m_notification_token = wrapper->m_object.add_notification_block(ChangeCallback(wrapper));
+        wrapper->m_notification_token = wrapper->m_object.add_notification_callback(ChangeCallback(wrapper));
     }
     CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 3b6c0f6110..7a1924b4cf 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 3b6c0f611061dddabc489f0b9f264306893c96c8
+Subproject commit 7a1924b4cf24f823825e9bc32b236b8a67ad52fe
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 8e99df9ca8..63a86d2bb0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -227,6 +227,9 @@ private void notifyFrontEnd() {
         if (pendingCollection.isValid()) {
             // PendingRow will always get the first Row of the query since we only support findFirst.
             UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+            // Clear the pending collection immediately in case beginTransaction is called in the listener which will
+            // execute the query again.
+            clearPendingCollection();
             // If no rows returned by the query, notify the frontend with an invalid row.
             if (uncheckedRow != null) {
                 Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
@@ -236,9 +239,10 @@ private void notifyFrontEnd() {
                 // No row matches the query, return a invalid row.
                 frontEnd.onQueryFinished(InvalidRow.INSTANCE);
             }
+        } else {
+            clearPendingCollection();
         }
 
-        clearPendingCollection();
     }
 
     // Execute the query immediately and call frontend's onQueryFinished().
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index e208131397..6b03bf8573 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -32,7 +32,7 @@
     public void put(SyncUser user) {
         String userJson = user.toJson();
         // create or update token (userJson) using identity
-        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString());
+        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString(), user.isAdmin());
     }
 
     /**
@@ -92,7 +92,7 @@ private static SyncUser toSyncUserOrNull(String userJson) {
 
     protected static native String[] nativeGetAllUsers();
 
-    protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
+    protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url, boolean isAdmin);
 
     protected static native void nativeLogoutUser(String identity);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 986e3bfc03..02738e9eb1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -73,7 +73,7 @@
      *
      * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials facebook(String facebookToken) {
@@ -86,7 +86,7 @@ public static SyncCredentials facebook(String facebookToken) {
      *
      * @param googleToken a google userIdentifier acquired by logging into Google.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials google(String googleToken) {
@@ -101,10 +101,10 @@ public static SyncCredentials google(String googleToken) {
      * @param username username of the user.
      * @param password the users password.
      * @param createUser {@code true} if the user should be created, {@code false} otherwise. It is not possible to
-     *                   create a user twice when logging in, so this flag should only be set to {@code true} the first
-     *                   time a users log in.
+     * create a user twice when logging in, so this flag should only be set to {@code true} the first
+     * time a users log in.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password, boolean createUser) {
@@ -122,7 +122,7 @@ public static SyncCredentials usernamePassword(String username, String password,
      * @param username username of the user.
      * @param password the users password.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password) {
@@ -136,10 +136,10 @@ public static SyncCredentials usernamePassword(String username, String password)
      * @param userIdentifier String identifying the user. Usually a username or user token.
      * @param identityProvider provider used to verify the credentials.
      * @param userInfo data describing the user further or {@code null} if the user does not have any extra data. The
-     *              data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
-     *              classes will be converted using {@code toString()}.
+     * data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
+     * classes will be converted using {@code toString()}.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if any parameter is either {@code null} or empty.
      */
     public static SyncCredentials custom(String userIdentifier, String identityProvider, Map<String, Object> userInfo) {
@@ -154,17 +154,38 @@ public static SyncCredentials custom(String userIdentifier, String identityProvi
     /**
      * Creates credentials from an existing access token. Since an access token is the proof that a user already
      * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
-     * This means that providing this credential to {@link SyncUser#login(SyncCredentials, String)} will always
+     * This means that providing these credentials to {@link SyncUser#login(SyncCredentials, String)} will always
      * succeed, but accessing any Realm after might fail if the token is no longer valid.
+     * <p>
+     * It is assumed that this user is not an administrator. Otherwise use {@link #accessToken(String, String, boolean)}.
      *
      * @param accessToken user's access token.
      * @param identifier user identifier.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
      */
     public static SyncCredentials accessToken(String accessToken, String identifier) {
+        return accessToken(accessToken, identifier, false);
+    }
+
+    /**
+     * Creates credentials from an existing access token. Since an access token is the proof that a user already
+     * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
+     * This means that providing these credentials to {@link SyncUser#login(SyncCredentials, String)} will always
+     * succeed, but accessing any Realm after might fail if the token is no longer valid.
+     *
+     * @param accessToken user's access token.
+     * @param identifier user identifier.
+     * @param isAdmin {@code true} if the access token is an administrator's token, {@code false} if it is a
+     * non-privileged users. It is to <i>not</i> possible to upgrade a non-admin token to an admin token by setting this
+     * value. It is purely informational.
+     * @return a set of credentials that can be used to log into the Object Server using
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     */
+    public static SyncCredentials accessToken(String accessToken, String identifier, boolean isAdmin) {
         HashMap<String, Object> userInfo = new HashMap<String, Object>();
         userInfo.put("_token", accessToken);
+        userInfo.put("_isAdmin", isAdmin);
         return new SyncCredentials(identifier, IdentityProvider.ACCESS_TOKEN, userInfo);
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index b1a78314af..ec1d2f0ba2 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -191,7 +191,8 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
                 // the JSON response expected from the server.
                 String userIdentifier = credentials.getUserIdentifier();
                 String token = (String) credentials.getUserInfo().get("_token");
-                result = AuthenticateResponse.createValidResponseWithUser(userIdentifier, token);
+                boolean isAdmin = (Boolean) credentials.getUserInfo().get("_isAdmin");
+                result = AuthenticateResponse.createValidResponseWithUser(userIdentifier, token, isAdmin);
             } else {
                 final AuthenticationServer server = SyncManager.getAuthServer();
                 result = server.loginUser(credentials, authUrl);
@@ -375,6 +376,17 @@ public boolean isValid() {
         return syncUser.isLoggedIn() && userToken != null && userToken.expiresMs() > System.currentTimeMillis();
     }
 
+    /**
+     * Returns {@code true} if this user is an administrator on the Realm Object Server, {@code false} otherwise.
+     * <p>
+     * Administrators can access all Realms on the server as well as change the permissions of the Realms.
+     *
+     * @return {@code true} if the user is an administrator on the Realm Object Server, {@code false} otherwise.
+     */
+    public boolean isAdmin() {
+        return syncUser.isAdmin();
+    }
+
     /**
      * Returns the identity of this user on the Realm Object Server. The identity is a guaranteed to be unique
      * among all users on the Realm Object Server.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
index e0140385cb..6f45d1146f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
@@ -81,10 +81,10 @@ public static AuthenticateResponse from(ObjectServerError error) {
      * @param identifier user identifier.
      * @param refreshToken user's refresh token.
      */
-    public static AuthenticateResponse createValidResponseWithUser(String identifier, String refreshToken) {
+    public static AuthenticateResponse createValidResponseWithUser(String identifier, String refreshToken, boolean isAdmin) {
         try {
             JSONObject response = new JSONObject();
-            response.put(JSON_FIELD_REFRESH_TOKEN, new Token(refreshToken, identifier, null, Long.MAX_VALUE, Token.Permission.ALL).toJson());
+            response.put(JSON_FIELD_REFRESH_TOKEN, new Token(refreshToken, identifier, null, Long.MAX_VALUE, Token.Permission.ALL, isAdmin).toJson());
             return new AuthenticateResponse(response.toString());
         } catch (JSONException e) {
             throw new RuntimeException(e);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
index 740125a54b..235c032a9b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
@@ -192,6 +192,10 @@ public int hashCode() {
         return realms.values();
     }
 
+    public boolean isAdmin() {
+        return refreshToken.isAdmin();
+    }
+
     // Wrapper for all Realm data needed by a User that might get serialized.
     public static class AccessDescription {
         public Token accessToken;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
index 1d45632b40..3d642ef43c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
@@ -30,20 +30,29 @@
  */
 public class Token {
 
+    private static final String KEY_TOKEN = "token";
+    private static final String KEY_TOKEN_DATA = "token_data";
+    private static final String KEY_IDENTITY = "identity";
+    private static final String KEY_PATH = "path";
+    private static final String KEY_EXPIRES = "expires";
+    private static final String KEY_ACCESS = "access";
+    private static final String KEY_IS_ADMIN = "is_admin";
+
     private final String value;
     private final long expiresSec;
     private final Permission[] permissions;
     private final String identity;
     private final String path;
+    private final boolean isAdmin;
 
     public static Token from(JSONObject token) throws JSONException {
-        String value = token.getString("token");
-        JSONObject tokenData = token.getJSONObject("token_data");
-        String identity = tokenData.getString("identity");
-        String path = tokenData.optString("path");
-        long expiresSec = tokenData.getLong("expires");
+        String value = token.getString(KEY_TOKEN);
+        JSONObject tokenData = token.getJSONObject(KEY_TOKEN_DATA);
+        String identity = tokenData.getString(KEY_IDENTITY);
+        String path = tokenData.optString(KEY_PATH);
+        long expiresSec = tokenData.getLong(KEY_EXPIRES);
         Permission[] permissions;
-        JSONArray access = tokenData.getJSONArray("access");
+        JSONArray access = tokenData.getJSONArray(KEY_ACCESS);
         if (access != null) {
             permissions = new Permission[access.length()];
             for (int i = 0; i < access.length(); i++) {
@@ -56,11 +65,16 @@ public static Token from(JSONObject token) throws JSONException {
         } else {
             permissions = new Permission[0];
         }
+        boolean isAdmin = tokenData.optBoolean(KEY_IS_ADMIN);
 
-        return new Token(value, identity, path, expiresSec, permissions);
+        return new Token(value, identity, path, expiresSec, permissions, isAdmin);
     }
 
     public Token(String value, String identity, String path, long expiresSec, Permission[] permissions) {
+        this(value, identity, path, expiresSec, permissions, false);
+    }
+
+    public Token(String value, String identity, String path, long expiresSec, Permission[] permissions, boolean isAdmin) {
         this.value = value;
         this.identity = identity;
         this.path = path;
@@ -70,6 +84,7 @@ public Token(String value, String identity, String path, long expiresSec, Permis
         } else {
             this.permissions = new Permission[0];
         }
+        this.isAdmin = isAdmin;
     }
 
     public String value() {
@@ -80,6 +95,8 @@ public String value() {
 
     public String path() { return path; }
 
+    public boolean isAdmin() { return isAdmin; }
+
     /**
      * Returns when this token expires. Timestamp is in UTC seconds.
      */
@@ -107,17 +124,18 @@ public long expiresMs() {
     public JSONObject toJson() {
         JSONObject obj = new JSONObject();
         try {
-            obj.put("token", value);
+            obj.put(KEY_TOKEN, value);
             JSONObject tokenData = new JSONObject();
-            tokenData.put("identity", identity);
-            tokenData.put("path", path);
-            tokenData.put("expires", expiresSec);
+            tokenData.put(KEY_IDENTITY, identity);
+            tokenData.put(KEY_PATH, path);
+            tokenData.put(KEY_EXPIRES, expiresSec);
             JSONArray perms = new JSONArray();
             for (int i = 0; i < permissions.length; i++) {
                 perms.put(permissions[i].toString().toLowerCase(Locale.US));
             }
-            tokenData.put("access", perms);
-            obj.put("token_data", tokenData);
+            tokenData.put(KEY_ACCESS, perms);
+            tokenData.put(KEY_IS_ADMIN, isAdmin);
+            obj.put(KEY_TOKEN_DATA, tokenData);
             return obj;
         } catch (JSONException e) {
             throw new RuntimeException("Could not convert Token to JSON.", e);
@@ -126,15 +144,16 @@ public JSONObject toJson() {
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
 
         Token token = (Token) o;
 
-        if (expiresSec != token.expiresSec) return false;
-        if (!value.equals(token.value)) return false;
-        if (!Arrays.equals(permissions, token.permissions)) return false;
-        if (!identity.equals(token.identity)) return false;
+        if (expiresSec != token.expiresSec) { return false; }
+        if (isAdmin != token.isAdmin) { return false; }
+        if (!value.equals(token.value)) { return false; }
+        if (!Arrays.equals(permissions, token.permissions)) { return false; }
+        if (!identity.equals(token.identity)) { return false; }
         return path != null ? path.equals(token.path) : token.path == null;
     }
 
@@ -145,6 +164,7 @@ public int hashCode() {
         result = 31 * result + Arrays.hashCode(permissions);
         result = 31 * result + identity.hashCode();
         result = 31 * result + (path != null ? path.hashCode() : 0);
+        result = 31 * result + (isAdmin ? 1 : 0);
         return result;
     }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index ae1cda7ac7..6ebb8efed5 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -6,6 +6,9 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.net.MalformedURLException;
+import java.net.URL;
+
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
@@ -24,6 +27,8 @@
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertFalse;
+
 
 @RunWith(AndroidJUnit4.class)
 public class AuthTests extends BaseIntegrationTest {
@@ -59,14 +64,38 @@ public void onError(ObjectServerError error) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void login_newUser() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword("myUser", "password", true);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                assertFalse(user.isAdmin());
+                try {
+                    assertEquals(new URL(Constants.AUTH_URL), user.getAuthenticationUrl());
+                } catch (MalformedURLException e) {
+                    fail(e.toString());
+                }
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void login_withAccessToken() {
-        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncCredentials credentials = SyncCredentials.accessToken(adminUser.getAccessToken().value(), "custom-admin-user", adminUser.isAdmin());
         SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
             @Override
             public void onSuccess(SyncUser user) {
+                assertTrue(user.isAdmin());
                 final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
                         .errorHandler(new SyncSession.ErrorHandler() {
                             @Override
