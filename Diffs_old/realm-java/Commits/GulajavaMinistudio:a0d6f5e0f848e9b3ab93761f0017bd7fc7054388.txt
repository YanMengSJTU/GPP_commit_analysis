diff --git a/CHANGELOG.md b/CHANGELOG.md
index b0e3fdf20c..df3a5b213d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,45 @@
+## 6.0.0(YYYY-MM-DD)
+
+### Breaking Changes
+* [ObjectServer] The `PermissionManager` is no longer backed by Realms but instead a REST API. This means that the `PermissionManager` class has been removed and all methods have been moved to `SyncUser`. Some method names have been renamed slightly and return values for methods have changed from `RealmResults<Permission>` to `List<Permission>`. This should only have an impact if change listeners were used to listen for changes. In these cases, you must now manually retry the request.
+
+### Enhancements
+None.
+
+### Fixed
+None.
+
+### Compatibility
+* Realm Object Server: 3.23.1 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 6.x.y series.
+
+### Internal
+* [ObjectServer] The OKHttp client will now follow redirects from the Realm Object Server.
+
+
+## 5.15.2(2019-09-30)
+
+### Enhancements
+* None.
+
+### Fixed
+* `null` values were not printed correctly when using `RealmResults.asJSON()` (Realm Core Issue [#3399](https://github.com/realm/realm-core/pull/3399))
+* [ObjectServer] Queries with nullable `Date`'s did not serialize correctly. Only relevant if using Query-based Synchronization. (Realm Core issue [#3388](https://github.com/realm/realm-core/pull/3388))
+* [ObjectServer] Fixed crash with `java.lang.IllegalStateException: The following changes cannot be made in additive-only schema mode` when opening an old Realm created between Realm Java 5.10.0 and Realm Java 5.13.0. (Issue [#6619](https://github.com/realm/realm-java/issues/6619), since 5.13.0).
+
+### Compatibility
+* Realm Object Server: 3.21.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* Updated to Object Store commit: 8416010e4be5e32ba552ff3fb29e500f3102d3db.
+* Updated to Realm Sync 4.7.8.
+* Updated to Realm Core 5.23.5.
+* Updated Docker image used on CI to Node 10.
+
+
 ## 5.15.1(2019-09-09)
 
 ### Enhancements
@@ -14,7 +56,6 @@
 ### Internal
 * None.
 
-
 ## 5.15.0(2019-09-05)
 
 ### Enhancements
diff --git a/dependencies.list b/dependencies.list
index 1255617b1f..777e0f4081 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,11 +1,11 @@
 # Realm Sync release used by Realm Java (This includes Realm Core)
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=4.7.4
-REALM_SYNC_SHA256=a7ec9b32a137760c317df15279cc33ffdb63b8663e9ce789a345628afb8424a7
+REALM_SYNC_VERSION=4.7.8
+REALM_SYNC_SHA256=d7453f2296e23fd29a9c7f6fd1225e6905bbc05b8c24d4f45308ad5dd8918f03
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_VERSION=3.21.0-rc1
+REALM_OBJECT_SERVER_VERSION=3.23.1
 
 # Common Android settings across projects
 GRADLE_BUILD_TOOLS=3.3.2
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/optionalsubscriptionfields.realm b/realm/realm-library/src/androidTestObjectServer/assets/optionalsubscriptionfields.realm
new file mode 100644
index 0000000000..3868f2f68d
Binary files /dev/null and b/realm/realm-library/src/androidTestObjectServer/assets/optionalsubscriptionfields.realm differ
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index 492acda0ea..cccf23178f 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -16,7 +16,7 @@
 import java.net.URL;
 
 import io.realm.internal.network.AuthenticateRequest;
-import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.RealmObjectServer;
 import io.realm.internal.objectserver.Token;
 
 import static org.junit.Assert.assertEquals;
@@ -71,8 +71,8 @@ public void userRefresh() throws URISyntaxException, JSONException {
 
     @Test
     public void errorsNotWrapped() {
-        AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
-        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        RealmObjectServer originalAuthServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = Mockito.mock(RealmObjectServer.class);
         when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createErrorResponse(ErrorCode.ACCESS_DENIED));
         SyncManager.setAuthServerImpl(authServer);
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 8388761106..4e6a04fa53 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -22,7 +22,6 @@
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
@@ -46,7 +45,7 @@
 import io.realm.entities.AllTypesModelModule;
 import io.realm.entities.StringOnly;
 import io.realm.internal.network.AuthenticateResponse;
-import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.RealmObjectServer;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.StringOnlyModule;
@@ -54,7 +53,6 @@
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 
-import static io.realm.SyncTestUtils.createNamedTestUser;
 import static io.realm.SyncTestUtils.createTestAdminUser;
 import static io.realm.SyncTestUtils.createTestUser;
 import static junit.framework.Assert.assertEquals;
@@ -176,8 +174,8 @@ public void currentUser_returnsNullIfUserExpired() {
 
     @Test
     public void currentUser_throwsIfMultipleUsersLoggedIn() {
-        AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
-        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        RealmObjectServer originalAuthServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = Mockito.mock(RealmObjectServer.class);
         SyncManager.setAuthServerImpl(authServer);
 
         try {
@@ -269,7 +267,7 @@ public void isAdmin_allUsers() {
     @Ignore("This test fails because of wrong JSON string.")
     @Test
     public void currentUser_returnsUserAfterLogin() {
-        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        RealmObjectServer authServer = Mockito.mock(RealmObjectServer.class);
         when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
 
         SyncUser user = SyncUser.logIn(SyncCredentials.facebook("foo"), "http://bar.com/auth");
@@ -286,9 +284,9 @@ public void toString_returnDescription() {
     // Test that a login with an access token logs the user in directly without touching the network
     @Test
     public void login_withAccessToken() {
-        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        RealmObjectServer authServer = Mockito.mock(RealmObjectServer.class);
         when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenThrow(new AssertionError("Server contacted."));
-        AuthenticationServer originalServer = SyncManager.getAuthServer();
+        RealmObjectServer originalServer = SyncManager.getAuthServer();
         SyncManager.setAuthServerImpl(authServer);
         try {
             SyncCredentials credentials = SyncCredentials.accessToken("foo", "bar");
@@ -302,8 +300,8 @@ public void login_withAccessToken() {
     // Checks that `/auth` is correctly added to any URL without a path
     @Test
     public void login_appendAuthSegment() {
-        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
-        AuthenticationServer originalServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = Mockito.mock(RealmObjectServer.class);
+        RealmObjectServer originalServer = SyncManager.getAuthServer();
         SyncManager.setAuthServerImpl(authServer);
         String[][] urls = {
                 {"http://ros.realm.io", "http://ros.realm.io/auth"},
@@ -413,51 +411,6 @@ public void changePassword_noneAdminThrows() {
         user.changePassword("user-id", "new-password");
     }
 
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissionManager_isReferenceCounted() {
-        SyncUser user = createTestUser();
-        PermissionManager pm1 = user.getPermissionManager();
-        PermissionManager pm2 = user.getPermissionManager();
-        assertTrue(pm1 == pm2);
-        assertFalse(pm1.isClosed());
-        pm1.close();
-        assertFalse(pm1.isClosed());
-        pm1.close();
-        assertTrue(pm1.isClosed());
-        looperThread.testComplete();
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissionManger_instanceUniqueToUser() {
-        SyncUser user1 = createNamedTestUser("user1");
-        SyncUser user2 = createNamedTestUser("user2");
-        PermissionManager pm1 = user1.getPermissionManager();
-        PermissionManager pm2 = user2.getPermissionManager();
-
-        try {
-            assertFalse(pm1 == pm2);
-            assertFalse(pm1.equals(pm2));
-            looperThread.testComplete();
-        } finally {
-            pm1.close();
-            pm2.close();
-            user1.logOut();
-            user2.logOut();
-        }
-    }
-
-    @Test
-    public void getPermissionManager_throwOnNonLooperThread() {
-        SyncUser user = createTestUser();
-        try {
-            user.getPermissionManager();
-            fail();
-        } catch (IllegalStateException e) {
-        }
-    }
-
     @Test
     public void allSessions() {
         String url1 = "realm://objectserver.realm.io/default";
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
index 51180a7fda..4d685b946c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
@@ -15,6 +15,7 @@
  */
 package io.realm;
 
+import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -35,6 +36,7 @@
 import io.realm.sync.Subscription;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -88,6 +90,36 @@ private Realm getFullySyncRealm() {
         return realm;
     }
 
+    // Test for https://github.com/realm/realm-java/issues/6619
+    @Test
+    public void testUpgragendingOptionalSubscriptionFields() throws IOException {
+        SyncUser user = SyncTestUtils.createTestUser();
+
+        // Put an older Realm at the location where Realm would otherwise create a new empty one.
+        // This way, Realm will upgrade this file instead.
+        // We don't need to synchronize data with the server, so any errors due to missing
+        // server side files are ignored.
+        // The file was created using Realm Java 5.10.0
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, "realm://127.0.0.1:9080/optionalsubscriptionfields").build();
+        File realmDir = config.getRealmDirectory();
+        File oldRealmFile = new File(realmDir, "optionalsubscriptionfields");
+        assertFalse(oldRealmFile.exists());
+        configFactory.copyFileFromAssets(InstrumentationRegistry.getTargetContext().getApplicationContext(), "optionalsubscriptionfields.realm", oldRealmFile);
+        assertTrue(oldRealmFile.exists());
+
+        try {
+            // Opening the Realm should not throw a schema mismatch
+            realm = Realm.getInstance(config);
+
+            // Verify that createdAt/updatedAt are still optional even though the Java model class
+            // says they should be required.
+            assertTrue(realm.getSchema().get("__ResultSets").isNullable("created_at"));
+            assertTrue(realm.getSchema().get("__ResultSets").isNullable("updated_at"));
+        } catch (Exception e) {
+            fail(e.toString());
+        }
+    }
+
     @Test
     public void unsubscribeAsync_nullOrEmptyArgumentsThrows() {
         Realm realm = getPartialRealm();
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 95e1fbfded..f8bd197a12 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -45,7 +45,7 @@ set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 
 # Initialize common compile & link flags.
 set(REALM_LINKER_FLAGS "")
-set(REALM_COMMON_CXX_FLAGS "")
+set(REALM_COMMON_CXX_FLAGS "-DREALM_PLATFORM_JAVA=1")
 
 # Setup lcache
 if(NDK_LCACHE)
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 9f19d79fde..8416010e4b 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 9f19d79fde248ba37cef0bd52fe64984f9d71be0
+Subproject commit 8416010e4be5e32ba552ff3fb29e500f3102d3db
diff --git a/realm/realm-library/src/main/java/io/realm/sync/Subscription.java b/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
index ff2f5e9fa3..a33a964fcd 100644
--- a/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
+++ b/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
@@ -15,7 +15,6 @@
  */
 package io.realm.sync;
 
-import java.lang.reflect.Field;
 import java.util.Date;
 import java.util.concurrent.TimeUnit;
 
@@ -29,7 +28,6 @@
 import io.realm.annotations.RealmClass;
 import io.realm.annotations.RealmField;
 import io.realm.annotations.Required;
-import io.realm.internal.Table;
 import io.realm.internal.annotations.ObjectServer;
 
 /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
deleted file mode 100644
index 6ffd9ad5c3..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
+++ /dev/null
@@ -1,1426 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.os.Handler;
-
-import java.io.Closeable;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.annotation.Nullable;
-
-import io.realm.internal.OsRealmConfig;
-import io.realm.internal.Util;
-import io.realm.internal.permissions.BasePermissionApi;
-import io.realm.internal.permissions.ManagementModule;
-import io.realm.internal.permissions.PermissionChange;
-import io.realm.internal.permissions.PermissionModule;
-import io.realm.internal.permissions.PermissionOfferResponse;
-import io.realm.log.RealmLog;
-import io.realm.permissions.Permission;
-import io.realm.permissions.PermissionOffer;
-import io.realm.permissions.PermissionRequest;
-
-
-/**
- * Helper class for interacting with Realm Object Server permissions for a {@link SyncUser}.
- * <p>
- * Current functionality supported by this class:
- * <ul>
- *     <li>List users existing permissions.</li>
- *     <li>List default permissions.</li>
- *     <li>Modify permissions for a Realm.</li>
- *     <li>Create a permission offer that can be sent to others.</li>
- *     <li>Accept permission offers sent by other users.</li>
- * </ul>
- * <p>
- * This class depends on underlying Realms, so all data coming from this class is thread-confined and must be
- * closed after use to avoid leaking resources.
- *
- * @see <a href="https://realm.io/docs/java/latest/#access-control">How to work with Access Controls</a>
- */
-public class PermissionManager implements Closeable {
-
-    // Reference counted cache equivalent to how Realm instances work.
-    private static Map<String, ThreadLocal<Cache>> cache = new HashMap<>();
-
-    private static class Cache {
-        public PermissionManager pm = null;
-        public Integer instanceCounter = Integer.valueOf(0);
-    }
-
-    private static final Object cacheLock = new Object();
-
-    /**
-     * Return a thread confined, reference counted instance of the PermissionManager.
-     *
-     * @param syncUser user to create the PermissionManager for.
-     * @return a thread confined PermissionManager instance for the provided user.
-     */
-    static PermissionManager getInstance(SyncUser syncUser) {
-        synchronized (cacheLock) {
-            String userId = syncUser.getIdentity();
-            ThreadLocal<Cache> threadLocalCache = cache.get(userId);
-            if (threadLocalCache == null) {
-                threadLocalCache = new ThreadLocal<Cache>() {
-                    @Override
-                    protected Cache initialValue() {
-                        return new Cache();
-                    }
-                };
-                cache.put(userId, threadLocalCache);
-            }
-            Cache c = threadLocalCache.get();
-            if (c.instanceCounter == 0) {
-                c.pm = new PermissionManager(syncUser);
-            }
-            c.instanceCounter++;
-            return c.pm;
-        }
-    }
-
-    private enum RealmType {
-        DEFAULT_PERMISSION_REALM("__wildcardpermissions", true),
-        PERMISSION_REALM("__permission", false),
-        MANAGEMENT_REALM("__management", false);
-
-        private final String name;
-        private final boolean globalRealm;
-
-        RealmType(String realmName, boolean globalRealm) {
-            this.name = realmName;
-            this.globalRealm = globalRealm;
-        }
-
-        public String getName() {
-            return name;
-        }
-
-        public boolean isGlobalRealm() {
-            return globalRealm;
-        }
-    }
-
-    private final SyncUser user;
-
-    // Used to track the lifecycle of the PermissionManager
-    private RealmAsyncTask managementRealmOpenTask;
-    private RealmAsyncTask permissionRealmOpenTask;
-    private RealmAsyncTask defaultPermissionRealmOpenTask;
-    private boolean openInProgress = false;
-    private boolean closed;
-
-    private final long threadId;
-    private Handler handler = new Handler();
-    final SyncConfiguration managementRealmConfig;
-    final SyncConfiguration permissionRealmConfig;
-    final SyncConfiguration defaultPermissionRealmConfig;
-    private Realm permissionRealm;
-    private Realm managementRealm;
-    private Realm defaultPermissionRealm;
-
-    // Task list used to queue tasks until the underlying Realms are done opening (or failed doing so).
-    private List<PermissionManagerTask> delayedTasks = new ArrayList<>();
-
-    // List of tasks that are being processed. Used to keep strong references for listeners to work.
-    // The task must remove itself from this list once it either completes
-    // or fails.
-    private List<RealmAsyncTask> activeTasks = new ArrayList<>();
-
-    // Object Server Errors might be reported on another thread than the one running this PermissionManager
-    // In order to prevent race conditions, all blocks of code that read/write these errors should do
-    // so while holding the errorLock
-    private final Object errorLock = new Object();
-    private volatile ObjectServerError permissionRealmError = null;
-    private volatile ObjectServerError managementRealmError = null;
-    private volatile ObjectServerError defaultPermissionRealmError = null;
-
-    // A client reset was encountered in one of the Realms.
-    // This has invalidated the PermissionManager and it must be closed as soon as possible.
-    // This flag purely used to be able to send a proper error message to users.
-    private boolean clientReset = false;
-
-
-    // Cached result of the permission query. This will be filled, once the first PermissionAsyncTask has loaded
-    // the result.
-    private RealmResults<Permission> userPermissions;
-    private RealmResults<Permission> defaultPermissions;
-    private RealmResults<PermissionOffer> offers;
-
-    /**
-     * Creates a PermissionManager for the given user.
-     *
-     * This class is thread confined, so thread safety is not a concern since all internal
-     * communication is routed through the original Handler thread.
-     *
-     * @param user user to create manager for.
-     */
-    private PermissionManager(SyncUser user) {
-        this.user = user;
-        threadId = Thread.currentThread().getId();
-        managementRealmConfig = user.createConfiguration(getRealmUrl(RealmType.MANAGEMENT_REALM, user.getAuthenticationUrl()))
-                .fullSynchronization()
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        synchronized (errorLock) {
-                            managementRealmError = error;
-                        }
-                    }
-                })
-                .modules(new ManagementModule())
-                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
-                .build();
-
-        permissionRealmConfig = user.createConfiguration(getRealmUrl(RealmType.PERMISSION_REALM, user.getAuthenticationUrl()))
-                .fullSynchronization()
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        RealmLog.error("Error in __permission:\n" + error.toString());
-                        synchronized (errorLock) {
-                            permissionRealmError = error;
-                        }
-                    }
-                })
-                .modules(new PermissionModule())
-                .waitForInitialRemoteData()
-                 // .readOnly() Temporarily disabled due to issues with ROS 3.0.0-alpha.X
-                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
-                .build();
-
-        defaultPermissionRealmConfig = user.createConfiguration(getRealmUrl(RealmType.DEFAULT_PERMISSION_REALM, user.getAuthenticationUrl()))
-                .fullSynchronization()
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        RealmLog.error("Error in __wildcardpermissions:\n" + error.toString());
-                        synchronized (errorLock) {
-                            defaultPermissionRealmError = error;
-                        }
-                    }
-                })
-                .modules(new PermissionModule())
-                .waitForInitialRemoteData()
-                .readOnly()
-                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
-                .build();
-    }
-
-    /**
-     * Retrieves the list of permissions for all Realms available to this user.
-     *
-     * @param callback callback notified when the permissions are ready. The returned {@link RealmResults} is a fully
-     * live query result, that will be auto-updated like any other {@link RealmResults}.
-     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
-     */
-    public RealmAsyncTask getPermissions(PermissionsCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        return addTask(new GetPermissionsAsyncTask(this, callback));
-    }
-
-    /**
-     * NOTE: Moved out of the public API until we know for sure how this is going to work.
-     *
-     * Returns default permissions for all Realms. The default permissions are the ones that will be used if no
-     * user specific permissions is in effect.
-     *
-     * @param callback callback notified when the permissions are ready. The returned {@link RealmResults} is a fully
-     * live query result, that will be auto-updated like any other {@link RealmResults}.
-     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
-     */
-    public RealmAsyncTask getDefaultPermissions(PermissionsCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        return addTask(new GetDefaultPermissionsAsyncTask(this, callback));
-    }
-
-    /**
-     * Applies a given set of permissions to a Realm.
-     * <p>
-     * A {@link PermissionRequest} object encapsulates a description of which users are granted what
-     * {@link io.realm.permissions.AccessLevel}s for which Realm(s).
-     * <p>
-     * Once the request is successfully handled, a {@link Permission} entry is created in each user's
-     * {@link PermissionManager} and can be found using {@link PermissionManager#getPermissions(PermissionsCallback)}.
-     *
-     * @param request request object describing which permissions to grant and to what Realm(s).
-     * @param callback callback when the request either succeeded or failed.
-     * @return async task representing the request. This can be used to cancel it if needed.
-     */
-    public RealmAsyncTask applyPermissions(PermissionRequest request, ApplyPermissionsCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        return addTask(new ApplyPermissionTask(this, request, callback));
-    }
-
-    /**
-     * Makes a permission offer to users. The offer is represented by an offer token and the permission changes
-     * described in the {@link PermissionOffer} do not take effect until the offer has been accepted by a user
-     * calling {@link #acceptOffer(String, AcceptOfferCallback)}.
-     * <p>
-     * A permission offer can be used as a flexible way of sharing Realms with other users that might not be known at the time
-     * of making the offer as well as enabling sharing across other channels like e-mail. If a specific user should be
-     * granted access, using {@link #applyPermissions(PermissionRequest, ApplyPermissionsCallback)} will be faster and quicker.
-     * <p>
-     * An offer can be accepted by multiple users.
-     *
-     * @param callback callback to be notified with the offer token once it is ready.
-     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
-     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
-     * documentation.
-     * @see <a href="https://realm.io/docs/java/latest/#modifying-permissions">Modifying permissions</a> for a more
-     * high level description.
-     */
-    public RealmAsyncTask makeOffer(PermissionOffer offer, MakeOfferCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        if (offer.isOfferCreated()) {
-            throw new IllegalStateException("Offer has already been created: " + offer);
-        }
-        return addTask(new MakeOfferAsyncTask(this, offer, callback));
-    }
-
-    /**
-     * Accepts a permission offer sent by another user. Once this offer is accepted successfully, the permissions
-     * described by the token will be granted.
-     *
-     * @param offerToken token representing the permission offer.
-     * @param callback with the permission details that were accepted.
-     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
-     */
-    public RealmAsyncTask acceptOffer(String offerToken, AcceptOfferCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        if (Util.isEmptyString(offerToken)) {
-            throw new IllegalArgumentException("Non-empty 'offerToken' required.");
-        }
-        return addTask(new AcceptOfferAsyncTask(this, offerToken, callback));
-    }
-
-    /**
-     * Revokes an existing offer. This will prevent any other users from accepting it. Users that already accepted it,
-     * will not be affected. Revocation cannot happen until the device has talked to the server. The callback will
-     * not be notified until this has happened.
-     *
-     * @param offerToken token that should be revoked.
-     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
-     */
-    public RealmAsyncTask revokeOffer(String offerToken, RevokeOfferCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        return addTask(new RevokeOfferAsyncTask(this, offerToken, callback));
-    }
-
-    /**
-     * Returns the list of offers created by this user. These offers can be revoked again by calling
-     * {@link #revokeOffer(String, RevokeOfferCallback)} or sent to other users by sending the
-     * {@link PermissionOffer#getToken()}.
-     *
-     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
-     */
-    public RealmAsyncTask getCreatedOffers(OffersCallback callback) {
-        checkIfValid();
-        checkCallbackNotNull(callback);
-        return addTask(new GetOffersAsyncTask(this, callback));
-    }
-
-    // Queue the task if the underlying Realms are not ready yet, otherwise
-    // start the task by sending it to this thread handler. This is done
-    // in order to be able to provide the user with a RealmAsyncTask representation
-    // of the work being done.
-    private RealmAsyncTask addTask(PermissionManagerTask task) {
-        if (isReady()) {
-            activateTask(task);
-        } else {
-            delayTask(task);
-            openRealms();
-        }
-
-        return task;
-    }
-
-    // Park the task until all underlying Realms are ready
-    private void delayTask(PermissionManagerTask task) {
-        delayedTasks.add(task);
-    }
-
-    // Run any tasks that were delayed while the underlying Realms were being opened.
-    // PRECONDITION: Underlying Realms are no longer in the process of being opened.
-    private void runDelayedTasks() {
-        for (PermissionManagerTask delayedTask : delayedTasks) {
-            activateTask(delayedTask);
-        }
-        delayedTasks.clear();
-    }
-
-    // Activate a task. All tasks are controlled by the Handler in order to make it asynchronous.
-    // PRECONDITION: Underlying Realms are no longer in the process of being opened.
-    private void activateTask(PermissionManagerTask task) {
-        activeTasks.add(task);
-        handler.post(task);
-    }
-
-    // Open all underlying Realms asynchronously. Once they are all ready, all tasks added in the meantime are
-    // started. Any error will be reported through the `Callback.onError` callback if the Realms failed to open
-    // correctly.
-    private void openRealms() {
-        if (!openInProgress) {
-            openInProgress = true;
-            managementRealmOpenTask = Realm.getInstanceAsync(managementRealmConfig, new Realm.Callback() {
-                @Override
-                public void onSuccess(Realm realm) {
-                    managementRealm = realm;
-                    managementRealmOpenTask = null;
-                    checkIfRealmsAreOpenedAndRunDelayedTasks();
-                }
-
-                @Override
-                public void onError(Throwable exception) {
-                    synchronized (errorLock) {
-                        managementRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
-                        managementRealmOpenTask = null;
-                        checkIfRealmsAreOpenedAndRunDelayedTasks();
-                    }
-                }
-            });
-            permissionRealmOpenTask = Realm.getInstanceAsync(permissionRealmConfig, new Realm.Callback() {
-                @Override
-                public void onSuccess(Realm realm) {
-                    permissionRealm = realm;
-                    permissionRealmOpenTask = null;
-                    checkIfRealmsAreOpenedAndRunDelayedTasks();
-                }
-
-                @Override
-                public void onError(Throwable exception) {
-                    synchronized (errorLock) {
-                        permissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
-                        permissionRealmOpenTask = null;
-                        checkIfRealmsAreOpenedAndRunDelayedTasks();
-                    }
-                }
-            });
-            defaultPermissionRealmOpenTask = Realm.getInstanceAsync(defaultPermissionRealmConfig, new Realm.Callback() {
-                @Override
-                public void onSuccess(Realm realm) {
-                    defaultPermissionRealm = realm;
-                    defaultPermissionRealmOpenTask = null;
-                    checkIfRealmsAreOpenedAndRunDelayedTasks();
-                }
-
-                @Override
-                public void onError(Throwable exception) {
-                    synchronized (errorLock) {
-                        defaultPermissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
-                        defaultPermissionRealmOpenTask = null;
-                        checkIfRealmsAreOpenedAndRunDelayedTasks();
-                    }
-                }
-            });
-        }
-    }
-
-    private void checkIfRealmsAreOpenedAndRunDelayedTasks() {
-        synchronized (errorLock) {
-            if ((permissionRealm != null || permissionRealmError != null)
-                && (defaultPermissionRealm != null || defaultPermissionRealmError != null)
-                && (managementRealm != null || managementRealmError != null)) {
-                openInProgress = false;
-                runDelayedTasks();
-            }
-        }
-    }
-
-    private void checkCallbackNotNull(PermissionManagerBaseCallback callback) {
-        //noinspection ConstantConditions
-        if (callback == null) {
-            throw new IllegalArgumentException("Non-null 'callback' required.");
-        }
-    }
-
-    private boolean isReady() {
-        return managementRealm != null && permissionRealm != null && defaultPermissionRealm != null;
-    }
-
-    private void checkIfValid() {
-        // Checks if we are in thread that created the PermissionManager.
-        if (threadId != Thread.currentThread().getId()) {
-            throw new IllegalStateException("PermissionManager was accessed from the wrong thread. It can only be " +
-                                            "accessed on the thread it was created on.");
-        }
-
-        if (closed) {
-            throw new IllegalStateException("PermissionManager has been closed. No further actions are possible.");
-        }
-    }
-
-    /**
-     * Closes the PermissionManager as well as any underlying Realms.
-     * Any active tasks in progress will be canceled.
-     */
-    @Override
-    public void close() {
-        checkIfValid();
-
-        // Multiple instances open, just decrement the reference count
-        synchronized (cacheLock) {
-            Cache cache = PermissionManager.cache.get(user.getIdentity()).get();
-            if (cache.instanceCounter > 1) {
-                cache.instanceCounter--;
-                return;
-            }
-
-            // Only one instance open. Do a full close
-            cache.instanceCounter = 0;
-            cache.pm = null;
-        }
-        closed = true;
-        delayedTasks.clear();
-
-        // If Realms are still being opened, abort that task
-        if (managementRealmOpenTask != null) {
-            managementRealmOpenTask.cancel();
-            managementRealmOpenTask = null;
-        }
-        if (permissionRealmOpenTask != null) {
-            permissionRealmOpenTask.cancel();
-            permissionRealmOpenTask = null;
-        }
-        if (defaultPermissionRealmOpenTask != null) {
-            defaultPermissionRealmOpenTask.cancel();
-            defaultPermissionRealmOpenTask = null;
-        }
-
-        // If Realms are opened. Close them.
-        if (managementRealm != null) {
-            managementRealm.close();
-        }
-
-        if (permissionRealm != null) {
-            permissionRealm.close();
-        }
-        if (defaultPermissionRealm != null) {
-            defaultPermissionRealm.close();
-        }
-    }
-
-    /**
-     * Checks if this PermissionManager is closed or not. If it is closed, all methods will report back an error.
-     *
-     * @return {@code true} if the PermissionManager is closed, {@code false} if it is still open.
-     */
-    public boolean isClosed() {
-        // Don't use `checkIfValid()` as it throws because closed might be false.
-        if (threadId != Thread.currentThread().getId()) {
-            throw new IllegalStateException("PermissionManager was accessed from the wrong thread. It can only be " +
-                    "accessed on the thread it was created on.");
-        }
-        return closed;
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        if (!closed) {
-            RealmLog.warn("PermissionManager was not correctly closed before being finalized.");
-        }
-        super.finalize();
-    }
-
-    // Creates the URL to the permission/management Realm based on the authentication URL.
-    private static String getRealmUrl(RealmType type, URL authUrl) {
-        String scheme = "realm";
-        if (authUrl.getProtocol().equalsIgnoreCase("https")) {
-            scheme = "realms";
-        }
-        try {
-            String path = (type.isGlobalRealm() ? "/" : "/~/") + type.getName();
-            return new URI(scheme, authUrl.getUserInfo(), authUrl.getHost(), authUrl.getPort(), path, null, null).toString();
-        } catch (URISyntaxException e) {
-            throw new IllegalArgumentException("Could not create URL to the " + type + " Realm", e);
-        }
-    }
-
-    // Task responsible for loading the Permissions result and returning it to the user.
-    // The Permission result is not considered available until the query has completed.
-    private class GetPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
-
-        private final PermissionsCallback callback;
-        // Prevent permissions from being GC'ed until fully loaded.
-        private RealmResults<Permission> loadingPermissions;
-
-        GetPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
-            super(permissionManager, callback);
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) { return; }
-            if (userPermissions != null) {
-                // Permissions already loaded
-                notifyCallbackWithSuccess(userPermissions);
-            } else {
-                // TODO Right now multiple getPermission() calls will result in multiple
-                // queries being executed. The first one to return will be the one returned
-                // by all callbacks.
-                loadingPermissions = permissionRealm.where(Permission.class).findAllAsync();
-                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
-                    @Override
-                    public void onChange(RealmResults <Permission> loadedPermissions) {
-                        // Don't report ready until both __permission and __management Realm are there
-                        if (loadedPermissions.size() > 1) {
-                            loadingPermissions.removeChangeListener(this);
-                            loadingPermissions = null;
-                            if (checkAndReportInvalidState()) { return; }
-                            if (userPermissions == null) {
-                                userPermissions = loadedPermissions;
-                            }
-                            notifyCallbackWithSuccess(userPermissions);
-                        }
-                    }
-                });
-            }
-        }
-
-        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
-            try {
-                callback.onSuccess(permissions);
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-    }
-
-    // Task responsible for loading the Default Permissions result and returning it to the user.
-    // The Permission result is not considered available until the query has completed.
-    private class GetDefaultPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
-
-        private final PermissionsCallback callback;
-        // Prevent permissions from being GC'ed until fully loaded.
-        private RealmResults<Permission> loadingPermissions;
-
-        GetDefaultPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
-            super(permissionManager, callback);
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) { return; }
-            if (defaultPermissions != null) {
-                notifyCallbackWithSuccess(defaultPermissions);
-            } else {
-                // Start loading permissions.
-                // TODO Right now multiple getPermission() calls will result in multiple
-                // queries being executed. The first one to return will be the one returned
-                // by all callbacks.
-                loadingPermissions = defaultPermissionRealm.where(Permission.class).findAllAsync();
-                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
-                    @Override
-                    public void onChange(RealmResults <Permission> loadedPermissions) {
-                        // Wildcard permissions should contain 1 Realm as the default, namely __wildcardpermissions
-                        if (loadedPermissions.size() > 0) {
-                            loadingPermissions.removeChangeListener(this);
-                            if (checkAndReportInvalidState()) { return; }
-                            if (defaultPermissions == null) {
-                                defaultPermissions = loadedPermissions;
-                            }
-                            notifyCallbackWithSuccess(defaultPermissions);
-                        }
-                    }
-                });
-            }
-        }
-
-        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
-            try {
-               callback.onSuccess(permissions);
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-    }
-
-    // Class encapsulating setting a Permission by writing a PermissionChange and waiting for it to
-    // be processed.
-    private class ApplyPermissionTask extends PermissionManagerTask<Void> {
-
-        private final PermissionChange unmanagedChangeRequest;
-        private final ApplyPermissionsCallback callback;
-        private final String changeRequestId;
-        private PermissionChange managedChangeRequest;
-        private RealmAsyncTask transactionTask;
-
-        public ApplyPermissionTask(PermissionManager manager, PermissionRequest request, ApplyPermissionsCallback callback) {
-            super(manager, callback);
-            this.unmanagedChangeRequest = PermissionChange.fromRequest(request);
-            this.changeRequestId = unmanagedChangeRequest.getId();
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) {
-                return;
-            }
-
-            // Save PermissionChange object. It will be synchronized to the server where it will be processed.
-            Realm.Transaction transaction = new Realm.Transaction() {
-                @Override
-                public void execute(Realm realm) {
-                    if (checkAndReportInvalidState()) { return; }
-                    realm.insertOrUpdate(unmanagedChangeRequest);
-                }
-            };
-
-            // If the PermissionChange was successfully written to Realm, we need to wait for it to be processed.
-            // Register a ChangeListener on the object and wait for the proper response code, which can then be
-            // converted to a proper response to the user.
-            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
-                @Override
-                public void onSuccess() {
-                    if (checkAndReportInvalidState()) { return; }
-
-                    // Find PermissionChange object we just added
-                    managedChangeRequest = managementRealm.where(PermissionChange.class)
-                            .equalTo("id", changeRequestId)
-                            .findFirstAsync();
-
-
-                    // Wait for it to be processed
-                    RealmObject.addChangeListener(managedChangeRequest, new RealmChangeListener<PermissionChange>() {
-                        @Override
-                        public void onChange(PermissionChange permissionChange) {
-                            if (checkAndReportInvalidState()) {
-                                RealmObject.removeChangeListener(managedChangeRequest, this);
-                                return;
-                            }
-                            handleServerStatusChanges(permissionChange, new Runnable() {
-                                @Override
-                                public void run() {
-                                    notifyCallbackWithSuccess();
-                                }
-                            });
-                        }
-                    });
-                }
-            };
-
-            // Critical error: The PermissionChange could not be written to the Realm.
-            // Report it back to the user.
-            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
-                @Override
-                public void onError(Throwable error) {
-                    if (checkAndReportInvalidState()) { return; }
-                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
-                }
-            };
-
-            // Run
-            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
-        }
-
-        void notifyCallbackWithSuccess() {
-            try {
-                callback.onSuccess();
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-
-        @Override
-        public void cancel() {
-            super.cancel();
-            if (transactionTask != null) {
-                cancel();
-            }
-        }
-    }
-
-    private class MakeOfferAsyncTask extends PermissionManagerTask<String> {
-
-        private final PermissionOffer unmanagedOffer;
-        private final String offerId;
-        private final MakeOfferCallback callback;
-        private PermissionOffer managedOffer;
-        private RealmAsyncTask transactionTask;
-
-        public MakeOfferAsyncTask(PermissionManager permissionManager, PermissionOffer offer, MakeOfferCallback callback) {
-            super(permissionManager, callback);
-            this.unmanagedOffer = offer;
-            this.offerId = offer.getId();
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) {
-                return;
-            }
-
-            // Save PermissionOffer object. It will be synchronized to the server where it will be processed.
-            Realm.Transaction transaction = new Realm.Transaction() {
-                @Override
-                public void execute(Realm realm) {
-                    if (checkAndReportInvalidState()) { return; }
-                    realm.insertOrUpdate(unmanagedOffer);
-                }
-            };
-
-            // If the PermissionOffer was successfully written to Realm, we need to wait for it to be processed.
-            // Register a ChangeListener on the object and wait for the proper response code, which can then be
-            // converted to a proper response to the user.
-            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
-                @Override
-                public void onSuccess() {
-                    if (checkAndReportInvalidState()) { return; }
-
-                    // Find PermissionChange object we just added
-                    // Wait for it to be processed
-                    managedOffer = managementRealm.where(PermissionOffer.class).equalTo("id", offerId).findFirstAsync();
-                    RealmObject.addChangeListener(managedOffer, new RealmChangeListener<PermissionOffer>() {
-                        @Override
-                        public void onChange(final PermissionOffer permissionOffer) {
-                            if (checkAndReportInvalidState()) {
-                                RealmObject.removeChangeListener(managedOffer, this);
-                                return;
-                            }
-                            handleServerStatusChanges(permissionOffer, new Runnable() {
-                                @Override
-                                public void run() {
-                                    notifyCallbackWithSuccess(permissionOffer.getToken());
-                                }
-                            });
-                        }
-                    });
-                }
-            };
-
-            // Critical error: The PermissionChange could not be written to the Realm.
-            // Report it back to the user.
-            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
-                @Override
-                public void onError(Throwable error) {
-                    if (checkAndReportInvalidState()) { return; }
-                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
-                }
-            };
-
-            // Run
-            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
-        }
-
-        void notifyCallbackWithSuccess(String token) {
-            try {
-                callback.onSuccess(token);
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-
-        @Override
-        public void cancel() {
-            super.cancel();
-            if (transactionTask != null) {
-                transactionTask.cancel();
-                transactionTask = null;
-            }
-        }
-    }
-
-    private class AcceptOfferAsyncTask extends PermissionManagerTask<Permission> {
-
-        private final PermissionOfferResponse unmanagedResponse;
-        private final String responseId;
-        private final AcceptOfferCallback callback;
-        private PermissionOfferResponse managedResponse;
-        private RealmAsyncTask transactionTask;
-        public RealmResults<Permission> grantedPermissionResults;
-
-        public AcceptOfferAsyncTask(PermissionManager permissionManager, String offerToken, AcceptOfferCallback callback) {
-            super(permissionManager, callback);
-            this.unmanagedResponse = new PermissionOfferResponse(offerToken);
-            this.responseId = unmanagedResponse.getId();
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) {
-                return;
-            }
-
-            // Save response object. It will be synchronized to the server where it will be processed.
-            Realm.Transaction transaction = new Realm.Transaction() {
-                @Override
-                public void execute(Realm realm) {
-                    if (checkAndReportInvalidState()) { return; }
-                    realm.insertOrUpdate(unmanagedResponse);
-                }
-            };
-
-            // If the response was successfully written to Realm, we need to wait for it to be processed.
-            // Register a ChangeListener on the object and wait for the proper response code, which can then be
-            // converted to a proper response to the user.
-            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
-                @Override
-                public void onSuccess() {
-                    if (checkAndReportInvalidState()) { return; }
-
-                    // Find PermissionOffer object we just added
-                    // Wait for it to be processed
-                    managedResponse = managementRealm.where(PermissionOfferResponse.class).equalTo("id", responseId).findFirstAsync();
-                    RealmObject.addChangeListener(managedResponse, new RealmChangeListener<PermissionOfferResponse>() {
-                        @Override
-                        public void onChange(final PermissionOfferResponse response) {
-                            if (checkAndReportInvalidState()) {
-                                RealmObject.removeChangeListener(managedResponse, this);
-                                return;
-                            }
-                            handleServerStatusChanges(response, new Runnable() {
-                                @Override
-                                public void run() {
-                                    grantedPermissionResults = permissionRealm.where(Permission.class).equalTo("path", response.getPath()).findAllAsync();
-                                    grantedPermissionResults.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
-                                        @Override
-                                        public void onChange(RealmResults<Permission> permissions) {
-                                            if (!permissions.isEmpty()) {
-                                                grantedPermissionResults.removeChangeListener(this);
-                                                //noinspection ConstantConditions
-                                                notifyCallbackWithSuccess(managedResponse.getRealmUrl(), permissions.first());
-                                            }
-                                        }
-                                    });
-                                }
-                            });
-                        }
-                    });
-                }
-            };
-
-            // Critical error: The PermissionChange could not be written to the Realm.
-            // Report it back to the user.
-            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
-                @Override
-                public void onError(Throwable error) {
-                    if (checkAndReportInvalidState()) { return; }
-                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
-                }
-            };
-
-            // Run
-            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
-        }
-
-        void notifyCallbackWithSuccess(String url, Permission permission) {
-            try {
-                callback.onSuccess(url, permission);
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-
-        @Override
-        public void cancel() {
-            super.cancel();
-            if (transactionTask != null) {
-                transactionTask.cancel();
-                transactionTask = null;
-            }
-        }
-    }
-
-    // Class encapsulating all async tasks exposed by the PermissionManager.
-    // Made package protected instead of private to facilitate testing
-    // IMPORTANT:
-    // - All subclasses are responsible for removing themselves from the activeTaskList when done.
-    // - All callbacks should start by checking `if (checkAndReportInvalidState()) { return; }`
-    //   This will abort the task if it was canceled or failed. It will also remove the task from the activeTaskList.
-    abstract static class PermissionManagerTask<T> implements RealmAsyncTask, Runnable {
-
-        private final PermissionManagerBaseCallback callback;
-        private final PermissionManager permissionManager;
-        private volatile boolean canceled = false;
-        private static final String ERROR_MESSAGE_CLIENT_RESET = "The PermissionManager " +
-                "has been invalidated due to a server conflict. No further tasks can be scheduled. " +
-                "The app needs to be restarted to allow the PermissionManager to work again.";
-
-        public PermissionManagerTask(PermissionManager permissionManager, PermissionManagerBaseCallback callback) {
-            this.callback = callback;
-            this.permissionManager = permissionManager;
-        }
-
-        @Override
-        public abstract void run();
-
-        @Override
-        public void cancel() {
-            canceled = true;
-        }
-
-        @Override
-        public boolean isCancelled() {
-            return canceled;
-        }
-
-        /**
-         * Checks if we are in a state where we are not allowed to continue executing.
-         * If an invalid state is encountered, it will be reported to the error callback.
-         *
-         * This method will return {@code true} if an invalid state was encountered, {@code false}
-         * if it looks ok to continue.
-
-         * @return {@code true} if in a invalid state, {@code false} if in a valid one.
-         */
-        protected final boolean checkAndReportInvalidState() {
-            if (isCancelled()) {
-                permissionManager.activeTasks.remove(this);
-                return true;
-            }
-            // Closed check need to work around thread confinement
-            if (permissionManager.closed) {
-                ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN,
-                        new IllegalStateException("PermissionManager has been closed"));
-                notifyCallbackWithError(error); // This will remove the task from the task list
-                return true;
-            }
-            if (permissionManager.clientReset) {
-                ObjectServerError error = new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET);
-                notifyCallbackWithError(error);
-                return true;
-            }
-
-            // We are juggling three different Realms. If only one fail, expose that error directly.
-            // Otherwise try to sensible join the three error messages before returning it to the user.
-            boolean managementErrorHappened;
-            boolean permissionErrorHappened;
-            boolean defaultPermissionErrorHappened;
-            ObjectServerError managementError;
-            ObjectServerError permissionError;
-            ObjectServerError defaultPermissionError;
-
-            // Only hold lock while making a safe copy of current error state
-            synchronized (permissionManager.errorLock) {
-
-                // Check if errors are only intermittent. In that case, just ignore them as
-                // we expect them to resolve eventually. So no reason to cause extra work for
-                // users of the PermissionManager.
-                if (permissionManager.managementRealmError != null && isIntermittentError(permissionManager.managementRealmError)) {
-                    RealmLog.debug("Ignore Management Realm error: " + permissionManager.managementRealmError.toString());
-                    permissionManager.managementRealmError = null;
-                }
-                if (permissionManager.permissionRealmError != null && isIntermittentError(permissionManager.permissionRealmError)) {
-                    RealmLog.debug("Ignore Permission Realm error: " + permissionManager.permissionRealmError.toString());
-                    permissionManager.permissionRealmError = null;
-                }
-                if (permissionManager.defaultPermissionRealmError != null && isIntermittentError(permissionManager.defaultPermissionRealmError)) {
-                    RealmLog.debug("Ignore Default Permission Realm error: " + permissionManager.defaultPermissionRealmError.toString());
-                    permissionManager.defaultPermissionRealmError = null;
-                }
-
-                managementErrorHappened = (permissionManager.managementRealmError != null);
-                permissionErrorHappened = (permissionManager.permissionRealmError != null);
-                defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
-                managementError = permissionManager.managementRealmError;
-                permissionError = permissionManager.permissionRealmError;
-                defaultPermissionError = permissionManager.defaultPermissionRealmError;
-            }
-
-            // Everything seems valid
-            if (!permissionErrorHappened && !managementErrorHappened && !defaultPermissionErrorHappened) {
-                return false;
-            }
-
-            // Handle Client Reset if it happened in any of the Realms.
-            // A Client Reset is a fatal error for the PermissionManager, so all current and
-            // future tasks will exit as soon as possible after this event happened and report it
-            // through the error callback. Only action a user can take is to close the
-            // PermissionManager and re-open it again. Some data might be lost (like permission
-            // offers not yet processed). This is currently unavoidable.
-            // TODO: Eventually we might be able to recover the permission manager from this event
-            // but it will require some serious task management as we would need to do a full
-            // close, reschedule all tasks, and re-open behind users back. This is out of scope for
-            // now.
-            if (managementErrorHappened && managementError instanceof ClientResetRequiredError) {
-                ClientResetRequiredError cr = (ClientResetRequiredError) managementError;
-                permissionManager.managementRealm.close();
-                cr.executeClientReset();
-                permissionManager.clientReset = true;
-            }
-
-            if (permissionErrorHappened && permissionError instanceof ClientResetRequiredError) {
-                ClientResetRequiredError cr = (ClientResetRequiredError) permissionError;
-                permissionManager.permissionRealm.close();
-                cr.executeClientReset();
-                permissionManager.clientReset = true;
-            }
-
-            if (defaultPermissionErrorHappened && defaultPermissionError instanceof ClientResetRequiredError) {
-                ClientResetRequiredError cr = (ClientResetRequiredError) defaultPermissionError;
-                permissionManager.defaultPermissionRealm.close();
-                cr.executeClientReset();
-                permissionManager.clientReset = true;
-            }
-
-            // Handle errors
-            Map<String, ObjectServerError> errors = new LinkedHashMap<>();
-            if (permissionManager.clientReset) {
-                errors.put("ClientReset", new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET));
-            } else {
-                if (managementErrorHappened) { errors.put("Management Realm", managementError); }
-                if (permissionErrorHappened) { errors.put("Permission Realm", permissionError); }
-                if (defaultPermissionErrorHappened) { errors.put("Default Permission Realm", defaultPermissionError); }
-            }
-            notifyCallbackWithError(combineRealmErrors(errors)); // This will remove the task from the task list
-
-            return true;
-        }
-
-        private boolean isIntermittentError(@Nullable ObjectServerError error) {
-            // Unknown errors normally have a undefined category as well. All serious errors
-            // should already be covered by known categories, so expect unknown categories
-            // to be intermittent.
-            if (error == null || error.getErrorCode() == ErrorCode.UNKNOWN) {
-                return true;
-            }
-
-            switch (error.getErrorType()) {
-                case ErrorCode.Type.CONNECTION:
-                case ErrorCode.Type.HTTP:
-                case ErrorCode.Type.MISC:
-                case ErrorCode.Type.UNKNOWN:
-                    return true;
-
-                case ErrorCode.Type.AUTH:
-                case ErrorCode.Type.DEPRECATED:
-                case ErrorCode.Type.JAVA:
-                case ErrorCode.Type.PROTOCOL:
-                case ErrorCode.Type.SESSION:
-                default:
-                    return false;
-            }
-        }
-
-        /**
-         * Handle the status change from ROS and either call error or success callbacks.
-         */
-        protected void handleServerStatusChanges(BasePermissionApi obj, Runnable onSuccessDelegate) {
-            Integer statusCode = obj.getStatusCode();
-            if (statusCode != null) {
-                RealmObject.removeAllChangeListeners(obj);
-                if (statusCode > 0) {
-                    ErrorCode errorCode = ErrorCode.fromNativeError(ErrorCode.Type.AUTH, statusCode);
-                    String errorMsg = obj.getStatusMessage();
-                    ObjectServerError error = new ObjectServerError(errorCode, errorMsg);
-                    notifyCallbackWithError(error);
-                } else if (statusCode == 0) {
-                    onSuccessDelegate.run();
-                } else {
-                    ErrorCode errorCode = ErrorCode.UNKNOWN;
-                    String errorMsg = "Illegal status code: " + statusCode;
-                    ObjectServerError error = new ObjectServerError(errorCode, errorMsg);
-                    notifyCallbackWithError(error);
-                }
-            }
-        }
-
-        protected final void notifyCallbackWithError(ObjectServerError e) {
-            RealmLog.debug("Error happened in PermissionManager for %s: %s",
-                    permissionManager.user.getIdentity(), e.toString());
-            try {
-                callback.onError(e);
-            } finally {
-                permissionManager.activeTasks.remove(this);
-            }
-        }
-
-        // Combine error messages. If they have the same ErrorCode, it will be re-used, otherwise
-        // we are forced to report back UNKNOWN as error code. The real error codes
-        // will be always part of the exception message.
-        private ObjectServerError combineRealmErrors(Map<String, ObjectServerError> errors) {
-            String errorMsg = combineErrorMessage(errors);
-            ErrorCode errorCode = combineErrorCodes(errors);
-            return new ObjectServerError(errorCode, errorMsg);
-        }
-
-        // Combine the text based error message from two ObjectServerErrrors.
-        private String combineErrorMessage(Map<String, ObjectServerError> errors) {
-            boolean multipleErrors = errors.size() > 1;
-            StringBuilder errorMsg = new StringBuilder(multipleErrors ? "Multiple errors occurred: " : "Error occurred in Realm: ");
-            for (Map.Entry<String, ObjectServerError> entry : errors.entrySet()) {
-                errorMsg.append('\n');
-                errorMsg.append(entry.getKey());
-                errorMsg.append('\n');
-                errorMsg.append(entry.getValue().toString());
-            }
-            return errorMsg.toString();
-        }
-
-        private ErrorCode combineErrorCodes(Map<String, ObjectServerError> errors) {
-            ErrorCode finalErrorCode = null;
-            for (ObjectServerError error : errors.values()) {
-                ErrorCode errorCode = error.getErrorCode();
-                if (finalErrorCode == null) {
-                    finalErrorCode = errorCode;
-                    continue;
-                }
-                if (errorCode == finalErrorCode) {
-                    continue;
-                }
-
-                // Multiple error codes. No good way to report this.
-                // The real error codes will still be in the error text.
-                finalErrorCode = ErrorCode.UNKNOWN;
-                break;
-            }
-            return finalErrorCode;
-        }
-
-    }
-
-    // Task responsible for loading the Permissions result and returning it to the user.
-    // The Permission result is not considered available until the query has completed.
-    private class GetOffersAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
-
-        private final OffersCallback callback;
-        // Prevent permissions from being GC'ed until fully loaded.
-        private RealmResults<PermissionOffer> loadingOffers;
-
-        GetOffersAsyncTask(PermissionManager permissionManager, OffersCallback callback) {
-            super(permissionManager, callback);
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) { return; }
-            if (offers != null) {
-                notifyCallbackWithSuccess(offers);
-            } else {
-                // We only want offers that have been created.
-                loadingOffers = managementRealm.where(PermissionOffer.class)
-                        .equalTo("statusCode", 0)
-                        .findAllAsync();
-                loadingOffers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
-                    @Override
-                    public void onChange(RealmResults<PermissionOffer> loadedOffers) {
-                        loadedOffers.removeChangeListener(this);
-                        if (checkAndReportInvalidState()) { return; }
-                        if (offers == null) {
-                            offers = loadedOffers;
-                        }
-                        notifyCallbackWithSuccess(offers);
-                    }
-                });
-            }
-        }
-
-        void notifyCallbackWithSuccess(RealmResults<PermissionOffer> permissions) {
-            try {
-                callback.onSuccess(permissions);
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-    }
-
-    private class RevokeOfferAsyncTask extends PermissionManagerTask<Permission> {
-
-        private final String offerToken;
-        private final RevokeOfferCallback callback;
-        private RealmResults<PermissionOffer> matchingOffers;
-
-        public RevokeOfferAsyncTask(PermissionManager permissionManager, String offerToken, RevokeOfferCallback callback) {
-            super(permissionManager, callback);
-            this.offerToken = offerToken;
-            this.callback = callback;
-        }
-
-        @Override
-        public void run() {
-            if (checkAndReportInvalidState()) {
-                return;
-            }
-            matchingOffers = managementRealm.where(PermissionOffer.class)
-                    .equalTo("token", offerToken)
-                    .findAllAsync();
-            matchingOffers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
-                @Override
-                public void onChange(final RealmResults<PermissionOffer> offers) {
-                    if (checkAndReportInvalidState()) { return; }
-                    if (!offers.isEmpty()) {
-                        managementRealm.executeTransactionAsync(new Realm.Transaction() {
-                            @Override
-                            public void execute(Realm realm) {
-                                if (checkAndReportInvalidState()) { return; }
-                                // Make 100% sure the offer is still in the Realm.
-                                // It could have been deleted between querying for it and the
-                                // transaction running. We will still call OnSuccess if the
-                                // offer was removed by someone else.
-                                RealmResults<PermissionOffer> offers = realm.where(PermissionOffer.class)
-                                        .equalTo("token", offerToken)
-                                        .findAll();
-                                if (!offers.isEmpty()) {
-                                    offers.deleteAllFromRealm();
-                                }
-                            }
-                        }, new Realm.Transaction.OnSuccess() {
-                            @Override
-                            public void onSuccess() {
-                                // Don't notify user about success before changes have been uploaded to the server.
-                                matchingOffers.removeAllChangeListeners();
-                                if (checkAndReportInvalidState()) { return; }
-                                final SyncSession session = SyncManager.getSession(managementRealmConfig);
-                                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-                                    @Override
-                                    public void onChange(Progress progress) {
-                                        if (progress.isTransferComplete()) {
-                                            session.removeProgressListener(this);
-                                            handler.post(new Runnable() {
-                                                @Override
-                                                public void run() {
-                                                    if (checkAndReportInvalidState()) { return; }
-                                                    notifyCallbackWithSuccess();
-                                                }
-                                            });
-                                        }
-                                    }
-                                });
-                            }
-                        }, new Realm.Transaction.OnError() {
-                            @Override
-                            public void onError(Throwable error) {
-                                matchingOffers.removeAllChangeListeners();
-                                notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
-
-                            }
-                        });
-                    }
-                }
-            });
-        }
-
-        void notifyCallbackWithSuccess() {
-            try {
-                callback.onSuccess();
-            } finally {
-                activeTasks.remove(this);
-            }
-        }
-    }
-
-    private interface PermissionManagerBaseCallback {
-        /**
-         * Called if an error happened while executing the task. The PermissionManager uses different underlying Realms,
-         * and this error will report errors from all of these Realms combining them as best as possible.
-         * <p>
-         * This means that if all Realms fail with the same error code, {@link ObjectServerError#getErrorCode()} will
-         * return that error code. If the underlying Realms fail for different reasons, {@link ErrorCode#UNKNOWN} will
-         * be returned. {@link ObjectServerError#getErrorMessage()} will always contain the full description of errors
-         * including the specific error code for each underlying Realm that failed.
-         *
-         * @param error error object describing what happened.
-         */
-        void onError(ObjectServerError error);
-    }
-
-    /**
-     * Callback used when loading a set of permissions.
-     */
-    public interface PermissionsCallback extends PermissionManagerBaseCallback {
-        /**
-         * Called when all known permissions are successfully loaded.
-         * <p>
-         * These permissions will continue to synchronize with the server in the background. Register a
-         * {@link RealmChangeListener} to be notified about any further changes.
-         *
-         * @param permissions The set of currently known permissions.
-         */
-        void onSuccess(RealmResults<Permission> permissions);
-    }
-
-    /**
-     * Callback used when modifying or creating new permissions.
-     */
-    public interface ApplyPermissionsCallback extends PermissionManagerBaseCallback {
-        /**
-         * Called when the permissions where successfully modified.
-         */
-        void onSuccess();
-    }
-
-    /**
-     * Callback used when making a permission offer for other users.
-     */
-    public interface MakeOfferCallback extends PermissionManagerBaseCallback {
-        /**
-         * Called when the offer was successfully created.
-         *
-         * @param offerToken token representing the offer that can be sent to other users.
-         */
-        void onSuccess(String offerToken);
-    }
-
-    /**
-     * Callback used when accepting a permission offer.
-     */
-    public interface AcceptOfferCallback extends PermissionManagerBaseCallback {
-        /**
-         * Called when the offer was successfully accepted. This means that this user can now access this Realm.
-         *
-         * @param realmUrl The url pointing to the Realm for which the offer was created.
-         * @param permission The permissions granted.
-         */
-        void onSuccess(String realmUrl, Permission permission);
-    }
-
-    /**
-     * Callback used when loading the list of {@link PermissionOffer}'s created by the user.
-     */
-    public interface OffersCallback extends PermissionManagerBaseCallback {
-        /**
-         * Called when all known offers are successfully loaded.
-         * <p>
-         * These offers will continue to synchronize with the server in the background. Register a
-         * {@link RealmChangeListener} to be notified about any further changes.
-         *
-         * @param offers The set of currently known offers.
-         */
-        void onSuccess(RealmResults<PermissionOffer> offers);
-    }
-
-    /**
-     * Callback used when revoking an existing offer.
-     */
-    public interface RevokeOfferCallback extends PermissionManagerBaseCallback {
-        /**
-         * Called when the offer was successfully revoked successfully modified.
-         */
-        void onSuccess();
-    }
-
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index eb2c6622aa..38f08495ad 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -46,9 +46,9 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.Keep;
 import io.realm.internal.Util;
-import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.RealmObjectServer;
 import io.realm.internal.network.NetworkStateReceiver;
-import io.realm.internal.network.OkHttpAuthenticationServer;
+import io.realm.internal.network.OkHttpRealmObjectServer;
 import io.realm.log.RealmLog;
 import okhttp3.internal.tls.OkHostnameVerifier;
 
@@ -128,7 +128,7 @@ public void onError(SyncSession session, ObjectServerError error) {
 
     // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
     // Right now it just lives and dies together with the process.
-    private static volatile AuthenticationServer authServer = new OkHttpAuthenticationServer();
+    private static volatile RealmObjectServer authServer = new OkHttpRealmObjectServer();
     private static volatile UserStore userStore;
 
     // Header configuration
@@ -466,14 +466,14 @@ private static synchronized void removeSession(SyncConfiguration syncConfigurati
         return allSessions;
     }
 
-    static AuthenticationServer getAuthServer() {
+    static RealmObjectServer getAuthServer() {
         return authServer;
     }
 
     /**
      * Sets the auth server implementation used when validating credentials.
      */
-    static void setAuthServerImpl(AuthenticationServer authServerImpl) {
+    static void setAuthServerImpl(RealmObjectServer authServerImpl) {
         authServer = authServerImpl;
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index d8686a8ae4..6d0f3a04a7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -45,7 +45,7 @@
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
-import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.RealmObjectServer;
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.objectserver.Token;
@@ -741,7 +741,7 @@ private void checkNonNullListener(@Nullable Object listener) {
     }
 
     // Return the access token for the Realm this Session is connected to.
-    String getAccessToken(final AuthenticationServer authServer, String refreshToken) {
+    String getAccessToken(final RealmObjectServer authServer, String refreshToken) {
         // check first if there's a valid access_token we can return immediately
         if (getUser().isRealmAuthenticated(configuration)) {
             Token accessToken = getUser().getAccessToken(configuration);
@@ -773,7 +773,7 @@ String getAccessToken(final AuthenticationServer authServer, String refreshToken
     }
 
     // Authenticate by getting access tokens for the specific Realm
-    private void authenticateRealm(final AuthenticationServer authServer) {
+    private void authenticateRealm(final RealmObjectServer authServer) {
         if (networkRequest != null) {
             networkRequest.cancel();
         }
@@ -828,7 +828,7 @@ protected void onError(AuthenticateResponse response) {
         networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
     }
 
-    private void scheduleRefreshAccessToken(final AuthenticationServer authServer, long expireDateInMs) {
+    private void scheduleRefreshAccessToken(final RealmObjectServer authServer, long expireDateInMs) {
         onGoingAccessTokenQuery.set(true);
         // calculate the delay time before which we should refresh the access_token,
         // we adjust to 10 second to proactively refresh the access_token before the session
@@ -862,7 +862,7 @@ public void run() {
     }
 
     // Authenticate by getting access tokens for the specific Realm
-    private void refreshAccessToken(final AuthenticationServer authServer) {
+    private void refreshAccessToken(final RealmObjectServer authServer) {
         // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
         clearScheduledAccessTokenRefresh();
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 8c55cd7138..f40b33f594 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -39,15 +39,24 @@
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.network.AcceptPermissionsOfferResponse;
+import io.realm.internal.network.ApplyPermissionsResponse;
 import io.realm.internal.network.AuthenticateResponse;
-import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.RealmObjectServer;
 import io.realm.internal.network.ChangePasswordResponse;
 import io.realm.internal.network.ExponentialBackoffTask;
+import io.realm.internal.network.GetPermissionsOffersResponse;
+import io.realm.internal.network.InvalidatePermissionsOfferResponse;
 import io.realm.internal.network.LogoutResponse;
+import io.realm.internal.network.RetrievePermissionsResponse;
 import io.realm.internal.network.LookupUserIdResponse;
+import io.realm.internal.network.MakePermissionsOfferResponse;
 import io.realm.internal.network.UpdateAccountResponse;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
 
 /**
  * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
@@ -63,6 +72,7 @@
 public class SyncUser {
     private final String identity;
     private Token refreshToken;
+    private final URL baseUrl;
     private final URL authenticationUrl;
     // maps all RealmConfiguration and accessToken, using this SyncUser.
     private final Map<SyncConfiguration, Token> realms = new HashMap<SyncConfiguration, Token>();
@@ -71,6 +81,12 @@
     SyncUser(Token refreshToken, URL authenticationUrl) {
         this.identity = refreshToken.identity();
         this.authenticationUrl = authenticationUrl;
+        try {
+            this.baseUrl = new URL(authenticationUrl.getProtocol(), authenticationUrl.getHost(), authenticationUrl.getPort(), "");
+        } catch (MalformedURLException e) {
+            // Should never happen
+            throw new RuntimeException(e);
+        }
         this.refreshToken = refreshToken;
     }
 
@@ -152,7 +168,7 @@ public static SyncUser logIn(final SyncCredentials credentials, final String aut
                 boolean isAdmin = (Boolean) credentials.getUserInfo().get("_isAdmin");
                 result = AuthenticateResponse.createValidResponseWithUser(userIdentifier, token, isAdmin);
             } else {
-                final AuthenticationServer server = SyncManager.getAuthServer();
+                final RealmObjectServer server = SyncManager.getAuthServer();
                 result = server.loginUser(credentials, authUrl);
             }
             if (result.isValid()) {
@@ -335,7 +351,7 @@ public void logOut() {
             realms.clear();
 
             // Finally revoke server token. The local user is logged out in any case.
-            final AuthenticationServer server = SyncManager.getAuthServer();
+            final RealmObjectServer server = SyncManager.getAuthServer();
             // don't reference directly the refreshToken inside the revoke request
             // as it may revoke the newly acquired refresh_token
             final Token refreshTokenToBeRevoked = refreshToken;
@@ -376,7 +392,7 @@ public void changePassword(final String newPassword) throws ObjectServerError {
         if (newPassword == null) {
             throw new IllegalArgumentException("Not-null 'newPassword' required.");
         }
-        AuthenticationServer authServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = SyncManager.getAuthServer();
         ChangePasswordResponse response = authServer.changePassword(refreshToken, newPassword, getAuthenticationUrl());
         if (!response.isValid()) {
             throw response.getError();
@@ -414,7 +430,7 @@ public void changePassword(final String userId, final String newPassword) throws
                 throw new IllegalStateException("User need to be admin in order to change another user's password.");
             }
 
-            AuthenticationServer authServer = SyncManager.getAuthServer();
+            RealmObjectServer authServer = SyncManager.getAuthServer();
             ChangePasswordResponse response = authServer.changePassword(refreshToken, userId, newPassword, getAuthenticationUrl());
             if (!response.isValid()) {
                 throw response.getError();
@@ -499,7 +515,7 @@ public static void requestPasswordReset(String email, String authenticationUrl)
             throw new IllegalArgumentException("Not-null 'email' required.");
         }
         URL authUrl = getUrl(authenticationUrl);
-        AuthenticationServer authServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = SyncManager.getAuthServer();
         UpdateAccountResponse response = authServer.requestPasswordReset(email, authUrl);
         if (!response.isValid()) {
             throw response.getError();
@@ -564,7 +580,7 @@ public static void completePasswordReset(String resetToken, String newPassword,
             throw new IllegalArgumentException("Not-null 'newPassword' required.");
         }
         URL authUrl = getUrl(authenticationUrl);
-        AuthenticationServer authServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = SyncManager.getAuthServer();
         UpdateAccountResponse response = authServer.completePasswordReset(resetToken, newPassword, authUrl);
         if (!response.isValid()) {
             throw response.getError();
@@ -629,7 +645,7 @@ public static void requestEmailConfirmation(String email, String authenticationU
             throw new IllegalArgumentException("Not-null 'email' required.");
         }
         URL authUrl = getUrl(authenticationUrl);
-        AuthenticationServer authServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = SyncManager.getAuthServer();
         UpdateAccountResponse response = authServer.requestEmailConfirmation(email, authUrl);
         if (!response.isValid()) {
             throw response.getError();
@@ -690,7 +706,7 @@ public static void confirmEmail(String confirmationToken, String authenticationU
             throw new IllegalArgumentException("Not-null 'confirmationToken' required.");
         }
         URL authUrl = getUrl(authenticationUrl);
-        AuthenticationServer authServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = SyncManager.getAuthServer();
         UpdateAccountResponse response = authServer.confirmEmail(confirmationToken, authUrl);
         if (!response.isValid()) {
             throw response.getError();
@@ -761,7 +777,7 @@ public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final
             throw new IllegalArgumentException("SyncUser needs to be admin in order to lookup other users ID.");
         }
 
-        AuthenticationServer authServer = SyncManager.getAuthServer();
+        RealmObjectServer authServer = SyncManager.getAuthServer();
         LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerUserIdentity, getAuthenticationUrl());
         if (!response.isValid()) {
             if (response.getError().getErrorCode() == ErrorCode.UNKNOWN_ACCOUNT) {
@@ -928,25 +944,325 @@ private static String getManagementRealmUrl(URL authUrl) {
     }
 
     /**
-     * Returns an instance of the {@link PermissionManager} for this user that makes it possible to see, modify and create
-     * permissions related to this users Realms.
+     * Retrieves the list of permissions granted to this user. The data is fetched directly from
+     * the Realm Object Server and requires a network connection.
+     *
+     * @return the list of permissions granted to this user.
+     * @throws ObjectServerError if an error happened while trying to retrieve the list of permissions on the Realm Object Server.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
+     */
+    public List<Permission> retrieveGrantedPermissions() {
+        ObjectServerError error;
+        try {
+            final RealmObjectServer server = SyncManager.getAuthServer();
+            RetrievePermissionsResponse result = server.getPermissions(refreshToken, baseUrl);
+            if (result.isValid()) {
+                return result.getPermissions();
+            } else {
+                error = result.getError();
+            }
+        } catch (Throwable e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+    /**
+     * Retrieves the list of permissions granted to this user. The data is fetched directly from
+     * the Realm Object Server and requires a network connection.
+     *
+     * @param callback callback notified when list the permissions are ready.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     *
+     * @throws IllegalStateException if this method is called from a thread without a looper.
+     */
+    public RealmAsyncTask retrieveGrantedPermissionsAsync(Callback<List<Permission>> callback) {
+        checkLooperThread("Asynchronously retrieving permissions is only possible from looper threads.");
+        checkCallbackNotNull(callback);
+        return new Request<List<Permission>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public List<Permission> run() throws ObjectServerError {
+                return retrieveGrantedPermissions();
+            }
+        }.start();
+    }
+
+
+    /**
+     * Applies a given set of permissions to a Realm. Only a user with {@link io.realm.permissions.AccessLevel#ADMIN}
+     * privileges to the Realm can use this method.
      * <p>
-     * Every instance returned by this method must be closed by calling {@link PermissionManager#close()} when it
-     * no longer is needed.
+     * A {@link PermissionRequest} object encapsulates a description of which users are granted what
+     * {@link io.realm.permissions.AccessLevel}s for which Realm(s).
      * <p>
-     * The {@link PermissionManager} can only be opened from the main tread, calling this method from any other thread
-     * will throw an {@link IllegalStateException}.
+     * Once the request is successfully handled, a {@link Permission} entry is created for each
+     * affected user and can be found by them using {@link #retrieveGrantedPermissions()}.
+     *
+     * @param request request object describing which permissions to grant and to what Realm(s).
+     * @throws ObjectServerError if an error happened while trying to apply the permission changes on the Realm Object Server.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
+     */
+    public void applyPermissions(PermissionRequest request) {
+        ObjectServerError error;
+        try {
+            final RealmObjectServer server = SyncManager.getAuthServer();
+            ApplyPermissionsResponse result = server.applyPermissions(request, refreshToken, baseUrl);
+            if (!result.isValid()) {
+                error = result.getError();
+            } else {
+                return;
+            }
+        } catch (Exception e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+    /**
+     * Applies a given set of permissions to a Realm. Only a user with {@link io.realm.permissions.AccessLevel#ADMIN}
+     * privileges to the Realm can use this method.
+     * <p>
+     * A {@link PermissionRequest} object encapsulates a description of which users are granted what
+     * {@link io.realm.permissions.AccessLevel}s for which Realm(s).
+     * <p>
+     * Once the request is successfully handled, a {@link Permission} entry is created for each
+     * affected user and can be found by them using {@link #retrieveGrantedPermissionsAsync(Callback)}.
+     *
+     * @param request request object describing which permissions to grant and to what Realm(s).
+     * @param callback callback when the request either succeeded or failed.
+     * @return async task representing the request. This can be used to cancel it if needed.
+     *
+     * @throws IllegalStateException if this method is called from a thread without a looper.
+     */
+    public RealmAsyncTask applyPermissionsAsync(PermissionRequest request, Callback<Void> callback) {
+        checkLooperThread("Asynchronously updating  permissions is only possible from looper threads.");
+        checkCallbackNotNull(callback);
+        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public Void run() throws ObjectServerError {
+                applyPermissions(request);
+                return null;
+            }
+        }.start();
+    }
+
+    /**
+     * Makes a permissions offer to users. The offer is represented by an offer token and the permission changes
+     * described in the {@link PermissionOffer} do not take effect until the offer has been accepted by a user
+     * calling {@link #acceptPermissionsOfferAsync(String, Callback)}.
+     * <p>
+     * A permission offer can be used as a flexible way of sharing Realms with other users that might not be known at the time
+     * of making the offer as well as enabling sharing across other channels like e-mail. If a specific user should be
+     * granted access, using {@link #applyPermissionsAsync(PermissionRequest, Callback)} will be faster and quicker.
+     * <p>
+     * An offer can be accepted by multiple users.
+     *
+     * @param offer the object description the kind of permissions that should be offered to other users.
+     * @return the offer token representing the offer.
+     * @throws ObjectServerError if an error happened while trying to create the permissions offer.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+     * documentation.
+     * @see <a href="https://realm.io/docs/java/latest/#modifying-permissions">Modifying permissions</a> for a more
+     * high level description.
+     */
+    public String makePermissionsOffer(PermissionOffer offer) {
+        ObjectServerError error;
+        try {
+            final RealmObjectServer server = SyncManager.getAuthServer();
+            MakePermissionsOfferResponse result = server.makeOffer(offer, refreshToken, baseUrl);
+            if (!result.isValid()) {
+                error = result.getError();
+            } else {
+                return result.getToken();
+            }
+        } catch (Exception e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+    /**
+     * Makes a permission offer to users. The offer is represented by an offer token and the permission changes
+     * described in the {@link PermissionOffer} do not take effect until the offer has been accepted by a user
+     * calling {@link #acceptPermissionsOfferAsync(String, Callback)}.
+     * <p>
+     * A permission offer can be used as a flexible way of sharing Realms with other users that might not be known at the time
+     * of making the offer as well as enabling sharing across other channels like e-mail. If a specific user should be
+     * granted access, using {@link #applyPermissionsAsync(PermissionRequest, Callback)} will be faster and quicker.
+     * <p>
+     * An offer can be accepted by multiple users.
+     *
+     * @return the path to the Realm affected by this permission.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+     * documentation.
+     * @see <a href="https://realm.io/docs/java/latest/#modifying-permissions">Modifying permissions</a> for a more
+     * high level description.
+     *
+     * @param offer the object description the kind of permissions that should be offered to other users.
+     * @param callback callback to be notified with the offer token once it is ready.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     * @throws IllegalStateException if this method is called from a Thread without a looper.
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+     * documentation.
+     * @see <a href="https://realm.io/docs/java/latest/#modifying-permissions">Modifying permissions</a> for a more
+     * high level description.
+     */
+    public RealmAsyncTask makePermissionsOfferAsync(PermissionOffer offer, Callback<String> callback) {
+        checkLooperThread("Asynchronously making an offer is only possible from looper threads.");
+        checkCallbackNotNull(callback);
+        return new Request<String>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public String run() throws ObjectServerError {
+                return makePermissionsOffer(offer);
+            }
+        }.start();
+    }
+
+    /**
+     * Accepts a permission offer sent by another user. Once this offer is accepted successfully, the permissions
+     * described by the token will be granted.
      *
-     * @throws IllegalStateException if this method is not called from the UI thread.
-     * @return an instance of the PermissionManager.
+     * @param offerToken token representing the permission offer.
+     * @return the path to the Realm affected by the offer.
+     * @throws ObjectServerError if an error happened while trying to accept the offer.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
      */
-    public PermissionManager getPermissionManager() {
-        if (!new AndroidCapabilities().isMainThread()) {
-            throw new IllegalStateException("The PermissionManager can only be opened from the main thread.");
+    public String acceptPermissionsOffer(String offerToken) {
+        if (Util.isEmptyString(offerToken)) {
+            throw new IllegalArgumentException("Non-empty 'offerToken' required.");
+        }
+        ObjectServerError error;
+        try {
+            final RealmObjectServer server = SyncManager.getAuthServer();
+            AcceptPermissionsOfferResponse result = server.acceptOffer(offerToken, refreshToken, baseUrl);
+            if (!result.isValid()) {
+                error = result.getError();
+            } else {
+                return result.getPath();
+            }
+        } catch (Exception e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
         }
-        return PermissionManager.getInstance(this);
+        throw error;
+    }
+
+    /**
+     * Accepts a permission offer sent by another user. Once this offer is accepted successfully, the permissions
+     * described by the token will be granted.
+     *
+     * @param offerToken token representing the permission offer.
+     * @param callback with the permission details that were accepted.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     * @throws IllegalStateException if this method is called from a thread without a looper.
+     */
+    public RealmAsyncTask acceptPermissionsOfferAsync(String offerToken, Callback<String> callback) {
+        checkLooperThread("Asynchronously accepting an permissions offer is only possible from looper threads.");
+        checkCallbackNotNull(callback);
+        return new Request<String>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public String run() throws ObjectServerError {
+                return acceptPermissionsOffer(offerToken);
+            }
+        }.start();
     }
 
+    /**
+     * Invalidates an existing offer. This will prevent any other users from accepting it. Users that already accepted it,
+     * will not be affected.
+     *
+     * @param offerToken token that should be invalidated.
+     * @throws ObjectServerError if an error happened while trying to invalidate the offer on the Realm Object Server.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
+     */
+    public void invalidatePermissionsOffer(String offerToken) {
+        if (Util.isEmptyString(offerToken)) {
+            throw new IllegalArgumentException("Non-empty 'offerToken' required.");
+        }
+        ObjectServerError error;
+        try {
+            final RealmObjectServer server = SyncManager.getAuthServer();
+            InvalidatePermissionsOfferResponse result = server.invalidateOffer(offerToken, refreshToken, baseUrl);
+            if (!result.isValid()) {
+                error = result.getError();
+            } else {
+                return;
+            }
+        } catch (Exception e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+    /**
+     * Invalidates an existing offer. This will prevent any other users from accepting it. Users that already accepted it,
+     * will not be affected.
+     *
+     * @param offerToken token that should be invalidated.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     * @throws IllegalStateException if this method is called from a thread without a looper.
+     */
+    public RealmAsyncTask invalidatePermissionsOfferAsync(String offerToken, SyncUser.Callback<Void> callback) {
+        checkLooperThread("Asynchronously accepting an permissions offer is only possible from looper threads.");
+        checkCallbackNotNull(callback);
+        return new Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public Void run() throws ObjectServerError {
+                invalidatePermissionsOffer(offerToken);
+                return null;
+            }
+        }.start();
+    }
+
+    /**
+     * Returns the list of offers created by this user. These offers can be revoked again by calling
+     * {@link #invalidatePermissionsOfferAsync(String, Callback)} or sent to other users by sending the
+     * {@link PermissionOffer#getToken()}.
+     *
+     * @return the list of available offers.
+     * @throws ObjectServerError if an error occured while trying retrieve the list of offers from the Realm Object Server.
+     * @throws android.os.NetworkOnMainThreadException if called from the UI thread.
+     */
+    public List<PermissionOffer> retrieveCreatedPermissionsOffers() {
+        ObjectServerError error;
+        try {
+            final RealmObjectServer server = SyncManager.getAuthServer();
+            GetPermissionsOffersResponse result = server.getPermissionOffers(refreshToken, baseUrl);
+            if (!result.isValid()) {
+                error = result.getError();
+            } else {
+                return result.getOffers();
+            }
+        } catch (Exception e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+
+    /**
+     * Returns the list of offers created by this user. These offers can be revoked again by calling
+     * {@link #invalidatePermissionsOfferAsync(String, Callback)} or sent to other users by sending the
+     * {@link PermissionOffer#getToken()}.
+     *
+     * @param callback that will receive the list of available offers.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     * @throws IllegalStateException if this method is called from a thread without a looper.
+     */
+    public RealmAsyncTask retrieveCreatedPermissionsOffersAsync(Callback<List<PermissionOffer>> callback) {
+        checkLooperThread("Asynchronously getting all permission offers is only possible from looper threads.");
+        checkCallbackNotNull(callback);
+        return new Request<List<PermissionOffer>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public List<PermissionOffer> run() throws ObjectServerError {
+                return retrieveCreatedPermissionsOffers();
+            }
+        }.start();
+    }
+
+
+
     // what defines a user is it's identity(Token) and authURL (as required by the constructor)
     //
     // not the list of Realms it's managing, furthermore, trying to include the `realms` in the `hashCode` will
@@ -979,6 +1295,13 @@ public String toString() {
         return sb.toString();
     }
 
+    private void checkCallbackNotNull(Callback callback) {
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+    }
+
     // Class wrapping requests made against the auth server. Is also responsible for calling with success/error on the
     // correct thread.
     private static abstract class Request<T> {
@@ -1042,9 +1365,24 @@ public void run() {
         }
     }
 
+    /**
+     * Callback for async methods available to the {@link SyncUser}.
+     *
+     * @param <T> Type returned if the request was a success.
+     */
     public interface Callback<T> {
-        void onSuccess(T result);
-
+        /**
+         * The request was a success.
+         * @param t The object representing the successful request. See each method for details.
+         */
+        void onSuccess(T t);
+
+        /**
+         * The request failed for some reason, either because there was a network error or the Realm
+         * Object Server returned an error.
+         *
+         * @param error the error that was detected.
+         */
         void onError(ObjectServerError error);
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AcceptPermissionsOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AcceptPermissionsOfferResponse.java
new file mode 100644
index 0000000000..293f7226d3
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AcceptPermissionsOfferResponse.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `POST permissions/offers/:token:/accept`
+ */
+public class AcceptPermissionsOfferResponse extends AuthServerResponse {
+
+    private String path;
+
+    /**
+     * Helper method for creating the proper lookup user response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static AcceptPermissionsOfferResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new AcceptPermissionsOfferResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new AcceptPermissionsOfferResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new AcceptPermissionsOfferResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static AcceptPermissionsOfferResponse from(ObjectServerError objectServerError) {
+        return new AcceptPermissionsOfferResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static AcceptPermissionsOfferResponse from(Exception exception) {
+        return AcceptPermissionsOfferResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private AcceptPermissionsOfferResponse(ObjectServerError error) {
+        RealmLog.debug("AcceptPermissionsOffer - Error: %s", error);
+        setError(error);
+        this.error = error;
+    }
+
+    private AcceptPermissionsOfferResponse(String serverResponse) {
+        RealmLog.debug("AcceptPermissionsOffer - Success: %s", serverResponse);
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            path = obj.getString("path");
+        } catch (JSONException e) {
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
+        }
+    }
+
+    public String getPath() {
+        return path;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ApplyPermissionsRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ApplyPermissionsRequest.java
new file mode 100644
index 0000000000..4c5923a260
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ApplyPermissionsRequest.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+
+/**
+ * Class wrapping a request for updating/setting permissions `POST permissions/apply`
+ */
+public class ApplyPermissionsRequest {
+
+    private final AccessLevel level;
+    private final String realmUrl;
+    private final String userId;
+    private final String metadataKey;
+    private final String metadataValue;
+
+    public ApplyPermissionsRequest(PermissionRequest request) {
+        UserCondition condition = request.getCondition();
+        level = request.getAccessLevel();
+        realmUrl = request.getUrl();
+
+        switch (condition.getType()) {
+            case USER_ID:
+                userId = condition.getValue();
+                metadataKey = null;
+                metadataValue = null;
+                break;
+            case METADATA:
+                userId = null;
+                metadataKey = condition.getKey();
+                metadataValue = condition.getValue();
+                break;
+            default:
+                throw new IllegalArgumentException("Unsupported type: " + condition.getType());
+        }
+    }
+
+    public String toJson() throws JSONException {
+        JSONObject request = new JSONObject();
+        request.put("realmPath", realmUrl);
+        request.put("accessLevel", level.getKey());
+        JSONObject condition = new JSONObject();
+        if (userId != null) {
+            condition.put("userId", userId);
+        } else {
+            condition.put("metadataKey", metadataKey);
+            condition.put("metadataValue", metadataValue);
+        }
+        request.put("condition", condition);
+        return request.toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ApplyPermissionsResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ApplyPermissionsResponse.java
new file mode 100644
index 0000000000..70e150815a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ApplyPermissionsResponse.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `POST permissions/apply`
+ */
+public class ApplyPermissionsResponse extends AuthServerResponse {
+
+    /**
+     * Helper method for creating the proper lookup user response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static ApplyPermissionsResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new ApplyPermissionsResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new ApplyPermissionsResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new ApplyPermissionsResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static ApplyPermissionsResponse from(ObjectServerError objectServerError) {
+        return new ApplyPermissionsResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static ApplyPermissionsResponse from(Exception exception) {
+        return ApplyPermissionsResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private ApplyPermissionsResponse(ObjectServerError error) {
+        RealmLog.debug("ApplyPermissions - Error: %s", error);
+        setError(error);
+        this.error = error;
+    }
+
+    private ApplyPermissionsResponse(String serverResponse) {
+        RealmLog.debug("ApplyPermissions - Success: %s", serverResponse);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/GetPermissionsOffersResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/GetPermissionsOffersResponse.java
new file mode 100644
index 0000000000..73df15990e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/GetPermissionsOffersResponse.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `GET permissions/offers`
+ */
+public class GetPermissionsOffersResponse extends AuthServerResponse {
+
+    private final List<PermissionOffer> offers = new ArrayList<>();
+
+    /**
+     * Helper method for creating the proper lookup user response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static GetPermissionsOffersResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new GetPermissionsOffersResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new GetPermissionsOffersResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new GetPermissionsOffersResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static GetPermissionsOffersResponse from(ObjectServerError objectServerError) {
+        return new GetPermissionsOffersResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static GetPermissionsOffersResponse from(Exception exception) {
+        return GetPermissionsOffersResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private GetPermissionsOffersResponse(ObjectServerError error) {
+        RealmLog.debug("GetPermissionOffers - Error: %s", error);
+        setError(error);
+        this.error = error;
+    }
+
+    private GetPermissionsOffersResponse(String serverResponse) {
+        RealmLog.debug("GetPermissionOffers - Success: %s", serverResponse);
+        try {
+            JSONObject responseObject = new JSONObject(serverResponse);
+            JSONArray responseOffersList = responseObject.getJSONArray("offers");
+            for (int i = 0; i < responseOffersList.length(); i++) {
+                JSONObject obj = responseOffersList.getJSONObject(i);
+                String path = obj.getString("realmPath");
+                Date expiresAt = obj.isNull("expiresAt") ? null : JsonUtils.stringToDate(obj.getString("expiresAt"));
+                AccessLevel accessLevel = AccessLevel.fromKey(obj.getString("accessLevel"));
+                Date createdAt = JsonUtils.stringToDate(obj.getString("createdAt"));
+                String userId = obj.getString("userId");
+                String token = obj.getString("token");
+                offers.add(new PermissionOffer(path, accessLevel, expiresAt, createdAt, userId, token));
+            }
+        } catch (JSONException e) {
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
+        }
+    }
+
+    public List<PermissionOffer> getOffers() {
+        return offers;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/InvalidatePermissionsOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/InvalidatePermissionsOfferResponse.java
new file mode 100644
index 0000000000..f676531891
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/InvalidatePermissionsOfferResponse.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import io.realm.permissions.Permission;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `DELETE /permissions/offers/:token:`
+ */
+public class InvalidatePermissionsOfferResponse extends AuthServerResponse {
+
+    /**
+     * Helper method for creating the proper response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static InvalidatePermissionsOfferResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new InvalidatePermissionsOfferResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new InvalidatePermissionsOfferResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new InvalidatePermissionsOfferResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static InvalidatePermissionsOfferResponse from(ObjectServerError objectServerError) {
+        return new InvalidatePermissionsOfferResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static InvalidatePermissionsOfferResponse from(Exception exception) {
+        return InvalidatePermissionsOfferResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private InvalidatePermissionsOfferResponse(ObjectServerError error) {
+        RealmLog.debug("InvalidatePermissionOffer - Error: %s", error);
+        setError(error);
+        this.error = error;
+    }
+
+    private InvalidatePermissionsOfferResponse(String serverResponse) {
+        RealmLog.debug("InvalidatePermissionOffer - Success: %s", serverResponse);
+        // No data to store
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/MakePermissionsOfferRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/MakePermissionsOfferRequest.java
new file mode 100644
index 0000000000..c4d60995bd
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/MakePermissionsOfferRequest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Date;
+
+import io.realm.permissions.PermissionOffer;
+
+/**
+ * Class wrapping request to `POST /auth/permissions/offers`
+ */
+public class MakePermissionsOfferRequest {
+
+    private final PermissionOffer offer;
+
+    public MakePermissionsOfferRequest(PermissionOffer offer) {
+        this.offer = offer;
+    }
+
+    public String toJson() throws JSONException {
+        JSONObject request = new JSONObject();
+        Date expires = offer.getExpiresAt();
+        if (expires != null) {
+            request.put("expiresAt", expires.toString());
+        }
+        request.put("realmPath", offer.getRealmUrl());
+        request.put("accessLevel", offer.getAccessLevel().getKey());
+        return request.toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/MakePermissionsOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/MakePermissionsOfferResponse.java
new file mode 100644
index 0000000000..aed7a4a43f
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/MakePermissionsOfferResponse.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.Date;
+
+import javax.annotation.Nonnull;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.internal.android.JsonUtils;
+import io.realm.internal.permissions.PermissionOfferResponse;
+import io.realm.log.RealmLog;
+import io.realm.permissions.AccessLevel;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `POST permissions/offers`
+ */
+public class MakePermissionsOfferResponse extends AuthServerResponse {
+
+    private PermissionOfferResponse response;
+
+    /**
+     * Helper method for creating the proper lookup user response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static MakePermissionsOfferResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new MakePermissionsOfferResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new MakePermissionsOfferResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new MakePermissionsOfferResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static MakePermissionsOfferResponse from(ObjectServerError objectServerError) {
+        return new MakePermissionsOfferResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static MakePermissionsOfferResponse from(Exception exception) {
+        return MakePermissionsOfferResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private MakePermissionsOfferResponse(ObjectServerError error) {
+        RealmLog.debug("MakePermissionsOffer - Error: %s", error);
+        setError(error);
+        this.error = error;
+    }
+
+    private MakePermissionsOfferResponse(String serverResponse) {
+        RealmLog.debug("MakePermissionsOffer - Success: %s", serverResponse);
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            @Nonnull String path = obj.getString("realmPath");
+            Date expiresAt = obj.isNull("expiresAt") ? null : JsonUtils.stringToDate(obj.getString("expiresAt"));
+            AccessLevel accessLevel = AccessLevel.fromKey(obj.getString("accessLevel"));
+            Date createdAt = JsonUtils.stringToDate(obj.getString("createdAt"));
+            String userId = obj.getString("userId");
+            String token = obj.getString("token");
+            response = new PermissionOfferResponse(path, expiresAt, accessLevel, createdAt, userId, token);
+        } catch (JSONException e) {
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
+        }
+    }
+
+    public String getToken() {
+        return response.getToken();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpRealmObjectServer.java
similarity index 73%
rename from realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpRealmObjectServer.java
index ebc5b87675..d6e2785cf4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpRealmObjectServer.java
@@ -16,8 +16,6 @@
 
 package io.realm.internal.network;
 
-import android.util.Log;
-
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URI;
@@ -35,6 +33,8 @@
 import io.realm.internal.objectserver.Token;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
 import okhttp3.Interceptor;
@@ -45,19 +45,27 @@
 import okhttp3.Response;
 import okio.Buffer;
 
-public class OkHttpAuthenticationServer implements AuthenticationServer {
+public class OkHttpRealmObjectServer implements RealmObjectServer {
 
     public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
     private static final String ACTION_LOGOUT = "revoke"; // Auth end point for logging out users
     private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
     private static final String ACTION_LOOKUP_USER_ID = "users/:provider:/:providerId:"; // Auth end point for looking up user id
     private static final String ACTION_UPDATE_ACCOUNT = "password/updateAccount"; // Password reset and email confirmation
+    private static final String ACTION_GET_PERMISSIONS = "permissions";
+    private static final String ACTION_UPDATE_PERMISSIONS = "permissions/apply";
+    private static final String ACTION_OFFER_PERMISSIONS = "permissions/offers";
+    private static final String ACTION_ACCEPT_PERMISSIONS_OFFER = "permissions/offers/:token:/accept";
+    private static final String ACTION_DELETE_PERMISSIONS_OFFER = "permissions/offers/:token:";
+    private static final String ACTION_GET_PERMISSION_OFFERS = "permissions/offers";
+
     private static final Charset UTF8 = Charset.forName("UTF-8");
 
     private final OkHttpClient client = new OkHttpClient.Builder()
             .connectTimeout(15, TimeUnit.SECONDS)
             .writeTimeout(15, TimeUnit.SECONDS)
             .readTimeout(30, TimeUnit.SECONDS)
+            .followRedirects(true)
             .addInterceptor(new Interceptor() {
                 @Override
                 public Response intercept(Chain chain) throws IOException {
@@ -89,7 +97,7 @@ public Response intercept(Chain chain) throws IOException {
     private Map<String, Map<String, String>> customHeaders = new LinkedHashMap<>();
     private Map<String, String> customAuthorizationHeaders = new HashMap<>();
 
-    public OkHttpAuthenticationServer() {
+    public OkHttpRealmObjectServer() {
         initHeaders();
     }
 
@@ -243,6 +251,104 @@ public UpdateAccountResponse confirmEmail(String confirmationToken, URL authenti
         }
     }
 
+    @Override
+    public RetrievePermissionsResponse getPermissions(Token userToken, URL baseUrl) {
+        try {
+            URL url = buildActionUrl(baseUrl, ACTION_GET_PERMISSIONS);
+            RealmLog.debug("Network request (retrieveGrantedPermissions): " + url);
+            Request request = newAuthRequest(url, userToken.value())
+                    .get()
+                    .build();
+            Call call = client.newCall(request);
+            Response response = call.execute();
+            return RetrievePermissionsResponse.from(response);
+        } catch (Exception e) {
+            return RetrievePermissionsResponse.from(e);
+        }
+    }
+
+    @Override
+    public ApplyPermissionsResponse applyPermissions(PermissionRequest permissionRequest, Token refreshToken, URL baseUrl) {
+        try {
+            URL url = buildActionUrl(baseUrl, ACTION_UPDATE_PERMISSIONS);
+            RealmLog.debug("Network request (applyPermissions): " + url);
+            Request request = newAuthRequest(url, refreshToken.value())
+                    .post(RequestBody.create(JSON, new ApplyPermissionsRequest(permissionRequest).toJson()))
+                    .build();
+            Call call = client.newCall(request);
+            Response response = call.execute();
+            return ApplyPermissionsResponse.from(response);
+        } catch (Exception e) {
+            return ApplyPermissionsResponse.from(e);
+        }
+    }
+
+    @Override
+    public MakePermissionsOfferResponse makeOffer(PermissionOffer offer, Token refreshToken, URL baseUrl) {
+        try {
+            URL url = buildActionUrl(baseUrl, ACTION_OFFER_PERMISSIONS);
+            RealmLog.debug("Network request (offerPermissions): " + url);
+            Request request = newAuthRequest(url, refreshToken.value())
+                    .post(RequestBody.create(JSON, new MakePermissionsOfferRequest(offer).toJson()))
+                    .build();
+            Call call = client.newCall(request);
+            Response response = call.execute();
+            return MakePermissionsOfferResponse.from(response);
+        } catch (Exception e) {
+            return MakePermissionsOfferResponse.from(e);
+        }
+    }
+
+    @Override
+    public AcceptPermissionsOfferResponse acceptOffer(String offerToken, Token refreshToken, URL baseUrl) {
+        try {
+            String action = ACTION_ACCEPT_PERMISSIONS_OFFER.replace(":token:", offerToken);
+            URL url = buildActionUrl(baseUrl, action);
+            RealmLog.debug("Network request (acceptPermissionOffer): " + url);
+            Request request = newAuthRequest(url, refreshToken.value())
+                    .post(RequestBody.create(JSON, ""))
+                    .build();
+            Call call = client.newCall(request);
+            Response response = call.execute();
+            return AcceptPermissionsOfferResponse.from(response);
+        } catch (Exception e) {
+            return AcceptPermissionsOfferResponse.from(e);
+        }
+    }
+
+    @Override
+    public InvalidatePermissionsOfferResponse invalidateOffer(String offerToken, Token refreshToken, URL baseUrl) {
+        try {
+            String action = ACTION_DELETE_PERMISSIONS_OFFER.replace(":token:", offerToken);
+            URL url = buildActionUrl(baseUrl, action);
+            RealmLog.debug("Network request (invalidatePermissionOffer): " + url);
+            Request request = newAuthRequest(url, refreshToken.value())
+                    .delete()
+                    .build();
+            Call call = client.newCall(request);
+            Response response = call.execute();
+            return InvalidatePermissionsOfferResponse.from(response);
+        } catch (Exception e) {
+            return InvalidatePermissionsOfferResponse.from(e);
+        }
+    }
+
+    @Override
+    public GetPermissionsOffersResponse getPermissionOffers(Token refreshToken, URL baseUrl) {
+        try {
+            URL url = buildActionUrl(baseUrl, ACTION_GET_PERMISSION_OFFERS);
+            RealmLog.debug("Network request (GetPermissionsOffers): " + url);
+            Request request = newAuthRequest(url, refreshToken.value())
+                    .get()
+                    .build();
+            Call call = client.newCall(request);
+            Response response = call.execute();
+            return GetPermissionsOffersResponse.from(response);
+        } catch (Exception e) {
+            return GetPermissionsOffersResponse.from(e);
+        }
+    }
+
     // Builds the URL for a specific auth endpoint
     private static URL buildActionUrl(URL authenticationUrl, String action) {
         final String baseUrlString = authenticationUrl.toExternalForm();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/RealmObjectServer.java
similarity index 80%
rename from realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/network/RealmObjectServer.java
index 7c608791dd..c0b3151612 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/RealmObjectServer.java
@@ -24,6 +24,8 @@
 import io.realm.SyncCredentials;
 import io.realm.SyncUser;
 import io.realm.internal.objectserver.Token;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
 
 /**
  * Interface for handling communication with Realm Object Servers.
@@ -31,7 +33,7 @@
  * Note, no implementation of this class is responsible for handling retries or error handling. It is
  * only responsible for executing a given network request.
  */
-public interface AuthenticationServer {
+public interface RealmObjectServer {
 
     /**
      * Overrides the default header name used to send Realm Object Server credentials.
@@ -114,4 +116,33 @@
      */
     UpdateAccountResponse confirmEmail(String confirmationToken, URL authenticationUrl);
 
+    /**
+     * Retrieves a list of all permissions for the given user.
+     */
+    RetrievePermissionsResponse getPermissions(Token userToken, URL baseUrl);
+
+    /**
+     * Updates a given set of permissions for a single Realm
+     */
+    ApplyPermissionsResponse applyPermissions(PermissionRequest request, Token refreshToken, URL baseUrl);
+
+    /**
+     * Creates an permissions offer for a Realm.
+     */
+    MakePermissionsOfferResponse makeOffer(PermissionOffer offer, Token refreshToken, URL baseUrl);
+
+    /**
+     * Accept a given permissions offer.
+     */
+    AcceptPermissionsOfferResponse acceptOffer(String offerToken, Token refreshToken, URL baseUrl);
+
+    /**
+     * Invalidates an already created permissions offer.
+     */
+    InvalidatePermissionsOfferResponse invalidateOffer(String id, Token refreshToken, URL baseUrl);
+
+    /**
+     * Retrieves a list of all permissions offers that has been created.
+     */
+    GetPermissionsOffersResponse getPermissionOffers(Token refreshToken, URL baseUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/RetrievePermissionsResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/RetrievePermissionsResponse.java
new file mode 100644
index 0000000000..46649b5bfd
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/RetrievePermissionsResponse.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.Permission;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `GET /permissions`
+ */
+public class RetrievePermissionsResponse extends AuthServerResponse {
+
+    private final List<Permission> permissions = new ArrayList<>();
+
+    /**
+     * Helper method for creating the proper response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static RetrievePermissionsResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new RetrievePermissionsResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new RetrievePermissionsResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new RetrievePermissionsResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static RetrievePermissionsResponse from(ObjectServerError objectServerError) {
+        return new RetrievePermissionsResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static RetrievePermissionsResponse from(Exception exception) {
+        return RetrievePermissionsResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private RetrievePermissionsResponse(ObjectServerError error) {
+        RealmLog.debug("LookupUserIdResponse - Error: %s", error);
+        setError(error);
+        this.error = error;
+    }
+
+    private RetrievePermissionsResponse(String serverResponse) {
+        RealmLog.debug("RetrievePermissionsResponse - Success: %s", serverResponse);
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            JSONArray array = obj.getJSONArray("permissions");
+            for (int i = 0; i < array.length(); i++) {
+                JSONObject permission = array.getJSONObject(i);
+                String userId = (permission.isNull("userId")) ? null : permission.getString("userId");
+                String path = permission.getString("path");
+                AccessLevel accessLevel = AccessLevel.fromKey(permission.getString("accessLevel"));
+                boolean mayRead = accessLevel.mayRead();
+                boolean mayWrite = accessLevel.mayWrite();
+                boolean mayManage = accessLevel.mayManage();
+                Date updatedAt = JsonUtils.stringToDate(permission.getString("updatedAt"));
+                permissions.add(new Permission(userId, path, accessLevel, mayRead, mayWrite, mayManage, updatedAt));
+            }
+        } catch (JSONException e) {
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
+        }
+    }
+
+    public List<Permission> getPermissions() {
+        return permissions;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java
deleted file mode 100644
index ea7e6fc103..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.permissions;
-
-import java.util.Date;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.RealmModel;
-
-
-/**
- * Common methods shared between most Realm model classes used in the Permission Realm API.
- */
-public interface BasePermissionApi extends RealmModel {
-
-    /**
-     * Returns the unique id for this object.
-     *
-     * @return the unique id for this object.
-     */
-    String getId();
-
-    /**
-     * Returns the timestamp on the Client that created this object.
-     *
-     * @return {@link Date} this object was created. The timestamp will use the device clock it was created on.
-     */
-    @SuppressFBWarnings("EI_EXPOSE_REP")
-    Date getCreatedAt();
-
-    /**
-     * Returns the timestamp this object was last updated. The timstamp can be both a server timestamp and a device
-     * timestamp.
-     *
-     * @return {@link Date} this object was last modified.
-     */
-    @SuppressFBWarnings("EI_EXPOSE_REP")
-    Date getUpdatedAt();
-
-    /**
-     * Returns the status code for this change.
-     *
-     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
-     */
-    Integer getStatusCode();
-
-    /**
-     * Returns the servers status message, if an error occurred. Otherwise it will return {@code null}.
-     *
-     * @return The servers status message in case of an error, {@code null} otherwise.
-     */
-    String getStatusMessage();
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
deleted file mode 100644
index 358330d92b..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.permissions;
-
-import io.realm.annotations.RealmModule;
-import io.realm.permissions.PermissionOffer;
-
-@RealmModule(library = true, classes = { PermissionChange.class, PermissionOffer.class, PermissionOfferResponse.class })
-public class ManagementModule {
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
deleted file mode 100644
index df839523d4..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal.permissions;
-
-import java.util.Date;
-import java.util.UUID;
-
-import javax.annotation.Nullable;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.RealmObject;
-import io.realm.annotations.PrimaryKey;
-import io.realm.annotations.RealmClass;
-import io.realm.annotations.Required;
-import io.realm.permissions.AccessLevel;
-import io.realm.permissions.UserCondition;
-import io.realm.permissions.PermissionRequest;
-
-
-/**
- * This class is used for requesting changes to a Realm's permissions.
- *
- * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
- */
-@RealmClass
-public class PermissionChange implements BasePermissionApi {
-
-    // Base fields
-    @PrimaryKey
-    @Required
-    private String id = UUID.randomUUID().toString();
-    @Required
-    private Date createdAt = new Date();
-    @Required
-    private Date updatedAt = new Date();
-    private Integer statusCode = null; // null=not processed, 0=success, >0=error
-    private String statusMessage;
-
-    @Required
-    private String realmUrl;
-    @Required
-    private String userId;
-
-    private String metadataKey;
-    private String metadataValue;
-    private String metadataNameSpace;
-    private Boolean mayRead = false;
-    private Boolean mayWrite = false;
-    private Boolean mayManage = false;
-
-    /**
-     * Maps between a PermissionRequest and a PermissionChange object.
-     *
-     * @param request request to map to a PermissionChange.
-     */
-    public static PermissionChange fromRequest(PermissionRequest request) {
-        // PRE-CONDITION: All input are verified to be valid from the perspective of the Client.
-        UserCondition condition = request.getCondition();
-        AccessLevel level = request.getAccessLevel();
-        String realmUrl = request.getUrl();
-
-        String userId = "";
-        String metadataKey = null;
-        String metadataValue = null;
-        switch (condition.getType()) {
-            case USER_ID:
-                userId = condition.getValue();
-                break;
-            case METADATA:
-                metadataKey = condition.getKey();
-                metadataValue = condition.getValue();
-                break;
-        }
-
-        return new PermissionChange(realmUrl, userId, metadataKey, metadataValue, level.mayRead(), level.mayWrite(),
-                level.mayManage());
-    }
-
-    public PermissionChange() {
-        // Default constructor required by Realm
-    }
-
-    /**
-     * Construct a Permission Change Object.
-     *
-     * @param realmUrl Realm to change permissions for. Use {@code *} to change the permissions of all Realms.
-     * @param userId User or users to effect. Use {@code *} to change the permissions for all users.
-     * @param mayRead Define read access. {@code true} or {@code false} to request this new value. {@code null} to
-     *                keep current value.
-     * @param mayWrite Define write access. {@code true} or {@code false} to request this new value. {@code null} to
-     *                 keep current value.
-     * @param mayManage Define manage access. {@code true} or {@code false} to request this new value. {@code null} to
-     *                  keep current value.
-     *
-     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
-     */
-    public PermissionChange(String realmUrl, String userId,
-            @Nullable Boolean mayRead, @Nullable Boolean mayWrite, @Nullable Boolean mayManage) {
-        this.realmUrl = realmUrl;
-        this.userId = userId;
-        this.mayRead = mayRead;
-        this.mayWrite = mayWrite;
-        this.mayManage = mayManage;
-    }
-
-    public PermissionChange(String realmUrl, String userId, String metadataKey, String metadataValue, Boolean mayRead,
-            Boolean mayWrite, Boolean mayManage) {
-        this.realmUrl = realmUrl;
-        this.userId = userId;
-        this.metadataKey = metadataKey;
-        this.metadataValue = metadataValue;
-        this.mayRead = mayRead;
-        this.mayWrite = mayWrite;
-        this.mayManage = mayManage;
-    }
-
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    @Override
-    @SuppressFBWarnings("EI_EXPOSE_REP")
-    public Date getCreatedAt() {
-        return createdAt;
-    }
-
-    @Override
-    @SuppressFBWarnings("EI_EXPOSE_REP")
-    public Date getUpdatedAt() {
-        return updatedAt;
-    }
-
-    /**
-     * Returns the status code for this change.
-     *
-     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
-     */
-    @Override
-    @Nullable
-    public Integer getStatusCode() {
-        return statusCode;
-    }
-
-    @Override
-    @Nullable
-    public String getStatusMessage() {
-        return statusMessage;
-    }
-
-    public String getRealmUrl() {
-        return realmUrl;
-    }
-
-    public String getUserId() {
-        return userId;
-    }
-
-    @Nullable
-    public Boolean mayRead() {
-        return mayRead;
-    }
-
-    @Nullable
-    public Boolean mayWrite() {
-        return mayWrite;
-    }
-
-    @Nullable
-    public Boolean mayManage() {
-        return mayManage;
-    }
-
-    public String getMetadataKey() {
-        return metadataKey;
-    }
-
-    public String getMetadataValue() {
-        return metadataValue;
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java
deleted file mode 100644
index 9ba21bba00..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.permissions;
-
-import io.realm.annotations.RealmModule;
-import io.realm.permissions.Permission;
-
-@RealmModule(library = true, classes = { Permission.class })
-public class PermissionModule {
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
index 812c67d7e8..c4f850dab3 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
@@ -18,14 +18,12 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.Date;
-import java.util.UUID;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.annotations.PrimaryKey;
-import io.realm.annotations.RealmClass;
-import io.realm.annotations.Required;
+import io.realm.permissions.AccessLevel;
 import io.realm.permissions.PermissionOffer;
 
 
@@ -39,93 +37,33 @@
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
  * documentation.
  */
-@RealmClass
-public class PermissionOfferResponse implements BasePermissionApi {
-
-    // Base fields
-    @PrimaryKey
-    @Required
-    private String id = UUID.randomUUID().toString();
-    @Required
-    private Date createdAt = new Date();
-    @Required
-    private Date updatedAt = new Date();
-    private Integer statusCode; // nil=not processed, 0=success, >0=error
-    private String statusMessage;
-
-    // Request fields
-    @Required
-    private String token;
-    private String realmUrl;
-
-    public PermissionOfferResponse() {
-        // No args constructor required by Realm
-    }
-
-    /**
-     * Construct a permission offer response object used to apply permission changes
-     * defined in the permission offer object represented by the specified token,
-     * which was created by another user's {@link PermissionOffer} object.
-     *
-     * @param token The received token which uniquely identifies another user's
-     *              {@link PermissionOffer}.
-     */
-    public PermissionOfferResponse(String token) {
-        //noinspection ConstantConditions
-        if (token == null) {
-            throw new IllegalArgumentException("Non-null 'token' required.");
-        }
+public final class PermissionOfferResponse {
+
+    @Nonnull private final String userId;
+    @Nonnull private final Date createdAt;
+    private final Date expiresAt;
+    @Nonnull private final String token;
+    @Nonnull private final String realmUrl;
+    @Nonnull private final AccessLevel accessLevel;
+
+    public PermissionOfferResponse(String path, Date expiresAt, AccessLevel accessLevel, Date createdAt, String userId, String token) {
+        this.realmUrl = path;
+        this.expiresAt = (expiresAt != null) ? (Date) expiresAt.clone() : null;
+        this.accessLevel = accessLevel;
+        this.createdAt = (Date) createdAt.clone();
+        this.userId = userId;
         this.token = token;
     }
 
-    public void setToken(String token) {
-        this.token = token;
+    public String getUserId() {
+        return userId;
     }
 
-    @Override
-    public String getId() {
-        return id;
-    }
-
-    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
-    @Override
-    @SuppressFBWarnings("EI_EXPOSE_REP")
-    public Date getUpdatedAt() {
-        return updatedAt;
-    }
-
-    /**
-     * Returns the status code for this change.
-     *
-     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
-     */
-    @Override
-    @Nullable
-    public Integer getStatusCode() {
-        return statusCode;
-    }
-
-    /**
-     * Check if the request was successfully handled by the Realm Object Server.
-     *
-     * @return {@code true} if request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
-     *         for the full error message.
-     */
-    public boolean isSuccessful() {
-        return statusCode != null && statusCode == 0;
-    }
-
-    @Override
-    @Nullable
-    public String getStatusMessage() {
-        return statusMessage;
-    }
-
     public String getToken() {
         return token;
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
index 79afe55b95..689700eb1f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
@@ -16,9 +16,9 @@
 
 package io.realm.permissions;
 
-import io.realm.PermissionManager;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.SyncUser;
 
 
 /**
@@ -30,14 +30,14 @@
  * access can always read or write from the Realm. This means that {@code NONE < READ < WRITE < ADMIN}.
  *
  * @see PermissionRequest
- * @see io.realm.PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ * @see SyncUser#applyPermissionsAsync(PermissionRequest, SyncUser.Callback)
  */
 public enum AccessLevel {
 
     /**
      * The user does not have access to this Realm.
      */
-    NONE(false, false, false),
+    NONE("none", false, false, false),
 
     /**
      * User can only read the contents of the Realm.
@@ -56,29 +56,40 @@
      * }
      * </pre>
      */
-    READ(true, false, false),
+    READ("read", true, false, false),
 
     /**
      * User can read and write the contents of the Realm.
      */
-    WRITE(true, true, false),
+    WRITE("write", true, true, false),
 
     /**
      * User can read, write, and administer the Realm. This includes both granting permissions as well as removing them
      * again.
      */
-    ADMIN(true, true, true);
+    ADMIN( "admin", true, true, true);
 
+    private final String key; // JSON description used by the Realm Object Server
     private final boolean mayRead;
     private final boolean mayWrite;
     private final boolean mayManage;
 
-    AccessLevel(boolean mayRead, boolean mayWrite, boolean mayManage) {
+    AccessLevel(String serverKey, boolean mayRead, boolean mayWrite, boolean mayManage) {
+        this.key = serverKey;
         this.mayRead = mayRead;
         this.mayWrite = mayWrite;
         this.mayManage = mayManage;
     }
 
+    public static AccessLevel fromKey(String accessLevel) {
+        for (AccessLevel level : values()) {
+            if (level.getKey().equals(accessLevel)) {
+                return level;
+            }
+        }
+        throw new IllegalArgumentException("Unknown access level: " + accessLevel);
+    }
+
     /**
      * Returns {@code true} if the user is allowed to read a Realm, {@code false} if not.
      */
@@ -102,4 +113,8 @@ public boolean mayWrite() {
     public boolean mayManage() {
         return mayManage;
     }
+
+    public String getKey() {
+        return key;
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
index 2e975c7ff5..ed9e21a0ce 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
@@ -18,44 +18,43 @@
 
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.PermissionManager;
-import io.realm.RealmObject;
 import io.realm.SyncUser;
-import io.realm.annotations.Required;
 
 
 /**
- * This class represents a given set of permissions for one user on one Realm.
+ * This class represents the given set of permissions provided to a user for the Realm identified by
+ * {@link #path}.
  * <p>
- * Permissions can be changed by users with administrative rights using the {@link PermissionManager}.
- *
- * @see SyncUser#getPermissionManager()
+ * Permissions can be changed by users with administrative rights using {@link SyncUser#applyPermissions(PermissionRequest)}.
  */
-public class Permission extends RealmObject {
-
-    @Required
-    private String userId;
-    @Required
-    private String path;
-    private boolean mayRead;
-    private boolean mayWrite;
-    private boolean mayManage;
-    @Required
-    private Date updatedAt;
+public final class Permission {
 
-    /**
-     * Required by Realm. Do not use.
-     */
-    public Permission() {
-        // Required by Realm
+    @Nullable private final String userId;
+    private final String path;
+    private final AccessLevel accessLevel;
+    private final boolean mayRead;
+    private final boolean mayWrite;
+    private final boolean mayManage;
+    private final Date updatedAt;
+
+    public Permission(@Nullable String userId, String path, AccessLevel accessLevel, boolean mayRead, boolean mayWrite, boolean mayManage, Date updatedAt) {
+        this.userId = userId;
+        this.path = path;
+        this.accessLevel = accessLevel;
+        this.mayRead = mayRead;
+        this.mayWrite = mayWrite;
+        this.mayManage = mayManage;
+        this.updatedAt = (Date) updatedAt.clone();
     }
 
     /**
-     * Returns the {@link SyncUser#getIdentity()} of the user effected by this permission.˚
-     * <p>
+     * Returns the {@link SyncUser#getIdentity()} of the user effected by this permission or
+     * {@code null} if this permissions applies to all users.
      *
-     * @return the user effected by this permission.
+     * @return the user(s) effected by this permission.
      */
     public String getUserId() {
         return userId;
@@ -70,6 +69,15 @@ public String getPath() {
         return path;
     }
 
+    /**
+     * Returns the access level granted by this permission.
+     *
+     * @return access level granted by this permission.
+     */
+    public AccessLevel getAccessLevel() {
+        return accessLevel;
+    }
+
     /**
      * Checks whether or not the user defined by this permission is allowed to read the Realm defined by
      * {@link #getPath()}.
@@ -116,10 +124,39 @@ public String toString() {
         return "Permission{" +
                 "userId='" + userId + '\'' +
                 ", path='" + path + '\'' +
+                ", accessLevel=" + accessLevel +
                 ", mayRead=" + mayRead +
                 ", mayWrite=" + mayWrite +
                 ", mayManage=" + mayManage +
                 ", updatedAt=" + updatedAt +
                 '}';
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Permission that = (Permission) o;
+
+        if (mayRead != that.mayRead) return false;
+        if (mayWrite != that.mayWrite) return false;
+        if (mayManage != that.mayManage) return false;
+        if (userId != null ? !userId.equals(that.userId) : that.userId != null) return false;
+        if (!path.equals(that.path)) return false;
+        if (accessLevel != that.accessLevel) return false;
+        return updatedAt.equals(that.updatedAt);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = userId != null ? userId.hashCode() : 0;
+        result = 31 * result + path.hashCode();
+        result = 31 * result + accessLevel.hashCode();
+        result = 31 * result + (mayRead ? 1 : 0);
+        result = 31 * result + (mayWrite ? 1 : 0);
+        result = 31 * result + (mayManage ? 1 : 0);
+        result = 31 * result + updatedAt.hashCode();
+        return result;
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
index a42e5b9e77..5baeaba7e7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
@@ -18,18 +18,13 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.Date;
-import java.util.UUID;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.PermissionManager;
-import io.realm.annotations.Index;
-import io.realm.annotations.PrimaryKey;
-import io.realm.annotations.RealmClass;
-import io.realm.annotations.Required;
+import io.realm.SyncUser;
 import io.realm.internal.Util;
-import io.realm.internal.permissions.BasePermissionApi;
 
 
 /**
@@ -40,42 +35,19 @@
  * <p>
  * Permission offers can only be created by users that can manage the Realm, the offer is about.
  *
- * @see PermissionManager#makeOffer(PermissionOffer, PermissionManager.MakeOfferCallback)
- * @see PermissionManager#acceptOffer(String, PermissionManager.AcceptOfferCallback)
+ * @see SyncUser#makePermissionsOfferAsync(PermissionOffer, SyncUser.Callback)
+ * @see SyncUser#acceptPermissionsOfferAsync(String, SyncUser.Callback)
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
  * documentation.
  */
+public final class PermissionOffer {
 
-@RealmClass
-public class PermissionOffer implements BasePermissionApi {
-
-    // Base fields
-    @PrimaryKey
-    @Required
-    private String id = UUID.randomUUID().toString();
-    @Required
-    private Date createdAt = new Date();
-    @Required
-    private Date updatedAt = new Date();
-    private Integer statusCode; // nil=not processed, 0=success, >0=error
-    private String statusMessage;
-
-    // Offer fields
-    @Index
-    private String token;
-    @Required
-    private String realmUrl;
-    private boolean mayRead;
-    private boolean mayWrite;
-    private boolean mayManage;
-    private Date expiresAt;
-
-    /**
-     * Constructor required by Realm. Should not be used.
-     */
-    public PermissionOffer() {
-        // No args constructor required by Realm
-    }
+    @Nonnull private final Date createdAt;
+    private final String userId;
+    private final String token;
+    @Nonnull private final String realmUrl;
+    @Nonnull private final AccessLevel accessLevel;
+    private final Date expiresAt;
 
     /**
      * Creates a request for an permission offer that last until it is manually revoked.
@@ -83,7 +55,7 @@ public PermissionOffer() {
      * @param url specific url to Realm effected this offer encompasses all Realms manged by the user making the offer.
      * @param accessLevel the {@link AccessLevel} granted to the user accepting the offer.
      *
-     * @see PermissionManager#revokeOffer(String, PermissionManager.RevokeOfferCallback)
+     * @see SyncUser#invalidatePermissionsOfferAsync(String, SyncUser.Callback)
      */
     @SuppressFBWarnings("EI_EXPOSE_REP2")
     public PermissionOffer(String url, AccessLevel accessLevel) {
@@ -99,18 +71,23 @@ public PermissionOffer(String url, AccessLevel accessLevel) {
      * @param expiresAt the date and time when this offer expires. If {@code null} is provided the offer never expires.
      *
      *
-     * @see PermissionManager#revokeOffer(String, PermissionManager.RevokeOfferCallback)
+     * @see SyncUser#invalidatePermissionsOfferAsync(String, SyncUser.Callback)
      */
     @SuppressFBWarnings("EI_EXPOSE_REP2")
     public PermissionOffer(String url, AccessLevel accessLevel, @Nullable Date expiresAt) {
-        validateUrl(url);
+        this(url, accessLevel, expiresAt, new Date(), null, null);
+    }
+
+    @SuppressFBWarnings("EI_EXPOSE_REP2")
+    public PermissionOffer(String path, AccessLevel accessLevel, @Nullable Date expiresAt, Date createdAt, @Nullable String userId, @Nullable String token) {
+        validateUrl(path);
         validateAccessLevel(accessLevel);
-        this.mayRead = accessLevel.mayRead();
-        this.mayWrite = accessLevel.mayWrite();
-        this.mayManage = accessLevel.mayManage();
-        this.realmUrl = url;
-        //noinspection ConstantConditions
+        this.realmUrl = path;
+        this.accessLevel = accessLevel;
         this.expiresAt = (expiresAt != null) ? (Date) expiresAt.clone() : null;
+        this.createdAt = (Date) createdAt.clone();
+        this.userId = userId;
+        this.token = token;
     }
 
     private void validateUrl(String url) {
@@ -132,72 +109,16 @@ private void validateAccessLevel(AccessLevel accessLevel) {
         }
     }
 
-    /**
-     * Returns the id uniquely identifying this offer.
-     *
-     * @return the id uniquely identifying this offer.
-     */
-    @Override
-    public String getId() {
-        return id;
-    }
-
     /**
      * Returns the timestamp when this offer was created.
      *
      * @return the timstamp when this offer was created.
      */
-    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
-    /**
-     * Returns the timestamp this offer was last updated.
-     *
-     * @return the timestamp when this offer was last updated.
-     */
-    @Override
-    @SuppressFBWarnings("EI_EXPOSE_REP")
-    public Date getUpdatedAt() {
-        return updatedAt;
-    }
-
-
-    /**
-     * Returns the server status code for this change.
-     *
-     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened.
-     * See {@link #getStatusMessage()}.
-     */
-    @Override
-    @Nullable
-    public Integer getStatusCode() {
-        return statusCode;
-    }
-
-    /**
-     * Returns the servers status message, if an error occurred. Otherwise it will return {@code null}.
-     *
-     * @return The servers status message in case of an error, {@code null} otherwise.
-     */
-    @Override
-    @Nullable
-    public String getStatusMessage() {
-        return statusMessage;
-    }
-
-    /**
-     * Checks if the request was successfully handled by the Realm Object Server.
-     *
-     * @return {@code true} if the request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
-     *         for the full error message.
-     */
-    public boolean isOfferCreated() {
-        return !Util.isEmptyString(token);
-    }
-
     /**
      * Returns the offer token if this offer was successfully created.
      *
@@ -223,7 +144,7 @@ public String getRealmUrl() {
      * @return {@code true} if the user accepting this offer is granted read permission, {@code false} if not.
      */
     public boolean mayRead() {
-        return mayRead;
+        return accessLevel.mayRead();
     }
 
     /**
@@ -232,7 +153,7 @@ public boolean mayRead() {
      * @return {@code true} if the user accepting this offer is granted write permission, {@code false} if not.
      */
     public boolean mayWrite() {
-        return mayWrite;
+        return accessLevel.mayWrite();
     }
 
     /**
@@ -242,7 +163,25 @@ public boolean mayWrite() {
      * @return {@code true} if the user accepting this offer is granted mange permission, {@code false} if not.
      */
     public boolean mayManage() {
-        return mayManage;
+        return accessLevel.mayManage();
+    }
+
+    /**
+     * Returns the access level granted by this offer.
+     *
+     * @return access level granted by this offer.
+     */
+    public AccessLevel getAccessLevel() {
+        return accessLevel;
+    }
+
+    /**
+     * Checks if the offer was successfully handled by the Realm Object Server.
+     *
+     * @return {@code true} if the request has been created, {@code false} if not.
+     */
+    public boolean isOfferCreated() {
+        return !Util.isEmptyString(token);
     }
 
     /**
@@ -259,16 +198,13 @@ public Date getExpiresAt() {
     @Override
     public String toString() {
         return "PermissionOffer{" +
-                "id='" + id + '\'' +
+                "userId='" + userId + '\'' +
                 ", createdAt=" + createdAt +
-                ", updatedAt=" + updatedAt +
-                ", statusCode=" + statusCode +
-                ", statusMessage='" + statusMessage + '\'' +
                 ", token='" + token + '\'' +
                 ", realmUrl='" + realmUrl + '\'' +
-                ", mayRead=" + mayRead +
-                ", mayWrite=" + mayWrite +
-                ", mayManage=" + mayManage +
+                ", mayRead=" + accessLevel.mayRead() +
+                ", mayWrite=" + accessLevel.mayWrite() +
+                ", mayManage=" + accessLevel.mayManage() +
                 ", expiresAt=" + expiresAt +
                 '}';
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
index c10a9af401..f72f9e4e6d 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
@@ -19,19 +19,17 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 
-import io.realm.PermissionManager;
+import io.realm.SyncUser;
 import io.realm.internal.Util;
 
-
 /**
  * This class represents the intent of giving a set of permissions to some users for some Realm(s).
  * <p>
- * If the request is successful, a {@link io.realm.permissions.Permission} entry will be added to each affected users
- * {@link PermissionManager}, where it can be fetched using
- * {@link PermissionManager#getPermissions(PermissionManager.PermissionsCallback)}
+ * If the request is successful, a {@link io.realm.permissions.Permission} entry will be added to each affected users,
+ * where it can be fetched using {@link SyncUser#retrieveGrantedPermissionsAsync(SyncUser.Callback)}
  *
- * @see PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
- * @see PermissionManager#getPermissions(PermissionManager.PermissionsCallback)
+ * @see SyncUser#applyPermissionsAsync(PermissionRequest, SyncUser.Callback)
+ * @see SyncUser#retrieveGrantedPermissionsAsync(SyncUser.Callback)
  */
 public final class PermissionRequest {
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
index 57026e7ed4..168e753e03 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
@@ -16,7 +16,6 @@
 
 package io.realm.permissions;
 
-import io.realm.PermissionManager;
 import io.realm.SyncUser;
 import io.realm.internal.Util;
 
@@ -26,7 +25,7 @@
  * It is used when a request for changing existing permissions is made.
  *
  * @see PermissionRequest
- * @see io.realm.PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ * @see SyncUser#applyPermissionsAsync(PermissionRequest, SyncUser.Callback)
  */
 public final class UserCondition {
 
@@ -66,7 +65,7 @@ public static UserCondition userId(String userId) {
      * The {@link AccessLevel} defined alongside this condition, will also be used as the default access level
      * for future new users that might be given access to the Realm.
      *
-     * @see PermissionManager#makeOffer(PermissionOffer, PermissionManager.MakeOfferCallback)
+     * @see SyncUser#makePermissionsOfferAsync(PermissionOffer, SyncUser.Callback)
      */
     public static UserCondition noExistingPermissions() {
         return userId("*");
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PathLevelPermissionsTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PathLevelPermissionsTests.java
new file mode 100644
index 0000000000..16cedc4cae
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PathLevelPermissionsTests.java
@@ -0,0 +1,507 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.annotation.Nullable;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.internal.OsRealmConfig;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class PathLevelPermissionsTests extends StandardIntegrationTest {
+
+    private SyncUser user;
+
+    @Before
+    public void setUpTest() {
+        user = UserFactory.createUniqueUser();
+    }
+
+    @Test
+    @RunTestInLooperThread()
+    public void retrieveGrantedPermissions_returnLoadedResults() {
+        user.retrieveGrantedPermissionsAsync(new SyncUser.Callback<List<Permission>>() {
+            @Override
+            public void onSuccess(List<Permission> permissions) {
+                assertInitialPermissions(permissions);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+
+    @Test
+    @RunTestInLooperThread
+    public void retrieveGrantedPermissions_updatedWithNewRealms() {
+        user.retrieveGrantedPermissionsAsync(new SyncUser.Callback<List<Permission>>() {
+            @Override
+            public void onSuccess(List<Permission> permissions) {
+                assertInitialPermissions(permissions);
+
+                // Create new Realm, which should create a new Permission entry
+                SyncConfiguration config2 = user.createConfiguration(Constants.USER_REALM_2)
+                        .schema(AllJavaTypes.class)
+                        .fullSynchronization()
+                        .errorHandler((session, error) -> fail(error.toString()))
+                        .build();
+                final Realm secondRealm = Realm.getInstance(config2);
+                looperThread.closeAfterTest(secondRealm);
+                try {
+                    SyncManager.getSession(config2).uploadAllLocalChanges();
+                } catch (InterruptedException e) {
+                    fail(e.toString());
+                }
+
+                // Wait for the permission Result to report the new Realms
+                List<Permission> permissions2 = user.retrieveGrantedPermissions();
+                assertEquals(1, permissions.size());
+                assertEquals(2, permissions2.size());
+                Permission permission = permissions2.get(1);
+                assertTrue(permission.getPath().endsWith("tests2"));
+                assertTrue(permission.mayRead());
+                assertTrue(permission.mayWrite());
+                assertTrue(permission.mayManage());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread()
+    public void getPermissions_updatedWithNewRealms_stressTest() {
+        final int TEST_SIZE = 10;
+        List<Permission> permissions = user.retrieveGrantedPermissions();
+        assertInitialPermissions(permissions);
+
+        for (int i = 0; i < TEST_SIZE; i++) {
+            SyncConfiguration configNew = user.createConfiguration("realm://" + Constants.HOST + "/~/test" + i)
+                    .fullSynchronization()
+                    .schema(AllJavaTypes.class)
+                    .build();
+            Realm newRealm = Realm.getInstance(configNew);
+            looperThread.closeAfterTest(newRealm);
+        }
+
+        List<Permission> perms = permissions;
+        while(perms.size() < TEST_SIZE + 1) { // +1 is __wildcardpermissions
+            perms = user.retrieveGrantedPermissions();
+        }
+
+        Permission p = perms.get(TEST_SIZE);
+        assertTrue(p.getPath().endsWith("test" + (TEST_SIZE - 1)));
+        assertTrue(p.mayRead());
+        assertTrue(p.mayWrite());
+        assertTrue(p.mayManage());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_nonAdminUserFails() {
+        SyncUser user2 = UserFactory.createUniqueUser();
+        String otherUsersUrl = createRemoteRealm(user2, "test");
+
+        // Create request for setting permissions on another users Realm,
+        // i.e. user making the request do not have manage rights.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, otherUsersUrl, accessLevel);
+
+        user.applyPermissionsAsync(request, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void success) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void applyPermissions_wrongUrlFails() {
+        String wrongUrl = createRemoteRealm(user, "test") + "-notexisting";
+
+        // Create request for setting permissions on another users Realm,
+        // i.e. user making the request do not have manage rights.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, wrongUrl, accessLevel);
+        user.applyPermissionsAsync(request, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void ignore) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_withUserId() {
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        String url = createRemoteRealm(user2, "test");
+
+        // Create request for giving `user` WRITE permissions to `user2`'s Realm.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        user2.applyPermissionsAsync(request, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void ignore) {
+                List<Permission> permissions = user.retrieveGrantedPermissions();
+                assertPermissionPresent(permissions, user, "/test", AccessLevel.WRITE);
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void applyPermissions_withUsername() {
+        String user1Username = TestHelper.getRandomEmail();
+        String user2Username = TestHelper.getRandomEmail();
+        final SyncUser user1 = UserFactory.createUser(user1Username);
+        final SyncUser user2 = UserFactory.createUser(user2Username);
+
+        // Create request for giving `user2` WRITE permissions to `user1`'s Realm.
+        UserCondition condition = UserCondition.username(user2Username);
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        String url = createRemoteRealm(user1, "test");
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        user1.applyPermissions(request);
+        List<Permission> user2Permissions = user2.retrieveGrantedPermissions();
+        assertPermissionPresent(user2Permissions, user2, user1.getIdentity() + "/test", AccessLevel.WRITE);
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void applyPermissions_usersWithNoExistingPermissions() {
+        final SyncUser user1 = UserFactory.createUser("user1@realm.io");
+        final SyncUser user2 = UserFactory.createUser("user2@realm.io");
+
+        // Create request for giving all users with no existing permissions WRITE permissions to `user1`'s Realm.
+        UserCondition condition = UserCondition.noExistingPermissions();
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        final String url = createRemoteRealm(user1, "test");
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        user1.applyPermissions(request);
+        List<Permission> user2Permissions = user2.retrieveGrantedPermissions();
+        assertPermissionPresent(user2Permissions, null, "/" + user1.getIdentity() + "/test", AccessLevel.WRITE);
+
+        // Remove wildcard permission to prevent them from interfering with other tests
+        user1.applyPermissions(new PermissionRequest(UserCondition.noExistingPermissions(), url, AccessLevel.NONE));
+
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void makeOffer() {
+        String url = createRemoteRealm(user, "test");
+
+        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
+        user.makePermissionsOfferAsync(offer, new SyncUser.Callback<String>() {
+            @Override
+            public void onSuccess(String token) {
+                assertNotNull(token);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void makeOffer_noManageAccessThrows() {
+        // User 2 creates a Realm
+        SyncUser user2 = UserFactory.createUniqueUser();
+        String url = createRemoteRealm(user2, "test");
+
+        // User 1 tries to create an offer for it.
+        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
+        user.makePermissionsOfferAsync(offer, new SyncUser.Callback<String>() {
+            @Override
+            public void onSuccess(String s) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void acceptOffer() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        user2.acceptPermissionsOfferAsync(offerToken, new SyncUser.Callback<String>() {
+            @Override
+            public void onSuccess(String realmPath) {
+                assertEquals("/" + user.getIdentity() + "/test", realmPath);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void acceptOffer_invalidToken() {
+        user.acceptPermissionsOfferAsync("wrong-token", new SyncUser.Callback<String>() {
+            @Override
+            public void onSuccess(String s) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void acceptOffer_multipleUsers() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final SyncUser user3 = UserFactory.createUniqueUser();
+
+        final AtomicInteger offersAccepted = new AtomicInteger(0);
+        SyncUser.Callback<String> callback = new SyncUser.Callback<String>() {
+            @Override
+            public void onSuccess(String url) {
+                assertEquals("/" + user.getIdentity() + "/test", url);
+                if (offersAccepted.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        };
+
+        user2.acceptPermissionsOfferAsync(offerToken, callback);
+        user2.acceptPermissionsOfferAsync(offerToken, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getCreatedOffers() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        user.retrieveCreatedPermissionsOffersAsync(new SyncUser.Callback<List<PermissionOffer>>() {
+            @Override
+            public void onSuccess(List<PermissionOffer> permissionOffers) {
+                assertEquals(1, permissionOffers.size());
+                assertEquals(offerToken, permissionOffers.get(0).getToken());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void revokeOffer() {
+        // createOffer validates that the offer is actually in the __management Realm.
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        user.invalidatePermissionsOfferAsync(offerToken, new SyncUser.Callback<Void>() {
+            @Override
+            public void onSuccess(Void aVoid) {
+                List<PermissionOffer> offers = user.retrieveCreatedPermissionsOffers();
+                assertEquals(0, offers.size());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void revokeOffer_afterOneAcceptEdit() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        SyncUser user2 = UserFactory.createUniqueUser();
+        SyncUser user3 = UserFactory.createUniqueUser();
+
+        String path = user2.acceptPermissionsOffer(offerToken);
+        assertTrue(path.endsWith("test"));
+        user.invalidatePermissionsOffer(offerToken);
+        try {
+            user3.acceptPermissionsOffer(offerToken);
+            fail();
+        } catch (ObjectServerError error) {
+            assertEquals(ErrorCode.EXPIRED_PERMISSION_OFFER, error.getErrorCode());
+            looperThread.testComplete();
+        }
+    }
+
+    /**
+     * Creates an offer for a newly created Realm.
+     *
+     * @param user User that should create the offer
+     * @param realmName Realm to create
+     * @param level accessLevel to offer
+     * @param expires when the offer expires
+     */
+    private String createOffer(final SyncUser user, final String realmName, final AccessLevel level, final Date expires) {
+        String url = createRemoteRealm(user, realmName);
+        return user.makePermissionsOffer(new PermissionOffer(url, level, expires));
+    }
+
+    /**
+     * Wait for a given permission to be present.
+     *
+     * @param permissions permission results.
+     * @param user user that is being granted the permission.
+     * @param urlSuffix the url suffix to listen for.
+     * @param accessLevel the expected access level for 'user'.
+     */
+    private void assertPermissionPresent(List<Permission> permissions, @Nullable final SyncUser user, String urlSuffix, final AccessLevel accessLevel) {
+        for (Permission p : permissions) {
+            if (p.getPath().endsWith(urlSuffix)) {
+                assertEquals(accessLevel.mayRead(), p.mayRead());
+                assertEquals(accessLevel.mayWrite(), p.mayWrite());
+                assertEquals(accessLevel.mayManage(), p.mayManage());
+                if (user != null) {
+                    // Specific permissions
+                    assertEquals(user.getIdentity(), p.getUserId());
+                } else {
+                    // Default permissions
+                    assertNull(p.getUserId());
+                }
+                looperThread.testComplete();
+                return;
+            }
+        }
+        throw new AssertionError("No matching permissions");
+    }
+
+    /**
+     * Creates an empty remote Realm on ROS owned by the provided user
+     */
+    private String createRemoteRealm(SyncUser user, String realmName) {
+        String url = Constants.AUTH_SERVER_URL + "~/" + realmName;
+        SyncConfiguration config = user.createConfiguration(url)
+                .name(realmName)
+                .schema(AllJavaTypes.class)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        final CountDownLatch uploadLatch = new CountDownLatch(1);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    uploadLatch.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(uploadLatch);
+        realm.close();
+        return config.getServerUrl().toString();
+    }
+
+    /**
+     * The initial set of permissions from ROS.
+     */
+    private void assertInitialPermissions(List<Permission> permissions) {
+        assertEquals(1, permissions.size());
+        assertEquals("/__wildcardpermissions", permissions.get(0).getPath());
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
deleted file mode 100644
index 6ead0af6ea..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
+++ /dev/null
@@ -1,1241 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.SystemClock;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.io.File;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import io.realm.entities.AllJavaTypes;
-import io.realm.internal.OsRealmConfig;
-import io.realm.log.RealmLog;
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
-import io.realm.permissions.AccessLevel;
-import io.realm.permissions.Permission;
-import io.realm.permissions.PermissionOffer;
-import io.realm.permissions.PermissionRequest;
-import io.realm.permissions.UserCondition;
-import io.realm.rule.RunTestInLooperThread;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@RunWith(AndroidJUnit4.class)
-public class PermissionManagerTests extends StandardIntegrationTest {
-
-    private SyncUser user;
-
-    @Before
-    public void setUpTest() {
-        user = UserFactory.createUniqueUser();
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissions_returnLoadedResults() {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                assertTrue(permissions.isLoaded());
-                assertInitialPermissions(permissions);
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissions_noLongerValidWhenPermissionManagerIsClosed() {
-        final PermissionManager pm = user.getPermissionManager();
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                assertTrue(permissions.isValid());
-                pm.close();
-                assertFalse(permissions.isValid());
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                pm.close();
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissions_updatedWithNewRealms() {
-        final PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                assertTrue(permissions.isLoaded());
-                assertInitialPermissions(permissions);
-
-                // Create new Realm, which should create a new Permission entry
-                SyncConfiguration config2 = user.createConfiguration(Constants.USER_REALM_2)
-                        .schema(AllJavaTypes.class)
-                        .errorHandler(new SyncSession.ErrorHandler() {
-                            @Override
-                            public void onError(SyncSession session, ObjectServerError error) {
-                                fail(error.toString());
-                            }
-                        })
-                        .build();
-                final Realm secondRealm = Realm.getInstance(config2);
-                looperThread.closeAfterTest(secondRealm);
-                // Wait for the permission Result to report the new Realms
-                looperThread.keepStrongReference(permissions);
-                permissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
-                    @Override
-                    public void onChange(RealmResults<Permission> permissions) {
-                        RealmLog.error(String.format("2ndCallback: Size: %s, Permissions: %s", permissions.size(), Arrays.toString(permissions.toArray())));
-                        Permission p = permissions.where().endsWith("path", "tests2").findFirst();
-                        if (p != null) {
-                            assertTrue(p.mayRead());
-                            assertTrue(p.mayWrite());
-                            assertTrue(p.mayManage());
-                            looperThread.testComplete();
-                        }
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail("Could not open Realm: " + error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissions_updatedWithNewRealms_stressTest() {
-        final int TEST_SIZE = 10;
-        final PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                assertTrue(permissions.isLoaded());
-                assertInitialPermissions(permissions);
-
-                for (int i = 0; i < TEST_SIZE; i++) {
-                    SyncConfiguration configNew = user.createConfiguration("realm://" + Constants.HOST + "/~/test" + i)
-                            .schema(AllJavaTypes.class)
-                            .build();
-                    Realm newRealm = Realm.getInstance(configNew);
-                    looperThread.closeAfterTest(newRealm);
-                }
-
-                // Wait for the permission Result to report the new Realms
-                looperThread.keepStrongReference(permissions);
-                permissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
-                    @Override
-                    public void onChange(RealmResults<Permission> permissions) {
-                        RealmLog.error(String.format("Size: %s, Permissions: %s", permissions.size(), Arrays.toString(permissions.toArray())));
-                        Permission p = permissions.where().endsWith("path", "test" + (TEST_SIZE - 1)).findFirst();
-                        if (p != null) {
-                            assertTrue(p.mayRead());
-                            assertTrue(p.mayWrite());
-                            assertTrue(p.mayManage());
-                            looperThread.testComplete();
-                        }
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissions_closed() throws IOException {
-        PermissionManager pm = user.getPermissionManager();
-        pm.close();
-
-        thrown.expect(IllegalStateException.class);
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                fail();
-            }
-            @Override
-            public void onError(ObjectServerError error) { fail(); }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getPermissions_clientReset() {
-        final PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                // Simulate reset after first request succeeded to make sure that session is
-                // alive.
-                SyncManager.simulateClientReset(SyncManager.getSession(pm.permissionRealmConfig));
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        assertEquals(3, permissions.size());
-                        looperThread.testComplete();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Ignore("The PermissionManager can only be opened from the main thread")
-    @Test
-    public void clientResetOnMultipleThreads() {
-
-        HandlerThread thread1 = new HandlerThread("handler1");
-        thread1.start();
-        Handler handler1 = new Handler(thread1.getLooper());
-
-        HandlerThread thread2 = new HandlerThread("handler2");
-        thread2.start();
-        Handler handler2 = new Handler(thread1.getLooper());
-
-        final AtomicReference<PermissionManager> pm1 = new AtomicReference<>(null);
-        final AtomicReference<PermissionManager> pm2 = new AtomicReference<>(null);
-
-        final CountDownLatch pmsOpened = new CountDownLatch(1);
-
-        // 1) Thread 1: Open PermissionManager and check permissions
-        handler1.post(new Runnable() {
-            @Override
-            public void run() {
-                PermissionManager pm = user.getPermissionManager();
-                pm1.set(pm);
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        assertInitialPermissions(permissions);
-                        pmsOpened.countDown();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-        });
-
-        // 2) Thread 2: Open PermissionManager and check permissions
-        handler2.post(new Runnable() {
-            @Override
-            public void run() {
-                PermissionManager pm = user.getPermissionManager();
-                pm2.set(pm);
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        assertInitialPermissions(permissions);
-                        pmsOpened.countDown();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-        });
-
-        TestHelper.awaitOrFail(pmsOpened);
-
-        // 3) Trigger Client Reset
-        SyncManager.simulateClientReset(SyncManager.getSession(pm1.get().permissionRealmConfig));
-        SyncManager.simulateClientReset(SyncManager.getSession(pm2.get().permissionRealmConfig));
-
-        // 4) Thread 1: Attempt to get permissions should trigger a Client Reset
-        final CountDownLatch clientResetThread1 = new CountDownLatch(1);
-        final CountDownLatch clientResetThread2 = new CountDownLatch(1);
-        handler1.post(new Runnable() {
-            @Override
-            public void run() {
-                final PermissionManager pm = pm1.get();
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        fail("Client reset should have been triggered");
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
-                        pm.close();
-                        assertFalse(new File(pm.permissionRealmConfig.getPath()).exists());
-                        clientResetThread1.countDown();
-                    }
-                });
-            }
-        });
-
-        // 5) Thread 2: Attempting to get permissions should also trigger a Client Reset even though
-        //    Thread 1 just executed it
-        TestHelper.awaitOrFail(clientResetThread1);
-        handler2.post(new Runnable() {
-            @Override
-            public void run() {
-                final PermissionManager pm = pm2.get();
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        fail("Client reset should have been triggered");
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
-                        pm.close();
-                        clientResetThread2.countDown();
-                    }
-                });
-            }
-        });
-        TestHelper.awaitOrFail(clientResetThread2);
-
-        // 6) After closing the PermissionManager, re-opening it again should work fine
-        final CountDownLatch newPmOpenedAndReady = new CountDownLatch(1);
-        handler1.post(new Runnable() {
-            @Override
-            public void run() {
-                final PermissionManager pm = user.getPermissionManager();
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        assertInitialPermissions(permissions);
-                        pm.close();
-                        newPmOpenedAndReady.countDown();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-        });
-
-        TestHelper.awaitOrFail(newPmOpenedAndReady);
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getDefaultPermissions_returnLoadedResults() {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                assertTrue(permissions.isLoaded());
-                assertInitialDefaultPermissions(permissions);
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getDefaultPermissions_noLongerValidWhenPermissionManagerIsClosed() {
-        final PermissionManager pm = user.getPermissionManager();
-        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                try {
-                    assertTrue(permissions.isValid());
-                } finally {
-                    pm.close();
-                }
-                assertFalse(permissions.isValid());
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                pm.close();
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @Ignore("FIXME Add once `setPermissions` are implemented")
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getDefaultPermissions_updatedWithNewRealms() {
-
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getDefaultPermissions_closed() throws IOException {
-        PermissionManager pm = user.getPermissionManager();
-        pm.close();
-
-        thrown.expect(IllegalStateException.class);
-        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                fail();
-            }
-            @Override
-            public void onError(ObjectServerError error) { fail(); }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void permissionManagerAsyncTask_handlePermissionRealmError() throws NoSuchFieldException, IllegalAccessException {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Simulate error in the permission Realm
-        Field permissionConfigField = pm.getClass().getDeclaredField("permissionRealmError");
-        permissionConfigField.setAccessible(true);
-        final ObjectServerError error = new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom");
-        permissionConfigField.set(pm, error);
-
-        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
-                assertTrue(error.getErrorMessage().contains("Permission Realm"));
-                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        };
-
-        // Create dummy task that can trigger the error reporting
-        runTask(pm, callback);
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void permissionManagerAsyncTask_handleManagementRealmError() throws NoSuchFieldException, IllegalAccessException {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Simulate error in the permission Realm
-        final ObjectServerError error = new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom");
-        setRealmError(pm, "managementRealmError", error);
-
-        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
-                assertTrue(error.getErrorMessage().contains("Management Realm"));
-                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        };
-
-        // Create dummy task that can trigger the error reporting
-        runTask(pm, callback);
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void permissionManagerAsyncTask_handleTwoErrorsSameErrorCode() throws NoSuchFieldException, IllegalAccessException {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Simulate error in the permission Realm
-        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom1"));
-
-        // Simulate error in the management Realm
-        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom2"));
-
-        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
-                assertTrue(error.toString().contains("Boom1"));
-                assertTrue(error.toString().contains("Boom2"));
-                looperThread.testComplete();
-            }
-        };
-
-        // Create dummy task that can trigger the error reporting
-        runTask(pm, callback);
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void permissionManagerAsyncTask_doNotReportIntermittentErrors() throws NoSuchFieldException, IllegalAccessException {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Simulate intermittent error in the management Realm that is possible to recover from
-        // These kind of errors should never reach the end user as we should recover automatically.
-        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.UNKNOWN, "Boom1"));
-
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                assertEquals(3, permissions.size());
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void permissionManagerAsyncTask_keepReportingFatalErrors() throws NoSuchFieldException, IllegalAccessException {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Simulate fatal error in the management Realm that is not possible to recover from
-        // This should be reported for all tasks, not just the first one.
-        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom1"));
-
-        pm.getPermissions(new PermissionManager.PermissionsCallback() {
-            @Override
-            public void onSuccess(RealmResults<Permission> permissions) {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        fail();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
-                        looperThread.testComplete();
-                    }
-                });
-            }
-        });
-    }
-
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void permissionManagerAsyncTask_handleTwoErrorsDifferentErrorCode() throws NoSuchFieldException, IllegalAccessException {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Simulate error in the permission Realm
-        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom1"));
-
-        // Simulate error in the management Realm
-        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.SESSION_CLOSED, "Boom2"));
-
-        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
-                assertTrue(error.toString().contains(ErrorCode.CONNECTION_CLOSED.toString()));
-                assertTrue(error.toString().contains(ErrorCode.SESSION_CLOSED.toString()));
-                looperThread.testComplete();
-            }
-        };
-
-        // Create dummy task that can trigger the error reporting
-        runTask(pm, callback);
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void applyPermissions_nonAdminUserFails() {
-        SyncUser user2 = UserFactory.createUniqueUser();
-        String otherUsersUrl = createRemoteRealm(user2, "test");
-
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Create request for setting permissions on another users Realm,
-        // i.e. user making the request do not have manage rights.
-        UserCondition condition = UserCondition.userId(user.getIdentity());
-        AccessLevel accessLevel = AccessLevel.WRITE;
-        PermissionRequest request = new PermissionRequest(condition, otherUsersUrl, accessLevel);
-
-        pm.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void applyPermissions_wrongUrlFails() {
-        String wrongUrl = createRemoteRealm(user, "test") + "-notexisting";
-
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        // Create request for setting permissions on another users Realm,
-        // i.e. user making the request do not have manage rights.
-        UserCondition condition = UserCondition.userId(user.getIdentity());
-        AccessLevel accessLevel = AccessLevel.WRITE;
-        PermissionRequest request = new PermissionRequest(condition, wrongUrl, accessLevel);
-
-        pm.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                // FIXME: Should be 614, see https://github.com/realm/ros/issues/429
-                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void applyPermissions_withUserId() {
-        final SyncUser user2 = UserFactory.createUniqueUser();
-        String url = createRemoteRealm(user2, "test");
-        PermissionManager pm2 = user2.getPermissionManager();
-        looperThread.closeAfterTest(pm2);
-
-        // Create request for giving `user` WRITE permissions to `user2`'s Realm.
-        UserCondition condition = UserCondition.userId(user.getIdentity());
-        AccessLevel accessLevel = AccessLevel.WRITE;
-        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
-
-        pm2.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                PermissionManager pm = user.getPermissionManager();
-                looperThread.closeAfterTest(pm);
-                pm.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        assertPermissionPresent(permissions, user, "/test", AccessLevel.WRITE);
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void applyPermissions_withUsername() {
-        String user1Username = TestHelper.getRandomEmail();
-        String user2Username = TestHelper.getRandomEmail();
-        final SyncUser user1 = UserFactory.createUser(user1Username);
-        final SyncUser user2 = UserFactory.createUser(user2Username);
-        PermissionManager pm1 = user1.getPermissionManager();
-        looperThread.closeAfterTest(pm1);
-
-        // Create request for giving `user2` WRITE permissions to `user1`'s Realm.
-        UserCondition condition = UserCondition.username(user2Username);
-        AccessLevel accessLevel = AccessLevel.WRITE;
-        String url = createRemoteRealm(user1, "test");
-        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
-
-        pm1.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                PermissionManager pm2 = user2.getPermissionManager();
-                looperThread.closeAfterTest(pm2);
-                pm2.getPermissions(new PermissionManager.PermissionsCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<Permission> permissions) {
-                        assertPermissionPresent(permissions, user2, user1.getIdentity() + "/test", AccessLevel.WRITE);
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void applyPermissions_usersWithNoExistingPermissions() {
-        final SyncUser user1 = UserFactory.createUser("user1@realm.io");
-        final SyncUser user2 = UserFactory.createUser("user2@realm.io");
-        PermissionManager pm1 = user1.getPermissionManager();
-        looperThread.closeAfterTest(pm1);
-
-        // Create request for giving all users with no existing permissions WRITE permissions to `user1`'s Realm.
-        UserCondition condition = UserCondition.noExistingPermissions();
-        AccessLevel accessLevel = AccessLevel.WRITE;
-        final String url = createRemoteRealm(user1, "test");
-        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
-
-        pm1.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
-            @Override
-            public void onSuccess() {
-                // Default permissions are not recorded in the __permission Realm for user2
-                // Only way to check is by opening the Realm.
-                SyncConfiguration config = user2.createConfiguration(url)
-                        .schema(AllJavaTypes.class)
-                        .waitForInitialRemoteData()
-                        .errorHandler(new SyncSession.ErrorHandler() {
-                            @Override
-                            public void onError(SyncSession session, ObjectServerError error) {
-                                fail(error.toString());
-                            }
-                        })
-                        .build();
-
-                RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
-                    @Override
-                    public void onSuccess(Realm realm) {
-                        realm.close();
-                        looperThread.testComplete();
-                    }
-
-                    @Override
-                    public void onError(Throwable exception) {
-                        fail(exception.toString());
-                    }
-                });
-                looperThread.keepStrongReference(task);
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void makeOffer() {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        String url = createRemoteRealm(user, "test");
-
-        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
-        pm.makeOffer(offer, new PermissionManager.MakeOfferCallback() {
-            @Override
-            public void onSuccess(String offerToken) {
-                assertNotNull(offerToken);
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void makeOffer_noManageAccessThrows() {
-        // User 2 creates a Realm
-        SyncUser user2 = UserFactory.createUniqueUser();
-        String url = createRemoteRealm(user2, "test");
-
-        // User 1 tries to create an offer for it.
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
-        pm.makeOffer(offer, new PermissionManager.MakeOfferCallback() {
-            @Override
-            public void onSuccess(String offerToken) {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void acceptOffer() {
-        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
-
-        final SyncUser user2 = UserFactory.createUniqueUser();
-        final PermissionManager pm = user2.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        pm.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
-            @Override
-            public void onSuccess(String url, Permission permission) {
-                assertEquals("/" + user.getIdentity() + "/test", permission.getPath());
-                assertTrue(permission.mayRead());
-                assertTrue(permission.mayWrite());
-                assertFalse(permission.mayManage());
-                assertEquals(user2.getIdentity(), permission.getUserId());
-                looperThread.testComplete();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void acceptOffer_invalidToken() {
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-        pm.acceptOffer("wrong-token", new PermissionManager.AcceptOfferCallback() {
-            @Override
-            public void onSuccess(String url, Permission permission) {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore("The offer is randomly accepted mostly on docker-02 SHIELD K1")
-    public void acceptOffer_expiredThrows() {
-        // Trying to guess how long CI is to process this. The offer cannot be created if it
-        // already expired.
-        long delayMillis = TimeUnit.SECONDS.toMillis(10);
-        Date expiresAt = new Date(new Date().getTime() + delayMillis);
-        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, expiresAt);
-        SystemClock.sleep(delayMillis); // Make sure that the offer expires.
-        final SyncUser user2 = UserFactory.createUniqueUser();
-        final PermissionManager pm = user2.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        pm.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
-            @Override
-            public void onSuccess(String url, Permission permission) {
-                fail();
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.EXPIRED_PERMISSION_OFFER, error.getErrorCode());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void acceptOffer_multipleUsers() {
-        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
-
-        final SyncUser user2 = UserFactory.createUniqueUser();
-        final SyncUser user3 = UserFactory.createUniqueUser();
-        final PermissionManager pm2 = user2.getPermissionManager();
-        final PermissionManager pm3 = user3.getPermissionManager();
-        looperThread.closeAfterTest(pm2);
-        looperThread.closeAfterTest(pm3);
-
-        final AtomicInteger offersAccepted = new AtomicInteger(0);
-        PermissionManager.AcceptOfferCallback callback = new PermissionManager.AcceptOfferCallback() {
-            @Override
-            public void onSuccess(String url, Permission permission) {
-                assertEquals("/" + user.getIdentity() + "/test", permission.getPath());
-                assertTrue(permission.mayRead());
-                assertTrue(permission.mayWrite());
-                assertFalse(permission.mayManage());
-                if (offersAccepted.incrementAndGet() == 2) {
-                    looperThread.testComplete();
-                }
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        };
-
-        pm2.acceptOffer(offerToken, callback);
-        pm3.acceptOffer(offerToken, callback);
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void getCreatedOffers() {
-        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
-        PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        pm.getCreatedOffers(new PermissionManager.OffersCallback() {
-            @Override
-            public void onSuccess(RealmResults<PermissionOffer> offers) {
-                RealmResults filteredOffers = offers.where()
-                        .equalTo("token", offerToken)
-                        .findAllAsync();
-                looperThread.keepStrongReference(offers);
-                filteredOffers.addChangeListener(new RealmChangeListener<RealmResults>() {
-                    @Override
-                    public void onChange(RealmResults results) {
-                        switch (results.size()) {
-                            case 0: return;
-                            case 1:
-                                looperThread.testComplete();
-                                break;
-                            default:
-                                fail("To many offers: " + Arrays.toString(results.toArray()));
-                        }
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void revokeOffer() {
-        // createOffer validates that the offer is actually in the __management Realm.
-        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
-        final PermissionManager pm = user.getPermissionManager();
-        looperThread.closeAfterTest(pm);
-
-        pm.revokeOffer(offerToken, new PermissionManager.RevokeOfferCallback() {
-            @Override
-            public void onSuccess() {
-                pm.getCreatedOffers(new PermissionManager.OffersCallback() {
-                    @Override
-                    public void onSuccess(RealmResults<PermissionOffer> offers) {
-                        assertEquals(0, offers.size());
-                        looperThread.testComplete();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    public void revokeOffer_afterOneAcceptEdit() {
-        // createOffer validates that the offer is actually in the __management Realm.
-        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
-
-        SyncUser user2 = UserFactory.createUniqueUser();
-        SyncUser user3 = UserFactory.createUniqueUser();
-        final PermissionManager pm1 = user.getPermissionManager();
-        PermissionManager pm2 = user2.getPermissionManager();
-        final PermissionManager pm3 = user3.getPermissionManager();
-        looperThread.closeAfterTest(pm1);
-        looperThread.closeAfterTest(pm2);
-        looperThread.closeAfterTest(pm3);
-
-        pm2.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
-            @Override
-            public void onSuccess(String realmUrl, Permission permission) {
-                pm1.revokeOffer(offerToken, new PermissionManager.RevokeOfferCallback() {
-                    @Override
-                    public void onSuccess() {
-                        pm3.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
-                            @Override
-                            public void onSuccess(String realmUrl, Permission permission) {
-                                fail("Offer should have been revoked");
-                            }
-
-                            @Override
-                            public void onError(ObjectServerError error) {
-                                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
-                                looperThread.testComplete();
-                            }
-                        });
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        fail(error.toString());
-                    }
-                });
-            }
-
-            @Override
-            public void onError(ObjectServerError error) {
-                fail(error.toString());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore("Figure out why clocks on server/emulator on CI seem to differ")
-    public void revokeOffer_alreadyExpired() {
-        fail("Implement this");
-    }
-
-    /**
-     * Creates a offer for a newly created Realm.
-     *
-     * @param user User that should create the offer
-     * @param realmName Realm to create
-     * @param level accessLevel to offer
-     * @param expires when the offer expires
-     */
-    private String createOffer(final SyncUser user, final String realmName, final AccessLevel level, final Date expires) {
-        final CountDownLatch offerReady = new CountDownLatch(1);
-        final AtomicReference<String> offer = new AtomicReference<>(null);
-        final HandlerThread ht = new HandlerThread("OfferThread");
-        ht.start();
-        Handler handler = new Handler(ht.getLooper());
-        handler.post(new Runnable() {
-            @Override
-            public void run() {
-                String url = createRemoteRealm(user, realmName);
-                final PermissionManager pm = user.getPermissionManager();
-                pm.makeOffer(new PermissionOffer(url, level, expires), new PermissionManager.MakeOfferCallback() {
-                    @Override
-                    public void onSuccess(String offerToken) {
-                        offer.set(offerToken);
-                        pm.close();
-                        offerReady.countDown();
-                    }
-
-                    @Override
-                    public void onError(ObjectServerError error) {
-                        pm.close();
-                        fail(error.toString());
-                    }
-                });
-            }
-        });
-        TestHelper.awaitOrFail(offerReady);
-        ht.quit();
-        return offer.get();
-    }
-
-    /**
-     * Wait for a given permission to be present.
-     *
-     * @param permissions permission results.
-     * @param user user that is being granted the permission.
-     * @param urlSuffix the url suffix to listen for.
-     * @param accessLevel the expected access level for 'user'.
-     */
-    private void assertPermissionPresent(RealmResults<Permission> permissions, final SyncUser user, String urlSuffix, final AccessLevel accessLevel) {
-        RealmResults<Permission> filteredPermissions = permissions.where().endsWith("path", urlSuffix).findAllAsync();
-        looperThread.keepStrongReference(permissions);
-        filteredPermissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
-            @Override
-            public void onChange(RealmResults<Permission> permissions) {
-                switch(permissions.size()) {
-                    case 0: return;
-                    case 1:
-                        Permission p = permissions.first();
-                        assertEquals(accessLevel.mayRead(), p.mayRead());
-                        assertEquals(accessLevel.mayWrite(), p.mayWrite());
-                        assertEquals(accessLevel.mayManage(), p.mayManage());
-                        assertEquals(user.getIdentity(), p.getUserId());
-                        looperThread.testComplete();
-                        break;
-                    default:
-                        fail("To many permissions matched: " + Arrays.toString(permissions.toArray()));
-                }
-            }
-        });
-    }
-
-    private void setRealmError(PermissionManager pm, String fieldName, ObjectServerError error) throws NoSuchFieldException,
-            IllegalAccessException {
-        Field managementRealmErrorField = pm.getClass().getDeclaredField(fieldName);
-        managementRealmErrorField.setAccessible(true);
-        managementRealmErrorField.set(pm, error);
-    }
-
-    private void runTask(final PermissionManager pm, final PermissionManager.ApplyPermissionsCallback callback) {
-        new PermissionManager.PermissionManagerTask<Void>(pm, callback) {
-            @Override
-            public void run() {
-                if (!checkAndReportInvalidState()) {
-                    fail();
-                }
-            }
-        }.run();
-    }
-
-    /**
-     * Creates an empty remote Realm on ROS owned by the provided user
-     */
-    private String createRemoteRealm(SyncUser user, String realmName) {
-        String url = Constants.AUTH_SERVER_URL + "~/" + realmName;
-        SyncConfiguration config = user.createConfiguration(url)
-                .name(realmName)
-                .schema(AllJavaTypes.class)
-                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
-                .build();
-
-        Realm realm = Realm.getInstance(config);
-        SyncSession session = SyncManager.getSession(config);
-        final CountDownLatch uploadLatch = new CountDownLatch(1);
-        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    uploadLatch.countDown();
-                }
-            }
-        });
-        TestHelper.awaitOrFail(uploadLatch);
-        realm.close();
-        return config.getServerUrl().toString();
-    }
-
-    /**
-     * The initial set of permissions of ROS is timing dependant. This method will identify the possible known starting
-     * states and fail if neither of these can be verified.
-     */
-    private void assertInitialPermissions(RealmResults<Permission> permissions) {
-         assertEquals("Unexpected count() for __permission Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__permission").count());
-         assertEquals("Unexpected count() for __management Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__management").count());
-    }
-
-    private void assertInitialDefaultPermissions(RealmResults<Permission> permissions) {
-         assertEquals("Unexpected count() for __wildcardpermissions Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__wildcardpermissions").count());
-    }
-
-    private void assertGreaterThan(String error, int base, long count) {
-        if (count <= base) {
-            throw new AssertionError(error);
-        }
-    }
-
-}
diff --git a/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
index b6c6bb1e30..bfc66bc7aa 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -199,13 +199,15 @@ public void copyRealmFromAssets(Context context, String realmPath, RealmConfigur
         if (new File(config.getPath()).exists()) {
             throw new IllegalStateException(String.format(Locale.ENGLISH, "%s exists!", config.getPath()));
         }
-
         File outFile = new File(config.getRealmDirectory(), config.getRealmFileName());
+        copyFileFromAssets(context, realmPath, outFile);
+    }
 
+    public void copyFileFromAssets(Context context, String assetPath, File outFile) throws IOException {
         InputStream is = null;
         FileOutputStream os = null;
         try {
-            is = context.getAssets().open(realmPath);
+            is = context.getAssets().open(assetPath);
             os = new FileOutputStream(outFile);
 
             byte[] buf = new byte[1024];
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index edcdc08940..24fde4982f 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -1,4 +1,4 @@
-FROM node:6.11.4
+FROM node:10
 
 # set timezone to Copenhagen (by default it's using UTC) to match Android's device time.
 RUN cp /usr/share/zoneinfo/Europe/Copenhagen /etc/localtime
diff --git a/tools/sync_test_server/integration-test-command-server.js b/tools/sync_test_server/integration-test-command-server.js
index f11c0cb7a3..826635747f 100755
--- a/tools/sync_test_server/integration-test-command-server.js
+++ b/tools/sync_test_server/integration-test-command-server.js
@@ -136,6 +136,7 @@ function startRealmObjectServer(onSuccess, onError) {
     }, onError)
 }
 
+// FIXME: This method seems broken in Node 10 and/or latest version of ROS
 function stopRealmObjectServer(onSuccess, onError) {
     if(syncServerChildProcess == null || syncServerChildProcess.killed) {
         onSuccess("No ROS process found or the process has been killed before");
@@ -161,7 +162,7 @@ function stopRealmObjectServer(onSuccess, onError) {
                     onSuccess();
                 });
             });
-            syncServerChildProcess.kill('SIGINT');
+            syncServerChildProcess.kill('SIGTERM');
         });
 
     }
diff --git a/version.txt b/version.txt
index 4f9633e8a5..5f68295fc1 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.16.0-SNAPSHOT
\ No newline at end of file
+6.0.0-SNAPSHOT
\ No newline at end of file
