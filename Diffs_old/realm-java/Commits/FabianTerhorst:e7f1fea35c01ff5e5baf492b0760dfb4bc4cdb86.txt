diff --git a/LICENSE b/LICENSE
index 48be149531..62e2f9e364 100644
--- a/LICENSE
+++ b/LICENSE
@@ -255,15 +255,15 @@ EXPORT COMPLIANCE
 You understand that the Software may contain cryptographic functions that may be
 subject to export restrictions, and you represent and warrant that you are not
 located in a country that is subject to United States export restriction or embargo,
-including Cuba, Iran, North Korea, Sudan, or Syria, and that you are not on the
-Department of Commerce list of Denied Persons, Unverified Parties, or affiliated
-with a Restricted Entity.
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
 
 You agree to comply with all export, re-export and import restrictions and
 regulations of the Department of Commerce or other agency or authority of the
 United States or other applicable countries. You also agree not to transfer, or
 authorize the transfer of, directly or indirectly, the Software to any prohibited
-country, including Cuba, Iran, North Korea, Sudan, or Syria, or to any person or
-organization on or affiliated with the Department of Commerce lists of Denied
-Persons, Unverified Parties or Restricted Entities, or otherwise in violation of any
-such restrictions or regulations.
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
diff --git a/README.md b/README.md
index 06621e6253..0665c1e31c 100644
--- a/README.md
+++ b/README.md
@@ -38,7 +38,7 @@ If you want to test recent bugfixes or features that have not been packaged in a
     }
 
     dependencies {
-      compile 'io.realm:realm-android:0.82.0-SNAPSHOT'
+      compile 'io.realm:realm-android:0.83.0-SNAPSHOT'
     }
 
 ## Building Realm
@@ -82,6 +82,10 @@ See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 Realm Java is published under the Apache 2.0 license.  
 The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](http://realm.io/docs/java/#faq).
 
+**This product is not being made available to any person located in Cuba, Iran,
+North Korea, Sudan, Syria or the Crimea region, or to any other person that is
+not eligible to receive the product under U.S. law.**
+
 ## Feedback
 
 **_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](http://twitter.com/realm), announce your app on [our mailing-list](https://groups.google.com/forum/#!forum/realm-java), or email [help@realm.io](mailto:help@realm.io) to let us know about it!_**
diff --git a/changelog.txt b/changelog.txt
index fba099f986..a77eda2796 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,11 +1,33 @@
+0.83
+ * BREAKING CHANGE: Removed deprecated methods and constructors from the Realm class.
+ * Fixed an issue preventing the call of listeners on refresh().
+
+0.82.2
+ * Fixed a bug which might cause failure when loading the native library.
+ * Fixed a bug which might trigger a timeout in Context.finalize().
+ * Fixed a bug which might cause RealmObject.isValid() to throw an exception if the object is deleted.
+ * Updated Realm core to version 0.89.9
+   - Fixed a potential stack overflow issue which might cause a crash when encryption was used.
+   - Embedded crypto functions into Realm dynamic lib to avoid random issues on some devices.
+   - Throw RealmEncryptionNotSupportedException if the device doesn't support Realm encryption. At least one device type (HTC One X) contains system bugs that prevents Realm's encryption from functioning properly. This is now detected, and an exception is thrown when trying to open/create an encrypted Realm file. It's up to the application to catch this and decide if it's OK to proceed without encryption instead.
+
+0.82.1
+ * Fixed a bug where using the wrong encryption key first caused the right key to be seen as invalid.
+ * Fixed a bug where String fields were ignored when updating objects from JSON with null values.
+ * Fixed a bug when calling System.exit(0), the process might hang.
+
 0.82
  * Support async queries & transactions.
+ * RealmConfiguration.setModules() now accept ignore null values which Realm.getDefaultModule() might return.
+>>>>>>> master
  * Trying to access a deleted Realm object throw throws a proper IllegalStateException.
  * Added in-memory Realm support.
  * Closing Realm on another thread different from where it was created now throws an exception.
  * Realm will now throw a RealmError when Realm's underlying storage engine encounters an unrecoverable error.
  * @Index annotation can also be applied to byte/short/int/long/boolean/Date now.
- * Fields with annotation @PrimaryKey are indexed automatically now.
+ * BREAKING CHANGE: Fields with annotation @PrimaryKey are indexed automatically now. Older schemas require a migration.
+ * Fixed a bug where RealmQuery objects are prematurely garbage collected.
+ * Removed RealmQuery.between() for link queries.
 
 0.81.1
  * Fixed memory leak causing Realm to never release Realm objects.
@@ -20,7 +42,7 @@
  * RealmList.add(), RealmList.addAt() and RealmList.set() now copy standalone objects transparently into Realm.
  * Realm now works with Kotlin (M12+). (thanks @cypressious)
  * Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
- * Added a check to give a better error message when null is used as value for a primary key. 
+ * Added a check to give a better error message when null is used as value for a primary key.
  * Fixed unchecked cast warnings when building with Realm.
  * Cleaned up examples (remove old test project).
  * Added checking for missing generic type in RealmList fields in annotation processor.
@@ -34,7 +56,7 @@
  * Fixed a memory leak when using RealmBaseAdapter.
  * RealmBaseAdapter now allow RealmResults to be null (thanks @zaki50).
  * Fixed a bug where a change to a model class (RealmList<A> to RealmList<B>) would not throw a RealmMigrationNeededException.
- * Fixed a bug where where setting multiple RealmLists didn't remove the previously added objects.
+ * Fixed a bug where setting multiple RealmLists didn't remove the previously added objects.
  * Solved ConcurrentModificationException thrown when addChangeListener/removeChangeListener got called in the onChange. (thanks @beeender)
  * Fixed duplicated listeners in the same realm instance. Trying to add duplicated listeners is ignored now. (thanks @beeender)
 
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index e70eabd5c3..fbd3542630 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -131,8 +131,6 @@ public boolean shouldSkipClass(Class<?> clazz) {
     }
 
     public void updateCities() {
-        Realm realm = Realm.getInstance(this);
-
         // Pull all the cities from the realm
         RealmResults<City> cities = realm.where(City.class).findAll();
 
@@ -146,9 +144,6 @@ public void updateCities() {
     public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
         City modifiedCity = (City)mAdapter.getItem(position);
 
-        // Update the realm object affected by the user
-        Realm realm = Realm.getInstance(this);
-
         // Acquire the list of realm cities matching the name of the clicked City.
         City city = realm.where(City.class).equalTo("name", modifiedCity.getName()).findFirst();
 
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 5b8238fcd1..b8e1ca5f40 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -22,6 +22,11 @@ android {
     command {
         events 2000
     }
+
+    // Incremental builds currently doesn't work with Kotlin
+    dexOptions {
+        incremental false
+    }
 }
 
 tasks.preBuild {
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
index 70747b7b8f..c86fc65170 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
@@ -36,7 +36,7 @@ public long execute(Realm realm, long version) {
         /*
             // Version 0
             class Person
-                String fullName;
+                String firstName;
                 String lastName;
                 int    age;
 
diff --git a/examples/realmModuleExample/app/proguard-rules.pro b/examples/realmModuleExample/app/proguard-rules.pro
index fe49641ad9..58151fa054 100644
--- a/examples/realmModuleExample/app/proguard-rules.pro
+++ b/examples/realmModuleExample/app/proguard-rules.pro
@@ -17,6 +17,7 @@
 #}
 
 # Realm ProGuard setup
+-keep class io.realm.annotations.RealmModule
 -keep @io.realm.annotations.RealmModule class *
 -dontwarn javax.**
 -dontwarn io.realm.**
diff --git a/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index ed25f0363e..85f20e7e3f 100644
--- a/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -8,6 +8,6 @@ class Realm implements Plugin<Project> {
     @Override
     void apply(Project project) {
     	project.repositories.add(project.repositories.jcenter())
-        project.dependencies.add('compile', 'io.realm:realm-android:0.81.1') // TODO: make version dynamic
+        project.dependencies.add('compile', 'io.realm:realm-android:0.82.1') // TODO: make version dynamic
     }
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index bc7fc4e854..374bb640fb 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -16,13 +16,9 @@
 
 package io.realm.processor;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Element;
@@ -36,10 +32,13 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
-
-import io.realm.annotations.Ignore;
-import io.realm.annotations.Index;
-import io.realm.annotations.PrimaryKey;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 /**
  * Utility class for holding metadata for RealmProxy classes.
@@ -377,6 +376,10 @@ public boolean isModelClass() {
         return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
     }
 
+    public String getPackageName() {
+        return packageName;
+    }
+
     public String getFullyQualifiedClassName() {
         return packageName + "." + className;
     }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java
new file mode 100644
index 0000000000..be426f28db
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.net.URL;
+import java.security.NoSuchAlgorithmException;
+import java.util.Enumeration;
+import java.util.Set;
+
+// Asynchronously submits build information to Realm when the annotation
+// processor is running
+//
+// To be clear: this does *not* run when your app is in production or on
+// your end-user's devices; it will only run when you build your app from source.
+//
+// Why are we doing this? Because it helps us build a better product for you.
+// None of the data personally identifies you, your employer or your app, but it
+// *will* help us understand what Realm version you use, what host OS you use,
+// etc. Having this info will help with prioritizing our time, adding new
+// features and deprecating old features. Collecting an anonymized bundle &
+// anonymized MAC is the only way for us to count actual usage of the other
+// metrics accurately. If we don't have a way to deduplicate the info reported,
+// it will be useless, as a single developer building their app on Windows ten
+// times would report 10 times more than a single developer that only builds
+// once from Mac OS X, making the data all but useless. No one likes sharing
+// data unless it’s necessary, we get it, and we’ve debated adding this for a
+// long long time. Since Realm is a free product without an email signup, we
+// feel this is a necessary step so we can collect relevant data to build a
+// better product for you.
+//
+// Currently the following information is reported:
+// - What version of Realm is being used
+// - What OS you are running on
+// - An anonymized MAC address and bundle ID to aggregate the other information on.
+public class RealmAnalytics {
+    private static RealmAnalytics instance;
+    private static final int READ_TIMEOUT = 2000;
+    private static final int CONNECT_TIMEOUT = 4000;
+    private static final String ADDRESS_PREFIX = "https://api.mixpanel.com/track/?data=";
+    private static final String ADDRESS_SUFFIX = "&ip=1";
+    private static final String TOKEN = "ce0fac19508f6c8f20066d345d360fd0";
+    private static final String EVENT_NAME = "Run";
+    private static final String JSON_TEMPLATE
+            = "{\n"
+            + "   \"event\": \"%EVENT%\",\n"
+            + "   \"properties\": {\n"
+            + "      \"token\": \"%TOKEN%\",\n"
+            + "      \"distinct_id\": \"%USER_ID%\",\n"
+            + "      \"Anonymized MAC Address\": \"%USER_ID%\",\n"
+            + "      \"Anonymized Bundle ID\": \"%APP_ID%\",\n"
+            + "      \"Binding\": \"java\",\n"
+            + "      \"Realm Version\": \"%REALM_VERSION%\",\n"
+            + "      \"Host OS Type\": \"%OS_TYPE%\",\n"
+            + "      \"Host OS Version\": \"%OS_VERSION%\",\n"
+            + "      \"Target OS Type\": \"android\"\n"
+            + "   }\n"
+            + "}";
+
+    // The list of packages the model classes reside in
+    private Set<String> packages;
+
+    private RealmAnalytics(Set<String> packages) {
+        this.packages = packages;
+    }
+
+    public static RealmAnalytics getInstance(Set<String> packages) {
+        if (instance == null) {
+            instance = new RealmAnalytics(packages);
+        }
+        return instance;
+    }
+
+    private void send() {
+        try {
+            URL url = getUrl();
+            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod("GET");
+            connection.connect();
+            connection.getResponseCode();
+        } catch (Exception ignored) {
+        }
+    }
+
+    public void execute() {
+        Thread backgroundThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                send();
+            }
+        });
+        backgroundThread.start();
+        try {
+            backgroundThread.join(CONNECT_TIMEOUT + READ_TIMEOUT);
+        } catch (InterruptedException ignored) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        } catch (IllegalArgumentException ignored) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        }
+    }
+
+    public URL getUrl() throws
+            MalformedURLException,
+            SocketException,
+            NoSuchAlgorithmException,
+            UnsupportedEncodingException {
+        return new URL(ADDRESS_PREFIX + Utils.base64Encode(generateJson()) + ADDRESS_SUFFIX);
+    }
+
+    public String generateJson() throws SocketException, NoSuchAlgorithmException {
+        return JSON_TEMPLATE
+                .replaceAll("%EVENT%", EVENT_NAME)
+                .replaceAll("%TOKEN%", TOKEN)
+                .replaceAll("%USER_ID%", getAnonymousUserId())
+                .replaceAll("%APP_ID%", getAnonymousAppId())
+                .replaceAll("%REALM_VERSION%", Version.VERSION)
+                .replaceAll("%OS_TYPE%", System.getProperty("os.name"))
+                .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
+    }
+
+    /**
+     * Compute an anonymous user id from the hashed MAC address of the first network interface
+     * @return the anonymous user id
+     * @throws NoSuchAlgorithmException
+     * @throws SocketException
+     */
+    public static String getAnonymousUserId() throws NoSuchAlgorithmException, SocketException {
+        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+
+        if (!networkInterfaces.hasMoreElements()) {
+            throw new IllegalStateException("No network interfaces detected");
+        }
+
+        NetworkInterface networkInterface = networkInterfaces.nextElement();
+        byte[] hardwareAddress = networkInterface.getHardwareAddress(); // Normally this is the MAC address
+
+        return Utils.hexStringify(Utils.sha256Hash(hardwareAddress));
+    }
+
+    /**
+     * Compute an anonymous app/library id from the packages containing Realm model classes
+     * @return the anonymous app/library id
+     * @throws NoSuchAlgorithmException
+     */
+    public String getAnonymousAppId() throws NoSuchAlgorithmException {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (String modelPackage : packages) {
+            stringBuilder.append(modelPackage).append(":");
+        }
+        byte[] packagesBytes = stringBuilder.toString().getBytes();
+
+        return Utils.hexStringify(Utils.sha256Hash(packagesBytes));
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index c04722c74d..ee547626a9 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -163,22 +163,54 @@ private SimpleTypeConverter(String castType, String jsonType) {
 
         @Override
         public void emitTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-            writer
-                .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("obj.%s((%s) json.get%s(\"%s\"))",
-                        setter,
-                        castType,
-                        jsonType,
-                        fieldName)
-                .endControlFlow();
+            // TODO: This checking should be removed after nullable support for all types.
+            //       And the else block should be removed as well.
+            if (Utils.isString(fieldType)) {
+                writer
+                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                            .emitStatement("obj.%s(\"\")", setter)
+                        .nextControlFlow("else")
+                            .emitStatement("obj.%s((%s) json.get%s(\"%s\"))",
+                                    setter,
+                                    castType,
+                                    jsonType,
+                                    fieldName)
+                        .endControlFlow()
+                    .endControlFlow();
+            } else {
+                writer
+                    .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("obj.%s((%s) json.get%s(\"%s\"))",
+                                setter,
+                                castType,
+                                jsonType,
+                                fieldName)
+                    .endControlFlow();
+            }
         }
 
         @Override
         public void emitStreamTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-            writer.emitStatement("obj.%s((%s) reader.next%s())",
-                    setter,
-                    castType,
-                    jsonType);
+            // TODO: This checking should be removed after nullable support for all types.
+            //       And remove the else block as well.
+            if (Utils.isString(fieldType)) {
+                writer
+                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                        .emitStatement("obj.%s(\"\")", setter)
+                        .emitStatement("reader.skipValue()")
+                    .nextControlFlow("else")
+                        .emitStatement("obj.%s((%s) reader.next%s())",
+                                setter,
+                                castType,
+                                jsonType)
+                    .endControlFlow();
+            } else {
+                writer.emitStatement("obj.%s((%s) reader.next%s())",
+                        setter,
+                        castType,
+                        jsonType);
+            }
         }
     }
 
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index f7dd18c9c7..a49892639c 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -16,10 +16,7 @@
 
 package io.realm.processor;
 
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
+import io.realm.annotations.RealmClass;
 
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
@@ -28,8 +25,11 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
-
-import io.realm.annotations.RealmClass;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 
 /**
  * The RealmProcessor is responsible for creating the plumbing that connects the RealmObjects to a Realm. The process
@@ -95,7 +95,7 @@
         "io.realm.annotations.Ignore",
         "io.realm.annotations.Index",
         "io.realm.annotations.PrimaryKey",
-        "io.realm.annotations.internal.RealmModule"
+        "io.realm.annotations.RealmModule"
 })
 public class RealmProcessor extends AbstractProcessor {
 
@@ -111,10 +111,14 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         if (hasProcessedModules) {
             return true;
         }
+
         RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
         updateChecker.executeRealmVersionUpdate();
+
         Utils.initialize(processingEnv);
 
+        Set<String> packages = new TreeSet<String>();
+
         // Create all proxy classes
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
@@ -132,6 +136,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 return true; // Abort processing by claiming all annotations
             }
             classesToValidate.add(metadata);
+            packages.add(metadata.getPackageName());
 
             RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, metadata);
             try {
@@ -143,6 +148,12 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             }
 	    }
 
+        String environmentVariable = System.getenv("REALM_DISABLE_ANALYTICS");
+        if (environmentVariable == null || !environmentVariable.equals("true")) {
+            RealmAnalytics analytics = RealmAnalytics.getInstance(packages);
+            analytics.execute();
+        }
+
         hasProcessedModules = true;
         return processModules(roundEnv);
     }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 4a1dd6f286..b990c5f1f2 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -806,10 +806,20 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
 
-            if (i == 0) {
-                writer.beginControlFlow("if (name.equals(\"%s\") && reader.peek() != JsonToken.NULL)", fieldName);
+            if (Utils.isString(qualifiedFieldType)) {
+                if (i == 0) {
+                    writer.beginControlFlow("if (name.equals(\"%s\"))", fieldName);
+                } else {
+                    writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
+                }
             } else {
-                writer.nextControlFlow("else if (name.equals(\"%s\")  && reader.peek() != JsonToken.NULL)", fieldName);
+                // TODO: This else block should be removed after nullable support for all types
+                //       as well as the condition checking.
+                if (i == 0) {
+                    writer.beginControlFlow("if (name.equals(\"%s\") && reader.peek() != JsonToken.NULL)", fieldName);
+                } else {
+                    writer.nextControlFlow("else if (name.equals(\"%s\")  && reader.peek() != JsonToken.NULL)", fieldName);
+                }
             }
             if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index b2ba192cf3..d2de94dc08 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -1,6 +1,8 @@
 package io.realm.processor;
 
-import java.lang.reflect.ParameterizedType;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
 import javax.annotation.processing.Messager;
@@ -14,6 +16,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.xml.bind.DatatypeConverter;
 
 /**
  * Utility methods working with the Realm processor.
@@ -69,6 +72,16 @@ public static boolean isString(VariableElement field) {
         return getFieldTypeSimpleName(field).equals("String");
     }
 
+    /**
+     * Returns true if a given field type string is "java.lang.String", false otherwise.
+     */
+    public static boolean isString(String fieldType) {
+        if (fieldType == null) {
+            return false;
+        }
+        return String.class.getName().equals(fieldType);
+    }
+
     /**
      * Returns the simple type name for a field.
      */
@@ -129,4 +142,39 @@ public static void note(String message) {
     public static Element getSuperClass(TypeElement classType) {
         return typeUtils.asElement(classType.getSuperclass());
     }
+
+    /**
+     * Encode the given string with Base64
+     * @param data the string to encode
+     * @return the encoded string
+     * @throws UnsupportedEncodingException
+     */
+    public static String base64Encode(String data) throws UnsupportedEncodingException {
+        return DatatypeConverter.printBase64Binary(data.getBytes("UTF-8"));
+    }
+
+    /**
+     * Compute the SHA-256 hash of the given byte array
+     * @param data the byte array to hash
+     * @return the hashed byte array
+     * @throws NoSuchAlgorithmException
+     */
+    public static byte[] sha256Hash(byte[] data) throws NoSuchAlgorithmException {
+        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+        return messageDigest.digest(data);
+    }
+
+    /**
+     * Convert a byte array to its hex-string
+     * @param data the byte array to convert
+     * @return the hex-string of the byte array
+     */
+    public static String hexStringify(byte[] data) {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (byte singleByte : data) {
+            stringBuilder.append(Integer.toString((singleByte & 0xff) + 0x100, 16).substring(1));
+        }
+
+        return stringBuilder.toString();
+    }
 }
diff --git a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index ef72c8aad8..c9a8957552 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -335,8 +335,12 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
         if (obj == null) {
             obj = realm.createObject(AllTypes.class);
         }
-        if (!json.isNull("columnString")) {
-            obj.setColumnString((String) json.getString("columnString"));
+        if (json.has("columnString")) {
+            if (json.isNull("columnString")) {
+                obj.setColumnString("");
+            } else {
+                obj.setColumnString((String) json.getString("columnString"));
+            }
         }
         if (!json.isNull("columnLong")) {
             obj.setColumnLong((long) json.getLong("columnLong"));
@@ -382,8 +386,13 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
-            if (name.equals("columnString") && reader.peek() != JsonToken.NULL) {
-                obj.setColumnString((String) reader.nextString());
+            if (name.equals("columnString")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    obj.setColumnString("");
+                    reader.skipValue();
+                } else {
+                    obj.setColumnString((String) reader.nextString());
+                }
             } else if (name.equals("columnLong")  && reader.peek() != JsonToken.NULL) {
                 obj.setColumnLong((long) reader.nextLong());
             } else if (name.equals("columnFloat")  && reader.peek() != JsonToken.NULL) {
@@ -601,4 +610,4 @@ public boolean equals(Object o) {
         return true;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 4c54eb3c62..2b7b4265be 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -131,8 +131,12 @@ public static String getTableName() {
     public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
         Simple obj = realm.createObject(Simple.class);
-        if (!json.isNull("name")) {
-            obj.setName((String) json.getString("name"));
+        if (json.has("name")) {
+            if (json.isNull("name")) {
+                obj.setName("");
+            } else {
+                obj.setName((String) json.getString("name"));
+            }
         }
         if (!json.isNull("age")) {
             obj.setAge((int) json.getInt("age"));
@@ -146,8 +150,13 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
-            if (name.equals("name") && reader.peek() != JsonToken.NULL) {
-                obj.setName((String) reader.nextString());
+            if (name.equals("name")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    obj.setName("");
+                    reader.skipValue();
+                } else {
+                    obj.setName((String) reader.nextString());
+                }
             } else if (name.equals("age")  && reader.peek() != JsonToken.NULL) {
                 obj.setAge((int) reader.nextInt());
             } else {
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
index d444451754..33f3fe4ea4 100644
--- a/realm-jni/build.gradle
+++ b/realm-jni/build.gradle
@@ -147,7 +147,7 @@ targets.each { target ->
         dependsOn "generateNdkToolchain${target.toolchain.name.capitalize()}"
         environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
         environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
-        environment STRIP: "${target.toolchain.commandPrefix}-strip"
+        environment STRIP: "${target.toolchain.commandPrefix}-strip -o librealm-jni-${target.name}-stripped.so"
         environment REALM_ANDROID: '1'
         commandLine = [
             'make',
@@ -162,11 +162,19 @@ targets.each { target ->
         ]
     }
 
-    task "copyAndroidJni${target.name.capitalize()}"(type: Copy) {
-        dependsOn "buildAndroidJni${target.name.capitalize()}"
-        from "${projectDir}/src/librealm-jni-${target.name}.so"
-        into "${projectDir}/../realm/src/main/jniLibs/${target.jniFolder}"
-        rename "librealm-jni-${target.name}.so", 'librealm-jni.so'
+    task "copyAndroidJni${target.name.capitalize()}"(dependsOn: "buildAndroidJni${target.name.capitalize()}") << {
+        copy {
+            from "${projectDir}/src/librealm-jni-${target.name}-stripped.so"
+            into "${projectDir}/../realm/src/main/jniLibs/${target.jniFolder}"
+            rename "librealm-jni-${target.name}-stripped.so", 'librealm-jni.so'
+        }
+
+        // Store the unstripped version
+        copy {
+            from "${projectDir}/src/librealm-jni-${target.name}.so"
+            into "${projectDir}/../build/output/jniLibs-unstripped/${target.jniFolder}"
+            rename "librealm-jni-${target.name}.so", 'librealm-jni.so'
+        }
     }
 }
 
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
index bed6e19add..8eb9c63f77 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -222,21 +222,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
 {
     GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
+    if (arr_len == 1) {
+        if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
+            return;
+        try {
             Q(nativeQueryPtr)->between(S(arr[0]), static_cast<int64_t>(value1), static_cast<int64_t>(value2));
-        }
-        else {
-            Q(nativeQueryPtr)->group();
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value1));
-            tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value2));
-            Q(nativeQueryPtr)->end_group();
-        }
-    } CATCH_STD()
+        } CATCH_STD()
+    }
+    else {
+        ThrowException(env, IllegalArgument, "between does not support link queries.");
+    }
     RELEASE_ARRAY();
 }
 
diff --git a/realm-jni/src/io_realm_internal_Util.cpp b/realm-jni/src/io_realm_internal_Util.cpp
index 77e1ce5779..aac1a5420c 100644
--- a/realm-jni/src/io_realm_internal_Util.cpp
+++ b/realm-jni/src/io_realm_internal_Util.cpp
@@ -102,7 +102,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
             if (dotest)
                 ThrowException(env, UnsupportedOperation, "parm1", "parm2");
             break;
-                ThrowException(env, OutOfMemory, "parm1", "parm2");
         case OutOfMemory:
             expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
             if (dotest)
@@ -121,7 +120,12 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
         case RowInvalid:
             expect = "java.lang.IllegalStateException: Illegal State: parm1";
             if (dotest)
-                ThrowException(env, TableInvalid, "parm1", "parm2");
+                ThrowException(env, RowInvalid, "parm1", "parm2");
+            break;
+        case EncryptionNotSupported:
+            expect = "io.realm.exceptions.RealmEncryptionNotSupportedException: parm1";
+            if (dotest)
+                ThrowException(env, EncryptionNotSupported, "parm1", "parm2");
             break;
     }
     if (dotest) {
diff --git a/realm-jni/src/io_realm_internal_tableview.cpp b/realm-jni/src/io_realm_internal_tableview.cpp
index f138569147..4f14f97ba3 100644
--- a/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm-jni/src/io_realm_internal_tableview.cpp
@@ -962,9 +962,10 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString(
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
-  (JNIEnv *env, jobject, jlong nativeViewPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
+    JNIEnv *env, jobject, jlong nativeViewPtr)
 {
+    TR_ENTER_PTR(nativeViewPtr)
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return 0;
diff --git a/realm-jni/src/util.cpp b/realm-jni/src/util.cpp
index 0b00e83dfc..59d9993056 100644
--- a/realm-jni/src/util.cpp
+++ b/realm-jni/src/util.cpp
@@ -18,6 +18,7 @@
 #include <stdexcept>
 
 #include <realm/util/assert.hpp>
+#include <realm/util/encryption_not_supported_exception.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
@@ -33,6 +34,10 @@ void ConvertException(JNIEnv* env, const char *file, int line)
     try {
         throw;
     }
+    catch (realm::util::EncryptionNotSupportedOnThisDevice& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, EncryptionNotSupported, ss.str());
+    }
     catch (std::bad_alloc& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, OutOfMemory, ss.str());
@@ -121,16 +126,18 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             jExceptionClass = env->FindClass("java/lang/RuntimeException");
             message = classStr;
             break;
-
         case RowInvalid:
             jExceptionClass = env->FindClass("java/lang/IllegalStateException");
             message = "Illegal State: " + classStr;
             break;
-
         case BadVersion:
             jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
             message = "Handover failed due to version mismatch: " + classStr;
             break;
+        case EncryptionNotSupported:
+            jExceptionClass = env->FindClass("io/realm/exceptions/RealmEncryptionNotSupportedException");
+            message = classStr;
+            break;
     }
     if (jExceptionClass != NULL) {
         env->ThrowNew(jExceptionClass, message.c_str());
diff --git a/realm-jni/src/util.hpp b/realm-jni/src/util.hpp
index 397fc59f79..aac1f0428e 100644
--- a/realm-jni/src/util.hpp
+++ b/realm-jni/src/util.hpp
@@ -106,7 +106,6 @@ std::string num_to_string(T pNumber)
 #define CH(ptr) reinterpret_cast<ClientHistory*>(ptr)
 
 // Exception handling
-
 enum ExceptionKind {
     ClassNotFound = 0,
     NoSuchField = 1,
@@ -123,7 +122,10 @@ enum ExceptionKind {
     FatalError = 11,
     RuntimeError = 12,
     RowInvalid = 13,
-    BadVersion = 14
+    BadVersion = 15
+    EncryptionNotSupported = 14
+// NOTE!!!!: Please also add test cases to Util.java when introducing a new exception kind.
+>>>>>>> master
 };
 
 void ConvertException(JNIEnv* env, const char *file, int line);
diff --git a/realm/build.gradle b/realm/build.gradle
index 2c7f7eace0..5ab7ebfd00 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -211,6 +211,7 @@ task generateDistributionExamplesBuildFiles << {
 task populateDistributionFolder(dependsOn: ['androidJar', 'bundleJavadocRelease']) << {
     copy {
         from '../changelog.txt'
+        from '../LICENSE'
         from "build/libs/realm-${version}.jar"
         from "build/libs/realm-${version}-javadoc.jar"
         into '../distribution'
@@ -314,9 +315,15 @@ task tagRepo(type: Exec) {
     commandLine 'git', 'tag', '-a', "v${version}", '-m', "v${version}"
 }
 
-task pushTag(type: Exec) {
+task pushRepo(type: Exec) {
     dependsOn tagRepo
     workingDir rootDir
+    commandLine 'git', 'push'
+}
+
+task pushTag(type: Exec) {
+    dependsOn pushRepo
+    workingDir rootDir
     commandLine 'git', 'push', '--tags'
 }
 
diff --git a/realm/src/androidTest/AndroidManifest.xml b/realm/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..d7fa5a811c
--- /dev/null
+++ b/realm/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm">
+
+    <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22" />
+
+    <application>
+        <uses-library android:name="android.test.runner" />
+        <service
+            android:name=".services.RemoteProcessService"
+            android:enabled="true"
+            android:exported="true"
+            android:process=":remote" >
+        </service>
+    </application>
+
+</manifest>
diff --git a/realm/src/androidTest/assets/all_types_primary_key_null.json b/realm/src/androidTest/assets/all_types_primary_key_null.json
new file mode 100644
index 0000000000..fd1536e4c4
--- /dev/null
+++ b/realm/src/androidTest/assets/all_types_primary_key_null.json
@@ -0,0 +1,11 @@
+{
+	"columnString" : null,
+	"columnLong" : 1,
+	"columnFloat" : null,
+	"columnDouble" : null,
+	"columnBoolean" : null,
+	"columnBinary" : null,
+	"columnDate" : null,
+	"columnRealmObject" : null,
+	"columnRealmList" : null
+}
diff --git a/realm/src/androidTest/assets/encrypted.realm b/realm/src/androidTest/assets/encrypted.realm
new file mode 100644
index 0000000000..d61e5677e0
Binary files /dev/null and b/realm/src/androidTest/assets/encrypted.realm differ
diff --git a/realm/src/androidTest/java/io/realm/NotificationsTest.java b/realm/src/androidTest/java/io/realm/NotificationsTest.java
index 79490545fb..8f6b3411d4 100644
--- a/realm/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/src/androidTest/java/io/realm/NotificationsTest.java
@@ -42,7 +42,7 @@
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
+        Realm.deleteRealm(TestHelper.createConfiguration(getContext()));
     }
 
     @Override
@@ -347,9 +347,10 @@ public void run() {
     }
 
     public void testHandlerNotRemovedToSoon() {
-        Realm.deleteRealmFile(getContext(), "private-realm");
-        Realm instance1 = Realm.getInstance(getContext(), "private-realm");
-        Realm instance2 = Realm.getInstance(getContext(), "private-realm");
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "private-realm");
+        Realm.deleteRealm(realmConfig);
+        Realm instance1 = Realm.getInstance(realmConfig);
+        Realm instance2 = Realm.getInstance(realmConfig);
         assertEquals(instance1.getPath(), instance2.getPath());
         assertNotNull(instance1.getHandler());
 
diff --git a/realm/src/androidTest/java/io/realm/RealmAdapterTest.java b/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
index 88b0d7c9a3..3457db2bbc 100644
--- a/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
@@ -32,8 +32,9 @@
 
     protected void setUp() throws Exception {
         super.setUp();
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
 
         testRealm.beginTransaction();
         for (int i = 0; i < TEST_DATA_SIZE; ++i) {
diff --git a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
index 74b9de8ef6..5b7dcaea6b 100644
--- a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
@@ -31,8 +31,9 @@
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
         testRealm.beginTransaction();
         AnnotationTypes object = testRealm.createObject(AnnotationTypes.class);
         object.setNotIndexString("String 1");
diff --git a/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java b/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java
index d486076c23..abc13b528e 100644
--- a/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java
@@ -79,6 +79,15 @@ public void testNullDirThrows() {
         }
     }
 
+    public void testGetInstanceCreateSubFoldersThrows() {
+        File folder = new File(getContext().getFilesDir().getAbsolutePath() + "/subfolder1/subfolder2/");
+        try {
+            new RealmConfiguration.Builder(folder).build();
+            fail("Assuming that subfolders are created automatically should fail");
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
     public void testNullNameThrows() {
         try {
             new RealmConfiguration.Builder(getContext()).name(null).build();
@@ -95,6 +104,18 @@ public void testEmptyNameThrows() {
         }
     }
 
+    public void testInstanceIdForHashCollision() {
+        // Ea.hashCode() == FB.hashCode()
+        RealmConfiguration configA = TestHelper.createConfiguration(getContext(), "Ea");
+        RealmConfiguration configB = TestHelper.createConfiguration(getContext(), "FB");
+        Realm.deleteRealm(configA);
+        Realm.deleteRealm(configB);
+
+        Realm r1 = Realm.getInstance(configA);
+        Realm r2 = Realm.getInstance(configB);
+        assertNotSame(r1, r2);
+    }
+
     public void testNullKeyThrows() {
         try {
             new RealmConfiguration.Builder(getContext()).encryptionKey(null).build();
@@ -172,22 +193,6 @@ public void testNullMigrationThrows() {
         }
     }
 
-    public void testSetModulesNullThrows() {
-        // Test first argument
-        try {
-            new RealmConfiguration.Builder(getContext()).setModules(null);
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
-
-        // Test second argument
-        try {
-            new RealmConfiguration.Builder(getContext()).setModules(Realm.getDefaultModule(), null, null);
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
     public void testSetModulesNonRealmModulesThrows() {
         // Test first argument
         try {
@@ -205,7 +210,7 @@ public void testSetModulesNonRealmModulesThrows() {
     }
 
     public void testSetModules() {
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).setModules(Realm.getDefaultModule()).build();
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).setModules(Realm.getDefaultModule(), null).build();
         realm = Realm.getInstance(realmConfig);
         assertNotNull(realm.getTable(AllTypes.class));
     }
diff --git a/realm/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/src/androidTest/java/io/realm/RealmInterprocessTest.java
new file mode 100644
index 0000000000..214acdc2f6
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -0,0 +1,290 @@
+package io.realm;
+
+import android.annotation.SuppressLint;
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.test.AndroidTestCase;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AllTypes;
+import io.realm.services.RemoteProcessService;
+
+// This is built for testing multi processes related cases.
+// To build a test case, create an InterprocessHandler in your test case. This handler will run in the newly
+// created thread's Looper. Remember to call Looper.loop() to start handling messages.
+// Pass the first thing you want to run to the constructor which will be posted to the beginning of the message queue.
+// And add steps you want to run in the remote process in RemoteProcessService.
+// Write the comments of the test case like this:
+// A-Z means steps running from remote service process.
+// 1-9xx means steps running from the main local process.
+// eg.: A. Open a Realm
+//      1. Open two Realms
+//      B. Open three Realms
+//      2. assertTrue("OK, remote process win. You can open more Realms than I do in the main local process", false);
+public class RealmInterprocessTest extends AndroidTestCase {
+    private Realm testRealm;
+    private Messenger remoteMessenger;
+    private Messenger localMessenger;
+    private CountDownLatch serviceStartLatch;
+    private final ServiceConnection serviceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
+            remoteMessenger = new Messenger(iBinder);
+            serviceStartLatch.countDown();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName componentName) {
+            if (serviceStartLatch != null && serviceStartLatch.getCount() > 1) {
+                serviceStartLatch.countDown();
+            }
+            serviceStartLatch = null;
+        }
+    };
+
+    // It is necessary to overload this method.
+    // AndroidTestRunner does call Looper.prepare() and we can have a looper in the case. The problem is all the test
+    // cases are running in a single thread!!! And after Looper.quit() called, it cannot start again. That means we
+    // can only have one case in this class LoL.
+    // By overloading this method, we create a new thread and looper to run the real case. And use latch to wait until
+    // it is finished. Then we can get rid of creating the thread in the test method, using array to store exception, many
+    // levels of nested code. Make the test case more nature.
+    @Override
+    public void runBare() throws Throwable {
+        final Throwable[] throwableArray = new Throwable[1];
+        final CountDownLatch latch = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                try {
+                    RealmInterprocessTest.super.runBare();
+                } catch (Throwable throwable) {
+                    throwableArray[0] = throwable;
+                } finally {
+                    latch.countDown();
+                }
+            }
+        });
+
+        thread.start();
+        latch.await();
+
+        if (throwableArray[0] != null) {
+            throw throwableArray[0];
+        }
+    }
+
+    // Helper handler to make it easy to interact with remote service process.
+    @SuppressLint("HandlerLeak") // SuppressLint bug, doesn't work
+    private class InterprocessHandler extends Handler {
+        // Timeout Watchdog. In case the service crashed or expected response is not returned.
+        // It is very important to feed the dog after the expected message arrived.
+        private final int timeout = 5000;
+        private volatile boolean isTimeout = true;
+        private Runnable timeoutRunnable = new Runnable() {
+            @Override
+            public void run() {
+                if (isTimeout) {
+                    assertTrue("Timeout happened", false);
+                } else {
+                    isTimeout = true;
+                    postDelayed(timeoutRunnable, timeout);
+                }
+            }
+        };
+
+        protected void clearTimeoutFlag() {
+            isTimeout = false;
+        }
+
+        protected void done() {
+            Looper.myLooper().quit();
+        }
+
+        public InterprocessHandler(Runnable startRunnable) {
+            super(Looper.myLooper());
+            localMessenger = new Messenger(this);
+            // To have the first step from main process run
+            post(startRunnable);
+            // Start watchdog
+            postDelayed(timeoutRunnable, timeout);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            Bundle bundle = msg.getData();
+            String error = bundle.getString(RemoteProcessService.BUNDLE_KEY_ERROR);
+            if (error != null) {
+                // Assert and show error from service process
+                assertTrue(error, false);
+            }
+        }
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        Realm.deleteRealm(new RealmConfiguration.Builder(getContext()).build());
+
+        // Start the testing service
+        serviceStartLatch = new CountDownLatch(1);
+        Intent intent = new Intent(getContext(), RemoteProcessService.class);
+        getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
+        assertTrue(serviceStartLatch.await(10, TimeUnit.SECONDS));
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        int counter = 10;
+        if (testRealm != null) {
+            testRealm.close();
+        }
+
+        getContext().unbindService(serviceConnection);
+        remoteMessenger = null;
+
+        // Kill the remote process.
+        ActivityManager.RunningAppProcessInfo info = getRemoteProcessInfo();
+        if (info != null) {
+            android.os.Process.killProcess(info.pid);
+        }
+        while (getRemoteProcessInfo() != null) {
+            if (counter == 0) {
+                assertTrue("The remote service process is still alive.", false);
+            }
+            Thread.sleep(300);
+            counter--;
+        }
+        super.tearDown();
+    }
+
+    // Call this to trigger the next step of service process
+    private void triggerServiceStep(RemoteProcessService.Step step) {
+        Message msg = Message.obtain(null, step.message);
+        msg.replyTo = localMessenger;
+        try {
+            remoteMessenger.send(msg);
+        } catch (RemoteException e) {
+            assertTrue(false);
+        }
+    }
+
+    // Return the service info if it is alive.
+    // When this method return null, it doesn't mean the remote process is not exsited. An 'empty' process could
+    // be retained by the system to be used next time.
+    // Use getRemoteProcessInfo if you want to check the existence of remote process.
+    private ActivityManager.RunningServiceInfo getServiceInfo() {
+        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningServiceInfo> serviceInfoList = manager.getRunningServices(Integer.MAX_VALUE);
+        for (ActivityManager.RunningServiceInfo service : serviceInfoList) {
+            if (RemoteProcessService.class.getName().equals(service.service.getClassName())) {
+                return service;
+            }
+        }
+        return null;
+    }
+
+    // Get the remote process info if it is alive.
+    private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
+        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
+        for (ActivityManager.RunningAppProcessInfo info : processInfoList) {
+            if (info.processName.equals(getContext().getPackageName() + ":remote")) {
+                return info;
+            }
+        }
+
+        return null;
+    }
+
+    // A. Open a realm, close it, then call Runtime.getRuntime().exit(0).
+    // 1. Wait 3 seconds to see if the service process existed.
+    public void testExitProcess() {
+        new InterprocessHandler(new Runnable() {
+            @Override
+            public void run() {
+                // Step A
+                triggerServiceStep(RemoteProcessService.stepExitProcess_A);
+            }
+        }) {
+
+            @SuppressWarnings("ConstantConditions")
+            final int servicePid = getServiceInfo().pid;
+
+            @Override
+            public void handleMessage(Message msg) {
+                super.handleMessage(msg);
+                if (msg.what == RemoteProcessService.stepExitProcess_A.message) {
+                    // Step 1
+                    clearTimeoutFlag();
+                    try {
+                        // Timeout is 5 seconds. 3 (6x500ms) seconds should be enough to quit the process.
+                        for (int i = 1; i <= 6; i++) {
+                            // We need to retrieve the service's pid again since the system might restart it automatically.
+                            ActivityManager.RunningAppProcessInfo processInfo = getRemoteProcessInfo();
+                            if (processInfo != null && processInfo.pid == servicePid && i >= 6) {
+                                // The process is still alive.
+                                assertTrue(false);
+                            } else if (processInfo == null || processInfo.pid != servicePid) {
+                                // The process is gone
+                                break;
+                            }
+                            Thread.sleep(500, 0);
+                        }
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                        assertTrue(false);
+                    }
+                    done();
+                }
+            }
+        };
+        Looper.loop();
+    }
+
+    // 1. Main process create Realm, write one object.
+    // A. Service process open Realm, check if there is one and only one object.
+    public void testCreateInitialRealm() throws InterruptedException {
+        new InterprocessHandler(new Runnable() {
+            @Override
+            public void run() {
+                // Step 1
+                testRealm = Realm.getInstance(getContext());
+                assertEquals(testRealm.allObjects(AllTypes.class).size(), 0);
+                testRealm.beginTransaction();
+                testRealm.createObject(AllTypes.class);
+                testRealm.commitTransaction();
+
+                // Step A
+                triggerServiceStep(RemoteProcessService.stepCreateInitialRealm_A);
+            }}) {
+
+            @Override
+            public void handleMessage(Message msg) {
+                super.handleMessage(msg);
+                if (msg.what == RemoteProcessService.stepCreateInitialRealm_A.message) {
+                    clearTimeoutFlag();
+                    done();
+                } else {
+                    assertTrue(false);
+                }
+            }
+        };
+        Looper.loop();
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmJsonTest.java b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
index 0ff63ecce1..42eb792c2c 100644
--- a/realm/src/androidTest/java/io/realm/RealmJsonTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
@@ -41,8 +41,9 @@
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
     }
 
     @Override
@@ -433,6 +434,79 @@ public void testCreateObjectFromJsonStream_nullValues() throws IOException {
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
+    // Test update a existing object with JSON stream.
+    public void testUpdateObjectFromJsonStream_nullValues() throws IOException {
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        Date date = new Date(0);
+        // ID
+        obj.setColumnLong(1);
+        obj.setColumnBinary(new byte[]{1});
+        obj.setColumnBoolean(true);
+        obj.setColumnDate(date);
+        obj.setColumnDouble(1);
+        obj.setColumnFloat(1);
+        obj.setColumnString("1");
+        testRealm.beginTransaction();
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+
+        InputStream in = loadJsonFromAssets("all_types_primary_key_null.json");
+        testRealm.beginTransaction();
+        testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
+        testRealm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        obj = testRealm.allObjects(AllTypesPrimaryKey.class).first();
+        // TODO: We only handle updating null for String right now.
+        //       Clean this up after nullable support for all types.
+        assertEquals("", obj.getColumnString());
+        assertEquals(1L, obj.getColumnLong());
+        assertEquals(1f, obj.getColumnFloat());
+        assertEquals(1d, obj.getColumnDouble());
+        assertEquals(true, obj.isColumnBoolean());
+        assertEquals(date, obj.getColumnDate());
+        assertArrayEquals(new byte[]{1}, obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    // Test update a existing object with JSON object.
+    public void testUpdateObjectFromJsonObject_nullValues() throws IOException {
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        Date date = new Date(0);
+        // ID
+        obj.setColumnLong(1);
+        obj.setColumnBinary(new byte[]{1});
+        obj.setColumnBoolean(true);
+        obj.setColumnDate(date);
+        obj.setColumnDouble(1);
+        obj.setColumnFloat(1);
+        obj.setColumnString("1");
+        testRealm.beginTransaction();
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+
+        String json = TestHelper.streamToString(loadJsonFromAssets("all_types_primary_key_null.json"));
+        testRealm.beginTransaction();
+        testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
+        testRealm.commitTransaction();
+
+        // Check that all primitive types are imported correctly
+        obj = testRealm.allObjects(AllTypesPrimaryKey.class).first();
+        // TODO: We only handle updating String with null value right now.
+        //       Clean this up after nullable support for all types.
+        assertEquals("", obj.getColumnString());
+        assertEquals(1L, obj.getColumnLong());
+        assertEquals(1f, obj.getColumnFloat());
+        assertEquals(1d, obj.getColumnDouble());
+        assertEquals(true, obj.isColumnBoolean());
+        assertEquals(date, obj.getColumnDate());
+        assertArrayEquals(new byte[]{1}, obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
     public void testCreateOrUpdateObject_noPrimaryKeyThrows() {
         try {
             testRealm.createOrUpdateObjectFromJson(AllTypes.class, new JSONObject());
diff --git a/realm/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/src/androidTest/java/io/realm/RealmLinkTests.java
index 81d8d04d85..415e79bfa6 100644
--- a/realm/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -29,8 +29,9 @@
     protected Realm testRealm;
 
     protected void setUp() {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
 
         testRealm.beginTransaction();
         testRealm.clear(Dog.class);
@@ -148,9 +149,11 @@ public void testQuerySingleRelationInteger() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.age", 1, 20).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.age", 1, 20).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     public void testQuerySingleRelationDate() {
@@ -309,8 +312,10 @@ public void testQueryMultipleRelationsInteger() {
         RealmResults<Owner> owners6 = testRealm.where(Owner.class).lessThanOrEqualTo("dogs.age", 9).findAll();
         assertEquals(1, owners6.size());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.age", 9, 11).findAll();
-        assertEquals(1, owners7.size());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.age", 9, 11).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {}
     }
 
     public void testQueryMultipleRelationsDate() {
diff --git a/realm/src/androidTest/java/io/realm/RealmListTest.java b/realm/src/androidTest/java/io/realm/RealmListTest.java
index 1de11546c7..20ec3ec90c 100644
--- a/realm/src/androidTest/java/io/realm/RealmListTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmListTest.java
@@ -33,8 +33,9 @@
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
 
         testRealm.beginTransaction();
         Owner owner = testRealm.createObject(Owner.class);
diff --git a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
index d717b3880d..0c78ade7a2 100644
--- a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -26,17 +26,18 @@ protected void tearDown() throws Exception {
 
     public void testRealmClosedAfterMigrationException() throws IOException {
         String REALM_NAME = "default0.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), REALM_NAME);
+        Realm.deleteRealm(realmConfig);
         TestHelper.copyRealmFromAssets(getContext(), REALM_NAME, REALM_NAME);
         try {
-            Realm.getInstance(getContext(), REALM_NAME);
+            Realm.getInstance(realmConfig);
             fail("A migration should be triggered");
         } catch (RealmMigrationNeededException expected) {
-            Realm.deleteRealmFile(getContext(), REALM_NAME); // Delete old realm
+            Realm.deleteRealm(realmConfig); // Delete old realm
         }
 
         // This should recreate the Realm with proper schema
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        Realm realm = Realm.getInstance(realmConfig);
         int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
         assertEquals(0, result);
     }
@@ -132,12 +133,14 @@ public void testNotSettingPrimaryKeyThrows() {
             @Override
             public long execute(Realm realm, long version) {
                 Table table = realm.getTable(AnnotationTypes.class);
-                long columnIndex = table.addColumn(ColumnType.INTEGER, "id");
-                table.addSearchIndex(columnIndex);
-                // Forget to set @PrimaryKey
-                columnIndex = table.addColumn(ColumnType.STRING, "indexString");
-                table.addSearchIndex(columnIndex);
-                table.addColumn(ColumnType.STRING, "notIndexString");
+                if (table.getColumnCount() == 0) {
+                    long columnIndex = table.addColumn(ColumnType.INTEGER, "id");
+                    table.addSearchIndex(columnIndex);
+                    // Forget to set @PrimaryKey
+                    columnIndex = table.addColumn(ColumnType.STRING, "indexString");
+                    table.addSearchIndex(columnIndex);
+                    table.addColumn(ColumnType.STRING, "notIndexString");
+                }
                 return 1;
             }
         };
@@ -152,7 +155,10 @@ public long execute(Realm realm, long version) {
         try {
             realm = Realm.getInstance(realmConfig);
             fail();
-        } catch (RealmMigrationNeededException expected) {
+        } catch (RealmMigrationNeededException e) {
+            if (!e.getMessage().equals("Primary key not defined for field 'id'")) {
+                fail(e.getMessage());
+            }
         }
     }
 
diff --git a/realm/src/androidTest/java/io/realm/RealmObjectTest.java b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
index 17b2af6a3c..7945842462 100644
--- a/realm/src/androidTest/java/io/realm/RealmObjectTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
@@ -111,7 +111,7 @@ public void testRemoveFromRealm() {
         testRealm.commitTransaction();
 
         RealmResults<Dog> allDogsAfter = testRealm.where(Dog.class).equalTo("name", "Rex").findAll();
-        assertEquals(0  , allDogsAfter.size());
+        assertEquals(0, allDogsAfter.size());
 
         fido.getName();
         try {
@@ -543,4 +543,98 @@ public void run() {
         } catch (IllegalStateException ignored) {
         }
     }
+
+    public void testIsValid() {
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("Fido");
+        testRealm.commitTransaction();
+
+        assertTrue(dog.isValid());
+
+        testRealm.beginTransaction();
+        dog.removeFromRealm();
+        testRealm.commitTransaction();
+
+        assertFalse(dog.isValid());
+    }
+
+    // Test NaN value on float and double columns
+    public void testFloatDoubleNaN() {
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.NaN);
+        allTypes.setColumnDouble(Double.NaN);
+        testRealm.commitTransaction();
+        assertEquals(Float.NaN, testRealm.where(AllTypes.class).findFirst().getColumnFloat());
+        assertEquals(Double.NaN, testRealm.where(AllTypes.class).findFirst().getColumnDouble());
+        // NaN != NaN !!!
+        assertEquals(0, testRealm.where(AllTypes.class).equalTo("columnFloat", Float.NaN).count());
+        assertEquals(0, testRealm.where(AllTypes.class).equalTo("columnDouble", Double.NaN).count());
+    }
+
+    // Test max value on float and double columns
+    public void testFloatDoubleMaxValue() {
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.MAX_VALUE);
+        allTypes.setColumnDouble(Double.MAX_VALUE);
+        testRealm.commitTransaction();
+        assertEquals(Float.MAX_VALUE, testRealm.where(AllTypes.class).findFirst().getColumnFloat());
+        assertEquals(Double.MAX_VALUE, testRealm.where(AllTypes.class).findFirst().getColumnDouble());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnFloat", Float.MAX_VALUE).count());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnDouble", Double.MAX_VALUE).count());
+    }
+
+    // Test min normal value on float and double columns
+    public void testFloatDoubleMinNormal() {
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.MIN_NORMAL);
+        allTypes.setColumnDouble(Double.MIN_NORMAL);
+        testRealm.commitTransaction();
+        assertEquals(Float.MIN_NORMAL, testRealm.where(AllTypes.class).findFirst().getColumnFloat());
+        assertEquals(Double.MIN_NORMAL, testRealm.where(AllTypes.class).findFirst().getColumnDouble());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnFloat", Float.MIN_NORMAL).count());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnDouble", Double.MIN_NORMAL).count());
+    }
+
+    // Test min value on float and double columns
+    public void testFloatDoubleMinValue() {
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.MIN_VALUE);
+        allTypes.setColumnDouble(Double.MIN_VALUE);
+        testRealm.commitTransaction();
+        assertEquals(Float.MIN_VALUE, testRealm.where(AllTypes.class).findFirst().getColumnFloat());
+        assertEquals(Double.MIN_VALUE, testRealm.where(AllTypes.class).findFirst().getColumnDouble());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnFloat", Float.MIN_VALUE).count());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnDouble", Double.MIN_VALUE).count());
+    }
+
+    // Test negative infinity value on float and double columns
+    public void testFloatDoubleNegativeInfinity() {
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.NEGATIVE_INFINITY);
+        allTypes.setColumnDouble(Double.NEGATIVE_INFINITY);
+        testRealm.commitTransaction();
+        assertEquals(Float.NEGATIVE_INFINITY, testRealm.where(AllTypes.class).findFirst().getColumnFloat());
+        assertEquals(Double.NEGATIVE_INFINITY, testRealm.where(AllTypes.class).findFirst().getColumnDouble());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnFloat", Float.NEGATIVE_INFINITY).count());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnDouble", Double.NEGATIVE_INFINITY).count());
+    }
+
+    // Test positive infinity value on float and double columns
+    public void testFloatPositiveInfinity() {
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.POSITIVE_INFINITY);
+        allTypes.setColumnDouble(Double.POSITIVE_INFINITY);
+        testRealm.commitTransaction();
+        assertEquals(Float.POSITIVE_INFINITY, testRealm.where(AllTypes.class).findFirst().getColumnFloat());
+        assertEquals(Double.POSITIVE_INFINITY, testRealm.where(AllTypes.class).findFirst().getColumnDouble());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnFloat", Float.POSITIVE_INFINITY).count());
+        assertEquals(1, testRealm.where(AllTypes.class).equalTo("columnDouble", Double.POSITIVE_INFINITY).count());
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmQueryTest.java b/realm/src/androidTest/java/io/realm/RealmQueryTest.java
index d399e365b0..bcda937de8 100644
--- a/realm/src/androidTest/java/io/realm/RealmQueryTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmQueryTest.java
@@ -3,8 +3,11 @@
 import android.test.AndroidTestCase;
 
 import java.util.Date;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.CatOwner;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
@@ -26,8 +29,9 @@
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
     }
 
     @Override
@@ -458,4 +462,58 @@ public void testGeorgian() {
             assertEquals(sorted[i], stringOnlies2.get(i).getChars());
         }
     }
+
+    // If the RealmQuery is built on a TableView, it should not crash when used after GC.
+    // See issue #1161 for more details.
+    public void testBuildQueryFromResultsGC() {
+        // According to the testing, setting this to 10 can almost certainly trigger the GC.
+        // Use 30 here can ensure GC happen. (Tested with 4.3 1G Ram and 5.0 3G Ram)
+        final int count = 30;
+        RealmResults<CatOwner> results = testRealm.where(CatOwner.class).findAll();
+
+        for (int i=1; i<=count; i++) {
+            @SuppressWarnings({"unused"})
+            byte garbage[] = TestHelper.allocGarbage(0);
+            results = results.where().findAll();
+            System.gc(); // if a native resource has a reference count = 0, doing GC here might lead to a crash
+        }
+    }
+
+    public void testLargeRealmMultipleThreads() throws InterruptedException {
+        final int nObjects = 500000;
+        final int nThreads = 3;
+        final CountDownLatch latch = new CountDownLatch(nThreads);
+
+        testRealm.beginTransaction();
+        testRealm.clear(StringOnly.class);
+        for (int i = 0; i < nObjects; i++) {
+            StringOnly stringOnly = testRealm.createObject(StringOnly.class);
+            stringOnly.setChars(String.format("string %d", i));
+        }
+        testRealm.commitTransaction();
+
+
+        for (int i = 0; i < nThreads; i++) {
+            Thread thread = new Thread(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+                            Realm realm = Realm.getInstance(realmConfig);
+                            RealmResults<StringOnly> realmResults = realm.allObjects(StringOnly.class);
+                            int n = 0;
+                            for (StringOnly stringOnly : realmResults) {
+                                n = n + 1;
+                            }
+                            assertEquals(nObjects, n);
+                            realm.close();
+                            latch.countDown();
+                        }
+                    }
+                );
+            thread.start();
+        }
+
+        latch.await();
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java b/realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
index adc3da79ac..3afcf33a4b 100644
--- a/realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
@@ -37,8 +37,9 @@
 
     @Override
     protected void setUp() throws InterruptedException {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
         testRealm.beginTransaction();
         for (int i = 0; i < TEST_DATA_SIZE; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
@@ -250,7 +251,8 @@ public void DISABLEDtestIteratorFailOnDoubleRemove() {
     public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws InterruptedException, ExecutionException {
 
         // Prefill
-        Realm realm = Realm.getInstance(getContext(), "test");
+        final RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "test");
+        Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
         realm.clear(AllTypes.class);
         AllTypes o1 = realm.createObject(AllTypes.class);
@@ -269,7 +271,7 @@ public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws In
         Callable<Boolean> backgroundWorker = new Callable<Boolean>() {
             @Override
             public Boolean call() throws Exception {
-                Realm backgroundRealm = Realm.getInstance(getContext(), "test");
+                Realm backgroundRealm = Realm.getInstance(realmConfig);
                 backgroundRealm.beginTransaction();
                 RealmResults<AllTypes> backgroundResult = backgroundRealm.allObjects(AllTypes.class);
                 if (backgroundResult.size() != 2) {
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsTest.java b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
index b247fb8857..e71651f007 100644
--- a/realm/src/androidTest/java/io/realm/RealmResultsTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
@@ -183,6 +183,25 @@ public void testResultListFirstIsFirst() {
         assertTrue(allTypes.getColumnString().startsWith("test data 0"));
     }
 
+    // first() and last() will throw an exception when no element exist
+    public void testResultListFirstLastThrowIfEmpty() {
+        testRealm.beginTransaction();
+        testRealm.clear(AllTypes.class);
+        testRealm.commitTransaction();
+
+        RealmResults<AllTypes> allTypes = testRealm.allObjects(AllTypes.class);
+        assertEquals(0, allTypes.size());
+        try {
+            allTypes.first();
+            fail();
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+
+        try {
+            allTypes.last();
+            fail();
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+    }
+
     public void testResultListLastIsLast() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
 
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
index d5c62c5b5b..ff0405a397 100644
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmTest.java
@@ -16,7 +16,6 @@
 package io.realm;
 
 import android.content.Context;
-import android.os.SystemClock;
 import android.test.AndroidTestCase;
 
 import junit.framework.AssertionFailedError;
@@ -28,13 +27,11 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.Reference;
-import java.lang.reflect.Field;
+import java.lang.Thread;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
 import java.util.Scanner;
 import java.util.concurrent.Callable;
@@ -43,7 +40,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.dynamic.DynamicRealmObject;
 import io.realm.entities.AllTypes;
@@ -62,7 +59,6 @@
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
-import io.realm.internal.FinalizerRunnable;
 import io.realm.internal.Table;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
@@ -82,6 +78,8 @@
     private final static String FIELD_BOOLEAN = "columnBoolean";
     private final static String FIELD_DATE = "columnDate";
 
+    private RealmConfiguration testConfig;
+
     protected void setColumnData() {
         columnData.add(0, FIELD_BOOLEAN);
         columnData.add(1, FIELD_DATE);
@@ -93,8 +91,9 @@ protected void setColumnData() {
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        testConfig = new RealmConfiguration.Builder(getContext()).build();
+        Realm.deleteRealm(testConfig);
+        testRealm = Realm.getInstance(testConfig);
     }
 
     @Override
@@ -139,23 +138,6 @@ public void testGetInstanceNullFolderThrows() {
         }
     }
 
-    public void testGetInstanceNullNameThrows() {
-        try {
-            Realm.getInstance(getContext(), (String) null);
-            fail("Parsing null as realm name should throw an error");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testGetInstanceCreateSubFoldersThrows() {
-        File folder = new File(getContext().getFilesDir().getAbsolutePath() + "/subfolder1/subfolder2/");
-        try {
-            Realm.getInstance(getContext(), (String) null);
-            fail("Assuming that subfolders are created automatically should fail");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
     public void testGetInstanceFolderNoWritePermissionThrows() {
         File folder = new File("/");
         try {
@@ -185,32 +167,23 @@ public void testGetInstanceFileNoWritePermissionThrows() throws IOException {
 
     public void testGetInstanceClearsCacheWhenFailed() {
         String REALM_NAME = "invalid_cache.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Random random = new Random();
-        byte[] key = TestHelper.getRandomKey();
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key); // Create starting Realm with key1
+        RealmConfiguration configA = TestHelper.createConfiguration(getContext(), REALM_NAME, TestHelper.getRandomKey());
+        RealmConfiguration configB = TestHelper.createConfiguration(getContext(), REALM_NAME, TestHelper.getRandomKey());
+
+        Realm.deleteRealm(configA);
+        Realm realm = Realm.getInstance(configA); // Create starting Realm with key1
         realm.close();
-        key = TestHelper.getRandomKey();
         try {
-            Realm.getInstance(getContext(), REALM_NAME, key); // Try to open with key 2
+            Realm.getInstance(configB); // Try to open with key 2
         } catch (IllegalArgumentException expected) {
             // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
             // if initialization failed.
-            assertTrue(Realm.deleteRealmFile(getContext(), REALM_NAME));
-            Realm.getInstance(getContext(), REALM_NAME, key);
+            assertTrue(Realm.deleteRealm(configA));
+            Realm.getInstance(configB);
             realm.close();
         }
     }
 
-    public void testInstanceIdForHashCollision() {
-        // Ea.hashCode() == FB.hashCode()
-        Realm.deleteRealmFile(getContext(), "Ea");
-        Realm.deleteRealmFile(getContext(), "FB");
-        Realm r1 = Realm.getInstance(getContext(), "Ea");
-        Realm r2 = Realm.getInstance(getContext(), "FB");
-        assertNotSame(r1, r2);
-    }
-
     public void testRealmCache() {
         Realm newRealm = Realm.getInstance(getContext());
         assertEquals(testRealm, newRealm);
@@ -219,13 +192,14 @@ public void testRealmCache() {
 
     public void testInternalRealmChangedHandlersRemoved() {
         final String REALM_NAME = "test-internalhandlers";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), REALM_NAME);
+        Realm.deleteRealm(realmConfig);
         Realm.handlers.clear(); // Make sure that handlers from other unit tests doesn't interfere.
 
         // Open and close first instance of a Realm
         Realm realm = null;
         try {
-            realm = Realm.getInstance(getContext(), REALM_NAME);
+            realm = Realm.getInstance(realmConfig);
             assertEquals(1, Realm.handlers.size());
             realm.close();
 
@@ -233,7 +207,7 @@ public void testInternalRealmChangedHandlersRemoved() {
             assertEquals(0, Realm.handlers.size());
 
             // Open instance the 2nd time. Old handler should now be gone
-            realm = Realm.getInstance(getContext(), REALM_NAME);
+            realm = Realm.getInstance(realmConfig);
             assertEquals(1, Realm.handlers.size());
             realm.close();
 
@@ -737,8 +711,9 @@ public void testShouldFailOutsideTransaction() {
     }
 
     public void createAndTestFilename(String language, String fileName) {
-        Realm.deleteRealmFile(getContext(), fileName);
-        Realm realm1 = Realm.getInstance(getContext(), fileName);
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), fileName);
+        Realm.deleteRealm(realmConfig);
+        Realm realm1 = Realm.getInstance(realmConfig);
         realm1.beginTransaction();
         Dog dog1 = realm1.createObject(Dog.class);
         dog1.setName("Rex");
@@ -748,7 +723,7 @@ public void createAndTestFilename(String language, String fileName) {
         File file = new File(getContext().getFilesDir(), fileName);
         assertTrue(language, file.exists());
 
-        Realm realm2 = Realm.getInstance(getContext(), fileName);
+        Realm realm2 = Realm.getInstance(realmConfig);
         Dog dog2 = realm2.allObjects(Dog.class).first();
         assertEquals(language, "Rex", dog2.getName());
         realm2.close();
@@ -862,8 +837,9 @@ public void testReferenceCounting() {
         }
 
         // Make sure the reference counter is per realm file
-        Realm.deleteRealmFile(getContext(), "anotherRealm.realm");
-        Realm otherRealm = Realm.getInstance(getContext(), "anotherRealm.realm");
+        RealmConfiguration anotherConfig = TestHelper.createConfiguration(getContext(), "anotherRealm.realm");
+        Realm.deleteRealm(anotherConfig);
+        Realm otherRealm = Realm.getInstance(anotherConfig);
 
         // Raise the reference
         Realm realm = null;
@@ -922,12 +898,14 @@ public void testReferenceCountingDoubleClose() {
     }
 
     public void testWriteCopyTo() throws IOException {
-        Realm.deleteRealmFile(getContext(), "file1.realm");
-        Realm.deleteRealmFile(getContext(), "file2.realm");
+        RealmConfiguration configA = TestHelper.createConfiguration(getContext(), "file1.realm");
+        RealmConfiguration configB = TestHelper.createConfiguration(getContext(), "file2.realm");
+        Realm.deleteRealm(configA);
+        Realm.deleteRealm(configB);
 
         Realm realm1 = null;
         try {
-            realm1 = Realm.getInstance(getContext(), "file1.realm");
+            realm1 = Realm.getInstance(configA);
             realm1.beginTransaction();
             AllTypes allTypes = realm1.createObject(AllTypes.class);
             allTypes.setColumnString("Hello World");
@@ -948,7 +926,7 @@ public void testWriteCopyTo() throws IOException {
         Realm realm2 = null;
         try {
             // Contents is copied too
-            realm2 = Realm.getInstance(getContext(), "file2.realm");
+            realm2 = Realm.getInstance(configB);
             RealmResults<AllTypes> results = realm2.allObjects(AllTypes.class);
             assertEquals(1, results.size());
             assertEquals("Hello World", results.first().getColumnString());
@@ -962,7 +940,7 @@ public void testWriteCopyTo() throws IOException {
 
     public void testCompactRealmFileThrowsIfOpen() throws IOException {
         try {
-            Realm.compactRealmFile(getContext());
+            Realm.compactRealm(TestHelper.createConfiguration(getContext()));
             fail();
         } catch (IllegalStateException expected) {
         }
@@ -1004,23 +982,25 @@ public void testCompactEncryptedPopulatedRealmFile() {
 
     public void testCompactEmptyRealmFile() throws IOException {
         final String REALM_NAME = "test.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), REALM_NAME);
+        Realm.deleteRealm(realmConfig);
+        Realm realm = Realm.getInstance(realmConfig);
         realm.close();
         long before = new File(getContext().getFilesDir(), REALM_NAME).length();
-        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
+        assertTrue(Realm.compactRealm(realmConfig));
         long after = new File(getContext().getFilesDir(), REALM_NAME).length();
         assertTrue(before >= after);
     }
 
     public void testCompactPopulateRealmFile() throws IOException {
         final String REALM_NAME = "test.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), REALM_NAME);
+        Realm.deleteRealm(realmConfig);
+        Realm realm = Realm.getInstance(realmConfig);
         populateTestRealm(realm, 100);
         realm.close();
         long before = new File(getContext().getFilesDir(), REALM_NAME).length();
-        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
+        assertTrue(Realm.compactRealm(realmConfig));
         long after = new File(getContext().getFilesDir(), REALM_NAME).length();
         assertTrue(before >= after);
     }
@@ -1055,8 +1035,9 @@ public void testCopManagedObjectToOtherRealm() {
         allTypes.setColumnString("Test");
         testRealm.commitTransaction();
 
-        Realm.deleteRealmFile(getContext(), "other-realm");
-        Realm otherRealm = Realm.getInstance(getContext(), "other-realm");
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "other-realm");
+        Realm.deleteRealm(realmConfig);
+        Realm otherRealm = Realm.getInstance(realmConfig);
         otherRealm.beginTransaction();
         AllTypes copiedAllTypes = otherRealm.copyToRealm(allTypes);
         otherRealm.commitTransaction();
@@ -1254,7 +1235,7 @@ public void execute(Realm realm) {
                 obj.setColumnFloat(1.23F);
                 obj.setColumnDouble(1.234D);
                 obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnBinary(new byte[] {1, 2, 3});
                 obj.setColumnDate(new Date(1000));
                 obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
                 obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
@@ -1266,7 +1247,7 @@ public void execute(Realm realm) {
                 obj2.setColumnFloat(2.23F);
                 obj2.setColumnDouble(2.234D);
                 obj2.setColumnBoolean(true);
-                obj2.setColumnBinary(new byte[]{2, 3, 4});
+                obj2.setColumnBinary(new byte[] {2, 3, 4});
                 obj2.setColumnDate(new Date(2000));
                 obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
                 obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
@@ -1283,7 +1264,7 @@ public void execute(Realm realm) {
         assertEquals(2.23F, obj.getColumnFloat());
         assertEquals(2.234D, obj.getColumnDouble());
         assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
+        assertArrayEquals(new byte[] {2, 3, 4}, obj.getColumnBinary());
         assertEquals(new Date(2000), obj.getColumnDate());
         assertEquals("Dog3", obj.getColumnRealmObject().getName());
         assertEquals(1, obj.getColumnRealmList().size());
@@ -1455,7 +1436,7 @@ public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
         assertTrue(key1 != key2);
 
         final String ENCRYPTED_REALM = "differentKeys.realm";
-        Realm.deleteRealmFile(getContext(), ENCRYPTED_REALM);
+        Realm.deleteRealm(TestHelper.createConfiguration(getContext(), ENCRYPTED_REALM));
         Realm realm1 = null;
         Realm realm2 = null;
         try {
@@ -1585,19 +1566,22 @@ public void testWriteEncryptedCopy() throws Exception {
     public void testOpenRealmFileDeletionShouldThrow() {
         final String OTHER_REALM_NAME = "yetAnotherRealm.realm";
 
+        RealmConfiguration configA = TestHelper.createConfiguration(getContext());
+        RealmConfiguration configB = TestHelper.createConfiguration(getContext(), OTHER_REALM_NAME);
+
         // This instance is already cached because of the setUp() method so this deletion should throw
         try {
-            Realm.deleteRealmFile(getContext());
+            Realm.deleteRealm(configA);
             fail();
         } catch (IllegalStateException ignored) {
         }
 
         // Create a new Realm file
-        Realm yetAnotherRealm = Realm.getInstance(getContext(), OTHER_REALM_NAME);
+        Realm yetAnotherRealm = Realm.getInstance(configB);
 
         // Deleting it should fail
         try {
-            Realm.deleteRealmFile(getContext(), OTHER_REALM_NAME);
+            Realm.deleteRealm(configB);
             fail();
         } catch (IllegalStateException ignored) {
         }
@@ -1605,7 +1589,7 @@ public void testOpenRealmFileDeletionShouldThrow() {
         // But now that we close it deletion should work
         yetAnotherRealm.close();
         try {
-            Realm.deleteRealmFile(getContext(), OTHER_REALM_NAME);
+            Realm.deleteRealm(configB);
         } catch (Exception e) {
             fail();
         }
@@ -1687,45 +1671,55 @@ public void testMutableMethodsOutsideWriteTransactions() throws JSONException, I
         try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
     }
 
-    // Check that FinalizerRunnable can free native resources (phantom refs)
-    public void testFinalizerThread() throws NoSuchFieldException, IllegalAccessException {
-        Field fieldReferences = FinalizerRunnable.class.getDeclaredField("references");
-        fieldReferences.setAccessible(true);
-        Map<Reference<?>, Boolean> references = (Map<Reference<?>, Boolean>) fieldReferences.get(null);
-        assertNotNull(references);
+    // TODO: re-introduce this test mocking the ReferenceQueue instead of relying on the GC
+/*    // Check that FinalizerRunnable can free native resources (phantom refs)
+    public void testReferenceCleaning() throws NoSuchFieldException, IllegalAccessException {
+        Field sharedGroupReference = Realm.class.getDeclaredField("sharedGroup");
+        sharedGroupReference.setAccessible(true);
+        SharedGroup sharedGroup = (SharedGroup) sharedGroupReference.get(testRealm);
+        assertNotNull(sharedGroup);
+
+        Field contextField = SharedGroup.class.getDeclaredField("context");
+        contextField.setAccessible(true);
+        io.realm.internal.Context context = (io.realm.internal.Context) contextField.get(sharedGroup);
+        assertNotNull(context);
+
+        Field rowReferencesField = io.realm.internal.Context.class.getDeclaredField("rowReferences");
+        rowReferencesField.setAccessible(true);
+        List<Reference<?>> rowReferences = (List<Reference<?>>) rowReferencesField.get(context);
+        assertNotNull(rowReferences);
 
-        Field fieldIsFinalizerStarted = Realm.class.getDeclaredField("isFinalizerStarted");
-        fieldIsFinalizerStarted.setAccessible(true);
-        boolean isFinalizerStarted = fieldIsFinalizerStarted.getBoolean(null);
-        assertTrue(isFinalizerStarted);
 
-        //insert some rows, then give the FinalizerRunnable some time to cleanup
+        // insert some rows, then give the thread some time to cleanup
         // we have 8 reference so far let's add more
-        final int numberOfPopulateTest = 10000;
+        final int numberOfPopulateTest = 1000;
         final int totalNumberOfReferences = 8 + 20 * 2 * numberOfPopulateTest;
 
+        long tic = System.currentTimeMillis();
         for (int i = 0; i < numberOfPopulateTest; i++) {
             populateTestRealm(testRealm, 20);
         }
+        long toc = System.currentTimeMillis();
+        Log.d(RealmTest.class.getName(), "Insertion time: " + (toc - tic));
 
         final int MAX_GC_RETRIES = 5;
         int numberOfRetries = 0;
-        while (references.size() > 0 && numberOfRetries < MAX_GC_RETRIES) {
+        while (rowReferences.size() > 0 && numberOfRetries < MAX_GC_RETRIES) {
             SystemClock.sleep(TimeUnit.SECONDS.toMillis(1)); //1s
             numberOfRetries++;
             System.gc();
         }
 
         // we can't guarantee that all references have been GC'd but we should detect a decrease
-        boolean isDecreasing = references.size() < totalNumberOfReferences;
+        boolean isDecreasing = rowReferences.size() < totalNumberOfReferences;
         if (!isDecreasing) {
-            fail("FinalizerRunnable is not closing all native resources");
+            fail("Native resources are not being closed");
 
         } else {
-            android.util.Log.d(RealmTest.class.getName(), "FinalizerRunnable freed : "
-                    + (totalNumberOfReferences - references.size()) + " out of " + totalNumberOfReferences);
+            android.util.Log.d(RealmTest.class.getName(), "References freed : "
+                    + (totalNumberOfReferences - rowReferences.size()) + " out of " + totalNumberOfReferences);
         }
-    }
+    }*/
 
     public void testCannotCreateDynamicRealmObject() {
         testRealm.beginTransaction();
@@ -1764,4 +1758,107 @@ public void run() {
         testRealm.checkIfValid();
         testRealm.close();
     }
+
+    // We should not cache wrong configurations
+    public void testDontCacheWrongConfigurations() throws IOException {
+        testRealm.close();
+        String REALM_NAME = "encrypted.realm";
+        TestHelper.copyRealmFromAssets(getContext(), REALM_NAME, REALM_NAME);
+
+        RealmConfiguration wrongConfig = new RealmConfiguration.Builder(getContext())
+                .name(REALM_NAME)
+                .encryptionKey(TestHelper.SHA512("foo"))
+                .build();
+
+        RealmConfiguration rightConfig = new RealmConfiguration.Builder(getContext())
+                .name(REALM_NAME)
+                .encryptionKey(TestHelper.SHA512("realm"))
+                .build();
+
+        // Open Realm with wrong key
+        try {
+            testRealm = Realm.getInstance(wrongConfig);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Try again with proper key
+        testRealm = Realm.getInstance(rightConfig);
+        assertNotNull(testRealm);
+    }
+
+    public void testDeletingRealmAlsoClearsConfigurationCache() throws IOException {
+        testRealm.close();
+        String REALM_NAME = "encrypted.realm";
+        byte[] oldPassword = TestHelper.SHA512("realm");
+        byte[] newPassword = TestHelper.SHA512("realm-copy");
+
+        TestHelper.copyRealmFromAssets(getContext(), REALM_NAME, REALM_NAME);
+
+        RealmConfiguration config = new RealmConfiguration.Builder(getContext())
+                .name(REALM_NAME)
+                .encryptionKey(oldPassword)
+                .build();
+
+        // 1. Write a copy of the encrypted Realm to a new file
+        testRealm = Realm.getInstance(config);
+        File copiedRealm = new File(config.getRealmFolder(), "encrypted-copy.realm");
+        copiedRealm.delete();
+        testRealm.writeEncryptedCopyTo(copiedRealm, newPassword);
+        testRealm.close();
+        testRealm = null;
+
+        // 2. Delete the old Realm.
+        Realm.deleteRealm(config);
+
+        // 3. Rename the new file to the old file name.
+        copiedRealm.renameTo(new File(config.getRealmFolder(), REALM_NAME));
+
+        // 4. Try to open the file again with the new password
+        // If the configuration cache wasn't cleared this would fail as we would detect two
+        // configurations with 2 different passwords pointing to the same file.
+        RealmConfiguration newConfig = new RealmConfiguration.Builder(getContext())
+                .name(REALM_NAME)
+                .encryptionKey(newPassword)
+                .build();
+
+        testRealm = Realm.getInstance(newConfig);
+        assertNotNull(testRealm);
+    }
+
+    public void testProcessLocalListenersAfterRefresh() {
+        // Used to validate the result
+        final AtomicBoolean listenerWasCalled = new AtomicBoolean(false);
+
+        // Used by the background thread to wait for the main thread to do the write operation
+        final CountDownLatch bgThreadLatch = new CountDownLatch(1);
+
+        Thread backgroundThread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(testConfig);
+                bgRealm.addChangeListener(new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        listenerWasCalled.set(true);
+                    }
+                });
+                try {
+                    bgThreadLatch.await(); // Wait for the main thread to do a write operation
+                    bgRealm.refresh(); // This should call the listener
+                    assertTrue(listenerWasCalled.get());
+                } catch (InterruptedException e) {
+                    fail();
+                } finally {
+                    bgRealm.close();
+                }
+            }
+        };
+        backgroundThread.start();
+
+        testRealm.beginTransaction();
+        testRealm.createObject(Dog.class);
+        testRealm.commitTransaction();
+        bgThreadLatch.countDown();
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/SortTest.java b/realm/src/androidTest/java/io/realm/SortTest.java
index 63bcaa50b0..75153b1882 100644
--- a/realm/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/src/androidTest/java/io/realm/SortTest.java
@@ -40,8 +40,9 @@ public void setUp() {
         // 1: (4, "Brian")
         // 2: (4, "Adam")
         // 3: (5, "Adam")
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration config = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(config);
+        testRealm = Realm.getInstance(config);
 
         testRealm.beginTransaction();
         testRealm.clear(AllTypes.class);
diff --git a/realm/src/androidTest/java/io/realm/TestHelper.java b/realm/src/androidTest/java/io/realm/TestHelper.java
index 7afca9ca13..5523a78159 100644
--- a/realm/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/src/androidTest/java/io/realm/TestHelper.java
@@ -26,7 +26,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.Random;
 
 public class TestHelper {
@@ -70,7 +73,7 @@ public static void copyRealmFromAssets(Context context, String realmPath, String
 
     // Deletes the old database and copies a new one into its place
     public static void prepareDatabaseFromAssets(Context context, String realmPath, String newName) throws IOException {
-        Realm.deleteRealmFile(context, newName);
+        Realm.deleteRealm(createConfiguration(context, newName));
         TestHelper.copyRealmFromAssets(context, realmPath, newName);
     }
 
@@ -94,4 +97,62 @@ public int read() throws IOException {
             return 0; // Stub implementation
         }
     }
+
+    // Alloc as much garbage as we can. Pass maxSize = 0 to use it.
+    public static byte[] allocGarbage(int garbageSize) {
+        if (garbageSize == 0) {
+            long maxMemory = Runtime.getRuntime().maxMemory();
+            long totalMemory = Runtime.getRuntime().totalMemory();
+            garbageSize = (int)(maxMemory - totalMemory)/10*9;
+        }
+        byte garbage[];
+        try {
+            garbage = new byte[garbageSize];
+            garbage[0] = 1;
+            garbage[garbage.length - 1] = 1;
+        } catch (OutOfMemoryError oom) {
+            return allocGarbage(garbageSize/10*9);
+        }
+
+        return garbage;
+    }
+
+    // Creates SHA512 hash of a String. Can be used as password for encrypted Realms.
+    public static byte[] SHA512(String str) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA-512");
+            md.update(str.getBytes("UTF-8"), 0, str.length());
+            return md.digest();
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static RealmConfiguration createConfiguration(Context context) {
+        return createConfiguration(context, Realm.DEFAULT_REALM_NAME);
+    }
+
+    public static RealmConfiguration createConfiguration(Context context, String name) {
+        return createConfiguration(context.getFilesDir(), name);
+    }
+
+    public static RealmConfiguration createConfiguration(File folder, String name) {
+        return createConfiguration(folder, name, null);
+    }
+
+    public static RealmConfiguration createConfiguration(Context context, String name, byte[] key) {
+        return createConfiguration(context.getFilesDir(), name, key);
+    }
+
+    public static RealmConfiguration createConfiguration(File dir, String name, byte[] key) {
+        RealmConfiguration.Builder config = new RealmConfiguration.Builder(dir).name(name);
+        if (key != null) {
+            config.encryptionKey(key);
+        }
+
+        return config.build();
+    }
+
 }
diff --git a/realm/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/src/androidTest/java/io/realm/services/RemoteProcessService.java
new file mode 100644
index 0000000000..97e5321334
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -0,0 +1,129 @@
+package io.realm.services;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.Realm;
+import io.realm.entities.AllTypes;
+
+/**
+ * Helper service for multi-processes support testing.
+ */
+public class RemoteProcessService extends Service {
+
+    public abstract static class Step {
+        public final int message;
+        private Step(int message) {
+            this.message = message;
+            stepMap.put(message, this);
+        }
+
+        abstract void run();
+
+        // Pass a null to tell main process that everything is OK.
+        // Otherwise, pass a error String which will be used by assertion in main process.
+        protected void response(String error) {
+            try {
+                Message msg = Message.obtain(null, message);
+                if (error != null) {
+                    Bundle bundle = new Bundle();
+                    bundle.putString(BUNDLE_KEY_ERROR, error);
+                    msg.setData(bundle);
+                }
+                thiz.client.send(msg);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static final String BUNDLE_KEY_ERROR = "error";
+    private static Map<Integer, Step> stepMap = new HashMap<Integer, Step>();
+
+    private static RemoteProcessService thiz;
+    private Realm testRealm;
+
+    private final Messenger messenger = new Messenger(new IncomingHandler());
+    private Messenger client;
+
+    public RemoteProcessService() {
+        if (thiz != null) {
+            throw new RuntimeException("Only one instance is allowed!");
+        }
+        thiz = this;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return messenger.getBinder();
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        stopSelf();
+        return super.onUnbind(intent);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        return START_NOT_STICKY;
+    }
+
+    private static class IncomingHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            thiz.client = msg.replyTo;
+            if (thiz.client == null) {
+                throw new RuntimeException("Message with an empty client.");
+            }
+            Step step = stepMap.get(msg.what);
+            if (step != null) {
+                step.run();
+            } else {
+                throw new RuntimeException("Cannot find corresponding step to message " + msg.what + ".");
+            }
+        }
+    }
+
+    // Call this function to return the String of current class and line number.
+    private static String currentLine() {
+        StackTraceElement element = new Throwable().getStackTrace()[1];
+        return element.getClassName() + " line " + element.getLineNumber() + ": ";
+    }
+
+    public final static Step stepCreateInitialRealm_A = new Step(10) {
+
+        @Override
+        void run() {
+            thiz.testRealm = Realm.getInstance(thiz);
+            int expected = 1;
+            int got = thiz.testRealm.allObjects(AllTypes.class).size();
+            if (expected == got) {
+                response(null);
+            } else {
+                response(currentLine() + "expected: " + expected + ", but got " + got);
+            }
+            thiz.testRealm.close();
+        }
+    };
+
+    public final static Step stepExitProcess_A = new Step(20) {
+
+        @Override
+        void run() {
+            thiz.testRealm = Realm.getInstance(thiz);
+            thiz.testRealm.close();
+            response(null);
+            Runtime.getRuntime().exit(0);
+        }
+    };
+}
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index d33e2d54f1..df0dd8ca60 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -54,9 +54,9 @@
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.exceptions.RealmEncryptionNotSupportedException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnType;
-import io.realm.internal.FinalizerRunnable;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
@@ -125,12 +125,6 @@
 public final class Realm implements Closeable {
     public static final String DEFAULT_REALM_NAME = "default.realm";
 
-    // This single thread executor ensures that only one finalizer thread ever exists
-    private static final ExecutorService executorService = Executors.newSingleThreadExecutor();
-
-    // This does not need to be thread safe since it's only used in a synchronized method
-    private static volatile boolean isFinalizerStarted = false;
-
     protected static final ThreadLocal<Map<RealmConfiguration, Realm>> realmsCache =
             new ThreadLocal<Map<RealmConfiguration, Realm>>() {
         @Override
@@ -206,7 +200,14 @@ protected void checkIfValid() {
         }
     }
 
-    // The constructor in private to enforce the use of the static one
+    /**
+     * The constructor is private to enforce the use of the static one.
+     *
+     * @param configuration Configuration used to open the Realm.
+     * @param autoRefresh {@code true} if Realm should auto-refresh. {@code false} otherwise.
+     * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
+     * @throws RealmEncryptionNotSupportedException if the device doesn't support Realm encryption.
+     */
     private Realm(RealmConfiguration configuration, boolean autoRefresh) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
@@ -256,7 +257,11 @@ public void close() {
             // It is necessary to be synchronized here since there is a chance that before the counter removed,
             // the other thread could get the counter and increase it in createAndValidate.
             synchronized (Realm.class) {
-                globalPathConfigurationCache.get(canonicalPath).remove(configuration);
+                List<RealmConfiguration>  pathConfigurationCache = globalPathConfigurationCache.get(canonicalPath);
+                pathConfigurationCache.remove(configuration);
+                if (pathConfigurationCache.isEmpty()) {
+                    globalPathConfigurationCache.remove(canonicalPath);
+                }
                 AtomicInteger counter = globalOpenInstanceCounter.get(canonicalPath);
                 if (counter.decrementAndGet() == 0) {
                     globalOpenInstanceCounter.remove(canonicalPath);
@@ -350,162 +355,9 @@ public Table getTable(Class<? extends RealmObject> clazz) {
      * @throws RealmException                Other errors
      */
     public static Realm getInstance(Context context) {
-        return Realm.getInstance(context, DEFAULT_REALM_NAME);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context  an Android {@link android.content.Context}
-     * @param fileName the name of the file to save the Realm to
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    public static Realm getInstance(Context context, String fileName) {
-        return Realm.getInstance(context, fileName, null);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    public static Realm getInstance(Context context, byte[] key) {
-        return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    public static Realm getInstance(Context context, String fileName, byte[] key) {
-        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context).name(fileName);
-        if (key != null) {
-            builder.encryptionKey(key);
-        }
-
-        return create(builder.build());
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writableFolder a File object representing a writable folder
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writableFolder) {
-        return create(new RealmConfiguration.Builder(writableFolder)
-                        .name(DEFAULT_REALM_NAME)
-                        .build()
-        );
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()}
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writableFolder a File object representing a writable folder
-     * @param fileName the name of the Realm file
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writableFolder, String fileName) {
-        return create(new RealmConfiguration.Builder(writableFolder)
-                        .name(fileName)
-                        .build()
-        );
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writableFolder a File object representing a writable folder
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writableFolder, byte[] key) {
-        return create(new RealmConfiguration.Builder(writableFolder)
-                        .name(DEFAULT_REALM_NAME)
-                        .encryptionKey(key)
-                        .build()
-        );
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writableFolder a File object representing a writable folder
-     * @param fileName the name of the Realm file
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @Deprecated
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writableFolder, String fileName, byte[] key) {
-        return create(new RealmConfiguration.Builder(writableFolder)
-                        .name(fileName)
-                        .encryptionKey(key)
-                        .build()
-        );
+        return Realm.getInstance(new RealmConfiguration.Builder(context)
+                    .name(DEFAULT_REALM_NAME)
+                    .build());
     }
 
     /**
@@ -532,6 +384,7 @@ public static Realm getDefaultInstance() {
      *
      * @throws RealmMigrationNeededException If no migration has been provided by the configuration and the
      * model classes or version has has changed so a migration is required.
+     * @throws RealmEncryptionNotSupportedException if the device doesn't support Realm encryption.
      * @see RealmConfiguration for details on how to configure a Realm.
      */
     public static Realm getInstance(RealmConfiguration configuration) {
@@ -578,12 +431,6 @@ private static Realm create(RealmConfiguration configuration) {
     }
 
     private static synchronized Realm createAndValidate(RealmConfiguration configuration, boolean validateSchema, boolean autoRefresh) {
-        // Start the finalizer thread if needed
-        if (!isFinalizerStarted) {
-            executorService.submit(new FinalizerRunnable());
-            isFinalizerStarted = true;
-        }
-
         // Check if a cached instance already exists for this thread
         String canonicalPath = configuration.getPath();
         Map<RealmConfiguration, Integer> localRefCount = referenceCount.get();
@@ -598,11 +445,16 @@ private static synchronized Realm createAndValidate(RealmConfiguration configura
             return realm;
         }
 
-
         // Create new Realm and cache it. All exception code paths must close the Realm otherwise we risk serving
         // faulty cache data.
         validateAgainstExistingConfigurations(configuration);
         realm = new Realm(configuration, autoRefresh);
+        List<RealmConfiguration> pathConfigurationCache = globalPathConfigurationCache.get(canonicalPath);
+        if (pathConfigurationCache == null) {
+            pathConfigurationCache = new CopyOnWriteArrayList<RealmConfiguration>();
+            globalPathConfigurationCache.put(canonicalPath, pathConfigurationCache);
+        }
+        pathConfigurationCache.add(configuration);
         realms.put(configuration, realm);
         localRefCount.put(configuration, references + 1);
 
@@ -647,12 +499,8 @@ private static void validateAgainstExistingConfigurations(RealmConfiguration new
         // Ensure cache state
         String realmPath = newConfiguration.getPath();
         List<RealmConfiguration> pathConfigurationCache = globalPathConfigurationCache.get(realmPath);
-        if (pathConfigurationCache == null) {
-            pathConfigurationCache = new CopyOnWriteArrayList<RealmConfiguration>();
-            globalPathConfigurationCache.put(realmPath, pathConfigurationCache);
-        }
 
-        if (pathConfigurationCache.size() > 0) {
+        if (pathConfigurationCache != null && pathConfigurationCache.size() > 0) {
 
             // For the current restrictions, it is enough to just check one of the existing configurations.
             RealmConfiguration cachedConfiguration = pathConfigurationCache.get(0);
@@ -685,9 +533,6 @@ private static void validateAgainstExistingConfigurations(RealmConfiguration new
                         "configurations pointing to " + newConfiguration.getPath() + " are being used.");
             }
         }
-
-        // The new configuration doesn't violate existing configurations. Cache it.
-        pathConfigurationCache.add(newConfiguration);
     }
 
     @SuppressWarnings("unchecked")
@@ -1076,6 +921,7 @@ public void writeCopyTo(File destination) throws IOException {
      * <p>
      * @param destination File to save the Realm to
      * @throws java.io.IOException if any write operation fails
+     * @throws RealmEncryptionNotSupportedException if the device doesn't support Realm encryption.
      */
     public void writeEncryptedCopyTo(File destination, byte[] key) throws IOException {
         if (destination == null) {
@@ -1356,7 +1202,14 @@ boolean contains(Class<? extends RealmObject> clazz) {
     // Notifications
 
     /**
-     * Add a change listener to the Realm
+     * Add a change listener to the Realm.
+     * <p>
+     * The listeners will be executed:
+     * <ul>
+     *     <li>Immediately if a change was committed by the local thread</li>
+     *     <li>On every loop of a Handler thread if changes were committed by another thread</li>
+     *     <li>On every call to {@link io.realm.Realm#refresh()}</li>
+     * </ul>
      *
      * @param listener the change listener
      * @see io.realm.RealmChangeListener
@@ -1444,12 +1297,14 @@ boolean hasChanged() {
      */
 
     /**
-     * Refresh the Realm instance and all the RealmResults and RealmObjects instances coming from it
+     * Refresh the Realm instance and all the RealmResults and RealmObjects instances coming from it.
+     * It also calls the listeners associated to the Realm instance.
      */
     @SuppressWarnings("UnusedDeclaration")
     public void refresh() {
         checkIfValid();
         transaction.advanceRead();
+        sendNotifications();
     }
 
     /**
@@ -1693,34 +1548,6 @@ private void checkHasPrimaryKey(Class<? extends RealmObject> clazz) {
         }
     }
 
-    @Deprecated
-    public static void migrateRealmAtPath(String realmPath, RealmMigration migration) {
-        migrateRealmAtPath(realmPath, null, migration, true);
-    }
-
-    @Deprecated
-    public static void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration) {
-        migrateRealmAtPath(realmPath, key, migration, true);
-    }
-
-    @Deprecated
-    public static void migrateRealmAtPath(String realmPath, RealmMigration migration, boolean autoRefresh) {
-        migrateRealmAtPath(realmPath, null, migration, autoRefresh);
-    }
-
-    @Deprecated
-    public static synchronized void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration,
-                                                       boolean autoUpdate) {
-        File file = new File(realmPath);
-        RealmConfiguration.Builder configuration = new RealmConfiguration.Builder(file.getParentFile())
-                .name(file.getName())
-                .migration(migration);
-        if (key != null) {
-            configuration.encryptionKey(key);
-        }
-        migrateRealm(configuration.build());
-    }
-
     /**
      * Manually trigger the migration associated with a given RealmConfiguration. If Realm is already at the
      * latest version, nothing will happen.
@@ -1760,44 +1587,6 @@ public static void migrateRealm(RealmConfiguration configuration, RealmMigration
         }
     }
 
-    /**
-     * Deprecated: Use {@link #deleteRealm(RealmConfiguration)} instead.
-     *
-     * Delete the Realm file from the filesystem for the default Realm (named "default.realm").
-     * The Realm must be unused and closed before calling this method.
-     * WARNING: Your Realm must not be open (typically when your app launch).
-     *
-     * @param context an Android {@link android.content.Context}.
-     * @return false if a file could not be deleted. The failing file will be logged.
-     * @see io.realm.Realm#clear(Class)
-     *
-     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
-     */
-    @Deprecated
-    public static boolean deleteRealmFile(Context context) {
-        return deleteRealmFile(context, DEFAULT_REALM_NAME);
-    }
-
-    /**
-     * Deprecated: Use {@link #deleteRealm(RealmConfiguration)} instead.
-     *
-     * Delete the Realm file from the filesystem for a custom named Realm.
-     * The Realm must be unused and closed before calling this method.
-     *
-     * @param context  an Android {@link android.content.Context}.
-     * @param fileName the name of the custom Realm (i.e. "myCustomRealm.realm").
-     * @return false if a file could not be deleted. The failing file will be logged.
-     *
-     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
-     */
-    @Deprecated
-    public static boolean deleteRealmFile(Context context, String fileName) {
-        return deleteRealm(new RealmConfiguration.Builder(context)
-                        .name(fileName)
-                        .build()
-        );
-    }
-
     /**
      * Delete the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
      * The Realm must be unused and closed before calling this method.
@@ -1808,7 +1597,7 @@ public static boolean deleteRealmFile(Context context, String fileName) {
      * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
      */
     public static synchronized boolean deleteRealm(RealmConfiguration configuration) {
-        boolean result = true;
+        boolean realmDeleted = true;
 
         String id = configuration.getPath();
         AtomicInteger counter = globalOpenInstanceCounter.get(id);
@@ -1828,57 +1617,13 @@ public static synchronized boolean deleteRealm(RealmConfiguration configuration)
             if (fileToDelete.exists()) {
                 boolean deleteResult = fileToDelete.delete();
                 if (!deleteResult) {
-                    result = false;
+                    realmDeleted = false;
                     RealmLog.w("Could not delete the file " + fileToDelete);
                 }
             }
         }
-        return result;
-    }
-
-
-    /**
-     * Deprecated: Use {@link #compactRealm(RealmConfiguration)} instead.
-      *
-     * Compact a Realm file. A Realm file usually contain free/unused space.
-     * This method removes this free space and the file size is thereby reduced.
-     * Objects within the Realm files are untouched.
-     * <p>
-     * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the Realm file.<br>
-     * The Realm file is left untouched if any file operation fails.<br>
-     * Currently it is not possible to compact an encrypted Realm.<br>
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param fileName the name of the file to compact
-     * @return true if successful, false if any file operation failed
-     *
-     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
-     */
-    @Deprecated
-    public static synchronized boolean compactRealmFile(Context context, String fileName) {
-        return compactRealm(new RealmConfiguration.Builder(context).name(fileName).build());
-    }
 
-    /**
-     * Deprecated: Use {@link #compactRealm(RealmConfiguration)} instead.
-     *
-     * Compact a Realm file. A Realm file usually contain free/unused space.
-     * This method removes this free space and the file size is thereby reduced.
-     * Objects within the Realm files are untouched.
-     * <p>
-     * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the realm file.<br>
-     * The Realm file is left untouched if any file operation fails.<br>
-     *
-     * @param context an Android {@link android.content.Context}
-     * @return true if successful, false if any file operation failed
-     *
-     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
-     */
-    @Deprecated
-    public static boolean compactRealmFile(Context context) {
-        return compactRealm(new RealmConfiguration.Builder(context).build());
+        return realmDeleted;
     }
 
     /**
diff --git a/realm/src/main/java/io/realm/RealmChangeListener.java b/realm/src/main/java/io/realm/RealmChangeListener.java
index a3487bdc83..da3ceb364d 100644
--- a/realm/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/src/main/java/io/realm/RealmChangeListener.java
@@ -38,6 +38,6 @@
     /**
      * Called when a transaction is committed
      */
-    public void onChange();
+    void onChange();
 
 }
diff --git a/realm/src/main/java/io/realm/RealmConfiguration.java b/realm/src/main/java/io/realm/RealmConfiguration.java
index a4aaa10fd5..fcf0b67d03 100644
--- a/realm/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/src/main/java/io/realm/RealmConfiguration.java
@@ -281,6 +281,10 @@ public Builder name(String filename) {
 
         /**
          * Sets the 64 bit key used to encrypt and decrypt the Realm file.
+         * <p>
+         * Note that a few older devices do not support the encryption used by Realm. These devices will instead throw a
+         * {@link io.realm.exceptions.RealmEncryptionNotSupportedException } when the Realm is opened. See
+         * {@link io.realm.exceptions.RealmEncryptionNotSupportedException } for further details.
          */
         public Builder encryptionKey(byte[] key) {
             if (key == null) {
@@ -361,8 +365,7 @@ public Builder inMemory() {
          * @param baseModule        First Realm module (required).
          * @param additionalModules Additional Realm modules
          *
-         * @throws IllegalArgumentException if any of the modules are {@code null} or doesn't have the
-         * {@link RealmModule} annotation.
+         * @throws IllegalArgumentException if any of the modules doesn't have the {@link RealmModule} annotation.
          * @see Realm#getDefaultModule()
          */
         public Builder setModules(Object baseModule, Object... additionalModules) {
@@ -371,7 +374,6 @@ public Builder setModules(Object baseModule, Object... additionalModules) {
             if (additionalModules != null) {
                 for (int i = 0; i < additionalModules.length; i++) {
                     Object module = additionalModules[i];
-                    checkModule(module);
                     addModule(module);
                 }
             }
@@ -379,8 +381,10 @@ public Builder setModules(Object baseModule, Object... additionalModules) {
         }
 
         private void addModule(Object module) {
-            checkModule(module);
-            modules.add(module);
+            if (module != null) {
+                checkModule(module);
+                modules.add(module);
+            }
         }
 
         /**
@@ -412,9 +416,6 @@ public RealmConfiguration build() {
         }
 
         private void checkModule(Object module) {
-            if (module == null) {
-                throw new IllegalArgumentException("Provided RealmModule must not be null.");
-            }
             if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
                 throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
                         "Add @RealmModule to the class definition.");
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
index 8e2c2e610d..0ea70627b1 100644
--- a/realm/src/main/java/io/realm/RealmList.java
+++ b/realm/src/main/java/io/realm/RealmList.java
@@ -220,7 +220,10 @@ public void move(int oldPos, int newPos) {
     }
 
     /**
-     * {@inheritDoc}
+     * Removes all elements from this list, leaving it empty.
+     *
+     * @see List#isEmpty
+     * @see List#size
      */
     @Override
     public void clear() {
@@ -232,7 +235,11 @@ public void clear() {
     }
 
     /**
-     * {@inheritDoc}
+     * Removes the object at the specified location from this list.
+     *
+     * @param location the index of the object to remove.
+     * @return the removed object.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}
      */
     @Override
     public E remove(int location) {
@@ -246,7 +253,11 @@ public E remove(int location) {
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the element at the specified location in this list.
+     *
+     * @param location the index of the element to return.
+     * @return the element at the specified index.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}
      */
     @Override
     public E get(int location) {
@@ -286,7 +297,9 @@ public E last() {
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the number of elements in this {@code List}.
+     *
+     * @return the number of elements in this {@code List}.
      */
     @Override
     public int size() {
diff --git a/realm/src/main/java/io/realm/RealmMigration.java b/realm/src/main/java/io/realm/RealmMigration.java
index 214aa2f002..afe9d71c17 100644
--- a/realm/src/main/java/io/realm/RealmMigration.java
+++ b/realm/src/main/java/io/realm/RealmMigration.java
@@ -44,11 +44,11 @@
  * </pre>
  *
  * During development when model classes can change frequently, it is possible to use
- * {@link io.realm.Realm#deleteRealmFile(android.content.Context)}. This will delete the database
+ * {@link io.realm.Realm#deleteRealm(RealmConfiguration)}. This will delete the database
  * file and eliminate the need for any migrations.
  *
- * @see Realm#migrateRealmAtPath(String, byte[], RealmMigration)
- * @see Realm#migrateRealmAtPath(String, RealmMigration)
+ * @see Realm#migrateRealm(RealmConfiguration)
+ * @see Realm#migrateRealm(RealmConfiguration, RealmMigration)
  */
 public interface RealmMigration {
 
@@ -59,6 +59,6 @@
      * @param version The schemaVersion of the Realm at the start of the migration.
      * @return The schemaVersion of the Realm after executing the migration.
      */
-    public long execute(Realm realm, long version);
+    long execute(Realm realm, long version);
 }
 
diff --git a/realm/src/main/java/io/realm/RealmResults.java b/realm/src/main/java/io/realm/RealmResults.java
index d034533ea9..3c3108ba78 100644
--- a/realm/src/main/java/io/realm/RealmResults.java
+++ b/realm/src/main/java/io/realm/RealmResults.java
@@ -99,24 +99,30 @@ TableOrView getTable() {
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the element at the specified location in this list.
+     *
+     * @param location the index of the element to return.
+     * @return the element at the specified index.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}
      */
     @Override
-    public E get(int rowIndex) {
+    public E get(int location) {
         E obj;
         realm.checkIfValid();
         TableOrView table = getTable();
         if (table instanceof TableView) {
-            obj = realm.getByIndex(classSpec, ((TableView) table).getSourceRowIndex(rowIndex));
+            obj = realm.get(classSpec, ((TableView)table).getSourceRowIndex(location));
         } else {
-            obj = realm.getByIndex(classSpec, rowIndex);
+            obj = realm.get(classSpec, location);
         }
 
         return obj;
     }
 
     /**
-     * {@inheritDoc}
+     * This method is not supported.
+     *
+     * @throws NoSuchMethodError always.
      */
     @Override
     public int indexOf(Object o) {
@@ -126,6 +132,7 @@ public int indexOf(Object o) {
     /**
      * Get the first object from the list.
      * @return The first object.
+     * @throws ArrayIndexOutOfBoundsException if RealmResults is empty.
      */
     public E first() {
         return get(0);
@@ -134,6 +141,7 @@ public E first() {
     /**
      * Get the last object from the list.
      * @return The last object.
+     * @throws ArrayIndexOutOfBoundsException if RealmResults is empty.
      */
     public E last() {
         return get(size()-1);
@@ -193,7 +201,7 @@ private long getColumnIndex(String fieldName) {
 
     /**
      * Sort (ascending) an existing {@link io.realm.RealmResults}.
-     * 
+     *
      * @param fieldName  The field name to sort by. Only fields of type boolean, short, int, long,
      *                   float, double, Date, and String are supported.
      * @throws java.lang.IllegalArgumentException if field name does not exist.
@@ -266,7 +274,6 @@ public void sort(String fieldNames[], boolean sortAscending[]) {
         }
     }
 
-
     /**
      * Sort existing {@link io.realm.RealmResults} using two fields.
      *
@@ -298,7 +305,9 @@ public void sort(String fieldName1, boolean sortAscending1, String fieldName2, b
     // Aggregates
 
     /**
-     * {@inheritDoc}
+     * Returns the number of elements in this query result.
+     *
+     * @return the number of elements in this query result.
      */
     @Override
     public int size() {
diff --git a/realm/src/main/java/io/realm/exceptions/RealmEncryptionNotSupportedException.java b/realm/src/main/java/io/realm/exceptions/RealmEncryptionNotSupportedException.java
new file mode 100644
index 0000000000..97393d1dce
--- /dev/null
+++ b/realm/src/main/java/io/realm/exceptions/RealmEncryptionNotSupportedException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+/**
+ * On some devices (HTC One X for example), for some reason, the system doesn't pass the right
+ * parameter (siginfo_t.si_addr) to the segfault signal handler which our encryption mechanism
+ * relies on. Realm will try to detect if this problem exists on the device when an encrypted
+ * Realm is being created/opened. A RealmEncryptionNotSupportedException will be thrown if this
+ * problem exists which means that encryption cannot be used on this device.
+ */
+@SuppressWarnings("unused") // Thrown by JNI
+public class RealmEncryptionNotSupportedException extends RuntimeException {
+    public RealmEncryptionNotSupportedException(String message) {
+        super(message);
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/CheckedRow.java b/realm/src/main/java/io/realm/internal/CheckedRow.java
index a6dc7d9fc1..f54aeef888 100644
--- a/realm/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/src/main/java/io/realm/internal/CheckedRow.java
@@ -50,7 +50,7 @@ private CheckedRow(UncheckedRow row) {
     public static CheckedRow get(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
         CheckedRow row = new CheckedRow(context, table, nativeRowPointer);
-        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        context.rowReferences.put(new NativeObjectReference(row, context.referenceQueue), context.ROW_REFERENCES_VALUE);
         return row;
     }
 
@@ -64,7 +64,7 @@ public static CheckedRow get(Context context, Table table, long index) {
     public static CheckedRow get(Context context, LinkView linkView, long index) {
         long nativeRowPointer = linkView.nativeGetRow(linkView.nativeLinkViewPtr, index);
         CheckedRow row = new CheckedRow(context, linkView.parent.getLinkTarget(linkView.columnIndexInParent), nativeRowPointer);
-        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        context.rowReferences.put(new NativeObjectReference(row, context.referenceQueue), context.ROW_REFERENCES_VALUE);
         return row;
     }
 
diff --git a/realm/src/main/java/io/realm/internal/ColumnType.java b/realm/src/main/java/io/realm/internal/ColumnType.java
index 18891ba41a..c9bb97449c 100644
--- a/realm/src/main/java/io/realm/internal/ColumnType.java
+++ b/realm/src/main/java/io/realm/internal/ColumnType.java
@@ -49,8 +49,7 @@
         }
     }
 
-    private ColumnType(int nativeValue)
-    {
+    ColumnType(int nativeValue) {
         this.nativeValue = nativeValue;
     }
 
diff --git a/realm/src/main/java/io/realm/internal/Context.java b/realm/src/main/java/io/realm/internal/Context.java
index b2a785840f..7bf3b62a96 100644
--- a/realm/src/main/java/io/realm/internal/Context.java
+++ b/realm/src/main/java/io/realm/internal/Context.java
@@ -16,10 +16,13 @@
 
 package io.realm.internal;
 
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 
-class Context {
+public class Context {
 
     // Each group of related Realm objects will have a Context object in the root.
     // The root can be a table, a group, or a shared group.
@@ -27,10 +30,16 @@
     // whose disposal need to be handed over from the garbage 
     // collection thread to the users thread.
 
+    // Reserved to be used only as a placholder by rowReferences Map to avoid autoboxing allocations
+    static final Integer ROW_REFERENCES_VALUE = 0;
+
     private List<Long> abandonedTables = new ArrayList<Long>();
     private List<Long> abandonedTableViews = new ArrayList<Long>();
     private List<Long> abandonedQueries = new ArrayList<Long>();
 
+    HashMap<Reference<?>, Integer> rowReferences = new HashMap<Reference<?>, Integer>();
+    ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
+
     private boolean isFinalized = false;
 
     public void executeDelayedDisposal() {
@@ -52,6 +61,17 @@ public void executeDelayedDisposal() {
                 TableQuery.nativeClose(nativePointer);
             }
             abandonedQueries.clear();
+
+            cleanRows();
+        }
+    }
+
+    public void cleanRows() {
+        NativeObjectReference reference = (NativeObjectReference) referenceQueue.poll();
+        while (reference != null) {
+            UncheckedRow.nativeClose(reference.nativePointer);
+            rowReferences.remove(reference);
+            reference = (NativeObjectReference) referenceQueue.poll();
         }
     }
 
diff --git a/realm/src/main/java/io/realm/internal/FinalizerRunnable.java b/realm/src/main/java/io/realm/internal/FinalizerRunnable.java
deleted file mode 100644
index c5e92c5c91..0000000000
--- a/realm/src/main/java/io/realm/internal/FinalizerRunnable.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.lang.ref.Reference;
-import java.lang.ref.ReferenceQueue;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-
-/**
- * This runnable performs the garbage collection of the references stored in the reference queue
- */
-public class FinalizerRunnable implements Runnable {
-
-    // Store the row references. Without this, objects would be garbage collected immediately so don't remove this! ;)
-    // A ConcurrentHashMap is used in lack of a ConcurrentHashSet in the Java API.
-    // ConcurrentLinkedQueue was tried instead, but the removal operation turned out to be too slow.
-    static final Map<Reference<?>, Boolean> references = new ConcurrentHashMap<Reference<?>, Boolean>();
-
-    // This is the actual reference queue in which the garbage collector will insert the row instances ready to be
-    // cleaned up
-    static final ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
-
-
-    @Override
-    public void run() {
-
-        NativeObjectReference reference;
-        while (true) {
-            try {
-                reference = (NativeObjectReference) referenceQueue.remove();
-                references.remove(reference);
-                UncheckedRow.nativeClose(reference.nativePointer);
-            } catch (InterruptedException e) {
-                //restore interrupted exception
-                Thread.currentThread().interrupt();
-            }
-        }
-    }
-}
diff --git a/realm/src/main/java/io/realm/internal/Group.java b/realm/src/main/java/io/realm/internal/Group.java
index 1bb6fa0fac..941ab1ffe5 100644
--- a/realm/src/main/java/io/realm/internal/Group.java
+++ b/realm/src/main/java/io/realm/internal/Group.java
@@ -26,7 +26,12 @@
  * of a collection of tables.
  */
 public class Group implements Closeable {
-    
+
+    // Below values must match the values in realm::group::OpenMode in C++
+    public static final int MODE_READONLY = 0; // Open in read-only mode. Fail if the file does not already exist.
+    public static final int MODE_READWRITE = 1; // Open in read/write mode. Create the file if it doesn't exist.
+    public static final int MODE_READWRITE_NOCREATE = 2; // Open in read/write mode. Fail if the file does not already exist.
+
     protected long nativePtr;
     protected boolean immutable;
     private final Context context;
@@ -35,10 +40,6 @@
         RealmCore.loadLibrary();
     }
 
-    //
-    // Group construction and destruction
-    //
-
     private void checkNativePtrNotZero() {
         if (this.nativePtr == 0)
             // FIXME: It is wrong to assume that a null pointer means 'out
@@ -55,35 +56,19 @@ public Group() {
         checkNativePtrNotZero();
     }
 
-    protected native long createNative();
-
-    public enum OpenMode {
-        // Below values must match the values in realm::group::OpenMode in C++
-        READ_ONLY(0),
-        READ_WRITE(1),
-        READ_WRITE_NO_CREATE(2);
-        private int value;
-        private OpenMode(int value) {
-            this.value = value;
-        }
-    };
-
-    public Group(String filepath, OpenMode mode) {
-        this.immutable = mode.equals(OpenMode.READ_ONLY);
-        
+    public Group(String filepath, int mode) {
+        this.immutable = (mode == MODE_READONLY);
         this.context = new Context();
-        this.nativePtr = createNative(filepath, mode.value);
+        this.nativePtr = createNative(filepath, mode);
         checkNativePtrNotZero();
     }
 
-    protected native long createNative(String filepath, int value);
-
     public Group(String filepath) {
-        this(filepath, OpenMode.READ_ONLY);
+        this(filepath, MODE_READONLY);
     }
 
     public Group(File file) {
-        this(file.getAbsolutePath(), file.canWrite() ? OpenMode.READ_WRITE : OpenMode.READ_ONLY);
+        this(file.getAbsolutePath(), file.canWrite() ? MODE_READWRITE : MODE_READONLY);
     }
 
     public Group(byte[] data) {
@@ -97,8 +82,6 @@ public Group(byte[] data) {
         }
     }
 
-    protected native long createNative(byte[] data);
-
     public Group(ByteBuffer buffer) {
         this.immutable = false;
         this.context = new Context();
@@ -110,8 +93,6 @@ public Group(ByteBuffer buffer) {
         }
     }
 
-    protected native long createNative(ByteBuffer buffer);
-
     Group(Context context, long nativePointer, boolean immutable) {
         this.context = context;
         this.nativePtr = nativePointer;
@@ -129,8 +110,6 @@ public void close() {
         }
     }
 
-    protected static native void nativeClose(long nativeGroupPtr);
-
     /**
      * Checks if a group has been closed and can no longer be used.
      *
@@ -149,10 +128,6 @@ protected void finalize() {
         }
     }
 
-    //
-    // Group methods
-    //
-
     private void verifyGroupIsValid() {
         if (nativePtr == 0) {
             throw new IllegalStateException("Illegal to call methods on a closed Group.");
@@ -164,14 +139,10 @@ public long size() {
         return nativeSize(nativePtr);
     }
 
-    protected native long nativeSize(long nativeGroupPtr);
-
-
     public boolean isEmpty(){
         return size() == 0;
     }
 
-
     /**
      * Checks whether table exists in the Group.
      *
@@ -183,8 +154,6 @@ public boolean hasTable(String name) {
         return name != null && nativeHasTable(nativePtr, name);
     }
 
-    protected native boolean nativeHasTable(long nativeGroupPtr, String name);
-
     public String getTableName(int index) {
         verifyGroupIsValid();
         long cnt = size();
@@ -196,8 +165,6 @@ public String getTableName(int index) {
         return nativeGetTableName(nativePtr, index);
     }
 
-    protected native String nativeGetTableName(long nativeGroupPtr, int index);
-
     /**
      * Returns a table with the specified name.
      *
@@ -228,11 +195,6 @@ public Table getTable(String name) {
         }
     }
 
-    protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
-
-    protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray)
-            throws IOException;
-
     /**
      * Serialize the group to the specific file on the disk using encryption.
      *
@@ -254,8 +216,6 @@ public void writeToFile(File file, byte[] key) throws IOException {
         nativeWriteToFile(nativePtr, file.getAbsolutePath(), key);
     }
 
-    protected static native long nativeLoadFromMem(byte[] buffer);
-
     /**
      * Serialize the group to a memory buffer. The byte[] is owned by the JVM.
      *
@@ -266,7 +226,6 @@ public void writeToFile(File file, byte[] key) throws IOException {
         return nativeWriteToMem(nativePtr);
     }
 
-    protected native byte[] nativeWriteToMem(long nativeGroupPtr);
 /*
  * TODO: Find a way to release the malloc'ed native memory automatically
 
@@ -287,17 +246,27 @@ public String toJson() {
         return nativeToJson(nativePtr);
     }
 
-    protected native String nativeToJson(long nativeGroupPtr);
-
     public String toString() {
         return nativeToString(nativePtr);
     }
 
-    protected native void nativeCommit(long nativeGroupPtr);
-
-    protected native String nativeToString(long nativeGroupPtr);
-
     private void throwImmutable() {
         throw new IllegalStateException("Objects cannot be changed outside a transaction; see beginTransaction() for details.");
     }
+
+    protected native long createNative();
+    protected native long createNative(String filepath, int value);
+    protected native long createNative(byte[] data);
+    protected native long createNative(ByteBuffer buffer);
+    protected static native void nativeClose(long nativeGroupPtr);
+    protected native long nativeSize(long nativeGroupPtr);
+    protected native String nativeGetTableName(long nativeGroupPtr, int index);
+    protected native boolean nativeHasTable(long nativeGroupPtr, String name);
+    protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray) throws IOException;
+    protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
+    protected native long nativeLoadFromMem(byte[] buffer);
+    protected native byte[] nativeWriteToMem(long nativeGroupPtr);
+    protected native String nativeToJson(long nativeGroupPtr);
+    protected native void nativeCommit(long nativeGroupPtr);
+    protected native String nativeToString(long nativeGroupPtr);
 }
diff --git a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
index 0ea882996e..4e54f71d86 100644
--- a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ b/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
@@ -68,7 +68,7 @@ private void assertNotClosed() {
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the absolute path to the Realm file backing this transaction.
      */
     public String getPath() {
         return parent.getPath();
diff --git a/realm/src/main/java/io/realm/internal/InvalidRow.java b/realm/src/main/java/io/realm/internal/InvalidRow.java
index 5aefdbcf84..7f685bdae0 100644
--- a/realm/src/main/java/io/realm/internal/InvalidRow.java
+++ b/realm/src/main/java/io/realm/internal/InvalidRow.java
@@ -20,8 +20,9 @@
 import java.util.Date;
 
 /**
- * Row wrapper that stubs all access with IllegalStateExceptions. This can be used instead of adding null checks
- * everywhere when the underlying Row accessor in Realm Core is no longer available.
+ * Row wrapper that stubs all access with IllegalStateExceptions except for isAttached. This can be used instead of
+ * adding null checks everywhere when the underlying Row accessor in Realm's underlying storage engine is no longer
+ * available.
  */
 public enum InvalidRow implements Row {
     INSTANCE;
@@ -168,7 +169,7 @@ public void nullifyLink(long columnIndex) {
 
     @Override
     public boolean isAttached() {
-        throw getStubException();
+        return false;
     }
 
     @Override
diff --git a/realm/src/main/java/io/realm/internal/RealmCore.java b/realm/src/main/java/io/realm/internal/RealmCore.java
index b4c7601f03..e1e75155d5 100644
--- a/realm/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/src/main/java/io/realm/internal/RealmCore.java
@@ -22,11 +22,9 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
-import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
 import java.nio.ByteBuffer;
 import java.util.Locale;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Utility methods for Realm Core.
@@ -40,7 +38,7 @@
     private static final String JAVA_LIBRARY_PATH = "java.library.path";
 //*/
 
-    private static AtomicBoolean libraryIsLoaded = new AtomicBoolean(false);
+    private static volatile boolean libraryIsLoaded = false;
 
 /*
     private static String getJniFileName()
@@ -94,40 +92,15 @@ public static void print(String caption, AbstractCursor<?> cursor) {
         System.out.println(caption + ": " + cursor);
     }
 */
-    /**
-     * Guarantee gc is done.
-     */
-    public static void gcGuaranteed(){
-        Object obj = new Object();
-        WeakReference<Object> ref = new WeakReference<Object>(obj);
-        obj = null;
-        while (ref.get()!=null)
-            System.gc();
-    }
-
-    /**
-     * Guarantee gc is done after JVM shutdown.
-     */
-    public static void gcOnExit(){
-        Runtime.getRuntime().addShutdownHook(new Thread(){
-            @Override
-            public void run(){
-                gcGuaranteed();
-            }
-        });
-    }
 
-    private static void init() {
-        // Guarantee gc is done on JVM exit to clean up any native resources
-        gcOnExit();
-    }
-
-    public static void loadLibrary() {
-        if (libraryIsLoaded.get())
-            // only load library once
+    // Although loadLibrary is synchronized internally from AOSP 4.3, for the compatibility reason,
+    // KEEP synchronized here for the old devices!
+    public static synchronized void loadLibrary() {
+        if (libraryIsLoaded) {
+            // The java native should ensure only load the lib once, but we met some problems before.
+            // So keep the flag.
             return;
-
-        init();
+        }
 
         if (osIsWindows()) {
             loadLibraryWindows();
@@ -143,7 +116,7 @@ public static void loadLibrary() {
             }
             System.loadLibrary(jnilib);
         }
-        libraryIsLoaded.set(true);
+        libraryIsLoaded = true;
 
         Version.coreLibVersionCompatible(true);
     }
diff --git a/realm/src/main/java/io/realm/internal/SharedGroup.java b/realm/src/main/java/io/realm/internal/SharedGroup.java
index 8b92aff781..340af6e6ea 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroup.java
@@ -105,8 +105,6 @@ void commitAndContinueAsRead() {
         nativeCommitAndContinueAsRead(nativePtr);
     }
 
-    private native void nativeCommitAndContinueAsRead(long nativePtr);
-
     void rollbackAndContinueAsRead() {
         nativeRollbackAndContinueAsRead(nativePtr, nativeReplicationPtr);
     }
@@ -124,8 +122,6 @@ public ImplicitTransaction beginImplicitTransaction() {
         return transaction;
     }
 
-    private native long nativeBeginImplicit(long nativePtr);
-
     public WriteTransaction beginWrite() {
         if (activeTransaction)
             throw new IllegalStateException(
@@ -210,7 +206,6 @@ void rollback() {
         activeTransaction = false;
     }
 
-
     boolean isClosed() {
         return nativePtr == 0;
     }
@@ -233,7 +228,6 @@ public boolean compact() {
         return nativeCompact(nativePtr);
     }
 
-
     /**
      * Returns the absolute path to the file backing this SharedGroup.
      *
@@ -243,37 +237,33 @@ public String getPath() {
         return path;
     }
 
-    private native String nativeGetDefaultReplicationDatabaseFileName();
+    private void checkNativePtrNotZero() {
+        if (this.nativePtr == 0) {
+            throw new IOError(new RealmIOException("Realm could not be opened"));
+        }
+    }
 
+    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, int durability, byte[] key);
+    private native long nativeCreateReplication(String databaseFile, byte[] key);
+    private native void nativeAdvanceRead(long nativePtr);
+    private native void nativePromoteToWrite(long nativePtr);
+    private native void nativeCommitAndContinueAsRead(long nativePtr);
+    private native void nativeRollbackAndContinueAsRead(long nativePtr);
+    private native long nativeBeginImplicit(long nativePtr);
+    private native String nativeGetDefaultReplicationDatabaseFileName();
     private native void nativeReserve(long nativePtr, long bytes);
-
     private native boolean nativeHasChanged(long nativePtr);
-
     private native long nativeBeginRead(long nativePtr);
-
     private native void nativeEndRead(long nativePtr);
-
     private native long nativeBeginWrite(long nativePtr);
-
     private native void nativeCommit(long nativePtr);
-
     private native void nativeRollback(long nativePtr);
-
     private native long nativeCreate(String databaseFile,
                                      int durabilityValue,
                                      boolean no_create,
                                      boolean enableReplication,
                                      byte[] key);
-
     private native boolean nativeCompact(long nativePtr);
-
-    private void checkNativePtrNotZero() {
-        if (this.nativePtr == 0) {
-            throw new IOError(new RealmIOException("Realm could not be opened"));
-        }
-    }
-
     protected static native void nativeClose(long nativePtr);
-
     private native void nativeCloseReplication(long nativeReplicationPtr);
 }
diff --git a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java b/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
deleted file mode 100644
index 176d4b2291..0000000000
--- a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*package io.realm.internal;
-
-public class SharedGroupWithReplication extends SharedGroup {
-
-    public SharedGroupWithReplication()
-    {
-        super("", true);
-    }
-
-    public SharedGroupWithReplication(String databaseFile)
-    {
-        super(databaseFile, true);
-    }
-
-    public static String getDefaultDatabaseFileName()
-    {
-        return nativeGetDefaultReplicationDatabaseFileName();
-    }
-} */
diff --git a/realm/src/main/java/io/realm/internal/TableOrView.java b/realm/src/main/java/io/realm/internal/TableOrView.java
index 63435e8991..72790a7074 100644
--- a/realm/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/src/main/java/io/realm/internal/TableOrView.java
@@ -23,7 +23,7 @@
  */
 public interface TableOrView {
 
-    public static final int NO_MATCH = -1;
+    int NO_MATCH = -1;
 
     void clear();
 
@@ -360,7 +360,7 @@
 
     long count(long columnIndex, String value);
 
-    public enum PivotType {
+    enum PivotType {
         COUNT(0),
         SUM(1),
         AVG(2),
@@ -369,12 +369,12 @@
 
         final int value; // Package protected, accessible from Table and TableView
 
-        private PivotType(int value) {
+        PivotType(int value) {
             this.value = value;
         }
     }
 
-    public Table pivot(long stringCol, long intCol, PivotType pivotType);
+    Table pivot(long stringCol, long intCol, PivotType pivotType);
 
     /**
      * Syncs the tableview with the underlying table data. It is not required to call this
@@ -382,5 +382,5 @@ private PivotType(int value) {
      *
      * @return Version number for the updated tableview.
      */
-    public long sync();
+    long sync();
 }
diff --git a/realm/src/main/java/io/realm/internal/TableQuery.java b/realm/src/main/java/io/realm/internal/TableQuery.java
index 5a9185ae74..3af88aa641 100644
--- a/realm/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/src/main/java/io/realm/internal/TableQuery.java
@@ -23,20 +23,37 @@
     protected boolean DEBUG = false;
 
     protected long nativePtr;
-    protected final Table parent;
+    protected final Table table;
+    // Don't convert this into local variable and don't remove this.
+    // Core requests Query to hold the TableView reference which it is built from.
+    @SuppressWarnings({"unused"})
+    private final TableOrView origin; // Table or TableView which created this TableQuery
     private final Context context;
 
     private boolean queryValidated = true;
 
     // TODO: Can we protect this?
-    public TableQuery(Context context, Table parent, long nativeQueryPtr){
-        if (DEBUG)
+    public TableQuery(Context context, Table table, long nativeQueryPtr) {
+        if (DEBUG) {
             System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
+        }
+        this.context = context;
+        this.table = table;
+        this.nativePtr = nativeQueryPtr;
+        this.origin = null;
+    }
+
+    public TableQuery(Context context, Table table, long nativeQueryPtr, TableOrView origin) {
+        if (DEBUG) {
+            System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
+        }
         this.context = context;
-        this.parent = parent;
+        this.table = table;
         this.nativePtr = nativeQueryPtr;
+        this.origin = origin;
     }
 
+
     public void close() {
         synchronized (context) {
             if (nativePtr != 0) {
@@ -55,7 +72,7 @@ public void close() {
     protected void finalize() {
         synchronized (context) {
             if (nativePtr != 0) {
-                context.asyncDisposeQuery(nativePtr); 
+                context.asyncDisposeQuery(nativePtr);
                 nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
             }
         }
@@ -481,7 +498,7 @@ public TableView findAll(long start, long end, long limit) {
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAll(nativePtr, start, end, limit);
         try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
+            return new TableView(this.context, this.table, nativeViewPtr, this);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
@@ -495,7 +512,7 @@ public TableView findAll() {
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAll(nativePtr, 0, Table.INFINITE, Table.INFINITE);
         try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
+            return new TableView(this.context, this.table, nativeViewPtr, this);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
@@ -757,13 +774,13 @@ public long count() {
     // Deletion.
     public long remove(long start, long end) {
         validateQuery();
-        if (parent.isImmutable()) throwImmutable();
+        if (table.isImmutable()) throwImmutable();
         return nativeRemove(nativePtr, start, end, Table.INFINITE);
     }
 
     public long remove() {
         validateQuery();
-        if (parent.isImmutable()) throwImmutable();
+        if (table.isImmutable()) throwImmutable();
         return nativeRemove(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
diff --git a/realm/src/main/java/io/realm/internal/TableView.java b/realm/src/main/java/io/realm/internal/TableView.java
index da409689b9..bf02373b74 100644
--- a/realm/src/main/java/io/realm/internal/TableView.java
+++ b/realm/src/main/java/io/realm/internal/TableView.java
@@ -64,19 +64,40 @@
  */
 public class TableView implements TableOrView, Closeable {
     protected boolean DEBUG = false; //true;
+    // Don't convert this into local variable and don't remove this.
+    // Core requests TableView to hold the Query reference.
+    @SuppressWarnings({"unused"})
+    private final TableQuery query; // the query which created this TableView
 
-     /**
+    /**
+     * Creates a TableView. This constructor is used if the TableView is created from a table.
+     *
+     * @param context
+     * @param parent
+     * @param nativePtr
+     */
+    protected TableView(Context context, Table parent, long nativePtr) {
+        this.context = context;
+        this.parent = parent;
+        this.nativePtr = nativePtr;
+        this.query = null;
+    }
+
+    /**
      * Creates a TableView with already created Java TableView Object and a
      * native native TableView object reference. The method is not supposed to
      * be called by the user of the db. The method is for internal use only.
      *
+     * @param context
      * @param parent A table.
-     * @param nativePtr pointer to table.
+     * @param nativePtr pointer to table view.
+     * @param query a reference to the query which the table view is based
      */
-    protected TableView(Context context, Table parent, long nativePtr){
+    protected TableView(Context context, Table parent, long nativePtr, TableQuery query) {
         this.context = context;
         this.parent = parent;
         this.nativePtr = nativePtr;
+        this.query = query;
     }
 
     @Override
@@ -85,7 +106,7 @@ public Table getTable() {
     }
 
     @Override
-    public void close(){
+    public void close() {
         synchronized (context) {
             if (nativePtr != 0) {
                 nativeClose(nativePtr);
@@ -848,7 +869,7 @@ public Date minimumDate(long columnIndex) {
 
     // Sorting
 
-    public enum Order { ascending, descending };
+    public enum Order { ascending, descending }
 
     public void sort(long columnIndex, Order order) {
         // Don't check for immutable. Sorting does not modify original table
@@ -910,7 +931,7 @@ public TableQuery where() {
         this.context.executeDelayedDisposal();
         long nativeQueryPtr = nativeWhere(nativePtr);
         try {
-            return new TableQuery(this.context, this.parent, nativeQueryPtr);
+            return new TableQuery(this.context, this.parent, nativeQueryPtr, this);
         } catch (RuntimeException e) {
             TableQuery.nativeClose(nativeQueryPtr);
             throw e;
diff --git a/realm/src/main/java/io/realm/internal/UncheckedRow.java b/realm/src/main/java/io/realm/internal/UncheckedRow.java
index 9c7531766c..8a6a285129 100644
--- a/realm/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/src/main/java/io/realm/internal/UncheckedRow.java
@@ -36,6 +36,8 @@ protected UncheckedRow(Context context, Table parent, long nativePtr) {
         this.context = context;
         this.parent = parent;
         this.nativePointer = nativePtr;
+
+        context.cleanRows();
     }
 
     /**
@@ -48,7 +50,7 @@ protected UncheckedRow(Context context, Table parent, long nativePtr) {
     public static UncheckedRow getByRowIndex(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
         UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
-        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        context.rowReferences.put(new NativeObjectReference(row, context.referenceQueue), context.ROW_REFERENCES_VALUE);
         return row;
     }
 
@@ -75,7 +77,7 @@ public static UncheckedRow getByRowPointer(Context context, Table table, long na
     public static UncheckedRow getByRowIndex(Context context, LinkView linkView, long index) {
         long nativeRowPointer = linkView.nativeGetRow(linkView.nativeLinkViewPtr, index);
         UncheckedRow row = new UncheckedRow(context, linkView.parent.getLinkTarget(linkView.columnIndexInParent), nativeRowPointer);
-        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        context.rowReferences.put(new NativeObjectReference(row, context.referenceQueue), context.ROW_REFERENCES_VALUE);
         return row;
     }
 
diff --git a/realm/src/main/java/io/realm/internal/Util.java b/realm/src/main/java/io/realm/internal/Util.java
index 829391c8b5..0b0e611a80 100644
--- a/realm/src/main/java/io/realm/internal/Util.java
+++ b/realm/src/main/java/io/realm/internal/Util.java
@@ -56,11 +56,11 @@ static void javaPrint(String txt) {
         Exception_OutOfMemory(10),
         Exception_FatalError(11),
         Exception_RuntimeError(12),
-        Exception_RowInvalid(13);
+        Exception_RowInvalid(13),
+        Exception_EncryptionNotSupported(14);
 
         private final int nativeTestcase;
-        private Testcase(int nativeValue)
-        {
+        Testcase(int nativeValue) {
             this.nativeTestcase = nativeValue;
         }
 
diff --git a/realm/src/main/java/io/realm/internal/Version.java b/realm/src/main/java/io/realm/internal/Version.java
index 97b0e32f0f..9464a48502 100644
--- a/realm/src/main/java/io/realm/internal/Version.java
+++ b/realm/src/main/java/io/realm/internal/Version.java
@@ -27,8 +27,7 @@
         Feature_Debug(0),
         Feature_Replication(1);
 
-        private Feature(int nativeValue)
-        {
+        Feature(int nativeValue) {
             this.nativeFeature = nativeValue;
         }
 
diff --git a/realm/src/main/java/io/realm/internal/log/Logger.java b/realm/src/main/java/io/realm/internal/log/Logger.java
index c48f6affaf..2461d73812 100644
--- a/realm/src/main/java/io/realm/internal/log/Logger.java
+++ b/realm/src/main/java/io/realm/internal/log/Logger.java
@@ -4,14 +4,14 @@
  * Interface for Realm logger implementations.
  */
 public interface Logger {
-    public void v(String message);
-    public void v(String message, Throwable t);
-    public void d(String message);
-    public void d(String message, Throwable t);
-    public void i(String message);
-    public void i(String message, Throwable t);
-    public void w(String message);
-    public void w(String message, Throwable t);
-    public void e(String message);
-    public void e(String message, Throwable t);
+    void v(String message);
+    void v(String message, Throwable t);
+    void d(String message);
+    void d(String message, Throwable t);
+    void i(String message);
+    void i(String message, Throwable t);
+    void w(String message);
+    void w(String message, Throwable t);
+    void e(String message);
+    void e(String message, Throwable t);
 }
diff --git a/version.txt b/version.txt
index f3e017c43e..d0019d604d 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.82.0-SNAPSHOT
+0.83.0-SNAPSHOT
