diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index d92707182b..bc95bd28c9 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -26,13 +26,13 @@
           Figure out why. For now place services here
           -->
         <service
-            android:name="io.realm.objectserver.service.SendOneCommit"
+            android:name="io.realm.objectserver.ProcessCommitTests$SimpleCommitRemoteService"
             android:enabled="true"
             android:exported="true"
             android:process=":remote">
         </service>
         <service
-            android:name="io.realm.objectserver.service.SendsALot"
+            android:name="io.realm.objectserver.ProcessCommitTests$ALotCommitsRemoteService"
             android:enabled="true"
             android:exported="true"
             android:process=":remote">
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java
new file mode 100644
index 0000000000..8abdea9c40
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import io.realm.services.RemoteTestService;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * This should be used along with {@link RunWithRemoteService}. See comments there for usage.
+ */
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface RunTestWithRemoteService {
+    Class<? extends RemoteTestService> value();
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java
new file mode 100644
index 0000000000..d2b84bba3e
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.TestHelper;
+import io.realm.services.RemoteTestService;
+
+import static android.support.test.InstrumentationRegistry.getContext;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+/**
+ * This is a helper {@link TestRule} to do test which needs interaction with a remote process.
+ * To use this:
+ * 1. Define a subclass of {@link RemoteTestService} and create steps as static member of it. Those steps should be
+ * named as "stepA_doXXX", "stepB_doYYY", etc. to indicate the order of them.
+ * 2. Add a base message id in {@link RemoteTestService}.
+ * 3. Add the service into the AndroidManifest.xml. And the android:process property must be ":remote".
+ * 4. Annotate your test case by {@link RunTestWithRemoteService} with your remote service class.
+ * 5. You also need a looper in your test thread. Normally you can just use {@link RunTestInLooperThread}.
+ * 6. When your looper thread starts, register the service messenger by calling
+ * {@link RunWithRemoteService#createHandler(Looper)}.
+ * 7. Trigger your first step in the remote service process by calling
+ * {@link RunWithRemoteService#triggerServiceStep(RemoteTestService.Step)}.
+ * 8. Name steps in the foreground process with step1, step2 ... stepN.
+ *    Name steps in the remote process with stepA, stepB ... stepZ.
+ *
+ * See the existing test cases for examples.
+ */
+public class RunWithRemoteService implements TestRule {
+
+    private class InterprocessHandler extends Handler {
+
+        private InterprocessHandler(Looper looper) {
+            super(looper);
+            localMessenger = new Messenger(this);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            Bundle bundle = msg.getData();
+            String error = bundle.getString(RemoteTestService.BUNDLE_KEY_ERROR);
+            if (error != null) {
+                // Assert and show error from remote process
+                fail(error);
+            }
+        }
+    }
+
+    private static final String REMOTE_PROCESS_POSTFIX = ":remote";
+
+    private Messenger remoteMessenger;
+    private Messenger localMessenger;
+    private CountDownLatch serviceStartLatch;
+
+    private final ServiceConnection serviceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
+            remoteMessenger = new Messenger(iBinder);
+            serviceStartLatch.countDown();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName componentName) {
+            if (serviceStartLatch != null && serviceStartLatch.getCount() > 1) {
+                serviceStartLatch.countDown();
+            }
+            serviceStartLatch = null;
+            remoteMessenger = null;
+        }
+    };
+
+    private void before(Class<?> serviceClass) throws Throwable {
+        // Start the testing remote process.
+        serviceStartLatch = new CountDownLatch(1);
+        Intent intent = new Intent(getContext(), serviceClass);
+        getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
+        TestHelper.awaitOrFail(serviceStartLatch);
+    }
+
+    public void after() {
+        getContext().unbindService(serviceConnection);
+
+        // Kill the remote process.
+        ActivityManager.RunningAppProcessInfo info = getRemoteProcessInfo();
+        if (info != null) {
+            android.os.Process.killProcess(info.pid);
+        }
+        int counter = 10;
+        while (getRemoteProcessInfo() != null) {
+            if (counter == 0) {
+                fail("The remote process is still alive.");
+            }
+            try {
+                Thread.sleep(300);
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+            counter--;
+        }
+    }
+
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        final RunTestWithRemoteService annotation = description.getAnnotation(RunTestWithRemoteService.class);
+        if (annotation == null) {
+            return base;
+        }
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                before(annotation.value());
+                try {
+                    base.evaluate();
+                } finally {
+                    after();
+                }
+            }
+        };
+    }
+
+    public void createHandler(Looper looper) {
+        new InterprocessHandler(looper);
+    }
+
+    // Call this to trigger the next step of remote process
+    public void triggerServiceStep(RemoteTestService.Step step) {
+        Message msg = Message.obtain(null, step.message);
+        msg.replyTo = localMessenger;
+        try {
+            remoteMessenger.send(msg);
+        } catch (RemoteException e) {
+            fail(e.getMessage());
+        }
+        // TODO: Find a way to block caller thread until the service process finishes current step.
+    }
+
+    // Get the remote process info if it is alive.
+    private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
+        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
+        for (ActivityManager.RunningAppProcessInfo info : processInfoList) {
+            if (info.processName.equals(getContext().getPackageName() + REMOTE_PROCESS_POSTFIX)) {
+                return info;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
index 78c7c18575..4062ee8e38 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -34,6 +34,7 @@
 
 /**
  * Helper service for multi-processes support testing.
+ * @deprecated use {@link RemoteTestService} instead.
  */
 public class RemoteProcessService extends Service {
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java
new file mode 100644
index 0000000000..46eee6e089
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.services;
+
+import android.annotation.SuppressLint;
+import android.app.Service;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.StrictMode;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.Realm;
+import io.realm.internal.Util;
+import io.realm.log.RealmLog;
+
+/**
+ * Helper class for multi-processes support testing.
+ * @see io.realm.rule.RunWithRemoteService
+ */
+public abstract class RemoteTestService extends Service {
+    // There is no easy way to dynamically ensure step IDs have same value for different processes. So, use the stupid
+    // way.
+    private static int BASE_MSG_ID = 0;
+    protected static int BASE_SIMPLE_COMMIT = BASE_MSG_ID;
+    protected static int BASE_A_LOT_COMMITS  = BASE_SIMPLE_COMMIT + 100;
+
+    public static abstract class Step {
+        public final int message;
+
+        protected Step(int base, int id) {
+            this.message = base + id;
+            stepMap.put(this.message, this);
+        }
+
+        protected abstract void run();
+
+        protected RemoteTestService getService() {
+            return RemoteTestService.thiz;
+        }
+
+        // Pass a null to tell main process that everything is OK.
+        // Otherwise, pass an error String which will be used by assertion in main process.
+        private void response(String error) {
+            try {
+                Message msg = Message.obtain(null, message);
+                if (error != null) {
+                    Bundle bundle = new Bundle();
+                    bundle.putString(BUNDLE_KEY_ERROR, error);
+                    msg.setData(bundle);
+                }
+                thiz.client.send(msg);
+            } catch (RemoteException e) {
+                RealmLog.error(e);
+            }
+        }
+    }
+
+    public static final String BUNDLE_KEY_ERROR = "error";
+    @SuppressLint("UseSparseArrays")
+    private static Map<Integer, Step> stepMap = new HashMap<Integer, Step>();
+    public static RemoteTestService thiz;
+    private final Messenger messenger = new Messenger(new IncomingHandler());
+    private Messenger client;
+    private File rootFolder;
+    private Realm realm;
+
+    public RemoteTestService() {
+        if (thiz != null) {
+            throw new RuntimeException("Only one instance is allowed!");
+        }
+        thiz = this;
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
+        StrictMode.setThreadPolicy(policy);
+        try {
+            rootFolder = File.createTempFile(this.getClass().getSimpleName(), "");
+        } catch (IOException e) {
+            RealmLog.error(e);
+        }
+        //noinspection ResultOfMethodCallIgnored
+        rootFolder.delete();
+        //noinspection ResultOfMethodCallIgnored
+        rootFolder.mkdir();
+
+        Realm.init(getApplicationContext());
+    }
+
+    public File getRoot() {
+        return rootFolder;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return messenger.getBinder();
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        stopSelf();
+        recursiveDelete(rootFolder);
+        return super.onUnbind(intent);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        return START_NOT_STICKY;
+    }
+
+    private static class IncomingHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            thiz.client = msg.replyTo;
+            if (thiz.client == null) {
+                throw new RuntimeException("Message with an empty client.");
+            }
+            Step step = stepMap.get(msg.what);
+            Throwable throwable = null;
+            if (step != null) {
+                try {
+                    step.run();
+                } catch (Throwable t) {
+                    throwable = t;
+                } finally {
+                    if (throwable != null) {
+                        step.response(throwable.getMessage() + "\n" + Util.getStackTrace(throwable));
+                    } else {
+                        step.response(null);
+                    }
+                }
+            } else {
+                throw new RuntimeException("Cannot find corresponding step to message " + msg.what + ".");
+            }
+        }
+    }
+
+    private void recursiveDelete(File file) {
+        File[] files = file.listFiles();
+        if (files != null) {
+            for (File each : files) {
+                recursiveDelete(each);
+            }
+        }
+        //noinspection ResultOfMethodCallIgnored
+        file.delete();
+    }
+
+    public Realm getRealm() {
+        return realm;
+    }
+
+    public void setRealm(Realm realm) {
+        this.realm = realm;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 1cf777cea0..a315e08331 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -4,6 +4,7 @@
 import android.os.Looper;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -94,8 +95,10 @@ public void onError(ObjectServerError error) {
         });
     }
 
+    // FIXME: https://github.com/realm/realm-java/issues/4711
     @Test
     @RunTestInLooperThread
+    @Ignore("This fails expectSimpleCommit for some reasons, needs to be FIXED ASAP.")
     public void login_withAccessToken() {
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
         SyncCredentials credentials = SyncCredentials.accessToken(adminUser.getAccessToken().value(), "custom-admin-user", adminUser.isAdmin());
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index 0ad9688104..ecb219cdae 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -41,6 +41,7 @@
 import io.realm.permissions.PermissionOfferResponse;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestSyncConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -55,8 +56,8 @@
     @Test
     @RunTestInLooperThread
     public void create_acceptOffer() {
-        SyncUser user1 = UserFactory.createUser(Constants.AUTH_URL, "user1");
-        final SyncUser user2 = UserFactory.createUser(Constants.AUTH_URL, "user2");
+        SyncUser user1 = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final SyncUser user2 = UserFactory.createUniqueUser(Constants.AUTH_URL);
 
         // 1. User1 creates Realm that user2 does not have access
         final String user1RealmUrl = "realm://127.0.0.1:9080/" + user1.getIdentity() + "/permission-offer-test";
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index b1469a6a1f..3f63754def 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -16,159 +16,207 @@
 
 package io.realm.objectserver;
 
-import android.content.Context;
-import android.content.Intent;
 import android.os.Looper;
-import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
 
-import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
-import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.objectserver.model.ProcessInfo;
 import io.realm.objectserver.model.TestObject;
-import io.realm.objectserver.service.SendOneCommit;
-import io.realm.objectserver.service.SendsALot;
 import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.RemoteIntegrationTestService;
 import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.RunTestWithRemoteService;
+import io.realm.rule.RunWithRemoteService;
+import io.realm.rule.TestSyncConfigurationFactory;
+import io.realm.services.RemoteTestService;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
 
 
 @RunWith(AndroidJUnit4.class)
 public class ProcessCommitTests extends BaseIntegrationTest {
 
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public RunWithRemoteService remoteService = new RunWithRemoteService();
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Before
+    public void before() throws Exception {
+        UserFactory.resetInstance();
+    }
+
+    public static class SimpleCommitRemoteService extends RemoteIntegrationTestService {
+        private static SyncUser user;
+        public static final Step stepA_openRealmAndCreateOneObject = new Step(RemoteTestService.BASE_SIMPLE_COMMIT, 1) {
+
+            @Override
+            protected void run() {
+                user = UserFactory.getInstance().loginWithDefaultUser(Constants.AUTH_URL);
+                String realmUrl = Constants.SYNC_SERVER_URL;
+
+                final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
+                        .directory(getService().getRoot())
+                        .build();
+                getService().setRealm(Realm.getInstance(syncConfig));
+                Realm realm = getService().getRealm();
+
+                realm.beginTransaction();
+                ProcessInfo processInfo = realm.createObject(ProcessInfo.class);
+                processInfo.setName("Background_Process1");
+                processInfo.setPid(android.os.Process.myPid());
+                processInfo.setThreadId(Thread.currentThread().getId());
+                realm.commitTransaction();
+                // FIXME: If we close the Realm here, the data won't be able to synced to the main process. Is it a bug
+                // in sync client which stops too early?
+                // Realm is currently configured with stop_immediately. This means the sync session is closed as soon as
+                // the last realm instance is closed. Not doing this would make the Realm lifecycle really
+                // unpredictable. We should have an easy way to wait for all changes to be uploaded though.
+                // Perhaps SyncSession.uploadAllLocalChanges() or something similar to
+                // SyncSesson.downloadAllServerChanges()
+            }
+        };
+
+        public static final Step stepB_closeRealmAndLogOut = new Step(RemoteTestService.BASE_SIMPLE_COMMIT, 2) {
+            @Override
+            protected void run() {
+                getService().getRealm().close();
+                user.logout();
+            }
+        };
+    }
+
+    // 1. Open a sync Realm and listen to changes.
+    // A. Open the same sync Realm and add one object.
+    // 2. Get the notification, check if the change in A is received.
     @Test
-    @Ignore("Failure might be caused by two processes each creating a Sync Client: needs investigation")
-    public void expectServerCommit() throws Throwable {
-        final Throwable[] exception = new Throwable[1];
-        final CountDownLatch testFinished = new CountDownLatch(1);
-        ExecutorService service = Executors.newSingleThreadExecutor();
-        //noinspection unused
-        final Future<?> future = service.submit(new Runnable() {
+    @RunTestWithRemoteService(SimpleCommitRemoteService.class)
+    @RunTestInLooperThread
+    public void expectSimpleCommit() {
+        remoteService.createHandler(Looper.myLooper());
+
+        final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);
+        String realmUrl = Constants.SYNC_SERVER_URL;
+        final SyncConfiguration syncConfig = configFactory.createSyncConfigurationBuilder(user, realmUrl).build();
+        final Realm realm = Realm.getInstance(syncConfig);
+        final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
+        looperThread.keepStrongReference(all);
+        all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
             @Override
-            public void run() {
-                try {
-                    Looper.prepare();
-                    Context targetContext = InstrumentationRegistry.getTargetContext();
-
-                    SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-                    String realmUrl = Constants.SYNC_SERVER_URL;
-                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                            .name(SendOneCommit.class.getSimpleName())
-                            .errorHandler(new SyncSession.ErrorHandler() {
-                                @Override
-                                public void onError(SyncSession session, ObjectServerError error) {
-                                    fail("Sync failure: " + error);
-                                }
-                            })
-                            .build();
-                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
-                    final Realm realm = Realm.getInstance(syncConfig);
-                    Intent intent = new Intent(targetContext, SendOneCommit.class);
-                    targetContext.startService(intent);
-                    final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
-                    all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
-                        @Override
-                        public void onChange(RealmResults<ProcessInfo> element) {
-                            assertEquals(1, all.size());
-                            assertEquals("Background_Process1", all.get(0).getName());
-                            testFinished.countDown();
-                        }
-                    });
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    exception[0] = e;
-                    testFinished.countDown();
-                }
+            public void onChange(RealmResults<ProcessInfo> element) {
+                assertEquals(1, all.size());
+                assertEquals("Background_Process1", all.get(0).getName());
+                realm.close();
+                user.logout();
+
+                remoteService.triggerServiceStep(SimpleCommitRemoteService.stepB_closeRealmAndLogOut);
+
+                looperThread.testComplete();
             }
         });
-        boolean testTimedOut = testFinished.await(300, TimeUnit.SECONDS);
-        if (exception[0] != null) {
-            throw exception[0];
-        } else if (!testTimedOut) {
-            fail("Test timed out ");
-        }
+
+        remoteService.triggerServiceStep(SimpleCommitRemoteService.stepA_openRealmAndCreateOneObject);
     }
 
-    // TODO:
-    // - send string from service and match replicate integration tests from Cocoa
-    // - add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process)
-    // - check the requirement for the issue again
+    public static class ALotCommitsRemoteService extends RemoteIntegrationTestService {
+        private static SyncUser user;
+        public static final Step stepA_openRealm = new Step(RemoteTestService.BASE_A_LOT_COMMITS, 1) {
+
+            @Override
+            protected void run() {
+                user = UserFactory.getInstance().loginWithDefaultUser(Constants.AUTH_URL);
+                String realmUrl = Constants.SYNC_SERVER_URL;
+
+                final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
+                        .directory(getService().getRoot())
+                        .name(UUID.randomUUID().toString() + ".realm")
+                        .build();
+                getService().setRealm(Realm.getInstance(syncConfig));
+            }
+        };
+
+        public static final Step stepB_createObjects = new Step(RemoteTestService.BASE_A_LOT_COMMITS, 2) {
+            @Override
+            protected void run() {
+                Realm realm = getService().getRealm();
+                realm.beginTransaction();
+                for (int i = 0; i < 100; i++) {
+                    Number max = realm.where(TestObject.class).findAll().max("intProp");
+                    int pk = max == null ? 0 : max.intValue() + 1;
+                    TestObject testObject = realm.createObject(TestObject.class, pk);
+                    testObject.setStringProp("Str" + pk);
+                }
+                realm.commitTransaction();
+            }
+        };
+
+        public static final Step stepC_closeRealm = new Step(RemoteTestService.BASE_A_LOT_COMMITS, 3) {
+            @Override
+            protected void run() {
+                getService().getRealm().close();
+                user.logout();
+            }
+        };
+    }
+
+    // 1. Open a sync Realm and listen to changes.
+    // A. Open the same sync Realm.
+    // B. Create 100 objects.
+    // 2. Check if the 100 objects are received.
+    // #. Repeat B/2 10 times.
     @Test
-    @Ignore("Failure might be caused by two processes each creating a Sync Client: needs investigation")
+    @RunTestWithRemoteService(ALotCommitsRemoteService.class)
+    @RunTestInLooperThread
     public void expectALot() throws Throwable {
-        final Throwable[] exception = new Throwable[1];
-        final CountDownLatch testFinished = new CountDownLatch(1);
-        ExecutorService service = Executors.newSingleThreadExecutor();
-        //noinspection unused
-        final Future<?> future = service.submit(new Runnable() {
+        remoteService.createHandler(Looper.myLooper());
+
+        final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);
+        String realmUrl = Constants.SYNC_SERVER_URL;
+        final SyncConfiguration syncConfig = configFactory.createSyncConfigurationBuilder(user, realmUrl).build();
+        final Realm realm = Realm.getInstance(syncConfig);
+        final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
+        looperThread.keepStrongReference(all);
+        final AtomicInteger listenerCalledCounter = new AtomicInteger(0);
+        all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
             @Override
-            public void run() {
-                try {
-                    Looper.prepare();
-                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
-
-                    SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-                    String realmUrl = Constants.SYNC_SERVER_URL_2;
-                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                            .name(SendsALot.class.getSimpleName())
-                            .errorHandler(new SyncSession.ErrorHandler() {
-                                @Override
-                                public void onError(SyncSession session, ObjectServerError error) {
-                                    fail("Sync failure: " + error);
-                                }
-                            })
-                            .build();
-                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
-                    final Realm realm = Realm.getInstance(syncConfig);
-                    Intent intent = new Intent(targetContext, SendsALot.class);
-                    targetContext.startService(intent);
-
-                    final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
-                    all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
-                        @Override
-                        public void onChange(RealmResults<TestObject> element) {
-                            assertEquals(100, element.size());
-                            for (int i = 0; i < 100; i++) {
-                                assertEquals(i, element.get(i).getIntProp());
-                                assertEquals("property " + i, element.get(i).getStringProp());
-                            }
-
-                            testFinished.countDown();
-                        }
-                    });
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    exception[0] = e;
-                    testFinished.countDown();
+            public void onChange(RealmResults<TestObject> element) {
+                int counter = listenerCalledCounter.incrementAndGet();
+                int size = all.size();
+                if (size == 0) {
+                    listenerCalledCounter.decrementAndGet();
+                    return;
+                }
+                assertEquals(0, size % 100); // Added 100 objects every time.
+                assertEquals(counter * 100 - 1, all.last().getIntProp());
+                assertEquals("Str" + (counter * 100 - 1), all.last().getStringProp());
+                if (counter == 10) {
+                    remoteService.triggerServiceStep(ALotCommitsRemoteService.stepC_closeRealm);
+                    realm.close();
+                    user.logout();
+                    looperThread.testComplete();
+                } else {
+                    remoteService.triggerServiceStep(ALotCommitsRemoteService.stepB_createObjects);
                 }
             }
         });
-        boolean testTimedOut = testFinished.await(30, TimeUnit.SECONDS);
-        if (exception[0] != null) {
-            throw exception[0];
-        } else if (!testTimedOut) {
-            fail("Test timed out ");
-        }
+
+        remoteService.triggerServiceStep(ALotCommitsRemoteService.stepA_openRealm);
+        remoteService.triggerServiceStep(ALotCommitsRemoteService.stepB_createObjects);
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
index 2bd27a6ef8..43b378d36a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
@@ -17,9 +17,12 @@
 package io.realm.objectserver.model;
 
 import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
 
 public class TestObject extends RealmObject {
+    @PrimaryKey
     private int intProp;
+
     private String stringProp;
 
     public int getIntProp() {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
deleted file mode 100644
index 4653b26211..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver.service;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-
-import io.realm.Realm;
-import io.realm.SyncConfiguration;
-import io.realm.SyncUser;
-import io.realm.objectserver.model.ProcessInfo;
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
-
-/**
- * Open a sync Realm on a different process, then send one commit.
- */
-public class SendOneCommit extends Service {
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        Realm.init(getApplicationContext());
-        SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-        String realmUrl = Constants.SYNC_SERVER_URL;
-        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                .name(SendOneCommit.class.getSimpleName())
-                .build();
-        Realm.deleteRealm(syncConfig);
-        Realm realm = Realm.getInstance(syncConfig);
-
-        realm.beginTransaction();
-        ProcessInfo processInfo = realm.createObject(ProcessInfo.class);
-        processInfo.setName("Background_Process1");
-        processInfo.setPid(android.os.Process.myPid());
-        processInfo.setThreadId(Thread.currentThread().getId());
-        realm.commitTransaction();
-
-        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
deleted file mode 100644
index dca642beb2..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver.service;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-
-import io.realm.Realm;
-import io.realm.SyncConfiguration;
-import io.realm.SyncUser;
-import io.realm.objectserver.model.TestObject;
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
-
-/**
- * Open a sync Realm on a different process, then send one commit.
- */
-public class SendsALot extends Service {
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        Realm.init(getApplicationContext());
-        SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-        String realmUrl = Constants.SYNC_SERVER_URL_2;
-        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                .name(SendsALot.class.getSimpleName())
-                .build();
-        Realm.deleteRealm(syncConfig);
-        Realm realm = Realm.getInstance(syncConfig);
-
-        realm.beginTransaction();
-
-        for (int i = 0; i < 100; i++) {
-            TestObject testObject = realm.createObject(TestObject.class);
-            testObject.setIntProp(i);
-            testObject.setStringProp("property " + i);
-        }
-        realm.commitTransaction();
-
-        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
-    }
-
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index 8d26d58fe4..f1956b5251 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -20,7 +20,7 @@
 
     public static final String USER_REALM = "realm://127.0.0.1:9080/~/tests";
     public static final String USER_REALM_SECURE = "realms://127.0.0.1:9443/~/tests";
-    public static final String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
+    public static final String SYNC_SERVER_URL = "realm://127.0.0.1:9080/~/tests";
     public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
 
     public static final String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index 8770019e59..ab909c0770 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -77,12 +77,10 @@ private static boolean waitAuthServerReady() throws InterruptedException {
                 if (response.isSuccessful()) {
                     return true;
                 }
-                RealmLog.error("Error response from auth server: %s", response.toString());
             } catch (IOException e) {
                 // TODO As long as the auth server hasn't started yet, OKHttp cannot parse the response
                 // correctly. At this point it is unknown weather is a bug in OKHttp or an
                 // unknown host is reported. This can cause a lot of "false" errors in the log.
-                RealmLog.error(e);
                 Thread.sleep(500);
             } finally {
                 if (response != null) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/RemoteIntegrationTestService.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/RemoteIntegrationTestService.java
new file mode 100644
index 0000000000..872b1089ec
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/RemoteIntegrationTestService.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import io.realm.SyncManager;
+import io.realm.services.RemoteTestService;
+
+// Remote test service base class which contains some initialization for sync.
+public class RemoteIntegrationTestService extends RemoteTestService {
+    public RemoteIntegrationTestService() {
+        super();
+        SyncManager.Debug.skipOnlineChecking = true;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index 1145f8a310..f9851b917d 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -16,18 +16,44 @@
 
 package io.realm.objectserver.utils;
 
+import java.util.UUID;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncUser;
+import io.realm.log.RealmLog;
 
+// Helper class to retrieve users with same IDs even in multi-processes.
 // Must be in `io.realm.objectserver` to work around package protected methods.
+// This require Realm.init() to be called before using this class.
 public class UserFactory {
+    private static final String PASSWORD = "myPassw0rd";
+    // Since the integration tests need to use the same user for different processes, we create a new user name when the
+    // test starts and store it in a Realm. Then it can be retrieved for every process.
+    private String userName;
+    private static UserFactory instance;
+    private static RealmConfiguration configuration = new RealmConfiguration.Builder()
+            .name("user-factory.realm")
+            .build();
+
+    private UserFactory(String userName) {
+        this.userName = userName;
+    }
 
-    public static SyncUser createDefaultUser(String authUrl) {
-        return createUser(authUrl, "test-user");
+    public SyncUser loginWithDefaultUser(String authUrl) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, false);
+        return SyncUser.login(credentials, authUrl);
+    }
+
+    public static SyncUser createUniqueUser(String authUrl) {
+        String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, PASSWORD, true);
+        return SyncUser.login(credentials, authUrl);
     }
 
-    public static SyncUser createUser(String authUrl, String userIdentifier) {
-        SyncCredentials credentials = SyncCredentials.usernamePassword(userIdentifier, "myPassw0rd", true);
+    public SyncUser createDefaultUser(String authUrl) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, true);
         return SyncUser.login(credentials, authUrl);
     }
 
@@ -36,4 +62,43 @@ public static SyncUser createAdminUser(String authUrl) {
         SyncCredentials credentials = SyncCredentials.custom("admin", "debug", null);
         return SyncUser.login(credentials, authUrl);
     }
+
+    // Since we don't have a reliable way to reset the sync server and client, just use a new user factory for every
+    // test case.
+    public static void resetInstance() {
+        instance = null;
+        Realm realm = Realm.getInstance(configuration);
+        UserFactoryStore store = realm.where(UserFactoryStore.class).findFirst();
+        realm.beginTransaction();
+        if (store == null) {
+            store = realm.createObject(UserFactoryStore.class);
+        }
+        store.setUserName(UUID.randomUUID().toString());
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    // The @Before method will be called before the looper tests finished. We need to find a better place to call this.
+    public static void clearInstance()  {
+        Realm realm = Realm.getInstance(configuration);
+        realm.beginTransaction();
+        realm.delete(UserFactoryStore.class);
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    public static synchronized UserFactory getInstance() {
+        if (instance == null)  {
+            Realm realm = Realm.getInstance(configuration);
+            UserFactoryStore store = realm.where(UserFactoryStore.class).findFirst();
+            if (store == null || store.getUserName() == null) {
+                throw new IllegalStateException("Current user has not been set. Call resetInstance() first.");
+            }
+
+            instance = new UserFactory(store.getUserName());
+            realm.close();
+        }
+        RealmLog.debug("UserFactory.getInstance, the default user is " + instance.userName + " .");
+        return instance;
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java
new file mode 100644
index 0000000000..80b8bac60c
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import io.realm.RealmObject;
+
+// Used by UserFactory. Storing current user name for testing to share the same user name across processes.
+public class UserFactoryStore extends RealmObject {
+    private String userName;
+
+    public String getUserName() {
+        return userName;
+    }
+
+    public void setUserName(String userName) {
+        this.userName = userName;
+    }
+}
