diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4efbb5d1ae..499c1a45cf 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,20 @@
+## 5.12.0(YYYY-MM-DD)
+
+### Enhancements
+* [ObjectServer] Added `SyncManager.refreshConnections()` that can be used to manually trigger a reconnect for all sessions. This is useful if the device has been offline for a long time or fail to detect that it regained connectivity. (Issue [#259](https://github.com/realm/realm-java-private/issues/259))
+
+### Fixed
+* [ObjectServer] `PermissionManager` stopped working if an intermittent network error was reported. (Issue [#6492](https://github.com/realm/realm-java/issues/6492), since 3.7.0)
+
+### Compatibility
+* Realm Object Server: 3.21.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* None.
+
+
 ## 5.11.0(2019-05-01)
 
 NOTE: This version is only compatible with Realm Object Server 3.21.0 or later.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
index f668c6385d..6ffd9ad5c3 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
@@ -29,6 +29,8 @@
 import java.util.List;
 import java.util.Map;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.OsRealmConfig;
 import io.realm.internal.Util;
 import io.realm.internal.permissions.BasePermissionApi;
@@ -454,13 +456,14 @@ private void checkIfRealmsAreOpenedAndRunDelayedTasks() {
     }
 
     private void checkCallbackNotNull(PermissionManagerBaseCallback callback) {
+        //noinspection ConstantConditions
         if (callback == null) {
             throw new IllegalArgumentException("Non-null 'callback' required.");
         }
     }
 
     private boolean isReady() {
-        return managementRealm != null && permissionRealm != null; // && defaultPermissionRealm != null;
+        return managementRealm != null && permissionRealm != null && defaultPermissionRealm != null;
     }
 
     private void checkIfValid() {
@@ -588,7 +591,6 @@ public void run() {
                 loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
                     @Override
                     public void onChange(RealmResults <Permission> loadedPermissions) {
-                        RealmLog.error(String.format("1stCallback: Size: %s, Permissions: %s", loadedPermissions.size(), Arrays.toString(loadedPermissions.toArray())));
                         // Don't report ready until both __permission and __management Realm are there
                         if (loadedPermissions.size() > 1) {
                             loadingPermissions.removeChangeListener(this);
@@ -1012,17 +1014,34 @@ protected final boolean checkAndReportInvalidState() {
                 return true;
             }
 
-            // We are juggling two different Realms. If only one fail, expose that error directly.
-            // Otherwise try to sensible join the two error messages before returning it to the user.
-            // TODO: Should we expose the underlying Realm errors directly? What else would make sense?
+            // We are juggling three different Realms. If only one fail, expose that error directly.
+            // Otherwise try to sensible join the three error messages before returning it to the user.
             boolean managementErrorHappened;
             boolean permissionErrorHappened;
             boolean defaultPermissionErrorHappened;
             ObjectServerError managementError;
             ObjectServerError permissionError;
             ObjectServerError defaultPermissionError;
+
+            // Only hold lock while making a safe copy of current error state
             synchronized (permissionManager.errorLock) {
-                // Only hold lock while making a safe copy of current error state
+
+                // Check if errors are only intermittent. In that case, just ignore them as
+                // we expect them to resolve eventually. So no reason to cause extra work for
+                // users of the PermissionManager.
+                if (permissionManager.managementRealmError != null && isIntermittentError(permissionManager.managementRealmError)) {
+                    RealmLog.debug("Ignore Management Realm error: " + permissionManager.managementRealmError.toString());
+                    permissionManager.managementRealmError = null;
+                }
+                if (permissionManager.permissionRealmError != null && isIntermittentError(permissionManager.permissionRealmError)) {
+                    RealmLog.debug("Ignore Permission Realm error: " + permissionManager.permissionRealmError.toString());
+                    permissionManager.permissionRealmError = null;
+                }
+                if (permissionManager.defaultPermissionRealmError != null && isIntermittentError(permissionManager.defaultPermissionRealmError)) {
+                    RealmLog.debug("Ignore Default Permission Realm error: " + permissionManager.defaultPermissionRealmError.toString());
+                    permissionManager.defaultPermissionRealmError = null;
+                }
+
                 managementErrorHappened = (permissionManager.managementRealmError != null);
                 permissionErrorHappened = (permissionManager.permissionRealmError != null);
                 defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
@@ -1032,7 +1051,7 @@ protected final boolean checkAndReportInvalidState() {
             }
 
             // Everything seems valid
-            if (!permissionErrorHappened && !managementErrorHappened) {// && !defaultPermissionErrorHappened) {
+            if (!permissionErrorHappened && !managementErrorHappened && !defaultPermissionErrorHappened) {
                 return false;
             }
 
@@ -1081,6 +1100,31 @@ protected final boolean checkAndReportInvalidState() {
             return true;
         }
 
+        private boolean isIntermittentError(@Nullable ObjectServerError error) {
+            // Unknown errors normally have a undefined category as well. All serious errors
+            // should already be covered by known categories, so expect unknown categories
+            // to be intermittent.
+            if (error == null || error.getErrorCode() == ErrorCode.UNKNOWN) {
+                return true;
+            }
+
+            switch (error.getErrorType()) {
+                case ErrorCode.Type.CONNECTION:
+                case ErrorCode.Type.HTTP:
+                case ErrorCode.Type.MISC:
+                case ErrorCode.Type.UNKNOWN:
+                    return true;
+
+                case ErrorCode.Type.AUTH:
+                case ErrorCode.Type.DEPRECATED:
+                case ErrorCode.Type.JAVA:
+                case ErrorCode.Type.PROTOCOL:
+                case ErrorCode.Type.SESSION:
+                default:
+                    return false;
+            }
+        }
+
         /**
          * Handle the status change from ROS and either call error or success callbacks.
          */
@@ -1118,10 +1162,8 @@ protected final void notifyCallbackWithError(ObjectServerError e) {
         // we are forced to report back UNKNOWN as error code. The real error codes
         // will be always part of the exception message.
         private ObjectServerError combineRealmErrors(Map<String, ObjectServerError> errors) {
-
             String errorMsg = combineErrorMessage(errors);
             ErrorCode errorCode = combineErrorCodes(errors);
-
             return new ObjectServerError(errorCode, errorMsg);
         }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index ceb1907170..5d948929d3 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -594,6 +594,21 @@ private synchronized static String bindSessionWithConfig(String sessionPath, Str
         return null;
     }
 
+    /**
+     * Realm will automatically detect when a device gets connectivity after being offline and
+     * resume syncing.
+     * <p>
+     * However, as some of these checks are performed using incremental backoff, this will in some
+     * cases not happen immediately.
+     * <p>
+     * In those cases it can be beneficial to call this method manually, which will force all
+     * sessions to attempt to reconnect immediately and reset any timers they are using for
+     * incremental backoff.
+     */
+    public static void refreshConnections() {
+        notifyNetworkIsBack();
+    }
+
     // Holds the certificate chain (per hostname). We need to keep the order of each certificate
     // according to it's depth in the chain. The depth of the last
     // certificate is 0. The depth of the first certificate is chain
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
index d418b763d4..4582e819c1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
@@ -506,7 +506,7 @@ public void permissionManagerAsyncTask_handlePermissionRealmError() throws NoSuc
         // Simulate error in the permission Realm
         Field permissionConfigField = pm.getClass().getDeclaredField("permissionRealmError");
         permissionConfigField.setAccessible(true);
-        final ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN, "Boom");
+        final ObjectServerError error = new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom");
         permissionConfigField.set(pm, error);
 
         PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
@@ -519,7 +519,7 @@ public void onSuccess() {
             public void onError(ObjectServerError error) {
                 assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
                 assertTrue(error.getErrorMessage().contains("Permission Realm"));
-                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
                 looperThread.testComplete();
             }
         };
@@ -535,7 +535,7 @@ public void permissionManagerAsyncTask_handleManagementRealmError() throws NoSuc
         looperThread.closeAfterTest(pm);
 
         // Simulate error in the permission Realm
-        final ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN, "Boom");
+        final ObjectServerError error = new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom");
         setRealmError(pm, "managementRealmError", error);
 
         PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
@@ -548,7 +548,7 @@ public void onSuccess() {
             public void onError(ObjectServerError error) {
                 assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
                 assertTrue(error.getErrorMessage().contains("Management Realm"));
-                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
                 looperThread.testComplete();
             }
         };
@@ -564,10 +564,10 @@ public void permissionManagerAsyncTask_handleTwoErrorsSameErrorCode() throws NoS
         looperThread.closeAfterTest(pm);
 
         // Simulate error in the permission Realm
-        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom1"));
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom1"));
 
         // Simulate error in the management Realm
-        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom2"));
+        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom2"));
 
         PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
             @Override
@@ -577,7 +577,7 @@ public void onSuccess() {
 
             @Override
             public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.CONNECTION_CLOSED, error.getErrorCode());
+                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
                 assertTrue(error.toString().contains("Boom1"));
                 assertTrue(error.toString().contains("Boom2"));
                 looperThread.testComplete();
@@ -588,6 +588,66 @@ public void onError(ObjectServerError error) {
         runTask(pm, callback);
     }
 
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_doNotReportIntermittentErrors() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate intermittent error in the management Realm that is possible to recover from
+        // These kind of errors should never reach the end user as we should recover automatically.
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.UNKNOWN, "Boom1"));
+
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertEquals(3, permissions.size());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_keepReportingFatalErrors() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate fatal error in the management Realm that is not possible to recover from
+        // This should be reported for all tasks, not just the first one.
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.WRONG_PROTOCOL_VERSION, "Boom1"));
+
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.WRONG_PROTOCOL_VERSION, error.getErrorCode());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+        });
+    }
+
+
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
     public void permissionManagerAsyncTask_handleTwoErrorsDifferentErrorCode() throws NoSuchFieldException, IllegalAccessException {
