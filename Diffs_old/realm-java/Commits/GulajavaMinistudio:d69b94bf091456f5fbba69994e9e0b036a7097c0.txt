diff --git a/CHANGELOG.md b/CHANGELOG.md
index 826a4c9524..f51a5c7b57 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,14 +17,18 @@ and `SyncUser#retrieveInfoForUserAsync` which returns a `SyncUserInfo` with mode
 * [ObjectServer] Added `SyncUser.allSessions` to retrieve the all valid sessions belonging to the user (#4783).
 * Added `Nullable` annotation to methods that may return `null` in order to improve Kotlin usability. This also introduced a dependency to `com.google.code.findbugs:jsr305`.
 * Added support for new data type `MutableRealmIntegers`. The new type behaves almost exactly as a reference to a Long (mutable nullable, etc) but supports `increment` and `decrement` methods, which implement a Conflict Free Replicated Data Type, whose value will converge even when changed across distributed devices with poor connections (#4266).
+* Added more detailed exception message for `RealmMigrationNeeded`.
+* Bumping schema version only without any actual schema changes will just succeed even when the migration block is not supplied. It threw an `RealmMigrationNeededException` before in the same case.
+* Throw `IllegalStateException` when schema validation fails because of wrong declaration of `@LinkingObjects`.
 
 ### Bug Fixes
 
 ### Internal
+
 * [ObjectServer] removed `ObjectServerUser` and its inner classes, in a step to reduce `SyncUser` complexity (#3741).
 * [ObjectServer] changed the `SyncSessionStopPolicy` to `AfterChangesUploaded` to align with other binding and to prevent use cases where the Realm might be deleted before the last changes get synchronized (#5028).
-
 * Upgraded Realm Sync to 1.10.8
+* Let Object Store handle migration.
 
 ## 3.5.1 (YYYY-MM-DD)
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index a34789b71f..6fcb0e32ec 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -27,7 +27,6 @@
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Locale;
-import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -52,6 +51,7 @@
             "io.realm.internal.ColumnInfo",
             "io.realm.internal.LinkView",
             "io.realm.internal.OsObject",
+            "io.realm.internal.OsSchemaInfo",
             "io.realm.internal.OsObjectSchemaInfo",
             "io.realm.internal.Property",
             "io.realm.internal.ProxyUtils",
@@ -140,7 +140,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitBacklinkFieldAccessors(writer);
         emitCreateExpectedObjectSchemaInfo(writer);
         emitGetExpectedObjectSchemaInfo(writer);
-        emitValidateTableMethod(writer);
+        emitCreateColumnInfoMethod(writer);
         emitGetTableNameMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitCreateOrUpdateUsingJsonObject(writer);
@@ -179,16 +179,18 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
         // constructor #1
         writer.beginConstructor(
                 EnumSet.noneOf(Modifier.class),
-                "SharedRealm", "realm", "Table", "table");
+                "OsSchemaInfo", "schemaInfo");
         writer.emitStatement("super(%s)", metadata.getFields().size());
+        writer.emitStatement("OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"%1$s\")",
+                simpleClassName);
         for (VariableElement field : metadata.getFields()) {
             writer.emitStatement(
-                    "this.%1$sIndex = addColumnDetails(table, \"%1$s\", %2$s)",
-                    field.getSimpleName().toString(), getRealmTypeChecked(field).getRealmType());
+                    "this.%1$sIndex = addColumnDetails(\"%1$s\", objectSchemaInfo)",
+                    field.getSimpleName().toString());
         }
         for (Backlink backlink : metadata.getBacklinkFields()) {
             writer.emitStatement(
-                    "addBacklinkDetails(realm, \"%s\", \"%s\", \"%s\")",
+                    "addBacklinkDetails(schemaInfo, \"%s\", \"%s\", \"%s\")",
                     backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
         }
         writer.endConstructor()
@@ -672,13 +674,13 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
 
                 case OBJECT:
                     String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
-                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
+                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
                             fieldName, fieldTypeSimpleName);
                     break;
 
                 case LIST:
                     String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
+                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
                             fieldName, genericTypeSimpleName);
                     break;
 
@@ -686,7 +688,7 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
                     String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                     String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                     String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                    writer.emitStatement("builder.addProperty(\"%s\", %s, %s, %s, %s)",
+                    writer.emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)",
                             fieldName,
                             fieldType.getRealmType(),
                             primaryKeyFlag,
@@ -694,6 +696,10 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
                             nullableFlag);
             }
         }
+        for (Backlink backlink: metadata.getBacklinkFields()) {
+            writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
+                    backlink.getTargetField(), backlink.getSimpleSourceClass(), backlink.getSourceField());
+        }
         writer.emitStatement("return builder.build()");
         writer.endMethod()
                 .emitEmptyLine();
@@ -711,247 +717,20 @@ private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOExcepti
                 .emitEmptyLine();
     }
 
-    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
+    private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 columnInfoClassName(),        // Return type
-                "validateTable",              // Method name
+                "createColumnInfo",              // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "SharedRealm", "sharedRealm", // Argument type & argument name
-                "boolean", "allowExtraColumns");
-
-        writer.beginControlFlow(
-                "if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        emitMigrationNeededException(writer, "\"The '%s' class is missing from the schema for this Realm.\")",
-                metadata.getSimpleClassName());
-        writer.endControlFlow();
-
-        writer.emitStatement(
-                "Table table = sharedRealm.getTable(\"%s%s\")",
-                Constants.TABLE_PREFIX,
-                this.simpleClassName);
-
-        // verify number of columns
-        writer.emitStatement("final long columnCount = table.getColumnCount()");
-        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
-        writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
-        emitMigrationNeededException(writer, "\"Field count is less than expected - expected %d but was \" + columnCount)",
-                metadata.getFields().size());
-        writer.endControlFlow();
-        writer.beginControlFlow("if (allowExtraColumns)");
-        writer.emitStatement(
-                "RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
-                metadata.getFields().size());
-        writer.nextControlFlow("else");
-        emitMigrationNeededException(writer, "\"Field count is more than expected - expected %d but was \" + columnCount)",
-                metadata.getFields().size());
-        writer.endControlFlow();
-        writer.endControlFlow();
-
-        // create type dictionary for lookup
-        writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
-        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)")
-                .emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))")
-                .endControlFlow()
-                .emitEmptyLine();
+                "OsSchemaInfo", "schemaInfo"); // Argument type & argument name
 
         // create an instance of ColumnInfo
-        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm, table)", columnInfoClassName())
-                .emitEmptyLine();
-
-        // verify primary key definition was not altered
-        if (metadata.hasPrimaryKey()) {
-            // the current model defines a PK, make sure it's defined in the Realm schema
-            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            writer.beginControlFlow("if (!table.hasPrimaryKey())");
-            emitMigrationNeededException(writer, "\"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")",
-                    metadata.getPrimaryKey().getSimpleName().toString());
-            writer.nextControlFlow("else")
-                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName);
-            emitMigrationNeededException(writer, "\"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")",
-                    metadata.getPrimaryKey().getSimpleName().toString());
-            writer.endControlFlow()
-                    .endControlFlow();
-        } else {
-            // the current model doesn't define a PK, make sure it's not defined in the Realm schema
-            writer.beginControlFlow("if (table.hasPrimaryKey())");
-            emitMigrationNeededException(writer, "\"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")");
-            writer.endControlFlow();
-        }
-        writer.emitEmptyLine();
-
-        // For each field verify there is a corresponding
-        long fieldIndex = -1;
-        for (VariableElement field : metadata.getFields()) {
-            fieldIndex++;
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
-                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
-            } else if (Utils.isMutableRealmInteger(field)) {
-                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
-            } else if (Utils.isRealmModel(field)) { // Links
-                emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
-            } else if (Utils.isRealmList(field)) { // Link Lists
-                emitValidateRealmListType(writer, field, fieldIndex, fieldName);
-            }
-        }
-
-        // verify the backlinks
-        Set<Backlink> backlinks = metadata.getBacklinkFields();
-        if (backlinks.size() > 0) {
-            writer.emitEmptyLine()
-                    .emitStatement("long backlinkFieldIndex")
-                    .emitStatement("Table backlinkSourceTable")
-                    .emitStatement("Table backlinkTargetTable")
-                    .emitStatement("RealmFieldType backlinkFieldType");
-            for (Backlink backlink : metadata.getBacklinkFields()) {
-                emitValidateBacklink(writer, backlink);
-            }
-        }
-
-        writer.emitEmptyLine();
-        writer.emitStatement("return %s", "columnInfo");
+        writer.emitStatement("return new %1$s(schemaInfo)", columnInfoClassName());
 
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
-            throws IOException {
-
-        // make field sure types align
-        writer.emitStatement(
-                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", %s, \"%s\")",
-                fieldName, getRealmTypeChecked(field).getRealmType(), Utils.getFieldTypeSimpleName(field));
-
-        // make sure that nullability matches
-        if (!metadata.isNullable(field)) {
-            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' does support null values in the existing Realm file. " +
-                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            } else {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' does support null values in the existing Realm file. " +
-                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            }
-            writer.endControlFlow();
-        } else {
-            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
-            if (metadata.isPrimaryKey(field)) {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
-                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
-                        fieldName);
-                // nullability check for boxed types
-            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                "\"Field '%s' does not support null values in the existing Realm file. " +
-                                "Either set @Required, use the primitive type for field '%s' " +
-                                "or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            } else {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' is required. Either set @Required to field '%s' " +
-                                "or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            }
-            writer.endControlFlow();
-        }
-
-        // Validate @Index
-        if (metadata.getIndexedFields().contains(field)) {
-            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
-            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
-                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
-            writer.endControlFlow();
-        }
-    }
-
-    private void emitValidateRealmModelType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
-            throws IOException {
-        String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
-
-        // make field sure types align
-        writer.emitStatement(
-                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.OBJECT, \"%s\")",
-                fieldName, Utils.getFieldTypeSimpleName(field));
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
-                Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
-        writer.endControlFlow();
-
-        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
-                fieldIndexVariableReference(field), fieldIndex);
-        emitMigrationNeededException(writer, "\"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                fieldName, fieldIndexVariableReference(field), fieldIndex);
-        writer.endControlFlow();
-    }
-
-    private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
-            throws IOException {
-
-        String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-
-        writer.emitStatement(
-                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.LIST, \"%s\")",
-                fieldName, genericTypeSimpleName);
-
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
-        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
-                Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
-        writer.endControlFlow();
-
-        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
-        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
-                fieldIndexVariableReference(field), fieldIndex);
-        emitMigrationNeededException(writer, "\"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                fieldName, fieldIndexVariableReference(field), fieldIndex);
-        writer.endControlFlow();
-    }
-
-    private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws IOException {
-        String targetField = backlink.getTargetField();
-        String targetClass = backlink.getTargetClass();
-
-        // Preceding code has already verified that the backlink field is not in the table.
-        // If it were, either the column count would be wrong, or some field would be missing.
-
-        // verify that the source class exists
-        String sourceClass = backlink.getSimpleSourceClass();
-        String fullyQualifiedSourceClass = backlink.getSourceClass();
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, sourceClass);
-        emitMigrationNeededException(writer, "\"Cannot find source class '%s' for @LinkingObjects field '%s.%s'\")",
-                fullyQualifiedSourceClass, targetClass, targetField);
-        writer.endControlFlow();
-
-        // verify that the source class contains the source field
-        String sourceField = backlink.getSourceField();
-        writer.emitStatement("backlinkSourceTable = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, sourceClass);
-        writer.emitStatement("backlinkFieldIndex = backlinkSourceTable.getColumnIndex(\"%s\")", sourceField);
-        writer.beginControlFlow("if (backlinkFieldIndex == Table.NO_MATCH)");
-        emitMigrationNeededException(writer, "\"Cannot find source field '%s.%s' for @LinkingObjects field '%s.%s'\")",
-                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
-        writer.endControlFlow();
-
-        // verify that the source field type is target class
-        writer.emitStatement("backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex)");
-        writer.beginControlFlow("if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST))");
-        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' is not a RealmObject type\")",
-                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
-        writer.endControlFlow();
-        writer.emitStatement("backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex)");
-        writer.beginControlFlow("if (!table.hasSameSchema(backlinkTargetTable))");
-        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' has wrong type '\" + backlinkTargetTable.getName() + \"'\")",
-                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
-        writer.endControlFlow();
-    }
-
     //@formatter:off
     private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
@@ -2125,10 +1904,6 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitMigrationNeededException(JavaWriter writer, String message, Object... args) throws IOException {
-        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), " + message, args);
-    }
-
     private String columnInfoClassName() {
         return simpleClassName + "ColumnInfo";
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 2b22cb915d..af3fc09c2c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -81,6 +81,7 @@ public void generate() throws IOException {
                 "io.realm.internal.RealmProxyMediator",
                 "io.realm.internal.Row",
                 "io.realm.internal.Table",
+                "io.realm.internal.OsSchemaInfo",
                 "io.realm.internal.OsObjectSchemaInfo",
                 "org.json.JSONException",
                 "org.json.JSONObject"
@@ -98,7 +99,7 @@ public void generate() throws IOException {
 
         emitFields(writer);
         emitGetExpectedObjectSchemaInfoMap(writer);
-        emitValidateTableMethod(writer);
+        emitCreateColumnInfoMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitGetTableNameMethod(writer);
         emitNewInstanceMethod(writer);
@@ -147,20 +148,20 @@ private void emitGetExpectedObjectSchemaInfoMap(JavaWriter writer) throws IOExce
         writer.emitEmptyLine();
     }
 
-    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
+    private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
                 "ColumnInfo",
-                "validateTable",
+                "createColumnInfo",
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz", // Argument type & argument name
-                "SharedRealm", "sharedRealm",
-                "boolean", "allowExtraColumns"
+                "OsSchemaInfo", "schemaInfo"
         );
+
         emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.validateTable(sharedRealm, allowExtraColumns)",
+                writer.emitStatement("return %s.createColumnInfo(schemaInfo)",
                         qualifiedProxyClasses.get(i));
             }
         }, writer);
@@ -451,10 +452,6 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     // Emits the control flow for selecting the appropriate proxy class based on the model class
     // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
     // Consider switching to HashMap or similar.
-    private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer) throws IOException {
-        emitMediatorSwitch(statement, writer, true);
-    }
-
     private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
             throws IOException {
         if (nullPointerCheck) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 5d99da6225..a855774e9d 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -10,6 +10,7 @@
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.Property;
 import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
@@ -47,19 +48,20 @@
         long columnObjectIndex;
         long columnRealmListIndex;
 
-        AllTypesColumnInfo(SharedRealm realm, Table table) {
+        AllTypesColumnInfo(OsSchemaInfo schemaInfo) {
             super(10);
-            this.columnStringIndex = addColumnDetails(table, "columnString", RealmFieldType.STRING);
-            this.columnLongIndex = addColumnDetails(table, "columnLong", RealmFieldType.INTEGER);
-            this.columnFloatIndex = addColumnDetails(table, "columnFloat", RealmFieldType.FLOAT);
-            this.columnDoubleIndex = addColumnDetails(table, "columnDouble", RealmFieldType.DOUBLE);
-            this.columnBooleanIndex = addColumnDetails(table, "columnBoolean", RealmFieldType.BOOLEAN);
-            this.columnDateIndex = addColumnDetails(table, "columnDate", RealmFieldType.DATE);
-            this.columnBinaryIndex = addColumnDetails(table, "columnBinary", RealmFieldType.BINARY);
-            this.columnMutableRealmIntegerIndex = addColumnDetails(table, "columnMutableRealmInteger", RealmFieldType.INTEGER);
-            this.columnObjectIndex = addColumnDetails(table, "columnObject", RealmFieldType.OBJECT);
-            this.columnRealmListIndex = addColumnDetails(table, "columnRealmList", RealmFieldType.LIST);
-            addBacklinkDetails(realm, "parentObjects", "AllTypes", "columnObject");
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("AllTypes");
+            this.columnStringIndex = addColumnDetails("columnString", objectSchemaInfo);
+            this.columnLongIndex = addColumnDetails("columnLong", objectSchemaInfo);
+            this.columnFloatIndex = addColumnDetails("columnFloat", objectSchemaInfo);
+            this.columnDoubleIndex = addColumnDetails("columnDouble", objectSchemaInfo);
+            this.columnBooleanIndex = addColumnDetails("columnBoolean", objectSchemaInfo);
+            this.columnDateIndex = addColumnDetails("columnDate", objectSchemaInfo);
+            this.columnBinaryIndex = addColumnDetails("columnBinary", objectSchemaInfo);
+            this.columnMutableRealmIntegerIndex = addColumnDetails("columnMutableRealmInteger", objectSchemaInfo);
+            this.columnObjectIndex = addColumnDetails("columnObject", objectSchemaInfo);
+            this.columnRealmListIndex = addColumnDetails("columnRealmList", objectSchemaInfo);
+            addBacklinkDetails(schemaInfo, "parentObjects", "AllTypes", "columnObject");
         }
 
         AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
@@ -418,16 +420,17 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes");
-        builder.addProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addLinkedProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
-        builder.addLinkedProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
+        builder.addPersistedProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedLinkProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
+        builder.addPersistedLinkProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
+        builder.addComputedLinkProperty("parentObjects", "AllTypes", "columnObject");
         return builder.build();
     }
 
@@ -435,111 +438,8 @@ public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
         return expectedObjectSchemaInfo;
     }
 
-    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
-        }
-        Table table = sharedRealm.getTable("class_AllTypes");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 10) {
-            if (columnCount < 10) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 10 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 10 but was %1$d", columnCount);
-            } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 10 but was " + columnCount);
-            }
-        }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm, table);
-
-        if (!table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
-        } else {
-            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
-            }
-        }
-
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnString", RealmFieldType.STRING, "String");
-        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
-        }
-        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnLong", RealmFieldType.INTEGER, "long");
-        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnFloat", RealmFieldType.FLOAT, "float");
-        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDouble", RealmFieldType.DOUBLE, "double");
-        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBoolean", RealmFieldType.BOOLEAN, "boolean");
-        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDate", RealmFieldType.DATE, "Date");
-        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBinary", RealmFieldType.BINARY, "byte[]");
-        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnMutableRealmInteger", RealmFieldType.INTEGER, "MutableRealmInteger");
-        if (!table.isColumnNullable(columnInfo.columnMutableRealmIntegerIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnMutableRealmInteger' is required. Either set @Required to field 'columnMutableRealmInteger' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
-        }
-        Table table_8 = sharedRealm.getTable("class_AllTypes");
-        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_8)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_8.getName() + "'");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
-        }
-        Table table_9 = sharedRealm.getTable("class_AllTypes");
-        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_9)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_9.getName() + "'");
-        }
-
-        long backlinkFieldIndex;
-        Table backlinkSourceTable;
-        Table backlinkTargetTable;
-        RealmFieldType backlinkFieldType;
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
-        }
-        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
-        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
-        if (backlinkFieldIndex == Table.NO_MATCH) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
-        }
-        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
-        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
-        }
-        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
-        if (!table.hasSameSchema(backlinkTargetTable)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
-        }
-
-        return columnInfo;
+    public static AllTypesColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new AllTypesColumnInfo(schemaInfo);
     }
 
     public static String getTableName() {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index b7965d3586..5e503752d6 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -10,6 +10,7 @@
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.Property;
 import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
@@ -40,12 +41,13 @@
         long mCompletedIndex;
         long anotherBooleanIndex;
 
-        BooleansColumnInfo(SharedRealm realm, Table table) {
+        BooleansColumnInfo(OsSchemaInfo schemaInfo) {
             super(4);
-            this.doneIndex = addColumnDetails(table, "done", RealmFieldType.BOOLEAN);
-            this.isReadyIndex = addColumnDetails(table, "isReady", RealmFieldType.BOOLEAN);
-            this.mCompletedIndex = addColumnDetails(table, "mCompleted", RealmFieldType.BOOLEAN);
-            this.anotherBooleanIndex = addColumnDetails(table, "anotherBoolean", RealmFieldType.BOOLEAN);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Booleans");
+            this.doneIndex = addColumnDetails("done", objectSchemaInfo);
+            this.isReadyIndex = addColumnDetails("isReady", objectSchemaInfo);
+            this.mCompletedIndex = addColumnDetails("mCompleted", objectSchemaInfo);
+            this.anotherBooleanIndex = addColumnDetails("anotherBoolean", objectSchemaInfo);
         }
 
         BooleansColumnInfo(ColumnInfo src, boolean mutable) {
@@ -191,10 +193,10 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Booleans");
-        builder.addProperty("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         return builder.build();
     }
 
@@ -202,51 +204,8 @@ public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
         return expectedObjectSchemaInfo;
     }
 
-    public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_Booleans")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
-        }
-        Table table = sharedRealm.getTable("class_Booleans");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 4) {
-            if (columnCount < 4) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 4 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 4 but was %1$d", columnCount);
-            } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 4 but was " + columnCount);
-            }
-        }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm, table);
-
-        if (table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-        }
-
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "done", RealmFieldType.BOOLEAN, "boolean");
-        if (table.isColumnNullable(columnInfo.doneIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "isReady", RealmFieldType.BOOLEAN, "boolean");
-        if (table.isColumnNullable(columnInfo.isReadyIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "mCompleted", RealmFieldType.BOOLEAN, "boolean");
-        if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "anotherBoolean", RealmFieldType.BOOLEAN, "boolean");
-        if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
-        }
-
-        return columnInfo;
+    public static BooleansColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new BooleansColumnInfo(schemaInfo);
     }
 
     public static String getTableName() {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 5aef17d6bd..194605c183 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -10,6 +10,7 @@
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.Property;
 import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
@@ -57,29 +58,30 @@
         long fieldDateNullIndex;
         long fieldObjectNullIndex;
 
-        NullTypesColumnInfo(SharedRealm realm, Table table) {
+        NullTypesColumnInfo(OsSchemaInfo schemaInfo) {
             super(21);
-            this.fieldStringNotNullIndex = addColumnDetails(table, "fieldStringNotNull", RealmFieldType.STRING);
-            this.fieldStringNullIndex = addColumnDetails(table, "fieldStringNull", RealmFieldType.STRING);
-            this.fieldBooleanNotNullIndex = addColumnDetails(table, "fieldBooleanNotNull", RealmFieldType.BOOLEAN);
-            this.fieldBooleanNullIndex = addColumnDetails(table, "fieldBooleanNull", RealmFieldType.BOOLEAN);
-            this.fieldBytesNotNullIndex = addColumnDetails(table, "fieldBytesNotNull", RealmFieldType.BINARY);
-            this.fieldBytesNullIndex = addColumnDetails(table, "fieldBytesNull", RealmFieldType.BINARY);
-            this.fieldByteNotNullIndex = addColumnDetails(table, "fieldByteNotNull", RealmFieldType.INTEGER);
-            this.fieldByteNullIndex = addColumnDetails(table, "fieldByteNull", RealmFieldType.INTEGER);
-            this.fieldShortNotNullIndex = addColumnDetails(table, "fieldShortNotNull", RealmFieldType.INTEGER);
-            this.fieldShortNullIndex = addColumnDetails(table, "fieldShortNull", RealmFieldType.INTEGER);
-            this.fieldIntegerNotNullIndex = addColumnDetails(table, "fieldIntegerNotNull", RealmFieldType.INTEGER);
-            this.fieldIntegerNullIndex = addColumnDetails(table, "fieldIntegerNull", RealmFieldType.INTEGER);
-            this.fieldLongNotNullIndex = addColumnDetails(table, "fieldLongNotNull", RealmFieldType.INTEGER);
-            this.fieldLongNullIndex = addColumnDetails(table, "fieldLongNull", RealmFieldType.INTEGER);
-            this.fieldFloatNotNullIndex = addColumnDetails(table, "fieldFloatNotNull", RealmFieldType.FLOAT);
-            this.fieldFloatNullIndex = addColumnDetails(table, "fieldFloatNull", RealmFieldType.FLOAT);
-            this.fieldDoubleNotNullIndex = addColumnDetails(table, "fieldDoubleNotNull", RealmFieldType.DOUBLE);
-            this.fieldDoubleNullIndex = addColumnDetails(table, "fieldDoubleNull", RealmFieldType.DOUBLE);
-            this.fieldDateNotNullIndex = addColumnDetails(table, "fieldDateNotNull", RealmFieldType.DATE);
-            this.fieldDateNullIndex = addColumnDetails(table, "fieldDateNull", RealmFieldType.DATE);
-            this.fieldObjectNullIndex = addColumnDetails(table, "fieldObjectNull", RealmFieldType.OBJECT);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("NullTypes");
+            this.fieldStringNotNullIndex = addColumnDetails("fieldStringNotNull", objectSchemaInfo);
+            this.fieldStringNullIndex = addColumnDetails("fieldStringNull", objectSchemaInfo);
+            this.fieldBooleanNotNullIndex = addColumnDetails("fieldBooleanNotNull", objectSchemaInfo);
+            this.fieldBooleanNullIndex = addColumnDetails("fieldBooleanNull", objectSchemaInfo);
+            this.fieldBytesNotNullIndex = addColumnDetails("fieldBytesNotNull", objectSchemaInfo);
+            this.fieldBytesNullIndex = addColumnDetails("fieldBytesNull", objectSchemaInfo);
+            this.fieldByteNotNullIndex = addColumnDetails("fieldByteNotNull", objectSchemaInfo);
+            this.fieldByteNullIndex = addColumnDetails("fieldByteNull", objectSchemaInfo);
+            this.fieldShortNotNullIndex = addColumnDetails("fieldShortNotNull", objectSchemaInfo);
+            this.fieldShortNullIndex = addColumnDetails("fieldShortNull", objectSchemaInfo);
+            this.fieldIntegerNotNullIndex = addColumnDetails("fieldIntegerNotNull", objectSchemaInfo);
+            this.fieldIntegerNullIndex = addColumnDetails("fieldIntegerNull", objectSchemaInfo);
+            this.fieldLongNotNullIndex = addColumnDetails("fieldLongNotNull", objectSchemaInfo);
+            this.fieldLongNullIndex = addColumnDetails("fieldLongNull", objectSchemaInfo);
+            this.fieldFloatNotNullIndex = addColumnDetails("fieldFloatNotNull", objectSchemaInfo);
+            this.fieldFloatNullIndex = addColumnDetails("fieldFloatNull", objectSchemaInfo);
+            this.fieldDoubleNotNullIndex = addColumnDetails("fieldDoubleNotNull", objectSchemaInfo);
+            this.fieldDoubleNullIndex = addColumnDetails("fieldDoubleNull", objectSchemaInfo);
+            this.fieldDateNotNullIndex = addColumnDetails("fieldDateNotNull", objectSchemaInfo);
+            this.fieldDateNullIndex = addColumnDetails("fieldDateNull", objectSchemaInfo);
+            this.fieldObjectNullIndex = addColumnDetails("fieldObjectNull", objectSchemaInfo);
         }
 
         NullTypesColumnInfo(ColumnInfo src, boolean mutable) {
@@ -826,27 +828,27 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("NullTypes");
-        builder.addProperty("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        builder.addProperty("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addLinkedProperty("fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
+        builder.addPersistedProperty("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedLinkProperty("fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
         return builder.build();
     }
 
@@ -854,123 +856,8 @@ public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
         return expectedObjectSchemaInfo;
     }
 
-    public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_NullTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
-        }
-        Table table = sharedRealm.getTable("class_NullTypes");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 21) {
-            if (columnCount < 21) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 21 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 21 but was %1$d", columnCount);
-            } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 21 but was " + columnCount);
-            }
-        }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm, table);
-
-        if (table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-        }
-
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldStringNotNull", RealmFieldType.STRING, "String");
-        if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldStringNull", RealmFieldType.STRING, "String");
-        if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBooleanNotNull", RealmFieldType.BOOLEAN, "Boolean");
-        if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBooleanNull", RealmFieldType.BOOLEAN, "Boolean");
-        if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBytesNotNull", RealmFieldType.BINARY, "byte[]");
-        if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBytesNull", RealmFieldType.BINARY, "byte[]");
-        if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldByteNotNull", RealmFieldType.INTEGER, "Byte");
-        if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldByteNull", RealmFieldType.INTEGER, "Byte");
-        if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldShortNotNull", RealmFieldType.INTEGER, "Short");
-        if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldShortNull", RealmFieldType.INTEGER, "Short");
-        if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldIntegerNotNull", RealmFieldType.INTEGER, "Integer");
-        if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldIntegerNull", RealmFieldType.INTEGER, "Integer");
-        if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldLongNotNull", RealmFieldType.INTEGER, "Long");
-        if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldLongNull", RealmFieldType.INTEGER, "Long");
-        if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldFloatNotNull", RealmFieldType.FLOAT, "Float");
-        if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldFloatNull", RealmFieldType.FLOAT, "Float");
-        if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDoubleNotNull", RealmFieldType.DOUBLE, "Double");
-        if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDoubleNull", RealmFieldType.DOUBLE, "Double");
-        if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDateNotNull", RealmFieldType.DATE, "Date");
-        if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDateNull", RealmFieldType.DATE, "Date");
-        if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
-        if (!sharedRealm.hasTable("class_NullTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
-        }
-        Table table_20 = sharedRealm.getTable("class_NullTypes");
-        if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
-        }
-
-        return columnInfo;
+    public static NullTypesColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new NullTypesColumnInfo(schemaInfo);
     }
 
     public static String getTableName() {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 3c3f0c02b1..a38f5851e4 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -4,6 +4,7 @@
 import android.util.JsonReader;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
@@ -40,11 +41,11 @@
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm, boolean allowExtraColumns) {
+    public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo schemaInfo) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.validateTable(sharedRealm, allowExtraColumns);
+            return io.realm.AllTypesRealmProxy.createColumnInfo(schemaInfo);
         }
         throw getMissingProxyClassException(clazz);
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 0b2e214c2b..9fc39f84e6 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -10,6 +10,7 @@
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.Property;
 import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
@@ -38,10 +39,11 @@
         long nameIndex;
         long ageIndex;
 
-        SimpleColumnInfo(SharedRealm realm, Table table) {
+        SimpleColumnInfo(OsSchemaInfo schemaInfo) {
             super(2);
-            this.nameIndex = addColumnDetails(table, "name", RealmFieldType.STRING);
-            this.ageIndex = addColumnDetails(table, "age", RealmFieldType.INTEGER);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Simple");
+            this.nameIndex = addColumnDetails("name", objectSchemaInfo);
+            this.ageIndex = addColumnDetails("age", objectSchemaInfo);
         }
 
         SimpleColumnInfo(ColumnInfo src, boolean mutable) {
@@ -147,8 +149,8 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Simple");
-        builder.addProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        builder.addProperty("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         return builder.build();
     }
 
@@ -156,43 +158,8 @@ public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
         return expectedObjectSchemaInfo;
     }
 
-    public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_Simple")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
-        }
-        Table table = sharedRealm.getTable("class_Simple");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 2) {
-            if (columnCount < 2) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 2 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 2 but was %1$d", columnCount);
-            } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 2 but was " + columnCount);
-            }
-        }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm, table);
-
-        if (table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-        }
-
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "name", RealmFieldType.STRING, "String");
-        if (!table.isColumnNullable(columnInfo.nameIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
-        }
-        ProxyUtils.verifyField(sharedRealm, columnTypes, "age", RealmFieldType.INTEGER, "int");
-        if (table.isColumnNullable(columnInfo.ageIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
-        }
-
-        return columnInfo;
+    public static SimpleColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new SimpleColumnInfo(schemaInfo);
     }
 
     public static String getTableName() {
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm b/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm
deleted file mode 100644
index 34a6e03968..0000000000
Binary files a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm and /dev/null differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm b/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm
deleted file mode 100644
index 6fe07400b3..0000000000
Binary files a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm and /dev/null differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm b/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm
deleted file mode 100644
index 0cc76c03f2..0000000000
Binary files a/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm and /dev/null differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
deleted file mode 100644
index 906f913009..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import android.support.annotation.NonNull;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.junit.runner.RunWith;
-
-import java.util.Collections;
-import java.util.HashMap;
-
-import io.realm.entities.Cat;
-import io.realm.entities.Dog;
-import io.realm.internal.ColumnIndices;
-import io.realm.internal.ColumnInfo;
-import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.util.Pair;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotSame;
-import static junit.framework.Assert.assertSame;
-import static org.junit.Assert.assertNotEquals;
-
-
-@RunWith(AndroidJUnit4.class)
-public class ColumnIndicesTests {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-    @Rule
-    public final ExpectedException thrown = ExpectedException.none();
-
-    private Realm realm;
-    private RealmProxyMediator mediator;
-
-    @Before
-    public void setUp() {
-        RealmConfiguration config = configFactory.createConfiguration();
-        realm = Realm.getInstance(config);
-        mediator = config.getSchemaMediator();
-    }
-
-    @After
-    public void tearDown() {
-        if (realm != null) {
-            realm.close();
-        }
-    }
-
-    @NonNull
-    private ColumnIndices create(long schemaVersion) {
-        final CatRealmProxy.CatColumnInfo catColumnInfo;
-        final DogRealmProxy.DogColumnInfo dogColumnInfo;
-        catColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
-        dogColumnInfo = (DogRealmProxy.DogColumnInfo) mediator.validateTable(Dog.class, realm.sharedRealm, false);
-        Pair<Class<? extends RealmModel>, String> catDesc = Pair.<Class<? extends RealmModel>, String>create(Cat.class, "Cat");
-        Pair<Class<? extends RealmModel>, String> dogDesc = Pair.<Class<? extends RealmModel>, String>create(Dog.class, "Dog");
-
-        HashMap<Pair<Class<? extends RealmModel>, String>, ColumnInfo> map = new HashMap<>();
-        map.put(catDesc, catColumnInfo);
-        map.put(dogDesc, dogColumnInfo);
-        return new ColumnIndices(schemaVersion, Collections.unmodifiableMap(map));
-    }
-
-    @Test
-    public void copyDeeply() {
-        final long schemaVersion = 100;
-
-        final ColumnIndices columnIndices = create(schemaVersion);
-        final ColumnIndices deepCopy = new ColumnIndices(columnIndices, true);
-        assertNotSame(columnIndices, deepCopy);
-
-        assertEquals(schemaVersion, deepCopy.getSchemaVersion());
-
-        ColumnInfo colInfo = columnIndices.getColumnInfo(Cat.class);
-        ColumnInfo colInfoCopy = deepCopy.getColumnInfo(Cat.class);
-        assertNotSame(colInfo, colInfoCopy);
-        assertEquals(colInfo.getColumnIndex(Cat.FIELD_NAME), colInfoCopy.getColumnIndex(Cat.FIELD_NAME));
-
-        colInfo = columnIndices.getColumnInfo(Dog.class);
-        colInfoCopy = deepCopy.getColumnInfo(Dog.class);
-        assertNotSame(colInfo, colInfoCopy);
-        assertEquals(colInfo.getColumnIndex(Dog.FIELD_AGE), colInfoCopy.getColumnIndex(Dog.FIELD_AGE));
-    }
-
-    @Test
-    public void copyFrom() {
-        final long sourceSchemaVersion = 101;
-        final long targetSchemaVersion = 100;
-
-        final ColumnIndices source = create(sourceSchemaVersion);
-        final ColumnIndices target = create(targetSchemaVersion);
-
-        final CatRealmProxy.CatColumnInfo catColumnInfoInSource = (CatRealmProxy.CatColumnInfo) source.getColumnInfo(Cat.class);
-        final CatRealmProxy.CatColumnInfo catColumnInfoInTarget = (CatRealmProxy.CatColumnInfo) target.getColumnInfo(Cat.class);
-
-        catColumnInfoInSource.nameIndex++;
-
-        // Checks preconditions.
-        assertNotEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
-        assertNotSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
-
-        target.copyFrom(source);
-
-        assertEquals(sourceSchemaVersion, target.getSchemaVersion());
-        assertEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
-        // update, not replace
-        assertSame(catColumnInfoInTarget, target.getColumnInfo(Cat.class));
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
index 6fcebce670..01b6920726 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
@@ -60,9 +60,9 @@ public void tearDown() {
     @Test
     public void copyColumnInfoFrom_checkIndex() {
         CatRealmProxy.CatColumnInfo sourceColumnInfo
-                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
         CatRealmProxy.CatColumnInfo targetColumnInfo
-                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         // Checks precondition.
         assertNotSame(sourceColumnInfo, targetColumnInfo);
@@ -101,7 +101,7 @@ public void copyColumnInfoFrom_checkIndex() {
     @Test
     public void copy_differentInstanceSameValues() {
         final CatRealmProxy.CatColumnInfo columnInfo
-                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         columnInfo.nameIndex = 1;
         columnInfo.ageIndex = 2;
@@ -150,7 +150,7 @@ public void copy_differentInstanceSameValues() {
     @Test
     public void copy_immutableThrows() {
         final CatRealmProxy.CatColumnInfo original
-                = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         CatRealmProxy.CatColumnInfo copy = (CatRealmProxy.CatColumnInfo) original.copy(false);
         try {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index 994c8ddad6..0561dd58ed 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -20,26 +20,27 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllJavaTypes;
-import io.realm.entities.BacklinksMissingFieldSourceModule;
-import io.realm.entities.BacklinksMissingFieldTargetModule;
 import io.realm.entities.BacklinksSource;
 import io.realm.entities.BacklinksTarget;
-import io.realm.entities.BacklinksWrongTypeSourceModule;
-import io.realm.entities.BacklinksWrongTypeTargetModule;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.RealmProxyMediator;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -47,8 +48,11 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 
 
 @RunWith(AndroidJUnit4.class)
@@ -544,131 +548,121 @@ public void migration_backlinkedFieldInUse() {
         } catch (IOException e) {
             fail("Failed copying realm");
         } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("Field count is"));
+            assertThat(expected.getMessage(),
+                    CoreMatchers.allOf(
+                            CoreMatchers.containsString("Property 'BacklinksSource.name' has been added"),
+                            CoreMatchers.containsString("Property 'BacklinksTarget.parents' has been removed")));
         } finally {
             Realm.deleteRealm(realmConfig);
         }
     }
 
     /**
-     * Table validation should fail if the backlinked column points to a non-existent class.
-     * The realm `backlinks-missingSourceClass.realm` contains two tables very like those
-     * defined by `BacklinksSource` and `BacklinksTarget`.  In it, though, the source class
-     * is named XXXBacklinksSource, like so:
-     * <pre>
-     * {@code
-     * @LinkingObjects("child")
-     *     private final RealmResults<XXXBacklinksSource> parents = null;
-     * }
-     * </pre>
-     * If both classes were present in the configuration, the test would fail because there
-     * is no class named BacklinksSource in the Realm.  Since the configuration contains only the
-     * single class `BacklinksTarget`, though, basic validation should pass. Backlink validation,
-     * however, should fail, seeking the `BacklinksSource` table.
+     * Schema validation should fail if the backlinked column points to a non-existent class.
+     * Since the configuration contains only the single class `BacklinksTarget`, basic validation passes.
+     * The computed property validation, however, should fail, seeking the `BacklinksSource` table.
      */
-    @Ignore("Need to rebuild the test library")
     @Test
     public void migration_backlinkedSourceClassDoesntExist() throws IOException {
         final String realmName = "backlinks-missingSourceClass.realm";
-
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .name(realmName)
                 .schema(BacklinksTarget.class)
                 .build();
 
         try {
-            configFactory.copyRealmFromAssets(context, realmName, realmName);
-
             Realm localRealm = Realm.getInstance(realmConfig);
             localRealm.close();
-            fail("A migration should have been required");
-        } catch (IOException e) {
-            fail("Failed copying realm");
-        } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("Cannot find source class"));
-        } finally {
-            Realm.deleteRealm(realmConfig);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "Property 'BacklinksTarget.parents' of type 'linking objects' has unknown object type 'BacklinksSource'"));
         }
     }
 
     /**
-     * Table validation should fail if the backlinked column points to a non-existent field in the source class.
-     * This test is quite a chore to construct!
-     * The realm `backlinks-missingSourceField.realm` was constructed with classes `BacklinksMissingFieldTarget`
-     * and `BacklinksMissingFieldSource`.  They are identical in their definitions to `BacklinkSource` and
-     * `BacklinkTarget` except for their names.  The library `backlinks-missing-field-source.jar` contains
-     * the class `BacklinksMissingFieldSource` and all of its annotation generated code.  The library
-     * `backlinks-missing-field-target.jar` however, contains a version of `BacklinksMissingFieldTarget` that
-     * was compiled with its backlink field referring to a field in `BacklinksMissingFieldSource`, called
-     * `xxxchild`.  Clearly, in order to compile successfully, the definition of `BacklinksMissingFieldSource`
-     * had to be changed accordingly.  The modified version, however, is *NOT* the version that is in
-     * `backlinks-missing-field-source.jar`!
-     * So, now, the proxy in `backlinks-missing-field-source.jar` will correctly validate the its table
-     * (it generated it!). Similarly, the proxy in `backlinks-missing-field-target.jar` will successfully
-     * validate its table.  If we have been living clean lives, though, the validator for
-     * `BacklinksMissingFieldTarget` should notice that there is no field named `BacklinksMissingFieldSource.xxxchild`.
+     * Schema validation should fail if the backlinked column points to a non-existent field in the source class.
      */
-    @Ignore("Need to rebuild the test library")
     @Test
-    public void migration_backlinkedSourceFieldDoesntExist() {
+    public void migration_backlinkedSourceFieldDoesntExist() throws ClassNotFoundException {
         final String realmName = "backlinks-missingSourceField.realm";
-
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .name(realmName)
-                .modules(new BacklinksMissingFieldSourceModule(), new BacklinksMissingFieldTargetModule())
+                .schema(BacklinksTarget.class, BacklinksSource.class)
                 .build();
 
-        try {
-            configFactory.copyRealmFromAssets(context, realmName, realmName);
+        // Mock the schema info so the only difference compared with the original schema is that the LinkingObject field
+        // points to BacklinksSource.childNotExist.
+        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget")
+                .addPersistedProperty("id", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED)
+                .addComputedLinkProperty("parents", "BacklinksSource", "childNotExist" /*"child" is the original value*/)
+                .build();
+        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource")
+                .addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED)
+                .addPersistedLinkProperty("child", RealmFieldType.OBJECT, "BacklinksTarget")
+                .build();
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        infoMap.put(BacklinksTarget.class, targetSchemaInfo);
+        infoMap.put(BacklinksSource.class, sourceSchemaInfo);
 
-            Realm localRealm = Realm.getInstance(realmConfig);
+        RealmProxyMediator mediator = spy(realmConfig.getSchemaMediator());
+        when(mediator.getExpectedObjectSchemaInfoMap()).thenReturn(infoMap);
+        RealmConfiguration spyConfig = spy(realmConfig);
+        when(spyConfig.getSchemaMediator()).thenReturn(mediator);
+
+        try {
+            Realm localRealm = Realm.getInstance(spyConfig);
             localRealm.close();
-            fail("A migration should have been required");
-        } catch (IOException e) {
-            fail("Failed copying realm");
-        } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("Cannot find source field"));
-        } finally {
-            Realm.deleteRealm(realmConfig);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "Property 'BacklinksSource.childNotExist' declared as origin of linking objects property 'BacklinksTarget.parents' does not exist"
+            ));
         }
     }
 
     /**
      * Table validation should fail if the backlinked column points to a field of the wrong type.
-     * This test is built in almost exactly the way as was `migration_backlinkedSourceFieldDoesntExist`
-     * The realm `backlinks-sourceFieldWrongType.realm` was constructed with classes `BacklinksWrongTypeTarget`
-     * and `BacklinksWrongTypeSource`.  Again, these two classes are nearly identical in their counterparts
-     * `BacklinkSource` and `BacklinkTarget` except for their names.  Unlike `BacklinkSource`,
-     * `BacklinksWrongTypeSource` has two fields, `child` and `childId`. The first is exactly as it is in
-     * `BacklinkSource`, the second is of type `Integer`.  To construct `backlinks-wrong-type-target.jar`
-     * I reversed the names of the two fields in `BacklinkSource`, and made then adjusted `parents` in
-     * `BacklinkTarget` to point to `childId`.
-     * All of the proxies in in the two jars should correctly validate their tables.  The backlink validation
-     * for `BacklinksWrongTypeTarget` should notice, though, that its `parents` field points to an object
-     * of the wrong type, `Integer`, instead of `BacklinksWrongTypeSource`.
      */
-    @Ignore("Need to rebuild the test library")
     @Test
     public void migration_backlinkedSourceFieldWrongType() {
         final String realmName = "backlinks-sourceFieldWrongType.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .name(realmName)
-                .modules(new BacklinksWrongTypeSourceModule(), new BacklinksWrongTypeTargetModule())
+                .schema(BacklinksTarget.class, BacklinksSource.class)
                 .build();
 
-        try {
-            configFactory.copyRealmFromAssets(context, realmName, realmName);
+        // Mock the schema info so the only difference compared with the original schema is that BacklinksSource.child
+        // type is changed to BacklinksSource from BacklinksTarget.
+        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget")
+                .addPersistedProperty("id", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED)
+                .addComputedLinkProperty("parents", "BacklinksSource", "child")
+                .build();
+        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource")
+                .addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED)
+                .addPersistedLinkProperty("child", RealmFieldType.OBJECT,
+                        "BacklinksSource"/*"BacklinksTarget" is the original value*/)
+                .build();
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        infoMap.put(BacklinksTarget.class, targetSchemaInfo);
+        infoMap.put(BacklinksSource.class, sourceSchemaInfo);
 
-            Realm localRealm = Realm.getInstance(realmConfig);
+        RealmProxyMediator mediator = spy(realmConfig.getSchemaMediator());
+        when(mediator.getExpectedObjectSchemaInfoMap()).thenReturn(infoMap);
+        RealmConfiguration spyConfig = spy(realmConfig);
+        when(spyConfig.getSchemaMediator()).thenReturn(mediator);
+
+        try {
+            Realm localRealm = Realm.getInstance(spyConfig);
             localRealm.close();
-            fail("A migration should have been required");
-        } catch (IOException e) {
-            fail("Failed copying realm");
-        } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("is not a RealmObject type"));
-        } finally {
-            Realm.deleteRealm(realmConfig);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "Property 'BacklinksSource.child' declared as origin of linking objects property 'BacklinksTarget.parents' links to type 'BacklinksSource'"
+            ));
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 92589caebb..b6a6955cfe 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -22,6 +22,7 @@
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
+import org.mockito.Mockito;
 
 import android.content.Context;
 import android.support.test.InstrumentationRegistry;
@@ -30,16 +31,13 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.lang.reflect.Field;
 import java.util.Set;
 
 import io.realm.entities.AllTypes;
-import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnimalModule;
 import io.realm.entities.AssetFileModule;
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
-import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
@@ -394,17 +392,13 @@ public void upgradeVersionWithNoMigration() {
         assertEquals(0, realm.getVersion());
         realm.close();
 
-        // Version upgrades should always require a migration.
-        try {
-            realm = Realm.getInstance(new RealmConfiguration.Builder(context)
-                    .directory(configFactory.getRoot())
-                    .schemaVersion(42)
-                    .build());
-            fail();
-        } catch (RealmMigrationNeededException expected) {
-            // And it should come with a cause.
-            assertEquals("Realm on disk need to migrate from v0 to v42", expected.getMessage());
-        }
+        // Version upgrades only without any actual schema changes will just succeed, and the schema version will be
+        // set to the new one.
+        realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schemaVersion(42)
+                .build());
+        assertEquals(42, realm.getVersion());
     }
 
     @Test
@@ -838,7 +832,7 @@ public void initialDataTransactionExecutionCount() {
 
         realm = Realm.getInstance(configuration);
         realm.close();
-        verify(transaction, times(1)).execute(realm);
+        verify(transaction, times(1)).execute(Mockito.any(Realm.class));
 
         realm = Realm.getInstance(configuration);
         realm.close();
@@ -865,6 +859,41 @@ public void initialDataTransactionAssetFile() throws IOException {
         verify(transaction, never()).execute(realm);
     }
 
+    @Test
+    public void initialDataTransactionThrows() {
+        final RuntimeException exception = new RuntimeException();
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(final Realm realm) {
+                        throw exception;
+                    }
+                }).build();
+
+        assertFalse(new File(configuration.getPath()).exists());
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(configuration);
+            fail();
+        } catch (RuntimeException expected) {
+            assertSame(exception, expected);
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        try {
+            // The schema should not be initialized.
+            assertNull(dynamicRealm.getSchema().get(StringOnly.CLASS_NAME));
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
     @Test
     public void assetFileNullAndEmptyFileName() {
         try {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index e5e9537463..923581bc45 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -70,6 +70,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -235,9 +236,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary key not defined for field 'id' in existing Realm file. @PrimaryKey was added.")) {
-                fail(e.toString());
-            }
+            assertThat(e.getMessage(), CoreMatchers.containsString(
+                    "Primary Key for class 'AnnotationTypes' has been added"));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -273,9 +273,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary Key defined for field chars was removed.")) {
-                fail(e.toString());
-            }
+            assertThat(e.getMessage(),
+                    CoreMatchers.containsString("Primary Key for class 'StringOnly' has been removed."));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -312,9 +311,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary Key annotation definition was changed, from field id to field name")) {
-                fail(e.toString());
-            }
+            assertThat(e.getMessage(), CoreMatchers.containsString(
+                    "Primary Key for class 'PrimaryKeyAsString' has changed from 'id' to 'name'."));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -408,10 +406,17 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .schema(MigrationClassRenamed.class)
                 .migration(migration)
                 .build();
+        // Trigger migration
         Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
 
-        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
-        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+        try {
+            assertTrue(dynamicRealm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+            assertFalse(dynamicRealm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        } finally {
+            dynamicRealm.close();
+        }
     }
 
     // Test to show that renaming a class does not effect the primary key.
@@ -472,9 +477,16 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .migration(migration)
                 .build();
         Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
 
-        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
-        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        // We cannot access 'MigrationPrimaryKey' from a typed Realm since it is not part of the pre-defined schema.
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+        try {
+            assertTrue(dynamicRealm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+            assertFalse(dynamicRealm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        } finally {
+            dynamicRealm.close();
+        }
     }
 
     @Test
@@ -831,7 +843,7 @@ public void migrationException_realmListChanged() throws IOException {
             fail();
         } catch (RealmMigrationNeededException ignored) {
             assertThat(ignored.getMessage(),
-                    CoreMatchers.containsString("Invalid RealmList type for field 'cats': 'class_Dog' expected "));
+                    CoreMatchers.containsString("Property 'CatOwner.cats' has been changed from 'array<Dog>' to 'array<Cat>'"));
         }
     }
 
@@ -859,8 +871,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm.close();
             fail();
         } catch (RealmMigrationNeededException e) {
-            assertEquals("Field 'chars' is required. Either set @Required to field 'chars' or migrate using RealmObjectSchema.setNullable().",
-                    e.getMessage());
+            assertThat(e.getMessage(), CoreMatchers.containsString(
+                    "Property 'StringOnly.chars' has been made optional"));
         }
     }
 
@@ -977,6 +989,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             @SuppressWarnings("unchecked")
             RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                     .schemaVersion(1)
+                    .name(field)
                     .schema(NullTypes.class)
                     .migration(migration)
                     .build();
@@ -990,10 +1003,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm = Realm.getInstance(realmConfig);
                 fail("Failed on " + field);
             } catch (RealmMigrationNeededException e) {
-                assertEquals("Field '" + field + "' does support null values in the existing Realm file." +
-                        " Remove @Required or @PrimaryKey from field '" + field + "' " +
-                        "or migrate using RealmObjectSchema.setNullable().",
-                        e.getMessage());
+                assertThat(e.getMessage(), CoreMatchers.containsString(
+                        String.format(Locale.US, "Property 'NullTypes.%s' has been made required", field)));
             }
         }
     }
@@ -1045,6 +1056,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             @SuppressWarnings("unchecked")
             RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                     .schemaVersion(1)
+                    .name(field)
                     .schema(NullTypes.class)
                     .migration(migration)
                     .build();
@@ -1058,16 +1070,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm = Realm.getInstance(realmConfig);
                 fail("Failed on " + field);
             } catch (RealmMigrationNeededException e) {
-                if (field.equals(NullTypes.FIELD_STRING_NULL) || field.equals(NullTypes.FIELD_BYTES_NULL) ||
-                        field.equals(NullTypes.FIELD_DATE_NULL)) {
-                    assertEquals("Field '" + field + "' is required. Either set @Required to field '" +
-                            field + "' " +
-                            "or migrate using RealmObjectSchema.setNullable().", e.getMessage());
-                } else {
-                    assertEquals("Field '" + field + "' does not support null values in the existing Realm file."
-                                    + " Either set @Required, use the primitive type for field '"
-                                    + field + "' or migrate using RealmObjectSchema.setNullable().",  e.getMessage());
-                }
+                assertThat(e.getMessage(), CoreMatchers.containsString(
+                        String.format(Locale.US, "Property 'NullTypes.%s' has been made optional", field)));
             }
         }
     }
@@ -1133,13 +1137,12 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm.close();
                 fail();
             } catch (RealmMigrationNeededException expected) {
+                String pkFieldName = "id";
                 if (clazz == PrimaryKeyAsString.class) {
-                    assertEquals("@PrimaryKey field 'name' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.",
-                            expected.getMessage());
-                } else {
-                    assertEquals("@PrimaryKey field 'id' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.",
-                            expected.getMessage());
+                    pkFieldName = "name";
                 }
+                assertThat(expected.getMessage(), CoreMatchers.containsString(String.format(Locale.US,
+                        "Property '%s.%s' has been made optional", clazz.getSimpleName(), pkFieldName)));
             }
         }
     }
@@ -1159,7 +1162,7 @@ public void migrating_nullableField_toward_notNullable_PrimaryKeyThrows() throws
                 fail();
             } catch (RealmMigrationNeededException expected) {
                 assertThat(expected.getMessage(), CoreMatchers.containsString(
-                        "Field 'id' does support null values in the existing Realm file."));
+                        String.format("Property '%s.%s' has been made required", clazz.getSimpleName(), "id")));
             }
         }
     }
@@ -1298,6 +1301,57 @@ public void migrationRequired_throwsOriginalException() {
         }
     }
 
+    private void createEmptyRealmVersion0(RealmConfiguration configuration)  {
+        assertFalse(new File(configuration.getPath()).exists());
+
+        DynamicRealm realm = DynamicRealm.getInstance(configuration);
+        realm.beginTransaction();
+        realm.setVersion(0);
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    @Test
+    public void migrationRequired_throwsExceptionInTheMigrationBlock() {
+        final RuntimeException exception = new RuntimeException("TEST");
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // The transaction should be canceled and this model should not be created.
+                RealmObjectSchema objectSchema = realm.getSchema().create(StringOnly.CLASS_NAME);
+                objectSchema.addField(StringOnly.FIELD_CHARS, String.class);
+                throw exception;
+            }
+        };
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .migration(migration)
+                .schemaVersion(1)
+                .schema(StringOnly.class)
+                .build();
+        createEmptyRealmVersion0(config);
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RuntimeException expected) {
+            assertSame(exception, expected);
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        try {
+            assertEquals(0, dynamicRealm.getVersion());
+            assertNull(dynamicRealm.getSchema().get(StringOnly.CLASS_NAME));
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
     // TODO Add unit tests for default nullability
     // TODO Add unit tests for default Indexing for Primary keys
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 076e0ff0af..d72618711b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -88,14 +88,16 @@ public void setUp() {
             realm = Realm.getInstance(realmConfig);
             realmSchema = realm.getSchema();
             DOG_SCHEMA = realmSchema.get("Dog");
-            schema = realmSchema.get("NewClass");
+            schema = realmSchema.get("Dog");
         }
         realm.beginTransaction();
     }
 
     @After
     public void tearDown() {
-        realm.cancelTransaction();
+        if (realm.isInTransaction()) {
+            realm.cancelTransaction();
+        }
         realm.close();
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
index b3acf5f0e8..7646e91645 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -58,9 +58,9 @@ public void tearDown() {
     }
 
     @Test
-    public void validateTable_noDuplicateIndexInIndexFields() {
+    public void createColumnInfo_noDuplicateIndexInIndexFields() {
         RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        CatRealmProxy.CatColumnInfo columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        CatRealmProxy.CatColumnInfo columnInfo = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
@@ -86,10 +86,10 @@ public void validateTable_noDuplicateIndexInIndexFields() {
     }
 
     @Test
-    public void validateTable_noDuplicateIndexInIndicesMap() {
+    public void createColumnInfo_noDuplicateIndexInIndicesMap() {
         RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
         CatRealmProxy.CatColumnInfo columnInfo;
-        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 9b8dced18a..ec12cb382b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -26,13 +26,13 @@
 
 import junit.framework.AssertionFailedError;
 
+import org.hamcrest.CoreMatchers;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.After;
 import org.junit.Assume;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -113,7 +113,6 @@
 import io.realm.util.ExceptionHolder;
 import io.realm.util.RealmThread;
 
-import static io.realm.TestHelper.awaitOrFail;
 import static io.realm.TestHelper.testNoObjectFound;
 import static io.realm.TestHelper.testOneObjectFound;
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
@@ -123,6 +122,8 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
@@ -1167,6 +1168,31 @@ public boolean shouldCompact(long totalBytes, long usedBytes) {
         assertEquals(results.first, results.second);
     }
 
+    @Test
+    public void compactOnLaunch_throwsInTheCallback() {
+        final RuntimeException exception = new RuntimeException();
+        final RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .name("compactThrowsTest")
+                .compactOnLaunch(new CompactOnLaunchCallback() {
+                    @Override
+                    public boolean shouldCompact(long totalBytes, long usedBytes) {
+                        throw exception;
+                    }
+                })
+                .build();
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(realmConfig);
+            fail();
+        } catch (RuntimeException expected) {
+            assertSame(exception, expected);
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
     @Test
     public void defaultCompactOnLaunch() throws IOException {
         Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 30000);
@@ -3915,49 +3941,51 @@ public void run(Realm realm) {
         assertFalse(bgRealmChangeResult.get());
     }
 
+    // Check if the column indices cache is refreshed if the index of a defined column is changed by another Realm
+    // instance.
     @Test
-    public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
-        final AtomicLong nameIndexNew = new AtomicLong(-1L);
+    public void nonAdditiveSchemaChangesWhenTypedRealmExists() throws InterruptedException {
+        final String TEST_CHARS = "TEST_CHARS";
+        final RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schema(StringOnly.class)
+                .name("schemaChangeTest")
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        StringOnlyRealmProxy.StringOnlyColumnInfo columnInfo
+                = (StringOnlyRealmProxy.StringOnlyColumnInfo) realm.getSchema().getColumnInfo(StringOnly.class);
+        assertEquals(0, columnInfo.charsIndex);
 
-        // get the pre-update index for the "name" column.
-        CatRealmProxy.CatColumnInfo catColumnInfo
-                = (CatRealmProxy.CatColumnInfo) realm.getSchema().getColumnInfo(Cat.class);
-        final long nameIndex = catColumnInfo.nameIndex;
+        realm.beginTransaction();
+        StringOnly stringOnly = realm.createObject(StringOnly.class);
+        stringOnly.setChars(TEST_CHARS);
+        realm.commitTransaction();
 
-        // Change the index of the column "name".
-        realm.executeTransaction(new Realm.Transaction() {
+        Thread thread = new Thread(new Runnable() {
             @Override
-            public void execute(Realm realm) {
-                final Table catTable = realm.getSchema().getTable(Cat.CLASS_NAME);
-                final long nameIndex = catTable.getColumnIndex(Cat.FIELD_NAME);
-                catTable.removeColumn(nameIndex);
-                final long newIndex = catTable.addColumn(RealmFieldType.STRING, Cat.FIELD_NAME, true);
-                realm.setVersion(realm.getConfiguration().getSchemaVersion() + 1);
-                nameIndexNew.set(newIndex);
+            public void run() {
+                // Here we try to change the column index of FIELD_CHARS from 0 to 1.
+                DynamicRealm realm = DynamicRealm.getInstance(realmConfig);
+                realm.beginTransaction();
+                RealmObjectSchema stringOnlySchema = realm.getSchema().get(StringOnly.CLASS_NAME);
+                assertEquals(0, stringOnlySchema.getColumnIndex(StringOnly.FIELD_CHARS));
+                Table table = stringOnlySchema.getTable();
+                // Please notice that we cannot do it by removing/adding a column since it is not allowed by Object
+                // Store. Do it by using the internal API insertColumn.
+                table.insertColumn(0, RealmFieldType.INTEGER, "NewColumn");
+                assertEquals(1, stringOnlySchema.getColumnIndex(StringOnly.FIELD_CHARS));
+                realm.commitTransaction();
+                realm.close();
             }
         });
+        thread.start();
+        thread.join();
+        realm.refresh();
 
-        // We need to update index cache if the schema version was changed in the same thread.
-        realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
-
-        // Verify that the index has changed.
-        assertNotEquals(nameIndex, nameIndexNew);
-
-        // Verify that the index in the ColumnInfo has been updated.
-        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.getSchema().getColumnInfo(Cat.class);
-        assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
-        assertEquals(nameIndexNew.get(), (long) catColumnInfo.getColumnIndex(Cat.FIELD_NAME));
-
-        // Checks by actual get and set.
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                final Cat cat = realm.createObject(Cat.class);
-                cat.setName("pochi");
-            }
-        });
-        //noinspection ConstantConditions
-        assertEquals("pochi", realm.where(Cat.class).findFirst().getName());
+        // The columnInfo object never changes, only the indexes it references will.
+        assertSame(columnInfo, realm.getSchema().getColumnInfo(StringOnly.class));
+        assertEquals(TEST_CHARS, stringOnly.getChars());
+        assertEquals(1, columnInfo.charsIndex);
+        realm.close();
     }
 
     @Test
@@ -4236,7 +4264,8 @@ public void beginTransaction_readOnlyThrows() {
             realm.beginTransaction();
             fail();
         } catch (IllegalStateException e) {
-            assertTrue(e.getMessage().startsWith("Write transactions cannot be used "));
+            assertThat(e.getMessage(),
+                    CoreMatchers.containsString("Can't perform transactions on read-only Realms."));
         } finally {
             realm.close();
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/AndroidCapabilitiesTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/AndroidCapabilitiesTest.java
new file mode 100644
index 0000000000..b3ca055a6d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/AndroidCapabilitiesTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class AndroidCapabilitiesTest {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Test
+    @RunTestInLooperThread()
+    public void emulateMainThread_false() {
+        assertFalse(new AndroidCapabilities().isMainThread());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void emulateMainThread_true() {
+        assertTrue(new AndroidCapabilities().isMainThread());
+        looperThread.testComplete();
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index 0457739f03..74bd40c9ee 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -74,7 +74,9 @@ public void tearDown() {
     }
 
     private SharedRealm getSharedRealm() {
-        return SharedRealm.getInstance(config, null, true);
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
+                .autoUpdateNotification(true);
+        return SharedRealm.getInstance(configBuilder);
     }
 
     private void populateData() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
index aea4d99dce..44ac4bcdb6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -72,7 +72,9 @@ public void tearDown() {
     }
 
     private SharedRealm getSharedRealm(RealmConfiguration config) {
-        return SharedRealm.getInstance(config, null, true);
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
+                .autoUpdateNotification(true);
+        return SharedRealm.getInstance(configBuilder);
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index 67a35b5b00..42ba2a3110 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -25,13 +25,11 @@
 import org.junit.runner.RunWith;
 
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
 
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmError;
 import io.realm.rule.TestRealmConfigurationFactory;
 
-import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
@@ -166,79 +164,49 @@ public void renameTable_tableNotExist() {
         sharedRealm.cancelTransaction();
     }
 
+
+    private void changeSchemaByAnotherRealm() {
+        SharedRealm sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        sharedRealm.createTable("NewTable");
+        sharedRealm.commitTransaction();
+        sharedRealm.close();
+    }
+
     @Test
-    public void beginTransaction_SchemaVersionListener() {
+    public void registerSchemaChangedCallback_beginTransaction() {
         final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
 
-        sharedRealm.close();
-        sharedRealm = SharedRealm.getInstance(config, new SharedRealm.SchemaVersionListener() {
+        assertFalse(sharedRealm.hasTable("NewTable"));
+
+        sharedRealm.registerSchemaChangedCallback(new SharedRealm.SchemaChangedCallback() {
             @Override
-            public void onSchemaVersionChanged(long currentVersion) {
+            public void onSchemaChanged() {
+                assertTrue(sharedRealm.hasTable("NewTable"));
                 listenerCalled.set(true);
-                schemaVersionFromListener.set(currentVersion);
             }
-        }, true);
-
-        final long before = sharedRealm.getSchemaVersion();
-
-        sharedRealm.beginTransaction();
-        try {
-            // Listener is not called if there was no schema change.
-            assertFalse(listenerCalled.get());
-
-            // Changes the schema version.
-            sharedRealm.setSchemaVersion(before + 1);
-        } finally {
-            sharedRealm.commitTransaction();
-        }
-
-        // Listener is not yet called.
-        assertFalse(listenerCalled.get());
-
+        });
+        changeSchemaByAnotherRealm();
         sharedRealm.beginTransaction();
-        try {
-            assertTrue(listenerCalled.get());
-            assertEquals(before + 1, schemaVersionFromListener.get());
-        } finally {
-            sharedRealm.cancelTransaction();
-        }
+        assertTrue(listenerCalled.get());
     }
 
     @Test
-    public void refresh_SchemaVersionListener() {
+    public void registerSchemaChangedCallback_refresh() {
         final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
 
-        sharedRealm.close();
-        sharedRealm = SharedRealm.getInstance(config, new SharedRealm.SchemaVersionListener() {
+        assertFalse(sharedRealm.hasTable("NewTable"));
+
+        sharedRealm.registerSchemaChangedCallback(new SharedRealm.SchemaChangedCallback() {
             @Override
-            public void onSchemaVersionChanged(long currentVersion) {
+            public void onSchemaChanged() {
+                assertTrue(sharedRealm.hasTable("NewTable"));
                 listenerCalled.set(true);
-                schemaVersionFromListener.set(currentVersion);
             }
-        }, true);
-
-        final long before = sharedRealm.getSchemaVersion();
-
-        sharedRealm.refresh();
-        // Listener is not called if there was no schema change.
-        assertFalse(listenerCalled.get());
-
-        sharedRealm.beginTransaction();
-        try {
-            // Changes the schema version.
-            sharedRealm.setSchemaVersion(before + 1);
-        } finally {
-            sharedRealm.commitTransaction();
-        }
-
-        // Listener is not yet called.
-        assertFalse(listenerCalled.get());
-
+        });
+        changeSchemaByAnotherRealm();
         sharedRealm.refresh();
         assertTrue(listenerCalled.get());
-        assertEquals(before + 1, schemaVersionFromListener.get());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index e5b6d65565..c5325a0d42 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -40,6 +40,7 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.TestHelper;
+import io.realm.internal.android.AndroidCapabilities;
 
 
 /**
@@ -281,7 +282,7 @@ protected void after() {
         // Wait for all async tasks to have completed to ensure a successful deleteRealm call.
         // If it times out, it will throw.
         TestHelper.waitRealmThreadExecutorFinish();
-
+        AndroidCapabilities.EMULATE_MAIN_THREAD = false;
         super.after();
 
         // probably belt *and* suspenders...
@@ -376,6 +377,7 @@ public void evaluate() throws Throwable {
                 runnableBefore.newInstance().run(getConfiguration());
             }
 
+            AndroidCapabilities.EMULATE_MAIN_THREAD = annotation.emulateMainThread();
             runTest(annotation.threadName());
         }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
index c24c085983..6413757f10 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
@@ -33,4 +33,5 @@
 public @interface RunTestInLooperThread {
         String threadName() default "RunTestInLooperThread";
         Class<?extends RunInLooperThread.RunnableBefore> before() default RunInLooperThread.RunnableBefore.class;
+        boolean emulateMainThread() default false;
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index c976698502..78caa6cf8c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -160,20 +160,15 @@ public void sameSchemaVersion_doNotRebuildIndexes() {
         dynamicRealm.commitTransaction();
         dynamicRealm.close();
 
+        Realm realm = Realm.getInstance(config); // Opening at same schema version (42) will not rebuild indexes
+
+        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
         try {
-            Realm realm = Realm.getInstance(config); // Opening at same schema version (42) will not rebuild indexes
-            fail();
-        } catch (RealmMigrationNeededException ignored) {
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
+        } finally {
+            realm.close();
         }
-
-// FIXME: This is the intended behaviour
-//        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
-//        try {
-//            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
-//            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
-//        } finally {
-//            realm.close();
-//        }
     }
 
     // Check that indexes are being added if the schema version is different
@@ -197,20 +192,15 @@ public void differentSchemaVersions_rebuildIndexes() {
         dynamicRealm.commitTransaction();
         dynamicRealm.close();
 
+        Realm realm = Realm.getInstance(config); // Opening at different schema version (42) should rebuild indexes
+        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
         try {
-            Realm realm = Realm.getInstance(config); // Opening at different schema version (42) should rebuild indexes
-            fail();
-        } catch (RealmMigrationNeededException ignored) {
+            // FIXME: Object Store doesn't add index to it. Is it expected?
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
+        } finally {
+            realm.close();
         }
-
-// FIXME: This is the intended behaviour
-//        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
-//        try {
-//            assertTrue(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
-//            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
-//        } finally {
-//            realm.close();
-//        }
     }
 
     // Check that indexes are being added if other fields are being added as well
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index b2bd687dd8..9636fb6a29 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -43,7 +43,7 @@ set(classes_LIST
     io.realm.log.LogLevel io.realm.log.RealmLog io.realm.internal.Property io.realm.internal.OsSchemaInfo
     io.realm.internal.OsObjectSchemaInfo io.realm.internal.Collection
     io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
-    io.realm.internal.OsObject
+    io.realm.internal.OsObject io.realm.internal.OsRealmConfig
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
index 52f1efd343..a07c5415f4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
@@ -14,14 +14,18 @@
  * limitations under the License.
  */
 
-#include <jni.h>
 #include "io_realm_internal_OsObjectSchemaInfo.h"
 
-#include <object-store/src/object_schema.hpp>
-#include <object-store/src/property.hpp>
+#include <object_schema.hpp>
+#include <property.hpp>
 
+#include "jni_util/java_exception_thrower.hpp"
+#include "java_exception_def.hpp"
 #include "util.hpp"
+
 using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::_impl;
 
 static void finalize_object_schema(jlong ptr)
 {
@@ -30,11 +34,11 @@ static void finalize_object_schema(jlong ptr)
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
-                                                                                        jstring className_)
+                                                                                                jstring j_name_str)
 {
     TR_ENTER()
     try {
-        JStringAccessor name(env, className_);
+        JStringAccessor name(env, j_name_str);
         ObjectSchema* object_schema = new ObjectSchema();
         object_schema->name = name;
         return reinterpret_cast<jlong>(object_schema);
@@ -50,22 +54,30 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetFinal
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
-                                                                         jlong property_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeAddProperty(JNIEnv* env, jclass,
+                                                                                   jlong native_ptr,
+                                                                                   jlong property_ptr,
+                                                                                   jboolean is_computed)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
         Property* property = reinterpret_cast<Property*>(property_ptr);
-        object_schema->persisted_properties.push_back(*property);
-        if (property->is_primary) {
-            object_schema->primary_key = property->name;
+        if (is_computed) {
+            object_schema->computed_properties.push_back(*property);
+        }
+        else {
+            object_schema->persisted_properties.push_back(*property);
+            if (property->is_primary) {
+                object_schema->primary_key = property->name;
+            }
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetClassName(JNIEnv* env, jclass,
+                                                                                       jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     try {
@@ -77,3 +89,23 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetCla
 
     return nullptr;
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetProperty(JNIEnv* env, jclass,
+                                                                                    jlong native_ptr,
+                                                                                    jstring j_property_name)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        JStringAccessor property_name_accessor(env, j_property_name);
+        StringData property_name(property_name_accessor);
+        auto* property = object_schema.property_for_name(property_name);
+        if (property) {
+            return reinterpret_cast<jlong>(new Property(*property));
+        }
+        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                             format("Property '%1' cannot be found.", property_name.data()));
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
new file mode 100644
index 0000000000..e55980ca6e
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -0,0 +1,330 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsRealmConfig.h"
+
+#include <shared_realm.hpp>
+#if REALM_ENABLE_SYNC
+#include <sync/sync_config.hpp>
+#include <sync/sync_manager.hpp>
+#include <sync/sync_session.hpp>
+#endif
+
+#include "util.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_global_ref.hpp"
+#include "jni_util/jni_utils.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+
+static_assert(SchemaMode::Automatic ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_AUTOMATIC),
+              "");
+static_assert(SchemaMode::Immutable==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_IMMUTABLE),
+              "");
+static_assert(SchemaMode::ReadOnlyAlternative ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_READONLY),
+              "");
+static_assert(SchemaMode::ResetFile ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_RESET_FILE),
+              "");
+static_assert(SchemaMode::Additive ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_ADDITIVE),
+              "");
+static_assert(SchemaMode::Manual == static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_MANUAL),
+              "");
+
+static void finalize_realm_config(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete reinterpret_cast<Realm::Config*>(ptr);
+}
+
+static JavaClass& get_shared_realm_class(JNIEnv* env)
+{
+    static JavaClass shared_realm_class(env, "io/realm/internal/SharedRealm");
+    return shared_realm_class;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsRealmConfig_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_realm_config);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreate(JNIEnv* env, jclass, jstring j_realm_path,
+                                                                          jboolean enable_cache,
+                                                                          jboolean enable_format_upgrade)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor realm_path(env, j_realm_path);
+        auto* config_ptr = new Realm::Config();
+        config_ptr->path = realm_path;
+        config_ptr->cache = enable_cache;
+        config_ptr->disable_format_upgrade = !enable_format_upgrade;
+        return reinterpret_cast<jlong>(config_ptr);
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetEncryptionKey(JNIEnv* env, jclass,
+                                                                                   jlong native_ptr,
+                                                                                   jbyteArray j_key_array)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        JniByteArray key_array(env, j_key_array);
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+        // Encryption key should be set before creating sync_config.
+        REALM_ASSERT(!config.sync_config);
+        config.encryption_key = key_array;
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInMemory(JNIEnv*, jclass, jlong native_ptr,
+                                                                              jboolean in_mem)
+{
+    TR_ENTER_PTR(native_ptr)
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    config.in_memory = in_mem; // no throw
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSchemaConfig(JNIEnv* env, jobject j_config,
+                                                                                  jlong native_ptr, jbyte schema_mode,
+                                                                                  jlong schema_version,
+                                                                                  jlong schema_info_ptr,
+                                                                                  jobject j_migration_callback)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+        config.schema_mode = static_cast<SchemaMode>(schema_mode);
+        config.schema_version = schema_version;
+        if (schema_info_ptr) {
+            auto& schema = *reinterpret_cast<Schema*>(schema_info_ptr);
+            config.schema = schema;
+        }
+        else {
+            config.schema = none;
+        }
+
+        if (j_migration_callback) {
+            static JavaMethod run_migration_callback_method(
+                env, get_shared_realm_class(env), "runMigrationCallback",
+                "(JLio/realm/internal/OsRealmConfig;Lio/realm/internal/SharedRealm$MigrationCallback;J)V", true);
+            JavaGlobalRef j_config_ref(env, j_config, true);
+            JavaGlobalRef j_migration_callback_ref(env, j_migration_callback, true);
+            config.migration_function = [j_config_ref, j_migration_callback_ref](SharedRealm old_realm,
+                                                                                 SharedRealm realm, Schema&) {
+                JNIEnv* env = JniUtils::get_env(false);
+                // Java needs a new pointer for the SharedRealm life control.
+                SharedRealm* new_shared_realm_ptr = new SharedRealm(realm);
+                env->CallStaticVoidMethod(get_shared_realm_class(env), run_migration_callback_method,
+                                          reinterpret_cast<jlong>(new_shared_realm_ptr), j_config_ref.get(),
+                                          j_migration_callback_ref.get(), old_realm->schema_version());
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
+            };
+        }
+        else {
+            config.migration_function = nullptr;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetCompactOnLaunchCallback(
+    JNIEnv* env, jclass, jlong native_ptr, jobject j_compact_on_launch)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+        if (j_compact_on_launch) {
+            static JavaClass compact_on_launch_class(env, "io/realm/CompactOnLaunchCallback");
+            static JavaMethod should_compact(env, compact_on_launch_class, "shouldCompact", "(JJ)Z");
+            JavaGlobalRef java_compact_on_launch_ref(env, j_compact_on_launch);
+
+            config.should_compact_on_launch_function = [java_compact_on_launch_ref](uint64_t totalBytes,
+                                                                                    uint64_t usedBytes) {
+                JNIEnv* env = JniUtils::get_env(false);
+                bool result = env->CallBooleanMethod(java_compact_on_launch_ref.get(), should_compact,
+                                                     static_cast<jlong>(totalBytes), static_cast<jlong>(usedBytes));
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
+                return result;
+            };
+        }
+        else {
+            config.should_compact_on_launch_function = nullptr;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInitializationCallback(JNIEnv* env,
+                                                                                            jobject j_config,
+                                                                                            jlong native_ptr,
+                                                                                            jobject j_init_callback)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+
+        if (j_init_callback) {
+            static JavaMethod run_initialization_callback_method(
+                env, get_shared_realm_class(env), "runInitializationCallback",
+                "(JLio/realm/internal/OsRealmConfig;Lio/realm/internal/SharedRealm$InitializationCallback;)V", true);
+            JavaGlobalRef j_init_callback_ref(env, j_init_callback, true);
+            JavaGlobalRef j_config_ref(env, j_config, true);
+            config.initialization_function = [j_init_callback_ref, j_config_ref](SharedRealm realm) {
+                JNIEnv* env = JniUtils::get_env(false);
+                // Java needs a new pointer for the SharedRealm life control.
+                SharedRealm* new_shared_realm_ptr = new SharedRealm(realm);
+                env->CallStaticVoidMethod(get_shared_realm_class(env), run_initialization_callback_method,
+                                          reinterpret_cast<jlong>(new_shared_realm_ptr), j_config_ref.get(),
+                                          j_init_callback_ref.get());
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
+            };
+        }
+        else {
+            config.initialization_function = nullptr;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeEnableChangeNotification(
+    JNIEnv*, jclass, jlong native_ptr, jboolean enable_auto_change_notification)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    // No throws
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    config.automatic_change_notifications = enable_auto_change_notification;
+}
+
+#if REALM_ENABLE_SYNC
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSyncConfig(
+    JNIEnv* env, jclass, jlong native_ptr, jstring j_sync_realm_url, jstring j_auth_url, jstring j_user_id,
+    jstring j_reresh_token)
+{
+    TR_ENTER_PTR(native_ptr)
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    // sync_config should only be initialized once!
+    REALM_ASSERT(!config.sync_config);
+
+    try {
+        static JavaClass sync_manager_class(env, "io/realm/SyncManager");
+        // Doing the methods lookup from the thread that loaded the lib, to avoid
+        // https://developer.android.com/training/articles/perf-jni.html#faq_FindClass
+        static JavaMethod java_error_callback_method(env, sync_manager_class, "notifyErrorHandler",
+                                                     "(ILjava/lang/String;Ljava/lang/String;)V", true);
+        static JavaMethod java_bind_session_method(env, sync_manager_class, "bindSessionWithConfig",
+                                                   "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", true);
+
+        // error handler will be called form the sync client thread
+        auto error_handler = [](std::shared_ptr<SyncSession> session, SyncError error) {
+            realm::jni_util::Log::d("error_handler lambda invoked");
+
+            auto error_message = error.message;
+            auto error_code = error.error_code.value();
+            if (error.is_client_reset_requested()) {
+                // Hack the error message to send information about the location of the backup.
+                // If more uses of the user_info map surfaces. Refactor this to send the full
+                // map instead.
+                error_message = error.user_info[SyncError::c_recovery_file_path_key];
+                error_code = 7; // See ErrorCode.java
+            }
+
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+            env->CallStaticVoidMethod(sync_manager_class, java_error_callback_method, error_code,
+                                      to_jstring(env, error_message), to_jstring(env, session.get()->path()));
+        };
+
+        // path on disk of the Realm file.
+        // the sync configuration object.
+        // the session which should be bound.
+        auto bind_handler = [](const std::string& path, const SyncConfig& syncConfig,
+                               std::shared_ptr<SyncSession> session) {
+            realm::jni_util::Log::d("Callback to Java requesting token for path");
+
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+
+            jstring access_token_string = (jstring)env->CallStaticObjectMethod(
+                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()),
+                to_jstring(env, session->user()->refresh_token().c_str()));
+            if (access_token_string) {
+                // reusing cached valid token
+                JStringAccessor access_token(env, access_token_string);
+                session->refresh_access_token(access_token, realm::util::Optional<std::string>(syncConfig.realm_url));
+            }
+        };
+
+        // Get logged in user
+        JStringAccessor user_id(env, j_user_id);
+        JStringAccessor auth_url(env, j_auth_url);
+        SyncUserIdentifier sync_user_identifier = {user_id, auth_url};
+        std::shared_ptr<SyncUser> user = SyncManager::shared().get_existing_logged_in_user(sync_user_identifier);
+        if (!user) {
+            JStringAccessor realm_auth_url(env, j_auth_url);
+            JStringAccessor refresh_token(env, j_reresh_token);
+            user = SyncManager::shared().get_user(sync_user_identifier, refresh_token);
+        }
+
+        util::Optional<std::array<char, 64>> sync_encryption_key(util::none);
+        if (!config.encryption_key.empty()) {
+            sync_encryption_key = std::array<char, 64>();
+            std::copy_n(config.encryption_key.begin(), 64, sync_encryption_key->begin());
+        }
+
+        JStringAccessor realm_url(env, j_sync_realm_url);
+        config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
+            user, realm_url, SyncSessionStopPolicy::AfterChangesUploaded, std::move(bind_handler), std::move(error_handler),
+            nullptr, sync_encryption_key});
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSyncConfigSslSettings(
+    JNIEnv* env, jclass, jlong native_ptr, jboolean sync_client_validate_ssl,
+    jstring j_sync_ssl_trust_certificate_path)
+{
+    TR_ENTER_PTR(native_ptr);
+
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    // To ensure the sync_config has been created and this function won't be called multiple time on the same config.
+    REALM_ASSERT(config.sync_config);
+    REALM_ASSERT(config.sync_config->client_validate_ssl);
+    REALM_ASSERT(!config.sync_config->ssl_trust_certificate_path);
+
+    try {
+        config.sync_config->client_validate_ssl = sync_client_validate_ssl;
+        if (j_sync_ssl_trust_certificate_path) {
+            JStringAccessor cert_path(env, j_sync_ssl_trust_certificate_path);
+            config.sync_config->ssl_trust_certificate_path = realm::util::Optional<std::string>(cert_path);
+        }
+    }
+    CATCH_STD()
+}
+
+#endif
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
index f52e15831f..3056e554df 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
@@ -14,16 +14,21 @@
  * limitations under the License.
  */
 
-#include <jni.h>
 #include "io_realm_internal_OsSchemaInfo.h"
 
-#include <object-store/src/schema.hpp>
-#include <object-store/src/object_schema.hpp>
-#include <object-store/src/property.hpp>
+#include <schema.hpp>
+#include <object_schema.hpp>
+#include <property.hpp>
+#include <util/format.hpp>
 
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
 #include "util.hpp"
 
 using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::util;
+using namespace realm::_impl;
 
 static void finalize_schema(jlong ptr)
 {
@@ -53,3 +58,26 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeGetFinalizerPt
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_schema);
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeGetObjectSchemaInfo(JNIEnv* env, jclass,
+                                                                                      jlong native_ptr,
+                                                                                      jstring j_class_name)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        JStringAccessor class_name_accessor(env, j_class_name);
+        StringData class_name(class_name_accessor);
+        auto& schema = *reinterpret_cast<Schema*>(native_ptr);
+        auto it = schema.find(class_name);
+        if (it == schema.end()) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                                 format("Class '%1' cannot be found in the schema.", class_name.data()));
+        } else {
+            return reinterpret_cast<jlong>(new ObjectSchema(*it));
+        }
+    }
+    CATCH_STD()
+
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
index e2e44dfae9..8362e7c559 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
@@ -14,12 +14,10 @@
  * limitations under the License.
  */
 
-#include <jni.h>
 #include "io_realm_internal_Property.h"
 
-#include <stdexcept>
-#include <object-store/src/property.hpp>
-#include <object-store/src/object_store.hpp>
+#include <property.hpp>
+#include <object_store.hpp>
 
 #include "util.hpp"
 
@@ -44,12 +42,14 @@ static void finalize_property(jlong ptr)
     delete reinterpret_cast<Property*>(ptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateProperty__Ljava_lang_String_2IZZ(
-    JNIEnv* env, jclass, jstring name_, jint type, jboolean is_primary, jboolean is_indexed)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreatePersistedProperty(JNIEnv* env, jclass,
+                                                                                      jstring j_name_str, jint type,
+                                                                                      jboolean is_primary,
+                                                                                      jboolean is_indexed)
 {
     TR_ENTER()
     try {
-        JStringAccessor str(env, name_);
+        JStringAccessor str(env, j_name_str);
         PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
         std::unique_ptr<Property> property(
             new Property(str, p_type, to_bool(is_primary), to_bool(is_indexed)));
@@ -67,13 +67,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateProperty__Lj
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(
-    JNIEnv* env, jclass, jstring name_, jint type, jstring linkedToName_)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreatePersistedLinkProperty(JNIEnv* env, jclass,
+                                                                                          jstring j_name_str,
+                                                                                          jint type,
+                                                                                          jstring j_target_class_name)
 {
     TR_ENTER()
     try {
-        JStringAccessor name(env, name_);
-        JStringAccessor link_name(env, linkedToName_);
+        JStringAccessor name(env, j_name_str);
+        JStringAccessor link_name(env, j_target_class_name);
         PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
         return reinterpret_cast<jlong>(new Property(name, p_type, link_name));
     }
@@ -81,8 +83,55 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateProperty__Lj
     return 0;
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateComputedLinkProperty(JNIEnv* env, jclass,
+                                                                                         jstring j_name_str,
+                                                                                         jstring j_source_class_name,
+                                                                                         jstring j_source_field_name)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, j_name_str);
+        JStringAccessor target_class_name(env, j_source_class_name);
+        JStringAccessor target_field_name(env, j_source_field_name);
+
+        PropertyType p_type = PropertyType::LinkingObjects | PropertyType::Array;
+        return reinterpret_cast<jlong>(new Property(name, p_type, target_class_name, target_field_name));
+    }
+    CATCH_STD()
+    return 0;
+}
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_property);
 }
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_Property_nativeGetType(JNIEnv*, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    auto& property = *reinterpret_cast<Property*>(native_ptr);
+    return static_cast<jint>(property.type);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeGetColumnIndex(JNIEnv*, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    auto& property = *reinterpret_cast<Property*>(native_ptr);
+    return static_cast<jlong>(property.table_column);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Property_nativeGetLinkedObjectName(JNIEnv* env, jclass,
+                                                                                    jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    try {
+        auto& property = *reinterpret_cast<Property*>(native_ptr);
+        std::string name = property.object_type;
+        if (!name.empty()) {
+            return to_jstring(env, name);
+        }
+    }
+    CATCH_STD()
+    return nullptr;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index fd36c60fc8..121419fc35 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -21,8 +21,9 @@
 #include "object-store/src/sync/sync_session.hpp"
 #endif
 
-#include <shared_realm.hpp>
+#include <realm/util/assert.hpp>
 
+#include <shared_realm.hpp>
 #include "object_store.hpp"
 #include "java_binding_context.hpp"
 #include "util.hpp"
@@ -37,141 +38,6 @@ using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
-static_assert(SchemaMode::Automatic ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC),
-              "");
-static_assert(SchemaMode::Immutable ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_IMMUTABLE),
-              "");
-static_assert(SchemaMode::ReadOnlyAlternative ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY),
-              "");
-static_assert(SchemaMode::ResetFile ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_RESET_FILE),
-              "");
-static_assert(SchemaMode::Additive ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_ADDITIVE),
-              "");
-static_assert(SchemaMode::Manual == static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL),
-              "");
-
-static void finalize_shared_realm(jlong ptr);
-
-// Wrapper class for SyncConfig. This is required as we need to keep track of the Java session
-// object as part of the configuration.
-class JniConfigWrapper {
-
-public:
-    JniConfigWrapper(const JniConfigWrapper&) = delete;
-
-    JniConfigWrapper& operator=(const JniConfigWrapper&) = delete;
-    JniConfigWrapper(JniConfigWrapper&&) = delete;
-    JniConfigWrapper& operator=(JniConfigWrapper&&) = delete;
-
-    // Non-sync constructor
-    JniConfigWrapper(JNIEnv*, Realm::Config& config)
-        : m_config(std::move(config))
-    {
-    }
-
-    // Sync constructor
-    JniConfigWrapper(REALM_UNUSED JNIEnv* env, REALM_UNUSED Realm::Config& config,
-                     REALM_UNUSED jstring sync_realm_url, REALM_UNUSED jstring sync_realm_auth_url,
-                     REALM_UNUSED jstring j_sync_user_id, REALM_UNUSED jstring sync_refresh_token,
-                     REALM_UNUSED jboolean sync_client_validate_ssl,
-                     REALM_UNUSED jstring sync_ssl_trust_certificate_path)
-        : m_config(std::move(config))
-    {
-#if REALM_ENABLE_SYNC
-        static JavaClass sync_manager_class(env, "io/realm/SyncManager");
-        // Doing the methods lookup from the thread that loaded the lib, to avoid
-        // https://developer.android.com/training/articles/perf-jni.html#faq_FindClass
-        static JavaMethod java_error_callback_method(env, sync_manager_class, "notifyErrorHandler",
-                                                     "(ILjava/lang/String;Ljava/lang/String;)V", true);
-        static JavaMethod java_bind_session_method(env, sync_manager_class, "bindSessionWithConfig",
-                                                   "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", true);
-
-        // error handler will be called form the sync client thread
-        auto error_handler = [=](std::shared_ptr<SyncSession> session, SyncError error) {
-            realm::jni_util::Log::d("error_handler lambda invoked");
-
-            auto error_message = error.message;
-            auto error_code = error.error_code.value();
-            if (error.is_client_reset_requested()) {
-                // Hack the error message to send information about the location of the backup.
-                // If more uses of the user_info map surfaces. Refactor this to send the full
-                // map instead.
-                error_message = error.user_info[SyncError::c_recovery_file_path_key];
-                error_code = 7; // See ErrorCode.java
-            }
-
-            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
-            env->CallStaticVoidMethod(sync_manager_class, java_error_callback_method, error_code,
-                                      to_jstring(env, error_message), to_jstring(env, session.get()->path()));
-        };
-
-        // path on disk of the Realm file.
-        // the sync configuration object.
-        // the session which should be bound.
-        auto bind_handler = [=](const std::string& path, const SyncConfig& syncConfig,
-                                std::shared_ptr<SyncSession> session) {
-            realm::jni_util::Log::d("Callback to Java requesting token for path");
-
-            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
-
-            jstring access_token_string = (jstring)env->CallStaticObjectMethod(
-                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()), to_jstring(env, session->user()->refresh_token().c_str()));
-            if (access_token_string) {
-                // reusing cached valid token
-                JStringAccessor access_token(env, access_token_string);
-                session->refresh_access_token(access_token, realm::util::Optional<std::string>(syncConfig.realm_url));
-            }
-        };
-
-        // Get logged in user
-        JStringAccessor user_id(env, j_sync_user_id);
-        JStringAccessor realm_auth_url(env, sync_realm_auth_url);
-        SyncUserIdentifier sync_user_identifier = {user_id, realm_auth_url};
-        std::shared_ptr<SyncUser> user = SyncManager::shared().get_existing_logged_in_user(sync_user_identifier);
-        if (!user) {
-            JStringAccessor refresh_token(env, sync_refresh_token);
-            user = SyncManager::shared().get_user(sync_user_identifier, refresh_token);
-        }
-
-        util::Optional<std::string> ssl_trust_certificate_path = util::none;
-        if (sync_ssl_trust_certificate_path) {
-            ssl_trust_certificate_path =
-                realm::util::Optional<std::string>(JStringAccessor(env, sync_ssl_trust_certificate_path));
-        }
-
-        util::Optional<std::array<char, 64>> sync_encryption_key(util::none);
-        if (!m_config.encryption_key.empty()) {
-            sync_encryption_key = std::array<char, 64>();
-            std::copy_n(m_config.encryption_key.begin(), 64, sync_encryption_key->begin());
-        }
-
-        JStringAccessor realm_url(env, sync_realm_url);
-        m_config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
-            user, realm_url, SyncSessionStopPolicy::AfterChangesUploaded, std::move(bind_handler), std::move(error_handler),
-            nullptr, sync_encryption_key, to_bool(sync_client_validate_ssl), ssl_trust_certificate_path});
-#else
-        REALM_UNREACHABLE();
-#endif
-    }
-
-    inline Realm::Config& get_config()
-    {
-        return m_config;
-    }
-
-    ~JniConfigWrapper()
-    {
-    }
-
-private:
-    Realm::Config m_config;
-};
-
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env, jclass,
                                                                      jstring temporary_directory_path)
 {
@@ -184,77 +50,45 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
-    JNIEnv* env, jclass, jstring realm_path, jbyteArray key, jbyte schema_mode, jboolean in_memory, jboolean cache,
-    jlong /* schema_version */, jboolean enable_format_upgrade, jboolean auto_change_notification,
-    jobject compact_on_launch,
-    REALM_UNUSED jstring sync_server_url, REALM_UNUSED jstring sync_server_auth_url,
-    REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token,
-    REALM_UNUSED jboolean sync_client_validate_ssl, REALM_UNUSED jstring sync_ssl_trust_certificate_path)
-{
-    TR_ENTER()
-
-    try {
-        JStringAccessor path(env, realm_path); // throws
-        JniByteArray key_array(env, key);
-        Realm::Config config;
-        config.path = path;
-        // config->schema_version = schema_version; TODO: Disabled until we remove version handling from Java
-        config.encryption_key = key_array;
-        config.schema_mode = static_cast<SchemaMode>(schema_mode);
-        config.in_memory = in_memory;
-        config.cache = cache;
-        config.disable_format_upgrade = !enable_format_upgrade;
-        config.automatic_change_notifications = auto_change_notification;
-
-        if (compact_on_launch) {
-            static JavaClass callback_class(env, "io/realm/CompactOnLaunchCallback");
-            static JavaMethod should_compact(env, callback_class, "shouldCompact", "(JJ)Z");
-            JavaGlobalRef java_compact_on_launch_ref(env, compact_on_launch);
-
-            auto should_compact_on_launch_function = [java_compact_on_launch_ref](uint64_t totalBytes, uint64_t usedBytes) {
-                JNIEnv* env = JniUtils::get_env(false);
-                return env->CallBooleanMethod(java_compact_on_launch_ref.get(), should_compact,
-                                              static_cast<jlong>(totalBytes), static_cast<jlong>(usedBytes));
-            };
-            config.should_compact_on_launch_function = std::move(should_compact_on_launch_function);
-        }
-
-        if (sync_server_url) {
-            return reinterpret_cast<jlong>(
-                new JniConfigWrapper(env, config, sync_server_url, sync_server_auth_url, sync_user_identity,
-                                     sync_refresh_token, sync_client_validate_ssl, sync_ssl_trust_certificate_path));
-        }
-        else {
-            return reinterpret_cast<jlong>(new JniConfigWrapper(env, config));
-        }
-    }
-    CATCH_STD()
-
-    return static_cast<jlong>(NULL);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv*, jclass, jlong config_ptr)
-{
-    TR_ENTER_PTR(config_ptr)
-
-    auto config = reinterpret_cast<JniConfigWrapper*>(config_ptr);
-    delete config;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv* env, jclass, jlong config_ptr,
                                                                                 jobject realm_notifier)
 {
     TR_ENTER_PTR(config_ptr)
 
-    auto config = reinterpret_cast<JniConfigWrapper*>(config_ptr);
+    auto& config = *reinterpret_cast<Realm::Config*>(config_ptr);
     try {
-        auto shared_realm = Realm::get_shared_realm(config->get_config());
+        auto shared_realm = Realm::get_shared_realm(config);
+        // The migration callback & initialization callback could throw.
+        if (env->ExceptionCheck()) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
         shared_realm->m_binding_context = JavaBindingContext::create(env, realm_notifier);
         return reinterpret_cast<jlong>(new SharedRealm(std::move(shared_realm)));
     }
+    catch (SchemaMismatchException& e) {
+        // An exception has been thrown in the migration block.
+        if (env->ExceptionCheck()) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
+        static JavaClass migration_needed_class(env, JavaExceptionDef::RealmMigrationNeeded);
+        static JavaMethod constructor(env, migration_needed_class, "<init>",
+                                      "(Ljava/lang/String;Ljava/lang/String;)V");
+
+        jstring message = to_jstring(env, e.what());
+        jstring path = to_jstring(env, config.path);
+        jobject migration_needed_exception = env->NewObject(migration_needed_class, constructor, path, message);
+        env->Throw(reinterpret_cast<jthrowable>(migration_needed_exception));
+    }
+    catch (InvalidSchemaVersionException& e) {
+        // An exception has been thrown in the migration block.
+        if (env->ExceptionCheck()) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
+        // To match the old behaviour. Otherwise it will be converted to ISE in the CATCH_STD.
+        ThrowException(env, IllegalArgument, e.what());
+    }
     CATCH_STD()
-    return static_cast<jlong>(NULL);
+    return reinterpret_cast<jlong>(nullptr);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv*, jclass,
@@ -616,35 +450,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeCompact(JNIE
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv* env, jclass,
-                                                                             jlong shared_realm_ptr, jlong schema_ptr,
-                                                                             jlong version)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-    try {
-        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        auto* schema = reinterpret_cast<Schema*>(schema_ptr);
-        shared_realm->update_schema(*schema, static_cast<uint64_t>(version), nullptr, nullptr, true);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeRequiresMigration(JNIEnv* env, jclass,
-                                                                                      jlong nativePtr,
-                                                                                      jlong nativeSchemaPtr)
-{
-
-    TR_ENTER()
-    try {
-        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
-        auto* schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
-        const std::vector<SchemaChange>& change_list = shared_realm->schema().compare(*schema);
-        return static_cast<jboolean>(!change_list.empty());
-    }
-    CATCH_STD()
-    return JNI_FALSE;
-}
-
 static void finalize_shared_realm(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
@@ -680,3 +485,28 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsAutoRefres
     CATCH_STD()
     return JNI_FALSE;
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSchemaInfo(JNIEnv*, jclass,
+                                                                               jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    // No throws
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return reinterpret_cast<jlong>(&shared_realm->schema());
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRegisterSchemaChangedCallback(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jobject j_schema_changed_callback)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    // No throws
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    JavaGlobalWeakRef callback_weak_ref(env, j_schema_changed_callback);
+    if (shared_realm->m_binding_context) {
+        JavaBindingContext& java_binding_context =
+            *(static_cast<JavaBindingContext*>(shared_realm->m_binding_context.get()));
+        java_binding_context.set_schema_changed_callback(env, j_schema_changed_callback);
+    }
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index ad6a75be1c..07e6e2d335 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -118,6 +118,22 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn(JNIEnv* e
     CATCH_STD()
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertColumn(JNIEnv* env, jclass, jlong native_table_ptr,
+                                                                       jlong column_index, jint type, jstring j_name)
+{
+    auto table_ptr = reinterpret_cast<realm::Table*>(native_table_ptr);
+    if (!TABLE_VALID(env, table_ptr)) {
+        return;
+    }
+    try {
+        JStringAccessor name(env, j_name); // throws
+
+        DataType data_type = DataType(type);
+        table_ptr->insert_column(column_index, data_type, name);
+    }
+    CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                        jlong columnIndex, jstring name)
 {
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
index 296d5bbc95..343a3c9384 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.cpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -54,6 +54,23 @@ void JavaBindingContext::did_change(std::vector<BindingContext::ObserverState> c
     }
 }
 
+void JavaBindingContext::schema_did_change(Schema const&)
+{
+    if (!m_schema_changed_callback) {
+        return;
+    }
+    auto env = JniUtils::get_env(false);
+    static JavaClass callback_class(env, "io/realm/internal/SharedRealm$SchemaChangedCallback");
+    static JavaMethod on_schema_changed_method(env, callback_class, "onSchemaChanged", "()V");
+    m_schema_changed_callback.call_with_local_ref(
+        env, [](JNIEnv* env, jobject callback_obj) { env->CallVoidMethod(callback_obj, on_schema_changed_method); });
+}
+
+void JavaBindingContext::set_schema_changed_callback(JNIEnv* env, jobject schema_changed_callback)
+{
+    m_schema_changed_callback = JavaGlobalWeakRef(env, schema_changed_callback);
+}
+
 JavaClass const& JavaBindingContext::get_notifier_class(JNIEnv* env)
 {
     static JavaClass notifier_class(env, "io/realm/internal/RealmNotifier");
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index f961d4f676..27dc3842f9 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -39,19 +39,26 @@ class JavaBindingContext final : public BindingContext {
         jobject java_notifier;
     };
 
-    // A weak global ref to the implementation of RealmNotifier
-    // Java should hold a strong ref to it as long as the SharedRealm lives
+    // Weak global refs to the needed Java objects.
+    // Java should hold a strong ref to them as long as the SharedRealm lives
     jni_util::JavaGlobalWeakRef m_java_notifier;
-    jni_util::JavaClass const& get_notifier_class(JNIEnv*);
+    jni_util::JavaGlobalWeakRef m_schema_changed_callback;
+    // Problem has been seen if the class is retrieved directly from loop callback. So make sure get_notifier_class()
+    // is called once when creating BindingContext.
+    jni_util::JavaClass const& m_notifier_class;
+    static jni_util::JavaClass const& get_notifier_class(JNIEnv*);
 
 public:
     virtual ~JavaBindingContext(){};
-    virtual void before_notify();
-    virtual void did_change(std::vector<ObserverState> const& observers, std::vector<void*> const& invalidated,
-                            bool version_changed = true);
+    void before_notify() override;
+    void did_change(std::vector<ObserverState> const& observers, std::vector<void*> const& invalidated,
+                    bool version_changed = true) override;
+    void schema_did_change(Schema const&) override;
 
     explicit JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
         : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier)
+        , m_schema_changed_callback()
+        , m_notifier_class(get_notifier_class(concrete_context.jni_env))
     {
     }
     JavaBindingContext(const JavaBindingContext&) = delete;
@@ -59,6 +66,8 @@ class JavaBindingContext final : public BindingContext {
     JavaBindingContext(JavaBindingContext&&) = delete;
     JavaBindingContext& operator=(JavaBindingContext&&) = delete;
 
+    void set_schema_changed_callback(JNIEnv* env, jobject schema_changed_callback);
+
     static inline std::unique_ptr<JavaBindingContext> create(JNIEnv* env, jobject notifier)
     {
         return std::make_unique<JavaBindingContext>(ConcreteJavaBindContext{env, notifier});
diff --git a/realm/realm-library/src/main/cpp/java_exception_def.cpp b/realm/realm-library/src/main/cpp/java_exception_def.cpp
index 75819d603b..af773d13f5 100644
--- a/realm/realm-library/src/main/cpp/java_exception_def.cpp
+++ b/realm/realm-library/src/main/cpp/java_exception_def.cpp
@@ -21,3 +21,4 @@ using namespace realm::_impl;
 const char* JavaExceptionDef::IllegalState = "java/lang/IllegalStateException";
 const char* JavaExceptionDef::IllegalArgument = "java/lang/IllegalArgumentException";
 const char* JavaExceptionDef::OutOfMemory = "java/lang/OutOfMemoryError";
+const char* JavaExceptionDef::RealmMigrationNeeded = "io/realm/exceptions/RealmMigrationNeededException";
diff --git a/realm/realm-library/src/main/cpp/java_exception_def.hpp b/realm/realm-library/src/main/cpp/java_exception_def.hpp
index 6ff17ebe36..c705416157 100644
--- a/realm/realm-library/src/main/cpp/java_exception_def.hpp
+++ b/realm/realm-library/src/main/cpp/java_exception_def.hpp
@@ -27,6 +27,7 @@ class JavaExceptionDef {
     static const char* IllegalState;
     static const char* IllegalArgument;
     static const char* OutOfMemory;
+    static const char* RealmMigrationNeeded;
 };
 
 } // namespace realm
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
index 6d5d89dc1c..e023e499d9 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
@@ -21,6 +21,12 @@
 
 using namespace realm::jni_util;
 
+JavaClass::JavaClass()
+    : m_ref_owner()
+    , m_class(nullptr)
+{
+}
+
 JavaClass::JavaClass(JNIEnv* env, const char* class_name, bool free_on_unload)
     : m_ref_owner(get_jclass(env, class_name))
     , m_class(reinterpret_cast<jclass>(m_ref_owner.get()))
@@ -41,7 +47,7 @@ JavaClass::JavaClass(JavaClass&& rhs)
 JavaGlobalRef JavaClass::get_jclass(JNIEnv* env, const char* class_name)
 {
     jclass cls = env->FindClass(class_name);
-    REALM_ASSERT_DEBUG(cls);
+    REALM_ASSERT_RELEASE(cls);
 
     JavaGlobalRef cls_ref(env, cls, true);
     return cls_ref;
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.hpp b/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
index 7aaf3a00ed..e6ee130f73 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
@@ -27,6 +27,7 @@ namespace jni_util {
 // To find the jclass and manage the lifecycle for the jclass's global ref.
 class JavaClass {
 public:
+    JavaClass();
     // when free_on_unload is true, the jclass's global ref will be released when JNI_OnUnload called. This is useful
     // when the JavaClass instance is static. Otherwise the jclass's global ref will be released when this object is
     // deleted.
@@ -47,6 +48,11 @@ class JavaClass {
         return m_class;
     }
 
+    inline operator bool() const noexcept
+    {
+        return m_class != nullptr;
+    }
+
     // Not implemented for now.
     JavaClass(JavaClass&) = delete;
     JavaClass& operator=(JavaClass&&) = delete;
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
index 63cd8a9ba7..a867145b08 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
@@ -22,6 +22,14 @@
 using namespace realm::util;
 using namespace realm::jni_util;
 
+JavaExceptionThrower::JavaExceptionThrower(const char* file_path, int line_num)
+    : std::runtime_error("Java exception has been occurred. Terminate JNI by throwing a c++ exception.")
+    , m_exception_class()
+    , m_file_path(file_path)
+    , m_line_num(line_num)
+{
+}
+
 JavaExceptionThrower::JavaExceptionThrower(JNIEnv* env, const char* class_name, std::string message,
                                            const char* file_path, int line_num)
     : std::runtime_error(std::move(message))
@@ -35,5 +43,19 @@ void JavaExceptionThrower::throw_java_exception(JNIEnv* env)
 {
     std::string message = format("%1\n(%2:%3)", what(), m_file_path, m_line_num);
     Log::w(message.c_str());
+
+    // There is a pending Java exception, just return.
+    if (env->ExceptionCheck()) {
+        Log::w("There is a pending Java exception.");
+        return;
+    }
     env->ThrowNew(m_exception_class, message.c_str());
 }
+
+void JavaExceptionThrower::terminate_jni_if_java_exception_occurred(JNIEnv* env, const char* file_path, int line_num)
+{
+    if (!env->ExceptionCheck()) {
+        return;
+    }
+    throw JavaExceptionThrower(file_path, line_num);
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
index 1d5bcdde69..e35bcc8a6d 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
@@ -29,14 +29,22 @@ namespace jni_util {
 #define THROW_JAVA_EXCEPTION(env, class_name, message)                                                               \
     throw realm::jni_util::JavaExceptionThrower(env, class_name, message, __FILE__, __LINE__)
 
+#define TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env)                                                                  \
+    JavaExceptionThrower::terminate_jni_if_java_exception_occurred(env, __FILE__, __LINE__);
+
 // Class to help throw a Java exception from JNI code.
 // This exception will be called from CATCH_STD and throw a Java exception there.
 class JavaExceptionThrower : public std::runtime_error {
 public:
+    JavaExceptionThrower(const char* file_path, int line_num);
     JavaExceptionThrower(JNIEnv* env, const char* class_name, std::string message, const char* file_path,
                          int line_num);
 
-    virtual void throw_java_exception(JNIEnv* env);
+    void throw_java_exception(JNIEnv* env);
+
+    // This method will throw a JavaExceptionThrower to terminate JNI then return to java if there is an Java
+    // exception has been thrown before.
+    static void terminate_jni_if_java_exception_occurred(JNIEnv* env, const char* file_path, int line_num);
 
 private:
     JavaClass m_exception_class;
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 383d295e8f..025c704a26 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -34,6 +34,9 @@
 import io.realm.internal.CheckedRow;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.OsRealmConfig;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
@@ -52,7 +55,6 @@
  */
 @SuppressWarnings("WeakerAccess")
 abstract class BaseRealm implements Closeable {
-    protected static final long UNVERSIONED = -1;
     private static final String INCORRECT_THREAD_CLOSE_MESSAGE =
             "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
     private static final String INCORRECT_THREAD_MESSAGE =
@@ -75,29 +77,65 @@
     // cache. It is also null if the Realm is closed.
     private RealmCache realmCache;
     protected SharedRealm sharedRealm;
+    private boolean shouldCloseSharedRealm;
+    private SharedRealm.SchemaChangedCallback schemaChangedCallback = new SharedRealm.SchemaChangedCallback() {
+        @Override
+        public void onSchemaChanged() {
+            RealmSchema schema = getSchema();
+            if (schema != null) {
+                schema.refresh();
+            }
+        }
+    };
 
     // Create a realm instance and associate it to a RealmCache.
-    BaseRealm(RealmCache cache) {
-        this(cache.getConfiguration());
+    BaseRealm(RealmCache cache, @Nullable OsSchemaInfo schemaInfo) {
+        this(cache.getConfiguration(), schemaInfo);
         this.realmCache = cache;
     }
 
     // Create a realm instance without associating it to any RealmCache.
-    BaseRealm(RealmConfiguration configuration) {
+    BaseRealm(final RealmConfiguration configuration, @Nullable OsSchemaInfo schemaInfo) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
         this.realmCache = null;
 
-        this.sharedRealm = SharedRealm.getInstance(configuration,
-                !(this instanceof Realm) ? null :
-                        new SharedRealm.SchemaVersionListener() {
-                            @Override
-                            public void onSchemaVersionChanged(long currentVersion) {
-                                if (realmCache != null) {
-                                    realmCache.updateSchemaCache((Realm) BaseRealm.this);
-                                }
-                            }
-                        }, true);
+        SharedRealm.MigrationCallback migrationCallback = null;
+        if (schemaInfo != null && configuration.getMigration() != null) {
+            migrationCallback = createMigrationCallback(configuration.getMigration());
+        }
+
+        SharedRealm.InitializationCallback initializationCallback = null;
+        final Realm.Transaction initialDataTransaction = configuration.getInitialDataTransaction();
+        if (initialDataTransaction != null) {
+            initializationCallback = new SharedRealm.InitializationCallback() {
+                @Override
+                public void onInit(SharedRealm sharedRealm) {
+                    initialDataTransaction.execute(Realm.createInstance(sharedRealm));
+                }
+            };
+        }
+
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration)
+                .autoUpdateNotification(true)
+                .migrationCallback(migrationCallback)
+                .schemaInfo(schemaInfo)
+                .initializationCallback(initializationCallback);
+        this.sharedRealm = SharedRealm.getInstance(configBuilder);
+        this.shouldCloseSharedRealm = true;
+
+        sharedRealm.registerSchemaChangedCallback(schemaChangedCallback);
+    }
+
+    // Create a realm instance directly from a SharedRealm instance. This instance doesn't have the ownership of the
+    // given SharedRealm instance. The SharedRealm instance should not be closed when close() called.
+    BaseRealm(SharedRealm sharedRealm) {
+        this.threadId = Thread.currentThread().getId();
+        this.configuration = sharedRealm.getConfiguration();
+        this.realmCache = null;
+
+        this.sharedRealm = sharedRealm;
+        this.shouldCloseSharedRealm = false;
     }
 
     /**
@@ -347,12 +385,8 @@ public void onCall() {
      * incompatible schema changes.
      */
     public void beginTransaction() {
-        beginTransaction(false);
-    }
-
-    void beginTransaction(boolean ignoreReadOnly) {
         checkIfValid();
-        sharedRealm.beginTransaction(ignoreReadOnly);
+        sharedRealm.beginTransaction();
     }
 
     /**
@@ -472,7 +506,7 @@ public void close() {
      */
     void doClose() {
         realmCache = null;
-        if (sharedRealm != null) {
+        if (sharedRealm != null && shouldCloseSharedRealm) {
             sharedRealm.close();
             sharedRealm = null;
         }
@@ -616,13 +650,10 @@ static boolean compactRealm(final RealmConfiguration configuration) {
      * @param configuration configuration for the Realm that should be migrated. If this is a SyncConfiguration this
      * method does nothing.
      * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
-     * @param callback callback for specific Realm type behaviors.
-     * @param cause which triggers this migration.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      * @throws IllegalArgumentException if the provided configuration is a {@code SyncConfiguration}.
      */
-    protected static void migrateRealm(final RealmConfiguration configuration, @Nullable final RealmMigration migration,
-            final MigrationCallback callback, @Nullable final RealmMigrationNeededException cause)
+    protected static void migrateRealm(final RealmConfiguration configuration, @Nullable final RealmMigration migration)
             throws FileNotFoundException {
 
         //noinspection ConstantConditions
@@ -633,7 +664,7 @@ protected static void migrateRealm(final RealmConfiguration configuration, @Null
             throw new IllegalArgumentException("Manual migrations are not supported for synced Realms");
         }
         if (migration == null && configuration.getMigration() == null) {
-            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
+            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided.");
         }
 
         final AtomicBoolean fileNotFound = new AtomicBoolean(false);
@@ -652,26 +683,24 @@ public void onResult(int count) {
                     return;
                 }
 
-                RealmMigration realmMigration = (migration == null) ? configuration.getMigration() : migration;
-                DynamicRealm realm = null;
+                RealmProxyMediator mediator = configuration.getSchemaMediator();
+                OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
+                SharedRealm.MigrationCallback migrationCallback = null;
+                final RealmMigration migrationToBeApplied = migration != null ? migration : configuration.getMigration();
+                if (migrationToBeApplied != null) {
+                    migrationCallback = createMigrationCallback(migrationToBeApplied);
+                }
+                OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration)
+                        .autoUpdateNotification(false)
+                        .schemaInfo(schemaInfo)
+                        .migrationCallback(migrationCallback);
+                SharedRealm sharedRealm = null;
                 try {
-                    // Create a DynamicRealm WITHOUT putting it into a RealmCache to avoid recursive locks and call init
-                    // steps multiple times (copy asset file / initialData transaction).
-                    realm = DynamicRealm.createInstance(configuration);
-                    realm.beginTransaction();
-                    long currentVersion = realm.getVersion();
-                    realmMigration.migrate(realm, currentVersion, configuration.getSchemaVersion());
-                    realm.setVersion(configuration.getSchemaVersion());
-                    realm.commitTransaction();
-                } catch (RuntimeException e) {
-                    if (realm != null) {
-                        realm.cancelTransaction();
-                    }
-                    throw e;
+                    sharedRealm =
+                            SharedRealm.getInstance(configBuilder);
                 } finally {
-                    if (realm != null) {
-                        realm.close();
-                        callback.migrationComplete();
+                    if (sharedRealm != null) {
+                        sharedRealm.close();
                     }
                 }
             }
@@ -683,9 +712,18 @@ public void onResult(int count) {
         }
     }
 
+    private static SharedRealm.MigrationCallback createMigrationCallback(final RealmMigration migration) {
+        return new SharedRealm.MigrationCallback() {
+            @Override
+            public void onMigrationNeeded(SharedRealm sharedRealm, long oldVersion, long newVersion) {
+                migration.migrate(DynamicRealm.createInstance(sharedRealm), oldVersion, newVersion);
+            }
+        };
+    }
+
     @Override
     protected void finalize() throws Throwable {
-        if (sharedRealm != null && !sharedRealm.isClosed()) {
+        if (shouldCloseSharedRealm && sharedRealm != null && !sharedRealm.isClosed()) {
             RealmLog.warn("Remember to call close() on all Realm instances. " +
                     "Realm %s is being finalized without being closed, " +
                     "this can lead to running out of native memory.", configuration.getPath()
@@ -701,11 +739,6 @@ SharedRealm getSharedRealm() {
         return sharedRealm;
     }
 
-    // Internal delegate for migrations.
-    protected interface MigrationCallback {
-        void migrationComplete();
-    }
-
     public static final class RealmObjectContext {
         private BaseRealm realm;
         private Row row;
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 27c25abcb1..10bb52dab8 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -22,6 +22,7 @@
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.OsObject;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.log.RealmLog;
 import rx.Observable;
@@ -52,12 +53,12 @@
     private final RealmSchema schema;
 
     private DynamicRealm(RealmCache cache) {
-        super(cache);
+        super(cache, null);
         this.schema = new MutableRealmSchema(this);
     }
 
-    private DynamicRealm(RealmConfiguration configuration) {
-        super(configuration);
+    private DynamicRealm(SharedRealm sharedRealm) {
+        super(sharedRealm);
         this.schema = new MutableRealmSchema(this);
     }
 
@@ -246,12 +247,14 @@ static DynamicRealm createInstance(RealmCache cache) {
     }
 
     /**
-     * Create a {@link DynamicRealm} instance without associating it to any RealmCache.
+     * Creates a {@link DynamicRealm} instance with a given {@link SharedRealm} instance without owning it.
+     * This is designed to be used in the migration block when opening a typed Realm instance.
      *
+     * @param sharedRealm the existing {@link SharedRealm} instance.
      * @return a {@link DynamicRealm} instance.
      */
-    static DynamicRealm createInstance(RealmConfiguration configuration) {
-        return new DynamicRealm(configuration);
+    static DynamicRealm createInstance(SharedRealm sharedRealm) {
+        return new DynamicRealm(sharedRealm);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
index 8200675ba4..5f56104ded 100644
--- a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import io.realm.internal.ColumnIndices;
 import io.realm.internal.Table;
 
 /**
@@ -26,8 +27,8 @@
     private static final String SCHEMA_IMMUTABLE_EXCEPTION_MSG = "This 'RealmSchema' is immutable." +
             " Please use 'DynamicRealm.getSchema() to get a mutable instance.";
 
-    ImmutableRealmSchema(BaseRealm realm) {
-        super(realm);
+    ImmutableRealmSchema(BaseRealm realm, ColumnIndices columnIndices) {
+        super(realm, columnIndices);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
index 0de3679e5f..e74556b5e5 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
@@ -26,7 +26,7 @@
 class MutableRealmSchema extends RealmSchema {
 
     MutableRealmSchema(BaseRealm realm) {
-        super(realm);
+        super(realm, null);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index dc57151b7d..63b75e95b2 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -52,7 +52,6 @@
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
-import io.realm.internal.ColumnInfo;
 import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsObject;
 import io.realm.internal.OsSchemaInfo;
@@ -63,7 +62,6 @@
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmAsyncTaskImpl;
-import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 import rx.Observable;
 
@@ -149,8 +147,36 @@
      * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
      */
     private Realm(RealmCache cache) {
-        super(cache);
-        schema = new ImmutableRealmSchema(this);
+        super(cache, createExpectedSchemaInfo(cache.getConfiguration().getSchemaMediator()));
+        schema = new ImmutableRealmSchema(this,
+                new ColumnIndices(configuration.getSchemaMediator(), sharedRealm.getSchemaInfo()));
+        // FIXME: This is to work around the different behaviour between the read only Realms in the Object Store and
+        // in current java implementation. Opening a read only Realm with some missing schemas is allowed by Object
+        // Store and realm-cocoa. In that case, any query based on the missing schema should just return an empty
+        // results. Fix this together with https://github.com/realm/realm-java/issues/2953
+        if (configuration.isReadOnly()) {
+            RealmProxyMediator mediator = configuration.getSchemaMediator();
+            Set<Class<? extends RealmModel>> classes = mediator.getModelClasses();
+            for (Class<? extends RealmModel> clazz  : classes) {
+                String tableName = mediator.getTableName(clazz);
+                if (!sharedRealm.hasTable(tableName)) {
+                    sharedRealm.close();
+                    throw new RealmMigrationNeededException(configuration.getPath(),
+                            String.format(Locale.US, "Cannot open the read only Realm. '%s' is missing.",
+                                    Table.getClassNameForTable(tableName)));
+                }
+            }
+        }
+    }
+
+    private Realm(SharedRealm sharedRealm) {
+        super(sharedRealm);
+        schema = new ImmutableRealmSchema(this,
+                new ColumnIndices(configuration.getSchemaMediator(), sharedRealm.getSchemaInfo()));
+    }
+
+    private static OsSchemaInfo createExpectedSchemaInfo(RealmProxyMediator mediator) {
+        return new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
     }
 
     /**
@@ -388,140 +414,15 @@ public static void removeDefaultConfiguration() {
      * @return a {@link Realm} instance.
      */
     static Realm createInstance(RealmCache cache) {
-        RealmConfiguration configuration = cache.getConfiguration();
-        try {
-            return createAndValidateFromCache(cache);
-
-        } catch (RealmMigrationNeededException e) {
-            if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
-                deleteRealm(configuration);
-            } else {
-                try {
-                    if (configuration.getMigration() != null) {
-                        migrateRealm(configuration, e);
-                    }
-                } catch (FileNotFoundException fileNotFoundException) {
-                    // Should never happen.
-                    throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
-                }
-            }
-
-            return createAndValidateFromCache(cache);
-        }
+        return new Realm(cache);
     }
 
-    private static Realm createAndValidateFromCache(RealmCache cache) {
-        Realm realm = new Realm(cache);
-        RealmConfiguration configuration = realm.configuration;
-
-        final long currentVersion = realm.getVersion();
-        final long requiredVersion = configuration.getSchemaVersion();
-
-        final ColumnIndices columnIndices = RealmCache.findColumnIndices(cache.getTypedColumnIndicesArray(),
-                requiredVersion);
-
-        if (columnIndices != null) {
-            // Copies global cache as a Realm local indices cache.
-            realm.schema.setInitialColumnIndices(columnIndices);
-        } else {
-            final boolean syncingConfig = configuration.isSyncConfiguration();
-
-            if (!syncingConfig && (currentVersion != UNVERSIONED)) {
-                if (currentVersion < requiredVersion) {
-                    realm.doClose();
-                    throw new RealmMigrationNeededException(
-                            configuration.getPath(),
-                            String.format(Locale.US, "Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
-                }
-                if (requiredVersion < currentVersion) {
-                    realm.doClose();
-                    throw new IllegalArgumentException(
-                            String.format(Locale.US, "Realm on disk is newer than the one specified: v%s vs. v%s", currentVersion, requiredVersion));
-                }
-            }
-
-            // Initializes Realm schema if needed.
-            try {
-                initializeRealm(realm);
-            } catch (RuntimeException e) {
-                realm.doClose();
-                throw e;
-            }
-        }
-
-        return realm;
-    }
-
-    private static void initializeRealm(Realm realm) {
-        // Everything in this method needs to be behind a transaction lock to prevent multi-process interaction while
-        // the Realm is initialized.
-        boolean commitChanges = false;
-        try {
-            // We need to start a transaction no matter readOnly mode, because it acts as an interprocess lock.
-            // TODO: For proper inter-process support we also need to move e.g copying the asset file under an
-            // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
-            // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
-            realm.beginTransaction(true);
-            RealmConfiguration configuration = realm.getConfiguration();
-            long currentVersion = realm.getVersion();
-            boolean unversioned = currentVersion == UNVERSIONED;
-            long newVersion = configuration.getSchemaVersion();
-
-            RealmProxyMediator mediator = configuration.getSchemaMediator();
-            Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-
-            if (configuration.isSyncConfiguration()) {
-                // Update/create the schema if allowed
-                if (!configuration.isReadOnly()) {
-                    OsSchemaInfo schema = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
-
-                    // Object Store handles all update logic
-                    realm.sharedRealm.updateSchema(schema, newVersion);
-                    commitChanges = true;
-                }
-            } else {
-                // Only allow creating the schema if not in read-only mode
-                if (unversioned) {
-                    if (configuration.isReadOnly()) {
-                        throw new IllegalArgumentException("Cannot create the Realm schema in a read-only file.");
-                    }
-
-                    // Let Object Store initialize all tables
-                    OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
-                    realm.sharedRealm.updateSchema(schemaInfo, newVersion);
-                    commitChanges = true;
-                }
-            }
-
-            // Now that they have all been created, validate them.
-            final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                String className = Table.getClassNameForTable(mediator.getTableName(modelClass));
-                Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(modelClass, className);
-                // More fields in the Realm than defined is allowed for synced Realm.
-                columnInfoMap.put(key, mediator.validateTable(modelClass, realm.sharedRealm,
-                        configuration.isSyncConfiguration()));
-            }
-
-            realm.getSchema().setInitialColumnIndices(
-                    (unversioned) ? newVersion : currentVersion,
-                    columnInfoMap);
-
-            // Finally add any initial data
-            final Transaction transaction = configuration.getInitialDataTransaction();
-            if (transaction != null && unversioned) {
-                transaction.execute(realm);
-            }
-        } catch (Exception e) {
-            commitChanges = false;
-            throw e;
-        } finally {
-            if (commitChanges) {
-                realm.commitTransaction();
-            } else if (realm.isInTransaction()) {
-                realm.cancelTransaction();
-            }
-        }
+    /**
+     * Creates a {@code Realm} instance directly from a {@link SharedRealm}. This {@code Realm} doesn't need to be
+     * closed.
+     */
+    static Realm createInstance(SharedRealm sharedRealm) {
+        return new Realm(sharedRealm);
     }
 
     /**
@@ -1692,23 +1593,7 @@ private void checkMaxDepth(int maxDepth) {
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
     public static void migrateRealm(RealmConfiguration configuration) throws FileNotFoundException {
-        migrateRealm(configuration, (RealmMigration) null);
-    }
-
-    /**
-     * Called when migration needed in the Realm initialization.
-     *
-     * @param configuration {@link RealmConfiguration}
-     * @param cause which triggers this migration.
-     * @throws FileNotFoundException if the Realm file doesn't exist.
-     */
-    private static void migrateRealm(final RealmConfiguration configuration, final RealmMigrationNeededException cause)
-            throws FileNotFoundException {
-        BaseRealm.migrateRealm(configuration, null, new MigrationCallback() {
-            @Override
-            public void migrationComplete() {
-            }
-        }, cause);
+        migrateRealm(configuration, null);
     }
 
     /**
@@ -1721,11 +1606,7 @@ public void migrationComplete() {
      */
     public static void migrateRealm(RealmConfiguration configuration, @Nullable RealmMigration migration)
             throws FileNotFoundException {
-        BaseRealm.migrateRealm(configuration, migration, new MigrationCallback() {
-            @Override
-            public void migrationComplete() {
-            }
-        }, null);
+        BaseRealm.migrateRealm(configuration, migration);
     }
 
     /**
@@ -1765,53 +1646,6 @@ Table getTable(Class<? extends RealmModel> clazz) {
         return schema.getTable(clazz);
     }
 
-    /**
-     * Updates own schema cache.
-     *
-     * @param globalCacheArray global cache of column indices. If it contains an entry for current
-     * schema version, this method only copies the indices information in the entry.
-     * @return newly created indices information for current schema version. Or {@code null} if {@code globalCacheArray}
-     * already contains the entry for current schema version.
-     */
-    @Nullable
-    ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
-        final long currentSchemaVersion = sharedRealm.getSchemaVersion();
-        final long cacheSchemaVersion = schema.getSchemaVersion();
-        if (currentSchemaVersion == cacheSchemaVersion) {
-            return null;
-        }
-
-        ColumnIndices createdGlobalCache = null;
-        ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
-                currentSchemaVersion);
-        if (cacheForCurrentVersion == null) {
-            final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
-
-            // Not found in global cache. create it.
-            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-            final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> map;
-            map = new HashMap<>(modelClasses.size());
-
-
-            // This code may throw a RealmMigrationNeededException
-            //noinspection CaughtExceptionImmediatelyRethrown
-            try {
-                for (Class<? extends RealmModel> clazz : modelClasses) {
-                    final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
-                    String className = Table.getClassNameForTable(mediator.getTableName(clazz));
-                    Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(clazz, className);
-                    map.put(key, columnInfo);
-                }
-            } catch (RealmMigrationNeededException e) {
-                throw e;
-            }
-
-            cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
-        }
-        schema.updateColumnIndices(cacheForCurrentVersion);
-        return createdGlobalCache;
-    }
-
     /**
      * Returns the default Realm module. This module contains all Realm classes in the current project, but not those
      * from library or project dependencies. Realm classes in these should be exposed using their own module.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 2c46b59fc8..1528639988 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -32,11 +32,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import javax.annotation.Nullable;
-
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.Capabilities;
-import io.realm.internal.ColumnIndices;
 import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.SharedRealm;
@@ -198,11 +195,6 @@ public void run() {
     // doCreateRealmOrGetFromCache is called with globalCount == 0.
     private RealmConfiguration configuration;
 
-    // Column indices are cached to speed up opening typed Realm. If a Realm instance is created in one thread, creating
-    // Realm instances in other threads doesn't have to initialize the column indices again.
-    private static final int MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY = 4;
-    private final ColumnIndices[] typedColumnIndicesArray = new ColumnIndices[MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY];
-
     // Realm path will be used to identify different RealmCaches. Different Realm configurations with same path
     // are not allowed and an exception will be thrown when trying to add it to the cache list.
     // A weak ref is used to hold the RealmCache instance. The weak ref entry will be cleared if and only if there
@@ -359,10 +351,6 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
             refAndCount.localRealm.set(realm);
             refAndCount.localCount.set(0);
 
-            if (realmClass == Realm.class && refAndCount.globalCount == 0) {
-                // Stores a copy of local ColumnIndices as a global cache.
-                RealmCache.storeColumnIndices(typedColumnIndicesArray, realm.getSchema().getImmutableColumnIndices());
-            }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
         }
@@ -410,12 +398,6 @@ synchronized void release(BaseRealm realm) {
                         " got corrupted.");
             }
 
-            // Clears the column indices cache if needed.
-            if (realm instanceof Realm && refAndCount.globalCount == 0) {
-                // All typed Realm instances of this file are cleared from cache.
-                Arrays.fill(typedColumnIndicesArray, null);
-            }
-
             // No more local reference to this Realm in current thread, close the instance.
             realm.doClose();
 
@@ -495,25 +477,6 @@ private synchronized void doInvokeWithGlobalRefCount(Callback callback) {
         callback.onResult(getTotalGlobalRefCount());
     }
 
-    /**
-     * Updates the schema cache in the typed Realm for {@code pathOfRealm}.
-     *
-     * @param realm the instance that contains the schema cache to be updated.
-     */
-    synchronized void updateSchemaCache(Realm realm) {
-        final RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.TYPED_REALM);
-        if (refAndCount.localRealm.get() == null) {
-            // Called during initialization. just skip it.
-            // We can reach here if the DynamicRealm instance is initialized first.
-            return;
-        }
-        final ColumnIndices[] globalCacheArray = typedColumnIndicesArray;
-        final ColumnIndices createdCacheEntry = realm.updateSchemaCache(globalCacheArray);
-        if (createdCacheEntry != null) {
-            RealmCache.storeColumnIndices(globalCacheArray, createdCacheEntry);
-        }
-    }
-
     /**
      * Runs the callback function with synchronization on {@link RealmCache}.
      *
@@ -614,62 +577,10 @@ static int getLocalThreadCount(RealmConfiguration configuration) {
         return totalRefCount;
     }
 
-    /**
-     * Finds an entry for specified schema version in the array.
-     *
-     * @param array target array of schema cache.
-     * @param schemaVersion requested version of the schema.
-     * @return {@link ColumnIndices} instance for specified schema version. {@code null} if not found.
-     */
-    @Nullable
-    static ColumnIndices findColumnIndices(ColumnIndices[] array, long schemaVersion) {
-        for (int i = array.length - 1; 0 <= i; i--) {
-            final ColumnIndices candidate = array[i];
-            if (candidate != null && candidate.getSchemaVersion() == schemaVersion) {
-                return candidate;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Stores the schema cache to the array.
-     * <p>
-     * If the {@code array} has an empty slot ({@code == null}), this method stores
-     * the {@code columnIndices} to it. Otherwise, the entry of the oldest schema version is
-     * replaced.
-     *
-     * @param array target array.
-     * @param columnIndices the item to be stored into the {@code array}.
-     * @return the index in the {@code array} where the {@code columnIndices} was stored.
-     */
-    private static int storeColumnIndices(ColumnIndices[] array, ColumnIndices columnIndices) {
-        long oldestSchemaVersion = Long.MAX_VALUE;
-        int candidateIndex = -1;
-        for (int i = array.length - 1; 0 <= i; i--) {
-            if (array[i] == null) {
-                array[i] = columnIndices;
-                return i;
-            }
-
-            ColumnIndices target = array[i];
-            if (target.getSchemaVersion() <= oldestSchemaVersion) {
-                oldestSchemaVersion = target.getSchemaVersion();
-                candidateIndex = i;
-            }
-        }
-        array[candidateIndex] = columnIndices;
-        return candidateIndex;
-    }
-
     public RealmConfiguration getConfiguration() {
         return configuration;
     }
 
-    public ColumnIndices[] getTypedColumnIndicesArray() {
-        return typedColumnIndicesArray;
-    }
-
     /**
      * @return the total global ref count.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 447db4b67c..4504abbc05 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -33,9 +33,9 @@
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
+import io.realm.internal.OsRealmConfig;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.SharedRealm;
 import io.realm.internal.Util;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
@@ -95,7 +95,7 @@
     private final long schemaVersion;
     private final RealmMigration migration;
     private final boolean deleteRealmIfMigrationNeeded;
-    private final SharedRealm.Durability durability;
+    private final OsRealmConfig.Durability durability;
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
@@ -112,7 +112,7 @@ protected RealmConfiguration(File realmDirectory,
             long schemaVersion,
             @Nullable RealmMigration migration,
             boolean deleteRealmIfMigrationNeeded,
-            SharedRealm.Durability durability,
+            OsRealmConfig.Durability durability,
             RealmProxyMediator schemaMediator,
             @Nullable RxObservableFactory rxObservableFactory,
             @Nullable Realm.Transaction initialDataTransaction,
@@ -158,7 +158,7 @@ public boolean shouldDeleteRealmIfMigrationNeeded() {
         return deleteRealmIfMigrationNeeded;
     }
 
-    public SharedRealm.Durability getDurability() {
+    public OsRealmConfig.Durability getDurability() {
         return durability;
     }
 
@@ -167,7 +167,8 @@ public boolean shouldDeleteRealmIfMigrationNeeded() {
      *
      * @return the mediator of the schema.
      */
-    RealmProxyMediator getSchemaMediator() {
+    // Protected for testing with mockito.
+    protected RealmProxyMediator getSchemaMediator() {
         return schemaMediator;
     }
 
@@ -435,7 +436,7 @@ boolean isSyncConfiguration() {
         private long schemaVersion;
         private RealmMigration migration;
         private boolean deleteRealmIfMigrationNeeded;
-        private SharedRealm.Durability durability;
+        private OsRealmConfig.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
         private RxObservableFactory rxFactory;
@@ -471,7 +472,7 @@ private void initializeBuilder(Context context) {
             this.schemaVersion = 0;
             this.migration = null;
             this.deleteRealmIfMigrationNeeded = false;
-            this.durability = SharedRealm.Durability.FULL;
+            this.durability = OsRealmConfig.Durability.FULL;
             this.readOnly = false;
             this.compactOnLaunch = null;
             if (DEFAULT_MODULE != null) {
@@ -600,7 +601,7 @@ public Builder inMemory() {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
 
-            this.durability = SharedRealm.Durability.MEM_ONLY;
+            this.durability = OsRealmConfig.Durability.MEM_ONLY;
 
             return this;
         }
@@ -674,7 +675,7 @@ public Builder assetFile(String assetFile) {
             if (Util.isEmptyString(assetFile)) {
                 throw new IllegalArgumentException("A non-empty asset file path must be provided");
             }
-            if (durability == SharedRealm.Durability.MEM_ONLY) {
+            if (durability == OsRealmConfig.Durability.MEM_ONLY) {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
             if (this.deleteRealmIfMigrationNeeded) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 0dffffed31..2f716193d8 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -55,13 +55,14 @@
 
     final BaseRealm realm;
     // Cached field look up
-    private ColumnIndices columnIndices;
+    private final ColumnIndices columnIndices;
 
     /**
      * Creates a wrapper to easily manipulate the current schema of a Realm.
      */
-    RealmSchema(BaseRealm realm) {
+    RealmSchema(BaseRealm realm, @Nullable ColumnIndices columnIndices) {
         this.realm = realm;
+        this.columnIndices = columnIndices;
     }
 
     /**
@@ -92,7 +93,7 @@ public void close() {
         int tableCount = (int) realm.getSharedRealm().size();
         Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
         for (int i = 0; i < tableCount; i++) {
-            RealmObjectSchema objectSchema = get(realm.getSharedRealm().getTableName(i));
+            RealmObjectSchema objectSchema = get(Table.getClassNameForTable(realm.getSharedRealm().getTableName(i)));
             if (objectSchema != null) {
                 schemas.add(objectSchema);
             }
@@ -221,68 +222,14 @@ RealmObjectSchema getSchemaForClass(String className) {
         return dynamicSchema;
     }
 
-    /**
-     * Set the column index cache for this schema.
-     *
-     * @param columnIndices the column index cache
-     */
-    final void setInitialColumnIndices(ColumnIndices columnIndices) {
-        if (this.columnIndices != null) {
-            throw new IllegalStateException("An instance of ColumnIndices is already set.");
-        }
-        this.columnIndices = new ColumnIndices(columnIndices, true);
-    }
-
-    /**
-     * Set the column index cache for this schema.
-     *
-     * @param version the schema version
-     * @param columnInfoMap the column info map
-     */
-    final void setInitialColumnIndices(long version, Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> columnInfoMap) {
-        if (this.columnIndices != null) {
-            throw new IllegalStateException("An instance of ColumnIndices is already set.");
-        }
-        columnIndices = new ColumnIndices(version, columnInfoMap);
-    }
-
-    /**
-     * Updates all {@link ColumnInfo} elements in {@code columnIndices}.
-     * <p>
-     * The ColumnInfo elements are shared between all {@link RealmObject}s created by the Realm instance
-     * which owns this RealmSchema. Updating them also means updating indices information in those {@link RealmObject}s.
-     *
-     * @param schemaVersion new schema version.
-     */
-    void updateColumnIndices(ColumnIndices schemaVersion) {
-        columnIndices.copyFrom(schemaVersion);
-    }
-
     private boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
         return modelClass.equals(testee);
     }
 
-    /**
-     * Sometimes you need ColumnIndicies that can be passed between threads.
-     * Setting the mutable flag false creates an instance that is effectively final.
-     *
-     * @return a new, thread-safe copy of this Schema's ColumnIndices.
-     * @see ColumnIndices for the effectively final contract.
-     */
-    final ColumnIndices getImmutableColumnIndices() {
-        checkIndices();
-        return new ColumnIndices(columnIndices, false);
-    }
-
     final boolean haveColumnInfo() {
         return columnIndices != null;
     }
 
-    final long getSchemaVersion() {
-        checkIndices();
-        return columnIndices.getSchemaVersion();
-    }
-
     final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
         checkIndices();
         return columnIndices.getColumnInfo(clazz);
@@ -306,4 +253,17 @@ private void checkIndices() {
             throw new IllegalStateException("Attempt to use column index before set.");
         }
     }
+
+    /**
+     * Called when schema changed. Clear all cached tables and refresh column indices.
+     */
+    void refresh() {
+        if (columnIndices != null) {
+            columnIndices.refresh();
+        }
+        dynamicClassToTable.clear();
+        classToTable.clear();
+        classToSchema.clear();
+        dynamicClassToSchema.clear();
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
index 9c8b567a24..53bd85bef6 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
@@ -23,6 +23,7 @@
 import io.realm.internal.Keep;
 
 
+// Constructed from JNI
 @Keep
 public final class RealmMigrationNeededException extends RuntimeException {
 
@@ -33,11 +34,6 @@ public RealmMigrationNeededException(String canonicalRealmPath, String detailMes
         this.canonicalRealmPath = canonicalRealmPath;
     }
 
-    public RealmMigrationNeededException(String canonicalRealmPath, String detailMessage, @Nullable Throwable throwable) {
-        super(detailMessage, throwable);
-        this.canonicalRealmPath = canonicalRealmPath;
-    }
-
     /**
      * Returns the canonical path to the Realm file that needs to be migrated.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 0081185c55..d391154a9a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -16,17 +16,22 @@
 
 package io.realm.internal;
 
+
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
+import java.util.Set;
 
-import javax.annotation.Nullable;
+import javax.annotation.Nonnull;
 
 import io.realm.RealmModel;
-import io.realm.internal.util.Pair;
-
+import io.realm.exceptions.RealmException;
 
 /**
- * Utility class used to cache the mapping between object field names and their column indices.
+ * Utility class used to cache the mapping between object field names and their column indices. The
+ * {@code ColumnIndices} instance is dedicated to a single {@link io.realm.BaseRealm} instance. Different Realm
+ * instances will never share the same column indices cache. The column info cache is loaded lazily. A
+ * {@link ColumnInfo} will be added to the cache when the relevant Realm object gets accessed.
  * <p>
  * This class can be mutated, after construction, in two ways:
  * <ul>
@@ -42,129 +47,91 @@
  * class lookup is very fast and on a hot path, so we maintain the redundant table.
  */
 public final class ColumnIndices {
-    // MultiKeyMap of <Class, String> -> ColumnInfo
-    // Right now we maintain 3 copies. One public and 2 internal ones.
-    private final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> classesToColumnInfo;
-    private final Map<Class<? extends RealmModel>, ColumnInfo> classes;
-    private final Map<String, ColumnInfo> classesByName;
+    // Class to ColumnInfo map
+    private final Map<Class<? extends RealmModel>, ColumnInfo> classToColumnInfoMap =
+            new HashMap<Class<? extends RealmModel>, ColumnInfo>();
+    // Class name to ColumnInfo map. All the elements in this map should be existing in classToColumnInfoMap.
+    private final Map<String, ColumnInfo> simpleClassNameToColumnInfoMap =
+            new HashMap<String, ColumnInfo>();
 
-    private final boolean mutable;
-    private long schemaVersion;
-
-    /**
-     * Create a mutable ColumnIndices initialized with the ColumnInfo objects in the passed map.
-     *
-     * @param schemaVersion the schema version
-     * @param classesMap a map of table classes to their column info
-     * @throws IllegalArgumentException if any of the ColumnInfo object is immutable.
-     */
-    public ColumnIndices(long schemaVersion, Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> classesMap) {
-        this(schemaVersion, new HashMap<>(classesMap), true);
-        for (Map.Entry<Pair<Class<? extends RealmModel>, String>, ColumnInfo> entry : classesMap.entrySet()) {
-            ColumnInfo columnInfo = entry.getValue();
-            if (mutable != columnInfo.isMutable()) {
-                throw new IllegalArgumentException("ColumnInfo mutability does not match ColumnIndices");
-            }
-            Pair<Class<? extends RealmModel>, String> classDescription = entry.getKey();
-            this.classes.put(classDescription.first, columnInfo);
-            this.classesByName.put(classDescription.second, columnInfo);
-        }
-    }
-
-    /**
-     * Create a copy of the passed ColumnIndices with the specified mutability.
-     *
-     * @param other the ColumnIndices object to copy
-     * @param mutable if false the object is effectively final.
-     */
-    public ColumnIndices(ColumnIndices other, boolean mutable) {
-        this(other.schemaVersion, new HashMap<Pair<Class<? extends RealmModel>, String>, ColumnInfo>(other.classesToColumnInfo.size()), mutable);
-        for (Map.Entry<Pair<Class<? extends RealmModel>, String>, ColumnInfo> entry : other.classesToColumnInfo.entrySet()) {
-            ColumnInfo columnInfo = entry.getValue().copy(mutable);
-            Pair<Class<? extends RealmModel>, String> key = entry.getKey();
-            this.classes.put(key.first, columnInfo);
-            this.classesByName.put(key.second, columnInfo);
-            this.classesToColumnInfo.put(key, columnInfo);
-        }
-    }
+    private final RealmProxyMediator mediator;
+    // Due to the nature of Object Store's Realm::m_schema, SharedRealm's OsObjectSchemaInfo object is fixed after set.
+    private final OsSchemaInfo osSchemaInfo;
 
-    private ColumnIndices(long schemaVersion, Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> classesMap, boolean mutable) {
-        this.schemaVersion = schemaVersion;
-        this.classesToColumnInfo = classesMap;
-        this.mutable = mutable;
-        this.classes = new HashMap<>(classesMap.size());
-        this.classesByName = new HashMap<>(classesMap.size());
-    }
 
     /**
-     * Get the schema version.
+     * Create a mutable ColumnIndices initialized with the ColumnInfo objects in the passed map.
      *
-     * @return the schema version.
+     * @param mediator the {@link RealmProxyMediator} used for the corresponding Realm.
+     * @param osSchemaInfo the corresponding Realm's {@link OsSchemaInfo}.
      */
-    public long getSchemaVersion() {
-        return schemaVersion;
+    public ColumnIndices(RealmProxyMediator mediator, OsSchemaInfo osSchemaInfo) {
+        this.mediator = mediator;
+        this.osSchemaInfo = osSchemaInfo;
     }
 
     /**
-     * Returns the {@link ColumnInfo} for the passed class or ({@code null} if there is no such class).
+     * Returns the {@link ColumnInfo} for the passed class.
      *
      * @param clazz the class for which to get the ColumnInfo.
-     * @return the corresponding {@link ColumnInfo} object, or {@code null} if not found.
+     * @return the corresponding {@link ColumnInfo} object.
+     * @throws io.realm.exceptions.RealmException if the class cannot be found in the schema.
      */
-    @Nullable
+    @Nonnull
     public ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
-        return classes.get(clazz);
+        ColumnInfo columnInfo = classToColumnInfoMap.get(clazz);
+        if (columnInfo == null) {
+            columnInfo = mediator.createColumnInfo(clazz, osSchemaInfo);
+            classToColumnInfoMap.put(clazz, columnInfo);
+        }
+        return columnInfo;
     }
 
     /**
-     * Returns the {@link ColumnInfo} for the passed class ({@code null} if there is no such class).
+     * Returns the {@link ColumnInfo} for the passed class name.
      *
-     * @param className the simple name of the class for which to get the ColumnInfo.
-     * @return the corresponding {@link ColumnInfo} object, or {@code null} if not found.
+     * @param simpleClassName the simple name of the class for which to get the ColumnInfo.
+     * @return the corresponding {@link ColumnInfo} object.
+     * @throws io.realm.exceptions.RealmException if the class cannot be found in the schema.
      */
-    @Nullable
-    public ColumnInfo getColumnInfo(String className) {
-        return classesByName.get(className);
+    @Nonnull
+    public ColumnInfo getColumnInfo(String simpleClassName) {
+        ColumnInfo columnInfo = simpleClassNameToColumnInfoMap.get(simpleClassName);
+        if (columnInfo == null) {
+            Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
+            for (Class<? extends RealmModel> modelClass : modelClasses) {
+                if (modelClass.getSimpleName().equals(simpleClassName)) {
+                    columnInfo = getColumnInfo(modelClass);
+                    simpleClassNameToColumnInfoMap.put(simpleClassName, columnInfo);
+                    break;
+                }
+            }
+        }
+        if (columnInfo == null) {
+            throw new RealmException(
+                    String.format(Locale.US, "'%s' doesn't exist in current schema.", simpleClassName));
+        }
+        return columnInfo;
     }
 
     /**
-     * Make this instance contain a (non-strict) subset of the data in the passed ColumnIndices.
-     * The schemaVersion and every ColumnInfo object held by this instance will be updated to be
-     * the same the corresponding data in the passed instance or IllegalStateException will be thrown.
-     * It is allowable for the passed ColumnIndices to contain information this instance does not.
-     * <p>
-     * NOTE: copying does not change this instance's mutability state.
-     *
-     * @param src the instance to copy.
-     * @throws UnsupportedOperationException if this instance is immutable.
-     * @throws IllegalStateException if this object contains information for a table that the source does not.
+     * Refreshes all the existing {@link ColumnInfo} in the cache.
      */
-    public void copyFrom(ColumnIndices src) {
-        if (!mutable) {
-            throw new UnsupportedOperationException("Attempt to modify immutable cache");
+    public void refresh() {
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classToColumnInfoMap.entrySet()) {
+            ColumnInfo newColumnInfo = mediator.createColumnInfo(entry.getKey(), osSchemaInfo);
+            entry.getValue().copyFrom(newColumnInfo);
         }
-        for (Map.Entry<String, ColumnInfo> entry : classesByName.entrySet()) {
-            final ColumnInfo otherColumnInfo = src.classesByName.get(entry.getKey());
-            if (otherColumnInfo == null) {
-                throw new IllegalStateException("Failed to copy ColumnIndices cache for class: " + entry.getKey());
-            }
-            entry.getValue().copyFrom(otherColumnInfo);
-        }
-        this.schemaVersion = src.schemaVersion;
     }
 
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder("ColumnIndices[");
-        buf.append(schemaVersion).append(",");
-        buf.append(mutable).append(",");
-        if (classes != null) {
-            boolean commaNeeded = false;
-            for (Map.Entry<String, ColumnInfo> entry : classesByName.entrySet()) {
-                if (commaNeeded) { buf.append(","); }
-                buf.append(entry.getKey()).append("->").append(entry.getValue());
-                commaNeeded = true;
-            }
+        boolean commaNeeded = false;
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classToColumnInfoMap.entrySet()) {
+            if (commaNeeded) { buf.append(","); }
+            buf.append(entry.getKey().getSimpleName()).append("->").append(entry.getValue());
+            commaNeeded = true;
         }
         return buf.append("]").toString();
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index 9b33e12029..c56343a1fa 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -25,13 +25,14 @@
 
 
 /**
- * Objects of this class play two roles:
- * <ul>
- * <li>Subclasses are a fast cache of column indices, for proxy object</li>
- * <li>They cache table (schema) information used by for StandardRealmObjectSchema and StandardRealmSchema</li>
- * </ul>
+ * The Subclasses of this are a fast cache of column indices, for proxy object.
+ * <p>
  * The fast cache functionality is implemented in the Proxy classes generated by {@code RealmProxyClassGenerator}.
- * Be sure to understand what is going on there, before changing things here.
+ * Every proxy object will hold an reference of its {@code ColumnInfo}. The ref to the {@code ColumnInfo} instance is
+ * maintained by the {@link ColumnIndices}. As long as the reference in proxy object has been set, it should never be
+ * changed. When schema changes, the relevant {@code ColumnInfo} instance's content will be refreshed therefore the
+ * proxy object could have the latest column indices. Be sure to understand what is going on there,
+ * before changing things here.
  * <p>
  * While the use of the fields in {@code ColumnDetails} is consistent, there are three subtly different cases:
  * <ul>
@@ -40,9 +41,9 @@
  * <li>If the column type is LINKING_OBJECT, the {@code linkedClassName} field is the class name of the backlink source table
  * and the column index field is the index of the backlink source field, in the source table</li>
  * </ul>
- *
  * <p>
- * Some instances of this class must be thread-safe.  The class support effectively-final semantics.
+ * The instance of this class is dedicated to a single {@link SharedRealm} instance. Thus this is not supposed to be
+ * used across threads.
  * An instance can be mutated, after construction, in four ways:
  * <ul>
  * <li>the {@code copyFrom} method</li>
@@ -67,13 +68,17 @@
         public final RealmFieldType columnType;
         public final String linkedClassName;
 
-        ColumnDetails(long columnIndex, RealmFieldType columnType, @Nullable String linkedClassName) {
+        private ColumnDetails(long columnIndex, RealmFieldType columnType, @Nullable String linkedClassName) {
             // invariant: (columnType == OBJECT || columnType == LIST || columnType == LINKING_OBJECTS) == (linkedClassName != null)
             this.columnIndex = columnIndex;
             this.columnType = columnType;
             this.linkedClassName = linkedClassName;
         }
 
+        ColumnDetails(Property property) {
+            this(property.getColumnIndex(), property.getType(), property.getLinkedObjectName());
+        }
+
         @Override
         public String toString() {
             StringBuilder buf = new StringBuilder("ColumnDetails[");
@@ -207,23 +212,14 @@ public String toString() {
      * <p>
      * No validation done here.  Presuming that all necessary validation takes place in {@code Proxy.validateTable}.
      *
-     * @param table The table to search for the column.
      * @param columnName The name of the column whose index is sought.
-     * @param columnType Type RealmType of the column.
+     * @param objectSchemaInfo the {@link OsObjectSchemaInfo} for the corresponding {@code RealmObject}.
      * @return the index of the column in the table
      */
-    @SuppressWarnings("unused")
-    protected final long addColumnDetails(Table table, String columnName, RealmFieldType columnType) {
-        long columnIndex = table.getColumnIndex(columnName);
-        if (columnIndex >= 0) {
-            String linkedTableName = ((columnType != RealmFieldType.OBJECT) && (columnType != RealmFieldType.LIST))
-                    ? null
-                    : table.getLinkTarget(columnIndex).getClassName();
-
-            indicesMap.put(columnName, new ColumnDetails(columnIndex, columnType, linkedTableName));
-        }
-
-        return columnIndex;
+    protected final long addColumnDetails(String columnName, OsObjectSchemaInfo objectSchemaInfo) {
+        Property property = objectSchemaInfo.getProperty(columnName);
+        indicesMap.put(columnName, new ColumnDetails(property));
+        return property.getColumnIndex();
     }
 
     /**
@@ -231,15 +227,13 @@ protected final long addColumnDetails(Table table, String columnName, RealmField
      * <b>For use only by subclasses!</b>.
      * Must be called from within the subclass constructor, to maintain the effectively-final contract.
      *
-     * @param realm The shared realm.
+     * @param schemaInfo the {@link OsSchemaInfo} of the corresponding {@code Realm} instance.
      * @param columnName The name of the backlink column.
      * @param sourceTableName The name of the backlink source class.
      * @param sourceColumnName The name of the backlink source field.
      */
-    @SuppressWarnings("unused")
-    protected final void addBacklinkDetails(SharedRealm realm, String columnName, String sourceTableName, String sourceColumnName) {
-        Table sourceTable = realm.getTable(Table.getTableNameForClass(sourceTableName));
-        long columnIndex = sourceTable.getColumnIndex(sourceColumnName);
+    protected final void addBacklinkDetails(OsSchemaInfo schemaInfo, String columnName, String sourceTableName, String sourceColumnName) {
+        long columnIndex = schemaInfo.getObjectSchemaInfo(sourceTableName).getProperty(sourceColumnName).getColumnIndex();
         indicesMap.put(columnName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
     }
 
@@ -250,7 +244,6 @@ protected final void addBacklinkDetails(SharedRealm realm, String columnName, St
      * @return the column details map.
      */
     @SuppressWarnings("ReturnOfCollectionOrArrayField")
-    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
     public Map<String, ColumnDetails> getIndicesMap() {
         return indicesMap;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
index 55bb98cd7f..58892d9630 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -30,7 +30,8 @@
 
     public static class Builder {
         private String className;
-        private List<Property> propertyList = new ArrayList<Property>();
+        private List<Property> persistedPropertyList = new ArrayList<Property>();
+        private List<Property> computedPropertyList = new ArrayList<Property>();
 
         /**
          * Creates an empty builder for {@code OsObjectSchemaInfo}. This constructor is intended to be used by
@@ -43,7 +44,7 @@ public Builder(String className) {
         }
 
         /**
-         * Adds a property to this builder.
+         * Adds a persisted non-link property to this builder.
          *
          * @param name the name of the property.
          * @param type the type of the property.
@@ -52,30 +53,51 @@ public Builder(String className) {
          * @param isRequired set to false if this property is not nullable.
          * @return this {@code OsObjectSchemaInfo}.
          */
-        public Builder addProperty(String name, RealmFieldType type, boolean isPrimaryKey, boolean isIndexed,
+        public Builder addPersistedProperty(String name, RealmFieldType type, boolean isPrimaryKey, boolean isIndexed,
                                    boolean isRequired) {
             final Property property = new Property(name, type, isPrimaryKey, isIndexed, isRequired);
-            propertyList.add(property);
+            persistedPropertyList.add(property);
             return this;
         }
 
         /**
-         * Adds a linked property to this {@code OsObjectSchema}.
+         * Adds a persisted link property to this {@code OsObjectSchemaInfo}. A persisted link property will be stored
+         * in the Realm file's schema.
          *
-         * @param name the name of the linked property.
-         * @param type the type of the linked property.
-         * @return this {@code OsObjectSchemaInfo}.
+         * @param name the name of the link property.
+         * @param type the type of the link property. Can only be {@link RealmFieldType#OBJECT} or
+         * {@link RealmFieldType#LIST}.
+         * @return this {@code OsObjectSchemaInfo.Builder}.
          */
-        public Builder addLinkedProperty(String name, RealmFieldType type, String linkedClassName) {
+        public Builder addPersistedLinkProperty(String name, RealmFieldType type, String linkedClassName) {
             final Property property = new Property(name, type, linkedClassName);
-            propertyList.add(property);
+            persistedPropertyList.add(property);
+            return this;
+        }
+
+        /**
+         * Adds a computed link property to this {@code OsObjectSchemaInfo}. A computed link property doesn't store
+         * information in the Realm file's schema. This property type will always be
+         * {@link RealmFieldType#LINKING_OBJECTS}.
+         *
+         * @param name the name of the link property.
+         * @param targetClassname The class name of the property links to.
+         * @param targetFieldName The field name of the property links to.
+         * @return this {@code OsObjectSchemaInfo.Builder}.
+         */
+        public Builder addComputedLinkProperty(String name, String targetClassname, String targetFieldName) {
+            final Property property = new Property(name, targetClassname, targetFieldName);
+            computedPropertyList.add(property);
             return this;
         }
 
         public OsObjectSchemaInfo build() {
             OsObjectSchemaInfo info = new OsObjectSchemaInfo(className);
-            for (Property property : propertyList) {
-                nativeAddProperty(info.nativePtr, property.getNativePtr());
+            for (Property property : persistedPropertyList) {
+                nativeAddProperty(info.nativePtr, property.getNativePtr(), false);
+            }
+            for (Property property : computedPropertyList) {
+                nativeAddProperty(info.nativePtr, property.getNativePtr(), true);
             }
 
             return info;
@@ -96,12 +118,12 @@ private OsObjectSchemaInfo(String className) {
     }
 
     /**
-     * Create a java wrapper class for given {@code ObjectSchema} pointer. This java wrapper will take the ownership of
+     * Creates a java wrapper class for given {@code ObjectSchema} pointer. This java wrapper will take the ownership of
      * the object's memory and release it through phantom reference.
      *
      * @param nativePtr pointer to the {@code ObjectSchema} object.
      */
-    private OsObjectSchemaInfo(long nativePtr) {
+    OsObjectSchemaInfo(long nativePtr) {
         this.nativePtr = nativePtr;
         NativeContext.dummyContext.addReference(this);
     }
@@ -113,6 +135,16 @@ public String getClassName() {
         return nativeGetClassName(nativePtr);
     }
 
+    /**
+     * Returns a property by the given name.
+     *
+     * @param propertyName the name of the property.
+     * @return a {@link Property} object.
+     */
+    public Property getProperty(String propertyName) {
+        return new Property(nativeGetProperty(nativePtr, propertyName));
+    }
+
     @Override
     public long getNativePtr() {
         return nativePtr;
@@ -127,7 +159,10 @@ public long getNativeFinalizerPtr() {
 
     private static native long nativeGetFinalizerPtr();
 
-    private static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
+    private static native void nativeAddProperty(long nativePtr, long nativePropertyPtr, boolean isComputed);
 
     private static native String nativeGetClassName(long nativePtr);
+
+    // Throw ISE if the property doesn't exist.
+    private static native long nativeGetProperty(long nativePtr, String propertyName);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
new file mode 100644
index 0000000000..bd4c16656b
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.CompactOnLaunchCallback;
+import io.realm.RealmConfiguration;
+
+/**
+ * Java wrapper of Object Store's Realm::Config.
+ */
+public class OsRealmConfig implements NativeObject {
+
+    public enum Durability {
+        FULL(0),
+        MEM_ONLY(1);
+
+        final int value;
+
+        Durability(int value) {
+            this.value = value;
+        }
+    }
+
+    public enum SchemaMode {
+        SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
+        SCHEMA_MODE_IMMUTABLE(SCHEMA_MODE_VALUE_IMMUTABLE),
+        SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
+        SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
+        SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
+        SCHEMA_MODE_MANUAL(SCHEMA_MODE_VALUE_MANUAL);
+
+        final byte value;
+
+        SchemaMode(byte value) {
+            this.value = value;
+        }
+
+        public byte getNativeValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Builder class for creating {@code OsRealmConfig}. The {@code OsRealmConfig} instance should only be created by
+     * {@link SharedRealm}.
+     */
+    public static class Builder {
+        private RealmConfiguration configuration;
+        private OsSchemaInfo schemaInfo = null;
+        private SharedRealm.MigrationCallback migrationCallback = null;
+        private SharedRealm.InitializationCallback initializationCallback = null;
+        private boolean autoUpdateNotification = false;
+
+        /**
+         * Initialize a {@link OsRealmConfig.Builder} with a given {@link RealmConfiguration}.
+         */
+        public Builder(RealmConfiguration configuration) {
+            this.configuration = configuration;
+        }
+
+        /**
+         * Sets the schema which Object Store initializes the Realm with.
+         *
+         * @param schemaInfo {@code null} to initialize the Realm in dynamic schema mode. Otherwise Object Store will
+         *                   initialize the Realm with given schema and handle migration with it.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder schemaInfo(@Nullable OsSchemaInfo schemaInfo) {
+            this.schemaInfo = schemaInfo;
+            return this;
+        }
+
+        /**
+         * Sets the callback when manual migration needed.
+         *
+         * @param migrationCallback callback to be set.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder migrationCallback(@Nullable SharedRealm.MigrationCallback migrationCallback) {
+            this.migrationCallback = migrationCallback;
+            return this;
+        }
+
+        /**
+         * Sets the callback which will be called when the Realm is created and the schema has just been initialized.
+         *
+         * @param initializationCallback the callback to be set.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder initializationCallback(@Nullable SharedRealm.InitializationCallback initializationCallback) {
+            this.initializationCallback = initializationCallback;
+            return this;
+        }
+
+        /**
+         * Set to {@code false} to disable the background worker thread for producing change notifications. Change
+         * notifications are enabled by default.
+         *
+         * @param autoUpdateNotification {@code false} to disable. {@code true} to enable it.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder autoUpdateNotification(boolean autoUpdateNotification) {
+            this.autoUpdateNotification = autoUpdateNotification;
+            return this;
+        }
+
+        // Package private because of the OsRealmConfig needs to carry the NativeContext. This should only be called
+        // by the SharedRealm.
+        OsRealmConfig build() {
+            return new OsRealmConfig(configuration, autoUpdateNotification, schemaInfo,
+                    migrationCallback, initializationCallback);
+        }
+    }
+
+    private static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
+    private static final byte SCHEMA_MODE_VALUE_IMMUTABLE = 1;
+    private static final byte SCHEMA_MODE_VALUE_READONLY = 2;
+    private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 3;
+    private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 4;
+    private static final byte SCHEMA_MODE_VALUE_MANUAL = 5;
+
+    private final static long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    private final RealmConfiguration realmConfiguration;
+    private final long nativePtr;
+    // Every SharedRealm instance has to be created from an OsRealmConfig instance. And the SharedRealm's NativeContext
+    // object will be the same as the context here. This is because of we may create different SharedRealm instances
+    // with different shared_ptrs which are point to the same SharedGroup object. It could happen when we create
+    // SharedRealm for migration/initialization callback. The context has to be the same object for those cases for
+    // core destructor's thread safety.
+    private final NativeContext context = new NativeContext();
+
+    private OsRealmConfig(final RealmConfiguration config,
+                          boolean autoUpdateNotification,
+                          @Nullable OsSchemaInfo schemaInfo,
+                          @Nullable SharedRealm.MigrationCallback migrationCallback,
+                          @Nullable SharedRealm.InitializationCallback initializationCallback) {
+        this.realmConfiguration = config;
+        this.nativePtr = nativeCreate(config.getPath(), false, true);
+        NativeContext.dummyContext.addReference(this);
+
+        // Retrieve Sync settings first. We need syncRealmUrl to identify if this is a SyncConfig
+        Object[] syncUserConf = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(realmConfiguration);
+        String syncUserIdentifier = (String) syncUserConf[0];
+        String syncRealmUrl = (String) syncUserConf[1];
+        String syncRealmAuthUrl = (String) syncUserConf[2];
+        String syncRefreshToken = (String) syncUserConf[3];
+        boolean syncClientValidateSsl = (Boolean.TRUE.equals(syncUserConf[4]));
+        String syncSslTrustCertificatePath = (String) syncUserConf[5];
+
+        // Set encryption key
+        byte[] key = config.getEncryptionKey();
+        if (key != null) {
+            nativeSetEncryptionKey(nativePtr, key);
+        }
+
+        // Set durability
+        nativeSetInMemory(nativePtr, config.getDurability() == Durability.MEM_ONLY);
+
+        // Set auto update notification
+        nativeEnableChangeNotification(nativePtr, autoUpdateNotification);
+
+        // Set schema related params.
+        SchemaMode schemaMode = SchemaMode.SCHEMA_MODE_MANUAL;
+        if (config.isReadOnly()) {
+            schemaMode = SchemaMode.SCHEMA_MODE_READONLY;
+        } else if (syncRealmUrl != null) {
+            schemaMode = SchemaMode.SCHEMA_MODE_ADDITIVE;
+        } else if (config.shouldDeleteRealmIfMigrationNeeded()) {
+            schemaMode = SchemaMode.SCHEMA_MODE_RESET_FILE;
+        }
+        final long schemaVersion = config.getSchemaVersion();
+        final long nativeSchemaPtr = schemaInfo == null ? 0 : schemaInfo.getNativePtr();
+        nativeSetSchemaConfig(nativePtr, schemaMode.getNativeValue(), schemaVersion, nativeSchemaPtr, migrationCallback);
+
+        // Compact on launch
+        CompactOnLaunchCallback compactOnLaunchCallback = config.getCompactOnLaunchCallback();
+        if (compactOnLaunchCallback != null) {
+            nativeSetCompactOnLaunchCallback(nativePtr, compactOnLaunchCallback);
+        }
+
+        // Initial data transaction
+        if (initializationCallback != null) {
+            nativeSetInitializationCallback(nativePtr, initializationCallback);
+        }
+
+        // Set sync config
+        if (syncRealmUrl != null) {
+            nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
+                    syncRefreshToken);
+            nativeSetSyncConfigSslSettings(nativePtr, syncClientValidateSsl, syncSslTrustCertificatePath);
+        }
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public RealmConfiguration getRealmConfiguration() {
+        return realmConfiguration;
+    }
+
+    NativeContext getContext() {
+        return context;
+    }
+
+    private static native long nativeCreate(String path, boolean enableCache, boolean enableFormatUpdate);
+
+    private static native void nativeSetEncryptionKey(long nativePtr, byte[] key);
+
+    private static native void nativeSetInMemory(long nativePtr, boolean inMem);
+
+    private native void nativeSetSchemaConfig(long nativePtr, byte schemaMode, long schemaVersion,
+                                              long schemaInfoPtr,
+                                              @Nullable SharedRealm.MigrationCallback migrationCallback);
+
+    private static native void nativeSetCompactOnLaunchCallback(long nativePtr, CompactOnLaunchCallback callback);
+
+    private native void nativeSetInitializationCallback(long nativePtr, SharedRealm.InitializationCallback callback);
+
+    private static native void nativeEnableChangeNotification(long nativePtr, boolean enableNotification);
+
+    private static native void nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl,
+                                                            String authUrl, String userId, String refreshToken);
+
+    private static native void nativeSetSyncConfigSslSettings(long nativePtr,
+                                                              boolean validateSsl, String trustCertificatePath);
+
+    private static native long nativeGetFinalizerPtr();
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
index f59f750010..4585c514b5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
@@ -28,21 +28,50 @@
 public class OsSchemaInfo implements NativeObject {
     private long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    // Hold the ref to the SharedRealm to ensure the SharedRealm won't be freed before this gets GCed.
+    @SuppressWarnings("unused")
+    private final SharedRealm sharedRealm;
 
     /**
-     * Construct a {@code OsSchemaInfo} object from a given {@code OsObjectSchemaInfo} list.
+     * Constructs a {@code OsSchemaInfo} object from a given {@code OsObjectSchemaInfo} list.
      *
      * @param objectSchemaInfoList all the object schemas should be contained in this {@code OsObjectSchemaInfo}.
      */
     public OsSchemaInfo(java.util.Collection<OsObjectSchemaInfo> objectSchemaInfoList) {
+        this.nativePtr = nativeCreateFromList(convertObjectSchemaInfoListToNativePointerArray(objectSchemaInfoList));
+        NativeContext.dummyContext.addReference(this);
+        this.sharedRealm = null;
+    }
+
+    /**
+     * Constructs a {@code OsSchemaInfo} and bind its life cycle with the given {@code ShareRealm}. The native pointer
+     * held by this instance points to the reference of ObjectStore's {@code Realm::m_schema}. It will be valid
+     * as long as the {@code SharedRealm} instance is not GCed.
+     * <p>
+     * This should only be called by {@link SharedRealm}.
+     *
+     * @param nativePtr the pointer to the Object Store's {@code Realm::m_schema}.
+     * @param sharedRealm the {@code SharedRealm} instance which is owning the schema object.
+     */
+    OsSchemaInfo(long nativePtr, SharedRealm sharedRealm) {
+        this.nativePtr = nativePtr;
+        this.sharedRealm = sharedRealm;
+    }
+
+    private static long[] convertObjectSchemaInfoListToNativePointerArray(
+            java.util.Collection<OsObjectSchemaInfo> objectSchemaInfoList) {
         long[] schemaNativePointers = new long[objectSchemaInfoList.size()];
         int i = 0;
         for (OsObjectSchemaInfo info : objectSchemaInfoList) {
             schemaNativePointers[i] = info.getNativePtr();
             i++;
         }
-        this.nativePtr = nativeCreateFromList(schemaNativePointers);
-        NativeContext.dummyContext.addReference(this);
+
+        return schemaNativePointers;
+    }
+
+    public OsObjectSchemaInfo getObjectSchemaInfo(String className) {
+        return new OsObjectSchemaInfo(nativeGetObjectSchemaInfo(nativePtr, className));
     }
 
     @Override
@@ -58,4 +87,7 @@ public long getNativeFinalizerPtr() {
     private static native long nativeCreateFromList(long[] objectSchemaPtrs);
 
     private static native long nativeGetFinalizerPtr();
+
+    // Throw ISE if the object schema doesn't exist.
+    private static native long nativeGetObjectSchemaInfo(long nativePtr, String className);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Property.java b/realm/realm-library/src/main/java/io/realm/internal/Property.java
index 9973d54d58..4cb755f768 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Property.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Property.java
@@ -17,6 +17,8 @@
 package io.realm.internal;
 
 
+import java.util.Locale;
+
 import io.realm.RealmFieldType;
 
 
@@ -58,22 +60,24 @@
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
     Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
-        this.nativePtr = nativeCreateProperty(name, convertFromRealmFieldType(type, isRequired), isPrimary, isIndexed);
-        NativeContext.dummyContext.addReference(this);
+        this(nativeCreatePersistedProperty(name, convertFromRealmFieldType(type, isRequired), isPrimary, isIndexed));
     }
 
     Property(String name, RealmFieldType type, String linkedClassName) {
         // Ignore the isRequired when creating the linking property.
-        int propertyType = convertFromRealmFieldType(type, false);
-        this.nativePtr = nativeCreateProperty(name, propertyType, linkedClassName);
-        NativeContext.dummyContext.addReference(this);
+        this(nativeCreatePersistedLinkProperty(name, convertFromRealmFieldType(type, false), linkedClassName));
     }
 
-    protected Property(long nativePtr) {
+    Property(String name, String sourceClassName, String sourceFieldName) {
+        this(nativeCreateComputedLinkProperty(name, sourceClassName, sourceFieldName));
+    }
+
+    Property(long nativePtr) {
         this.nativePtr = nativePtr;
+        NativeContext.dummyContext.addReference(this);
     }
 
-    private int convertFromRealmFieldType(RealmFieldType fieldType, boolean isRequired) {
+    private static int convertFromRealmFieldType(RealmFieldType fieldType, boolean isRequired) {
         int type;
         switch (fieldType) {
             case OBJECT:
@@ -108,13 +112,55 @@ private int convertFromRealmFieldType(RealmFieldType fieldType, boolean isRequir
                 break;
             default:
                 throw new IllegalArgumentException(
-                        String.format("Unsupported filed type: '%s'.", fieldType.name()));
+                        String.format(Locale.US, "Unsupported filed type: '%s'.", fieldType.name()));
 
         }
         int requiredFlag = isRequired ? TYPE_REQUIRED : TYPE_NULLABLE;
         return type | requiredFlag;
     }
 
+    private static RealmFieldType convertToRealmFieldType(int propertyType) {
+        // Clear the nullable flag
+        switch (propertyType & ~TYPE_NULLABLE) {
+            case  TYPE_OBJECT:
+                return RealmFieldType.OBJECT;
+            case TYPE_OBJECT | TYPE_ARRAY:
+                return RealmFieldType.LIST;
+            case TYPE_LINKING_OBJECTS | TYPE_ARRAY:
+                return RealmFieldType.LINKING_OBJECTS;
+            case TYPE_INT:
+                return RealmFieldType.INTEGER;
+            case TYPE_BOOL:
+                return RealmFieldType.BOOLEAN;
+            case TYPE_STRING:
+                return RealmFieldType.STRING;
+            case TYPE_DATA:
+                return RealmFieldType.BINARY;
+            case TYPE_DATE:
+                return RealmFieldType.DATE;
+            case TYPE_FLOAT:
+                return RealmFieldType.FLOAT;
+            case TYPE_DOUBLE:
+                return RealmFieldType.DOUBLE;
+            default:
+                throw new IllegalArgumentException(
+                        String.format(Locale.US, "Unsupported property type: '%d'", propertyType));
+
+        }
+    }
+
+    public RealmFieldType getType() {
+        return convertToRealmFieldType(nativeGetType(nativePtr));
+    }
+
+    public String getLinkedObjectName() {
+        return nativeGetLinkedObjectName(nativePtr);
+    }
+
+    public long getColumnIndex() {
+        return nativeGetColumnIndex(nativePtr);
+    }
+
     @Override
     public long getNativePtr() {
         return nativePtr;
@@ -125,9 +171,20 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    private static native long nativeCreateProperty(String name, int type, boolean isPrimary, boolean isIndexed);
+    private static native long nativeGetFinalizerPtr();
 
-    private static native long nativeCreateProperty(String name, int type, String linkedToName);
+    private static native long nativeCreatePersistedProperty(
+            String name, int type, boolean isPrimary, boolean isIndexed);
 
-    private static native long nativeGetFinalizerPtr();
+    private static native long nativeCreatePersistedLinkProperty(String name, int type, String linkedToName);
+
+    private static native long nativeCreateComputedLinkProperty(
+            String name, String sourceClassName, String sourceFieldName);
+
+    private static native int nativeGetType(long nativePtr);
+
+    private static native long nativeGetColumnIndex(long nativePtr);
+
+    // Return null if the property is not OBJECT, LIST or LINKING_OBJECT type.
+    private static native String nativeGetLinkedObjectName(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 441401487e..54777969ac 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -52,17 +52,13 @@
     public abstract Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap();
 
     /**
-     * Validates the backing table in Realm for the given RealmObject class.
+     * Creates {@link ColumnInfo} for the given RealmObject class.
      *
-     * @param clazz the {@link RealmObject} model class to validate.
-     * @param sharedRealm the wrapper object of underlying native database to validate against.
-     * @param allowExtraColumns if {@code} false, {@link io.realm.exceptions.RealmMigrationNeededException}
-     * is thrown when the column count it more than expected.
+     * @param clazz which {@link RealmObject} model class to create the column info of.
+     * @param osSchemaInfo the {@link OsSchemaInfo} for the corresponding Realm instance.
      * @return the field indices map.
      */
-    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
-            SharedRealm sharedRealm,
-            boolean allowExtraColumns);
+    public abstract ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo);
 
     /**
      * Returns a map of non-obfuscated object field names to their internal Realm name.
@@ -230,6 +226,12 @@ protected static void checkClass(Class<? extends RealmModel> clazz) {
     }
 
     protected static RealmException getMissingProxyClassException(Class<? extends RealmModel> clazz) {
-        return new RealmException(clazz + " is not part of the schema for this Realm.");
+        return new RealmException(
+                String.format("'%s' is not part of the schema for this Realm.", clazz.toString()));
+    }
+
+    protected static RealmException getMissingProxyClassException(String className) {
+        return new RealmException(
+                String.format("'%s' is not part of the schema for this Realm.", className));
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index e9ef74c7ea..3bc4f8ccaf 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -25,12 +25,11 @@
 
 import javax.annotation.Nullable;
 
-import io.realm.CompactOnLaunchCallback;
 import io.realm.RealmConfiguration;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
-
+@Keep
 public final class SharedRealm implements Closeable, NativeObject {
 
     // Const value for RealmFileException conversion
@@ -70,43 +69,6 @@ public static File getTemporaryDirectory() {
 
     private static volatile File temporaryDirectory;
 
-    public enum Durability {
-        FULL(0),
-        MEM_ONLY(1);
-
-        final int value;
-
-        Durability(int value) {
-            this.value = value;
-        }
-    }
-
-    private static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
-    private static final byte SCHEMA_MODE_VALUE_IMMUTABLE = 1;
-    private static final byte SCHEMA_MODE_VALUE_READONLY = 2;
-    private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 3;
-    private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 4;
-    private static final byte SCHEMA_MODE_VALUE_MANUAL = 5;
-
-    private enum SchemaMode {
-        SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
-        SCHEMA_MODE_IMMUTABLE(SCHEMA_MODE_VALUE_IMMUTABLE),
-        SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
-        SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
-        SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
-        SCHEMA_MODE_MANUAL(SCHEMA_MODE_VALUE_MANUAL);
-
-        final byte value;
-
-        SchemaMode(byte value) {
-            this.value = value;
-        }
-
-        public byte getNativeValue() {
-            return value;
-        }
-    }
-
     private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
     public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<>();
     public final List<WeakReference<Collection.Iterator>> iterators = new ArrayList<>();
@@ -169,97 +131,103 @@ public int hashCode() {
         }
     }
 
-    public interface SchemaVersionListener {
-        void onSchemaVersionChanged(long currentVersion);
+    /**
+     * The migration callback which will be called when manual migration is needed.
+     */
+    public interface MigrationCallback {
+
+        /**
+         * Callback function.
+         *
+         * @param sharedRealm the same {@link SharedRealm} instance which has been created from the same
+         * {@link OsRealmConfig} instance.
+         * @param oldVersion the schema version of the existing Realm file.
+         * @param newVersion the expected schema version after migration.
+         */
+        void onMigrationNeeded(SharedRealm sharedRealm, long oldVersion, long newVersion);
     }
 
-    private final SchemaVersionListener schemaChangeListener;
-    private final RealmConfiguration configuration;
-    private final long nativePtr;
+    /**
+     * Callback function to be executed when the schema is created.
+     */
+    public interface InitializationCallback {
+        /**
+         * @param sharedRealm a {@link SharedRealm} instance which is in transaction state.
+         */
+        void onInit(SharedRealm sharedRealm);
+    }
 
-    private long lastSchemaVersion;
+    /**
+     * Callback function to be called from JNI by Object Store when the schema is changed.
+     */
+    @SuppressWarnings("unused")
+    public interface SchemaChangedCallback {
+        void onSchemaChanged();
+    }
 
+    private final OsRealmConfig osRealmConfig;
+    private final long nativePtr;
     final NativeContext context;
+    private final OsSchemaInfo schemaInfo;
 
-    private SharedRealm(long nativeConfigPtr,
-            RealmConfiguration configuration,
-            @Nullable SchemaVersionListener schemaVersionListener) {
+    private SharedRealm(OsRealmConfig osRealmConfig) {
         Capabilities capabilities = new AndroidCapabilities();
         RealmNotifier realmNotifier = new AndroidRealmNotifier(this, capabilities);
 
-        this.nativePtr = nativeGetSharedRealm(nativeConfigPtr, realmNotifier);
-        this.configuration = configuration;
+        this.nativePtr = nativeGetSharedRealm(osRealmConfig.getNativePtr(), realmNotifier);
+        this.osRealmConfig = osRealmConfig;
+        this.schemaInfo = new OsSchemaInfo(nativeGetSchemaInfo(nativePtr), this);
+        this.context = osRealmConfig.getContext();
+        this.context.addReference(this);
 
         this.capabilities = capabilities;
         this.realmNotifier = realmNotifier;
-        this.schemaChangeListener = schemaVersionListener;
-        context = new NativeContext();
-        context.addReference(this);
-        this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
         nativeSetAutoRefresh(nativePtr, capabilities.canDeliverNotification());
     }
 
-    // This will create a SharedRealm where autoChangeNotifications is false,
-    // If autoChangeNotifications is true, an additional SharedGroup might be created in the OS's external commit helper.
-    // That is not needed for some cases: eg.: An extra opened SharedGroup will cause a compact failure.
+    /**
+     * Creates a {@code SharedRealm} instance from a given Object Store's {@code SharedRealm} pointer. This is used to
+     * create {@code SharedRealm} from the callback functions. When this is called, there is another
+     * {@code SharedRealm} instance with the same {@link OsRealmConfig} which has been created before. Although they
+     * are different {@code shared_ptr}, they point to the same {@code SharedGroup} instance. The {@code context} has
+     * to be the same one to ensure core's destructor thread safety.
+     */
+    private SharedRealm(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig) {
+        this.nativePtr = nativeSharedRealmPtr;
+        this.osRealmConfig = osRealmConfig;
+        this.schemaInfo = new OsSchemaInfo(nativeGetSchemaInfo(nativePtr), this);
+        this.context = osRealmConfig.getContext();
+        this.context.addReference(this);
+
+        this.capabilities = new AndroidCapabilities();
+        // This instance should never need notifications.
+        this.realmNotifier = null;
+        nativeSetAutoRefresh(nativePtr, false);
+    }
+
+
+    /**
+     * Creates a {@code SharedRealm} instance in dynamic schema mode.
+     */
     public static SharedRealm getInstance(RealmConfiguration config) {
-        return getInstance(config, null, false);
-    }
-
-
-    public static SharedRealm getInstance(RealmConfiguration config, @Nullable SchemaVersionListener schemaVersionListener,
-            boolean autoChangeNotifications) {
-        Object[] syncUserConf = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
-        String syncUserIdentifier = (String) syncUserConf[0];
-        String syncRealmUrl = (String) syncUserConf[1];
-        String syncRealmAuthUrl = (String) syncUserConf[2];
-        String syncRefreshToken = (String) syncUserConf[3];
-        boolean syncClientValidateSsl = (Boolean.TRUE.equals(syncUserConf[4]));
-        String syncSslTrustCertificatePath = (String) syncUserConf[5];
-
-        final boolean enableCaching = false; // Handled in Java currently
-        final boolean enableFormatUpgrade = true;
-
-        long nativeConfigPtr = nativeCreateConfig(
-                config.getPath(),
-                config.getEncryptionKey(),
-                syncRealmUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
-                config.getDurability() == Durability.MEM_ONLY,
-                enableCaching,
-                config.getSchemaVersion(),
-                enableFormatUpgrade,
-                autoChangeNotifications,
-                config.getCompactOnLaunchCallback(),
-                syncRealmUrl,
-                syncRealmAuthUrl,
-                syncUserIdentifier,
-                syncRefreshToken,
-                syncClientValidateSsl,
-                syncSslTrustCertificatePath);
-
-        try {
-            ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(config);
-
-            return new SharedRealm(nativeConfigPtr, config, schemaVersionListener);
-        } finally {
-            nativeCloseConfig(nativeConfigPtr);
-        }
+        OsRealmConfig.Builder builder = new OsRealmConfig.Builder(config);
+        return getInstance(builder);
     }
 
-    public void beginTransaction() {
-        beginTransaction(false);
+    /**
+     * Creates a {@code ShareRealm} instance from the given {@link OsRealmConfig.Builder}.
+     */
+    public static SharedRealm getInstance(OsRealmConfig.Builder configBuilder) {
+        OsRealmConfig osRealmConfig = configBuilder.build();
+        ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(osRealmConfig.getRealmConfiguration());
+
+        return new SharedRealm(osRealmConfig);
     }
 
-    public void beginTransaction(boolean ignoreReadOnly) {
-        // TODO ReadOnly is also supported by the Object Store Schema, but until we support that we need to enforce it
-        // ourselves.
-        if (!ignoreReadOnly && configuration.isReadOnly()) {
-            throw new IllegalStateException("Write transactions cannot be used when a Realm is marked as read-only.");
-        }
+    public void beginTransaction() {
         detachIterators();
         executePendingRowQueries();
         nativeBeginTransaction(nativePtr);
-        invokeSchemaChangeListenerIfSchemaChanged();
     }
 
     public void commitTransaction() {
@@ -331,7 +299,7 @@ public long size() {
     }
 
     public String getPath() {
-        return configuration.getPath();
+        return osRealmConfig.getRealmConfiguration().getPath();
     }
 
     public boolean isEmpty() {
@@ -340,7 +308,6 @@ public boolean isEmpty() {
 
     public void refresh() {
         nativeRefresh(nativePtr);
-        invokeSchemaChangeListenerIfSchemaChanged();
     }
 
     public SharedRealm.VersionID getVersionID() {
@@ -371,17 +338,6 @@ public boolean compact() {
         return nativeCompact(nativePtr);
     }
 
-    /**
-     * Initializes the underlying schema based on the schema description.
-     * Calling this method must be done from inside a write transaction.
-     *
-     * @param schemaInfo the expected schema.
-     * @param version the target version.
-     */
-    public void updateSchema(OsSchemaInfo schemaInfo, long version) {
-        nativeUpdateSchema(nativePtr, schemaInfo.getNativePtr(), version);
-    }
-
     public void setAutoRefresh(boolean enabled) {
         capabilities.checkCanDeliverNotification(null);
         nativeSetAutoRefresh(nativePtr, enabled);
@@ -391,19 +347,8 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
-    /**
-     * Determine whether the passed schema needs to be updated.
-     * <p>
-     * TODO: This method should not require the caller to get the native pointer.
-     * Instead, the signature should be something like:
-     * public <T extends RealmSchema & NativeObject> </T>void updateSchema(T schema, long version)
-     * ... that is, something that is a schema and that wraps a native object.
-     *
-     * @param schemaNativePtr the pointer to a native schema object.
-     * @return true if it will be necessary to call {@code updateSchema}
-     */
-    public boolean requiresMigration(long schemaNativePtr) {
-        return nativeRequiresMigration(nativePtr, schemaNativePtr);
+    public RealmConfiguration getConfiguration() {
+        return osRealmConfig.getRealmConfiguration();
     }
 
     @Override
@@ -428,17 +373,21 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    public void invokeSchemaChangeListenerIfSchemaChanged() {
-        if (schemaChangeListener == null) {
-            return;
-        }
+    /**
+     * @return the {@link OsSchemaInfo} of this {@code SharedRealm}.
+     */
+    public OsSchemaInfo getSchemaInfo() {
+        return schemaInfo;
+    }
 
-        final long before = lastSchemaVersion;
-        final long current = getSchemaVersion();
-        if (current != before) {
-            lastSchemaVersion = current;
-            schemaChangeListener.onSchemaVersionChanged(current);
-        }
+    /**
+     * Registers a {@link SchemaChangedCallback} with JNI {@code BindingContext}.
+     *
+     * @param callback to be registered. It will be held as a weak ref in the JNI. The caller needs to hold a strong ref
+     *                 to the callback to ensure it won't be GCed before calling.
+     */
+    public void registerSchemaChangedCallback(SchemaChangedCallback callback) {
+        nativeRegisterSchemaChangedCallback(nativePtr, callback);
     }
 
     // addIterator(), detachIterators() and invalidateIterators() are used to make RealmResults stable iterators work.
@@ -503,23 +452,30 @@ private void executePendingRowQueries() {
         pendingRows.clear();
     }
 
-    private static native void nativeInit(String temporaryDirectoryPath);
+    /**
+     * Called from JNI when the expected schema doesn't match the existing one.
+     *
+     * @param callback the {@link MigrationCallback} in the {@link RealmConfiguration}.
+     * @param oldVersion the schema version of the existing Realm file.
+     */
+    @SuppressWarnings("unused")
+    private static void runMigrationCallback(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig, MigrationCallback callback,
+                                             long oldVersion) {
+        callback.onMigrationNeeded(new SharedRealm(nativeSharedRealmPtr, osRealmConfig), oldVersion,
+                osRealmConfig.getRealmConfiguration().getSchemaVersion());
+    }
+
+    /**
+     * Called from JNI when the schema is created the first time.
+     *
+     * @param callback to be executed with a given in-transact {@link SharedRealm}.
+     */
+    @SuppressWarnings("unused")
+    private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig, InitializationCallback callback) {
+        callback.onInit(new SharedRealm(nativeSharedRealmPtr, osRealmConfig));
+    }
 
-    // Keep last session as an 'object' to avoid any reference to sync code
-    private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
-            boolean cache,
-            long schemaVersion,
-            boolean enabledFormatUpgrade,
-            boolean autoChangeNotification,
-            CompactOnLaunchCallback compactOnLaunch,
-            String syncServerURL,
-            String syncServerAuthURL,
-            String syncUserIdentity,
-            String syncRefreshToken,
-            boolean syncClientValidateSsl,
-            String syncSslTrustCertificatePath);
-
-    private static native void nativeCloseConfig(long nativeConfigPtr);
+    private static native void nativeInit(String temporaryDirectoryPath);
 
     private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
 
@@ -571,13 +527,14 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
 
     private static native boolean nativeCompact(long nativeSharedRealmPtr);
 
-    private static native void nativeUpdateSchema(long nativePtr, long nativeSchemaPtr, long version);
-
     private static native void nativeSetAutoRefresh(long nativePtr, boolean enabled);
 
     private static native boolean nativeIsAutoRefresh(long nativePtr);
 
-    private static native boolean nativeRequiresMigration(long nativePtr, long nativeSchemaPtr);
-
     private static native long nativeGetFinalizerPtr();
+
+    // Return the pointer to the Realm::m_schema.
+    private static native long nativeGetSchemaInfo(long nativePtr);
+
+    private static native void nativeRegisterSchemaChangedCallback(long nativePtr, SchemaChangedCallback callback);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index a9b8cc4f23..cfdcd2cfa2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -211,6 +211,15 @@ public void renameColumn(long columnIndex, String newName) {
         }
     }
 
+    /**
+     * Inserts a column at the given {@code columnIndex}.
+     * WARNING: This is only for internal testing purpose. Don't expose this to public API.
+     */
+    public void insertColumn(long columnIndex, RealmFieldType type, String name) {
+        verifyColumnName(name);
+        nativeInsertColumn(nativePtr, columnIndex, type.getNativeValue(), name);
+    }
+
     /**
      * Checks whether the specific column is nullable?
      *
@@ -891,6 +900,8 @@ public static String getTableNameForClass(String name) {
 
     private native void nativeRemoveColumn(long nativeTablePtr, long columnIndex);
 
+    private static native void nativeInsertColumn(long nativeTablePtr, long columnIndex, int type, String name);
+
     private native boolean nativeIsColumnNullable(long nativePtr, long columnIndex);
 
     private native void nativeConvertColumnToNullable(long nativeTablePtr, long columnIndex, boolean isPrimaryKey);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
index 03eae2702f..0a2d95496e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
@@ -17,6 +17,7 @@
 
 import android.os.Looper;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import javax.annotation.Nullable;
 
 import io.realm.internal.Capabilities;
@@ -27,6 +28,13 @@
  */
 public class AndroidCapabilities implements Capabilities {
 
+    // Public so it can be set from tests.
+    // If set, it will treat the current looper thread as the main thread.
+    // It is up to the caller to handle any race conditions around this. Right now only
+    // RunInLooperThread.java does this as part of setting up the test.
+    @SuppressFBWarnings("MS_SHOULD_BE_FINAL")
+    public static boolean EMULATE_MAIN_THREAD = false;
+
     private final Looper looper;
     private final boolean isIntentServiceThread;
 
@@ -54,7 +62,7 @@ public void checkCanDeliverNotification(@Nullable String exceptionMessage) {
 
     @Override
     public boolean isMainThread() {
-        return looper != null && looper == Looper.getMainLooper();
+        return looper != null && (EMULATE_MAIN_THREAD || looper == Looper.getMainLooper());
     }
 
     private boolean hasLooper() {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 3d636e0f6b..390ad0104a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -33,10 +33,10 @@
 import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
-import io.realm.internal.SharedRealm;
 import io.realm.internal.Util;
 
 
@@ -71,10 +71,9 @@ public CompositeMediator(RealmProxyMediator... mediators) {
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
-            boolean allowExtraColumns) {
+    public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.validateTable(clazz, sharedRealm, allowExtraColumns);
+        return mediator.createColumnInfo(clazz, osSchemaInfo);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index 2a7bc7c183..e2d3c99e22 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -34,10 +34,10 @@
 import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
-import io.realm.internal.SharedRealm;
 import io.realm.internal.Util;
 
 
@@ -86,10 +86,9 @@ public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
-            boolean allowExtraColumns) {
+    public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo) {
         checkSchemaHasClass(clazz);
-        return originalMediator.validateTable(clazz, sharedRealm, allowExtraColumns);
+        return originalMediator.createColumnInfo(clazz, osSchemaInfo);
     }
 
     @Override
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 0e65fcae3c..abdd2fcfea 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -23,7 +23,7 @@
  */
 public enum ErrorCode {
 
-    // See https://github.com/realm/realm-sync/blob/master/doc/protocol.md
+    // See Client::Error in https://github.com/realm/realm-sync/blob/master/src/realm/sync/client.hpp
     // See https://github.com/realm/realm-object-server/blob/master/object-server/doc/problems.md
 
     // Realm Java errors (0-49)
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index a3c0e1e5e4..1c160cbdff 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -35,8 +35,8 @@
 
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
+import io.realm.internal.OsRealmConfig;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.SharedRealm;
 import io.realm.internal.Util;
 import io.realm.log.RealmLog;
 import io.realm.rx.RealmObservableFactory;
@@ -78,8 +78,7 @@
     static final int MAX_FULL_PATH_LENGTH = 256;
     static final int MAX_FILE_NAME_LENGTH = 255;
     private static final char[] INVALID_CHARS = {'<', '>', ':', '"', '/', '\\', '|', '?', '*'};
-
-    private final URI serverUrl;
+private final URI serverUrl;
     private final SyncUser user;
     private final SyncSession.ErrorHandler errorHandler;
     private final boolean deleteRealmOnLogout;
@@ -101,7 +100,7 @@ private SyncConfiguration(File directory,
                                 @Nullable
                                 RealmMigration migration,
                                 boolean deleteRealmIfMigrationNeeded,
-                                SharedRealm.Durability durability,
+                                OsRealmConfig.Durability durability,
                                 RealmProxyMediator schemaMediator,
                                 @Nullable
                                 RxObservableFactory rxFactory,
@@ -318,7 +317,7 @@ boolean isSyncConfiguration() {
         private Realm.Transaction initialDataTransaction;
         private File defaultFolder;
         private String defaultLocalFileName;
-        private SharedRealm.Durability durability = SharedRealm.Durability.FULL;
+        private OsRealmConfig.Durability durability = OsRealmConfig.Durability.FULL;
         private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
         private boolean readOnly = false;
         private boolean waitForServerChanges = false;
@@ -655,7 +654,7 @@ public Builder initialData(Realm.Transaction transaction) {
          * reference to the in-memory Realm object with the specific name as long as you want the data to last.
          */
         public Builder inMemory() {
-            this.durability = SharedRealm.Durability.MEM_ONLY;
+            this.durability = OsRealmConfig.Durability.MEM_ONLY;
             return this;
         }
 
diff --git a/realm/realm-library/testLibs/backlinks-missing-field-source.jar b/realm/realm-library/testLibs/backlinks-missing-field-source.jar
deleted file mode 100644
index a34490c3ca..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-missing-field-source.jar and /dev/null differ
diff --git a/realm/realm-library/testLibs/backlinks-missing-field-target.jar b/realm/realm-library/testLibs/backlinks-missing-field-target.jar
deleted file mode 100644
index 91a513c5b3..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-missing-field-target.jar and /dev/null differ
diff --git a/realm/realm-library/testLibs/backlinks-wrong-type-source.jar b/realm/realm-library/testLibs/backlinks-wrong-type-source.jar
deleted file mode 100644
index 67cbdbefea..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-wrong-type-source.jar and /dev/null differ
diff --git a/realm/realm-library/testLibs/backlinks-wrong-type-target.jar b/realm/realm-library/testLibs/backlinks-wrong-type-target.jar
deleted file mode 100644
index 3745742b94..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-wrong-type-target.jar and /dev/null differ
