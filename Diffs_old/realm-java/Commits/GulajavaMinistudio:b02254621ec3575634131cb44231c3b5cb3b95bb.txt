diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index 4d223c132d..94718dbc2f 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -1,14 +1,15 @@
-> We LOVE to help with any issues or bug you have!
+<!---
 
-> **Questions**: If you have questions about how to use Realm, please ask on [SO](http://stackoverflow.com/questions/ask?tags=realm) - we monitor the Realm tag.
+**Questions**: If you have questions about how to use Realm, ask on
+[StackOverflow](http://stackoverflow.com/questions/ask?tags=realm).
+We monitor the `realm` tag.
 
-> **Feature Request**: Just fill in the first two sections below.
+**Feature Request**: Just fill in the first two sections below.
 
-> **Bugs**: To help you as fast as possible with an issue or bug please describe your issue and the steps you have taken to reproduce it in as many details as possible.
->
-> Thanks for helping us help you :-)
->
-> Remove this and above before submitting.
+**Bugs**: To help you as fast as possible with an issue please describe your issue
+and the steps you have taken to reproduce it in as many details as possible.
+
+-->
 
 #### Goal
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e150e3e9bb..3e6f763a34 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,6 +9,8 @@
 
 ### Enhancements
 
+* Added `RealmConfiguration.Builder.compactOnLaunch()` to compact the file on launch (#3739).
+
 ### Bug Fixes
 
 ### Internal
@@ -30,10 +32,10 @@
 
 ### Bug Fixes
 
-* Fixed a bug in `isNull()`, `isNotNull()`, `isEmpty()`, and `isNotEmpty()` when queries involve nullable fields in link queries (#4856).
-* Fixed a bug in how to resolve field names when querying `@LinkingObjects` as the last field (#4864).
+* Bug in `isNull()`, `isNotNull()`, `isEmpty()`, and `isNotEmpty()` when queries involve nullable fields in link queries (#4856).
+* Bug in how to resolve field names when querying `@LinkingObjects` as the last field (#4864).
 * Rare crash in `RealmLog` when log level was set to `LogLevel.DEBUG`.
-* [ObjectServer] Fixed a bug related to the behaviour of `SyncUser#logout` and the use of invalid `SyncUser` with `SyncConfiguration` (#4822).
+* [ObjectServer] Bug related to the behaviour of `SyncUser#logout` and the use of invalid `SyncUser` with `SyncConfiguration` (#4822).
 * [ObjectServer] Not all error codes from the server were recognized correctly, resulting in UNKNOWN being reported instead.
 
 ### Internal
@@ -62,10 +64,10 @@
 
 ### Bug Fixes
 
-* [ObjectServer] Fixed a bug which may crash when the JNI local reference limitation was reached on sync client thread.
+* [ObjectServer] Bug which may crash when the JNI local reference limitation was reached on sync client thread.
 * [ObjectServer] Retrying connections with exponential backoff, when encountering `ConnectException` (#4310).
 * When converting nullable BLOB field to required, `null` values should be converted to `byte[0]` instead of `byte[1]`.
-* Fixed a bug which may cause duplicated primary key values when migrating a nullable primary key field to not nullable. `RealmObjectSchema.setRequired()` and `RealmObjectSchema.setNullable()` will throw when converting a nullable primary key field with null values stored to a required primary key field.
+* Bug which may cause duplicated primary key values when migrating a nullable primary key field to not nullable. `RealmObjectSchema.setRequired()` and `RealmObjectSchema.setNullable()` will throw when converting a nullable primary key field with null values stored to a required primary key field.
 
 ### Internal
 
@@ -81,7 +83,7 @@
 
 ### Bug Fixes
 
-* [ObjectServer] Fixed a crash when an authentication error happens (#4726).
+* [ObjectServer] Crash when an authentication error happens (#4726).
 * [ObjectServer] Enabled encryption with Sync (#4561).
 * [ObjectServer] Admin users did not connect correctly to the server (#4750).
 
@@ -118,7 +120,7 @@
 
 * [ObjectServer] `schemaVersion` was mistakenly required in order to trigger migrations (#4658).
 * [ObjectServer] Fields removed from model classes will now correctly be hidden instead of throwing an exception when opening the Realm (#4658).
-* Fixed random crashes which were caused by a race condition in encrypted Realm (#4343).
+* Random crashes which were caused by a race condition in encrypted Realm (#4343).
 
 ### Internal
 
@@ -221,7 +223,7 @@
 
 * Crash with `LogicError` with `Bad version number` on notifier thread (#4369).
 * `Realm.migrateRealm(RealmConfiguration)` now fails correctly with an `IllegalArgumentException` if a `SyncConfiguration` is provided (#4075).
-* Fixed a potential cause for Realm file corruptions (never reported).
+* Potential cause for Realm file corruptions (never reported).
 * Add `@Override` annotation to proxy class accessors and stop using raw type in proxy classes in order to remove warnings from javac (#4329).
 * `findFirstAsync()` now returns an invalid object if there is no object matches the query condition instead of running the query repeatedly until it can find one (#4352).
 * [ObjectServer] Changing the log level after starting a session now works correctly (#4337).
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 6935c2dd53..92589caebb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -1014,4 +1014,22 @@ public void readOnly_deleteRealmIfMigrationRequired_throws() {
         } catch (IllegalStateException ignored) {
         }
     }
+
+    @Test
+    public void readOnly_compactOnLaunch_throws() {
+        try {
+            new RealmConfiguration.Builder()
+                    .assetFile("foo")
+                    .readOnly()
+                    .compactOnLaunch(new CompactOnLaunchCallback() {
+                        @Override
+                        public boolean shouldCompact(long totalBytes, long usedBytes) {
+                            return false;
+                        }
+                    })
+                    .build();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index ae80d7b7d4..f30d459da5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -60,6 +60,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -102,6 +103,7 @@
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 import io.realm.objectid.NullPrimaryKey;
 import io.realm.rule.RunInLooperThread;
@@ -110,6 +112,7 @@
 import io.realm.util.ExceptionHolder;
 import io.realm.util.RealmThread;
 
+import static io.realm.TestHelper.awaitOrFail;
 import static io.realm.TestHelper.testNoObjectFound;
 import static io.realm.TestHelper.testOneObjectFound;
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
@@ -1056,6 +1059,142 @@ public void compactRealm_onExternalStorage() {
         Realm.deleteRealm(config);
     }
 
+    private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch) {
+        return populateTestRealmAndCompactOnLaunch(compactOnLaunch, 100);
+    }
+
+    private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch, int objects) {
+        final String REALM_NAME = "test.realm";
+        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
+        Realm realm = Realm.getInstance(realmConfig);
+        populateTestRealm(realm, objects);
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+        realm.close();
+        long before = new File(realmConfig.getPath()).length();
+        if (compactOnLaunch != null) {
+            realmConfig = configFactory.createConfigurationBuilder()
+                    .name(REALM_NAME)
+                    .compactOnLaunch(compactOnLaunch)
+                    .build();
+        } else {
+            realmConfig = configFactory.createConfigurationBuilder()
+                    .name(REALM_NAME)
+                    .compactOnLaunch()
+                    .build();
+        }
+        realm = Realm.getInstance(realmConfig);
+        realm.close();
+        long after = new File(realmConfig.getPath()).length();
+        return new Pair(before, after);
+    }
+
+    @Test
+    public void compactOnLaunch_shouldCompact() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(new CompactOnLaunchCallback() {
+            @Override
+            public boolean shouldCompact(long totalBytes, long usedBytes) {
+                assertTrue(totalBytes > usedBytes);
+                return true;
+            }
+        });
+        assertTrue(results.first > results.second);
+    }
+
+    @Test
+    public void compactOnLaunch_shouldNotCompact() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(new CompactOnLaunchCallback() {
+            @Override
+            public boolean shouldCompact(long totalBytes, long usedBytes) {
+                assertTrue(totalBytes > usedBytes);
+                return false;
+            }
+        });
+        assertEquals(results.first, results.second);
+    }
+
+    @Test
+    public void compactOnLaunch_multipleThread() throws IOException {
+        final String REALM_NAME = "test.realm";
+        final AtomicInteger compactOnLaunchCount = new AtomicInteger(0);
+
+        final RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .compactOnLaunch(new CompactOnLaunchCallback() {
+                    @Override
+                    public boolean shouldCompact(long totalBytes, long usedBytes) {
+                        compactOnLaunchCount.incrementAndGet();
+                        return true;
+                    }
+                })
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realmConfig);
+                bgRealm.close();
+            }
+        });
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail();
+        }
+
+        realm.close();
+
+        // FIXME: It should be 1. Current compactOnLaunch is called each time a Realm is opened on a new thread.
+        assertNotEquals(1, compactOnLaunchCount.get());
+        assertEquals(3, compactOnLaunchCount.get());
+    }
+
+    @Test
+    public void compactOnLaunch_insufficientAmount() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(new CompactOnLaunchCallback() {
+            @Override
+            public boolean shouldCompact(long totalBytes, long usedBytes) {
+                final long thresholdSize = 50 * 1024 * 1024;
+                return (totalBytes > thresholdSize) && (((double) usedBytes / (double) totalBytes) < 0.5);
+            }
+        }, 100);
+        final long thresholdSize = 50 * 1024 * 1024;
+        assertTrue(results.first < thresholdSize);
+        assertEquals(results.first, results.second);
+    }
+
+    @Test
+    public void defaultCompactOnLaunch() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 30000);
+        final long thresholdSize = 50 * 1024 * 1024;
+        assertTrue(results.first > thresholdSize);
+        assertTrue(results.first > results.second);
+    }
+
+    @Test
+    public void defaultCompactOnLaunch_onlyCallback() {
+        DefaultCompactOnLaunchCallback callback = new DefaultCompactOnLaunchCallback();
+        final long thresholdSize = 50 * 1024 * 1024;
+        final long big = thresholdSize + 1024;
+        assertFalse(callback.shouldCompact(big, (long) (big * 0.6)));
+        assertTrue(callback.shouldCompact(big, (long) (big * 0.3)));
+        final long small = thresholdSize - 1024;
+        assertFalse(callback.shouldCompact(small, (long) (small * 0.6)));
+        assertFalse(callback.shouldCompact(small, (long) (small * 0.3)));
+    }
+
+    @Test
+    public void defaultCompactOnLaunch_insufficientAmount() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 100);
+        final long thresholdSize = 50 * 1024 * 1024;
+        assertTrue(results.first < thresholdSize);
+        assertEquals(results.first, results.second);
+    }
+
     @Test
     public void copyToRealm_null() {
         realm.beginTransaction();
@@ -3973,7 +4112,7 @@ public void run() {
                 realm.close();
                 bgThreadDone.countDown();
             }
-        }).run();
+        }).start();
         TestHelper.awaitOrFail(bgThreadDone);
 
         realm.refresh();
@@ -3997,7 +4136,7 @@ public void run() {
                 realm.close();
                 bgThreadDone.countDown();
             }
-        }).run();
+        }).start();
         TestHelper.awaitOrFail(bgThreadDone);
 
         realm.refresh();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 6cb628e5c1..d262d92e07 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -32,13 +32,9 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import io.realm.DynamicRealm;
+import io.realm.CompactOnLaunchCallback;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
-import io.realm.RealmMigration;
-import io.realm.RealmObject;
-import io.realm.TestHelper;
-import io.realm.annotations.RealmModule;
 
 import static org.junit.Assert.assertTrue;
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 5eb72588d5..8d7351d452 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -184,6 +184,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
     JNIEnv* env, jclass, jstring realm_path, jbyteArray key, jbyte schema_mode, jboolean in_memory, jboolean cache,
     jlong /* schema_version */, jboolean enable_format_upgrade, jboolean auto_change_notification,
+    jobject compact_on_launch,
     REALM_UNUSED jstring sync_server_url, REALM_UNUSED jstring sync_server_auth_url,
     REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token,
     REALM_UNUSED jboolean sync_client_validate_ssl, REALM_UNUSED jstring sync_ssl_trust_certificate_path)
@@ -202,6 +203,19 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
         config.cache = cache;
         config.disable_format_upgrade = !enable_format_upgrade;
         config.automatic_change_notifications = auto_change_notification;
+
+        if (compact_on_launch) {
+            static JavaMethod should_compact(env, compact_on_launch, "shouldCompact", "(JJ)Z");
+            JavaGlobalRef java_compact_on_launch_ref(env, compact_on_launch);
+
+            auto should_compact_on_launch_function = [java_compact_on_launch_ref](uint64_t totalBytes, uint64_t usedBytes) {
+                JNIEnv* env = JniUtils::get_env(false);
+                return env->CallBooleanMethod(java_compact_on_launch_ref.get(), should_compact,
+                                              static_cast<jlong>(totalBytes), static_cast<jlong>(usedBytes));
+            };
+            config.should_compact_on_launch_function = std::move(should_compact_on_launch_function);
+        }
+
         if (sync_server_url) {
             return reinterpret_cast<jlong>(
                 new JniConfigWrapper(env, config, sync_server_url, sync_server_auth_url, sync_user_identity,
diff --git a/realm/realm-library/src/main/java/io/realm/CompactOnLaunchCallback.java b/realm/realm-library/src/main/java/io/realm/CompactOnLaunchCallback.java
new file mode 100644
index 0000000000..8da63ac6f0
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/CompactOnLaunchCallback.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.internal.Keep;
+import io.realm.internal.KeepMember;
+
+/**
+ * This interface is used to determine if a Realm file should be compacted the first time the file is opened and before
+ * the instance is returned.
+ * <p>
+ * Note that compacting a file can take a while, so compacting should generally only be done on a background thread or
+ * when used in combination with {@link Realm#getInstanceAsync(RealmConfiguration, Callback)}.
+ */
+@Keep
+public interface CompactOnLaunchCallback {
+
+    /**
+     * This method determines if the Realm file should be compacted before opened and returned to the user. It is passed
+     * the total file size (data + free space) and the bytes used by data in the file.
+     *
+     * @param totalBytes the total file size (data + free space).
+     * @param usedBytes the total bytes used by data in the file.
+     * @return {code true} to indicate an attempt to compact the file should be made. Otherwise, the compaction will be
+     * skipped.
+     */
+    boolean shouldCompact(long totalBytes, long usedBytes);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java b/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
new file mode 100644
index 0000000000..9c385effbc
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.log.RealmLog;
+
+/**
+ * The default implementation for determining if a file should be compacted or not. This implementation will only
+ * trigger if the file is above 50 MB and more than 50% can be reclaimed.
+ */
+public class DefaultCompactOnLaunchCallback implements CompactOnLaunchCallback {
+    @Override
+    public boolean shouldCompact(long totalBytes, long usedBytes) {
+        final long thresholdSize = 50 * 1024 * 1024;
+        return (totalBytes > thresholdSize) && (((double) usedBytes / (double) totalBytes) < 0.5);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index cafcd4a23d..2d85a0b9bf 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -52,7 +52,7 @@
  * <p>
  * A minimal configuration can be created using:
  * <p>
- * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
+ * {@code RealmConfiguration config = new RealmConfiguration.Builder().build()}
  * <p>
  * This will create a RealmConfiguration with the following properties.
  * <ul>
@@ -98,6 +98,7 @@
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
     private final boolean readOnly;
+    private final CompactOnLaunchCallback compactOnLaunch;
 
     // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
     // subsets of them.
@@ -113,7 +114,8 @@ protected RealmConfiguration(File realmDirectory,
             RealmProxyMediator schemaMediator,
             RxObservableFactory rxObservableFactory,
             Realm.Transaction initialDataTransaction,
-            boolean readOnly) {
+            boolean readOnly,
+            CompactOnLaunchCallback compactOnLaunch) {
         this.realmDirectory = realmDirectory;
         this.realmFileName = realmFileName;
         this.canonicalPath = canonicalPath;
@@ -127,6 +129,7 @@ protected RealmConfiguration(File realmDirectory,
         this.rxObservableFactory = rxObservableFactory;
         this.initialDataTransaction = initialDataTransaction;
         this.readOnly = readOnly;
+        this.compactOnLaunch = compactOnLaunch;
     }
 
     public File getRealmDirectory() {
@@ -193,6 +196,17 @@ String getAssetFilePath() {
         return assetFilePath;
     }
 
+    /**
+     * Returns a callback to determine if the Realm file should be compacted before being returned to the user.
+     *
+     * @return a callback called when opening a Realm for the first time during the life of a process to determine if
+     * it should be compacted before being returned to the user. It is passed the total file size (data + free space)
+     * and the total bytes used by data in the file.
+     */
+    public CompactOnLaunchCallback getCompactOnLaunchCallback() {
+        return compactOnLaunch;
+    }
+
     /**
      * Returns the unmodifiable {@link Set} of model classes that make up the schema for this Realm.
      *
@@ -272,6 +286,7 @@ public boolean equals(Object obj) {
             return false;
         }
         if (readOnly != that.readOnly) { return false; }
+        if (compactOnLaunch != null ? !compactOnLaunch.equals(that.compactOnLaunch) : that.compactOnLaunch != null) { return false; }
 
         return schemaMediator.equals(that.schemaMediator);
     }
@@ -291,6 +306,7 @@ public int hashCode() {
         result = 31 * result + (rxObservableFactory != null ? rxObservableFactory.hashCode() : 0);
         result = 31 * result + (initialDataTransaction != null ? initialDataTransaction.hashCode() : 0);
         result = 31 * result + (readOnly ? 1 : 0);
+        result = 31 * result + (compactOnLaunch != null ? compactOnLaunch.hashCode() : 0);
 
         return result;
     }
@@ -365,6 +381,8 @@ public String toString() {
         stringBuilder.append("schemaMediator: ").append(schemaMediator);
         stringBuilder.append("\n");
         stringBuilder.append("readOnly: ").append(readOnly);
+        stringBuilder.append("\n");
+        stringBuilder.append("compactOnLaunch: ").append(compactOnLaunch);
 
         return stringBuilder.toString();
     }
@@ -421,6 +439,7 @@ boolean isSyncConfiguration() {
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
         private boolean readOnly;
+        private CompactOnLaunchCallback compactOnLaunch;
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
@@ -451,6 +470,7 @@ private void initializeBuilder(Context context) {
             this.deleteRealmIfMigrationNeeded = false;
             this.durability = SharedRealm.Durability.FULL;
             this.readOnly = false;
+            this.compactOnLaunch = null;
             if (DEFAULT_MODULE != null) {
                 this.modules.add(DEFAULT_MODULE);
             }
@@ -672,6 +692,30 @@ public Builder readOnly() {
             return this;
         }
 
+        /**
+         * Setting this will cause Realm to compact the Realm file if the Realm file has grown too large and a
+         * significant amount of space can be recovered. See {@link DefaultCompactOnLaunchCallback} for details.
+         */
+        public Builder compactOnLaunch() {
+            return compactOnLaunch(new DefaultCompactOnLaunchCallback());
+        }
+
+        /**
+         * Sets this to determine if the Realm file should be compacted before returned to the user. It is passed the
+         * total file size (data + free space) and the bytes used by data in the file.
+         *
+         * @param compactOnLaunch a callback called when opening a Realm for the first time during the life of a process
+         *                        to determine if it should be compacted before being returned to the user. It is passed
+         *                        the total file size (data + free space) and the bytes used by data in the file.
+         */
+        public Builder compactOnLaunch(CompactOnLaunchCallback compactOnLaunch) {
+            if (compactOnLaunch == null) {
+                throw new IllegalArgumentException("A non-null compactOnLaunch must be provided");
+            }
+            this.compactOnLaunch = compactOnLaunch;
+            return this;
+        }
+
         private void addModule(Object module) {
             if (module != null) {
                 checkModule(module);
@@ -716,6 +760,9 @@ public RealmConfiguration build() {
                 if (deleteRealmIfMigrationNeeded) {
                     throw new IllegalStateException("'deleteRealmIfMigrationNeeded()' and read-only Realms cannot be combined");
                 }
+                if (compactOnLaunch != null) {
+                    throw new IllegalStateException("'compactOnLaunch()' and read-only Realms cannot be combined");
+                }
             }
 
             if (rxFactory == null && isRxJavaAvailable()) {
@@ -734,7 +781,8 @@ public RealmConfiguration build() {
                     createSchemaMediator(modules, debugSchema),
                     rxFactory,
                     initialDataTransaction,
-                    readOnly
+                    readOnly,
+                    compactOnLaunch
             );
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 2408560e85..287eda3756 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -23,6 +23,7 @@
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
+import io.realm.CompactOnLaunchCallback;
 import io.realm.RealmConfiguration;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
@@ -224,6 +225,7 @@ public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionLi
                 config.getSchemaVersion(),
                 enableFormatUpgrade,
                 autoChangeNotifications,
+                config.getCompactOnLaunchCallback(),
                 syncRealmUrl,
                 syncRealmAuthUrl,
                 syncUserIdentifier,
@@ -505,6 +507,7 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
             long schemaVersion,
             boolean enabledFormatUpgrade,
             boolean autoChangeNotification,
+            CompactOnLaunchCallback compactOnLaunch,
             String syncServerURL,
             String syncServerAuthURL,
             String syncUserIdentity,
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 234a3ec80e..c14669b019 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -120,7 +120,8 @@ private SyncConfiguration(File directory,
                 schemaMediator,
                 rxFactory,
                 initialDataTransaction,
-                readOnly
+                readOnly,
+                null
         );
 
         this.user = user;
