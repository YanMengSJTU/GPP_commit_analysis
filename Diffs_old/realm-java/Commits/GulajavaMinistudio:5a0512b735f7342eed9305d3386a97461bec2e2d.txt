diff --git a/CHANGELOG.md b/CHANGELOG.md
index e5d174d92a..aa00936b8d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -6,14 +6,17 @@
 
 ### Bug Fixes
 
+* [ObjectServer] Fixed a crash when an authentication error happend (#4726).
+
 ### Internal
 
+* Factor out internal interface ManagedObject
 
 ## 3.3.1 (2017-05-26)
 
 ### Bug Fixes
 
-* Accept extra columns against synced Realm (#4706).
+* [ObjectServer] Accepted extra columns against synced Realm (#4706).
 
 
 ## 3.3.0 (2017-05-24)
@@ -66,7 +69,7 @@
 
 ### Internal
 
-* Use separated locks for different `RealmCache`s ($4551).
+* Use separated locks for different `RealmCache`s (#4551).
 
 ## 3.1.4 (2017-05-04)
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 7d6d866549..30dbd66c0d 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -20,6 +20,8 @@
 import java.util.Collections;
 import java.util.Date;
 
+import io.realm.internal.ManagableObject;
+
 
 /**
  * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
@@ -31,7 +33,7 @@
  *
  * @param <E> type of {@link RealmObject} stored in the collection.
  */
-public interface RealmCollection<E extends RealmModel> extends Collection<E> {
+public interface RealmCollection<E extends RealmModel> extends Collection<E>, ManagableObject {
 
     /**
      * Returns a {@link RealmQuery}, which can be used to query for specific objects from this collection.
@@ -144,6 +146,7 @@
      *
      * @return {@code true} if it is still valid to use or an unmanaged collection, {@code false} otherwise.
      */
+    @Override
     boolean isValid();
 
     /**
@@ -159,6 +162,7 @@
      *
      * @return {@code true} if this is a managed {@link RealmCollection}, {@code false} otherwise.
      */
+    @Override
     boolean isManaged();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 85199653ac..6652d40d22 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -20,6 +20,7 @@
 
 import io.realm.annotations.RealmClass;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.ManagableObject;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import rx.Observable;
@@ -66,7 +67,7 @@
  */
 
 @RealmClass
-public abstract class RealmObject implements RealmModel {
+public abstract class RealmObject implements RealmModel, ManagableObject {
 
     /**
      * Deletes the object from the Realm it is currently associated to.
@@ -128,6 +129,7 @@ public final void deleteFromRealm() {
      * @return {@code true} if the object is still accessible or an unmanaged object, {@code false} otherwise.
      * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
+    @Override
     public final boolean isValid() {
         return RealmObject.isValid(this);
     }
@@ -256,6 +258,7 @@ public final boolean isLoaded() {
      *
      * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
      */
+    @Override
     public boolean isManaged() {
         return isManaged(this);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ManagableObject.java b/realm/realm-library/src/main/java/io/realm/internal/ManagableObject.java
new file mode 100644
index 0000000000..884da88dbb
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ManagableObject.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+/**
+ * This internal interface represents a java object that corresponds to data
+ * that may be managed in the Realm core. It specifies the operations common to all such objects.
+ */
+public interface ManagableObject {
+
+    /**
+     * Checks to see if this object is managed by Realm..
+     *
+     * @return {@code true} if this is a managed Realm object, {@code false} otherwise.
+     */
+    boolean isManaged();
+
+    /**
+     * Checks to see if the managed object is still valid to use.
+     * That is if it that it hasn't been deleted nor has the {@link io.realm.Realm} been closed.
+     * It will always return {@code true} for unmanaged objects.
+     *
+     * @return {@code true} if this object is unmanaged or is still valid for use, {@code false} otherwise.
+     */
+    boolean isValid();
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index b008a2fae3..846e79bd98 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -324,7 +324,8 @@ protected void onSuccess(AuthenticateResponse response) {
             @Override
             protected void onError(AuthenticateResponse response) {
                 onGoingAccessTokenQuery.set(false);
-                RealmLog.debug("Session[%s]: Failed to get access token (%d)", configuration.getPath(), response.getError().getErrorCode());
+                RealmLog.debug("Session[%s]: Failed to get access token (%s)", configuration.getPath(),
+                        response.getError().getErrorCode());
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
                     errorHandler.onError(SyncSession.this, response.getError());
                 }
