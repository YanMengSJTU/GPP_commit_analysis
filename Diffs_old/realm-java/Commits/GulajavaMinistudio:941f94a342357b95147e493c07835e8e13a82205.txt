diff --git a/CHANGELOG.md b/CHANGELOG.md
index ed9bad7e72..812334a0eb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,8 @@
 
 ### Breaking Changes
 
+* An `IllegalStateException` will be thrown if the given `RealmModule` doesn't include all required model classes (#3398).
+
 ### Deprecated
 
 ### Enhancements
@@ -10,6 +12,8 @@
 
 ### Internal
 
+* Use Object Store to do table initialization.
+
 ### Credits
 
 
@@ -21,8 +25,14 @@
 
 ### Enhancements
 
+* [ObjectServer] Adding user lookup API for administrators (#4828).
+
 ### Bug Fixes
 
+* Fixed a bug in `isNull()`, `isNotNull()`, `isEmpty()`, and `isNotEmpty()` when queries involve nullable fields in link queries (#4856).
+* Rare crash in `RealmLog` when log level was set to `LogLevel.DEBUG`.   
+* [ObjectServer] Fixed a bug related to the behaviour of `SyncUser#logout` and the use of invalid `SyncUser` with `SyncConfiguration` (#4822).
+
 ### Internal
 
 * Removed `Table#Table()`, `Table#addEmptyRow()`, `Table#addEmptyRows()`, `Table#add(Object...)`, `Table#pivot(long,long,PivotType)` and `Table#createnative()`.
@@ -34,7 +44,6 @@
 ### Breaking Changes
 
 * [ObjectServer] Updated protocol version to 18 which is only compatible with ROS > 1.6.0.
-* An `IllegalStateException` will be thrown if the given `RealmModule` doesn't include all required model classes (#3398).
 
 ### Deprecated
 
@@ -76,7 +85,6 @@
 ### Internal
 
 * Factor out internal interface ManagedObject.
-* Use Object Store to do table initialization.
 
 ## 3.3.1 (2017-05-26)
 
diff --git a/dependencies.list b/dependencies.list
index 82afed2cb5..597493e8ca 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -10,4 +10,4 @@ REALM_SYNC_SHA256=b48fd48461b563e2a6b1605ec346aca48b64b64a12d42a0f5a61135906d490
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
 # install/use between 'realm' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.7.6-62
+REALM_OBJECT_SERVER_DE_VERSION=1.8.1-149
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
index ceeaff107a..e658f157a8 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
@@ -16,6 +16,8 @@
 
 package io.realm.processor;
 
+import java.util.Locale;
+
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
 
@@ -87,7 +89,7 @@
 
     public Backlink(ClassMetaData clazz, VariableElement backlink) {
         if ((null == clazz) || (null == backlink)) {
-            throw new NullPointerException(String.format("null parameter: %s, %s", clazz, backlink));
+            throw new NullPointerException(String.format(Locale.US, "null parameter: %s, %s", clazz, backlink));
         }
 
         this.backlink = backlink;
@@ -130,6 +132,7 @@ public boolean validateSource() {
         // A @LinkingObjects cannot be @Required
         if (backlink.getAnnotation(Required.class) != null) {
             Utils.error(String.format(
+                    Locale.US,
                     "The @LinkingObjects field \"%s.%s\" cannot be @Required.",
                     targetClass,
                     targetField));
@@ -139,6 +142,7 @@ public boolean validateSource() {
         // The annotation must have an argument, identifying the linked field
         if ((sourceField == null) || sourceField.equals("")) {
             Utils.error(String.format(
+                    Locale.US,
                     "The @LinkingObjects annotation for the field \"%s.%s\" must have a parameter identifying the link target.",
                     targetClass,
                     targetField));
@@ -148,6 +152,7 @@ public boolean validateSource() {
         // Using link syntax to try to reference a linked field is not possible.
         if (sourceField.contains(".")) {
             Utils.error(String.format(
+                    Locale.US,
                     "The parameter to the @LinkingObjects annotation for the field \"%s.%s\" contains a '.'.  The use of '.' to specify fields in referenced classes is not supported.",
                     targetClass,
                     targetField));
@@ -157,6 +162,7 @@ public boolean validateSource() {
         // The annotated element must be a RealmResult
         if (!Utils.isRealmResults(backlink)) {
             Utils.error(String.format(
+                    Locale.US,
                     "The field \"%s.%s\" is a \"%s\". Fields annotated with @LinkingObjects must be RealmResults.",
                     targetClass,
                     targetField,
@@ -166,6 +172,7 @@ public boolean validateSource() {
 
         if (sourceClass == null) {
             Utils.error(String.format(
+                    Locale.US,
                     "\"The field \"%s.%s\", annotated with @LinkingObjects, must specify a generic type.",
                     targetClass,
                     targetField));
@@ -175,6 +182,7 @@ public boolean validateSource() {
         // A @LinkingObjects field must be final
         if (!backlink.getModifiers().contains(Modifier.FINAL)) {
             Utils.error(String.format(
+                    Locale.US,
                     "A @LinkingObjects field \"%s.%s\" must be final.",
                     targetClass,
                     targetField));
@@ -188,7 +196,7 @@ public boolean validateTarget(ClassMetaData clazz) {
         VariableElement field = clazz.getDeclaredField(sourceField);
 
         if (field == null) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", does not exist in class \"%s\".",
                     sourceField,
                     targetClass,
@@ -199,7 +207,7 @@ public boolean validateTarget(ClassMetaData clazz) {
 
         String fieldType = field.asType().toString();
         if (!(targetClass.equals(fieldType) || targetClass.equals(Utils.getRealmListType(field)))) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s.%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", has type \"%s\" instead of \"%3$s\".",
                     sourceClass,
                     sourceField,
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index b0ad1ef915..18f4a8fda0 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -21,6 +21,7 @@
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
@@ -266,7 +267,7 @@ private boolean categorizeClassElements() {
         }
 
         if (fields.size() == 0) {
-            Utils.error(String.format("Class \"%s\" must contain at least 1 persistable field.", className));
+            Utils.error(String.format(Locale.US, "Class \"%s\" must contain at least 1 persistable field.", className));
         }
 
         return true;
@@ -320,7 +321,7 @@ private boolean checkReferenceTypes() {
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Class \"%s\" must declare a public constructor with no arguments if it contains custom constructors.",
                     className));
             return false;
@@ -332,7 +333,7 @@ private boolean checkDefaultConstructor() {
     private boolean checkForFinalFields() {
         for (VariableElement field : fields) {
             if (field.getModifiers().contains(Modifier.FINAL)) {
-                Utils.error(String.format(
+                Utils.error(String.format(Locale.US,
                         "Class \"%s\" contains illegal final field \"%s\".", className, field.getSimpleName().toString()));
                 return false;
             }
@@ -343,7 +344,7 @@ private boolean checkForFinalFields() {
     private boolean checkForVolatileFields() {
         for (VariableElement field : fields) {
             if (field.getModifiers().contains(Modifier.VOLATILE)) {
-                Utils.error(String.format(
+                Utils.error(String.format(Locale.US,
                         "Class \"%s\" contains illegal volatile field \"%s\".",
                         className,
                         field.getSimpleName().toString()));
@@ -410,22 +411,22 @@ private boolean categorizeIndexField(Element element, VariableElement variableEl
             }
         }
 
-        Utils.error(String.format("Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
+        Utils.error(String.format(Locale.US, "Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
         return false;
     }
 
     // The field has the @Required annotation
     private void categorizeRequiredField(Element element, VariableElement variableElement) {
         if (Utils.isPrimitiveType(variableElement)) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "@Required annotation is unnecessary for primitive field \"%s\".", element));
         } else if (Utils.isRealmList(variableElement) || Utils.isRealmModel(variableElement)) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s\" with type \"%s\" cannot be @Required.", element, element.asType()));
         } else {
             // Should never get here - user should remove @Required
             if (nullableFields.contains(variableElement)) {
-                Utils.error(String.format(
+                Utils.error(String.format(Locale.US,
                         "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
                         element,
                         element.asType()));
@@ -437,7 +438,7 @@ private void categorizeRequiredField(Element element, VariableElement variableEl
     // String, short, int, long and must only be present one time
     private boolean categorizePrimaryKeyField(VariableElement variableElement) {
         if (primaryKey != null) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "A class cannot have more than one @PrimaryKey. Both \"%s\" and \"%s\" are annotated as @PrimaryKey.",
                     primaryKey.getSimpleName().toString(),
                     variableElement.getSimpleName().toString()));
@@ -446,7 +447,7 @@ private boolean categorizePrimaryKeyField(VariableElement variableElement) {
 
         TypeMirror fieldType = variableElement.asType();
         if (!isValidPrimaryKeyType(fieldType)) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s\" with type \"%s\" cannot be used as primary key. See @PrimaryKey for legal types.",
                     variableElement.getSimpleName().toString(),
                     fieldType));
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
index 1b177c5183..cdae9807cc 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 
 import javax.annotation.processing.ProcessingEnvironment;
@@ -44,7 +45,7 @@ public DefaultModuleGenerator(ProcessingEnvironment env) {
     }
 
     public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME);
+        String qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME);
         JavaFileObject sourceFile = env.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
         writer.setIndent("    ");
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index 1b93e5b355..da89d6a46a 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -20,6 +20,7 @@
 
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 
 
@@ -187,8 +188,8 @@ public void emitTypeConversion(
             // Only throw exception for primitive types.
             // For boxed types and String, exception will be thrown in the setter.
             String statementSetNullOrThrow = Utils.isPrimitiveType(fieldType) ?
-                    String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
-                    String.format("((%s) obj).%s(null)", interfaceName, setter);
+                    String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
+                    String.format(Locale.US, "((%s) obj).%s(null)", interfaceName, setter);
             // @formatter:off
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
@@ -211,8 +212,8 @@ public void emitStreamTypeConversion(
             // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
             // the setter.
             String statementSetNullOrThrow = (Utils.isPrimitiveType(fieldType)) ?
-                    String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
-                    String.format("((%s) obj).%s(null)", interfaceName, setter);
+                    String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
+                    String.format(Locale.US, "((%s) obj).%s(null)", interfaceName, setter);
             // @formatter:off
             writer
                 .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 0e68b14d0c..81fd9a5c11 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -26,6 +26,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
@@ -87,7 +88,7 @@ public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, Cla
         this.simpleClassName = metadata.getSimpleClassName();
         this.qualifiedClassName = metadata.getFullyQualifiedClassName();
         this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
-        this.qualifiedGeneratedClassName = String.format("%s.%s",
+        this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
                 Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));
 
         // See the configuration for the debug build type,
@@ -285,7 +286,7 @@ private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOExcep
             } else if (Utils.isRealmList(field)) {
                 emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
             } else {
-                throw new UnsupportedOperationException(String.format(
+                throw new UnsupportedOperationException(String.format(Locale.US,
                         "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
             }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
index ed1785e904..ab60954f91 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
@@ -20,6 +20,7 @@
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.util.EnumSet;
+import java.util.Locale;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -42,7 +43,7 @@ public RealmProxyInterfaceGenerator(ProcessingEnvironment processingEnvironment,
 
     public void generate() throws IOException {
         String qualifiedGeneratedInterfaceName =
-                String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className));
+                String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className));
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedInterfaceName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index bd3b75d5b5..2b22cb915d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -25,6 +25,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
@@ -55,7 +56,7 @@ public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
     }
 
     public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%sMediator", REALM_PACKAGE_NAME, className);
+        String qualifiedGeneratedClassName = String.format(Locale.US, "%s.%sMediator", REALM_PACKAGE_NAME, className);
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
         writer.setIndent("    ");
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 2f84e1f916..243336069f 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -69,6 +69,7 @@
     private JavaFileObject backlinksNotFound = JavaFileObjects.forResource("some/test/Backlinks_NotFound.java");
     private JavaFileObject backlinksNonFinalField = JavaFileObjects.forResource("some/test/Backlinks_NotFinal.java");
     private JavaFileObject backlinksWrongType = JavaFileObjects.forResource("some/test/Backlinks_WrongType.java");
+    private JavaFileObject nonLatinName = JavaFileObjects.forResource("some/test/ÁrvíztűrőTükörfúrógép.java");
 
     @Test
     public void compileSimpleFile() {
@@ -564,4 +565,12 @@ public void failsOnLinkingObjectsWithFieldWrongType() {
                 .failsToCompile()
                 .withErrorContaining("instead of");
     }
+
+    @Test
+    public void compareNonLatinName() throws Exception {
+        ASSERT.about(javaSource())
+                .that(nonLatinName)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
 }
diff --git "a/realm/realm-annotations-processor/src/test/resources/some/test/\303\201rv\303\255zt\305\261r\305\221T\303\274k\303\266rf\303\272r\303\263g\303\251p.java" "b/realm/realm-annotations-processor/src/test/resources/some/test/\303\201rv\303\255zt\305\261r\305\221T\303\274k\303\266rf\303\272r\303\263g\303\251p.java"
new file mode 100644
index 0000000000..0cf6fe08d5
--- /dev/null
+++ "b/realm/realm-annotations-processor/src/test/resources/some/test/\303\201rv\303\255zt\305\261r\305\221T\303\274k\303\266rf\303\272r\303\263g\303\251p.java"
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+
+
+/**
+ * A model class to test non latin class name.
+ */
+public class ÁrvíztűrőTükörfúrógép extends RealmObject {
+    public String name;
+    public long 델타;
+    public long Δέλτα;
+    public float 貸借対照表;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 2e802eb7f2..e9c94fb610 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -534,6 +534,9 @@ public void linkIsNull() {
 
         RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("cat").findAll();
         assertEquals(1, owners2.size());
+
+        RealmResults<Owner> owners3 = testRealm.where(Owner.class).isNull("dogs.birthday").findAll();
+        assertEquals(0, owners3.size());
     }
 
     @Test
@@ -547,6 +550,27 @@ public void linkIsNotNull() {
 
         RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("cat").findAll();
         assertEquals(0, owners2.size());
+
+        RealmResults<Owner> owners3 = testRealm.where(Owner.class).isNotNull("dogs.birthday").findAll();
+        assertEquals(1, owners3.size());
+    }
+
+    @Test
+    public void isEmpty() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isEmpty("cat.name").findAll();
+        assertEquals(0, owners1.size());
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isEmpty("dogs.name").findAll();
+        assertEquals(0, owners2.size());
+    }
+
+    @Test
+    public void isNotEmpty() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotEmpty("cat.name").findAll();
+        assertEquals(1, owners1.size());
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotEmpty("dogs.name").findAll();
+        assertEquals(1, owners2.size());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 95bb08e745..acf65b49ac 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -56,7 +56,7 @@ public void setUp() {
     @Test
     public void get_syncValues() {
         SyncSession session = new SyncSession(configuration);
-        assertEquals("realm://objectserver.realm.io/JohnDoe/default", session.getServerUrl().toString());
+        assertEquals("realm://objectserver.realm.io/" + user.getIdentity() + "/default", session.getServerUrl().toString());
         assertEquals(user, session.getUser());
         assertEquals(configuration, session.getConfiguration());
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 0ab6661ff9..c91a7e2def 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -34,7 +34,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.entities.AllJavaTypes;
 import io.realm.entities.StringOnly;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.TestSyncConfigurationFactory;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 25caf4fb6a..e49a13e89b 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -68,6 +68,10 @@ public void remove(String identity) {}
                 return null;
             }
 
+            @Override
+            public boolean isActive(String identity) {
+                return true;
+            }
         };
     }
 
@@ -139,6 +143,7 @@ public void loggedOut(SyncUser user) {
         assertEquals(0, counter[0]);
         assertEquals(0, counter[1]);
     }
+
     @Test
     public void session() throws IOException {
         SyncUser user = createTestUser();
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 237618dd48..32f8b61834 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -20,7 +20,7 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
+import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -74,8 +74,8 @@ public static void initUserStore() {
         SyncManager.setUserStore(userStore);
     }
 
-    @After
-    public void tearDown() {
+    @Before
+    public void setUp() {
         SyncManager.reset();
     }
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index 9d3a57694d..927a5f5021 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -16,15 +16,10 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.io.FileNotFoundException;
@@ -33,8 +28,6 @@
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.log.RealmLog;
-import io.realm.rule.TestRealmConfigurationFactory;
 import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index 8d0a12d01f..87d856956e 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -28,6 +28,7 @@
 import io.realm.ObjectServerError;
 import io.realm.SyncManager;
 import io.realm.SyncUser;
+import io.realm.UserStore;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
@@ -37,7 +38,6 @@
     public static final String USER_TOKEN = UUID.randomUUID().toString();
     public static final String REALM_TOKEN = UUID.randomUUID().toString();
     public static final String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
-    public static final String DEFAULT_USER_IDENTIFIER = "JohnDoe";
 
     private final static Method SYNC_MANAGER_RESET_METHOD;
     static {
@@ -49,6 +49,16 @@
         }
     }
 
+    private final static Method SYNC_MANAGER_GET_USER_STORE_METHOD;
+    static {
+        try {
+            SYNC_MANAGER_GET_USER_STORE_METHOD = SyncManager.class.getDeclaredMethod("getUserStore");
+            SYNC_MANAGER_GET_USER_STORE_METHOD.setAccessible(true);
+        } catch (NoSuchMethodException e) {
+            throw new AssertionError(e);
+        }
+    }
+
     public static SyncUser createRandomTestUser() {
         return createTestUser(UUID.randomUUID().toString(),
                 UUID.randomUUID().toString(),
@@ -59,19 +69,19 @@ public static SyncUser createRandomTestUser() {
     }
 
     public static SyncUser createTestAdminUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
     }
 
     public static SyncUser createTestUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createTestUser(long expires) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  DEFAULT_AUTH_URL, expires, false);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, expires, false);
     }
 
     public static SyncUser createTestUser(String authUrl) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  authUrl, Long.MAX_VALUE, false);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), authUrl, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createNamedTestUser(String userIdentifier) {
@@ -94,7 +104,12 @@ public static SyncUser createTestUser(String userTokenValue, String realmTokenVa
             obj.put("authUrl", authUrl);
             obj.put("userToken", userToken.toJson());
             obj.put("realms", realmList);
-            return SyncUser.fromJson(obj.toString());
+            SyncUser syncUser = SyncUser.fromJson(obj.toString());
+            // persist the user to the ObjectStore sync metadata, to simulate real login, otherwise SyncUser.isValid will
+            // "throw IllegalArgumentException: User not authenticated or authentication expired." since
+            // the call to  SyncManager.getUserStore().isActive(syncUser.getIdentity()) will return false
+            addToUserStore(syncUser);
+            return syncUser;
         } catch (JSONException e) {
             throw new RuntimeException(e);
         }
@@ -139,4 +154,15 @@ public static void resetSyncMetadata() {
             throw new AssertionError(e);
         }
     }
+
+    private static void addToUserStore(SyncUser user) {
+        try {
+            UserStore userStore = (UserStore) SYNC_MANAGER_GET_USER_STORE_METHOD.invoke(null);
+            userStore.put(user);
+        } catch (InvocationTargetException e) {
+            throw new AssertionError(e);
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index e2eaa319cd..31d77f1e36 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -85,6 +85,20 @@ JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeLogoutUser(JNIEnv*
     CATCH_STD()
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_RealmFileUserStore_nativeIsActive(JNIEnv* env, jclass, jstring j_identity)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor identity(env, j_identity); // throws
+        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_existing_logged_in_user(identity);
+        if (user) {
+            return to_jbool(user->state() == SyncUser::State::Active);
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
 JNIEXPORT jobjectArray JNICALL Java_io_realm_RealmFileUserStore_nativeGetAllUsers(JNIEnv* env, jclass)
 {
     TR_ENTER()
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index ed674b6c3a..f8cc250cd5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -1510,7 +1510,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* en
         }
 
         TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
-        int col_type = src_table_ref->get_column_type(S(column_idx));
+        DataType col_type = table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
                 case type_Link:
@@ -1591,7 +1591,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv*
 
         TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
 
-        int col_type = src_table_ref->get_column_type(S(column_idx));
+        DataType col_type = table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
                 case type_Link:
@@ -1674,7 +1674,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
             return;
         }
 
-        int col_type = src_table_ref->get_column_type(column_idx);
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        DataType col_type = table_ref->get_column_type(column_idx);
         if (arr_len == 1) {
             // Field queries
             switch (col_type) {
@@ -1744,7 +1745,8 @@ Java_io_realm_internal_TableQuery_nativeIsNotEmpty(JNIEnv *env, jobject, jlong n
             return;
         }
 
-        int col_type = src_table_ref->get_column_type(column_idx);
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        DataType col_type = table_ref->get_column_type(column_idx);
         if (arr_len == 1) {
             // Field queries
             switch (col_type) {
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
index c90a4d5e25..14026e3ccc 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -19,6 +19,7 @@
 #include <realm/util/assert.hpp>
 
 #include "jni_util/log.hpp"
+#include "jni_util/java_local_ref.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
@@ -91,8 +92,9 @@ void JavaLogger::log(Log::Level level, const char* tag, jthrowable throwable, co
     // "JNI called with pending exception". This is something that should be avoided when printing log in JNI --
     // Always
     // print log before calling env->ThrowNew. Doing env->ExceptionCheck() here creates overhead for normal cases.
-    env->CallVoidMethod(m_java_logger, m_log_method, level, env->NewStringUTF(tag), throwable,
-                        env->NewStringUTF(message));
+    JavaLocalRef<jstring> java_tag(env, env->NewStringUTF(tag));
+    JavaLocalRef<jstring> java_error_message(env, env->NewStringUTF(message));
+    env->CallVoidMethod(m_java_logger, m_log_method, level, java_tag.get(), throwable, java_error_message.get());
 }
 
 bool JavaLogger::is_same_object(JNIEnv* env, jobject java_logger)
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 427e782030..827ce43f28 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -66,6 +66,9 @@
 
     // 300 - 599 Reserved for Standard HTTP error codes
 
+    // user lookup endpoint returns 404 in case it couldn't honor the query
+    NOT_FOUND(404),
+
     // Realm Authentication Server response errors (600 - 699)
     INVALID_PARAMETERS(601),
     MISSING_PARAMETERS(602),
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index e208131397..8464445c5b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -77,6 +77,14 @@ public void remove(String identity) {
         return Collections.emptyList();
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isActive(String identity) {
+        return nativeIsActive(identity);
+    }
+
     private static SyncUser toSyncUserOrNull(String userJson) {
         if (userJson == null) {
             return null;
@@ -95,4 +103,6 @@ private static SyncUser toSyncUserOrNull(String userJson) {
     protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
 
     protected static native void nativeLogoutUser(String identity);
+
+    protected static native boolean nativeIsActive(String identity);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 94ea8c6a68..1ef1f5cf10 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -43,6 +43,7 @@
 import io.realm.internal.network.ChangePasswordResponse;
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.LogoutResponse;
+import io.realm.internal.network.LookupUserIdResponse;
 import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
@@ -426,6 +427,82 @@ public SyncUser run() {
         }.start();
     }
 
+    /**
+     * Helper method for Admin users in order to lookup a {@code SyncUser} using the identity provider and the used username.
+     *
+     * @param provider identity providers {@link io.realm.SyncCredentials.IdentityProvider} used when the account was created.
+     * @param providerId username or email used to create the account for the first time,
+     *                   what is needed will depend on what type of {@link SyncCredentials} was used.
+     *
+     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
+     * of an {@code invalid} provider or {@code providerId}.
+     * @throws ObjectServerError in case of an error.
+     */
+    public SyncUser retrieveUser(final String provider, final String providerId) throws ObjectServerError {
+        if (Util.isEmptyString(provider)) {
+            throw new IllegalArgumentException("Not-null 'provider' required.");
+        }
+
+        if (Util.isEmptyString(providerId)) {
+            throw new IllegalArgumentException("None empty 'providerId' required.");
+        }
+
+        if (!isAdmin()) {
+            throw new IllegalArgumentException("SyncUser needs to be admin in order to lookup other users ID.");
+        }
+
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        LookupUserIdResponse response = authServer.retrieveUser(getSyncUser().getUserToken(), provider, providerId, getAuthenticationUrl());
+        if (!response.isValid()) {
+            // the endpoint returns a 404 if it can't honor the query, either because
+            // - provider is not valid
+            // - provider_id is not valid
+            // - token used is not an admin one
+            // in this case we should return null instead of throwing
+            if (response.getError().getErrorCode() == ErrorCode.NOT_FOUND) {
+                return null;
+            } else {
+                throw response.getError();
+            }
+        } else {
+            SyncUser syncUser = SyncManager.getUserStore().get(response.getUserId());
+            if (syncUser != null) {
+                return syncUser;
+            } else {
+                // build an SynUser without a token
+                Token refreshToken = new Token(null, response.getUserId(), null, 0, null, response.isAdmin());
+                ObjectServerUser objectServerUser = new ObjectServerUser(refreshToken, getAuthenticationUrl());
+                objectServerUser.localLogout();
+                return new SyncUser(objectServerUser);
+            }
+        }
+    }
+
+    /**
+     * Asynchronously lookup a {@code SyncUser} using the identity provider and the used username.
+     * This is for Admin users only.
+     *
+     * @param provider identity providers {@link io.realm.SyncCredentials.IdentityProvider} used when the account was created.
+     * @param providerId  username or email used to create the account for the first time,
+     *                    what is needed will depend on what type of {@link SyncCredentials} was used.
+     * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     */
+    public RealmAsyncTask retrieveUserAsync(final String provider, final String providerId, final Callback callback) {
+        checkLooperThread("Asynchronously retrieving user id is only possible from looper threads.");
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public SyncUser run() {
+                return retrieveUser(provider, providerId);
+            }
+        }.start();
+    }
+
     private static void checkLooperThread(String errorMessage) {
         AndroidCapabilities capabilities = new AndroidCapabilities();
         capabilities.checkCanDeliverNotification(errorMessage);
@@ -458,7 +535,7 @@ public String toJson() {
      */
     public boolean isValid() {
         Token userToken = getSyncUser().getUserToken();
-        return syncUser.isLoggedIn() && userToken != null && userToken.expiresMs() > System.currentTimeMillis();
+        return syncUser.isLoggedIn() && userToken != null && userToken.expiresMs() > System.currentTimeMillis() && SyncManager.getUserStore().isActive(syncUser.getIdentity());
     }
 
     /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
index 7a7b488337..9d744157dc 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
@@ -68,4 +68,14 @@
      * @return Collection of all users. If no users exist, an empty collection is returned.
      */
     Collection<SyncUser> allUsers();
+
+    /**
+     * Returns the state of the specified user: {@code true} if active (not logged out), {@code false} otherwise.
+     * This method checks if the user was marked as logged out. If the user has expired but not actively logged out
+     * this method will return {@code true}.
+     *
+     * @param identity identity of the user.
+     * @return {@code true} if the user is not logged out, {@code false} otherwise.
+     */
+    boolean isActive(String identity);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index 60151daf6d..d70160e7fb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -28,9 +28,11 @@
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
+import io.realm.SyncUser;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.log.RealmLog;
 
 @SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
 @Keep
@@ -86,11 +88,23 @@ public void realmClosed(RealmConfiguration configuration) {
     public Object[] getUserAndServerUrl(RealmConfiguration config) {
         if (config instanceof SyncConfiguration) {
             SyncConfiguration syncConfig = (SyncConfiguration) config;
+            // make sure the user is still valid
+            SyncUser user = syncConfig.getUser();
+            if (!user.isValid()) {
+                if (user.getAccessToken() == null) {
+                    throw new IllegalStateException("The SyncUser is already logged out and can not use the provided configuration to open a Realm.");
+                } else {
+                    // user was not logged out but the `refresh_token` is not longer valid
+                    // the user will still get a stall version of Realm, that will work offline
+                    // but not sync.
+                    RealmLog.warn("Can not use the provided configuration to open a Realm, the SyncUser is no longer valid.");
+                }
+            }
             String rosServerUrl = syncConfig.getServerUrl().toString();
-            String rosUserIdentity = syncConfig.getUser().getIdentity();
-            String syncRealmAuthUrl = syncConfig.getUser().getAuthenticationUrl().toString();
-            String rosRefreshToken = syncConfig.getUser().getAccessToken().value();
-            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosRefreshToken, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath()};
+            String rosUserIdentity = user.getIdentity();
+            String syncRealmAuthUrl = user.getAuthenticationUrl().toString();
+            String rosSerializedUser = user.toJson();
+            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath()};
         } else {
             return new Object[6];
         }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 869e39d8b6..8906515e83 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -66,4 +66,11 @@
      * Changes a user's password using admin account.
      */
     ChangePasswordResponse changePassword(Token adminToken, String userID, String newPassword, URL authenticationUrl);
+
+    /**
+     * Looks up a {@code SyncUser} using the identity provider {@link io.realm.SyncCredentials.IdentityProvider}
+     * used when the account was created and the username or email used to create the account for the first time
+     * what is needed will depend on what type of {@link SyncCredentials} was used.
+     */
+    LookupUserIdResponse retrieveUser(Token adminToken, String provider, String providerId, URL authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
new file mode 100644
index 0000000000..03f162131e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.Locale;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `GET /api/providers/:provider/accounts/:provider_id`
+ */
+public class LookupUserIdResponse extends AuthServerResponse {
+
+    private static final String JSON_FIELD_USER = "user";
+    private static final String JSON_FIELD_USER_ID = "id";
+    private static final String JSON_FIELD_USER_IS_ADMIN = "isAdmin";
+
+    private final String userId;
+    private final Boolean isAdmin;
+
+    /**
+     * Helper method for creating the proper lookup user response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static LookupUserIdResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new LookupUserIdResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new LookupUserIdResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new LookupUserIdResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static LookupUserIdResponse from(ObjectServerError objectServerError) {
+        return new LookupUserIdResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static LookupUserIdResponse from(Exception exception) {
+        return LookupUserIdResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private LookupUserIdResponse(ObjectServerError error) {
+        RealmLog.debug("LookupUserIdResponse - Error: " + error);
+        setError(error);
+        this.error = error;
+        this.userId = null;
+        this.isAdmin = null;
+    }
+
+    private LookupUserIdResponse(String serverResponse) {
+        ObjectServerError error;
+        String userId;
+        Boolean isAdmin;
+        String message;
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            JSONObject jsonUser = obj.getJSONObject(JSON_FIELD_USER);
+            if (jsonUser != null) {
+                userId = jsonUser.optString(JSON_FIELD_USER_ID, null);
+                // can not use optBoolean since `null` is not permitted as default value
+                // (we need it for the Boolean boxed type)
+                isAdmin = jsonUser.has(JSON_FIELD_USER_IS_ADMIN) ? jsonUser.getBoolean(JSON_FIELD_USER_IS_ADMIN) : null;
+                error = null;
+
+                message = String.format(Locale.US, "Identity %s; Path %b", userId, isAdmin);
+
+            } else {
+                userId = null;
+                isAdmin = null;
+                error = null;
+                message = "user = null";
+            }
+
+        } catch (JSONException e) {
+            userId = null;
+            isAdmin = null;
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
+            message = String.format(Locale.US, "Error %s", error.getErrorMessage());
+        }
+
+        RealmLog.debug("LookupUserIdResponse. " + message);
+        setError(error);
+        this.userId = userId;
+        this.isAdmin = isAdmin;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public boolean isAdmin() {
+        return isAdmin;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 1c7bc4afb0..35f49c92b4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -36,6 +36,7 @@
     public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
     private static final String ACTION_LOGOUT = "revoke"; // Auth end point for logging out users
     private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
+    private static final String ACTION_LOOKUP_USER_ID = "api/providers"; // Auth end point for looking up user id
 
     private final OkHttpClient client = new OkHttpClient.Builder()
             .connectTimeout(10, TimeUnit.SECONDS)
@@ -106,6 +107,15 @@ public ChangePasswordResponse changePassword(Token adminToken, String userId, St
         }
     }
 
+    @Override
+    public LookupUserIdResponse retrieveUser(Token adminToken, String provider, String providerId, URL authenticationUrl) {
+        try {
+            return lookupUserId(buildLookupUserIdUrl(authenticationUrl, ACTION_LOOKUP_USER_ID, provider, providerId), adminToken.value());
+        } catch (Exception e) {
+            return LookupUserIdResponse.from(e);
+        }
+    }
+
     // Builds the URL for a specific auth endpoint
     private static URL buildActionUrl(URL authenticationUrl, String action) {
         final String baseUrlString = authenticationUrl.toExternalForm();
@@ -117,6 +127,18 @@ private static URL buildActionUrl(URL authenticationUrl, String action) {
         }
     }
 
+    private static URL buildLookupUserIdUrl(URL authenticationUrl, String action, String provider, String providerId) {
+        String authURL = authenticationUrl.toExternalForm();
+        // we need the base URL without the '/auth' part
+        String baseUrlString = authURL.substring(0, authURL.indexOf(authenticationUrl.getPath()));
+        try {
+            String separator = baseUrlString.endsWith("/") ? "" : "/";
+            return new URL(baseUrlString + separator + action + "/" + provider + "/accounts/" + providerId);
+        } catch (MalformedURLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
     private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
         RealmLog.debug("Network request (authenticate): " + authenticationUrl);
         Request request = newAuthRequest(authenticationUrl).post(RequestBody.create(JSON, requestBody)).build();
@@ -141,6 +163,14 @@ private ChangePasswordResponse changePassword(URL changePasswordUrl, String requ
         return ChangePasswordResponse.from(response);
     }
 
+    private LookupUserIdResponse lookupUserId(URL lookupUserIdUrl, String token) throws Exception {
+        RealmLog.debug("Network request (lookupUserId): " + lookupUserIdUrl);
+        Request request = newAuthRequest(lookupUserIdUrl).get().header("Authorization", token).build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return LookupUserIdResponse.from(response);
+    }
+
     private Request.Builder newAuthRequest(URL url) {
         return new Request.Builder()
                 .url(url)
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index a2ed00777c..be0a22499f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -11,6 +11,7 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -18,6 +19,7 @@
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
@@ -28,9 +30,11 @@
 import io.realm.rule.RunTestInLooperThread;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 
 
 @RunWith(AndroidJUnit4.class)
@@ -266,4 +270,253 @@ public void changePassword_throwWhenUserIsLoggedOut() {
         user.changePassword("new-password");
     }
 
+    // Cached instances of RealmConfiguration should not be allowed to be used if the user is no longer valid
+    @Test
+    public void cachedInstanceShouldThrowIfUserBecomeInvalid() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+        Realm realm = Realm.getInstance(configuration);
+
+        user.logout();
+        assertFalse(user.isValid());
+
+        final CountDownLatch backgroundThread = new CountDownLatch(1);
+        // Should throw when using the invalid configuration form a different thread
+        new Thread() {
+            @Override
+            public void run() {
+                try {
+                    Realm.getInstance(configuration);
+                    fail("Invalid SyncConfiguration should throw");
+                } catch (IllegalStateException expected) {
+                } finally {
+                    backgroundThread.countDown();
+                }
+            }
+        }.start();
+
+        backgroundThread.await();
+
+        // it is ok to return the cached instance, since this use case is legit
+        // user refresh token can timeout, or the token can be revoked from ROS
+        // while running the Realm instance. So it doesn't make sense to break this behaviour
+        Realm cachedInstance = Realm.getInstance(configuration);
+        assertNotNull(cachedInstance);
+
+        realm.close();
+        cachedInstance.close();
+    }
+
+    @Test
+    public void buildingSyncConfigurationShouldThrowIfInvalidUser() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.currentUser();
+        user.logout();
+
+        assertFalse(user.isValid());
+
+        try {
+            // We should not be able to build a configuration with an invalid/logged out user
+            new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+            fail("Invalid user, it should not be possible to create a SyncConfiguration");
+        } catch (IllegalArgumentException expected) {
+            // User not authenticated or authentication expired.
+        }
+
+        try {
+            // We should not be able to build a configuration with an invalid/logged out user
+            new SyncConfiguration.Builder(currentUser, Constants.USER_REALM).build();
+            fail("Invalid currentUser, it should not be possible to create a SyncConfiguration");
+        } catch (IllegalArgumentException expected) {
+            // User not authenticated or authentication expired.
+        }
+    }
+
+    // using a logout user should throw
+    @Test
+    public void usingConfigurationWithInvalidUserShouldThrow() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+        user.logout();
+        assertFalse(user.isValid());
+
+        try {
+            Realm.getInstance(configuration);
+            fail("SyncUser is not longer valid, it should not be possible to get a Realm instance");
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    // logging out 'user' should have the same impact on other instance(s) of the same user
+    @Test
+    public void loggingOutUserShouldImpactOtherInstances() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.currentUser();
+
+        assertTrue(user.isValid());
+        assertEquals(user, currentUser);
+
+        user.logout();
+
+        assertFalse(user.isValid());
+        assertFalse(currentUser.isValid());
+    }
+
+    // logging out 'currentUser' should have the same impact on other instance(s) of the user
+    @Test
+    public void loggingOutCurrentUserShouldImpactOtherInstances() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.currentUser();
+
+        assertTrue(user.isValid());
+        assertEquals(user, currentUser);
+
+        SyncUser.currentUser().logout();
+
+        assertFalse(user.isValid());
+        assertFalse(currentUser.isValid());
+        assertNull(SyncUser.currentUser());
+    }
+
+    @Test
+    public void retrieve() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+
+        String identity = user.getIdentity();
+        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username);
+        assertNotNull(syncUser);
+        assertEquals(identity, syncUser.getIdentity());
+        assertFalse(syncUser.isAdmin());
+        assertTrue(syncUser.isValid());
+    }
+
+    @Test
+    public void retrieve_logout() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final String identity = user.getIdentity();
+        user.logout();
+        assertFalse(user.isValid());
+
+        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username);
+        assertNotNull(syncUser);
+        assertEquals(identity, syncUser.getIdentity());
+        assertFalse(syncUser.isAdmin());
+        assertFalse(syncUser.isValid());
+    }
+
+    @Test
+    public void retrieve_AdminUser() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.DEBUG, "admin");// TODO use enum for auth provider
+        assertNotNull(syncUser);
+        assertEquals(adminUser.getIdentity(), syncUser.getIdentity());
+        assertTrue(syncUser.isAdmin());
+        assertTrue(syncUser.isValid());
+    }
+
+    @Test
+    public void retrieve_unknownProviderId() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, "doesNotExist");
+        assertNull(syncUser);
+    }
+
+    @Test
+    public void retrieve_invalidProvider() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+
+        SyncUser syncUser = adminUser.retrieveUser("invalid", "username");
+        assertNull(syncUser);
+    }
+
+    @Test
+    public void retrieve_notAdmin() {
+        final String username1 = UUID.randomUUID().toString();
+        final String password1 = "password";
+        final SyncCredentials credentials1 = SyncCredentials.usernamePassword(username1, password1, true);
+        final SyncUser user1 = SyncUser.login(credentials1, Constants.AUTH_URL);
+        assertTrue(user1.isValid());
+
+        final String username2 = UUID.randomUUID().toString();
+        final String password2 = "password";
+        final SyncCredentials credentials2 = SyncCredentials.usernamePassword(username2, password2, true);
+        final SyncUser user2 = SyncUser.login(credentials2, Constants.AUTH_URL);
+        assertTrue(user2.isValid());
+
+        // trying to lookup user2 using user1 should not work (requires admin token)
+        try {
+            user1.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username2);
+            fail("It should not be possible to lookup a user using non admin token");
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void retrieve_async() {
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+
+        // Login an admin user
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(adminUser.isValid());
+        assertTrue(adminUser.isAdmin());
+
+        final String identity = user.getIdentity();
+        adminUser.retrieveUserAsync("password", username, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser syncUser) {
+
+                assertNotNull(syncUser);
+                assertEquals(identity, syncUser.getIdentity());
+                assertFalse(syncUser.isAdmin());
+                assertTrue(syncUser.isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.getErrorMessage());
+            }
+        });
+    }
 }
