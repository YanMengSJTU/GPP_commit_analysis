diff --git a/CHANGELOG.md b/CHANGELOG.md
index ce1d742950..b1bab8fc53 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,17 +1,33 @@
 ## 2.4.0
 
+## 2.3.2
+
+### Internal
+
+* Updated to Realm Sync v1.0.4.
+* Updated to Realm Core v2.3.1.
+
 ## 2.3.1
 
+### Enhancements
+
+* [ObjectServer] The `serverUrl` given to `SyncConfiguration.Builder()` is now more lenient and will also accept only paths as argument (#4144).
+
 ### Bug fixes
 
-* Fixed NPE problem happened in SharedRealm.finalize() (#3730).
-* Fixed a build error when the project is using Kotlin (#4087).
-* Fixed a bug causing classes to be replaced by classes already in Gradle's classpath (#3568).
+* NPE problem in SharedRealm.finalize() (#3730).
+* `RealmList.contains()` and `RealmResults.contains()` now correctly use custom `equals()` method on Realm model classes.
+* Build error when the project is using Kotlin (#4087).
+* Bug causing classes to be replaced by classes already in Gradle's classpath (#3568).
 * NullPointerException when notifying a single object that it changed (#4086).
 
+### Enhancements
+
+* [ObjectServer] Add a timer to refresh periodically the access_token.
+
 ## 2.3.0
 
-### Object Server API Changes 
+### Object Server API Changes
 
 * Realm Sync v1.0.0 has been released, and Realm Mobile Platform is no longer considered in beta.
 * Breaking change: Location of Realm files are now placed in `getFilesDir()/<userIdentifier>` instead of `getFilesDir()/`.
diff --git a/dependencies.list b/dependencies.list
index daca48ea06..ef11c2e0f6 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.0.0
-REALM_SYNC_SHA256=0e95ee9ed06f1bf66d1531086197e6549ad7ca36da6400b0c5026c5a0c3c4249
+REALM_SYNC_VERSION=1.0.4
+REALM_SYNC_SHA256=a1d00577219b7c2749a0b4baa8b07ead2380bc47907fb2ce4b13cf59d26ca463
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index d903e5a208..73f0663136 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -51,17 +51,17 @@ class KotlinExampleActivity : Activity() {
         // Open the realm for the UI thread.
         realm = Realm.getDefaultInstance()
 
-        basicCRUD(realm)
-        basicQuery(realm)
-        basicLinkQuery(realm)
-
         // Delete all persons
         // Using executeTransaction with a lambda reduces code size and makes it impossible
         // to forget to commit the transaction.
         realm.executeTransaction {
-            realm.delete(Person::class.java)
+            realm.deleteAll()
         }
 
+        basicCRUD(realm)
+        basicQuery(realm)
+        basicLinkQuery(realm)
+
         // More complex operations can be executed on another thread, for example using
         // Anko's async extension method.
         async() {
@@ -93,7 +93,7 @@ class KotlinExampleActivity : Activity() {
         // All writes must be wrapped in a transaction to facilitate safe multi threading
         realm.executeTransaction {
             // Add a person
-            val person = realm.createObject(Person::class.java, 1)
+            val person = realm.createObject(Person::class.java, 0)
             person.name = "Young Person"
             person.age = 14
         }
@@ -139,9 +139,8 @@ class KotlinExampleActivity : Activity() {
         realm.executeTransaction {
             val fido = realm.createObject(Dog::class.java)
             fido.name = "fido"
-            for (i in 0..9) {
-                val person = realm.createObject(Person::class.java)
-                person.id = i.toLong()
+            for (i in 1..9) {
+                val person = realm.createObject(Person::class.java, i.toLong())
                 person.name = "Person no. $i"
                 person.age = i
                 person.dog = fido
@@ -177,7 +176,6 @@ class KotlinExampleActivity : Activity() {
 
         // Sorting
         val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
-        check(realm.where(Person::class.java).findAll().last().name == sortedPersons.first().name)
         status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
 
         realm.close()
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index e6e4813551..94ee5af4f4 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -174,11 +174,14 @@ class RealmTransformer extends Transform {
             it.getPackageName()
         }
 
+        def targetSdk = project?.android?.defaultConfig?.targetSdkVersion?.mApiLevel as String;
+        def minSdk = project?.android?.defaultConfig?.minSdkVersion?.mApiLevel as String;
+
         def env = System.getenv()
         def disableAnalytics = env["REALM_DISABLE_ANALYTICS"]
         if (disableAnalytics == null || disableAnalytics != "true") {
             boolean sync = project?.realm?.syncEnabled != null && project.realm.syncEnabled
-            def analytics = new RealmAnalytics(packages as Set, containsKotlin, sync)
+            def analytics = new RealmAnalytics(packages as Set, containsKotlin, sync, targetSdk, minSdk)
             analytics.execute()
         }
     }
diff --git a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
index 18dd7b827b..9e0a240aea 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
@@ -71,7 +71,9 @@
             + "      \"Realm Version\": \"%REALM_VERSION%\",\n"
             + "      \"Host OS Type\": \"%OS_TYPE%\",\n"
             + "      \"Host OS Version\": \"%OS_VERSION%\",\n"
-            + "      \"Target OS Type\": \"android\"\n"
+            + "      \"Target OS Type\": \"android\",\n"
+            + "      \"Target OS Version\": \"%TARGET_SDK%\",\n"
+            + "      \"Target OS Minimum Version\": \"%MIN_SDK%\"\n"
             + "   }\n"
             + "}";
 
@@ -80,11 +82,15 @@
 
     private boolean usesKotlin;
     private boolean usesSync;
+    private String targetSdk;
+    private String minSdk;
 
-    public RealmAnalytics(Set<String> packages, boolean usesKotlin, boolean usesSync) {
+    public RealmAnalytics(Set<String> packages, boolean usesKotlin, boolean usesSync, String targetSdk, String minSdk) {
         this.packages = packages;
         this.usesKotlin = usesKotlin;
         this.usesSync = usesSync;
+        this.targetSdk = targetSdk;
+        this.minSdk = minSdk;
     }
 
     private void send() {
@@ -133,7 +139,9 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
                 .replaceAll("%SYNC_VERSION%", usesSync ? "\"" + Version.SYNC_VERSION + "\"": "null")
                 .replaceAll("%REALM_VERSION%", Version.VERSION)
                 .replaceAll("%OS_TYPE%", System.getProperty("os.name"))
-                .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
+                .replaceAll("%OS_VERSION%", System.getProperty("os.version"))
+                .replaceAll("%TARGET_SDK%", targetSdk)
+                .replaceAll("%MIN_SDK%", minSdk);
     }
 
     /**
diff --git a/realm/config/checkstyle/checkstyle.xml b/realm/config/checkstyle/checkstyle.xml
index b3903724c8..3926b73b72 100644
--- a/realm/config/checkstyle/checkstyle.xml
+++ b/realm/config/checkstyle/checkstyle.xml
@@ -26,7 +26,7 @@
 
     <!-- Space after 'for', 'if', 'while', 'try' -->
     <module name="RegexpSingleline">
-        <property name="format" value="^\s*(for|if|while|try)[^ ]"/>
+        <property name="format" value="^\s*(for|if|while|try)\b[^ ]"/>
         <property name="message" value="Space needed before opening parenthesis."/>
     </module>
 
diff --git a/realm/realm-library/src/androidTest/assets/rename-and-add-indexed.realm b/realm/realm-library/src/androidTest/assets/rename-and-add-indexed.realm
new file mode 100644
index 0000000000..851be9725a
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/rename-and-add-indexed.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/rename-and-add.realm b/realm/realm-library/src/androidTest/assets/rename-and-add.realm
new file mode 100644
index 0000000000..e873f83f4a
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/rename-and-add.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index ee6946c1f9..09b297ae05 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -131,7 +131,7 @@ public void insert() {
         assertNull(realmTypes.getFieldList().get(0).getFieldIgnored());
 
 
-        // make sure Dog was not inserted twice in the recursive process
+        // Makes sure Dog was not inserted twice in the recursive process.
         assertEquals(2, realm.where(AllJavaTypes.class).findAll().size());
     }
 
@@ -310,7 +310,7 @@ public void insertOrUpdate_cyclicDependenciesFromOtherRealm() {
         dog.setOwner(owner);
         realm1.commitTransaction();
 
-        //Copy object with relations from realm1 to realm2
+        // Copies object with relations from realm1 to realm2.
         realm2.beginTransaction();
         realm2.insertOrUpdate(owner);
         realm2.commitTransaction();
@@ -422,7 +422,7 @@ public void execute(Realm realm) {
         assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
 
-        // Check that the only element has all its properties updated
+        // Checks that the only element has all its properties updated.
         assertNotNull(obj);
         assertEquals("Bar", obj.getColumnString());
         assertEquals(1, obj.getColumnLong());
@@ -471,7 +471,7 @@ public void execute(Realm realm) {
     }
 
     /**
-     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     * Added to reproduce https://github.com/realm/realm-java/issues/3103
      */
     @Test
     public void insert_emptyListWithCompositeMediator() {
@@ -499,7 +499,7 @@ public void execute(Realm realm) {
     }
 
     /**
-     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     * Added to reproduce https://github.com/realm/realm-java/issues/3103
      */
     @Test
     public void insert_emptyListWithFilterableMediator() {
@@ -567,7 +567,7 @@ public void execute(Realm realm) {
     }
 
     /**
-     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     * Added to reproduce https://github.com/realm/realm-java/issues/3103
      */
     @Test
     public void insertOrUpdate_emptyListWithCompositeMediator() {
@@ -595,7 +595,7 @@ public void execute(Realm realm) {
     }
 
     /**
-     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     * Added to reproduce https://github.com/realm/realm-java/issues/3103
      */
     @Test
     public void insertOrUpdate_emptyListWithFilterableMediator() {
@@ -657,7 +657,7 @@ public void insertOrUpdate_mixingPrimaryKeyAndNoPrimaryKeyModels() {
         assertEquals(42, all.get(0).getColumnInt());
         assertNotNull(all.get(0).getColumnRealmObjectNoPK());
         assertEquals("updated B", all.get(0).getColumnRealmObjectNoPK().getColumnString());
-        // since AllTypes doesn't have a PK we now have two instances
+        // Since AllTypes doesn't have a PK we now have two instances.
         assertEquals(2, realm.where(AllTypes.class).findAll().size());
     }
 
@@ -686,8 +686,8 @@ public void insertOrUpdate_mixingNoPrimaryKeyAndPrimaryKeyModels() {
         assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
 
         objA_no_pk.setColumnString("different A");
-        objA_no_pk.setColumnInt(42);//should insert a new instance
-        // update (since it has a PK) now both AllTypesPrimaryKey points to the same objB_pk instance
+        objA_no_pk.setColumnInt(42); // Should insert a new instance
+        // Updates (since it has a PK) now both AllTypesPrimaryKey points to the same objB_pk instance.
         objB_pk.setColumnString("updated B");
 
         realm.beginTransaction();
@@ -749,7 +749,7 @@ public void insertOrUpdate_mixingPrimaryAndNoPrimaryKeyList() {
         assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
     }
 
-    //any omitted argument should not end in a SIGSEGV but an exception
+    // Any omitted argument should not end in a SIGSEGV but an exception.
 
     @Test
     public void insert_nullObject() {
@@ -803,7 +803,7 @@ public void insert_listWithNullElement() {
         }
     }
 
-    //Inserting a managed object will result in it being copied or updated again
+    // Inserting a managed object will result in it being copied or updated again.
     @Test
     public void insertOrUpdate_managedObject() {
         AllJavaTypes obj = new AllJavaTypes();
@@ -895,7 +895,7 @@ public void insertOrUpdate_collectionOfManagedObjects() {
         assertEquals(1, allTypes.getColumnRealmList().size());
     }
 
-    // To reproduce https://github.com/realm/realm-java/issues/3105
+    // To reproduce https://github.com/realm/realm-java/issues/3105.
     @Test
     public void insertOrUpdate_shouldNotClearRealmList() {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 1ef8aad27b..2c0051d66d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -32,50 +32,50 @@
 
     protected final static long YEAR_MILLIS = TimeUnit.DAYS.toMillis(365);
 
-    // Enumerate all known collection classes from the Realm API.
+    // Enumerates all known collection classes from the Realm API.
     protected enum CollectionClass {
         MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS
     }
 
-    // Enumerate all current supported collections that can be in unmanaged mode.
+    // Enumerates all current supported collections that can be in unmanaged mode.
     protected enum UnManagedCollection {
         UNMANAGED_REALMLIST
     }
 
-    // Enumerate all current supported collections that can be managed by Realm.
+    // Enumerates all current supported collections that can be managed by Realm.
     protected enum ManagedCollection {
         MANAGED_REALMLIST, REALMRESULTS
     }
 
-    // Enumerate all methods from the RealmCollection interface that depend on Realm API's.
+    // Enumerates all methods from the RealmCollection interface that depend on Realm API's.
     protected enum RealmCollectionMethod {
         WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID, IS_MANAGED
     }
 
-    // Enumerate all methods from the Collection interface
+    // Enumerates all methods from the Collection interface
     protected enum CollectionMethod {
         ADD_OBJECT, ADD_ALL_OBJECTS, CLEAR, CONTAINS, CONTAINS_ALL, EQUALS, HASHCODE, IS_EMPTY, ITERATOR, REMOVE_OBJECT,
         REMOVE_ALL, RETAIN_ALL, SIZE, TO_ARRAY, TO_ARRAY_INPUT
     }
 
-    // Enumerate all methods on the List interface and OrderedRealmCollection interface that doesn't depend on Realm
+    // Enumerates all methods on the List interface and OrderedRealmCollection interface that doesn't depend on Realm
     // API's.
     protected enum ListMethod {
         FIRST, LAST, ADD_INDEX, ADD_ALL_INDEX, GET_INDEX, INDEX_OF, LAST_INDEX_OF, LIST_ITERATOR, LIST_ITERATOR_INDEX, REMOVE_INDEX,
         SET, SUBLIST
     }
 
-    // Enumerate all methods from the OrderedRealmCollection interface that depend on Realm API's.
+    // Enumerates all methods from the OrderedRealmCollection interface that depend on Realm API's.
     protected enum OrderedRealmCollectionMethod {
         DELETE_INDEX, DELETE_FIRST, DELETE_LAST, SORT, SORT_FIELD, SORT_2FIELDS, SORT_MULTI
     }
 
-    // Enumerate all methods that can mutate a RealmCollection
+    // Enumerates all methods that can mutate a RealmCollection.
     protected enum CollectionMutatorMethod {
         DELETE_ALL, ADD_OBJECT, ADD_ALL_OBJECTS, CLEAR, REMOVE_OBJECT, REMOVE_ALL, RETAIN_ALL
     }
 
-    // Enumerate all methods that can mutate a RealmOrderedCollection
+    // Enumerates all methods that can mutate a RealmOrderedCollection.
     protected enum OrderedCollectionMutatorMethod {
         DELETE_INDEX, DELETE_FIRST, DELETE_LAST, ADD_INDEX, ADD_ALL_INDEX, SET, REMOVE_INDEX
     }
@@ -93,7 +93,7 @@ protected void populateRealm(Realm realm, int objects) {
                 nonLatinFieldNames.setΔέλτα(i);
             }
 
-            // Add all items to the RealmList on the first object
+            // Adds all items to the RealmList on the first object.
             AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 0).findFirst();
             RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_ID, Sort.ASCENDING);
             RealmList<AllJavaTypes> list = firstObj.getFieldList();
@@ -155,7 +155,7 @@ private void fillObject(int index, int totalObjects, AllJavaTypes obj) {
         return result;
     }
 
-    // Create a number of objects that mix null and real values for number type fields.
+    // Creates a number of objects that mix null and real values for number type fields.
     protected void populatePartialNullRowsForNumericTesting(Realm realm) {
         NullTypes nullTypes1 = new NullTypes();
         nullTypes1.setId(1);
@@ -185,7 +185,7 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
         realm.commitTransaction();
     }
 
-    // Create a list of AllJavaTypes with its `fieldString` field set to a given value.
+    // Creates a list of AllJavaTypes with its `fieldString` field set to a given value.
     protected OrderedRealmCollection<AllJavaTypes> createStringCollection(Realm realm, ManagedCollection collectionClass, String... args) {
         realm.beginTransaction();
         realm.deleteAll();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
index 0205aa80ce..d8cfe9972b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
@@ -89,7 +89,7 @@ public void copyDeeply() {
         assertEquals(columnIndices.getColumnIndex(Dog.class, Dog.FIELD_AGE),
                 deepCopy.getColumnIndex(Dog.class, Dog.FIELD_AGE));
 
-        // check if those are different instance.
+        // Checks if those are different instance.
         assertNotSame(columnIndices, deepCopy);
         assertNotSame(columnIndices.getColumnInfo(Cat.class), deepCopy.getColumnInfo(Cat.class));
         assertNotSame(columnIndices.getColumnInfo(Dog.class), deepCopy.getColumnInfo(Dog.class));
@@ -108,7 +108,7 @@ public void copyFrom() {
 
         catColumnInfoInSource.nameIndex++;
 
-        // check preconditions
+        // Checks preconditions.
         assertNotEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
         assertNotSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
index ae20b233a3..618c54d588 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
@@ -61,7 +61,7 @@ public void copyColumnInfoFrom_checkIndex() {
         sourceColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
         targetColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
 
-        // check precondition
+        // Checks precondition.
         assertNotSame(sourceColumnInfo, targetColumnInfo);
         assertNotSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
 
@@ -94,7 +94,7 @@ public void copyColumnInfoFrom_checkIndex() {
         assertEquals(7, targetColumnInfo.ownerIndex);
         assertEquals(8, targetColumnInfo.scaredOfDogIndex);
 
-        // current implementation shares the indices map.
+        // Current implementation shares the indices map.
         assertSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
     }
 
@@ -115,7 +115,7 @@ public void clone_hasSameValue() {
 
         CatRealmProxy.CatColumnInfo copy = columnInfo.clone();
 
-        // modify original object
+        // Modifies original object.
         columnInfo.nameIndex = 0;
         columnInfo.ageIndex = 0;
         columnInfo.heightIndex = 0;
@@ -136,7 +136,7 @@ public void clone_hasSameValue() {
         assertEquals(7, copy.ownerIndex);
         assertEquals(8, copy.scaredOfDogIndex);
 
-        // current implementation shares the indices map between copies.
+        // Current implementation shares the indices map between copies.
         assertSame(columnInfo.getIndicesMap(), copy.getIndicesMap());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 9386beb7cb..b6552f7105 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -136,15 +136,15 @@ public void constructor_unmanagedObjectThrows() {
         new DynamicRealmObject(new AllTypes());
     }
 
-    // Test that all getters fail if given invalid field name
+    // Tests that all getters fail if given invalid field name.
     @Test
     public void typedGetter_illegalFieldNameThrows() {
-        // Set arguments
+        // Sets arguments.
         String linkedField = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_STRING;
         List<String> arguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_STRING, linkedField);
         List<String> stringArguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_BOOLEAN, linkedField);
 
-        // Test all getters
+        // Tests all getters.
         for (SupportedType type : SupportedType.values()) {
 
             // We cannot modularize everything, so STRING is a special case with its own set
@@ -167,7 +167,7 @@ public void typedGetter_illegalFieldNameThrows() {
     public void typedGetter_wrongUnderlyingTypeThrows() {
         for (SupportedType type : SupportedType.values()) {
             try {
-                // Make sure we hit the wrong underlying type for all types.
+                // Makes sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.DOUBLE) {
                     callGetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
                 } else {
@@ -177,7 +177,7 @@ public void typedGetter_wrongUnderlyingTypeThrows() {
             } catch (IllegalArgumentException ignored) {
             }
             try {
-                // Make sure we hit the wrong underlying type for all types.
+                // Makes sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.DOUBLE) {
                     callGetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
                 } else {
@@ -189,7 +189,7 @@ public void typedGetter_wrongUnderlyingTypeThrows() {
         }
     }
 
-    // Helper method for calling getters with different field names
+    // Helper method for calling getters with different field names.
     private static void callGetter(DynamicRealmObject target, SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
             switch (type) {
@@ -211,16 +211,16 @@ private static void callGetter(DynamicRealmObject target, SupportedType type, Li
         }
     }
 
-    // Test that all getters fail if given an invalid field name
+    // Tests that all getters fail if given an invalid field name.
     @Test
     public void typedSetter_illegalFieldNameThrows() {
 
-        // Set arguments
+        // Sets arguments.
         String linkedField = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_STRING;
         List<String> arguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_STRING, linkedField);
         List<String> stringArguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_BOOLEAN, linkedField);
 
-        // Test all getters
+        // Tests all getters.
         for (SupportedType type : SupportedType.values()) {
             List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
             try {
@@ -241,7 +241,7 @@ public void typedSetter_wrongUnderlyingTypeThrows() {
         for (SupportedType type : SupportedType.values()) {
             realm.beginTransaction();
             try {
-                // Make sure we hit the wrong underlying type for all types.
+                // Makes sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.STRING) {
                     callSetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
                 } else {
@@ -254,7 +254,7 @@ public void typedSetter_wrongUnderlyingTypeThrows() {
             }
             dynamicRealm.beginTransaction();
             try {
-                // Make sure we hit the wrong underlying type for all types.
+                // Makes sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.STRING) {
                     callSetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
                 } else {
@@ -312,7 +312,7 @@ public void typedSetter_changePrimaryKeyThrows() {
         }
     }
 
-    // Helper method for calling setters with different field names
+    // Helper method for calling setters with different field names.
     private static void callSetter(DynamicRealmObject target, SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
             switch (type) {
@@ -334,7 +334,7 @@ private static void callSetter(DynamicRealmObject target, SupportedType type, Li
         }
     }
 
-    // Test all typed setters/setters
+    // Tests all typed setters/setters.
     @Test
     public void typedGettersAndSetters() {
         realm.beginTransaction();
@@ -388,7 +388,7 @@ public void typedGettersAndSetters() {
                         assertEquals(dObj, dObj.getObject(AllJavaTypes.FIELD_OBJECT));
                         break;
                     case LIST:
-                        // ignore, see testGetList/testSetList
+                        // Ignores. See testGetList/testSetList.
                         break;
                     default:
                         fail();
@@ -505,7 +505,7 @@ public void setter_nullOnRequiredFieldsThrows() {
         }
     }
 
-    // Test types where you can set null using the typed setter instead of using setNull().
+    // Tests types where you can set null using the typed setter instead of using setNull().
     @Test
     public void typedSetter_null() {
         realm.beginTransaction();
@@ -735,7 +735,7 @@ public void untypedSetter_listMixedTypesThrows() {
         dObjTyped.set(AllJavaTypes.FIELD_LIST, list);
     }
 
-    // List is not a simple getter, test separately.
+    // List is not a simple getter, tests separately.
     @Test
     public void getList() {
         realm.beginTransaction();
@@ -921,7 +921,7 @@ public void untypedSetter_illegalImplicitConversionThrows() {
                 } catch (IllegalArgumentException ignored) {
                 } catch (RealmException e) {
                     if (!(e.getCause() instanceof ParseException)) {
-                        // providing "foo" to the date parser will blow up with a RealmException
+                        // Providing "foo" to the date parser will blow up with a RealmException
                         // and the cause will be a ParseException.
                         fail(type + " failed");
                     }
@@ -1048,7 +1048,7 @@ public void hashcode() {
 
     @Test
     public void toString_test() {
-        // Check that toString() doesn't crash. And do simple formatting checks. We cannot compare to a set String as
+        // Checks that toString() doesn't crash, and does simple formatting checks. We cannot compare to a set String as
         // eg. the byte array will be allocated each time it is accessed.
         String str = dObjTyped.toString();
         assertTrue(str.startsWith("AllJavaTypes = ["));
@@ -1078,14 +1078,14 @@ public void toString_nullValues() {
 
 
     public void testExceptionMessage() {
-        // test for https://github.com/realm/realm-java/issues/2141
+        // Tests for https://github.com/realm/realm-java/issues/2141
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
         DynamicRealmObject o = new DynamicRealmObject(obj);
         try {
-            o.getFloat("nonExisting"); // Note that "o" does not have "nonExisting" field.
+            o.getFloat("nonExisting"); // Notes that "o" does not have "nonExisting" field.
             fail();
         } catch (IllegalArgumentException e) {
             assertEquals("Illegal Argument: Field not found: nonExisting", e.getMessage());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index cca89c96ca..ca45c3923b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -71,7 +71,7 @@
     public void setUp() {
         defaultConfig = configFactory.createConfiguration();
 
-        // Initialize schema. DynamicRealm will not do that, so let a normal Realm create the file first.
+        // Initializes schema. DynamicRealm will not do that, so let a normal Realm create the file first.
         Realm.getInstance(defaultConfig).close();
         realm = DynamicRealm.getInstance(defaultConfig);
     }
@@ -108,7 +108,7 @@ private void populateTestRealm(DynamicRealm realm, int objects) {
         }
     }
 
-    // Test that the SharedGroupManager is not reused across Realm/DynamicRealm on the same thread.
+    // Tests that the SharedGroupManager is not reused across Realm/DynamicRealm on the same thread.
     // This is done by starting a write transaction in one Realm and verifying that none of the data
     // written (but not committed) is available in the other Realm.
     @Test
@@ -131,7 +131,7 @@ public void separateSharedGroups() {
         }
     }
 
-    // Test that Realms can only be deleted after all Typed and Dynamic instances are closed
+    // Tests that Realms can only be deleted after all Typed and Dynamic instances are closed.
     @Test
     public void deleteRealm_ThrowsIfDynamicRealmIsOpen() {
         realm.close(); // Close Realm opened in setUp();
@@ -333,7 +333,7 @@ public void execute(DynamicRealm realm) {
                 }
             });
         } catch (RuntimeException ignored) {
-            // Ensure that we pass a valuable error message to the logger for developers.
+            // Ensures that we pass a valuable error message to the logger for developers.
             assertEquals(testLogger.message, "Could not cancel transaction, not currently in a transaction.");
         } finally {
             RealmLog.remove(testLogger);
@@ -410,7 +410,7 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
         looperThread.keepStrongReference.add(allTypes);
     }
 
-    // Initialize a Dynamic Realm used by the *Async tests and keep it ref in the looperThread.
+    // Initializes a Dynamic Realm used by the *Async tests and keeps it ref in the looperThread.
     private DynamicRealm initializeDynamicRealm() {
         RealmConfiguration defaultConfig = looperThread.realmConfiguration;
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
@@ -439,14 +439,14 @@ public void findAllSortedAsync_usingMultipleFields() {
         dynamicRealm.commitTransaction();
         dynamicRealm.setAutoRefresh(true);
 
-        // Sort first set by using: String[ASC], Long[DESC]
+        // Sorts first set by using: String[ASC], Long[DESC].
         final RealmResults<DynamicRealmObject> realmResults1 = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .findAllSortedAsync(
                         new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
                         new Sort[]{Sort.ASCENDING, Sort.DESCENDING}
                 );
 
-        // Sort second set by using: String[DESC], Long[ASC]
+        // Sorts second set by using: String[DESC], Long[ASC].
         final RealmResults<DynamicRealmObject> realmResults2 = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .between(AllTypes.FIELD_LONG, 0, 5)
                 .findAllSortedAsync(
@@ -534,7 +534,7 @@ public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
         final DynamicRealm dynamicRealm = initializeDynamicRealm();
         final DynamicRealmObject[] dynamicRealmObject = new DynamicRealmObject[1];
 
-        // Intercept completion of the async DynamicRealmObject query
+        // Intercepts completion of the async DynamicRealmObject query.
         Handler handler = new HandlerProxy(dynamicRealm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 87d1799643..2278bf240d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -80,11 +80,11 @@ public void iOSDataTypes() throws IOException {
                     "ios/" + iosVersion + "-alltypes.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
             RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
-            // Verify metadata
+            // Verifies metadata.
             Table table = realm.getTable(IOSAllTypes.class);
             assertTrue(table.hasPrimaryKey());
             assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
-            // iterative check
+            // Iterative check.
             for (int i = 0; i < 10; i++) {
                 IOSAllTypes obj = result.get(i);
                 assertTrue(obj.isBoolCol());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index c903d110c7..908219ccdb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -275,7 +275,7 @@ private void doTestSortOnColumnWithPartialNullValues(String fieldName,
 
         RealmResults<NullTypes> sortedList = copy.sort(fieldName, Sort.ASCENDING);
         assertEquals("Should have same size", original.size(), sortedList.size());
-        // Null should always be the first one in the ascending sorted list
+        // Null should always be the first one in the ascending sorted list.
         assertEquals(2, sortedList.first().getId());
         assertEquals(1, sortedList.last().getId());
 
@@ -283,11 +283,11 @@ private void doTestSortOnColumnWithPartialNullValues(String fieldName,
         sortedList = sortedList.sort(fieldName, Sort.DESCENDING);
         assertEquals("Should have same size", original.size(), sortedList.size());
         assertEquals(1, sortedList.first().getId());
-        // Null should always be the last one in the descending sorted list
+        // Null should always be the last one in the descending sorted list.
         assertEquals(2, sortedList.last().getId());
     }
 
-    // Test sort on nullable fields with null values partially
+    // Tests sort on nullable fields with null values partially.
     @Test
     public void sort_rowsWithPartialNullValues() {
         populatePartialNullRowsForNumericTesting(realm);
@@ -410,7 +410,7 @@ public void sort_greekCharacters() {
         assertEquals("αύριο", collection.get(2).getFieldString());
     }
 
-    //No sorting order defined. There are Korean, Arabic and Chinese characters.
+    // No sorting order defined. There are Korean, Arabic and Chinese characters.
     @Test
     public void sort_manyDifferentCharacters() {
         OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
@@ -630,8 +630,8 @@ public void deleteLastFromRealm_emptyCollection() {
         assertEquals(0, collection.size());
     }
 
-    // Test all methods that mutate data throw correctly if not inside an transaction.
-    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level
+    // Tests all methods that mutate data throw correctly if not inside an transaction.
+    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level.
     @Test
     public void mutableMethodsOutsideTransactions() {
 
@@ -648,7 +648,7 @@ public void mutableMethodsOutsideTransactions() {
                         expected = UnsupportedOperationException.class;
                         break;
                     default:
-                        // Use default exception
+                        // Uses default exception.
                 }
             }
 
@@ -715,7 +715,7 @@ private boolean runMethodOnWrongThread(final ListMethod method) throws Execution
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
             @Override
             public Boolean call() throws Exception {
-                // Define expected exception
+                // Defines expected exception.
                 Class<? extends Throwable> expected = IllegalStateException.class;
                 if (collectionClass == ManagedCollection.REALMRESULTS) {
                     switch (method) {
@@ -726,7 +726,7 @@ public Boolean call() throws Exception {
                             expected = UnsupportedOperationException.class;
                             break;
                         default:
-                            // Use default exception
+                            // Uses default exception.
                     }
                 }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 0c40da4b90..fa8e7a8d05 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -241,7 +241,7 @@ public void where_shouldNotContainRemovedItem() {
     }
 
     /**
-     * Test to see if a particular item that does exist in the same Realm does not
+     * Tests to see if a particular item that does exist in the same Realm does not
      * exist in the result set of another query.
      */
     @Test
@@ -267,15 +267,15 @@ public void where_findAll_size() {
         RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).findAll();
         assertEquals(TEST_SIZE, results.size());
 
-        // querying a RealmResults should find objects that fulfill the condition
+        // Querying a RealmResults should find objects that fulfill the condition.
         RealmResults<AllJavaTypes> onedigits = results.where().lessThan(AllJavaTypes.FIELD_LONG, 10).findAll();
         assertEquals(Math.min(10, TEST_SIZE), onedigits.size());
 
-        // if no objects fulfill conditions, the result has zero objects
+        // If no objects fulfill conditions, the result has zero objects.
         RealmResults<AllJavaTypes> none = results.where().greaterThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(0, none.size());
 
-        // querying a result with zero objects must give zero objects
+        // Querying a result with zero objects must give zero objects.
         RealmResults<AllJavaTypes> stillNone = none.where().greaterThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(0, stillNone.size());
     }
@@ -330,7 +330,7 @@ public void min() {
         assertEquals(0, minimum.intValue());
     }
 
-    // Test min on empty columns
+    // Tests min on empty columns.
     @Test
     public void min_emptyNonNullFields() {
         OrderedRealmCollection<NullTypes> results = createEmptyCollection(realm, collectionClass);
@@ -340,7 +340,7 @@ public void min_emptyNonNullFields() {
         assertNull(results.minDate(NullTypes.FIELD_DATE_NOT_NULL));
     }
 
-    // Test min on nullable rows with all null values
+    // Tests min on nullable rows with all null values.
     @Test
     public void min_emptyNullFields() {
         OrderedRealmCollection<NullTypes> results = createAllNullRowsForNumericTesting(realm, collectionClass);
@@ -350,7 +350,7 @@ public void min_emptyNullFields() {
         assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
     }
 
-    // Test min on nullable rows with partial null values
+    // Tests min on nullable rows with partial null values.
     @Test
     public void min_partialNullRows() {
         OrderedRealmCollection<NullTypes> results = createPartialNullRowsForNumericTesting(realm, collectionClass);
@@ -365,7 +365,7 @@ public void max() {
         assertEquals(TEST_SIZE - 1, maximum.intValue());
     }
 
-    // Test max on empty columns
+    // Tests max on empty columns.
     @Test
     public void max_emptyNonNullFields() {
         OrderedRealmCollection<NullTypes> results = createEmptyCollection(realm, collectionClass);
@@ -375,7 +375,7 @@ public void max_emptyNonNullFields() {
         assertNull(results.maxDate(NullTypes.FIELD_DATE_NOT_NULL));
     }
 
-    // Test max on nullable rows with all null values
+    // Tests max on nullable rows with all null values.
     @Test
     public void max_emptyNullFields() {
         OrderedRealmCollection<NullTypes> results = createAllNullRowsForNumericTesting(realm, collectionClass);
@@ -385,7 +385,7 @@ public void max_emptyNullFields() {
         assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
     }
 
-    // Test max on nullable rows with partial null values
+    // Tests max on nullable rows with partial null values.
     @Test
     public void max_partialNullRows() {
         OrderedRealmCollection<NullTypes> results = createPartialNullRowsForNumericTesting(realm, collectionClass);
@@ -401,7 +401,7 @@ public void sum() {
         assertEquals((TEST_SIZE - 1) * TEST_SIZE / 2, sum.intValue());
     }
 
-    // Test sum on nullable rows with all null values
+    // Tests sum on nullable rows with all null values.
     @Test
     public void sum_nullRows() {
         OrderedRealmCollection<NullTypes> resultList = createAllNullRowsForNumericTesting(realm, collectionClass);
@@ -410,7 +410,7 @@ public void sum_nullRows() {
         assertEquals(0d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
     }
 
-    // Test sum on nullable rows with partial null values
+    // Tests sum on nullable rows with partial null values.
     @Test
     public void sum_partialNullRows() {
         OrderedRealmCollection<NullTypes> resultList = createPartialNullRowsForNumericTesting(realm, collectionClass);
@@ -438,7 +438,7 @@ public void avg() {
         double N = (double) TEST_SIZE;
 
         // Sum of numbers 1 to M: M*(M+1)/2
-        // See setUp() for values of fields
+        // See setUp() for values of fields.
         // N = TEST_DATA_SIZE
 
         // Type: double; a = 3.1415
@@ -461,7 +461,7 @@ public void avg() {
         assertEquals(1.234567 + 0.5 * (N - 1.0), collection.average(AllJavaTypes.FIELD_FLOAT), 0.0001);
     }
 
-    // Test average on empty columns
+    // Tests average on empty columns.
     @Test
     public void avg_emptyNonNullFields() {
         OrderedRealmCollection<NullTypes> resultList = createEmptyCollection(realm, collectionClass);
@@ -470,7 +470,7 @@ public void avg_emptyNonNullFields() {
         assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NOT_NULL), 0d);
     }
 
-    // Test average on nullable rows with all null values
+    // Tests average on nullable rows with all null values.
     @Test
     public void avg_emptyNullFields() {
         OrderedRealmCollection<NullTypes> resultList = createEmptyCollection(realm, collectionClass);
@@ -479,7 +479,7 @@ public void avg_emptyNullFields() {
         assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
     }
 
-    // Test average on nullable rows with partial null values
+    // Tests average on nullable rows with partial null values.
     @Test
     public void avg_partialNullRows() {
         OrderedRealmCollection<NullTypes> resultList = createPartialNullRowsForNumericTesting(realm, collectionClass);
@@ -576,7 +576,7 @@ public void deleteAllFromRealm() {
         if (collectionClass == ManagedCollection.MANAGED_REALMLIST) {
             RealmList list = (RealmList) collection;
             realm.beginTransaction();
-            list.remove(0); // Break the cycle
+            list.remove(0); // Breaks the cycle.
             realm.commitTransaction();
             size = TEST_SIZE - 1;
         }
@@ -658,13 +658,13 @@ public void equals_sameRealmObjectsDifferentCollection() {
         assertTrue(collection.equals(createCollection(collectionClass)));
     }
 
-    // Test all methods that mutate data throw correctly if not inside an transaction.
-    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level
+    // Tests all methods that mutate data throw correctly if not inside an transaction.
+    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level.
     @Test
     public void mutableMethodsOutsideTransactions() {
         for (CollectionMutatorMethod method : CollectionMutatorMethod.values()) {
 
-            // Define expected exception
+            // Defines expected exception.
             Class<? extends Throwable> expected = IllegalStateException.class;
             if (collectionClass == ManagedCollection.REALMRESULTS) {
                 switch (method) {
@@ -744,7 +744,7 @@ private boolean runMethodOnWrongThread(final CollectionMethod method) throws Exe
             @Override
             public Boolean call() throws Exception {
 
-                // Define expected exception
+                // Defines expected exception.
                 Class<? extends Throwable> expected = IllegalStateException.class;
                 if (collectionClass == ManagedCollection.REALMRESULTS) {
                     switch (method) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 0a8979656f..9ec3db4f47 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -48,8 +48,8 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
 import io.realm.log.LogLevel;
-import io.realm.log.RealmLogger;
 import io.realm.log.RealmLog;
+import io.realm.log.RealmLogger;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -57,7 +57,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -217,13 +216,13 @@ public Boolean call() throws Exception {
             }
         });
 
-        // Wait until the looper in the background thread is started
+        // Waits until the looper in the background thread is started.
         while (!isReady.get()) {
             Thread.sleep(5);
         }
         Thread.sleep(100);
 
-        // Trigger OnRealmChanged on background thread
+        // Triggers OnRealmChanged on background thread.
         realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
         Dog dog = realm.createObject(Dog.class);
@@ -238,7 +237,7 @@ public Boolean call() throws Exception {
             looper[0].quit();
         }
 
-        // Wait until the Looper thread is actually closed
+        // Waits until the Looper thread is actually closed.
         while (isRealmOpen.get()) {
             Thread.sleep(5);
         }
@@ -257,18 +256,18 @@ public void closeClearingHandlerMessages() throws InterruptedException, TimeoutE
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
             @Override
             public Boolean call() throws Exception {
-                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService
+                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService.
                 Realm realm = Realm.getInstance(realmConfig);
                 backgroundLooperStarted.countDown();
 
-                // Random operation in the client code
+                // Random operation in the client code.
                 final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
                 if (dogs.size() != 0) {
                     return false;
                 }
-                addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages
+                addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages.
 
-                // Create a Handler for the thread now. All message and references for the notification handler will be
+                // Creates a Handler for the thread now. All message and references for the notification handler will be
                 // cleared once we call close().
                 Handler threadHandler = new Handler(Looper.myLooper());
                 realm.close(); // Close native resources + associated handlers.
@@ -295,10 +294,10 @@ public void run() {
             }
         });
 
-        // Wait until the looper is started on a background thread
+        // Waits until the looper is started on a background thread.
         backgroundLooperStarted.await(1, TimeUnit.SECONDS);
 
-        // Execute a transaction that will trigger a Realm update
+        // Executes a transaction that will trigger a Realm update.
         Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -310,7 +309,7 @@ public void run() {
         realm.close();
         addHandlerMessages.countDown();
 
-        // Check that messages was properly cleared
+        // Checks that messages was properly cleared.
         // It looks like getting this future sometimes takes a while for some reason. Setting to
         // 10s. now.
         Boolean result = future.get(10, TimeUnit.SECONDS);
@@ -359,18 +358,18 @@ public void addRemoveListenerConcurrency() {
         final AtomicInteger counter3 = new AtomicInteger(0);
 
         // At least we need 2 listeners existing in the list to make sure
-        // the iterator.next get called
+        // the iterator.next get called.
 
-        // This one will be added when listener2's onChange called
+        // This one will be added when listener2's onChange called.
         final RealmChangeListener<Realm> listener1 = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                // Step 7: Last listener called. Should only be called once
+                // Step 7: Last listener called. Should only be called once.
                 counter1.incrementAndGet();
 
                 // after listener2.onChange
                 // Since duplicated entries will be ignored, we still have:
-                // [listener2, listener1]
+                // [listener2, listener1].
                 assertEquals(1, counter1.get());
                 assertEquals(2, counter2.get());
                 assertEquals(1, counter3.get());
@@ -378,13 +377,13 @@ public void onChange(Realm object) {
             }
         };
 
-        // This one will be existing in the list all the time
+        // This one will be existing in the list all the time.
         final RealmChangeListener<Realm> listener2 = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
                 // Step 3: Listener2 called
-                // Listener state [listener2, listener3, listener1]
-                // Listener 1 will not be called this time around
+                // Listener state [listener2, listener3, listener1].
+                // Listener 1 will not be called this time around.
                 counter2.incrementAndGet();
                 realm.addChangeListener(listener1);
             }
@@ -395,29 +394,29 @@ public void onChange(Realm object) {
             @Override
             public void onChange(Realm object) {
                 // Step 4: Listener3 called
-                // Listener state [listener2, listener1]
+                // Listener state [listener2, listener1].
                 counter3.incrementAndGet();
                 realm.removeChangeListener(this);
 
-                // Step 5: Assert proper state
-                // [listener2, listener1]
+                // Step 5: Asserts proper state
+                // [listener2, listener1].
                 assertEquals(0, counter1.get());
                 assertEquals(1, counter2.get());
                 assertEquals(1, counter3.get());
 
-                // Step 6: Trigger next round of changes on [listener2, listener1]
+                // Step 6: Triggers next round of changes on [listener2, listener1].
                 realm.beginTransaction();
                 realm.createObject(AllTypes.class);
                 realm.commitTransaction();
             }
         };
 
-        // Step 1: Add initial listeners
-        // Listener state [listener2, listener3]
+        // Step 1: Adds initial listeners
+        // Listener state [listener2, listener3].
         realm.addChangeListener(listener2);
         realm.addChangeListener(listener3);
 
-        // Step 2: Trigger change listeners
+        // Step 2: Triggers change listeners.
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
@@ -431,7 +430,7 @@ public void weakReferenceListener() throws InterruptedException {
 
         final Realm realm = looperThread.realm;
 
-        // Setup weak listener
+        // Setups weak listener.
         RealmChangeListener<Realm> weakListener = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -464,14 +463,14 @@ public void onChange(Realm object) {
             weakRef.clear();
         }
 
-        // Trigger change listeners
+        // Triggers change listeners.
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
     }
 
 
-    // Test that that a WeakReferenceListener can be removed.
+    // Tests that that a WeakReferenceListener can be removed.
     // This test is not a proper GC test, but just ensures that listeners can be removed from the list of weak listeners
     // without throwing an exception.
     @Test
@@ -533,7 +532,7 @@ public void onChange(Realm object) {
             public void onChange(Realm object) {
                 listenerBCalled.incrementAndGet();
                 if (listenerACalled.get() == 1) {
-                    // 2. Reverse order
+                    // 2. Reverse order.
                     realm.removeAllChangeListeners();
                     realm.addChangeListener(this);
                     realm.addChangeListener(listenerA);
@@ -544,7 +543,7 @@ public void onChange(Realm object) {
             }
         };
 
-        // 1. Add initial ordering
+        // 1. Adds initial ordering.
         realm.addChangeListener(listenerA);
         realm.addChangeListener(listenerB);
 
@@ -560,7 +559,7 @@ public void doNotUseClosedHandler() throws InterruptedException {
         final CountDownLatch backgroundThread1Started = new CountDownLatch(1);
         final CountDownLatch backgroundThread2Closed = new CountDownLatch(1);
 
-        // Create Handler on Thread1 by opening a Realm instance
+        // Creates Handler on Thread1 by opening a Realm instance.
         new Thread("thread1") {
 
             @Override
@@ -580,7 +579,7 @@ public void onChange(Realm object) {
             }
         }.start();
 
-        // Create Handler on Thread2 for the same Realm path and close the Realm instance again.
+        // Creates Handler on Thread2 for the same Realm path and closes the Realm instance again.
         new Thread("thread2") {
             @Override
             public void run() {
@@ -605,7 +604,7 @@ public void onChange(Realm object) {
         Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
         realm.commitTransaction();
-        // Any REALM_CHANGED message should now only reach the open Handler on Thread1
+        // Any REALM_CHANGED message should now only reach the open Handler on Thread1.
         try {
             // TODO: Waiting 5 seconds is not a reliable condition. Figure out a better way for this.
             if (!handlerNotified.await(5, TimeUnit.SECONDS)) {
@@ -616,7 +615,7 @@ public void onChange(Realm object) {
         }
     }
 
-    // Test that we handle a Looper thread quiting it's looper before it is done executing the current loop ( = Realm.close()
+    // Tests that we handle a Looper thread quiting it's looper before it is done executing the current loop ( = Realm.close()
     // isn't called yet).
     @Test
     public void looperThreadQuitsLooperEarly() throws InterruptedException {
@@ -624,12 +623,12 @@ public void looperThreadQuitsLooperEarly() throws InterruptedException {
         final CountDownLatch mainThreadCommitCompleted = new CountDownLatch(1);
         final CountDownLatch backgroundThreadStopped = new CountDownLatch(1);
 
-        // Start background looper and let it hang
+        // Starts background looper and let it hang.
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         executorService.submit(new Runnable() {
             @Override
             public void run() {
-                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService
+                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService.
 
                 Realm realm = Realm.getInstance(realmConfig);
                 realm.setAutoRefresh(false);
@@ -645,7 +644,7 @@ public void run() {
             }
         });
 
-        // Create a commit on another thread
+        // Creates a commit on another thread.
         TestHelper.awaitOrFail(backgroundLooperStartedAndStopped);
         Realm realm = Realm.getInstance(realmConfig);
         RealmLogger logger = TestHelper.getFailureLogger(Log.WARN);
@@ -689,7 +688,7 @@ public void onChange(Realm object) {
             }
         });
         TestHelper.awaitOrFail(backgroundThreadReady);
-        // At this point the background thread started & registered the listener
+        // At this point the background thread started & registered the listener.
 
         Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
@@ -748,7 +747,7 @@ public void onChange(Realm object) {
 
     // The presence of async RealmResults block any `REALM_CHANGE` notification causing historically the Realm
     // to advance to the latest version. We make sure in this test that all Realm listeners will be notified
-    // regardless of the presence of an async RealmResults that will delay the `REALM_CHANGE` sometimes
+    // regardless of the presence of an async RealmResults that will delay the `REALM_CHANGE` sometimes.
     @Test
     @RunTestInLooperThread
     public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification() {
@@ -764,7 +763,7 @@ public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification() {
             @Override
             public void onChange(RealmResults<Dog> results) {
                 if (dogs.size() == 2) {
-                    // Results has the latest changes
+                    // Results has the latest changes.
                     resultsListenerDone.set(true);
                     if (realmListenerDone.get()) {
                         looperThread.testComplete();
@@ -777,7 +776,7 @@ public void onChange(RealmResults<Dog> results) {
             @Override
             public void onChange(Realm element) {
                 if (dogs.size() == 1) {
-                    // Step 2. Create the second dog
+                    // Step 2. Creates the second dog.
                     realm.executeTransactionAsync(new Realm.Transaction() {
                         @Override
                         public void execute(Realm realm) {
@@ -785,7 +784,7 @@ public void execute(Realm realm) {
                         }
                     });
                 } else if (dogs.size() == 2) {
-                    // Realm listener can see the latest changes
+                    // Realm listener can see the latest changes.
                     realmListenerDone.set(true);
                     if (resultsListenerDone.get()) {
                         looperThread.testComplete();
@@ -794,7 +793,7 @@ public void execute(Realm realm) {
             }
         });
 
-        // Step 1. Create the first dog
+        // Step 1. Creates the first dog.
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -818,7 +817,7 @@ public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification() {
             public void onChange(final Realm realm) {
                 switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
                     case 1: {
-                        // first commit
+                        // First commit.
                         Dog dog = realm.where(Dog.class).findFirstAsync();
                         assertTrue(dog.load());
                         dog.addChangeListener(new RealmChangeListener<Dog>() {
@@ -841,7 +840,7 @@ public void run() {
                         break;
                     }
                     case 2: {
-                        // finish test
+                        // Finishes test.
                         TestHelper.awaitOrFail(signalClosedRealm);
                         looperThread.testComplete();
                         break;
@@ -948,7 +947,7 @@ public void execute(Realm realm) {
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm element) {
-                // Change event triggered by deletion in async transaction.
+                // Changes event triggered by deletion in async transaction.
                 assertEquals(0, realm.where(AllTypes.class).count());
                 assertEquals(0, results.size());
                 looperThread.testComplete();
@@ -977,7 +976,7 @@ public void callingOrdersOfListeners() {
                 new RealmChangeListener<RealmResults<AllTypes>>() {
                     @Override
                     public void onChange(RealmResults<AllTypes> element) {
-                        // First called
+                        // First called.
                         assertEquals(0, count.getAndIncrement());
                     }
                 };
@@ -985,14 +984,14 @@ public void onChange(RealmResults<AllTypes> element) {
         final RealmChangeListener<AllTypes> syncedObjectListener = new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes element) {
-                // Second called
+                // Second called.
                 assertEquals(1, count.getAndIncrement());
             }
         };
         final RealmChangeListener<Realm> globalListener = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm element) {
-                // third called
+                // Third called.
                 assertEquals(2, count.getAndIncrement());
                 looperThread.testComplete();
             }
@@ -1003,23 +1002,23 @@ public void onChange(Realm element) {
         final AllTypes allTypes = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        // We need to create one objects first and let the pass the first change event
+        // We need to create one objects first and let the pass the first change event.
         final RealmChangeListener<Realm> initListener = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm element) {
                 looperThread.postRunnable(new Runnable() {
                     @Override
                     public void run() {
-                        // Clear the change listeners
+                        // Clears the change listeners.
                         realm.removeAllChangeListeners();
 
-                        // Now we can start testing
+                        // Now we can start testing.
                         allTypes.addChangeListener(syncedObjectListener);
                         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
                         results.addChangeListener(syncedResultsListener);
                         realm.addChangeListener(globalListener);
 
-                        // Now we trigger those listeners
+                        // Now we trigger those listeners.
                         realm.executeTransactionAsync(new Realm.Transaction() {
                             @Override
                             public void execute(Realm realm) {
@@ -1035,11 +1034,11 @@ public void execute(Realm realm) {
         realm.addChangeListener(initListener);
     }
 
-    // See https://github.com/realm/realm-android-adapters/issues/48
-    // Step 1: Populate the db
-    // Step 2: Post a runnable to caller thread.
+    // See https://github.com/realm/realm-android-adapters/issues/48.
+    // Step 1: Populates the db.
+    // Step 2: Posts a runnable to caller thread.
     //         Event Queue: |Posted Runnable| <- TOP
-    // Step 3: Delete object which will make the results contain an invalid object at this moment
+    // Step 3: Deletes object which will make the results contain an invalid object at this moment.
     //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
     //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
     // Step 4: Posted runnable called.
@@ -1075,12 +1074,12 @@ public void execute(Realm realm) {
         });
     }
 
-    // See https://github.com/realm/realm-android-adapters/issues/48
-    // Step 1: Populate the db
-    // Step 2: Create a async query, and wait until it finishes
-    // Step 3: Post a runnable to caller thread.
+    // See https://github.com/realm/realm-android-adapters/issues/48.
+    // Step 1: Populates the db.
+    // Step 2: Creates a async query, and waits until it finishes.
+    // Step 3: Posts a runnable to caller thread.
     //         Event Queue: |Posted Runnable| <- TOP
-    // Step 4: Delete object which will make the results contain a invalid object at this moment
+    // Step 4: Deletes object which will make the results contain a invalid object at this moment.
     //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
     //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
     // Step 5: Posted runnable called.
@@ -1128,12 +1127,12 @@ public void execute(Realm realm) {
         });
     }
 
-    // See https://github.com/realm/realm-android-adapters/issues/48
-    // Step 1: Populate the db
-    // Step 2: Create a async query, and pause it
-    // Step 3: Post a runnable to caller thread.
+    // See https://github.com/realm/realm-android-adapters/issues/48.
+    // Step 1: Populates the db.
+    // Step 2: Creates a async query, and pauses it.
+    // Step 3: Posts a runnable to caller thread.
     //         Event Queue: |Posted Runnable| <- TOP
-    // Step 4: Delete object which will make the results contain a invalid object at this moment
+    // Step 4: Deletes object which will make the results contain a invalid object at this moment.
     //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
     //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
     // Step 5: Posted runnable called.
@@ -1221,7 +1220,7 @@ public void accessingSyncRealmResultInsideAsyncResultListener() {
             public void onChange(RealmResults<AllTypes> results) {
                 switch (asyncResultCallback.incrementAndGet()) {
                     case 1:
-                        // Called when first async query completes
+                        // Called when first async query completes.
                         assertEquals(0, results.size());
                         realm.executeTransactionAsync(new Realm.Transaction() {
                             @Override
@@ -1233,7 +1232,7 @@ public void execute(Realm realm) {
 
                     case 2:
                         // Called after async transaction completes, A REALM_CHANGED event has been triggered,
-                        // async queries have rerun, and listeners are triggered again
+                        // async queries have rerun, and listeners are triggered again.
                         assertEquals(1, results.size());
                         assertEquals(1, syncResults.size()); // If syncResults is not in sync yet, this will fail.
                         looperThread.testComplete();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 0643ba9316..3484cb2c1f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -258,7 +258,7 @@ public void iterator_remove() {
         try {
             it.remove();
         } catch (UnsupportedOperationException e) {
-            // RealmResults doesn't support remove
+            // RealmResults doesn't support remove.
             assertEquals(CollectionClass.REALMRESULTS, collectionClass);
             return;
         }
@@ -301,7 +301,7 @@ public void iterator_deleteManagedObjectIndirectly() {
     @Test
     public void iterator_removeCalledTwice() {
         if (skipTest(CollectionClass.REALMRESULTS)) {
-            return; // remove() not supported by RealmResults
+            return; // remove() not supported by RealmResults.
         }
 
         Iterator<AllJavaTypes> it = collection.iterator();
@@ -341,13 +341,13 @@ public void listIterator_oneElement() {
         collection = createCollection(realm, collectionClass, 1);
         ListIterator<AllJavaTypes> it = collection.listIterator();
 
-        // Test beginning of the list
+        // Tests beginning of the list.
         assertFalse(it.hasPrevious());
         assertTrue(it.hasNext());
         assertEquals(-1, it.previousIndex());
         assertEquals(0, it.nextIndex());
 
-        // Test end of the list
+        // Tests end of the list.
         AllJavaTypes firstObject = it.next();
         assertEquals(0, firstObject.getFieldLong());
         assertTrue(it.hasPrevious());
@@ -360,19 +360,19 @@ public void listIterator_oneElement() {
     public void listIterator_manyElements() {
         ListIterator<AllJavaTypes> it = collection.listIterator();
 
-        // Test beginning of the list
+        // Tests beginning of the list.
         assertFalse(it.hasPrevious());
         assertTrue(it.hasNext());
         assertEquals(-1, it.previousIndex());
         assertEquals(0, it.nextIndex());
 
-        // Test 1st element in the list
+        // Tests 1st element in the list.
         AllJavaTypes firstObject = it.next();
         assertEquals(0, firstObject.getFieldLong());
         assertTrue(it.hasPrevious());
         assertEquals(0, it.previousIndex());
 
-        // Move to second last element
+        // Moves to second last element.
         for (int i = 1; i < TEST_SIZE - 1; i++) {
             it.next();
         }
@@ -380,7 +380,7 @@ public void listIterator_manyElements() {
         assertTrue(it.hasNext());
         assertEquals(TEST_SIZE - 1, it.nextIndex());
 
-        // Test end of the list
+        // Tests end of the list.
         AllJavaTypes lastObject = it.next();
         assertEquals(TEST_SIZE - 1, lastObject.getFieldLong());
         assertTrue(it.hasPrevious());
@@ -439,7 +439,7 @@ public void listIterator_remove_calledTwice() {
                 break;
             case REALMRESULTS:
                 try {
-                    it.remove(); // Method not supported
+                    it.remove(); // Method not supported.
                     fail();
                 } catch (UnsupportedOperationException ignored) {
                 }
@@ -458,7 +458,7 @@ public void listIterator_transactionBeforeNextItem() {
             assertEquals("Failed at index: " + i, i, item.getFieldLong());
             i++;
 
-            // Committing transactions while iterating should not effect the current iterator if on a looper thread
+            // Committing transactions while iterating should not effect the current iterator if on a looper thread.
             createNewObject();
         }
     }
@@ -531,7 +531,7 @@ public void listIterator_deleteManagedObjectIndirectly() {
         }
         it = collection.listIterator();
         it.next();
-        AllJavaTypes types = it.next(); // Iterator can still access the deleted object
+        AllJavaTypes types = it.next(); // Iterator can still access the deleted object.
 
         //noinspection SimplifiableConditionalExpression
         assertTrue(collectionClass == CollectionClass.MANAGED_REALMLIST ? types.isValid() : !types.isValid());
@@ -563,7 +563,7 @@ public void listIterator_set() {
         realm.beginTransaction();
         ListIterator<AllJavaTypes> it = collection.listIterator();
 
-        // Calling set() before next() should throw
+        // Calling set() before next() should throw.
         try {
             it.set(new AllJavaTypes());
             fail();
@@ -588,7 +588,7 @@ public void listIterator_add() {
         realm.beginTransaction();
         ListIterator<AllJavaTypes> it = collection.listIterator();
 
-        // Calling set() before next() should throw
+        // Calling set() before next() should throw.
         try {
             it.add(new AllJavaTypes());
             fail();
@@ -639,7 +639,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification() {
             return;
         }
 
-        // Test all standard collection methods
+        // Tests all standard collection methods.
         for (CollectionMethod method : CollectionMethod.values()) {
             collection = createCollection(realm, collectionClass, TEST_SIZE);
             realm.beginTransaction();
@@ -652,7 +652,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification() {
                 case REMOVE_ALL: collection.removeAll(Collections.singletonList(collection.get(0))); break;
                 case RETAIN_ALL: collection.retainAll(Collections.singletonList(collection.get(0))); break;
 
-                // Does not impact size, so does not trigger ConcurrentModificationException
+                // Does not impact size, so does not trigger ConcurrentModificationException.
                 case CONTAINS:
                 case CONTAINS_ALL:
                 case EQUALS:
@@ -679,7 +679,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification() {
                 case ADD_ALL_INDEX: collection.addAll(0, Collections.singleton(new AllJavaTypes(TEST_SIZE))); break;
                 case REMOVE_INDEX: collection.remove(0); break;
 
-                // Does not impact size, so does not trigger ConcurrentModificationException
+                // Does not impact size, so does not trigger ConcurrentModificationException.
                 case FIRST:
                 case LAST:
                 case GET_INDEX:
@@ -705,17 +705,17 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedColl
             return;
         }
 
-        // Test all RealmCollection methods
+        // Tests all RealmCollection methods.
         for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
             collection = createCollection(realm, collectionClass, TEST_SIZE);
             realm.beginTransaction();
-            collection.remove(0); // Remove object creating circular dependency which will crash deleteAll.
+            collection.remove(0); // Removes object creating circular dependency which will crash deleteAll.
             Iterator<AllJavaTypes> it = collection.iterator();
             switch (method) {
                 case DELETE_ALL_FROM_REALM:
                     collection.deleteAllFromRealm(); break;
 
-                // Does not impact size, so does not trigger ConcurrentModificationException
+                // Does not impact size, so does not trigger ConcurrentModificationException.
                 case WHERE:
                 case MIN:
                 case MAX:
@@ -733,7 +733,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedColl
             checkIteratorThrowsConcurrentModification(realm, method.toString(), it);
         }
 
-        // Test all OrderedRealmCollection methods
+        // Tests all OrderedRealmCollection methods.
         for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
             collection = createCollection(realm, collectionClass, TEST_SIZE);
             realm.beginTransaction();
@@ -743,7 +743,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedColl
                 case DELETE_FIRST: collection.deleteFirstFromRealm(); break;
                 case DELETE_LAST: collection.deleteLastFromRealm(); break;
 
-                // Does not impact size, so does not trigger ConcurrentModificationException
+                // Does not impact size, so does not trigger ConcurrentModificationException.
                 case SORT:
                 case SORT_FIELD:
                 case SORT_2FIELDS:
@@ -777,7 +777,7 @@ public void iterator_realmResultsThrowConcurrentModification() {
             return;
         }
 
-        // Verify that ConcurrentModification is correctly detected on non-looper threads
+        // Verifies that ConcurrentModification is correctly detected on non-looper threads.
         Iterator<AllJavaTypes> it = collection.iterator();
         final CountDownLatch bgDone = new CountDownLatch(1);
         new Thread(new Runnable() {
@@ -815,7 +815,7 @@ public void useCase_simpleIterator_modifyQueryResult_innerTransaction() {
             realm.commitTransaction();
         }
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -834,7 +834,7 @@ public void useCase_simpleIterator_modifyQueryResult_outerTransaction() {
         }
         realm.commitTransaction();
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -852,7 +852,7 @@ public void useCase_forEachIterator_modifyQueryResult_innerTransaction() {
             realm.commitTransaction();
         }
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -870,7 +870,7 @@ public void useCase_forEachIterator_modifyQueryResult_outerTransaction() {
         }
         realm.commitTransaction();
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -890,7 +890,7 @@ public void useCase_simpleIterator_modifyQueryResult_innerTransaction_looperThre
             realm.commitTransaction();
         }
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -910,7 +910,7 @@ public void useCase_simpleIterator_modifyQueryResult_outerTransaction_looperThre
         }
         realm.commitTransaction();
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -929,7 +929,7 @@ public void useCase_forEachIterator_modifyQueryResult_innerTransaction_looperThr
             realm.commitTransaction();
         }
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 
@@ -948,7 +948,7 @@ public void useCase_forEachIterator_modifyQueryResult_outerTransaction_looperThr
         }
         realm.commitTransaction();
 
-        // Verify that all elements were modified
+        // Verifies that all elements were modified.
         assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index 6677482d9c..5b5084f004 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -70,7 +70,7 @@ public void ignore() {
         assertEquals(-1, table.getColumnIndex("ignoreString"));
     }
 
-    // Test if "index" annotation works with supported types
+    // Tests if "index" annotation works with supported types.
     @Test
     public void index() {
         Table table = realm.getTable(AnnotationIndexTypes.class);
@@ -97,7 +97,7 @@ public void index() {
         assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexDate")));
     }
 
-    // Test migrating primary key from string to long with existing data
+    // Tests migrating primary key from string to long with existing data.
     @Test
     public void primaryKey_migration_long() {
         realm.beginTransaction();
@@ -112,13 +112,13 @@ public void primaryKey_migration_long() {
         realm.cancelTransaction();
     }
 
-    // Test migrating primary key from string to long with existing data
+    // Tests migrating primary key from string to long with existing data.
     @Test
     public void primaryKey_migration_longDuplicateValues() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
             PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
-            obj.setId(1); // Create duplicate values
+            obj.setId(1); // Creates duplicate values.
         }
 
         Table table = realm.getTable(PrimaryKeyAsString.class);
@@ -132,7 +132,7 @@ public void primaryKey_migration_longDuplicateValues() {
         }
     }
 
-    // Test migrating primary key from long to str with existing data
+    // Tests migrating primary key from long to str with existing data.
     @Test
     public void primaryKey_migration_string() {
         realm.beginTransaction();
@@ -147,13 +147,13 @@ public void primaryKey_migration_string() {
         realm.cancelTransaction();
     }
 
-    // Test migrating primary key from long to str with existing data
+    // Tests migrating primary key from long to str with existing data.
     @Test
     public void primaryKey_migration_stringDuplicateValues() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
             PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
-            obj.setName("String"); // Create duplicate values
+            obj.setName("String"); // Creates duplicate values.
         }
 
         Table table = realm.getTable(PrimaryKeyAsLong.class);
@@ -203,8 +203,8 @@ public void primaryKey_isIndexed() {
         assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
     }
 
-    // Annotation processor honors common naming conventions
-    // We check if setters and getters are generated and working
+    // Annotation processor honors common naming conventions.
+    // We check if setters and getters are generated and working.
     @Test
     public void namingConvention() {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 9375d6efd8..3e2b84a346 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -74,7 +74,7 @@
     // ****  Async transaction  ***
     // ****************************
 
-    // start asynchronously a transaction to insert one element
+    // Starts asynchronously a transaction to insert one element.
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync() throws Throwable {
@@ -168,7 +168,7 @@ public void onChange(Realm object) {
         });
     }
 
-    // Test that an async transaction that throws an exception propagate it properly to the user.
+    // Tests that an async transaction that throws an exception propagate it properly to the user.
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_exceptionHandling() throws Throwable {
@@ -184,7 +184,7 @@ public void executeTransactionAsync_exceptionHandling() throws Throwable {
             public void execute(Realm realm) {
                 Owner owner = realm.createObject(Owner.class);
                 owner.setName("Owner");
-                realm.cancelTransaction(); // Cancel the transaction then throw
+                realm.cancelTransaction(); // Cancels the transaction then throw.
                 throw new RuntimeException("Boom");
             }
         }, new Realm.Transaction.OnSuccess() {
@@ -195,7 +195,7 @@ public void onSuccess() {
         }, new Realm.Transaction.OnError() {
             @Override
             public void onError(Throwable error) {
-                // Ensure we are giving developers quality messages in the logs.
+                // Ensures we are giving developers quality messages in the logs.
                 assertEquals("Could not cancel transaction, not currently in a transaction.", testLogger.message);
                 RealmLog.remove(testLogger);
                 looperThread.testComplete();
@@ -203,7 +203,7 @@ public void onError(Throwable error) {
         });
     }
 
-    // Test if the background Realm is closed when transaction success returned.
+    // Tests if the background Realm is closed when transaction success returned.
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_realmClosedOnSuccess() {
@@ -224,7 +224,7 @@ public void onResult(int count) {
             public void onSuccess() {
                 RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);
                 if (counter.get() == 0) {
-                    // Finish testing
+                    // Finishes testing.
                     return;
                 }
                 realm.executeTransactionAsync(new Realm.Transaction() {
@@ -242,7 +242,7 @@ public void execute(Realm realm) {
         }, transactionCallback);
     }
 
-    // Test if the background Realm is closed when transaction error returned.
+    // Tests if the background Realm is closed when transaction error returned.
     @Test
     @RunTestInLooperThread
     public void executeTransaction_async_realmClosedOnError() {
@@ -263,7 +263,7 @@ public void onResult(int count) {
             public void onError(Throwable error) {
                 RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);
                 if (counter.get() == 0) {
-                    // Finish testing
+                    // Finishes testing.
                     return;
                 }
                 realm.executeTransactionAsync(new Realm.Transaction() {
@@ -284,7 +284,7 @@ public void execute(Realm realm) {
     }
 
     // Test case for https://github.com/realm/realm-java/issues/1893
-    // Ensure that onSuccess is called with the correct Realm version for async transaction.
+    // Ensures that onSuccess is called with the correct Realm version for async transaction.
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_asyncQuery() {
@@ -316,7 +316,7 @@ public void onError(Throwable error) {
     // *** promises based async queries ***
     // ************************************
 
-    // finding element [0-4] asynchronously then wait for the promise to be loaded.
+    // Finds element [0-4] asynchronously then waits for the promise to be loaded.
     @Test
     @RunTestInLooperThread
     public void findAllAsync() throws Throwable {
@@ -395,7 +395,7 @@ public void findAllAsync_reusingQuery() throws Throwable {
         assertTrue(allAsync.load());
         assertEquals(allAsync, queryAllSync);
 
-        // the RealmQuery already has an argumentHolder, can't reuse it
+        // The RealmQuery already has an argumentHolder, can't reuse it.
         try {
             query.findAllSorted("columnLong");
             fail("Should throw an exception, can not reuse RealmQuery");
@@ -404,8 +404,8 @@ public void findAllAsync_reusingQuery() throws Throwable {
         }
     }
 
-    // finding elements [0-4] asynchronously then wait for the promise to be loaded
-    // using a callback to be notified when the data is loaded
+    // Finds elements [0-4] asynchronously then waits for the promise to be loaded
+    // using a callback to be notified when the data is loaded.
     @Test
     @RunTestInLooperThread
     public void findAllAsync_withNotification() throws Throwable {
@@ -430,8 +430,8 @@ public void onChange(RealmResults<AllTypes> object) {
         assertEquals(0, results.size());
     }
 
-    // transforming an async query into sync by calling load to force
-    // the blocking behaviour
+    // Transforms an async query into sync by calling load to force
+    // the blocking behaviour.
     @Test
     @RunTestInLooperThread
     public void findAllAsync_forceLoad() throws Throwable {
@@ -442,7 +442,7 @@ public void findAllAsync_forceLoad() throws Throwable {
                 .findAllAsync();
 
         looperThread.keepStrongReference.add(realmResults);
-        // notification should be called as well
+        // Notification should be called as well.
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -464,14 +464,14 @@ public void onChange(RealmResults<AllTypes> object) {
     }
 
     // UC:
-    //   1- insert 10 objects
-    //   2- start an async query to find object [0-4]
-    //   3- assert current RealmResults is empty (Worker Thread didn't complete)
-    //   4- when the worker thread complete, advance the Realm
-    //   5- the caller thread is ahead of the result provided by the worker thread
-    //   6- retry automatically the async query
-    //   7- the returned RealmResults is now in the same version as the caller thread
-    //   8- the notification should be called once (when we retry automatically we shouldn't
+    //   1- Inserts 10 objects.
+    //   2- Starts an async query to find object [0-4].
+    //   3- Asserts current RealmResults is empty (Worker Thread didn't complete).
+    //   4- When the worker thread completes, advances the Realm.
+    //   5- The caller thread is ahead of the result provided by the worker thread.
+    //   6- Retries automatically the async query.
+    //   7- The returned RealmResults is now in the same version as the caller thread.
+    //   8- The notification should be called once (when we retry automatically we shouldn't
     //      notify the user).
     @Test
     @RunTestInLooperThread
@@ -480,23 +480,23 @@ public void findAllAsync_retry() throws Throwable {
         final AtomicInteger numberOfInvocation = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
 
-        // 1. Populate initial data
+        // 1. Populates initial data.
         realm.setAutoRefresh(false);
         populateTestRealm(realm, 10);
         realm.setAutoRefresh(true);
 
-        // 2. Configure handler interceptor
+        // 2. Configures handler interceptor.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
-                // Intercepts in order: [QueryComplete, RealmChanged, QueryUpdated]
+                // Intercepts in order: [QueryComplete, RealmChanged, QueryUpdated].
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    // 5. Intercept all messages from other threads. On the first complete, we advance the tread
+                    // 5. Intercepts all messages from other threads. On the first complete, we advance the tread
                     // which will cause the async query to rerun instead of triggering the change listener.
                     case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
                         if (intercepts == 1) {
-                            // We advance the Realm so we can simulate a retry
+                            // We advance the Realm so we can simulate a retry.
                             realm.beginTransaction();
                             realm.delete(AllTypes.class);
                             realm.commitTransaction();
@@ -507,16 +507,16 @@ public boolean onInterceptInMessage(int what) {
         };
         realm.setHandler(handler);
 
-        // 3. Create a async query
+        // 3. Creates a async query.
         final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
                 .findAllAsync();
 
-        // 4. Ensure that query isn't loaded yet
+        // 4. Ensures that query isn't loaded yet.
         assertFalse(realmResults.isLoaded());
         assertEquals(0, realmResults.size());
 
-        // 6. Callback triggered after retry has completed
+        // 6. Callback triggered after retry has completed.
         looperThread.keepStrongReference.add(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -531,13 +531,13 @@ public void onChange(RealmResults<AllTypes> object) {
     }
 
     // UC:
-    //   1- insert 10 objects
-    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
-    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
-    //   4- the queries will complete with the same version as the caller thread
-    //   5- using a background thread update the Realm
-    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
-    //   7- callbacks are notified with the latest results (called twice overall)
+    //   1- Inserts 10 objects.
+    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
+    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
+    //   4- The queries will complete with the same version as the caller thread.
+    //   5- Using a background thread update the Realm.
+    //   6- Now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries.
+    //   7- Callbacks are notified with the latest results (called twice overall).
     @Test
     @RunTestInLooperThread
     public void findAllAsync_batchUpdate() throws Throwable {
@@ -547,7 +547,7 @@ public void findAllAsync_batchUpdate() throws Throwable {
         final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
-        // 1. Configure Handler interceptor
+        // 1. Configures Handler interceptor.
         Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
@@ -575,7 +575,7 @@ public void doInBackground(Realm realm) {
         };
         realm.setHandler(handler);
 
-        // 2. Create 2 async queries and check they are not loaded
+        // 2. Creates 2 async queries and check they are not loaded.
         final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class).findAllAsync();
         final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class).between("columnLong", 0, 4).findAllAsync();
 
@@ -607,13 +607,13 @@ public void run() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
-                    case 1: // first callback invocation
+                    case 1: // First callback invocation
                         assertTrue(realmResults1.isLoaded());
                         assertEquals(10, realmResults1.size());
                         assertEquals("test data 4", realmResults1.get(4).getColumnString());
                         break;
 
-                    case 2: // second callback
+                    case 2: // Second callback
                         assertTrue(realmResults1.isLoaded());
                         assertEquals(12, realmResults1.size());
                         assertEquals("modified", realmResults1.get(4).getColumnString());
@@ -628,13 +628,13 @@ public void onChange(RealmResults<AllTypes> object) {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
-                    case 1: // first callback invocation
+                    case 1: // First callback invocation
                         assertTrue(realmResults2.isLoaded());
                         assertEquals(5, realmResults2.size());
                         assertEquals("test data 4", realmResults2.get(4).getColumnString());
                         break;
 
-                    case 2: // second callback
+                    case 2: // Second callback
                         assertTrue(realmResults2.isLoaded());
                         assertEquals(7, realmResults2.size());
                         assertEquals("modified", realmResults2.get(4).getColumnString());
@@ -645,9 +645,9 @@ public void onChange(RealmResults<AllTypes> object) {
         });
     }
 
-    // simulate a use case, when the caller thread advance read, while the background thread
+    // Simulates a use case, when the caller thread advance read, while the background thread
     // is operating on a previous version, this should retry the query on the worker thread
-    // to deliver the results once (using the latest version of the Realm)
+    // to deliver the results once (using the latest version of the Realm).
     @Test
     @RunTestInLooperThread
     public void findAllAsync_callerIsAdvanced() throws Throwable {
@@ -655,15 +655,15 @@ public void findAllAsync_callerIsAdvanced() throws Throwable {
         final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
-        // Configure handler interceptor
+        // Configures handler interceptor.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
-                // Intercepts in order [QueryCompleted, RealmChanged, QueryUpdated]
+                // Intercepts in order [QueryCompleted, RealmChanged, QueryUpdated].
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
                     case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
-                        // we advance the Realm so we can simulate a retry
+                        // We advance the Realm so we can simulate a retry.
                         if (intercepts == 1) {
                             realm.beginTransaction();
                             realm.createObject(AllTypes.class).setColumnLong(0);
@@ -676,7 +676,7 @@ public boolean onInterceptInMessage(int what) {
         };
         realm.setHandler(handler);
 
-        // Create async query and verify it has not been loaded.
+        // Creates async query and verify it has not been loaded.
         final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
                 .findAllAsync();
@@ -686,7 +686,7 @@ public boolean onInterceptInMessage(int what) {
 
         looperThread.keepStrongReference.add(realmResults);
 
-        // Add change listener that should only be called once
+        // Adds change listener that should only be called once.
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -699,14 +699,14 @@ public void onChange(RealmResults<AllTypes> object) {
     }
 
     // UC:
-    //   1- insert 10 objects
-    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
-    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
-    //   4- start a third thread to insert 2 more elements
-    //   5- the third thread signal a REALM_CHANGE that should update all async queries
-    //   6- when the results from step [2] completes they should be ignored, since a pending
-    //      update (using the latest realm) for all async queries is in progress
-    //   7- onChange notification will be triggered once
+    //   1- Inserts 10 objects.
+    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
+    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
+    //   4- Starts a third thread to insert 2 more elements.
+    //   5- The third thread signal a REALM_CHANGE that should update all async queries.
+    //   6- When the results from step [2] completes they should be ignored, since a pending
+    //      update (using the latest realm) for all async queries is in progress.
+    //   7- onChange notification will be triggered once.
     @Test
     @RunTestInLooperThread
     public void findAllAsync_callerThreadBehind() throws Throwable {
@@ -717,25 +717,25 @@ public void findAllAsync_callerThreadBehind() throws Throwable {
         final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
-        // Configure Handler Interceptor
+        // Configures Handler Interceptor.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
                     case HandlerControllerConstants.REALM_CHANGED: {
-                        // should only intercept the first REALM_CHANGED coming from the
-                        // background update thread
+                        // Should only intercept the first REALM_CHANGED coming from the
+                        // background update thread.
 
-                        // swallow this message, so the caller thread
-                        // remain behind the worker thread. This has as
-                        // a consequence to ignore the delivered result & wait for the
-                        // upcoming REALM_CHANGED to batch update all async queries
+                        // Swallows this message, so the caller thread
+                        // remains behind the worker thread. This has as
+                        // a consequence to ignore the delivered result & waits for the
+                        // upcoming REALM_CHANGED to batch update all async queries.
                         return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
                     }
                     case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
-                            // both queries have completed now (& their results should be ignored)
-                            // now send the REALM_CHANGED event that should batch update all queries
+                            // Both queries have completed now (& their results should be ignored)
+                            // now sends the REALM_CHANGED event that should batch update all queries.
                             sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
                         }
                     }
@@ -746,7 +746,7 @@ public boolean onInterceptInMessage(int what) {
         realm.setHandler(handler);
         Realm.asyncTaskExecutor.pause();
 
-        // Create async queries and check they haven't completed
+        // Creates async queries and checks they haven't completed.
         final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
                 .findAllAsync();
         final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
@@ -757,7 +757,7 @@ public boolean onInterceptInMessage(int what) {
         assertEquals(0, realmResults1.size());
         assertEquals(0, realmResults2.size());
 
-        // advance the Realm from a background thread
+        // Advances the Realm from a background thread.
         new RealmBackgroundTask(looperThread.realmConfiguration) {
             @Override
             public void doInBackground(Realm realm) {
@@ -770,7 +770,7 @@ public void doInBackground(Realm realm) {
         }.awaitOrFail();
         Realm.asyncTaskExecutor.resume();
 
-        // Setup change listeners
+        // Setups change listeners.
         final Runnable signalCallbackDone = new Runnable() {
             private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
             @Override
@@ -813,7 +813,7 @@ public void onChange(RealmResults<AllTypes> object) {
     // *** 'findFirst' async queries  ***
     // **********************************
 
-    // similar UC as #testFindAllAsync using 'findFirst'
+    // Similar UC as #testFindAllAsync using 'findFirst'.
     @Test
     @RunTestInLooperThread
     public void findFirstAsync() {
@@ -888,8 +888,8 @@ public void onChange(AllTypes object) {
         looperThread.realm.commitTransaction();
     }
 
-    // finding elements [0-4] asynchronously then wait for the promise to be loaded
-    // using a callback to be notified when the data is loaded
+    // Finds elements [0-4] asynchronously then waits for the promise to be loaded
+    // using a callback to be notified when the data is loaded.
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_withNotification() throws Throwable {
@@ -919,7 +919,7 @@ public void onChange(AllTypes object) {
         }
     }
 
-    // similar UC as #testForceLoadAsync using 'findFirst'
+    // Similar UC as #testForceLoadAsync using 'findFirst'.
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_forceLoad() throws Throwable {
@@ -938,16 +938,16 @@ public void findFirstAsync_forceLoad() throws Throwable {
         looperThread.testComplete();
     }
 
-    // similar UC as #testFindAllAsyncRetry using 'findFirst'
+    // Similar UC as #testFindAllAsyncRetry using 'findFirst'.
     // UC:
-    //   1- insert 10 objects
-    //   2- start an async query to find object [0-4]
-    //   3- assert current RealmResults is empty (Worker Thread didn't complete)
-    //   4- when the worker thread complete, advance the Realm
-    //   5- the caller thread is ahead of the result provided by the worker thread
-    //   6- retry automatically the async query
-    //   7- the returned RealmResults is now in the same version as the caller thread
-    //   8- the notification should be called once (when we retry automatically we shouldn't
+    //   1- Inserts 10 objects.
+    //   2- Starts an async query to find object [0-4].
+    //   3- Asserts current RealmResults is empty (Worker Thread didn't complete).
+    //   4- When the worker thread completes, advances the Realm.
+    //   5- The caller thread is ahead of the result provided by the worker thread.
+    //   6- Retries automatically the async query.
+    //   7- The returned RealmResults is now in the same version as the caller thread.
+    //   8- The notification should be called once (when we retry automatically we shouldn't
     //      notify the user).
     @Test
     @RunTestInLooperThread
@@ -956,7 +956,7 @@ public void findFirstAsync_retry() throws Throwable {
         final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
-        // Configure interceptor handler
+        // Configures interceptor handler.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
@@ -964,7 +964,7 @@ public boolean onInterceptInMessage(int what) {
                 switch (what) {
                     case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
                         if (intercepts == 1) {
-                            // we advance the Realm so we can simulate a retry
+                            // We advance the Realm so we can simulate a retry.
                             realm.beginTransaction();
                             realm.delete(AllTypes.class);
                             AllTypes object = realm.createObject(AllTypes.class);
@@ -979,7 +979,7 @@ public boolean onInterceptInMessage(int what) {
         };
         realm.setHandler(handler);
 
-        // Create a async query and verify it is not still loaded.
+        // Creates a async query and verifies it is not still loaded.
         final AllTypes realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 6)
                 .findFirstAsync();
@@ -992,7 +992,7 @@ public boolean onInterceptInMessage(int what) {
         } catch (IllegalStateException ignored) {
         }
 
-        // Add change listener that should only be called once after the retry completed.
+        // Adds change listener that should only be called once after the retry completed.
         looperThread.keepStrongReference.add(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
@@ -1010,7 +1010,7 @@ public void onChange(AllTypes object) {
     // *** 'findAllSorted' async queries  ***
     // **************************************
 
-    // similar UC as #testFindAllAsync using 'findAllSorted'
+    // Similar UC as #testFindAllAsync using 'findAllSorted'.
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync() throws Throwable {
@@ -1040,24 +1040,24 @@ public void onChange(RealmResults<AllTypes> object) {
     }
 
 
-    // finding elements [4-8] asynchronously then wait for the promise to be loaded
-    // using a callback to be notified when the data is loaded
+    // Finds elements [4-8] asynchronously then waits for the promise to be loaded
+    // using a callback to be notified when the data is loaded.
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync_retry() throws Throwable {
         final AtomicInteger numberOfIntercept = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
 
-        // 1. Populate the Realm without triggering a RealmChangeEvent.
+        // 1. Populates the Realm without triggering a RealmChangeEvent.
         realm.setAutoRefresh(false);
         populateTestRealm(realm, 10);
         realm.setAutoRefresh(true);
 
-        // 2. Configure proxy handler to intercept messages
+        // 2. Configures proxy handler to intercept messages.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
-                // In order [QueryCompleted, RealmChanged, QueryUpdated]
+                // In order [QueryCompleted, RealmChanged, QueryUpdated].
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
                     case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
@@ -1076,7 +1076,7 @@ public boolean onInterceptInMessage(int what) {
         };
         realm.setHandler(handler);
 
-        // 3. This will add a task to the paused asyncTaskExecutor
+        // 3. This will add a task to the paused asyncTaskExecutor.
         final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 8)
                 .findAllSortedAsync("columnString", Sort.ASCENDING);
@@ -1097,15 +1097,15 @@ public void onChange(RealmResults<AllTypes> object) {
         });
     }
 
-    // similar UC as #testFindAllAsyncBatchUpdate using 'findAllSorted'
+    // Similar UC as #testFindAllAsyncBatchUpdate using 'findAllSorted'.
     // UC:
-    //   1- insert 10 objects
-    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
-    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
-    //   4- the queries will complete with the same version as the caller thread
-    //   5- using a background thread update the Realm
-    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
-    //   7- callbacks are notified with the latest results (called twice overall)
+    //   1- Inserts 10 objects.
+    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
+    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
+    //   4- The queries will complete with the same version as the caller thread.
+    //   5- Using a background thread update the Realm.
+    //   6- Now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries.
+    //   7- Callbacks are notified with the latest results (called twice overall).
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync_batchUpdate() {
@@ -1114,12 +1114,12 @@ public void findAllSortedAsync_batchUpdate() {
         final AtomicInteger numberOfIntercept = new AtomicInteger(0);
         Realm realm = looperThread.realm;
 
-        // 1. Add initial 10 objects
+        // 1. Adds initial 10 objects.
         realm.setAutoRefresh(false);
         populateTestRealm(realm, 10);
         realm.setAutoRefresh(true);
 
-        // 2. Configure interceptor
+        // 2. Configures interceptor.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
@@ -1153,21 +1153,21 @@ public void run() {
         };
         realm.setHandler(handler);
 
-        // 3. Create 2 async queries
+        // 3. Creates 2 async queries.
         final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
                 .findAllSortedAsync("columnString", Sort.ASCENDING);
         final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
                 .findAllSortedAsync("columnString", Sort.DESCENDING);
 
-        // 4. Assert that queries have not finished
+        // 4. Asserts that queries have not finished.
         assertFalse(realmResults1.isLoaded());
         assertFalse(realmResults2.isLoaded());
         assertEquals(0, realmResults1.size());
         assertEquals(0, realmResults2.size());
 
-        // 5. Change listeners will be called twice. Once when the first query completely and then
-        // when the background thread has completed, notifying this thread to rerun and then receive
+        // 5. Change listeners will be called twice. Once when the first query has completed and then
+        // when the background thread has completed, notifies this thread to rerun and then receives
         // the updated results.
         final Runnable signalCallbackDone = new Runnable() {
             private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
@@ -1188,13 +1188,13 @@ public void run() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
-                    case 1: { // first callback invocation
+                    case 1: { // First callback invocation
                         assertTrue(realmResults1.isLoaded());
                         assertEquals(10, realmResults1.size());
                         assertEquals("test data 4", realmResults1.get(4).getColumnString());
                         break;
                     }
-                    case 2: { // second callback
+                    case 2: { // Second callback
                         assertTrue(realmResults1.isLoaded());
                         assertEquals(12, realmResults1.size());
                         assertEquals("modified", realmResults1.get(2).getColumnString());
@@ -1209,13 +1209,13 @@ public void onChange(RealmResults<AllTypes> object) {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
-                    case 1: { // first callback invocation
+                    case 1: { // First callback invocation
                         assertTrue(realmResults2.isLoaded());
                         assertEquals(5, realmResults2.size());
                         assertEquals("test data 4", realmResults2.get(0).getColumnString());
                         break;
                     }
-                    case 2: { // second callback
+                    case 2: { // Second callback
                         assertTrue(realmResults2.isLoaded());
                         assertEquals(7, realmResults2.size());
                         assertEquals("modified", realmResults2.get(4).getColumnString());
@@ -1227,15 +1227,15 @@ public void onChange(RealmResults<AllTypes> object) {
         });
     }
 
-    // similar UC as #testFindAllAsyncBatchUpdate using 'findAllSortedMulti'
+    // Similar UC as #testFindAllAsyncBatchUpdate using 'findAllSortedMulti'.
     // UC:
-    //   1- insert 10 objects
-    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
-    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
-    //   4- the queries will complete with the same version as the caller thread
-    //   5- using a background thread update the Realm
-    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
-    //   7- callbacks are notified with the latest results (called twice overall)
+    //   1- Inserts 10 objects.
+    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
+    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
+    //   4- The queries will complete with the same version as the caller thread.
+    //   5- Using a background thread updates the Realm.
+    //   6- Now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries.
+    //   7- Callbacks are notified with the latest results (called twice overall).
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
@@ -1244,7 +1244,7 @@ public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
         final AtomicInteger numberOfIntercept = new AtomicInteger(0);
         Realm realm = looperThread.realm;
 
-        // 1. Add initial objects
+        // 1. Adds initial objects.
         realm.setAutoRefresh(false);
         realm.beginTransaction();
         for (int i = 0; i < 5; ) {
@@ -1259,7 +1259,7 @@ public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
         realm.commitTransaction();
         realm.setAutoRefresh(true);
 
-        // 2. Configure interceptor
+        // 2. Configures interceptor.
         final Handler handler = new HandlerProxy(realm.handlerController) {
             @Override
             public boolean onInterceptInMessage(int what) {
@@ -1292,14 +1292,14 @@ public void doInBackground(Realm realm) {
         };
         realm.setHandler(handler);
 
-        // 3. Create 2 async queries
+        // 3. Creates 2 async queries.
         final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
                 .findAllSortedAsync("columnString", Sort.ASCENDING, "columnLong", Sort.DESCENDING);
         final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
                 .between("columnLong", 0, 5)
                 .findAllSortedAsync("columnString", Sort.DESCENDING, "columnLong", Sort.ASCENDING);
 
-        // 4. Assert that queries have not finished
+        // 4. Asserts that queries have not finished.
         assertFalse(realmResults1.isLoaded());
         assertFalse(realmResults2.isLoaded());
         assertEquals(0, realmResults1.size());
@@ -1309,8 +1309,8 @@ public void doInBackground(Realm realm) {
         assertEquals(0, realmResults1.size());
         assertEquals(0, realmResults2.size());
 
-        // 5. Change listeners will be called twice. Once when the first query completely and then
-        // when the background thread has completed, notifying this thread to rerun and then receive
+        // 5. Changes listeners will be called twice. Once when the first query has completed and then
+        // when the background thread has completed, notifies this thread to rerun and then receives
         // the updated results.
         final Runnable signalCallbackDone = new Runnable() {
             private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
@@ -1332,7 +1332,7 @@ public void run() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
-                    case 1: // first callback invocation
+                    case 1: // First callback invocation
                         assertTrue(realmResults1.isLoaded());
                         assertEquals(10, realmResults1.size());
 
@@ -1360,14 +1360,14 @@ public void onChange(RealmResults<AllTypes> object) {
                         assertEquals(1, realmResults1.get(9).getColumnLong());
                         break;
 
-                    case 2: // second callback
+                    case 2: // Second callback
                         assertTrue(realmResults1.isLoaded());
                         assertEquals(12, realmResults1.size());
-                        //first
+                        // First
                         assertEquals("data 0", realmResults1.get(0).getColumnString());
                         assertEquals(3, realmResults1.get(0).getColumnLong());
 
-                        //last
+                        // Last
                         assertEquals("data 5", realmResults1.get(11).getColumnString());
                         assertEquals(0, realmResults1.get(11).getColumnLong());
 
@@ -1381,7 +1381,7 @@ public void onChange(RealmResults<AllTypes> object) {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
-                    case 1: // first callback invocation
+                    case 1: // First callback invocation
                         assertTrue(realmResults2.isLoaded());
                         assertEquals(10, realmResults2.size());
 
@@ -1409,7 +1409,7 @@ public void onChange(RealmResults<AllTypes> object) {
                         assertEquals(3, realmResults2.get(9).getColumnLong());
                         break;
 
-                    case 2: // second callback
+                    case 2: // Second callback
                         assertTrue(realmResults2.isLoaded());
                         assertEquals(12, realmResults2.size());
 
@@ -1429,25 +1429,25 @@ public void onChange(RealmResults<AllTypes> object) {
         });
     }
 
-    // make sure the notification listener does not leak the enclosing class
+    // Makes sure the notification listener does not leak the enclosing class
     // if unregistered properly.
     @Test
     @RunTestInLooperThread
     public void listenerShouldNotLeak() {
         populateTestRealm(looperThread.realm, 10);
 
-        // simulate the ActivityManager by creating 1 instance responsible
-        // of attaching an onChange listener, then simulate a configuration
+        // Simulates the ActivityManager by creating 1 instance responsible
+        // of attaching an onChange listener, then simulates a configuration
         // change (ex: screen rotation), this change will create a new instance.
-        // we make sure that the GC enqueue the reference of the destroyed instance
-        // which indicate no memory leak
+        // We make sure that the GC enqueues the reference of the destroyed instance
+        // which indicate no memory leak.
         MockActivityManager mockActivityManager =
                 MockActivityManager.newInstance(looperThread.realm.getConfiguration());
 
         mockActivityManager.sendConfigurationChange();
 
         assertEquals(1, mockActivityManager.numberOfInstances());
-        // remove GC'd reference & assert that one instance should remain
+        // Removes GC'd reference & asserts that one instance should remain.
         Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator =
                 looperThread.realm.handlerController.asyncRealmResults.entrySet().iterator();
         while (iterator.hasNext()) {
@@ -1459,7 +1459,7 @@ public void listenerShouldNotLeak() {
         }
 
         assertEquals(1, looperThread.realm.handlerController.asyncRealmResults.size());
-        mockActivityManager.onStop();// to close the Realm
+        mockActivityManager.onStop();// To close the Realm.
         looperThread.testComplete();
     }
 
@@ -1486,8 +1486,8 @@ public void onChange(RealmResults<AllTypes> object) {
         looperThread.keepStrongReference.add(allTypesAsync);
     }
 
-    // keep advancing the Realm by sending 1 commit for each frame (16ms)
-    // the async queries should keep up with the modification
+    // Keeps advancing the Realm by sending 1 commit for each frame (16ms).
+    // The async queries should keep up with the modification.
     @Test
     @RunTestInLooperThread
     public void stressTestBackgroundCommits() throws Throwable {
@@ -1496,7 +1496,7 @@ public void stressTestBackgroundCommits() throws Throwable {
         final long[] latestLongValue = new long[1];
         final float[] latestFloatValue = new float[1];
 
-        // start a background thread that pushes a commit every 16ms
+        // Starts a background thread that pushes a commit every 16ms.
         final Thread backgroundThread = new Thread() {
             @Override
             public void run() {
@@ -1511,7 +1511,7 @@ public void run() {
                     object.setColumnLong(latestLongValue[0]);
                     backgroundThreadRealm.commitTransaction();
 
-                    // Wait 16ms. before adding the next commit.
+                    // Waits 16ms. Before adding the next commit.
                     SystemClock.sleep(16);
                 }
                 backgroundThreadRealm.close();
@@ -1550,7 +1550,7 @@ public void run() {
     public void distinctAsync() throws Throwable {
         Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync("indexBoolean");
@@ -1651,7 +1651,7 @@ public void onChange(RealmResults<AllJavaTypes> results) {
     public void distinctAsync_notIndexedFields() throws Throwable {
         Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         for (String fieldName : new String[]{"Boolean", "Long", "Date", "String"}) {
@@ -1670,7 +1670,7 @@ public void distinctAsync_notIndexedFields() throws Throwable {
     public void distinctAsync_noneExistingField() throws Throwable {
         Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
@@ -1696,7 +1696,7 @@ public void batchUpdateDifferentTypeOfQueries() {
             allTypes.setColumnString("data " + (++i % 3));
         }
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         realm.commitTransaction();
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
@@ -1791,8 +1791,8 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
             }
         });
 
-        // wait for the queries to completes then send a commit from
-        // another thread to trigger a batch update of the 4 queries
+        // Waits for the queries to complete then sends a commit from
+        // another thread to trigger a batch update of the 4 queries.
         new Thread() {
             @Override
             public void run() {
@@ -1814,7 +1814,7 @@ public void run() {
         }.start();
     }
 
-    // this test make sure that Async queries update when using link
+    // This test makes sure that Async queries update when using link.
     @Test
     @RunTestInLooperThread
     public void queryingLinkHandover() throws Throwable {
@@ -1864,15 +1864,15 @@ public void doInBackground(Realm realm) {
         });
     }
 
-    // Make sure we don't get the run into the IllegalStateException
+    // Makes sure we don't get the run into the IllegalStateException.
     // (Caller thread behind the worker thread)
     // Scenario:
-    // - Caller thread is in version 1, start an asyncFindFirst
-    // - Another thread advance the Realm, now the latest version = 2
-    // - The worker thread should query against version 1 not version 2
-    // otherwise the caller thread wouldn't be able to import the result
+    // - Caller thread is in version 1, starts an asyncFindFirst.
+    // - Another thread advances the Realm, now the latest version = 2.
+    // - The worker thread should query against version 1 not version 2.
+    // Otherwise the caller thread wouldn't be able to import the result.
     // - The notification mechanism will guarantee that the REALM_CHANGE triggered by
-    // the background thread, will update the caller thread (advancing it to version 2)
+    // the background thread, will update the caller thread (advancing it to version 2).
     @Test
     @RunTestInLooperThread
     public void testFindFirstUsesCallerThreadVersion() throws Throwable {
@@ -1892,12 +1892,12 @@ public void onChange(AllTypes object) {
             }
         });
 
-        // advance the background Realm
+        // Advances the background Realm.
         new Thread() {
             @Override
             public void run() {
                 Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                // Advancing the Realm without generating notifications
+                // Advances the Realm without generating notifications.
                 bgRealm.sharedRealm.beginTransaction();
                 bgRealm.sharedRealm.commitTransaction();
                 Realm.asyncTaskExecutor.resume();
@@ -1908,7 +1908,7 @@ public void run() {
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
     @Test
     @UiThreadTest
     public void badVersion_findAll() throws NoSuchFieldException, IllegalAccessException {
@@ -1943,7 +1943,7 @@ public void execute(Realm realm) {
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
     @Test
     @UiThreadTest
     public void badVersion_findAllSortedAsync() throws NoSuchFieldException, IllegalAccessException {
@@ -1976,7 +1976,7 @@ public void execute(Realm realm) {
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
     @Test
     @UiThreadTest
     public void badVersion_distinct() throws NoSuchFieldException, IllegalAccessException {
@@ -2010,14 +2010,14 @@ public void execute(Realm realm) {
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
     @Test
     @RunTestInLooperThread
     public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAccessException {
         TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
         Realm realm = looperThread.realm;
 
-        // 1. Make sure that async query is not started
+        // 1. Makes sure that async query is not started.
         final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
         looperThread.keepStrongReference.add(result);
         result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -2025,7 +2025,6 @@ public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAcc
             public void onChange(RealmResults<AllTypes> object) {
                 // 4. The commit in #2, should result in a refresh being triggered, which means this callback will
                 // be notified once the updated async queries has run.
-                // with the correct
                 assertTrue(result.isValid());
                 assertTrue(result.isLoaded());
                 assertEquals(1, result.size());
@@ -2033,18 +2032,18 @@ public void onChange(RealmResults<AllTypes> object) {
             }
         });
 
-        // 2. Advance the calle Realm, invalidating the version in the handover object
+        // 2. Advances the callee Realm, invalidating the version in the handover object.
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        // 3. The async query should now (hopefully) fail with a BadVersion
+        // 3. The async query should now (hopefully) fail with a BadVersion.
         result.load();
         TestHelper.resetRealmThreadExecutor();
     }
 
-    // handlerController#emptyAsyncRealmObject is accessed from different threads
-    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
+    // handlerController#emptyAsyncRealmObject is accessed from different threads.
+    // Makes sure that we iterate over it safely without any race condition (ConcurrentModification).
     @Test
     @UiThreadTest
     public void concurrentModificationEmptyAsyncRealmObject() {
@@ -2065,8 +2064,8 @@ public void concurrentModificationEmptyAsyncRealmObject() {
         final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
 
         final RealmQuery<Dog> dummyQuery = RealmQuery.createQuery(realm, Dog.class);
-        // Initialize the emptyAsyncRealmObject map, to make sure that iterating is safe
-        // even if we modify the map from a background thread (in case of an empty findFirstAsync)
+        // Initializes the emptyAsyncRealmObject map, to make sure that iterating is safe
+        // even if we modify the map from a background thread (in case of an empty findFirstAsync).
         realm.handlerController.emptyAsyncRealmObject.put(weakReference1, dummyQuery);
 
         final CountDownLatch dogAddFromBg = new CountDownLatch(1);
@@ -2074,13 +2073,13 @@ public void concurrentModificationEmptyAsyncRealmObject() {
         AtomicBoolean fireOnce = new AtomicBoolean(true);
         while (iterator.hasNext()) {
             Dog next = (Dog) iterator.next().getKey().get();
-            // add a new Dog from a background thread
+            // Adds a new Dog from a background thread.
             if (fireOnce.compareAndSet(true, false)) {
                 new Thread() {
                     @Override
                     public void run() {
-                        // add a WeakReference to simulate an empty row using a findFirstAsync
-                        // this is added on an Executor thread, hence the dedicated thread
+                        // Adds a WeakReference to simulate an empty row using a findFirstAsync.
+                        // This is added on an Executor thread, hence the dedicated thread.
                         realm.handlerController.emptyAsyncRealmObject.put(weakReference2, dummyQuery);
                         dogAddFromBg.countDown();
                     }
@@ -2093,8 +2092,8 @@ public void run() {
         realm.close();
     }
 
-    // handlerController#realmObjects is accessed from different threads
-    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
+    // handlerController#realmObjects is accessed from different threads.
+    // Makes sure that we iterate over it safely without any race condition (ConcurrentModification).
     @Test
     @UiThreadTest
     public void concurrentModificationRealmObjects() {
@@ -2121,7 +2120,7 @@ public void concurrentModificationRealmObjects() {
         AtomicBoolean fireOnce = new AtomicBoolean(true);
         while (iterator.hasNext()) {
             Dog next = (Dog) iterator.next().getKey().get();
-            // add a new Dog from a background thread
+            // Adds a new Dog from a background thread.
             if (fireOnce.compareAndSet(true, false)) {
                 new Thread() {
                     @Override
@@ -2139,14 +2138,14 @@ public void run() {
         realm.close();
     }
 
-    // This test reproduce the issue in https://secure.helpscout.net/conversation/244053233/6163/?folderId=366141
-    // First it creates 512 async queries, then trigger a transaction to make the queries gets update with
+    // This test reproduces the issue in https://secure.helpscout.net/conversation/244053233/6163/?folderId=366141
+    // First it creates 512 async queries, then triggers a transaction to make the queries gets update with
     // nativeBatchUpdateQueries. It should not exceed the limits of local ref map size in JNI.
     @Test
     @RunTestInLooperThread
     public void batchUpdate_localRefIsDeletedInLoopOfNativeBatchUpdateQueries() {
         final Realm realm = looperThread.realm;
-        // For Android, the size of local ref map is 512. Use 1024 for more pressure.
+        // For Android, the size of local ref map is 512. Uses 1024 for more pressure.
         final int TEST_COUNT = 1024;
         final AtomicBoolean updatesTriggered = new AtomicBoolean(false);
         // The first time onChange gets called for every results.
@@ -2167,7 +2166,7 @@ public void onChange(RealmResults<AllTypes> element) {
                 } else {
                     int count  = firstOnChangeCounter.addAndGet(1);
                     if (count == TEST_COUNT) {
-                        // Step 3: Commit the transaction to trigger queries updates.
+                        // Step 3: Commits the transaction to trigger queries updates.
                         updatesTriggered.set(true);
                         realm.executeTransactionAsync(new Realm.Transaction() {
                             @Override
@@ -2176,7 +2175,7 @@ public void execute(Realm realm) {
                             }
                         });
                     } else {
-                        // Step 2: Create 2nd - TEST_COUNT queries.
+                        // Step 2: Creates 2nd - TEST_COUNT queries.
                         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
                         results.addChangeListener(this);
                         looperThread.keepStrongReference.add(results);
@@ -2184,7 +2183,7 @@ public void execute(Realm realm) {
                 }
             }
         };
-        // Step 1. Create first async to kick the test start.
+        // Step 1. Creates first async to kick the test start.
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
         results.addChangeListener(listener);
         looperThread.keepStrongReference.add(results);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index c8213e7d9c..99375d1b2d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -56,7 +56,7 @@ public void setUp() {
         context = InstrumentationRegistry.getInstrumentation().getContext();
     }
 
-    // Test that the closed Realm isn't kept in the Realm instance cache
+    // Tests that the closed Realm isn't kept in the Realm instance cache.
     @Test
     public void typedRealmCacheIsCleared() {
         Realm typedRealm = Realm.getInstance(defaultConfig);
@@ -67,7 +67,7 @@ public void typedRealmCacheIsCleared() {
 
         Realm typedRealm1 = Realm.getInstance(defaultConfig);
         try {
-            assertFalse(typedRealm == typedRealm1); // Must be different instance
+            assertFalse(typedRealm == typedRealm1); // Must be different instance.
             // If cache isn't cleared this would crash because of a closed shared group.
             assertEquals(0, typedRealm1.where(AllTypes.class).count());
         } finally {
@@ -75,7 +75,7 @@ public void typedRealmCacheIsCleared() {
         }
     }
 
-    // Test that the closed DynamicRealms isn't kept in the DynamicRealm instance cache
+    // Tests that the closed DynamicRealms isn't kept in the DynamicRealm instance cache.
     @Test
     public void dynamicRealmCacheIsCleared() {
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
@@ -102,13 +102,13 @@ public void getInstanceClearsCacheWhenFailed() {
         RealmConfiguration configB = configFactory.createConfiguration(REALM_NAME,
                 TestHelper.getRandomKey(43));
 
-        Realm realm = Realm.getInstance(configA); // Create starting Realm with key1
+        Realm realm = Realm.getInstance(configA); // Creates starting Realm with key 1.
         realm.close();
         try {
-            Realm.getInstance(configB); // Try to open with key 2
+            Realm.getInstance(configB); // Tries to open with key 2.
         } catch (RealmFileException expected) {
             assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
-            // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
+            // Deletes Realm so key 2 works. This should work as a Realm shouldn't be cached
             // if initialization failed.
             assertTrue(Realm.deleteRealm(configA));
             realm = Realm.getInstance(configB);
@@ -128,7 +128,7 @@ public void realmCache() {
         }
     }
 
-    // We should not cache wrong configurations
+    // We should not cache wrong configurations.
     @Test
     public void dontCacheWrongConfigurations() throws IOException {
         Realm testRealm;
@@ -150,7 +150,7 @@ public void dontCacheWrongConfigurations() throws IOException {
                 .schema(StringOnly.class)
                 .build();
 
-        // Open Realm with wrong key
+        // Opens Realm with wrong key.
         try {
             Realm.getInstance(wrongConfig);
             fail();
@@ -158,7 +158,7 @@ public void dontCacheWrongConfigurations() throws IOException {
             assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
 
-        // Try again with proper key
+        // Tries again with proper key.
         testRealm = Realm.getInstance(rightConfig);
         assertNotNull(testRealm);
         testRealm.close();
@@ -180,7 +180,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
                 .schema(StringOnly.class)
                 .build();
 
-        // 1. Write a copy of the encrypted Realm to a new file
+        // 1. Writes a copy of the encrypted Realm to a new file.
         Realm testRealm = Realm.getInstance(config);
         File copiedRealm = new File(config.getRealmDirectory(), "encrypted-copy.realm");
         if (copiedRealm.exists()) {
@@ -189,13 +189,13 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         testRealm.writeEncryptedCopyTo(copiedRealm, newPassword);
         testRealm.close();
 
-        // 2. Delete the old Realm.
+        // 2. Deletes the old Realm.
         Realm.deleteRealm(config);
 
-        // 3. Rename the new file to the old file name.
+        // 3. Renames the new file to the old file name.
         assertTrue(copiedRealm.renameTo(new File(config.getRealmDirectory(), REALM_NAME)));
 
-        // 4. Try to open the file again with the new password
+        // 4. Tries to open the file again with the new password.
         // If the configuration cache wasn't cleared this would fail as we would detect two
         // configurations with 2 different passwords pointing to the same file.
         RealmConfiguration newConfig = configFactory.createConfigurationBuilder()
@@ -262,17 +262,17 @@ public void run() {
 
     @Test
     public void releaseCacheInOneThread() {
-        // Test release typed Realm instance
+        // Tests release typed Realm instance.
         Realm realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         Realm realmB = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         RealmCache.release(realmA);
         assertNotNull(realmA.sharedRealm);
         RealmCache.release(realmB);
         assertNull(realmB.sharedRealm);
-        // No crash but warning in the log
+        // No crash but warning in the log.
         RealmCache.release(realmB);
 
-        // Test release dynamic Realm instance
+        // Tests release dynamic Realm instance.
         DynamicRealm dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
         DynamicRealm dynamicRealmB = RealmCache.createRealmOrGetFromCache(defaultConfig,
@@ -281,10 +281,10 @@ public void releaseCacheInOneThread() {
         assertNotNull(dynamicRealmA.sharedRealm);
         RealmCache.release(dynamicRealmB);
         assertNull(dynamicRealmB.sharedRealm);
-        // No crash but warning in the log
+        // No crash but warning in the log.
         RealmCache.release(dynamicRealmB);
 
-        // Test both typed Realm and dynamic Realm in same thread
+        // Tests both typed Realm and dynamic Realm in same thread.
         realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig, DynamicRealm.class);
         RealmCache.release(realmA);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index 1fcc0c64df..e3c1e2f2b6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -30,6 +30,7 @@
 import java.util.List;
 
 import io.realm.entities.AllJavaTypes;
+import io.realm.entities.CustomMethods;
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -133,6 +134,38 @@ public void tearDown() {
         }
     }
 
+    private RealmCollection<CustomMethods> createCustomMethodsCollection(Realm realm, CollectionClass collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                realm.beginTransaction();
+                CustomMethods top = realm.createObject(CustomMethods.class);
+                top.setName("Top");
+                for (int i = 0; i < TEST_SIZE; i++) {
+                    top.getMethods().add(new CustomMethods("Child" + i));
+                }
+                realm.commitTransaction();
+                return top.getMethods();
+
+            case UNMANAGED_REALMLIST:
+                RealmList<CustomMethods> list = new RealmList<CustomMethods>();
+                for (int i = 0; i < TEST_SIZE; i++) {
+                    list.add(new CustomMethods("Child" + i));
+                }
+                return list;
+
+            case REALMRESULTS:
+                realm.beginTransaction();
+                for (int i = 0; i < TEST_SIZE; i++) {
+                    realm.copyToRealm(new CustomMethods("Child" + i));
+                }
+                realm.commitTransaction();
+                return realm.where(CustomMethods.class).findAll();
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
     private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, CollectionClass collectionClass) {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
@@ -181,6 +214,19 @@ public void contains_null() {
         assertFalse(collection.contains(null));
     }
 
+    // Test that the custom equal methods is being used when testing if an object is part of the
+    // collection
+    @Test
+    public void contains_customEqualMethod() {
+        RealmCollection<CustomMethods> collection = createCustomMethodsCollection(realm, collectionClass);
+        // This custom equals method will only consider the field `name` when comparing objects.
+        // So this unmanaged version should be equal to any object with the same value, managed
+        // or not.
+        assertTrue(collection.contains(new CustomMethods("Child0")));
+        assertTrue(collection.contains(new CustomMethods("Child" + (TEST_SIZE - 1))));
+        assertFalse(collection.contains(new CustomMethods("Child" + TEST_SIZE)));
+    }
+
     @Test
     public void containsAll() {
         Iterator<AllJavaTypes> it = collection.iterator();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 2763ab5b16..0986180f0c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -225,7 +225,7 @@ public void constructBuilder_versionLessThanDiscVersionThrows() {
 
     @Test
     public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
-        // Create initial Realm
+        // Creates initial Realm.
         RealmConfiguration config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
                 .schemaVersion(42)
@@ -233,7 +233,7 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
                 .build();
         Realm.getInstance(config).close();
 
-        // Create new instance with a configuration containing another schema
+        // Creates new instance with a configuration containing another schema.
         try {
             config = new RealmConfiguration.Builder(context)
                     .directory(configFactory.getRoot())
@@ -271,14 +271,14 @@ public void migration_nullThrows() {
 
     @Test
     public void modules_nonRealmModulesThrows() {
-        // Test first argument
+        // Tests first argument.
         try {
             new RealmConfiguration.Builder(context).modules(new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
-        // Test second argument
+        // Tests second argument.
         try {
             new RealmConfiguration.Builder(context).modules(Realm.getDefaultModule(), new Object());
             fail();
@@ -334,7 +334,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
 
     @Test
     public void deleteRealmIfMigrationNeeded() {
-        // Populate v0 of a Realm with an object
+        // Populates v0 of a Realm with an object.
         RealmConfiguration config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
                 .schema(Dog.class)
@@ -348,7 +348,7 @@ public void deleteRealmIfMigrationNeeded() {
         assertEquals(1, realm.where(Dog.class).count());
         realm.close();
 
-        // Change schema and verify that Realm has been cleared
+        // Changes schema and verifies that Realm has been cleared.
         config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
                 .schema(Owner.class, Dog.class)
@@ -363,7 +363,7 @@ public void deleteRealmIfMigrationNeeded() {
     public void deleteRealmIfMigrationNeeded_failsWhenAssetFileProvided() {
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
 
-        // have a builder instance to isolate codepath
+        // Has a builder instance to isolate codepath.
         RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
         try {
             builder
@@ -404,7 +404,7 @@ public void equals() {
 
     @Test
     public void equalsWhenRxJavaUnavailable() {
-        // test for https://github.com/realm/realm-java/issues/2416
+        // Test for https://github.com/realm/realm-java/issues/2416
         RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config1);
         RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
@@ -535,7 +535,7 @@ public void schema_differentSchemasThrows() {
         }
     }
 
-    // Creating Realm instances with same name but different durabilities is not allowed.
+    // Creates Realm instances with same name but different durabilities is not allowed.
     @Test
     public void inMemory_differentDurabilityThrows() {
         RealmConfiguration config1 = new RealmConfiguration.Builder(context)
@@ -546,7 +546,7 @@ public void inMemory_differentDurabilityThrows() {
                 .directory(configFactory.getRoot())
                 .build();
 
-        // Create In-memory Realm first.
+        // Creates In-memory Realm first.
         Realm realm1 = Realm.getInstance(config1);
         try {
             // On-disk Realm then. Not allowed!
@@ -557,7 +557,7 @@ public void inMemory_differentDurabilityThrows() {
             realm1.close();
         }
 
-        // Create on-disk Realm first.
+        // Creates on-disk Realm first.
         realm1 = Realm.getInstance(config2);
         try {
             // In-memory Realm then. Not allowed!
@@ -569,7 +569,7 @@ public void inMemory_differentDurabilityThrows() {
         }
     }
 
-    // It is allowed to create multiple Realm with same name but in different directory
+    // It is allowed to create multiple Realm with same name but in different directory.
     @Test
     public void constructBuilder_differentDirSameName() throws IOException {
         RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
@@ -583,7 +583,7 @@ public void constructBuilder_differentDirSameName() throws IOException {
 
     @Test
     public void encryptionKey_keyStorage() throws Exception {
-        // Generate a key and use it in a RealmConfiguration
+        // Generates a key and uses it in a RealmConfiguration.
         byte[] oldKey = TestHelper.getRandomKey(12345);
         byte[] key = oldKey;
         RealmConfiguration config = new RealmConfiguration.Builder(context)
@@ -591,13 +591,13 @@ public void encryptionKey_keyStorage() throws Exception {
                 .encryptionKey(key)
                 .build();
 
-        // Generate a different key and assign it to the same variable
+        // Generates a different key and assigns it to the same variable.
         byte[] newKey = TestHelper.getRandomKey(67890);
         MoreAsserts.assertNotEqual(key, newKey);
         key = newKey;
         MoreAsserts.assertEquals(key, newKey);
 
-        // Ensure that the stored key did not change
+        // Ensures that the stored key did not change.
         MoreAsserts.assertEquals(oldKey, config.getEncryptionKey());
     }
 
@@ -609,7 +609,7 @@ public void modelClassesForDefaultMediator() throws Exception {
 
         assertTrue(realmClasses.contains(AllTypes.class));
 
-        // tests returned Set is unmodifiable.
+        // Tests returned Set is unmodifiable.
         try {
             realmClasses.add(AllTypes.class);
             fail();
@@ -631,7 +631,7 @@ public void modelClasses_forGeneratedMediator() throws Exception {
         assertTrue(realmClasses.contains(CatOwner.class));
         assertFalse(realmClasses.contains(Cat.class));
 
-        // tests returned Set is unmodifiable.
+        // Tests returned Set is unmodifiable.
         try {
             realmClasses.add(AllTypes.class);
             fail();
@@ -653,7 +653,7 @@ public void modelClasses_forCompositeMediator() throws Exception {
         assertTrue(realmClasses.contains(CatOwner.class));
         assertTrue(realmClasses.contains(Cat.class));
 
-        // tests returned Set is unmodifiable.
+        // Tests returned Set is unmodifiable.
         try {
             realmClasses.add(AllTypes.class);
             fail();
@@ -676,7 +676,7 @@ public void modelClasses_forFilterableMediator() throws Exception {
         assertTrue(realmClasses.contains(CatOwner.class));
         assertFalse(realmClasses.contains(Cat.class));
 
-        // tests returned Set is unmodifiable.
+        // Tests returned Set is unmodifiable.
         try {
             realmClasses.add(AllTypes.class);
             fail();
@@ -774,7 +774,7 @@ public void initialDataTransactionNull() {
 
     @Test
     public void initialDataTransactionNotNull() {
-        // Remove default instance
+        // Removes default instance.
         Realm.deleteRealm(defaultConfig);
 
         RealmConfiguration configuration = configFactory.createConfigurationBuilder()
@@ -788,7 +788,7 @@ public void execute(final Realm realm) {
 
         realm = Realm.getInstance(configuration);
 
-        // First time check for initial data
+        // First time check for initial data.
         assertEquals(1, realm.where(AllTypes.class).count());
         assertEquals(1, realm.where(Owner.class).count());
         assertEquals(1, realm.where(Cat.class).count());
@@ -801,7 +801,7 @@ public void execute(final Realm realm) {
 
         realm.close();
         realm = Realm.getInstance(configuration);
-        // Check if there is still the same data
+        // Checks if there is still the same data.
         assertEquals(0, realm.where(AllTypes.class).count());
         assertEquals(1, realm.where(Owner.class).count());
         assertEquals(1, realm.where(Cat.class).count());
@@ -809,7 +809,7 @@ public void execute(final Realm realm) {
 
     @Test
     public void initialDataTransactionExecutionCount() {
-        // Remove default instance
+        // Removes default instance.
         Realm.deleteRealm(defaultConfig);
 
         Realm.Transaction transaction = mock(Realm.Transaction.class);
@@ -828,7 +828,7 @@ public void initialDataTransactionExecutionCount() {
 
     @Test
     public void initialDataTransactionAssetFile() throws IOException {
-        // Remove default instance
+        // Removes default instance.
         Realm.deleteRealm(defaultConfig);
 
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
@@ -863,7 +863,7 @@ public void assetFileNullAndEmptyFileName() {
 
     @Test
     public void assetFileWithInMemoryConfig() {
-        // Ensure that there is no data
+        // Ensures that there is no data.
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
         try {
@@ -875,7 +875,7 @@ public void assetFileWithInMemoryConfig() {
 
     @Test
     public void assetFileFakeFile() {
-        // Ensure that there is no data
+        // Ensures that there is no data.
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
         RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile("no_file").build();
@@ -889,7 +889,7 @@ public void assetFileFakeFile() {
 
     @Test
     public void assetFileValidFile() throws IOException {
-        // Ensure that there is no data
+        // Ensures that there is no data.
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
         RealmConfiguration configuration = new RealmConfiguration
@@ -905,13 +905,13 @@ public void assetFileValidFile() throws IOException {
         realm = Realm.getInstance(configuration);
         assertTrue(realmFile.exists());
 
-        // Asset file has 10 Owners and 10 Cats, check if data is present
+        // Asset file has 10 Owners and 10 Cats, checks if data is present.
         assertEquals(10, realm.where(Owner.class).count());
         assertEquals(10, realm.where(Cat.class).count());
 
         realm.close();
 
-        // Copy original file to another location
+        // Copies original file to another location.
         configFactory.copyRealmFromAssets(context, "asset_file.realm", "asset_file_copy.realm");
         File copyFromAsset = new File(configFactory.getRoot(), "asset_file_copy.realm");
         assertTrue(copyFromAsset.exists());
@@ -924,7 +924,7 @@ public void assetFileValidFile() throws IOException {
     public void assetFile_failsWhenDeleteRealmIfMigrationNeededConfigured() {
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
 
-        // have a builder instance to isolate codepath
+        // Has a builder instance to isolate codepath.
         RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
         try {
             builder
@@ -940,7 +940,7 @@ public void assetFile_failsWhenDeleteRealmIfMigrationNeededConfigured() {
     private static class MigrationWithNoEquals implements RealmMigration {
         @Override
         public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-            // Do nothing
+            // Does nothing.
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index b273290f41..8fd06f3310 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -60,7 +60,7 @@ public void setUp() {
                 .inMemory()
                 .build();
 
-        // Delete the same name Realm file just in case
+        // Deletes the same name Realm file just in case.
         Realm.deleteRealm(onDiskConf);
         testRealm = Realm.getInstance(inMemConf);
     }
@@ -72,7 +72,7 @@ public void tearDown() {
         }
     }
 
-    // Testing the in-memory Realm by Creating one instance, adding a record, then close the instance.
+    // Tests the in-memory Realm by creating one instance, adding a record, then closes the instance.
     // By the next time in-memory Realm instance with the same name created, it should be empty.
     @Test
     public void inMemoryRealm() {
@@ -99,7 +99,7 @@ public void inMemoryRealmWithDifferentNames() {
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
-        // Create the 2nd in-memory Realm with a different name. To make sure they are not affecting each other.
+        // Creates the 2nd in-memory Realm with a different name. To make sure they are not affecting each other.
         RealmConfiguration inMemConf2 = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER + "2")
                 .inMemory()
@@ -120,7 +120,7 @@ public void inMemoryRealmWithDifferentNames() {
         testRealm2.close();
     }
 
-    // Test deleteRealm called on a in-memory Realm instance
+    // Tests deleteRealm called on a in-memory Realm instance.
     @Test
     public void delete() {
         RealmConfiguration configuration = testRealm.getConfiguration();
@@ -136,7 +136,7 @@ public void delete() {
         assertTrue(Realm.deleteRealm(configuration));
     }
 
-    // Test if an in-memory Realm can be written to disk with/without encryption
+    // Tests if an in-memory Realm can be written to disk with/without encryption.
     @Test
     public void writeCopyTo() {
         byte[] key = TestHelper.getRandomKey();
@@ -158,18 +158,18 @@ public void writeCopyTo() {
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
-        // Test a normal Realm file
+        // Tests a normal Realm file.
         testRealm.writeCopyTo(new File(configFactory.getRoot(), fileName));
         Realm onDiskRealm = Realm.getInstance(conf);
         assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
 
-        // Test a encrypted Realm file
+        // Tests a encrypted Realm file.
         testRealm.writeEncryptedCopyTo(new File(configFactory.getRoot(), encFileName), key);
         onDiskRealm = Realm.getInstance(encConf);
         assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
-        // Test with a wrong key to see if it fails as expected.
+        // Tests with a wrong key to see if it fails as expected.
         try {
             RealmConfiguration wrongKeyConf = configFactory.createConfigurationBuilder()
                     .name(encFileName)
@@ -183,11 +183,11 @@ public void writeCopyTo() {
     }
 
     // Test below scenario:
-    // 1. Create a in-memory Realm instance in the main thread.
-    // 2. Create a in-memory Realm with same name in another thread.
-    // 3. Close the in-memory Realm instance in the main thread and the Realm data should not be released since
+    // 1. Creates a in-memory Realm instance in the main thread.
+    // 2. Creates a in-memory Realm with same name in another thread.
+    // 3. Closes the in-memory Realm instance in the main thread and the Realm data should not be released since
     //    another instance is still held by the other thread.
-    // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
+    // 4. Closes the in-memory Realm instance and the Realm data should be released since no more instance with the
     //    specific name exists.
     @Test
     public void multiThread() throws InterruptedException, ExecutionException {
@@ -215,7 +215,7 @@ public void run() {
                 }
                 workerCommittedLatch.countDown();
 
-                // Wait until Realm instance closed in main thread
+                // Waits until Realm instance closed in main thread.
                 try {
                     realmInMainClosedLatch.await(3, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
@@ -231,20 +231,20 @@ public void run() {
         workerThread.start();
 
 
-        // Wait until the worker thread started
+        // Waits until the worker thread started.
         workerCommittedLatch.await(3, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
-        // refresh will be ran in the next loop, manually refresh it here.
+        // Refreshes will be ran in the next loop, manually refreshes it here.
         testRealm.waitForChange();
         assertEquals(testRealm.where(Dog.class).count(), 1);
 
         // Step 3.
-        // Release the main thread Realm reference, and the worker thread hold the reference still
+        // Releases the main thread Realm reference, and the worker thread holds the reference still.
         testRealm.close();
 
         // Step 4.
-        // Create a new Realm reference in main thread and checking the data.
+        // Creates a new Realm reference in main thread and checks the data.
         testRealm = Realm.getInstance(inMemConf);
         assertEquals(testRealm.where(Dog.class).count(), 1);
         testRealm.close();
@@ -252,11 +252,11 @@ public void run() {
         // Let the worker thread continue.
         realmInMainClosedLatch.countDown();
 
-        // Wait until the worker thread finished
+        // Waits until the worker thread finished.
         workerClosedLatch.await(3, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
-        // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance
+        // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance.
         testRealm = Realm.getInstance(inMemConf);
         assertEquals(testRealm.where(Dog.class).count(), 0);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index 1b80bb1b0f..c4e597eb45 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -134,9 +134,9 @@ protected void done() {
         public InterprocessHandler(Runnable startRunnable) {
             super(Looper.myLooper());
             localMessenger = new Messenger(this);
-            // To have the first step from main process run
+            // To have the first step from main process run.
             post(startRunnable);
-            // Start watchdog
+            // Starts watchdog.
             postDelayed(timeoutRunnable, timeout);
         }
 
@@ -145,7 +145,7 @@ public void handleMessage(Message msg) {
             Bundle bundle = msg.getData();
             String error = bundle.getString(RemoteProcessService.BUNDLE_KEY_ERROR);
             if (error != null) {
-                // Assert and show error from service process
+                // Asserts and shows error from service process.
                 assertTrue(error, false);
             }
         }
@@ -157,7 +157,7 @@ protected void setUp() throws Exception {
 
         Realm.deleteRealm(new RealmConfiguration.Builder(getContext()).build());
 
-        // Start the testing service
+        // Starts the testing service.
         serviceStartLatch = new CountDownLatch(1);
         Intent intent = new Intent(getContext(), RemoteProcessService.class);
         getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
@@ -174,7 +174,7 @@ protected void tearDown() throws Exception {
         getContext().unbindService(serviceConnection);
         remoteMessenger = null;
 
-        // Kill the remote process.
+        // Kills the remote process.
         ActivityManager.RunningAppProcessInfo info = getRemoteProcessInfo();
         if (info != null) {
             android.os.Process.killProcess(info.pid);
@@ -189,7 +189,7 @@ protected void tearDown() throws Exception {
         super.tearDown();
     }
 
-    // Call this to trigger the next step of service process
+    // Calls this to trigger the next step of service process.
     private void triggerServiceStep(RemoteProcessService.Step step) {
         Message msg = Message.obtain(null, step.message);
         msg.replyTo = localMessenger;
@@ -200,8 +200,8 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
         }
     }
 
-    // Return the service info if it is alive.
-    // When this method return null, it doesn't mean the remote process is not existed. An 'empty' process could
+    // Returns the service info if it is alive.
+    // When this method returns null, it doesn't mean the remote process is not existed. An 'empty' process could
     // be retained by the system to be used next time.
     // Use getRemoteProcessInfo if you want to check the existence of remote process.
     private ActivityManager.RunningServiceInfo getServiceInfo() {
@@ -215,7 +215,7 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
         return null;
     }
 
-    // Get the remote process info if it is alive.
+    // Gets the remote process info if it is alive.
     private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
         ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
         List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
@@ -228,8 +228,8 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
         return null;
     }
 
-    // A. Open a realm, close it, then call Runtime.getRuntime().exit(0).
-    // 1. Wait 3 seconds to see if the service process existed.
+    // A. Opens a realm, closes it, then calls Runtime.getRuntime().exit(0).
+    // 1. Waits 3 seconds to see if the service process existed.
     public void testExitProcess() {
         new InterprocessHandler(new Runnable() {
             @Override
@@ -257,7 +257,7 @@ public void handleMessage(Message msg) {
                                 // The process is still alive.
                                 assertTrue(false);
                             } else if (processInfo == null || processInfo.pid != servicePid) {
-                                // The process is gone
+                                // The process is gone.
                                 break;
                             }
                             Thread.sleep(500, 0);
@@ -273,8 +273,8 @@ public void handleMessage(Message msg) {
         Looper.loop();
     }
 
-    // 1. Main process create Realm, write one object.
-    // A. Service process open Realm, check if there is one and only one object.
+    // 1. Main process creates Realm, write one object.
+    // A. Service process opens Realm, check if there is one and only one object.
     public void testCreateInitialRealm() throws InterruptedException {
         new InterprocessHandler(new Runnable() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
index 58fa4950b3..1e023847cd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
@@ -64,7 +64,7 @@ public void tearDown() {
         }
     }
 
-    // parameters for testing absent primary key value. PrimaryKey field is absent.
+    // Parameters for testing absent primary key value. PrimaryKey field is absent.
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
@@ -84,7 +84,7 @@ public RealmJsonAbsentPrimaryKeyTests(Class<? extends RealmObject> clazz, String
         this.clazz = clazz;
     }
 
-    // Testing absent primary key value for createObjectFromJson()
+    // Tests absent primary key value for createObjectFromJson().
     @Test
     public void createObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
         realm.beginTransaction();
@@ -93,7 +93,7 @@ public void createObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSO
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createOrUpdateObjectFromJson()
+    // Tests absent primary key value for createOrUpdateObjectFromJson().
     @Test
     public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
         realm.beginTransaction();
@@ -102,7 +102,7 @@ public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonObject() th
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createAllFromJson()
+    // Tests absent primary key value for createAllFromJson().
     @Test
     public void createAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
         JSONArray jsonArray = new JSONArray();
@@ -113,7 +113,7 @@ public void createAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONEx
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createOrUpdateAllFromJson()
+    // Tests absent primary key value for createOrUpdateAllFromJson().
     @Test
     public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
         JSONArray jsonArray = new JSONArray();
@@ -124,7 +124,7 @@ public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonObject() throw
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createObjectFromJson() stream version
+    // Tests absent primary key value for createObjectFromJson() stream version.
     @Test
     public void createObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
@@ -135,7 +135,7 @@ public void createObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSO
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createOrUpdateObjectFromJson() stream version
+    // Tests absent primary key value for createOrUpdateObjectFromJson() stream version.
     @Test
     public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
         realm.beginTransaction();
@@ -144,7 +144,7 @@ public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonStream() th
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createAllFromJson() stream version
+    // Tests absent primary key value for createAllFromJson() stream version.
     @Test
     public void createAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
@@ -157,7 +157,7 @@ public void createAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONEx
         realm.commitTransaction();
     }
 
-    // Testing absent primary key value for createOrUpdateAllFromJson() stream version
+    // Tests absent primary key value for createOrUpdateAllFromJson() stream version.
     @Test
     public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
index f0345f07bd..78d8c7f56e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
@@ -57,7 +57,7 @@ public void tearDown() {
         }
     }
 
-    // parameters for testing null primary key value. PrimaryKey field is explicitly null
+    // Parameters for testing null primary key value. PrimaryKey field is explicitly null.
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
@@ -79,7 +79,7 @@ public RealmJsonNullPrimaryKeyTests(Class<? extends RealmObject> clazz, String s
         this.clazz = clazz;
     }
 
-    // Testing null primary key value for createObjectFromJson()
+    // Tests null primary key value for createObjectFromJson().
     @Test
     public void createObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONException {
         realm.beginTransaction();
@@ -102,7 +102,7 @@ public void createObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONE
         }
     }
 
-    // Testing null primary key value for createOrUpdateObjectFromJson()
+    // Tests null primary key value for createOrUpdateObjectFromJson().
     @Test
     public void createOrUpdateObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONException {
         realm.beginTransaction();
@@ -125,7 +125,7 @@ public void createOrUpdateObjectFromJson_primaryKey_isNull_fromJsonObject() thro
         }
     }
 
-    // Testing null primary key value for createObject() -> createOrUpdateObjectFromJson()
+    // Tests null primary key value for createObject() -> createOrUpdateObjectFromJson().
     @Test
     public void createOrUpdateObjectFromJson_primaryKey_isNull_updateFromJsonObject() throws JSONException {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 01733ddd9e..718abc0f41 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -90,7 +90,7 @@ private InputStream convertJsonObjectToStream(JSONObject obj) {
         return new ByteArrayInputStream(obj.toString().getBytes());
     }
 
-    // Assert that the list of AllTypesPrimaryKey objects where inserted and updated properly.
+    // Asserts that the list of AllTypesPrimaryKey objects where inserted and updated properly.
     private void assertAllTypesPrimaryKeyUpdated() {
         assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
@@ -105,7 +105,7 @@ private void assertAllTypesPrimaryKeyUpdated() {
         assertEquals("Dog5", obj.getColumnRealmList().get(0).getName());
     }
 
-    // Check the imported object from nulltyps.json[0].
+    // Checks the imported object from nulltyps.json[0].
     private void checkNullableValuesAreNull(NullTypes nullTypes1) {
         // 1 String
         assertNull(nullTypes1.getFieldStringNull());
@@ -141,7 +141,7 @@ private void checkNullableValuesAreNull(NullTypes nullTypes1) {
         assertNull(nullTypes1.getFieldObjectNull());
     }
 
-    // Check the imported object from nulltyps.json[1].
+    // Checks the imported object from nulltyps.json[1].
     private void checkNullableValuesAreNotNull(NullTypes nullTypes2) {
         // 1 String
         assertEquals("", nullTypes2.getFieldStringNull());
@@ -205,7 +205,7 @@ public void createObjectFromJson_allSimpleObjectAllTypes() throws JSONException
         realm.commitTransaction();
         AllTypes obj = realm.where(AllTypes.class).findFirst();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         assertEquals("String", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1.23F, obj.getColumnFloat(), 0F);
@@ -217,7 +217,7 @@ public void createObjectFromJson_allSimpleObjectAllTypes() throws JSONException
     @Test
     public void createObjectFromJson_dateAsLong() throws JSONException {
         JSONObject json = new JSONObject();
-        json.put("columnDate", 1000L); // Realm operates at seconds level granularity
+        json.put("columnDate", 1000L); // Realm operates at seconds level granularity.
 
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, json);
@@ -375,16 +375,16 @@ public void createAllFromJson_jsonArray() throws JSONException {
     public void createFromJson_respectDefaultValues() throws JSONException {
         final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
 
-        // Step 1: Prepare almost empty JSON
+        // Step 1: Prepares almost empty JSON.
         final JSONObject json = new JSONObject();
         json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
 
-        // Step 2: Update with almost empty JSONObject
+        // Step 2: Updates with almost empty JSONObject.
         realm.beginTransaction();
         final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
         realm.commitTransaction();
 
-        // Step 3: Check that default values are applied
+        // Step 3: Checks that default values are applied.
         assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE,
                 managedObj.getFieldIgnored());
         assertEquals(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE, managedObj.getFieldString());
@@ -403,7 +403,7 @@ public void createFromJson_respectDefaultValues() throws JSONException {
         assertEquals(1, managedObj.getFieldList().size());
         assertEquals(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldList().first().getFieldInt());
 
-        // make sure that excess object by default value is not created.
+        // Makes sure that excess object by default value is not created.
         assertEquals(2, realm.where(RandomPrimaryKey.class).count());
     }
 
@@ -411,7 +411,7 @@ public void createFromJson_respectDefaultValues() throws JSONException {
     public void createFromJson_defaultValuesAreIgnored() throws JSONException {
         final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
 
-        // Step 1: Prepare JSON
+        // Step 1: Prepares JSON.
         final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
         final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
         final String fieldRandomStringValue = "non-random";
@@ -441,12 +441,12 @@ public void createFromJson_defaultValuesAreIgnored() throws JSONException {
         json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
         json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
         json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
-        // value for 'fieldObject'
+        // Value for 'fieldObject'
         final JSONObject fieldObjectJson = new JSONObject();
         fieldObjectJson.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk of fieldObject");
         fieldObjectJson.put(RandomPrimaryKey.FIELD_INT, fieldObjectIntValue);
         json.put(DefaultValueOfField.FIELD_OBJECT, fieldObjectJson);
-        // value for 'fieldList'
+        // Value for 'fieldList'
         final JSONArray fieldListArrayJson = new JSONArray();
         final JSONObject fieldListItem0Json = new JSONObject();
         fieldListItem0Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk1 of fieldList");
@@ -458,13 +458,13 @@ public void createFromJson_defaultValuesAreIgnored() throws JSONException {
         fieldListArrayJson.put(fieldListItem1Json);
         json.put(DefaultValueOfField.FIELD_LIST, fieldListArrayJson);
 
-        // Step 3: Update with JSONObject
+        // Step 3: Updates with JSONObject.
         realm.beginTransaction();
         final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
         realm.commitTransaction();
 
-        // Step 4: Check that properly created
-        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+        // Step 4: Checks that properly created.
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE /* not fieldIgnoredValue */,
                 managedObj.getFieldIgnored());
         assertEquals(fieldStringValue, managedObj.getFieldString());
         assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
@@ -489,7 +489,7 @@ public void createFromJson_defaultValuesAreIgnored() throws JSONException {
                 managedObj.getFieldList().get(1).getFieldRandomPrimaryKey());
         assertEquals(fieldListIntValue + 1, managedObj.getFieldList().get(1).getFieldInt());
 
-        // make sure that excess object by default value is not created.
+        // Makes sure that excess object by default value is not created.
         assertEquals(3, realm.where(RandomPrimaryKey.class).count());
     }
 
@@ -497,14 +497,14 @@ public void createFromJson_defaultValuesAreIgnored() throws JSONException {
     public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
         final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
 
-        // Step 1: Create an object with default values
+        // Step 1: Creates an object with default values.
         final DefaultValueOfField original;
         realm.beginTransaction(); {
             original = realm.createObject(DefaultValueOfField.class, fieldLongPrimaryKeyValue);
         }
         realm.commitTransaction();
 
-        // Step 2: Prepare JSON
+        // Step 2: Prepares JSON.
         final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
         final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
         final String fieldRandomStringValue = "non-random";
@@ -540,26 +540,26 @@ public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
                 original.getFieldObject().getFieldRandomPrimaryKey());
         fieldObjectJson.put(RandomPrimaryKey.FIELD_INT, fieldObjectIntValue);
         json.put(DefaultValueOfField.FIELD_OBJECT, fieldObjectJson);
-        // value for 'fieldList'
+        // Value for 'fieldList'
         final JSONArray fieldListArrayJson = new JSONArray();
-        final JSONObject fieldListItem0Json = new JSONObject(); // to be added
+        final JSONObject fieldListItem0Json = new JSONObject(); // To be added.
         fieldListItem0Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,  "unique value");
         fieldListItem0Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue);
         fieldListArrayJson.put(fieldListItem0Json);
-        final JSONObject fieldListItem1Json = new JSONObject(); // to be updated
+        final JSONObject fieldListItem1Json = new JSONObject(); // To be updated.
         fieldListItem1Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,
                 original.getFieldList().first().getFieldRandomPrimaryKey());
         fieldListItem1Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue + 1);
         fieldListArrayJson.put(fieldListItem1Json);
         json.put(DefaultValueOfField.FIELD_LIST, fieldListArrayJson);
 
-        // Step 3: Update with JSONObject
+        // Step 3: Updates with JSONObject.
         realm.beginTransaction();
         final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
         realm.commitTransaction();
 
-        // Step 4: Check that properly updated
-        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+        // Step 4: Checks that properly updated.
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE /* not fieldIgnoredValue */,
                 managedObj.getFieldIgnored());
         assertEquals(fieldStringValue, managedObj.getFieldString());
         assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
@@ -581,11 +581,11 @@ public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
                 managedObj.getFieldList().get(1).getFieldRandomPrimaryKey());
         assertEquals(fieldListIntValue + 1, managedObj.getFieldList().get(1).getFieldInt());
 
-        // make sure that excess object by default value is not created.
+        // Makes sure that excess object by default value is not created.
         assertEquals(3/* 2 updated + 1 added*/, realm.where(RandomPrimaryKey.class).count());
     }
 
-    // Test if Json object doesn't have the field, then the field should have default value.
+    // Tests if Json object doesn't have the field, then the field should have default value.
     @Test
     public void createObjectFromJson_noValues() throws JSONException {
         JSONObject json = new JSONObject();
@@ -595,7 +595,7 @@ public void createObjectFromJson_noValues() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("", obj.getColumnString());
         assertEquals(0L, obj.getColumnLong());
@@ -608,7 +608,7 @@ public void createObjectFromJson_noValues() throws JSONException {
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
-    // Test that given an exception everything up to the exception is saved
+    // Tests that given an exception everything up to the exception is saved.
     @Test
     public void createObjectFromJson_jsonException() throws JSONException {
         JSONObject json = new JSONObject();
@@ -712,7 +712,7 @@ public void createObjectFromJson_streamAllSimpleTypes() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("String", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
@@ -732,7 +732,7 @@ public void createObjectFromJson_streamDateAsLong() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
@@ -747,7 +747,7 @@ public void createObjectFromJson_streamDateAsString() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
@@ -767,7 +767,7 @@ public void createObjectFromJson_streamDateAsISO8601String() throws IOException
         cal.set(Calendar.MILLISECOND, 789);
         Date date = cal.getTime();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(date, obj.getColumnDate());
     }
@@ -828,7 +828,7 @@ public void createAllFromJson_streamArray() throws IOException {
     }
 
 
-    // Test if Json object doesn't have the field, then the field should have default value. Stream version.
+    // Tests if Json object doesn't have the field, then the field should have default value. Stream version.
     @Test
     public void createObjectFromJson_streamNoValues() throws IOException {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
@@ -839,7 +839,7 @@ public void createObjectFromJson_streamNoValues() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("", obj.getColumnString());
         assertEquals(0L, obj.getColumnLong());
@@ -889,7 +889,7 @@ public void createObjectFromJson_streamNullInputStream() throws IOException {
     }
 
     /**
-     * Test update a existing object with JSON stream. Only primary key in JSON.
+     * Tests updating a existing object with JSON stream. Only primary key in JSON.
      * No value should be changed.
      */
     @Test
@@ -916,7 +916,7 @@ public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("1", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
@@ -992,7 +992,7 @@ public void createOrUpdateObjectFromJson_streamIgnoreUnsetProperties() throws IO
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
         realm.commitTransaction();
 
-        // No-op as no properties should be updated
+        // No-op as no properties should be updated.
         realm.beginTransaction();
         realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{ \"columnLong\":1 }"));
         realm.commitTransaction();
@@ -1020,8 +1020,8 @@ public void createOrUpdateObjectFromJson_inputStream() throws IOException {
     }
 
     /**
-     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
-     * it to the default value (which can fail)
+     * Checks that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail).
      */
     @Test
     public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
@@ -1039,7 +1039,7 @@ public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFro
         assertEquals("bar", owners.get(1).getName());
     }
 
-    // Test update a existing object with JSON object with only primary key.
+    // Tests updating a existing object with JSON object with only primary key.
     // No value should be changed.
     @Test
     public void createOrUpdateObjectFromJson_objectNullValues() throws IOException {
@@ -1062,7 +1062,7 @@ public void createOrUpdateObjectFromJson_objectNullValues() throws IOException {
         realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
         realm.commitTransaction();
 
-        // Check that all primitive types are imported correctly
+        // Checks that all primitive types are imported correctly.
         obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("1", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
@@ -1220,8 +1220,8 @@ public void createOrUpdateObjectFromJson_invalidJsonObject() throws JSONExceptio
     }
 
     /**
-     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
-     * it to the default value (which can fail)
+     * Checks that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail).
      */
     @Test
     public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
@@ -1357,7 +1357,7 @@ public void createOrUpdateAllFromJson_inputString() throws IOException {
         assertAllTypesPrimaryKeyUpdated();
     }
 
-    // Testing create objects from Json, all nullable fields with null values or non-null values
+    // Tests creating objects from Json, all nullable fields with null values or non-null values.
     @Test
     public void createAllFromJson_nullTypesJsonWithNulls() throws IOException, JSONException {
         String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
@@ -1376,7 +1376,7 @@ public void createAllFromJson_nullTypesJsonWithNulls() throws IOException, JSONE
         checkNullableValuesAreNotNull(nullTypes2);
     }
 
-    // Test creating objects form JSON stream, all nullable fields with null values or non-null values
+    // Tests creating objects form JSON stream, all nullable fields with null values or non-null values.
     @Test
     public void createAllFromJson_nullTypesStreamJSONWithNulls() throws IOException {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
@@ -1396,7 +1396,7 @@ public void createAllFromJson_nullTypesStreamJSONWithNulls() throws IOException
     }
 
     /**
-     * Test a nullable field already has a non-null value, update it through JSON with null value
+     * Tests a nullable field already has a non-null value, update it through JSON with null value
      * of the corresponding field.
      */
     @Test
@@ -1416,7 +1416,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
         assertEquals(2, nullTypesRealmResults.size());
         checkNullableValuesAreNotNull(nullTypesRealmResults.where().equalTo("id", 1).findFirst());
 
-        // Update object with id 1, nullable fields should have null values
+        // Updates object with id 1, nullable fields should have null values.
         JSONArray array = new JSONArray(json);
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(NullTypes.class, array);
@@ -1636,8 +1636,8 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
     }
 
     /**
-     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
-     * it to the default value (which can fail)
+     * Checks that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail).
      */
     @Test
     public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
@@ -1663,7 +1663,7 @@ public void createObjectFromJson_objectNullClass() throws JSONException {
 
     /**
      * createObject using primary keys doesn't work if the Check that using createOrUpdateObject
-     * will set the primary key directly instead of first setting it to the default value (which can fail)
+     * will set the primary key directly instead of first setting it to the default value (which can fail).
      */
     @Test
     public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 8e7e01d727..2af194d3ef 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -552,7 +552,7 @@ public void linkIsNotNull() {
     @Test
     public void isNullWrongType() {
         try {
-            // AllTypes.columnFloat is not nullable
+            // AllTypes.columnFloat is not nullable.
             testRealm.where(AllTypes.class).isNull("columnFloat").findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 7dc7177144..5106b86cb8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -104,9 +104,9 @@ public void tearDown() throws Exception {
         return dogs;
     }
 
-            //noinspection TryWithIdenticalCatches
+    //noinspection TryWithIdenticalCatches
     /*********************************************************
-     * Unmanaged mode tests                                *
+     * Unmanaged mode tests                                  *
      *********************************************************/
 
     @Test(expected = IllegalArgumentException.class)
@@ -252,7 +252,7 @@ public void remove_unmanagedMode() {
         assertEquals(object1, object2);
     }
 
-    // Test move where oldPosition > newPosition
+    // Tests move where oldPosition > newPosition.
     @Test
     public void move_down() {
         Owner owner = realm.where(Owner.class).findFirst();
@@ -264,7 +264,7 @@ public void move_down() {
         assertEquals(0, owner.getDogs().indexOf(dog1));
     }
 
-    // Test move where oldPosition < newPosition
+    // Tests move where oldPosition < newPosition.
     @Test
     public void move_up() {
         Owner owner = realm.where(Owner.class).findFirst();
@@ -279,7 +279,7 @@ public void move_up() {
         assertEquals(newIndex, owner.getDogs().indexOf(dog));
     }
 
-    // Test move where oldPosition > newPosition
+    // Tests move where oldPosition > newPosition.
     @Test
     public void move_downInUnmanagedMode() {
         RealmList<Dog> dogs = createUnmanagedDogList();
@@ -289,7 +289,7 @@ public void move_downInUnmanagedMode() {
         assertEquals(0, dogs.indexOf(dog1));
     }
 
-    // Test move where oldPosition < newPosition
+    // Tests move where oldPosition < newPosition.
     @Test
     public void move_upInUnmanagedMode() {
         RealmList<Dog> dogs = createUnmanagedDogList();
@@ -371,7 +371,7 @@ public void add_managedObjectToManagedList() {
         assertEquals(1, realm.where(Owner.class).findFirst().getDogs().size());
     }
 
-    // Test that add correctly uses Realm.copyToRealm() on unmanaged objects.
+    // Tests that add correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
     public void add_unmanagedObjectToManagedList() {
         realm.beginTransaction();
@@ -382,7 +382,7 @@ public void add_unmanagedObjectToManagedList() {
         assertEquals(1, realm.where(CyclicType.class).findFirst().getObjects().size());
     }
 
-    // Make sure that unmanaged objects with a primary key are added using copyToRealmOrUpdate
+    // Makes sure that unmanaged objects with a primary key are added using copyToRealmOrUpdate.
     @Test
     public void add_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
@@ -395,7 +395,7 @@ public void add_unmanagedPrimaryKeyObjectToManagedList() {
         assertEquals("new", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
     }
 
-    // Test that set correctly uses Realm.copyToRealm() on unmanaged objects.
+    // Tests that set correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
     public void set_unmanagedObjectToManagedList() {
         realm.beginTransaction();
@@ -413,7 +413,7 @@ public void set_unmanagedObjectToManagedList() {
         assertEquals(5, realm.where(CyclicType.class).count());
     }
 
-    // Test that set correctly uses Realm.copyToRealmOrUpdate() on unmanaged objects with a primary key.
+    // Tests that set correctly uses Realm.copyToRealmOrUpdate() on unmanaged objects with a primary key.
     @Test
     public void set_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
@@ -723,8 +723,8 @@ public void realmMethods_onDeletedLinkView() {
                     case MIN_DATE: results.minDate(CyclicType.FIELD_DATE); break;
                     case MAX_DATE: results.maxDate(CyclicType.FIELD_DATE); break;
                     case DELETE_ALL_FROM_REALM: results.deleteAllFromRealm(); break;
-                    case IS_VALID: continue; // Does not throw
-                    case IS_MANAGED: continue; // Does not throw
+                    case IS_VALID: continue; // Does not throw.
+                    case IS_MANAGED: continue; // Does not throw.
                 }
                 fail(method + " should have thrown an Exception.");
             } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index cb26f70fb5..6789108cd1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -49,9 +49,11 @@
 import io.realm.entities.StringOnly;
 import io.realm.entities.Thread;
 import io.realm.entities.migration.MigrationClassRenamed;
+import io.realm.entities.migration.MigrationFieldRenameAndAdd;
 import io.realm.entities.migration.MigrationFieldRenamed;
 import io.realm.entities.migration.MigrationFieldTypeToInt;
 import io.realm.entities.migration.MigrationFieldTypeToInteger;
+import io.realm.entities.migration.MigrationIndexedFieldRenamed;
 import io.realm.entities.migration.MigrationPosteriorIndexOnly;
 import io.realm.entities.migration.MigrationPriorIndexOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -97,10 +99,10 @@ public void getInstance_realmClosedAfterMigrationException() throws IOException
             Realm.getInstance(realmConfig);
             fail("A migration should be triggered");
         } catch (RealmMigrationNeededException expected) {
-            Realm.deleteRealm(realmConfig); // Delete old realm
+            Realm.deleteRealm(realmConfig); // Deletes old realm.
         }
 
-        // This should recreate the Realm with proper schema
+        // This should recreate the Realm with proper schema.
         Realm realm = Realm.getInstance(realmConfig);
         int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
         assertEquals(0, result);
@@ -114,7 +116,7 @@ public void localColumnIndices() throws IOException {
         String MIGRATED_REALM = "migrated.realm";
         String NEW_REALM = "new.realm";
 
-        // Migrate old Realm to proper schema
+        // Migrates old Realm to proper schema.
 
         // V1 config
         RealmConfiguration v1Config = configFactory.createConfigurationBuilder()
@@ -144,8 +146,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .build();
         oldRealm = Realm.getInstance(v2Config);
 
-        // Create new Realm which will cause column indices to be recalculated based on the order in the java file
-        // instead of the migration
+        // Creates new Realm which will cause column indices to be recalculated based on the order in the java file
+        // instead of the migration.
         RealmConfiguration newConfig = configFactory.createConfigurationBuilder()
                 .name(NEW_REALM)
                 .schemaVersion(2)
@@ -154,7 +156,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm newRealm = Realm.getInstance(newConfig);
         newRealm.close();
 
-        // Try to query migrated realm. With local column indices this will work. With global it will fail.
+        // Tries to query migrated realm. With local column indices this will work. With global it will fail.
         assertEquals(0, oldRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
         oldRealm.close();
     }
@@ -162,20 +164,20 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void notSettingIndexThrows() {
 
-        // Create v0 of the Realm
+        // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
                 .schema(AllTypes.class)
                 .build();
         Realm.getInstance(originalConfig).close();
 
-        // Create v1 of the Realm
+        // Creates v1 of the Realm.
         RealmMigration migration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 RealmSchema schema = realm.getSchema();
                 schema.create("AnnotationTypes")
                         .addField("id", long.class, FieldAttribute.PRIMARY_KEY)
-                        .addField("indexString", String.class) // Forget to set @Index
+                        .addField("indexString", String.class) // Forgets to set @Index.
                         .addField("notIndexString", String.class);
             }
         };
@@ -199,7 +201,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void addingPrimaryKeyThrows() {
 
-        // Create v0 of the Realm
+        // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
                 .schema(Thread.class)
                 .build();
@@ -210,13 +212,13 @@ public void addingPrimaryKeyThrows() {
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 RealmSchema schema = realm.getSchema();
                 schema.create("AnnotationTypes")
-                        .addField("id", long.class) // Forget to set @PrimaryKey
+                        .addField("id", long.class) // Forgets to set @PrimaryKey.
                         .addField("indexString", String.class, FieldAttribute.INDEXED)
                         .addField("notIndexString", String.class);
             }
         };
 
-        // Create v1 of the Realm
+        // Creates v1 of the Realm.
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
                 .schema(Thread.class, AnnotationTypes.class)
@@ -239,7 +241,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void removingPrimaryKeyThrows() {
 
-        // Create v0 of the Realm
+        // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
                 .schema(Thread.class)
                 .build();
@@ -254,7 +256,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             }
         };
 
-        // Create v1 of the Realm
+        // Creates v1 of the Realm.
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
                 .schema(Thread.class, StringOnly.class)
@@ -277,7 +279,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void changingPrimaryKeyThrows() {
 
-        // Create v0 of the Realm
+        // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
                 .schema(Thread.class)
                 .build();
@@ -288,12 +290,12 @@ public void changingPrimaryKeyThrows() {
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 RealmSchema schema = realm.getSchema();
                 schema.create("PrimaryKeyAsString")
-                        .addField("id", long.class, FieldAttribute.PRIMARY_KEY) // initial @PrimaryKey is on the int
+                        .addField("id", long.class, FieldAttribute.PRIMARY_KEY) // Initial @PrimaryKey is on the int.
                         .addField("name", String.class);
             }
         };
 
-        // Create v1 of the Realm
+        // Creates v1 of the Realm.
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
                 .schema(Thread.class, PrimaryKeyAsString.class)
@@ -328,9 +330,9 @@ private void buildInitialMigrationSchema(final String className, final boolean c
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                // first, remove an existing schema
+                // First, removes an existing schema.
                 realm.getSchema().remove(className);
-                // then recreate the deleted schema or build a base schema
+                // Then recreates the deleted schema or builds a base schema.
                 realm.getSchema()
                         .create(createBase ? MigrationPrimaryKey.CLASS_NAME : className)
                         .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
@@ -343,7 +345,7 @@ public void execute(Realm realm) {
         realm.close();
     }
 
-    // Test to show renaming a class does not hinder its PK field's attribute
+    // Tests to show renaming a class does not hinder its PK field's attribute.
     @Test
     public void renameClassTransferPrimaryKey() {
         buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
@@ -367,7 +369,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
         assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
         assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
-        //old schema does not exist
+        // Old schema does not exist.
         assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
     }
 
@@ -382,7 +384,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm.getSchema()
                         .rename(MigrationPrimaryKey.CLASS_NAME, MigrationClassRenamed.CLASS_NAME);
 
-                // Then recreate the original schema to see if Realm is going to get confused.
+                // Then recreates the original schema to see if Realm is going to get confused.
                 // Unlike the first time with buildInitialMigrationSchema(), we will not have a primary key.
                 realm.getSchema()
                         .create(MigrationPrimaryKey.CLASS_NAME)
@@ -404,7 +406,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
     }
 
-    // Test to show that renaming a class does not effect the primary key
+    // Test to show that renaming a class does not effect the primary key.
     @Test
     public void setClassName_transferPrimaryKey() {
         buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
@@ -429,7 +431,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
         assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
         assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
-        //old schema does not exist
+        // Old schema does not exist.
         assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
     }
 
@@ -440,12 +442,12 @@ public void setClassName_noSimilarPrimaryKeyWithOldSchema() {
         RealmMigration migration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                // Let us set a new class name
+                // Let us set a new class name.
                 realm.getSchema()
                         .get(MigrationPrimaryKey.CLASS_NAME)
                         .setClassName(MigrationClassRenamed.CLASS_NAME);
 
-                // Then recreate the original schema to see if Realm is going to get confused.
+                // Then recreates the original schema to see if Realm is going to get confused.
                 // Unlike the first time with buildInitialMigrationSchema(), we will not have a primary key.
                 realm.getSchema()
                         .create(MigrationPrimaryKey.CLASS_NAME)
@@ -469,7 +471,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
 
     @Test
     public void setClassName_throwOnLongClassName() {
-        // create the first version of schema
+        // Creates the first version of schema.
         Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
         realm.executeTransaction(new Realm.Transaction() {
             @Override
@@ -479,14 +481,14 @@ public void execute(Realm realm) {
         });
         realm.close();
 
-        // get ready for the 2nd version migration
+        // Gets ready for the 2nd version migration.
         RealmMigration migration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm.getSchema()
                         .get(MigrationPrimaryKey.CLASS_NAME)
                         // 57 characters
-                        .setClassName("MigrationNameIsLongerThan56charThisShouldThrowAnException");
+                        .setClassName("MigrationNameIsLongerThan56CharThisShouldThrowAnException");
             }
         };
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
@@ -494,17 +496,17 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .migration(migration)
                 .build();
 
-        // create Realm instance fails
+        // Creating Realm instance fails.
         try {
             Realm.getInstance(realmConfig);
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals("Class name is to long. Limit is 56 characters: 'MigrationNameIsLongerThan56charThisShouldThrowAnException' (57)",
+            assertEquals("Class name is too long. Limit is 56 characters: 'MigrationNameIsLongerThan56CharThisShouldThrowAnException' (57)",
                     expected.getMessage());
         }
     }
 
-    // Removing fields before a pk field does not affect the pk
+    // Removing fields before a pk field does not affect the pk.
     @Test
     public void removeFieldsBeforePrimaryKey() {
         buildInitialMigrationSchema(MigrationPosteriorIndexOnly.CLASS_NAME, false);
@@ -531,7 +533,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertEquals(MigrationPosteriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
     }
 
-    // Removing fields after a pk field does not affect the pk
+    // Removing fields after a pk field does not affect the pk.
     @Test
     public void removeFieldsAfterPrimaryKey() {
         buildInitialMigrationSchema(MigrationPriorIndexOnly.CLASS_NAME, false);
@@ -558,7 +560,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertEquals(MigrationPriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
     }
 
-    // Renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys
+    // Renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys.
     @Test
     public void renamePrimaryKeyFieldInMigration() {
         buildInitialMigrationSchema(MigrationFieldRenamed.CLASS_NAME, false);
@@ -604,7 +606,7 @@ public void execute(DynamicRealm realm) {
         }
     }
 
-    // This is to test how PK type can change to non-nullable int in migration
+    // This is to test how PK type can change to non-nullable int in migration.
     @Test
     public void modifyPrimaryKeyFieldTypeToIntInMigration() {
         final String TEMP_FIELD_ID = "temp_id";
@@ -655,12 +657,12 @@ public void apply(DynamicRealmObject obj) {
         assertEquals(12, realm.where(MigrationFieldTypeToInt.class).findFirst().fieldIntPrimary);
     }
 
-    // This is to test how PK type can change to nullable Integer in migration
+    // This is to test how PK type can change to nullable Integer in migration.
     @Test
     public void modifyPrimaryKeyFieldTypeToIntegerInMigration() {
         final String TEMP_FIELD_ID = "temp_id";
         buildInitialMigrationSchema(MigrationFieldTypeToInteger.CLASS_NAME, false);
-        // create objects with the schema provided
+        // Creates objects with the schema provided.
         createObjectsWithOldPrimaryKey(MigrationFieldTypeToInteger.CLASS_NAME, true);
 
         RealmMigration migration = new RealmMigration() {
@@ -714,7 +716,7 @@ public void apply(DynamicRealmObject obj) {
 
     @Test
     public void settingPrimaryKeyWithObjectSchema() {
-        // Create v0 of the Realm
+        // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
                 .schema(AllTypes.class)
                 .build();
@@ -726,14 +728,14 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 RealmSchema schema = realm.getSchema();
                 schema.create("AnnotationTypes")
                         .addField("id", long.class)
-                        .addPrimaryKey("id")    // use addPrimaryKey() instead of adding FieldAttribute.PrimaryKey
+                        .addPrimaryKey("id")    // Uses addPrimaryKey() instead of adding FieldAttribute.PrimaryKey.
                         .addField("indexString", String.class)
-                        .addIndex("indexString") // use addIndex() instead of FieldAttribute.Index
+                        .addIndex("indexString") // Uses addIndex() instead of FieldAttribute.Index.
                         .addField("notIndexString", String.class);
             }
         };
 
-        // Create v1 of the Realm
+        // Creates v1 of the Realm.
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
                 .schema(AllTypes.class, AnnotationTypes.class)
@@ -747,7 +749,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         realm.close();
     }
 
-    // adding search index is idempotent
+    // Adding search index is idempotent.
     @Test
     public void addingSearchIndexTwice() throws IOException {
         final Class[] classes = {PrimaryKeyAsLong.class, PrimaryKeyAsString.class};
@@ -785,7 +787,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void setAnnotations() {
 
-        // Create v0 of the Realm
+        // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
                 .schema(AllTypes.class)
                 .build();
@@ -851,7 +853,7 @@ public void openPreNullRealmRequiredMissing() throws IOException {
         RealmMigration realmMigration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                // intentionally left empty
+                // Intentionally lefts empty.
             }
         };
 
@@ -923,7 +925,7 @@ public void openPreNullWithRequired() throws IOException {
         realm.close();
     }
 
-    // If a required field was nullable before, a RealmMigrationNeededException should be thrown
+    // If a required field was nullable before, a RealmMigrationNeededException should be thrown.
     @Test
     public void notSettingRequiredForNotNullableThrows() {
         String[] notNullableFields = {NullTypes.FIELD_STRING_NOT_NULL, NullTypes.FIELD_BYTES_NOT_NULL,
@@ -975,7 +977,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                     .migration(migration)
                     .build();
             Realm.deleteRealm(realmConfig);
-            // Prepare the version 0 db
+            // Prepares the version 0 db.
             DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
             TestHelper.initNullTypesTableExcludes(dynamicRealm, field);
             dynamicRealm.close();
@@ -992,7 +994,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
-    // If a field is not required but was not nullable before, a RealmMigrationNeededException should be thrown
+    // If a field is not required but was not nullable before, a RealmMigrationNeededException should be thrown.
     @Test
     public void settingRequiredForNullableThrows() {
         String[] notNullableFields = {NullTypes.FIELD_STRING_NULL, NullTypes.FIELD_BYTES_NULL,
@@ -1043,7 +1045,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                     .migration(migration)
                     .build();
             Realm.deleteRealm(realmConfig);
-            // Prepare the version 0 db
+            // Prepares the version 0 db.
             DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
             TestHelper.initNullTypesTableExcludes(dynamicRealm, field);
             dynamicRealm.close();
@@ -1066,7 +1068,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
-    // Testing older Realms for setting Boxed type primary keys fields nullable in migration process to support Realm Version 0.89+
+    // Tests older Realms for setting Boxed type primary keys fields nullable in migration process to support Realm Version 0.89+.
     @Test
     public void settingNullableToPrimaryKey() throws IOException {
         final long SCHEMA_VERSION = 67;
@@ -1106,7 +1108,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
-    // Not-setting older boxed type PrimaryKey field nullable to see if migration fails in order to support Realm version 0.89+
+    // Not-setting older boxed type PrimaryKey field nullable to see if migration fails in order to support Realm version 0.89+.
     @Test
     public void notSettingNullableToPrimaryKeyThrows() throws IOException {
         configFactory.copyRealmFromAssets(context, "default-notnullable-primarykey.realm", Realm.DEFAULT_REALM_NAME);
@@ -1119,7 +1121,7 @@ public void notSettingNullableToPrimaryKeyThrows() throws IOException {
                         .migration(new RealmMigration() {
                             @Override
                             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                                // intentionally left empty to preserve not-nullablility of PrimaryKey on old schema.
+                                // Intentionally lefts empty to preserve not-nullablility of PrimaryKey on old schema.
                             }
                         })
                         .build();
@@ -1138,7 +1140,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
-    // Migrate a nullable field containing null value to non-nullable PrimaryKey field throws Realm version 0.89+
+    // Migrates a nullable field containing null value to non-nullable PrimaryKey field throws Realm version 0.89+.
     @Test
     public void migrating_nullableField_toward_notNullable_PrimaryKeyThrows() throws IOException {
         configFactory.copyRealmFromAssets(context, "default-nullable-primarykey.realm", Realm.DEFAULT_REALM_NAME);
@@ -1151,7 +1153,7 @@ public void migrating_nullableField_toward_notNullable_PrimaryKeyThrows() throws
                         .migration(new RealmMigration() {
                             @Override
                             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                                // intentionally left empty to demonstrate incompatibilities between nullable/not-nullable PrimaryKeys.
+                                // intentionally lefts empty to demonstrate incompatibilities between nullable/not-nullable PrimaryKeys.
                             }
                         })
                         .build();
@@ -1171,12 +1173,12 @@ public void realmOpenBeforeMigrationThrows() throws FileNotFoundException {
         realm = Realm.getInstance(config);
 
         try {
-            // Trigger manual migration. This can potentially change the schema, so should only be allowed when
+            // Triggers manual migration. This can potentially change the schema, so should only be allowed when
             // no-one else is working on the Realm.
             Realm.migrateRealm(config, new RealmMigration() {
                 @Override
                 public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                    // Do nothing
+                    // Does nothing.
                 }
             });
             fail();
@@ -1209,6 +1211,75 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm.migrateRealm(config, migration);
     }
 
+    @Test
+    public void renameAndAddField() {
+        final Class<MigrationFieldRenameAndAdd> schemaClass = MigrationFieldRenameAndAdd.class;
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(schemaClass.getSimpleName())
+                        .renameField("string1", "string2")
+                        .addField("string1", String.class);
+            }
+        };
+
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .schema(schemaClass)
+                .schemaVersion(2)
+                .migration(migration)
+                .assetFile("rename-and-add.realm")
+                .build();
+        Realm realm = Realm.getInstance(config);
+
+        RealmObjectSchema schema = realm.getSchema().get(schemaClass.getSimpleName());
+        assertTrue(schema.hasField("string1"));
+        assertTrue(schema.hasField("string2"));
+        realm.close();
+    }
+
+    @Test
+    public void renameAndAddIndexedField() {
+        final Class<MigrationIndexedFieldRenamed> schemaClass = MigrationIndexedFieldRenamed.class;
+        final int oldTestVal = 7;
+        final Long testVal = Long.valueOf(293);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(schemaClass.getSimpleName())
+                        .renameField("testField", "oldTestField")
+                        .addField("testField", Long.class);
+            }
+        };
+
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .schema(schemaClass)
+                .schemaVersion(2)
+                .migration(migration)
+                .assetFile("rename-and-add-indexed.realm")
+                .build();
+        realm = Realm.getInstance(config);
+
+        realm.beginTransaction();
+        MigrationIndexedFieldRenamed obj = realm.createObject(schemaClass, 2);
+        obj.oldTestField = oldTestVal;
+        obj.testField = testVal;
+        realm.commitTransaction();
+
+        RealmObjectSchema schema = realm.getSchema().get(schemaClass.getSimpleName());
+        assertTrue(schema.hasField("testField"));
+        assertTrue(schema.hasField("oldTestField"));
+        assertTrue(schema.hasIndex("oldTestField"));
+
+        RealmResults<MigrationIndexedFieldRenamed> result = realm.where(schemaClass).equalTo("id", 2).findAll();
+        assertEquals("There should be an object with PK=2", 1, result.size());
+        assertEquals("Unexpected oldTestField value", oldTestVal, result.first().oldTestField);
+        assertEquals("Unexpected testField value", testVal, result.first().testField);
+
+        realm.close();
+    }
+
     // TODO Add unit tests for default nullability
     // TODO Add unit tests for default Indexing for Primary keys
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 95f063b2f2..8447b2ce2e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -51,7 +51,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeThat;
 
-// tests API methods when using a model class implementing RealmModel instead
+// Tests API methods when using a model class implementing RealmModel instead
 // of extending RealmObject.
 @RunWith(AndroidJUnit4.class)
 public class RealmModelTests {
@@ -102,8 +102,8 @@ private void populateTestRealm(Realm realm, int objects) {
 
     @Test
     public void createObject() {
-        for (int i = 1; i < 43; i++) { // using i = 0 as PK will crash subsequent createObject
-                                       // since createObject uses default values
+        for (int i = 1; i < 43; i++) { // Using i = 0 as PK will crash subsequent createObject
+                                       // since createObject uses default values.
             realm.beginTransaction();
             realm.createObject(AllTypesRealmModel.class, i);
             realm.commitTransaction();
@@ -183,7 +183,7 @@ public void createOrUpdateAllFromJson() throws IOException {
         assertEquals("Dog5", obj.columnRealmList.get(0).getName());
     }
 
-    // where with filed selection
+    // 'where' with filed selection.
     @Test
     public void query() {
         populateTestRealm(realm, TEST_DATA_SIZE);
@@ -191,7 +191,7 @@ public void query() {
         assertEquals(5, realm.where(AllTypesRealmModel.class).greaterThanOrEqualTo(AllTypesRealmModel.FIELD_DOUBLE, 8.1415).count());
     }
 
-    // async where with filed selection
+    // Async where with filed selection.
     @Test
     @RunTestInLooperThread
     public void async_query() {
@@ -258,9 +258,9 @@ public void dynamicRealm() {
         looperThread.testComplete();
     }
 
-    // exception expected when using in schema model not annotated
-    // a valid model need to implement the interface RealmModel and annotate the class with @RealmClass
-    // we expect in this test a runtime exception 'InvalidRealmModel is not part of the schema for this Realm.'
+    // Exception expected when using in schema model not annotated.
+    // A valid model need to implement the interface RealmModel and annotate the class with @RealmClass.
+    // We expect in this test a runtime exception 'InvalidRealmModel is not part of the schema for this Realm.'.
     @Test(expected = RealmException.class)
     public void invalidModelDefinition() {
         realm.beginTransaction();
@@ -268,8 +268,8 @@ public void invalidModelDefinition() {
         realm.commitTransaction();
     }
 
-    // Test the behaviour of a RealmModel, containing a RealmList
-    // of other RealmModel, in managed and unmanaged mode
+    // Tests the behaviour of a RealmModel, containing a RealmList
+    // of other RealmModel, in managed and unmanaged mode.
     @Test
     public void realmModelWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModels = new RealmList<AllTypesRealmModel>();
@@ -297,8 +297,8 @@ public void realmModelWithRealmListOfRealmModel() {
         assertEquals(1, all.first().getColumnRealmList().first().columnLong);
     }
 
-    // Test the behaviour of a RealmModel, containing a RealmList
-    // of RealmObject, in managed and unmanaged mode
+    // Tests the behaviour of a RealmModel, containing a RealmList
+    // of RealmObject, in managed and unmanaged mode.
     @Test
     public void realmModelWithRealmListOfRealmObject() {
         RealmList<AllTypes> allTypes = new RealmList<AllTypes>();
@@ -326,8 +326,8 @@ public void realmModelWithRealmListOfRealmObject() {
         assertEquals(1, all.first().getColumnRealmList().first().getColumnLong());
     }
 
-    // Test the behaviour of a RealmObject, containing a RealmList
-    // of RealmModel, in managed and unmanaged mode
+    // Tests the behaviour of a RealmObject, containing a RealmList
+    // of RealmModel, in managed and unmanaged mode.
     @Test
     public void realmObjectWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModel = new RealmList<AllTypesRealmModel>();
@@ -355,7 +355,7 @@ public void realmObjectWithRealmListOfRealmModel() {
         assertEquals(1, all.first().getColumnRealmList().first().columnLong);
     }
 
-    // Test the behaviour of a RealmModel, containing a RealmModel field
+    // Tests the behaviour of a RealmModel, containing a RealmModel field.
     @Test
     public void realmModelWithRealmModelField() {
         RealmModelWithRealmModelField realmModelWithRealmModelField = new RealmModelWithRealmModelField();
@@ -372,7 +372,7 @@ public void realmModelWithRealmModelField() {
         assertEquals(42, all.first().getAllTypesRealmModel().columnLong);
     }
 
-    // Test the behaviour of a RealmObject, containing a RealmModel field
+    // Tests the behaviour of a RealmObject, containing a RealmModel field.
     @Test
     public void realmObjectWithRealmModelField() {
         RealmObjectWithRealmModelField realmObjectWithRealmModelField = new RealmObjectWithRealmModelField();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
index 91f85404b5..dc37e6c8ad 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
@@ -98,7 +98,7 @@ private RealmObject addPrimaryKeyObjectToTestRealm(Realm testRealm) throws NoSuc
         return obj;
     }
 
-    // create a RealmObject with null primarykey
+    // Creates a RealmObject with null primarykey.
     private void createNullPrimaryKeyObjectFromTestRealm(Realm testRealm) {
         testRealm.beginTransaction();
 
@@ -112,7 +112,7 @@ private void createNullPrimaryKeyObjectFromTestRealm(Realm testRealm) {
         testRealm.commitTransaction();
     }
 
-    // update existing null PrimaryKey object with a new updating value.
+    // Updates existing null PrimaryKey object with a new updating value.
     private void updatePrimaryKeyObject(Realm testRealm, RealmObject realmObject) {
         if (testClazz.equals(PrimaryKeyAsString.class)) {
             ((PrimaryKeyAsString) realmObject).setId((long) updatingFieldValue);
@@ -125,7 +125,7 @@ private void updatePrimaryKeyObject(Realm testRealm, RealmObject realmObject) {
         testRealm.commitTransaction();
     }
 
-    // @PrimaryKey annotation accept null value properly as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey annotation accept null value properly as a primary key value for Realm version 0.89.1+.
     @Test
     public void copyToRealm_primaryKeyIsNull() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
         addPrimaryKeyObjectToTestRealm(realm);
@@ -144,7 +144,7 @@ public void copyToRealm_primaryKeyIsNull() throws NoSuchMethodException, Instant
         }
     }
 
-    // @PrimaryKey annotation accept & update null value properly as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey annotation accept & update null value properly as a primary key value for Realm version 0.89.1+.
     @Test
     public void copyToRealmOrUpdate_primaryKeyFieldIsNull() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
         RealmObject obj = addPrimaryKeyObjectToTestRealm(realm);
@@ -163,7 +163,7 @@ public void copyToRealmOrUpdate_primaryKeyFieldIsNull() throws NoSuchMethodExcep
 
         }
 
-        // commit to the Realm
+        // Commits to the Realm.
         updatePrimaryKeyObject(realm, obj);
 
         if (testClazz.equals(PrimaryKeyAsString.class)) {
@@ -173,7 +173,7 @@ public void copyToRealmOrUpdate_primaryKeyFieldIsNull() throws NoSuchMethodExcep
         }
     }
 
-    // @PrimaryKey annotation creates null value properly as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey annotation creates null value properly as a primary key value for Realm version 0.89.1+.
     @Test
     public void createObject_primaryKeyFieldIsNull() {
         createNullPrimaryKeyObjectFromTestRealm(realm);
@@ -192,7 +192,7 @@ public void createObject_primaryKeyFieldIsNull() {
         }
     }
 
-    // @PrimaryKey annotation checked duplicated null value properly as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey annotation checked duplicated null value properly as a primary key value for Realm version 0.89.1+.
     @Test
     public void createObject_duplicatedNullPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
         addPrimaryKeyObjectToTestRealm(realm);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index efd306014f..a29dbee7d4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -53,7 +53,7 @@
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
-        Realm.getInstance(realmConfig).close(); // Create Schema
+        Realm.getInstance(realmConfig).close(); // Creates Schema.
         realm = DynamicRealm.getInstance(realmConfig);
         realmSchema = realm.getSchema();
         DOG_SCHEMA = realmSchema.get("Dog");
@@ -200,7 +200,7 @@ public void addRemoveField() {
         }
     }
 
-    // Check that field is actually added and that it can be removed again.
+    // Checks that field is actually added and that it can be removed again.
     private void checkAddedAndRemovable(String fieldName) {
         assertTrue(schema.hasField(fieldName));
         schema.removeField(fieldName);
@@ -276,8 +276,8 @@ public void requiredFieldAttribute() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
             switch (fieldType) {
-                case OBJECT: continue; // Not possible
-                case LIST: continue; // Not possible
+                case OBJECT: continue; // Not possible.
+                case LIST: continue; // Not possible.
                 default:
                     // All simple types
                     schema.addField(fieldName, fieldType.getType(), FieldAttribute.REQUIRED);
@@ -387,7 +387,7 @@ public void addPrimaryKeyFieldModifier_duplicateValues() {
             final String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
 
-            // create multiple objects with same values.
+            // Creates multiple objects with same values.
             realm.createObject(schema.getClassName());
             realm.createObject(schema.getClassName());
 
@@ -395,7 +395,7 @@ public void addPrimaryKeyFieldModifier_duplicateValues() {
                 schema.addPrimaryKey(fieldName);
                 fail();
             } catch (IllegalArgumentException e) {
-                // check if message reports correct field name.
+                // Checks if message reports correct field name.
                 assertTrue(e.getMessage().contains("\"" + fieldName + "\""));
             }
             schema.removeField(fieldName);
@@ -461,7 +461,7 @@ public void setRemoveNullable() {
                     }
                     break;
                 default:
-                    // All simple types
+                    // All simple types.
                     schema.addField(fieldName, fieldType.getType());
                     assertEquals(fieldType.isNullable(), schema.isNullable(fieldName));
                     schema.setNullable(fieldName, !fieldType.isNullable());
@@ -497,7 +497,7 @@ public void setRemoveRequired() {
                     }
                     break;
                 default:
-                    // All simple types
+                    // All simple types.
                     schema.addField(fieldName, fieldType.getType());
                     assertEquals(!fieldType.isNullable(), schema.isRequired(fieldName));
                     schema.setRequired(fieldName, fieldType.isNullable());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 0224d6496c..c8d3a4025f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -140,8 +140,8 @@ public void stringEncoding() {
         }
     }
 
-    // invalid surrogate pairs:
-    // both high and low should lead to an IllegalArgumentException
+    // Invalid surrogate pairs:
+    // Both high and low should lead to an IllegalArgumentException.
     @Test
     public void invalidSurrogates() {
         String high = "Invalid high surrogate \uD83C\uD83C\uDF51";
@@ -168,7 +168,7 @@ public void invalidSurrogates() {
         realm.cancelTransaction();
     }
 
-    // removing original object and see if has been removed
+    // Removes original object and sees if has been removed.
     @Test
     public void deleteFromRealm() {
         realm.beginTransaction();
@@ -195,7 +195,7 @@ public void deleteFromRealm() {
             fail();
         } catch (IllegalStateException ignored) {}
 
-        // deleting rex twice should fail
+        // Deleting rex twice should fail.
         realm.beginTransaction();
         try {
             rex.deleteFromRealm();
@@ -236,7 +236,7 @@ public void deleteFromRealm_throwOnUnmanagedObject() {
         }
     }
 
-    // query for an object, remove it and see it has been removed from realm
+    // Queries for an object, removes it and sees it has been removed from realm.
     @Test
     public void deleteFromRealm_removedFromResults() {
         realm.beginTransaction();
@@ -270,7 +270,7 @@ public void deleteFromRealm_removedFromResults() {
     }
 
     private void removeOneByOne(boolean removeFromFront) {
-        // Create test data
+        // Creates test data.
         realm.beginTransaction();
         realm.delete(Dog.class);
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -278,11 +278,11 @@ private void removeOneByOne(boolean removeFromFront) {
         }
         realm.commitTransaction();
 
-        // Check initial size
+        // Checks initial size.
         RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
         assertEquals(TEST_SIZE, dogs.size());
 
-        // Check that calling deleteFromRealm doesn't remove the object from the RealmResult
+        // Checks that calling deleteFromRealm doesn't remove the object from the RealmResult.
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
             dogs.get(removeFromFront ? i : TEST_SIZE - 1 - i).deleteFromRealm();
@@ -293,7 +293,7 @@ private void removeOneByOne(boolean removeFromFront) {
         assertEquals(0, realm.where(Dog.class).count());
     }
 
-    // Tests calling deleteFromRealm on a RealmResults instead of RealmResults.remove()
+    // Tests calling deleteFromRealm on a RealmResults instead of RealmResults.remove().
     @Test
     public void deleteFromRealm_atPosition() {
         removeOneByOne(REMOVE_FIRST);
@@ -425,23 +425,6 @@ public void equals_plainCustomMethod() {
         assertTrue(cm1.equals(cm2));
     }
 
-    @Test
-    public void equals_reverseCustomMethod() {
-        realm.beginTransaction();
-        CustomMethods cm = realm.createObject(CustomMethods.class);
-        cm.setName("Foo");
-        realm.commitTransaction();
-
-        CustomMethods cm1 = realm.where(CustomMethods.class).findFirst();
-        CustomMethods cm2 = realm.where(CustomMethods.class).findFirst();
-
-        realm.beginTransaction();
-        cm1.reverseEquals = true;
-        realm.commitTransaction();
-
-        assertFalse(cm1.equals(cm2));
-    }
-
     @Test
     public void equals_unmanagedCustomMethod() {
         CustomMethods cm1 = new CustomMethods();
@@ -464,8 +447,8 @@ public void equals_mixedCustomMethod() {
         realm.commitTransaction();
 
         CustomMethods cm3 = realm.where(CustomMethods.class).findFirst();
-        assertFalse(cm3.equals(cm2));
-        assertTrue(cm3.getName().equals(cm2.getName()));
+        assertTrue(cm3.equals(cm2));
+        assertTrue(cm2.equals(cm3));
     }
 
     @Test
@@ -493,11 +476,11 @@ public void hashCode_cyclicObject() {
         final CyclicType foo = createCyclicData();
         realm.commitTransaction();
 
-        // Check that the hash code is always the same between multiple calls.
+        // Checks that the hash code is always the same between multiple calls.
         assertEquals(foo.hashCode(), foo.hashCode());
-        // Check that the hash code is the same among same object
+        // Checks that the hash code is the same among same object.
         assertEquals(foo.hashCode(), realm.where(CyclicType.class).equalTo("name", foo.getName()).findFirst().hashCode());
-        // hash code is different from other objects.
+        // Hash code is different from other objects.
         assertNotEquals(foo.getObject().hashCode(), foo.hashCode());
 
         final int originalHashCode = foo.hashCode();
@@ -507,10 +490,10 @@ public void execute(Realm realm) {
                 foo.setName(foo.getName() + "1234");
             }
         });
-        // Check that Updating the value of its field does not affect the hash code.
+        // Checks that Updating the value of its field does not affect the hash code.
         assertEquals(originalHashCode, foo.hashCode());
 
-        // Check the hash code of the object from a Realm in different file name.
+        // Checks the hash code of the object from a Realm in different file name.
         RealmConfiguration realmConfig_differentName = configFactory.createConfiguration(
                 "another_" + realmConfig.getRealmFileName());
         Realm realm_differentName = Realm.getInstance(realmConfig_differentName);
@@ -525,7 +508,7 @@ public void execute(Realm realm) {
             realm_differentName.close();
         }
 
-        // Check the hash code of the object from a Realm in different directory.
+        // Checks the hash code of the object from a Realm in different directory.
         RealmConfiguration realmConfig_differentPath = configFactory.createConfiguration(
                 "anotherDir", realmConfig.getRealmFileName());
         Realm realm_differentPath = Realm.getInstance(realmConfig_differentPath);
@@ -556,7 +539,7 @@ private CyclicType createCyclicData(Realm realm) {
         CyclicType bar = realm.createObject(CyclicType.class);
         bar.setName("Bar");
 
-        // Setup cycle on normal object references
+        // Setups cycle on normal object references.
         foo.setObject(bar);
         bar.setObject(foo);
         return foo;
@@ -725,7 +708,7 @@ public void setter_link_objectFromAnotherThread() throws InterruptedException {
             public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
 
-                // 1. create an object
+                // 1. Creates an object.
                 realm.beginTransaction();
                 objFromAnotherThread.set(realm.createObject(CyclicType.class));
                 realm.commitTransaction();
@@ -736,14 +719,14 @@ public void run() {
                 } catch (InterruptedException ignored) {
                 }
 
-                // 3. close Realm in this thread and finish.
+                // 3. Closes Realm in this thread and finishes.
                 realm.close();
             }
         };
         thread.start();
 
         createLatch.await();
-        // 2. set created object to target
+        // 2. Sets created object to target.
         realm.beginTransaction();
         try {
             CyclicType target = realm.createObject(CyclicType.class);
@@ -757,7 +740,7 @@ public void run() {
             realm.cancelTransaction();
         }
 
-        // wait for finishing the thread
+        // Waits for finishing the thread.
         thread.join();
     }
 
@@ -795,7 +778,7 @@ public void setter_list_withDeletedObject() {
 
             RealmList<CyclicType> list = new RealmList<>();
             list.add(realm.createObject(CyclicType.class));
-            list.add(removed); // List contains a deleted object
+            list.add(removed); // List contains a deleted object.
             list.add(realm.createObject(CyclicType.class));
 
             try {
@@ -823,7 +806,7 @@ public void setter_list_withClosedObject() {
 
             RealmList<CyclicType> list = new RealmList<>();
             list.add(realm.createObject(CyclicType.class));
-            list.add(closed); // List contains a closed object
+            list.add(closed); // List contains a closed object.
             list.add(realm.createObject(CyclicType.class));
 
             try {
@@ -852,7 +835,7 @@ public void setter_list_withObjectFromAnotherRealm() {
 
                 RealmList<CyclicType> list = new RealmList<>();
                 list.add(realm.createObject(CyclicType.class));
-                list.add(objFromAnotherRealm); // List contains an object from another Realm
+                list.add(objFromAnotherRealm); // List contains an object from another Realm.
                 list.add(realm.createObject(CyclicType.class));
 
                 try {
@@ -880,7 +863,7 @@ public void setter_list_withObjectFromAnotherThread() throws InterruptedExceptio
             public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
 
-                // 1. create an object
+                // 1. Creates an object.
                 realm.beginTransaction();
                 objFromAnotherThread.set(realm.createObject(CyclicType.class));
                 realm.commitTransaction();
@@ -891,14 +874,14 @@ public void run() {
                 } catch (InterruptedException ignored) {
                 }
 
-                // 3. close Realm in this thread and finish.
+                // 3. Close Realm in this thread and finishes.
                 realm.close();
             }
         };
         thread.start();
 
         createLatch.await();
-        // 2. set created object to target
+        // 2. Sets created object to target.
         realm.beginTransaction();
         try {
             CyclicType target = realm.createObject(CyclicType.class);
@@ -918,7 +901,7 @@ public void run() {
             realm.cancelTransaction();
         }
 
-        // wait for finishing the thread
+        // Waits for finishing the thread.
         thread.join();
     }
 
@@ -969,7 +952,7 @@ public void isValid_managedObject() {
         assertTrue(allTypes.isValid());
     }
 
-    // store and retrieve null values for nullable fields
+    // Stores and retrieves null values for nullable fields.
     @Test
     public void set_get_nullOnNullableFields() {
         realm.beginTransaction();
@@ -1019,7 +1002,7 @@ public void set_get_nullOnNullableFields() {
         assertNull(nullTypes.getFieldDateNull());
     }
 
-    // store and retrieve non-null values when field can contain null strings
+    // Stores and retrieves non-null values when field can contain null strings.
     @Test
     public void get_set_nonNullValueOnNullableFields() {
         final String testString = "FooBar";
@@ -1072,7 +1055,7 @@ public void get_set_nonNullValueOnNullableFields() {
         assertEquals(testDate.getTime(), nullTypes.getFieldDateNull().getTime());
     }
 
-    // try to store null values in non-nullable fields
+    // Tries to store null values in non-nullable fields.
     @Test
     public void set_nullValuesToNonNullableFields() {
         try {
@@ -1204,7 +1187,7 @@ public void run() {
         TestHelper.awaitOrFail(bgRealmDone);
         realm.waitForChange();
 
-        // Object should no longer be available
+        // Object should no longer be available.
         assertFalse(obj.isValid());
         try {
             obj.getColumnLong();
@@ -1244,7 +1227,7 @@ public void isManaged_unmanagedObject() {
         assertFalse(dog.isManaged());
     }
 
-    // Test NaN value on float and double columns
+    // Tests NaN value on float and double columns.
     @Test
     public void float_double_NaN() {
         realm.beginTransaction();
@@ -1259,7 +1242,7 @@ public void float_double_NaN() {
         assertEquals(0, realm.where(AllTypes.class).equalTo("columnDouble", Double.NaN).count());
     }
 
-    // Test max value on float and double columns
+    // Tests max value on float and double columns.
     @Test
     public void float_double_maxValue() {
         realm.beginTransaction();
@@ -1273,7 +1256,7 @@ public void float_double_maxValue() {
         assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.MAX_VALUE).count());
     }
 
-    // Test min normal value on float and double columns
+    // Tests min normal value on float and double columns.
     @Test
     public void float_double_minNormal() {
         realm.beginTransaction();
@@ -1287,7 +1270,7 @@ public void float_double_minNormal() {
         assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.MIN_NORMAL).count());
     }
 
-    // Test min value on float and double columns
+    // Tests min value on float and double columns.
     @Test
     public void float_double_minValue() {
         realm.beginTransaction();
@@ -1301,7 +1284,7 @@ public void float_double_minValue() {
         assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.MIN_VALUE).count());
     }
 
-    // Test negative infinity value on float and double columns
+    // Tests negative infinity value on float and double columns.
     @Test
     public void float_double_negativeInfinity() {
         realm.beginTransaction();
@@ -1315,7 +1298,7 @@ public void float_double_negativeInfinity() {
         assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.NEGATIVE_INFINITY).count());
     }
 
-    // Test positive infinity value on float and double columns
+    // Tests positive infinity value on float and double columns.
     @Test
     public void float_double_positiveInfinity() {
         realm.beginTransaction();
@@ -1345,7 +1328,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                         }
 
                         final long newStrIndex;
-                        // swap column indices
+                        // Swaps column indices.
                         if (strIndex < numberIndex) {
                             table.addColumn(RealmFieldType.INTEGER, "number");
                             newStrIndex = table.addColumn(RealmFieldType.STRING, "str");
@@ -1363,7 +1346,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .migration(new RealmMigration() {
                     @Override
                     public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                        // Do nothing
+                        // Does nothing.
                     }
                 })
                 .schemaVersion(1L)
@@ -1379,7 +1362,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     public void realmProxy_columnIndex() throws FileNotFoundException {
         final RealmConfiguration configForSwapped = prepareColumnSwappedRealm();
 
-        // open swapped Realm in order to load column index
+        // Opens swapped Realm in order to load column index.
         Realm.getInstance(configForSwapped).close();
 
         realm.executeTransaction(new Realm.Transaction() {
@@ -1413,7 +1396,7 @@ public void execute(Realm realm) {
             }
         });
 
-        // tests those values are persisted
+        // Tests those values are persisted.
         final ConflictingFieldName managed = realm.where(ConflictingFieldName.class).findFirst();
         assertEquals("realm", managed.getRealm());
         assertEquals("row", managed.getRow());
@@ -1422,7 +1405,7 @@ public void execute(Realm realm) {
         assertEquals("pendingQuery", managed.getPendingQuery());
         assertEquals("currentTableVersion", managed.getCurrentTableVersion());
 
-        // tests those values can be updated
+        // Tests those values can be updated.
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -1443,7 +1426,7 @@ public void execute(Realm realm) {
         assertEquals("currentTableVersion_updated", managed.getCurrentTableVersion());
     }
 
-    // Setting a not-nullable field to null is an error
+    // Setting a not-nullable field to null is an error.
     // TODO Move this to RealmObjectTests?
     @Test
     public void setter_nullValueInRequiredField() {
@@ -1523,7 +1506,7 @@ public void setter_nullValueInRequiredField() {
         }
     }
 
-    // Setting a nullable field to null is not an error
+    // Setting a nullable field to null is not an error.
     // TODO Move this to RealmObjectsTest?
     @Test
     public void setter_nullValueInNullableField() {
@@ -1790,7 +1773,7 @@ public void addChangeListener_shouldNotAddDupEntriesToHandlerRealmObjects() {
             assertFalse(ref.get() == allTypesPrimaryKey);
         }
 
-        // Add different listeners twice
+        // Adds different listeners twice.
         allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey element) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
index 155607bbfe..9484310bd4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
@@ -90,7 +90,7 @@ public RealmPrimaryKeyTests(Class<? extends RealmObject> testClazz, Class primar
         this.secondaryFieldValue = secondaryFieldValue;
     }
 
-    // @PrimaryKey + @Required annotation accept not-null value properly as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey + @Required annotation accept not-null value properly as a primary key value for Realm version 0.89.1+.
     @Test
     public void copyToRealmOrUpdate_requiredPrimaryKey() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
         RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(primaryKeyFieldValue, secondaryFieldValue);
@@ -104,7 +104,7 @@ public void copyToRealmOrUpdate_requiredPrimaryKey() throws NoSuchMethodExceptio
         assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
     }
 
-    // @PrimaryKey + @Required annotation does accept null as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey + @Required annotation does accept null as a primary key value for Realm version 0.89.1+.
     @Test
     public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
         RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
@@ -125,7 +125,7 @@ public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodEx
         }
     }
 
-    // @PrimaryKey + @Required annotation does not accept null as a primary key value for Realm version 0.89.1+
+    // @PrimaryKey + @Required annotation does not accept null as a primary key value for Realm version 0.89.1+.
     @Test
     public void createObject_nullPrimaryKeyValueThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
index 9facd69f7f..1546c13524 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -95,7 +95,7 @@ public void validateTable_noDuplicateIndexInIndicesMap() {
         final Set<Long> indexSet = new HashSet<>();
         int indexCount = 0;
 
-        // get index for each field and then put into set
+        // Gets index for each field and then put into set.
         for (Field field : Cat.class.getDeclaredFields()) {
             if (Modifier.isStatic(field.getModifiers())) {
                 continue;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 6ef934579b..b1dbf6c3f4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -267,11 +267,11 @@ public void or() {
     public void not() {
         populateTestRealm(); // create TEST_DATA_SIZE objects
 
-        // only one object with value 5 -> TEST_DATA_SIZE-1 object with value "not 5"
+        // Only one object with value 5 -> TEST_DATA_SIZE-1 object with value "not 5".
         RealmResults<AllTypes> list1 = realm.where(AllTypes.class).not().equalTo(AllTypes.FIELD_LONG, 5).findAll();
         assertEquals(TEST_DATA_SIZE - 1, list1.size());
 
-        // not().greater() and lessThenOrEqual() must be the same
+        // not().greater() and lessThenOrEqual() must be the same.
         RealmResults<AllTypes> list2 = realm.where(AllTypes.class).not().greaterThan(AllTypes.FIELD_LONG, 5).findAll();
         RealmResults<AllTypes> list3 = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_LONG, 5).findAll();
         assertEquals(list2.size(), list3.size());
@@ -933,16 +933,16 @@ public void like_caseSensitiveWithNonLatinCharacters() {
         assertEquals(0, resultList.size());
 
         resultList = realm.where(AllTypes.class).like("columnString", "*Α*", Case.INSENSITIVE).findAll();
-        //without ASCII-only limitation A matches α
-        //assertEquals(3, resultList.size());
+        // without ASCII-only limitation A matches α
+        // assertEquals(3, resultList.size());
         assertEquals(1, resultList.size());
 
         resultList = realm.where(AllTypes.class).like("columnString", "*λ*", Case.INSENSITIVE).findAll();
         assertEquals(2, resultList.size());
 
         resultList = realm.where(AllTypes.class).like("columnString", "*Δ*", Case.INSENSITIVE).findAll();
-        //without ASCII-only limitation Δ matches δ
-        //assertEquals(1, resultList.size());
+        // without ASCII-only limitation Δ matches δ
+        // assertEquals(1, resultList.size());
         assertEquals(0, resultList.size());
 
         resultList = realm.where(AllTypes.class).like("columnString", "?λ*").findAll();
@@ -997,14 +997,14 @@ public void queryLink() {
 
     @Test
     public void findAllSorted_multiFailures() {
-        // zero fields specified
+        // Zero fields specified.
         try {
             realm.where(AllTypes.class).findAllSorted(new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
-        // number of fields and sorting orders don't match
+        // Number of fields and sorting orders don't match.
         try {
             realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING},
                     new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
@@ -1012,7 +1012,7 @@ public void findAllSorted_multiFailures() {
         } catch (IllegalArgumentException ignored) {
         }
 
-        // null is not allowed
+        // Null is not allowed.
         try {
             realm.where(AllTypes.class).findAllSorted((String[]) null, null);
             fail();
@@ -1024,7 +1024,7 @@ public void findAllSorted_multiFailures() {
         } catch (IllegalArgumentException ignored) {
         }
 
-        // non-existing field name
+        // Non-existing field name.
         try {
             realm.where(AllTypes.class)
                     .findAllSorted(new String[]{AllTypes.FIELD_STRING, "do-not-exist"},
@@ -1115,7 +1115,7 @@ public void georgian() {
         }
     }
 
-    // Querying a non-nullable field with null is an error
+    // Quering a non-nullable field with null is an error.
     @Test
     public void equalTo_notNullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1183,7 +1183,7 @@ public void equalTo_notNullableFields() {
         }
     }
 
-    // Querying a non-nullable field with null is an error
+    // Querying a non-nullable field with null is an error.
     @Test
     public void isNull_notNullableFields() {
         // 1 String
@@ -1248,12 +1248,12 @@ public void isNull_notNullableFields() {
         }
     }
 
-    // Querying nullable PrimaryKey
+    // Queries nullable PrimaryKey.
     @Test
     public void equalTo_nullPrimaryKeys() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
         final String SECONDARY_FIELD_STRING = "Realm is a mobile database hundreds of millions of people rely on.";
-        // fill up a Realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a Realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    SECONDARY_FIELD_STRING, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   SECONDARY_FIELD_STRING, 10, -5);
@@ -1276,7 +1276,7 @@ public void equalTo_nullPrimaryKeys() {
     public void isNull_nullPrimaryKeys() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
         final String SECONDARY_FIELD_STRING = "Realm is a mobile database hundreds of millions of people rely on.";
-        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    SECONDARY_FIELD_STRING, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   SECONDARY_FIELD_STRING, 10, -5);
@@ -1299,7 +1299,7 @@ public void isNull_nullPrimaryKeys() {
     public void notEqualTo_nullPrimaryKeys() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
         final String SECONDARY_FIELD_STRING = "Realm is a mobile database hundreds of millions of people rely on.";
-        // fill up a realm with one user PrimaryKey value and one numeric values, starting from -1
+        // Fills up a realm with one user PrimaryKey value and one numeric values, starting from -1.
         TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 2, -1);
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    SECONDARY_FIELD_STRING, 2, -1);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   SECONDARY_FIELD_STRING, 2, -1);
@@ -1355,7 +1355,7 @@ public void like_nullStringPrimaryKey() {
 
     @Test
     public void between_nullPrimaryKeysIsNotZero() {
-        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
         TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
@@ -1373,7 +1373,7 @@ public void between_nullPrimaryKeysIsNotZero() {
 
     @Test
     public void greaterThan_nullPrimaryKeysIsNotZero() {
-        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
         TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
@@ -1391,7 +1391,7 @@ public void greaterThan_nullPrimaryKeysIsNotZero() {
 
     @Test
     public void greaterThanOrEqualTo_nullPrimaryKeysIsNotZero() {
-        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
         TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
@@ -1409,7 +1409,7 @@ public void greaterThanOrEqualTo_nullPrimaryKeysIsNotZero() {
 
     @Test
     public void lessThan_nullPrimaryKeysIsNotZero() {
-        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
         TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
@@ -1427,7 +1427,7 @@ public void lessThan_nullPrimaryKeysIsNotZero() {
 
     @Test
     public void lessThanOrEqualTo_nullPrimaryKeysIsNotZero() {
-        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        // Fills up a realm with one user PrimaryKey value and 9 numeric values, starting from -5.
         TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
         TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
         TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
@@ -1443,7 +1443,7 @@ public void lessThanOrEqualTo_nullPrimaryKeysIsNotZero() {
         assertEquals(7, realm.where(PrimaryKeyAsBoxedLong.class).lessThanOrEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       1).count());
     }
 
-    // Querying nullable fields, querying with equalTo null
+    // Queries nullable fields with equalTo null.
     @Test
     public void equalTo_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1496,7 +1496,7 @@ public void equalTo_nullableFields() {
         // 11 Object skipped, doesn't support equalTo query
     }
 
-    // Querying nullable field for null
+    // Queries nullable field for null.
     @Test
     public void isNull_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1525,7 +1525,7 @@ public void isNull_nullableFields() {
         assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL).count());
     }
 
-    // Querying nullable field for not null
+    // Queries nullable field for not null.
     @Test
     public void notEqualTo_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1562,7 +1562,7 @@ public void notEqualTo_nullableFields() {
         // 11 Object skipped, doesn't support notEqualTo query
     }
 
-    // Querying nullable field for not null
+    // Queries nullable field for not null.
     @Test
     public void isNotNull_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1591,7 +1591,7 @@ public void isNotNull_nullableFields() {
         assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL).count());
     }
 
-    // Querying nullable field with beginsWith - all strings begin with null
+    // Queries nullable field with beginsWith - all strings begin with null.
     @Test
     public void beginWith_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1599,7 +1599,7 @@ public void beginWith_nullForNullableStrings() {
                 (String) null).findFirst().getFieldStringNotNull());
     }
 
-    // Querying nullable field with contains - all strings contain null
+    // Queries nullable field with contains - all strings contain null.
     @Test
     public void contains_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1607,7 +1607,7 @@ public void contains_nullForNullableStrings() {
                 (String) null).findFirst().getFieldStringNotNull());
     }
 
-    // Querying nullable field with endsWith - all strings end with null
+    // Queries nullable field with endsWith - all strings end with null.
     @Test
     public void endsWith_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1615,7 +1615,7 @@ public void endsWith_nullForNullableStrings() {
                 (String) null).findFirst().getFieldStringNotNull());
     }
 
-    // Querying nullable field with like - nulls do not match either '?' or '*'
+    // Queries nullable field with like - nulls do not match either '?' or '*'.
     @Test
     public void like_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1627,7 +1627,7 @@ public void like_nullForNullableStrings() {
         assertEquals(0, resultList.size());
     }
 
-    // Querying with between and table has null values in row.
+    // Queries with between and table has null values in row.
     @Test
     public void between_nullValuesInRow() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1645,7 +1645,7 @@ public void between_nullValuesInRow() {
                 new Date(20000)).count());
     }
 
-    // Querying with greaterThan and table has null values in row.
+    // Queries with greaterThan and table has null values in row.
     @Test
     public void greaterThan_nullValuesInRow() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1663,7 +1663,7 @@ public void greaterThan_nullValuesInRow() {
                 new Date(5000)).count());
     }
 
-    // Querying with greaterThanOrEqualTo and table has null values in row.
+    // Queries with greaterThanOrEqualTo and table has null values in row.
     @Test
     public void greaterThanOrEqualTo_nullValuesInRow() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1681,7 +1681,7 @@ public void greaterThanOrEqualTo_nullValuesInRow() {
                 new Date(10000)).count());
     }
 
-    // Querying with lessThan and table has null values in row.
+    // Queries with lessThan and table has null values in row.
     @Test
     public void lessThan_nullValuesInRow() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1700,7 +1700,7 @@ public void lessThan_nullValuesInRow() {
 
     }
 
-    // Querying with lessThanOrEqualTo and table has null values in row.
+    // Queries with lessThanOrEqualTo and table has null values in row.
     @Test
     public void lessThanOrEqual_nullValuesInRow() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1723,7 +1723,7 @@ public void lessThanOrEqual_nullValuesInRow() {
     @Test
     public void buildQueryFromResultsGC() {
         // According to the testing, setting this to 10 can almost certainly trigger the GC.
-        // Use 30 here can ensure GC happen. (Tested with 4.3 1G Ram and 5.0 3G Ram)
+        // Uses 30 here can ensure GC happen. (Tested with 4.3 1G Ram and 5.0 3G Ram)
         final int count = 30;
         RealmResults<CatOwner> results = realm.where(CatOwner.class).findAll();
 
@@ -1731,7 +1731,7 @@ public void buildQueryFromResultsGC() {
             @SuppressWarnings({"unused"})
             byte garbage[] = TestHelper.allocGarbage(0);
             results = results.where().findAll();
-            System.gc(); // if a native resource has a reference count = 0, doing GC here might lead to a crash
+            System.gc(); // If a native resource has a reference count = 0, doing GC here might lead to a crash.
         }
     }
 
@@ -1815,7 +1815,7 @@ public void notEqualTo_binary_multiFailures() {
         }
     }
 
-    // Test min on empty columns
+    // Tests min on empty columns.
     @Test
     public void min_emptyColumns() {
         RealmQuery<NullTypes> query = realm.where(NullTypes.class);
@@ -1825,7 +1825,7 @@ public void min_emptyColumns() {
         assertNull(query.minimumDate(NullTypes.FIELD_DATE_NOT_NULL));
     }
 
-    // Test min on columns with all null rows
+    // Tests min on columns with all null rows.
     @Test
     public void min_allNullColumns() {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
@@ -1837,7 +1837,7 @@ public void min_allNullColumns() {
         assertNull(query.minimumDate(NullTypes.FIELD_DATE_NULL));
     }
 
-    // Test min on columns with all non-null rows
+    // Tests min on columns with all non-null rows.
     @Test
     public void min_allNonNullRows() {
         TestHelper.populateAllNonNullRowsForNumericTesting(realm);
@@ -1849,7 +1849,7 @@ public void min_allNonNullRows() {
         assertEquals(-2000, query.minimumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
-    // Test min on columns with partial null rows
+    // Tests min on columns with partial null rows.
     @Test
     public void min_partialNullRows() {
         TestHelper.populatePartialNullRowsForNumericTesting(realm);
@@ -1870,7 +1870,7 @@ public void max_emptyColumns() {
         assertNull(query.maximumDate(NullTypes.FIELD_DATE_NOT_NULL));
     }
 
-    // Test max on columns with all null rows
+    // Tests max on columns with all null rows.
     @Test
     public void max_allNullColumns() {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
@@ -1882,7 +1882,7 @@ public void max_allNullColumns() {
         assertNull(query.maximumDate(NullTypes.FIELD_DATE_NULL));
     }
 
-    // Test max on columns with all non-null rows
+    // Tests max on columns with all non-null rows.
     @Test
     public void max_allNonNullRows() {
         TestHelper.populateAllNonNullRowsForNumericTesting(realm);
@@ -1894,7 +1894,7 @@ public void max_allNonNullRows() {
         assertEquals(12345, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
-    // Test max on columns with partial null rows
+    // Tests max on columns with partial null rows.
     @Test
     public void max_partialNullRows() {
         TestHelper.populatePartialNullRowsForNumericTesting(realm);
@@ -1906,7 +1906,7 @@ public void max_partialNullRows() {
         assertEquals(12345, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
-    // Test average on empty columns
+    // Tests average on empty columns.
     @Test
     public void average_emptyColumns() {
         RealmQuery<NullTypes> query = realm.where(NullTypes.class);
@@ -1915,7 +1915,7 @@ public void average_emptyColumns() {
         assertEquals(0d, query.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
     }
 
-    // Test average on columns with all null rows
+    // Tests average on columns with all null rows.
     @Test
     public void average_allNullColumns() {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
@@ -1926,7 +1926,7 @@ public void average_allNullColumns() {
         assertEquals(0d, query.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
     }
 
-    // Test average on columns with all non-null rows
+    // Tests average on columns with all non-null rows.
     @Test
     public void average_allNonNullRows() {
         TestHelper.populateAllNonNullRowsForNumericTesting(realm);
@@ -1937,7 +1937,7 @@ public void average_allNonNullRows() {
         assertEquals(8.0 / 3, query.average(NullTypes.FIELD_DOUBLE_NULL), 0.001d);
     }
 
-    // Test average on columns with partial null rows
+    // Tests average on columns with partial null rows.
     @Test
     public void average_partialNullRows() {
         TestHelper.populatePartialNullRowsForNumericTesting(realm);
@@ -1948,7 +1948,7 @@ public void average_partialNullRows() {
         assertEquals(5.5, query.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
     }
 
-    // Test sum on empty columns
+    // Tests sum on empty columns.
     @Test
     public void sum_emptyColumns() {
         RealmQuery<NullTypes> query = realm.where(NullTypes.class);
@@ -1957,7 +1957,7 @@ public void sum_emptyColumns() {
         assertEquals(0d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
     }
 
-    // Test sum on columns with all null rows
+    // Tests sum on columns with all null rows.
     @Test
     public void sum_allNullColumns() {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
@@ -1968,7 +1968,7 @@ public void sum_allNullColumns() {
         assertEquals(0d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
     }
 
-    // Test sum on columns with all non-null rows
+    // Tests sum on columns with all non-null rows.
     @Test
     public void sum_allNonNullRows() {
         TestHelper.populateAllNonNullRowsForNumericTesting(realm);
@@ -1979,7 +1979,7 @@ public void sum_allNonNullRows() {
         assertEquals(8d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
     }
 
-    // Test sum on columns with partial null rows
+    // Tests sum on columns with partial null rows.
     @Test
     public void sum_partialNullRows() {
         TestHelper.populatePartialNullRowsForNumericTesting(realm);
@@ -1996,7 +1996,7 @@ public void count() {
         assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
     }
 
-    // Test isNull on link's nullable field.
+    // Tests isNull on link's nullable field.
     @Test
     public void isNull_linkField() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -2044,7 +2044,7 @@ public void isNull_linkField() {
         }
     }
 
-    // Test isNull on link's not-nullable field. should throw
+    // Tests isNull on link's not-nullable field. Should throw.
     @Test
     public void isNull_linkFieldNotNullable() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -2122,7 +2122,7 @@ public void isNull_linkFieldNotNullable() {
         // 11 Object skipped, doesn't support equalTo query
     }
 
-    // Test isNotNull on link's nullable field.
+    // Tests isNotNull on link's nullable field.
     @Test
     public void isNotNull_linkField() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -2169,7 +2169,7 @@ public void isNotNull_linkField() {
         }
     }
 
-    // Test isNotNull on link's not-nullable field. should throw
+    // Tests isNotNull on link's not-nullable field. Should throw.
     @Test
     public void isNotNull_linkFieldNotNullable() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -2247,7 +2247,7 @@ public void isNotNull_linkFieldNotNullable() {
         // 11 Object skipped, RealmObject is always nullable.
     }
 
-    // Calling isNull on fields with the RealmList type will trigger an exception
+    // Calling isNull on fields with the RealmList type will trigger an exception.
     @Test
     public void isNull_listFieldThrows() {
         try {
@@ -2265,7 +2265,7 @@ public void isNull_listFieldThrows() {
         }
     }
 
-    // Calling isNotNull on fields with the RealmList type will trigger an exception
+    // Calling isNotNull on fields with the RealmList type will trigger an exception.
     @Test
     public void isNotNull_listFieldThrows() {
         try {
@@ -2328,7 +2328,7 @@ public void isValid_tableQuery() {
 
         assertTrue(query.isValid());
         populateTestRealm(realm, 1);
-        // still valid if result changed
+        // Still valid if result changed.
         assertTrue(query.isValid());
 
         realm.close();
@@ -2343,14 +2343,14 @@ public void isValid_tableViewQuery() {
         assertTrue(query.isValid());
 
         populateTestRealm(realm, 1);
-        // still valid if table view changed
+        // Still valid if table view changed.
         assertTrue(query.isValid());
 
         realm.close();
         assertFalse(query.isValid());
     }
 
-    // test for https://github.com/realm/realm-java/issues/1905
+    // Test for https://github.com/realm/realm-java/issues/1905
     @Test
     public void resultOfTableViewQuery() {
         populateTestRealm();
@@ -2378,7 +2378,7 @@ public void isValid_linkViewQuery() {
         list.add(dog);
         realm.commitTransaction();
 
-        // still valid if base view changed
+        // Still valid if base view changed.
         assertEquals(listLength + 1, query.count());
         assertTrue(query.isValid());
 
@@ -2397,7 +2397,7 @@ public void isValid_removedParent() {
         obj.deleteFromRealm();
         realm.commitTransaction();
 
-        // invalid if parent has been removed
+        // Invalid if parent has been removed.
         assertFalse(query.isValid());
     }
 
@@ -2524,7 +2524,7 @@ public void isEmpty_invalidFieldNameThrows() {
         }
     }
 
-    // not-empty test harnesses
+    // Not-empty test harnesses.
     private static final List<RealmFieldType> SUPPORTED_IS_NOT_EMPTY_TYPES = Arrays.asList(
             RealmFieldType.STRING,
             RealmFieldType.BINARY,
@@ -2647,15 +2647,15 @@ public void isNotEmpty_invalidFieldNameThrows() {
         }
     }
 
-    // Test that deep queries work on a lot of data
+    // Tests that deep queries work on a lot of data.
     @Test
     public void deepLinkListQuery() {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
 
-                // Crash with i == 1000, 500, 100, 89, 85, 84
-                // Doesn't crash for i == 10, 50, 75, 82, 83
+                // Crashes with i == 1000, 500, 100, 89, 85, 84.
+                // Doesn't crash for i == 10, 50, 75, 82, 83.
                 for (int i = 0; i < 84; i++) {
                     AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i + 1);
                     obj.setFieldBoolean(i % 2 == 0);
@@ -2714,7 +2714,7 @@ public void findAllSortedAsync_listOnSubObjectFieldThrows() {
         realm.where(AllTypes.class).findAllSortedAsync(fieldNames, sorts);
     }
 
-    // RealmQuery.distinct(): requires indexing, and type = boolean, integer, date, string
+    // RealmQuery.distinct(): requires indexing, and type = boolean, integer, date, string.
     private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
         realm.beginTransaction();
         for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
@@ -2747,7 +2747,7 @@ private void populateForDistinctInvalidTypesLinked(Realm realm) {
     @Test
     public void distinct() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
@@ -2788,7 +2788,7 @@ public void distinct_notIndexedFields() {
     @Test
     public void distinct_doesNotExist() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
@@ -2863,7 +2863,7 @@ public void distinctAsync() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
         final Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
@@ -2951,7 +2951,7 @@ public void run() {
                     Realm.asyncTaskExecutor.pause();
                     asyncRealm = openRealmInstance("testDistinctAsyncQueryWithNull");
                     final long numberOfBlocks = 25;
-                    final long numberOfObjects = 10; // must be greater than 1
+                    final long numberOfObjects = 10; // Must be greater than 1
                     populateForDistinct(asyncRealm, numberOfBlocks, numberOfObjects, true);
 
                     final RealmResults<AnnotationIndexTypes> distinctDate = asyncRealm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
@@ -3070,7 +3070,7 @@ public void distinctAsync_notIndexedLinkedFields() {
     @Test
     public void distinctMultiArgs() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3083,7 +3083,7 @@ public void distinctMultiArgs_switchedFieldsOrder() {
         final long numberOfBlocks = 25;
         TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
 
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
+        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         RealmResults<AnnotationIndexTypes> distinctStringLong = query.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
         RealmResults<AnnotationIndexTypes> distinctLongString = query.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
@@ -3099,47 +3099,47 @@ public void distinctMultiArgs_emptyField() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        // an empty string field in the middle
+        // An empty string field in the middle.
         try {
             query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
-        // an empty string field at the end
+        // An empty string field at the end.
         try {
             query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
         } catch (IllegalArgumentException ignored) {
         }
-        // a null string field in the middle
+        // A null string field in the middle.
         try {
             query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
-        // a null string field at the end
+        // A null string field at the end.
         try {
             query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
-        // (String)null makes varargs a null array.
+        // (String) Null makes varargs a null array.
         try {
             query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
-        // Two (String)null for first and varargs fields
+        // Two (String) null for first and varargs fields.
         try {
             query.distinct((String) null, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
-        // "" & (String)null combination
+        // "" & (String) null combination.
         try {
             query.distinct("", (String) null);
         } catch (IllegalArgumentException ignored) {
         }
-        // "" & (String)null combination
+        // "" & (String) null combination.
         try {
             query.distinct((String) null, "");
         } catch (IllegalArgumentException ignored) {
         }
-        // Two empty fields tests
+        // Two empty fields tests.
         try {
             query.distinct("", "");
         } catch (IllegalArgumentException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index cbce2dfd79..312b93fe66 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -135,7 +135,7 @@ public void unsupportedMethods() {
                     case REMOVE_ALL: collection.removeAll(Collections.singletonList(new AllTypes())); break;
                     case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllTypes())); break;
 
-                    // Supported methods
+                    // Supported methods.
                     case DELETE_ALL:
                         continue;
                 }
@@ -152,7 +152,7 @@ public void unsupportedMethods() {
                     case SET: collection.set(0, new AllTypes()); break;
                     case REMOVE_INDEX: collection.remove(0); break;
 
-                    // Supported methods
+                    // Supported methods.
                     case DELETE_INDEX:
                     case DELETE_FIRST:
                     case DELETE_LAST:
@@ -164,7 +164,7 @@ public void unsupportedMethods() {
         }
     }
 
-    // Triggered an ARM bug
+    // Triggers an ARM bug.
     @Test
     public void verifyArmComparisons() {
         realm.beginTransaction();
@@ -185,7 +185,7 @@ public void verifyArmComparisons() {
         assertEquals(10, realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 0).findAll().size());
     }
 
-    // RealmResults.distinct(): requires indexing, and type = boolean, integer, date, string
+    // RealmResults.distinct(): requires indexing, and type = boolean, integer, date, string.
     private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
         realm.beginTransaction();
         for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
@@ -217,7 +217,7 @@ private void populateForDistinctInvalidTypesLinked(Realm realm) {
     @Test
     public void distinct() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
@@ -234,16 +234,16 @@ public void distinct_restrictedByPreviousDistinct() {
         final long numberOfObjects = 10;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        // all objects
+        // All objects
         RealmResults<AnnotationIndexTypes> allResults = realm.where(AnnotationIndexTypes.class).findAll();
         assertEquals("All Objects Count", numberOfBlocks * numberOfBlocks * numberOfObjects, allResults.size());
-        // distinctive dates
+        // Distinctive dates
         RealmResults<AnnotationIndexTypes> distinctDates = allResults.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE);
         assertEquals("Distinctive Dates", numberOfBlocks, distinctDates.size());
-        // distinctive Booleans
+        // Distinctive Booleans
         RealmResults<AnnotationIndexTypes> distinctBooleans = distinctDates.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
         assertEquals("Distinctive Booleans", 2, distinctBooleans.size());
-        // all three results are the same object
+        // All three results are the same object
         assertTrue(allResults == distinctDates);
         assertTrue(allResults == distinctBooleans);
     }
@@ -251,7 +251,7 @@ public void distinct_restrictedByPreviousDistinct() {
     @Test
     public void distinct_withNullValues() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
@@ -263,7 +263,7 @@ public void distinct_withNullValues() {
     @Test
     public void distinct_notIndexedFields() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
@@ -278,7 +278,7 @@ public void distinct_notIndexedFields() {
     @Test
     public void distinct_noneExistingField() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
@@ -304,7 +304,7 @@ public void distinct_invalidTypes() {
     @Test
     public void distinct_indexedLinkedFields() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
@@ -319,7 +319,7 @@ public void distinct_indexedLinkedFields() {
     @Test
     public void distinct_notIndexedLinkedFields() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
@@ -351,7 +351,7 @@ public void changeListener_syncIfNeeded_updatedFromOtherThread() {
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 10).findAll();
         assertEquals(10, results.size());
 
-        // 1. Delete first object from another thread.
+        // 1. Deletes first object from another thread.
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -360,7 +360,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
-                // 2. RealmResults are refreshed before onSuccess is called
+                // 2. RealmResults are refreshed before onSuccess is called.
                 assertEquals(9, results.size());
                 realm.close();
                 looperThread.testComplete();
@@ -420,7 +420,7 @@ public void distinctAsync() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
         final Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
@@ -496,7 +496,7 @@ public void distinctAsync_withNullValues() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(2);
         final Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
@@ -605,7 +605,7 @@ public void distinctAsync_notIndexedLinkedFields() {
     @Test
     public void distinctMultiArgs() {
         final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
@@ -618,7 +618,7 @@ public void distinctMultiArgs_switchedFieldsOrder() {
         final long numberOfBlocks = 25;
         TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
 
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
+        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
         RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
         RealmResults<AnnotationIndexTypes> distinctStringLong = results.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
         RealmResults<AnnotationIndexTypes> distinctLongString = results.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
@@ -634,47 +634,47 @@ public void distinctMultiArgs_emptyField() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        // an empty string field in the middle
+        // An empty string field in the middle.
         try {
             results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
-        // an empty string field at the end
+        // An empty string field at the end.
         try {
             results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
         } catch (IllegalArgumentException ignored) {
         }
-        // a null string field in the middle
+        // A null string field in the middle.
         try {
             results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, null, AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
-        // a null string field at the end
+        // A null string field at the end.
         try {
             results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, null);
         } catch (IllegalArgumentException ignored) {
         }
-        // (String)null makes varargs a null array.
+        // (String) Null makes varargs a null array.
         try {
             results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
         } catch (IllegalArgumentException ignored) {
         }
-        // Two (String)null for first and varargs fields
+        // Two (String) null for first and varargs fields.
         try {
             results.distinct(null, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
-        // "" & (String)null combination
+        // "" & (String)null combination.
         try {
             results.distinct("", (String) null);
         } catch (IllegalArgumentException ignored) {
         }
-        // "" & (String)null combination
+        // "" & (String)null combination.
         try {
             results.distinct(null, "");
         } catch (IllegalArgumentException ignored) {
         }
-        // Two empty fields tests
+        // Two empty fields tests.
         try {
             results.distinct("", "");
         } catch (IllegalArgumentException ignored) {
@@ -1029,12 +1029,12 @@ public void deleteAndDeleteAll() {
         RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAll();
 
         realm.beginTransaction();
-        // remove one object
+        // Removes one object.
         stringOnlies.get(0).deleteFromRealm();
         realm.commitTransaction();
 
         realm.beginTransaction();
-        // remove the rest
+        // Removes the rest.
         stringOnlies.deleteAllFromRealm();
         realm.commitTransaction();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index 018f063f37..da49a66229 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -122,7 +122,7 @@ public void rename() {
     public void rename_invalidArgumentThrows() {
         String[] illegalNames = new String[] { null, "" };
 
-        // Test as first parameter
+        // Tests as first parameter.
         for (String illegalName : illegalNames) {
             try {
                 realmSchema.rename(illegalName, AllJavaTypes.CLASS_NAME);
@@ -131,7 +131,7 @@ public void rename_invalidArgumentThrows() {
             }
         }
 
-        // Test as last parameters
+        // Tests as last parameters.
         for (String illegalName : illegalNames) {
             try {
                 realmSchema.rename(AllJavaTypes.CLASS_NAME, illegalName);
@@ -152,12 +152,12 @@ public void rename_shouldChangeInfoInPKTable() {
 
         assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
 
-        // Create an object with the old name, and the PK should not exist after created.
+        // Creates an object with the old name, and the PK should not exist after created.
         RealmObjectSchema oldObjectSchema = realmSchema.create(PrimaryKeyAsString.CLASS_NAME);
         oldObjectSchema.addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
 
         try {
-            // It should not have primary key anymore at this point
+            // It should not have primary key anymore at this point.
             oldObjectSchema.getPrimaryKey();
             fail();
         } catch (IllegalStateException ignored) {
@@ -217,7 +217,7 @@ public void remove_shouldRemoveInfoFromPKTable() {
         objectSchema.addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
 
         try {
-            // It should not have primary key anymore at this point
+            // It should not have primary key anymore at this point.
             objectSchema.getPrimaryKey();
             fail();
         } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index d449711600..4337317fcc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -222,7 +222,7 @@ public void getInstance_writeProtectedFileWithContext() throws IOException {
 
     @Test
     public void getInstance_twiceWhenRxJavaUnavailable() {
-        // test for https://github.com/realm/realm-java/issues/2416
+        // Test for https://github.com/realm/realm-java/issues/2416
 
         // Though it's not a recommended way to create multiple configuration instance with the same parameter, it's legal.
         final RealmConfiguration configuration1 = configFactory.createConfiguration("no_RxJava.realm");
@@ -693,7 +693,7 @@ public void execute(Realm realm) {
                 }
             });
         } catch (RuntimeException ignored) {
-            // Ensure that we pass a valuable error message to the logger for developers.
+            // Ensures that we pass a valuable error message to the logger for developers.
             assertEquals(testLogger.message, "Could not cancel transaction, not currently in a transaction.");
         } finally {
             RealmLog.remove(testLogger);
@@ -703,30 +703,30 @@ public void execute(Realm realm) {
 
     @Test
     public void delete_type() {
-        // ** delete non existing table should succeed
+        // ** Deletes non existing table should succeed.
         realm.beginTransaction();
         realm.delete(AllTypes.class);
         realm.commitTransaction();
 
-        // ** delete existing class, but leave other classes classes
+        // ** Deletes existing class, but leaves other classes classes.
 
-        // Add two classes
+        // Adds two classes.
         populateTestRealm();
         realm.beginTransaction();
         Dog dog = realm.createObject(Dog.class);
         dog.setName("Castro");
         realm.commitTransaction();
-        // Clear
+        // Clears.
         realm.beginTransaction();
         realm.delete(Dog.class);
         realm.commitTransaction();
-        // Check one class is cleared but other class is still there
+        // Checks one class is cleared but other class is still there.
         RealmResults<AllTypes> resultListTypes = realm.where(AllTypes.class).findAll();
         assertEquals(TEST_DATA_SIZE, resultListTypes.size());
         RealmResults<Dog> resultListDogs = realm.where(Dog.class).findAll();
         assertEquals(0, resultListDogs.size());
 
-        // ** delete() must throw outside a transaction
+        // ** delete() must throw outside a transaction.
         try {
             realm.delete(AllTypes.class);
             fail("Expected exception");
@@ -856,19 +856,19 @@ public void unicodeStrings() {
 
     @Test
     public void getInstance_referenceCounting() {
-        // At this point reference count should be one because of the setUp method
+        // At this point reference count should be one because of the setUp method.
         try {
             realm.where(AllTypes.class).count();
         } catch (IllegalStateException e) {
             fail();
         }
 
-        // Make sure the reference counter is per realm file
+        // Makes sure the reference counter is per realm file.
         RealmConfiguration anotherConfig = configFactory.createConfiguration("anotherRealm.realm");
         Realm.deleteRealm(anotherConfig);
         Realm otherRealm = Realm.getInstance(anotherConfig);
 
-        // Raise the reference
+        // Raises the reference.
         Realm realm = null;
         try {
             realm = Realm.getInstance(configFactory.createConfiguration());
@@ -877,7 +877,7 @@ public void getInstance_referenceCounting() {
         }
 
         try {
-            // This should not fail because the reference is now 1
+            // This should not fail because the reference is now 1.
             if (realm != null) {
                 realm.where(AllTypes.class).count();
             }
@@ -910,14 +910,14 @@ public void getInstance_referenceCounting() {
     @Test
     public void getInstance_referenceCounting_doubleClose() {
         realm.close();
-        realm.close(); // Count down once too many. Counter is now potentially negative
+        realm.close(); // Counts down once too many. Counter is now potentially negative.
         realm = Realm.getInstance(configFactory.createConfiguration());
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
         RealmResults<AllTypes> queryResult = realm.where(AllTypes.class).findAll();
         assertEquals(allTypes, queryResult.get(0));
         realm.commitTransaction();
-        realm.close(); // This might not close the Realm if the reference count is wrong
+        realm.close(); // This might not close the Realm if the reference count is wrong.
 
         // This should now fail due to the Realm being fully closed.
         thrown.expect(IllegalStateException.class);
@@ -946,14 +946,14 @@ public void writeCopyTo() throws IOException {
             }
         }
 
-        // Copy is compacted i.e. smaller than original
+        // Copy is compacted i.e. smaller than original.
         File file1 = new File(configA.getPath());
         File file2 = new File(configB.getPath());
         assertTrue(file1.length() >= file2.length());
 
         Realm realm2 = null;
         try {
-            // Contents is copied too
+            // Contents is copied too.
             realm2 = Realm.getInstance(configB);
             RealmResults<AllTypes> results = realm2.where(AllTypes.class).findAll();
             assertEquals(1, results.size());
@@ -1070,8 +1070,8 @@ public void copyToRealm_fromOtherRealm() {
         AllTypes copiedAllTypes = otherRealm.copyToRealm(allTypes);
         otherRealm.commitTransaction();
 
-        assertNotSame(allTypes, copiedAllTypes); // Same object in different Realms is not the same
-        assertEquals(allTypes.getColumnString(), copiedAllTypes.getColumnString()); // But data is still the same
+        assertNotSame(allTypes, copiedAllTypes); // Same object in different Realms is not the same.
+        assertEquals(allTypes.getColumnString(), copiedAllTypes.getColumnString()); // But data is still the same.
         otherRealm.close();
     }
 
@@ -1098,8 +1098,8 @@ public void copyToRealm() {
         AllTypes realmTypes = realm.copyToRealm(allTypes);
         realm.commitTransaction();
 
-        assertNotSame(allTypes, realmTypes); // Objects should not be considered equal
-        assertEquals(allTypes.getColumnString(), realmTypes.getColumnString()); // But they contain the same data
+        assertNotSame(allTypes, realmTypes); // Objects should not be considered equal.
+        assertEquals(allTypes.getColumnString(), realmTypes.getColumnString()); // But they contain the same data.
         assertEquals(allTypes.getColumnLong(), realmTypes.getColumnLong());
         assertEquals(allTypes.getColumnFloat(), realmTypes.getColumnFloat(), 0);
         assertEquals(allTypes.getColumnDouble(), realmTypes.getColumnDouble(), 0);
@@ -1128,8 +1128,8 @@ public void copyToRealm_cyclicObjectReferences() {
         assertEquals("Two", realmObject.getObject().getName());
         assertEquals(2, realm.where(CyclicType.class).count());
 
-        // testing copyToRealm overload that uses the Iterator
-        // making sure we reuse the same graph cache Map to avoid duplicates
+        // Tests copyToRealm overload that uses the Iterator.
+        // Makes sure we reuse the same graph cache Map to avoid duplicates.
         realm.beginTransaction();
         realm.deleteAll();
         realm.commitTransaction();
@@ -1160,8 +1160,8 @@ public void copyToRealm_cyclicObjectReferencesWithPK() {
         assertEquals("Two", realmObject.getObject().getName());
         assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
 
-        // testing copyToRealm overload that uses the Iterator
-        // making sure we reuse the same graph cache Map to avoid duplicates
+        // Tests copyToRealm overload that uses the Iterator.
+        // Makes sure we reuse the same graph cache Map to avoid duplicates.
         realm.beginTransaction();
         realm.deleteAll();
         realm.commitTransaction();
@@ -1194,7 +1194,7 @@ public void copyToRealm_cyclicListReferences() {
         assertEquals(2, realm.where(CyclicType.class).count());
     }
 
-    // Check that if a field has a null value it gets converted to the default value for that type
+    // Checks that if a field has a null value, it gets converted to the default value for that type.
     @Test
     public void copyToRealm_convertsNullToDefaultValue() {
         realm.beginTransaction();
@@ -1290,11 +1290,11 @@ public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
     public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
         realm.beginTransaction();
 
-        // Child object is managed by Realm
+        // Child object is managed by Realm.
         CyclicTypePrimaryKey childObj = realm.createObject(CyclicTypePrimaryKey.class, 1);
         childObj.setName("Child");
 
-        // Parent object is an unmanaged object
+        // Parent object is an unmanaged object.
         CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
         parentObj.setObject(childObj);
 
@@ -1370,7 +1370,7 @@ public void copyToRealmOrUpdate_stringPrimaryKeyFieldIsNull() {
         assertEquals(null, result.first().getName());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getId());
 
-        // update objects
+        // Updates objects.
         realm.beginTransaction();
         nullPrimaryKeyObj.setId(SECONDARY_FIELD_UPDATED);
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
@@ -1390,7 +1390,7 @@ public void copyToRealmOrUpdate_boxedBytePrimaryKeyFieldIsNull() {
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
 
-        // update objects
+        // Updates objects.
         realm.beginTransaction();
         nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
@@ -1410,7 +1410,7 @@ public void copyToRealmOrUpdate_boxedShortPrimaryKeyFieldIsNull() {
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
 
-        // update objects
+        // Updates objects.
         realm.beginTransaction();
         nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
@@ -1430,7 +1430,7 @@ public void copyToRealmOrUpdate_boxedIntegerPrimaryKeyFieldIsNull() {
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
 
-        // update objects
+        // Updates objects.
         realm.beginTransaction();
         nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
@@ -1450,7 +1450,7 @@ public void copyToRealmOrUpdate_boxedLongPrimaryKeyFieldIsNull() {
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
 
-        // update objects
+        // Updates objects.
         realm.beginTransaction();
         nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
@@ -1522,7 +1522,7 @@ public void execute(Realm realm) {
         assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
 
-        // Check that the the only element has all its properties updated
+        // Checks that the the only element has all its properties updated.
         assertEquals("Bar", obj.getColumnString());
         assertEquals(1, obj.getColumnLong());
         assertEquals(2.23F, obj.getColumnFloat(), 0);
@@ -1560,7 +1560,7 @@ public void copyToRealmOrUpdate_cyclicObject() {
     }
 
 
-    // Checks that an unmanaged object with only default values can override data
+    // Checks that an unmanaged object with only default values can override data.
     @Test
     public void copyToRealmOrUpdate_defaultValuesOverrideExistingData() {
         realm.executeTransaction(new Realm.Transaction() {
@@ -1599,7 +1599,7 @@ public void execute(Realm realm) {
     }
 
 
-    // Tests that if references to objects are removed, the objects are still in the Realm
+    // Tests that if references to objects are removed, the objects are still in the Realm.
     @Test
     public void copyToRealmOrUpdate_referencesNotDeleted() {
         realm.executeTransaction(new Realm.Transaction() {
@@ -1766,7 +1766,7 @@ public void getInstance_differentEncryptionKeys() {
         byte[] key1 = TestHelper.getRandomKey(42);
         byte[] key2 = TestHelper.getRandomKey(42);
 
-        // Make sure the key is the same, but in two different instances
+        // Makes sure the key is the same, but in two different instances.
         assertArrayEquals(key1, key2);
         assertTrue(key1 != key2);
 
@@ -1797,7 +1797,7 @@ public void writeEncryptedCopyTo() throws Exception {
         long before = realm.where(AllTypes.class).count();
         assertEquals(TEST_DATA_SIZE, before);
 
-        // Configure test realms
+        // Configures test realms.
         final String ENCRYPTED_REALM_FILE_NAME = "encryptedTestRealm.realm";
         final String RE_ENCRYPTED_REALM_FILE_NAME = "reEncryptedTestRealm.realm";
         final String DECRYPTED_REALM_FILE_NAME = "decryptedTestRealm.realm";
@@ -1810,21 +1810,21 @@ public void writeEncryptedCopyTo() throws Exception {
 
         RealmConfiguration decryptedRealmConfig = configFactory.createConfiguration(DECRYPTED_REALM_FILE_NAME);
 
-        // Write encrypted copy from a unencrypted Realm
+        // Writes encrypted copy from a unencrypted Realm.
         File destination = new File(encryptedRealmConfig.getPath());
         realm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
 
         Realm encryptedRealm = null;
         try {
 
-            // Verify encrypted Realm and write new encrypted copy with a new key
+            // Verifies encrypted Realm and writes new encrypted copy with a new key.
             encryptedRealm = Realm.getInstance(encryptedRealmConfig);
             assertEquals(TEST_DATA_SIZE, encryptedRealm.where(AllTypes.class).count());
 
             destination = new File(reEncryptedRealmConfig.getPath());
             encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
 
-            // Verify re-encrypted copy
+            // Verifies re-encrypted copy.
             Realm reEncryptedRealm = null;
             try {
                 reEncryptedRealm = Realm.getInstance(reEncryptedRealmConfig);
@@ -1838,11 +1838,11 @@ public void writeEncryptedCopyTo() throws Exception {
                 }
             }
 
-            // Write non-encrypted copy from the encrypted version
+            // Writes non-encrypted copy from the encrypted version.
             destination = new File(decryptedRealmConfig.getPath());
             encryptedRealm.writeEncryptedCopyTo(destination, null);
 
-            // Verify decrypted Realm and cleanup
+            // Verifies decrypted Realm and cleans up.
             Realm decryptedRealm = null;
             try {
                 decryptedRealm = Realm.getInstance(decryptedRealmConfig);
@@ -1880,24 +1880,24 @@ public void deleteRealm_failures() {
         RealmConfiguration configA = configFactory.createConfiguration();
         RealmConfiguration configB = configFactory.createConfiguration(OTHER_REALM_NAME);
 
-        // This instance is already cached because of the setUp() method so this deletion should throw
+        // This instance is already cached because of the setUp() method so this deletion should throw.
         try {
             Realm.deleteRealm(configA);
             fail();
         } catch (IllegalStateException ignored) {
         }
 
-        // Create a new Realm file
+        // Creates a new Realm file.
         Realm yetAnotherRealm = Realm.getInstance(configB);
 
-        // Deleting it should fail
+        // Deleting it should fail.
         try {
             Realm.deleteRealm(configB);
             fail();
         } catch (IllegalStateException ignored) {
         }
 
-        // But now that we close it deletion should work
+        // But now that we close it deletion should work.
         yetAnotherRealm.close();
         try {
             Realm.deleteRealm(configB);
@@ -1911,7 +1911,7 @@ public void deleteRealm_failures() {
     public void setter_updateField() throws Exception {
         realm.beginTransaction();
 
-        // Create an owner with two dogs
+        // Creates an owner with two dogs.
         OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class, 1);
         owner.setName("Jack");
         Dog rex = realm.createObject(Dog.class);
@@ -1922,11 +1922,11 @@ public void setter_updateField() throws Exception {
         owner.getDogs().add(fido);
         assertEquals(2, owner.getDogs().size());
 
-        // Changing the name of the owner should not affect the number of dogs
+        // Changing the name of the owner should not affect the number of dogs.
         owner.setName("Peter");
         assertEquals(2, owner.getDogs().size());
 
-        // Updating the user should not affect it either. This is actually a no-op since owner is a Realm backed object
+        // Updating the user should not affect it either. This is actually a no-op since owner is a Realm backed object.
         OwnerPrimaryKey owner2 = realm.copyToRealmOrUpdate(owner);
         assertEquals(2, owner.getDogs().size());
         assertEquals(2, owner2.getDogs().size());
@@ -1949,7 +1949,7 @@ public void deleteRealm() throws InterruptedException {
         final CountDownLatch closedLatch = new CountDownLatch(1);
 
         Realm realm = Realm.getInstance(configuration);
-        // Create another Realm to ensure the log files are generated
+        // Creates another Realm to ensure the log files are generated.
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -1968,7 +1968,7 @@ public void run() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        // Wait for bg thread's opening the same Realm.
+        // Waits for bg thread's opening the same Realm.
         TestHelper.awaitOrFail(bgThreadReadyLatch);
 
         // A core upgrade might change the location of the files
@@ -1982,19 +1982,19 @@ public void run() {
 
         assertTrue(Realm.deleteRealm(configuration));
 
-        // Directory should be empty now
+        // Directory should be empty now.
         assertEquals(0, tempDir.listFiles().length);
     }
 
-    // Test that all methods that require a transaction (ie. any function that mutates Realm data)
+    // Tests that all methods that require a transaction. (ie. any function that mutates Realm data)
     @Test
     public void callMutableMethodOutsideTransaction() throws JSONException, IOException {
 
-        // Prepare unmanaged object data
+        // Prepares unmanaged object data.
         AllTypesPrimaryKey t = new AllTypesPrimaryKey();
         List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
 
-        // Prepare JSON data
+        // Prepares JSON data.
         String jsonObjStr = "{ \"columnLong\" : 1 }";
         JSONObject jsonObj = new JSONObject(jsonObjStr);
         InputStream jsonObjStream = TestHelper.stringToStream(jsonObjStr);
@@ -2005,7 +2005,7 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         InputStream jsonArrStream = TestHelper.stringToStream(jsonArrStr);
         InputStream jsonArrStream2 = TestHelper.stringToStream(jsonArrStr);
 
-        // Test all methods that should require a transaction
+        // Tests all methods that should require a transaction.
         try { realm.createObject(AllTypes.class);   fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealm(t);                 fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
@@ -2224,7 +2224,7 @@ public void createObject_defaultValueFromModelField() {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                // create a DefaultValueOfField with non-default primary key value
+                // Creates a DefaultValueOfField with non-default primary key value.
                 realm.createObject(DefaultValueOfField.class,
                         DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
             }
@@ -2241,7 +2241,7 @@ public void execute(Realm realm) {
         testOneObjectFound(realm, DefaultValueOfField.class,
                 DefaultValueOfField.FIELD_INT,
                 DefaultValueOfField.FIELD_INT_DEFAULT_VALUE);
-        // default value for pk must be ignored
+        // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueOfField.class,
                 DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
                 DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
@@ -2292,7 +2292,7 @@ public void createObject_defaultValueFromModelConstructor() {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                // create a DefaultValueConstructor with non-default primary key value
+                // Creates a DefaultValueConstructor with non-default primary key value.
                 realm.createObject(DefaultValueConstructor.class,
                         DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
             }
@@ -2311,7 +2311,7 @@ public void execute(Realm realm) {
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_INT,
                 DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);;
-        // default value for pk must be ignored
+        // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
                         DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
@@ -2351,7 +2351,7 @@ public void createObject_defaultValueSetterInConstructor() {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                // create a DefaultValueSetter with non-default primary key value
+                // Creates a DefaultValueSetter with non-default primary key value.
                 realm.createObject(DefaultValueSetter.class,
                         DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
             }
@@ -2370,7 +2370,7 @@ public void execute(Realm realm) {
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_INT,
                 DefaultValueSetter.FIELD_INT_DEFAULT_VALUE);
-        // default value for pk must be ignored
+        // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
                         DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
@@ -2476,7 +2476,7 @@ public void copyToRealm_defaultValuesAreIgnored() {
         assertEquals(1, managedObj.getFieldList().size());
         assertEquals(fieldListIntValue, managedObj.getFieldList().first().getFieldInt());
 
-        // make sure that excess object by default value is not created.
+        // Makes sure that excess object by default value is not created.
         assertEquals(2, realm.where(RandomPrimaryKey.class).count());
     }
 
@@ -2533,7 +2533,7 @@ public void copyFromRealm_defaultValuesAreIgnored() {
         assertEquals(managedObj.getFieldList().first().getFieldInt(), copy.getFieldList().first().getFieldInt());
     }
 
-    // Test close Realm in another thread different from where it is created.
+    // Tests close Realm in another thread different from where it is created.
     @Test
     public void close_differentThread() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
@@ -2553,7 +2553,7 @@ public void run() {
         });
         thatThread.start();
 
-        // Timeout should never happen
+        // Timeout should never happen.
         latch.await();
         if (threadAssertionError[0] != null) {
             throw threadAssertionError[0];
@@ -2571,7 +2571,7 @@ public void isClosed() {
         assertTrue(realm.isClosed());
     }
 
-    // Test Realm#isClosed() in another thread different from where it is created.
+    // Tests Realm#isClosed() in another thread different from where it is created.
     @Test
     public void isClosed_differentThread() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
@@ -2591,7 +2591,7 @@ public void run() {
         });
         thatThread.start();
 
-        // Timeout should never happen
+        // Timeout should never happen.
         latch.await();
         if (threadAssertionError[0] != null) {
             throw threadAssertionError[0];
@@ -2604,7 +2604,7 @@ public void run() {
 
     // Realm validation & initialization is done once, still ColumnIndices
     // should be populated for the subsequent Realm sharing the same configuration
-    // even if we skip initialization & validation
+    // even if we skip initialization & validation.
     @Test
     public void columnIndicesIsPopulatedWhenSkippingInitialization() throws Throwable {
         final RealmConfiguration realmConfiguration = configFactory.createConfiguration("columnIndices");
@@ -2616,7 +2616,7 @@ public void columnIndicesIsPopulatedWhenSkippingInitialization() throws Throwabl
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Realm realm = Realm.getInstance(realmConfiguration); // This will populate columnIndices
+                Realm realm = Realm.getInstance(realmConfiguration); // This will populate columnIndices.
                 try {
                     bgRealmOpened.countDown();
                     TestHelper.awaitOrFail(mainThreadRealmDone);
@@ -2634,7 +2634,7 @@ public void run() {
 
         TestHelper.awaitOrFail(bgRealmOpened);
         Realm realm = Realm.getInstance(realmConfiguration);
-        realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll(); // This would crash if columnIndices == null
+        realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll(); // This would crash if columnIndices == null.
         realm.close();
         mainThreadRealmDone.countDown();
         TestHelper.awaitOrFail(bgRealmClosed);
@@ -2656,7 +2656,7 @@ public void isInTransaction() {
         assertFalse(realm.isInTransaction());
     }
 
-    // test for https://github.com/realm/realm-java/issues/1646
+    // Test for https://github.com/realm/realm-java/issues/1646
     @Test
     public void closingRealmWhileOtherThreadIsOpeningRealm() throws Exception {
         final CountDownLatch startLatch = new CountDownLatch(1);
@@ -2686,11 +2686,11 @@ public void run() {
             }
         }.start();
 
-        // prevent for another thread to enter Realm.createAndValidate().
+        // Prevents for another thread to enter Realm.createAndValidate().
         synchronized (BaseRealm.class) {
             startLatch.countDown();
 
-            // wait for another thread's entering Realm.createAndValidate().
+            // Waits for another thread's entering Realm.createAndValidate().
             SystemClock.sleep(100L);
 
             realm.close();
@@ -2720,7 +2720,7 @@ public void openRealmWhileTransactionInAnotherThread() throws Exception {
         Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
-                // Step 2: Open realm in background thread.
+                // Step 2: Opens realm in background thread.
                 Realm realm = Realm.getInstance(realmConfig);
                 realmOpenedInBgLatch.countDown();
                 try {
@@ -2731,7 +2731,7 @@ public void run() {
                     return;
                 }
 
-                // Step 4: Start transaction in background
+                // Step 4: Starts transaction in background.
                 realm.beginTransaction();
                 transBeganInBgLatch.countDown();
                 try {
@@ -2739,7 +2739,7 @@ public void run() {
                 } catch (InterruptedException e) {
                     exception.add(e);
                 }
-                // Step 6: Cancel Transaction and close realm in background
+                // Step 6: Cancels Transaction and closes realm in background.
                 realm.cancelTransaction();
                 realm.close();
                 bgFinishedLatch.countDown();
@@ -2748,12 +2748,12 @@ public void run() {
         thread.start();
 
         realmOpenedInBgLatch.await();
-        // Step 3: Close all realm instances in foreground thread.
+        // Step 3: Closes all realm instances in foreground thread.
         realm.close();
         realmClosedInFgLatch.countDown();
         transBeganInBgLatch.await();
 
-        // Step 5: Get a new Realm instance in foreground
+        // Step 5: Gets a new Realm instance in foreground.
         realm = Realm.getInstance(realmConfig);
         fgFinishedLatch.countDown();
         bgFinishedLatch.await();
@@ -2845,10 +2845,10 @@ public void copyFromRealm_newCopyEachTime() {
         assertNotSame(unmanagedObject1, unmanagedObject2);
     }
 
-    // Test that the object graph is copied as it is and no extra copies are made
+    // Tests that the object graph is copied as it is and no extra copies are made.
     // 1) (A -> B/[B,C])
     // 2) (C -> B/[B,A])
-    // A copy should result in only 3 distinct objects
+    // A copy should result in only 3 distinct objects.
     @Test
     public void copyFromRealm_cyclicObjectGraph() {
         realm.beginTransaction();
@@ -2874,14 +2874,14 @@ public void copyFromRealm_cyclicObjectGraph() {
         assertEquals("B", copyB.getName());
         assertEquals("C", copyC.getName());
 
-        // Assert object equality on the object graph
+        // Asserts object equality on the object graph.
         assertTrue(copyA.getObject() == copyC.getObject());
         assertTrue(copyA.getObjects().get(0) == copyC.getObjects().get(0));
         assertTrue(copyA == copyC.getObjects().get(1));
         assertTrue(copyC == copyA.getObjects().get(1));
     }
 
-    // Test that for (A -> B -> C) for maxDepth = 1, result is (A -> B -> null)
+    // Tests that for (A -> B -> C) for maxDepth = 1, result is (A -> B -> null).
     @Test
     public void copyFromRealm_checkMaxDepth() {
         realm.beginTransaction();
@@ -2902,7 +2902,7 @@ public void copyFromRealm_checkMaxDepth() {
         assertNull(copyA.getObject().getObject());
     }
 
-    // Test that depth restriction is calculated from the top-most encountered object, i.e. it is possible for some
+    // Tests that depth restriction is calculated from the top-most encountered object, i.e. it is possible for some
     // objects to exceed the depth limit.
     // A -> B -> C -> D -> E
     // A -> D -> E
@@ -2927,8 +2927,8 @@ public void copyFromRealm_sameObjectDifferentDepths() {
         objA.setOtherObject(objD);
         realm.commitTransaction();
 
-        // object is filled before otherObject (because of field order - WARNING: Not guaranteed)
-        // this means that the object will be encountered first time at max depth, so E will not be copied.
+        // Object is filled before otherObject. (because of field order - WARNING: Not guaranteed)
+        // This means that the object will be encountered first time at max depth, so E will not be copied.
         // If the object cache does not handle this, otherObject will be wrong.
         CyclicType copyA = realm.copyFromRealm(objA, 3);
         assertEquals("E", copyA.getOtherObject().getObject().getName());
@@ -2953,7 +2953,7 @@ public void copyFromRealm_list_invalidDepthThrows() {
         realm.copyFromRealm(results, -1);
     }
 
-    // Test that the same Realm objects in a list result in the same Java in-memory copy.
+    // Tests that the same Realm objects in a list result in the same Java in-memory copy.
     // List: A -> [(B -> C), (B -> C)] should result in only 2 copied objects A and B and not A1, B1, A2, B2
     @Test
     public void copyFromRealm_list_sameElements() {
@@ -3006,7 +3006,7 @@ public void copyFromRealm_dynamicRealmListThrows() {
         }
     }
 
-    // Test if close can be called from Realm change listener when there is no other listeners
+    // Tests if close can be called from Realm change listener when there is no other listeners.
     @Test
     public void closeRealmInChangeListener() {
         realm.close();
@@ -3042,7 +3042,7 @@ public void execute(Realm realm) {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // Test if close can be called from Realm change listener when there is a listener on empty Realm Object
+    // Tests if close can be called from Realm change listener when there is a listener on empty Realm Object.
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject() {
@@ -3083,7 +3083,7 @@ public void execute(Realm realm) {
         });
     }
 
-    // Test if close can be called from Realm change listener when there is an listener on non-empty Realm Object
+    // Tests if close can be called from Realm change listener when there is an listener on non-empty Realm Object.
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnObject() {
@@ -3100,7 +3100,7 @@ public void onChange(Realm object) {
                     realm.removeChangeListener(this);
                     realm.close();
 
-                    // End test after next looper event to ensure that all listeners were called.
+                    // Ends test after next looper event to ensure that all listeners were called.
                     looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
@@ -3117,7 +3117,7 @@ public void run() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        // Step 1: Change listener on Realm Object
+        // Change listener on Realm Object.
         final AllTypes allTypes = realm.where(AllTypes.class).findFirst();
         allTypes.addChangeListener(dummyListener);
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -3128,7 +3128,7 @@ public void execute(Realm realm) {
         });
     }
 
-    // Test if close can be called from Realm change listener when there is an listener on RealmResults
+    // Tests if close can be called from Realm change listener when there is an listener on RealmResults.
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnResults() {
@@ -3156,7 +3156,7 @@ public void run() {
 
         realm.addChangeListener(listener);
 
-        // Step 1: Change listener on Realm results
+        // Change listener on Realm results.
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         results.addChangeListener(dummyListener);
 
@@ -3318,7 +3318,7 @@ public void waitForChange_emptyDataChange() throws InterruptedException {
         final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
         final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
 
-        // wait in background
+        // Waits in background.
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
         Thread thread = new Thread(new Runnable() {
             @Override
@@ -3348,7 +3348,7 @@ public void waitForChange_withDataChange() throws InterruptedException {
         final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
         final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
 
-        // wait in background
+        // Waits in background.
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
         Thread thread = new Thread(new Runnable() {
             @Override
@@ -3377,14 +3377,14 @@ public void waitForChange_syncBackgroundRealmResults() throws InterruptedExcepti
         final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
         final AtomicLong bgRealmResultSize = new AtomicLong(0);
 
-        // wait in background
+        // Wait in background
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
         Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-                // first make sure the results is empty
+                // First makes sure the results is empty.
                 bgRealmResultSize.set(results.size());
                 bgRealmOpened.countDown();
                 bgRealmChangeResult.set(realm.waitForChange());
@@ -3396,12 +3396,12 @@ public void run() {
         thread.start();
 
         TestHelper.awaitOrFail(bgRealmOpened);
-        // background result should be empty
+        // Background result should be empty.
         assertEquals(0, bgRealmResultSize.get());
         populateTestRealm();
         TestHelper.awaitOrFail(bgRealmClosed);
         assertTrue(bgRealmChangeResult.get());
-        // Once RealmResults are synchronized after waitForChange, the result size should be what we expect
+        // Once RealmResults are synchronized after waitForChange, the result size should be what we expect.
         assertEquals(TEST_DATA_SIZE, bgRealmResultSize.get());
     }
 
@@ -3412,7 +3412,7 @@ public void stopWaitForChange() throws InterruptedException {
         final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(true);
         final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
 
-        // wait in background
+        // Waits in background.
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -3432,7 +3432,7 @@ public void run() {
         assertFalse(bgRealmChangeResult.get());
     }
 
-    // Test if waitForChange doesn't blocks once stopWaitForChange has been called before.
+    // Tests if waitForChange doesn't blocks once stopWaitForChange has been called before.
     @Test
     public void waitForChange_stopWaitForChangeDisablesWaiting() throws InterruptedException {
         final CountDownLatch bgRealmOpened = new CountDownLatch(1);
@@ -3442,7 +3442,7 @@ public void waitForChange_stopWaitForChangeDisablesWaiting() throws InterruptedE
         final AtomicBoolean bgRealmSecondWaitResult = new AtomicBoolean(false);
         final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
 
-        // wait in background
+        // Waits in background.
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -3465,7 +3465,7 @@ public void run() {
         assertFalse(bgRealmSecondWaitResult.get());
     }
 
-    // Test if waitForChange still blocks if stopWaitForChange has been called for a realm in a different thread.
+    // Tests if waitForChange still blocks if stopWaitForChange has been called for a realm in a different thread.
     @Test
     public void waitForChange_blockSpecificThreadOnly() throws InterruptedException {
         final CountDownLatch bgRealmsOpened = new CountDownLatch(2);
@@ -3475,7 +3475,7 @@ public void waitForChange_blockSpecificThreadOnly() throws InterruptedException
         final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
         final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
 
-        // wait in background
+        // Waits in background.
         Thread thread1 = new Thread(new Runnable() {
             @Override
             public void run() {
@@ -3504,7 +3504,7 @@ public void run() {
 
         TestHelper.awaitOrFail(bgRealmsOpened);
         bgRealm.get().stopWaitForChange();
-        // wait for Thread 2 to wait
+        // Waits for Thread 2 to wait.
         Thread.sleep(500);
         populateTestRealm();
         TestHelper.awaitOrFail(bgRealmsClosed);
@@ -3513,7 +3513,7 @@ public void run() {
         assertEquals(TEST_DATA_SIZE, bgRealmWaitForChangeResult.get());
     }
 
-    // Check if waitForChange() does not respond to Thread.interrupt().
+    // Checks if waitForChange() does not respond to Thread.interrupt().
     @Test
     public void waitForChange_interruptingThread() throws InterruptedException {
         final CountDownLatch bgRealmOpened = new CountDownLatch(1);
@@ -3521,7 +3521,7 @@ public void waitForChange_interruptingThread() throws InterruptedException {
         final AtomicReference<Boolean> bgRealmWaitResult = new AtomicReference<Boolean>();
         final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
 
-        // wait in background
+        // Waits in background.
         Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
@@ -3536,14 +3536,14 @@ public void run() {
         thread.start();
 
         TestHelper.awaitOrFail(bgRealmOpened);
-        // make sure background thread goes to wait
+        // Makes sure background thread goes to wait.
         Thread.sleep(500);
-        // interrupting a thread should neither cause any side effect nor terminate the Background Realm from waiting.
+        // Interrupting a thread should neither cause any side effect nor terminate the Background Realm from waiting.
         thread.interrupt();
         assertTrue(thread.isInterrupted());
         assertEquals(null, bgRealmWaitResult.get());
 
-        // now we'll stop realm from waiting
+        // Now we'll stop realm from waiting.
         bgRealm.get().stopWaitForChange();
         TestHelper.awaitOrFail(bgRealmClosed);
         assertFalse(bgRealmWaitResult.get().booleanValue());
@@ -3579,7 +3579,7 @@ public void run() {
         assertEquals(IllegalStateException.class, bgError.getException().getClass());
     }
 
-    // Cannot wait inside of a transaction
+    // Cannot wait inside of a transaction.
     @Test(expected= IllegalStateException.class)
     public void waitForChange_illegalWaitInsideTransaction() {
         realm.beginTransaction();
@@ -3668,7 +3668,7 @@ public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
         final long nameIndex = catColumnInfo.nameIndex;
         final AtomicLong nameIndexNew = new AtomicLong(-1L);
 
-        // change column index of "name"
+        // Changes column index of "name".
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -3683,17 +3683,17 @@ public void execute(Realm realm) {
                 nameIndexNew.set(newIndex);
             }
         });
-        // we need ↓ to update index cache if the schema version was changed in the same thread.
+        // We need to update index cache if the schema version was changed in the same thread.
         realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
 
-        // check if the index was changed
+        // Checks if the index was changed.
         assertNotEquals(nameIndex, nameIndexNew);
 
-        // check if index in the ColumnInfo is updated
+        // Checks if index in the ColumnInfo is updated.
         assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
         assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
 
-        // check by actual get and set
+        // Checks by actual get and set.
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -3712,15 +3712,15 @@ public void getGlobalInstanceCount() {
         final RealmConfiguration config = configFactory.createConfiguration("globalCountTest");
         assertEquals(0, Realm.getGlobalInstanceCount(config));
 
-        // Open thread local Realm
+        // Opens thread local Realm.
         Realm realm = Realm.getInstance(config);
         assertEquals(1, Realm.getGlobalInstanceCount(config));
 
-        // Open thread local DynamicRealm
+        // Opens thread local DynamicRealm.
         DynamicRealm dynRealm = DynamicRealm.getInstance(config);
         assertEquals(2, Realm.getGlobalInstanceCount(config));
 
-        // Open Realm in another thread
+        // Opens Realm in another thread.
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -3744,11 +3744,11 @@ public void getLocalInstanceCount() {
         final RealmConfiguration config = configFactory.createConfiguration("localInstanceCount");
         assertEquals(0, Realm.getLocalInstanceCount(config));
 
-        // Open thread local Realm
+        // Opens thread local Realm.
         Realm realm = Realm.getInstance(config);
         assertEquals(1, Realm.getLocalInstanceCount(config));
 
-        // Open thread local DynamicRealm
+        // Opens thread local DynamicRealm.
         DynamicRealm dynRealm = DynamicRealm.getInstance(config);
         assertEquals(2, Realm.getLocalInstanceCount(config));
 
@@ -3761,7 +3761,7 @@ public void getLocalInstanceCount() {
     @Test
     public void namedPipeDirForExternalStorage() {
 
-        // test for https://github.com/realm/realm-java/issues/3140
+        // Test for https://github.com/realm/realm-java/issues/3140
         realm.close();
         realm = null;
 
@@ -3778,7 +3778,7 @@ public void namedPipeDirForExternalStorage() {
                 .build();
         Realm.deleteRealm(config);
 
-        // test if it works when the namedPipeDir is empty.
+        // Test if it works when the namedPipeDir is empty.
         Realm realmOnExternalStorage = Realm.getInstance(config);
         realmOnExternalStorage.close();
 
@@ -3786,7 +3786,7 @@ public void namedPipeDirForExternalStorage() {
 
         Assume.assumeTrue("SELinux is not enforced on this device.", TestHelper.isSelinuxEnforcing());
 
-        // Only check the fifo file created by call, since all Realm instances share the same fifo created by
+        // Only checks the fifo file created by call, since all Realm instances share the same fifo created by
         // external_commit_helper which might not be created in the newly created dir if there are Realm instances
         // are not deleted when TestHelper.deleteRecursively(namedPipeDir) called.
         File[] files = namedPipeDir.listFiles(new FilenameFilter() {
@@ -3797,7 +3797,7 @@ public boolean accept(File dir, String name) {
         });
         assertEquals(1, files.length);
 
-        // test if it works when the namedPipeDir and the named pipe files already exist.
+        // Tests if it works when the namedPipeDir and the named pipe files already exist.
         realmOnExternalStorage = Realm.getInstance(config);
         realmOnExternalStorage.close();
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index ba4898e4a3..09b5ebba2f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -68,13 +68,13 @@ public void looperTearDown() {
 
     @Before
     public void setUp() throws Exception {
-        // For non-LooperThread tests
+        // For non-LooperThread tests.
         realm = Realm.getInstance(configFactory.createConfiguration());
     }
 
     @After
     public void tearDown() throws Exception {
-        // For non-LooperThread tests
+        // For non-LooperThread tests.
         if (realm != null) {
             realm.close();
         }
@@ -600,7 +600,7 @@ public void realmResults_gcStressTest() {
         realm.commitTransaction();
 
         for (int i = 0; i < TEST_SIZE; i++) {
-            // Don't keep a reference to the Observable
+            // Doesn't keep a reference to the Observable.
             realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
                     .filter(new Func1<RealmResults<AllTypes>, Boolean>() {
                         @Override
@@ -608,11 +608,11 @@ public Boolean call(RealmResults<AllTypes> results) {
                             return results.isLoaded();
                         }
                     })
-                    .take(1) // Unsubscribes from Realm
+                    .take(1) // Unsubscribes from Realm.
                     .subscribe(new Action1<RealmResults<AllTypes>>() {
                         @Override
                         public void call(RealmResults<AllTypes> result) {
-                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 looperThread.testComplete();
@@ -643,7 +643,7 @@ public void dynamicRealmResults_gcStressTest() {
         realm.commitTransaction();
 
         for (int i = 0; i < TEST_SIZE; i++) {
-            // Don't keep a reference to the Observable
+            // Doesn't keep a reference to the Observable.
             realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
                     .filter(new Func1<RealmResults<DynamicRealmObject>, Boolean>() {
                         @Override
@@ -651,11 +651,11 @@ public Boolean call(RealmResults<DynamicRealmObject> results) {
                             return results.isLoaded();
                         }
                     })
-                    .take(1) // Unsubscribes from Realm
+                    .take(1) // Unsubscribes from Realm.
                     .subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
                         @Override
                         public void call(RealmResults<DynamicRealmObject> result) {
-                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 realm.close();
@@ -687,7 +687,7 @@ public void realmObject_gcStressTest() {
         realm.commitTransaction();
 
         for (int i = 0; i < TEST_SIZE; i++) {
-            // Don't keep a reference to the Observable
+            // Doesn't keep a reference to the Observable.
             realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<AllTypes>asObservable()
                     .filter(new Func1<AllTypes, Boolean>() {
                         @Override
@@ -695,11 +695,11 @@ public Boolean call(AllTypes obj) {
                             return obj.isLoaded();
                         }
                     })
-                    .take(1) // Unsubscribes from Realm
+                    .take(1) // Unsubscribes from Realm.
                     .subscribe(new Action1<AllTypes>() {
                         @Override
                         public void call(AllTypes result) {
-                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 looperThread.testComplete();
@@ -730,7 +730,7 @@ public void dynamicRealmObject_gcStressTest() {
         realm.commitTransaction();
 
         for (int i = 0; i < TEST_SIZE; i++) {
-            // Don't keep a reference to the Observable
+            // Doesn't keep a reference to the Observable.
             realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<DynamicRealmObject>asObservable()
                     .filter(new Func1<DynamicRealmObject, Boolean>() {
                         @Override
@@ -738,11 +738,11 @@ public Boolean call(DynamicRealmObject obj) {
                             return obj.isLoaded();
                         }
                     })
-                    .take(1) // Unsubscribes from Realm
+                    .take(1) // Unsubscribes from Realm.
                     .subscribe(new Action1<DynamicRealmObject>() {
                         @Override
                         public void call(DynamicRealmObject result) {
-                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 realm.close();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index bb2f61f4cb..0dabb5911e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -108,21 +108,21 @@ public void tearDown() {
     public void sortMultiFailures() {
         RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
 
-        // zero fields specified
+        // Zero fields specified.
         try {
             allTypes.sort(new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
-        // number of fields and sorting orders don't match
+        // Number of fields and sorting orders don't match.
         try {
             allTypes.sort(new String[]{FIELD_STRING}, ORDER_ASC_ASC);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
-        // null is not allowed
+        // Null is not allowed.
         try {
             allTypes.sort(null, (Sort[]) null);
             fail();
@@ -134,7 +134,7 @@ public void sortMultiFailures() {
         } catch (IllegalArgumentException ignored) {
         }
 
-        // non-existing field name
+        // Non-existing field name.
         try {
             allTypes.sort(new String[]{FIELD_STRING, "dont-exist"}, ORDER_ASC_ASC);
             fail();
@@ -169,7 +169,7 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
-        // Sorted Long (ascending), String (descending)
+        // Sorted Long (ascending), String (descending).
         // Expected output:
         // (4, "Adam"), row index = 2
         // (4, "Brian"), row index = 1
@@ -195,7 +195,7 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
-        // Sorted Long (ascending), String (descending)
+        // Sorted Long (ascending), String (descending).
         // Expected output:
         // (4, "Brian"), row index = 1
         // (4, "Adam"), row index = 2
@@ -221,7 +221,7 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
-        // Sorted String (ascending), Long (descending)
+        // Sorted String (ascending), Long (descending).
         // Expected output:
         // (5, "Adam"), row index = 0 - stable sort!
         // (5, "Adam"), row index = 3
@@ -303,14 +303,14 @@ public void realmSortTwoFields() {
     public void realmSortMultiFailures() {
         RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
 
-        // zero fields specified
+        // Zero fields specified.
         try {
             realm.where(AllTypes.class).findAll().sort(new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
-        // number of fields and sorting orders don't match
+        // Number of fields and sorting orders don't match.
         try {
             realm.where(AllTypes.class).findAll().
                     sort(new String[]{FIELD_STRING}, ORDER_ASC_ASC);
@@ -318,7 +318,7 @@ public void realmSortMultiFailures() {
         } catch (IllegalArgumentException ignored) {
         }
 
-        // null is not allowed
+        // Null is not allowed.
         try {
             realm.where(AllTypes.class).findAll().sort(null, (Sort[]) null);
             fail();
@@ -330,7 +330,7 @@ public void realmSortMultiFailures() {
         } catch (IllegalArgumentException ignored) {
         }
 
-        // non-existing field name
+        // Non-existing field name.
         try {
             realm.where(AllTypes.class).findAll().
                     sort(new String[]{FIELD_STRING, "dont-exist"}, ORDER_ASC_ASC);
@@ -369,7 +369,7 @@ public void run() {
         rr0.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
-                // After commit: [0, 1, 2, 3, 4] - most likely as order isn't guaranteed
+                // After commit: [0, 1, 2, 3, 4] - most likely as order isn't guaranteed.
                 assertEquals(5, element.size());
                 endTest.run();
             }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 0bbf6178a8..72de604064 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -101,7 +101,7 @@ public static RealmFieldType getColumnType(Object o) {
     }
 
     /**
-     * Creates an empty table with 1 column of all our supported column types, currently 9 columns
+     * Creates an empty table with 1 column of all our supported column types, currently 9 columns.
      *
      * @return
      */
@@ -141,7 +141,7 @@ public static InputStream stringToStream(String str) {
         return new ByteArrayInputStream(str.getBytes(Charset.forName("UTF-8")));
     }
 
-    // Creates a simple migration step in order to support null
+    // Creates a simple migration step in order to support null.
     // FIXME: generate a new encrypted.realm will null support
     public static RealmMigration prepareMigrationToNullSupportStep() {
         RealmMigration realmMigration = new RealmMigration() {
@@ -231,7 +231,7 @@ public int read() throws IOException {
         }
     }
 
-    // Alloc as much garbage as we can. Pass maxSize = 0 to use it.
+    // Allocs as much garbage as we can. Pass maxSize = 0 to use it.
     public static byte[] allocGarbage(int garbageSize) {
         if (garbageSize == 0) {
             long maxMemory = Runtime.getRuntime().maxMemory();
@@ -479,7 +479,7 @@ public static void populateTestRealmWithLongPrimaryKey(Realm testRealm, Long pri
 
     public static void populateTestRealmForNullTests(Realm testRealm) {
 
-        // Create 3 NullTypes objects. The objects are self-referenced (link) in
+        // Creates 3 NullTypes objects. The objects are self-referenced (link) in
         // order to test link queries.
         //
         // +-+--------+------+---------+--------+--------------------+
@@ -784,7 +784,7 @@ public static void awaitOrFail(CountDownLatch latch) {
     public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
         try {
             if (android.os.Debug.isDebuggerConnected()) {
-                // If we are debugging the tests, just wait without a timeout. In case we are stopping at a break point
+                // If we are debugging the tests, just waits without a timeout. In case we are stopping at a break point
                 // and timeout happens.
                 latch.await();
             } else if (!latch.await(numberOfSeconds, TimeUnit.SECONDS)) {
@@ -795,14 +795,14 @@ public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
         }
     }
 
-    // clean resource, shutdown the executor service & throw any background exception
+    // Cleans resource, shutdowns the executor service and throws any background exception.
     public static void exitOrThrow(final ExecutorService executorService,
                                    final CountDownLatch signalTestFinished,
                                    final CountDownLatch signalClosedRealm,
                                    final Looper[] looper,
                                    final Throwable[] throwable) throws Throwable {
 
-        // wait for the signal indicating the test's use case is done
+        // Waits for the signal indicating the test's use case is done.
         try {
             // Even if this fails we want to try as hard as possible to cleanup. If we fail to close all resources
             // properly, the `after()` method will most likely throw as well because it tries do delete any Realms
@@ -810,19 +810,19 @@ public static void exitOrThrow(final ExecutorService executorService,
             TestHelper.awaitOrFail(signalTestFinished);
         } finally {
             if (looper[0] != null) {
-                // failing to quit the looper will not execute the finally block responsible
-                // of closing the Realm
+                // Failing to quit the looper will not execute the finally block responsible
+                // of closing the Realm.
                 looper[0].quit();
             }
 
-            // wait for the finally block to execute & close the Realm
+            // Waits for the finally block to execute and closes the Realm.
             TestHelper.awaitOrFail(signalClosedRealm);
-            // Close the executor.
+            // Closes the executor.
             // This needs to be called after waiting since it might interrupt waitRealmThreadExecutorFinish().
             executorService.shutdownNow();
 
             if (throwable[0] != null) {
-                // throw any assertion errors happened in the background thread
+                // Throws any assertion errors happened in the background thread.
                 throw throwable[0];
             }
         }
@@ -958,7 +958,7 @@ public static void resetRealmThreadExecutor() throws NoSuchFieldException, Illeg
     }
 
     /**
-     * Wait and check if all tasks in BaseRealm.asyncTaskExecutor can be finished in 5 seconds, otherwise fail the test.
+     * Waits and checks if all tasks in BaseRealm.asyncTaskExecutor can be finished in 5 seconds, otherwise fails the test.
      */
     public static void waitRealmThreadExecutorFinish() {
         int counter = 50;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index 59d59b1c7c..54fb15250f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -78,11 +78,11 @@ public void setUp() {
 
     // ****************************************************************************************** //
     // UC 0.
-    // Callback should be notified if we create a RealmObject without the async mechanism
+    // Callback should be notified if we create a RealmObject without the async mechanism.
     // ex: using (createObject, copyOrUpdate, createObjectFromJson etc.)
     // ***************************************************************************************** //
 
-    //UC 0 using Realm.createObject
+    //UC 0 Uses Realm.createObject.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject() {
@@ -159,7 +159,7 @@ public void onChange(DynamicRealmObject object) {
         realm.commitTransaction();
     }
 
-    //UC 0 using Realm.copyToRealm
+    //UC 0 Uses Realm.copyToRealm.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealm() {
@@ -199,7 +199,7 @@ public void onChange(Dog object) {
         realm.commitTransaction();
     }
 
-    //UC 0 using Realm.copyToRealmOrUpdate
+    //UC 0 Uses Realm.copyToRealmOrUpdate.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealmOrUpdate() {
@@ -248,7 +248,7 @@ public void onChange(PrimaryKeyAsLong object) {
         assertEquals(primaryKeyAsLong, primaryKeyAsLong2);
     }
 
-    //UC 0 using Realm.copyToRealmOrUpdate
+    //UC 0 Uses Realm.copyToRealmOrUpdate.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson() {
@@ -300,7 +300,7 @@ public void onChange(AllTypes object) {
         }
     }
 
-    //UC 0 using Realm.copyToRealmOrUpdate
+    //UC 0 Uses Realm.copyToRealmOrUpdate.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
@@ -356,7 +356,7 @@ public void onChange(AllTypes object) {
         }
     }
 
-    //UC 0 using Realm.createOrUpdateObjectFromJson
+    //UC 0 Uses Realm.createOrUpdateObjectFromJson.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
@@ -424,7 +424,7 @@ public void onChange(AllTypesPrimaryKey object) {
         }
     }
 
-    //UC 0 using Realm.copyToRealmOrUpdate
+    //UC 0 Uses Realm.copyToRealmOrUpdate.
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson_from_JSONObject() throws JSONException {
@@ -477,8 +477,8 @@ public void onChange(AllTypesPrimaryKey object) {
 
     // ********************************************************************************* //
     // UC 1.
-    // Callback should be invoked after a relevant commit (one that should impact the
-    // query from which we obtained our RealmObject or RealmResults)
+    // Callback should be invoked after a relevant commit. (one that should impact the
+    // query from which we obtained our RealmObject or RealmResults.)
     // ********************************************************************************* //
     // UC 1 for Sync RealmObject
     @Test
@@ -486,7 +486,7 @@ public void onChange(AllTypesPrimaryKey object) {
     public void callback_with_relevant_commit_realmobject_sync() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Trigger global Realm change listener
+        // Step 1: Triggers global Realm change listener.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
@@ -497,7 +497,7 @@ public void callback_with_relevant_commit_realmobject_sync() {
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                // Step 4: Respond to relevant change
+                // Step 4: Responds to relevant change.
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals("Akamaru", dog.getName());
                 assertEquals(17, dog.getAge());
@@ -510,20 +510,20 @@ public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
-                        // Step 2: Trigger non-related commit
+                        // Step 2: Triggers non-related commit.
                         realm.beginTransaction();
                         realm.commitTransaction();
                         break;
 
                     case 2:
-                        // Step 3: Trigger related commit
+                        // Step 3: Triggers related commit.
                         realm.beginTransaction();
                         akamaru.setAge(17);
                         realm.commitTransaction();
                         break;
 
                     case 3:
-                        // Step 5: Complete test
+                        // Step 5: Completes test.
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -537,13 +537,13 @@ public void run() {
         });
     }
 
-    // UC 1 Async RealmObject
+    // UC 1 Async RealmObject.
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmobject_async() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Trigger global Realm change listener
+        // Step 1: Triggers global Realm change listener.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
@@ -563,7 +563,7 @@ public void onChange(Dog object) {
                         break;
 
                     case 2:
-                        // Step 4: Respond to relevant change
+                        // Step 4: Responds to relevant change.
                         assertEquals(17, dog.getAge());
                         break;
                 }
@@ -576,20 +576,20 @@ public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
-                        // Step 2: Trigger non-related commit
+                        // Step 2: Triggers non-related commit.
                         realm.beginTransaction();
                         realm.commitTransaction();
                         break;
 
                     case 2:
-                        // Step 3: Trigger related commit
+                        // Step 3: Triggers related commit.
                         realm.beginTransaction();
                         akamaru.setAge(17);
                         realm.commitTransaction();
                         break;
 
                     case 3:
-                        // Step 5: Complete test
+                        // Step 5: Completes test.
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -604,7 +604,7 @@ public void run() {
         });
     }
 
-    // UC 1 Async RealmObject
+    // UC 1 Async RealmObject.
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_from_different_looper_realmobject_async() {
@@ -635,7 +635,7 @@ public void onChange(Realm object) {
             @Override
             public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
-                    case 1: // triggered by COMPLETED_ASYNC_REALM_OBJECT from calling dog.load()
+                    case 1: // Triggered by COMPLETED_ASYNC_REALM_OBJECT from calling dog.load().
                         assertTrue(dog.isLoaded());
                         assertFalse(dog.isValid());
 
@@ -650,7 +650,7 @@ public void run() {
                             }
                         });
                         break;
-                    case 2: // triggered by the irrelevant commit (not affecting Dog table) from LooperThread1
+                    case 2: // Triggered by the irrelevant commit (not affecting Dog table) from LooperThread1.
                         assertTrue(dog.isLoaded());
                         assertFalse(dog.isValid());
 
@@ -658,7 +658,7 @@ public void run() {
                             @Override
                             public void run() {
                                 Realm realmLooperThread2 = Realm.getInstance(realm.getConfiguration());
-                                // trigger first callback invocation
+                                // Triggers first callback invocation.
                                 realmLooperThread2.beginTransaction();
                                 Dog dog = realmLooperThread2.createObject(Dog.class);
                                 dog.setName("Akamaru");
@@ -669,12 +669,12 @@ public void run() {
                         });
                         break;
 
-                    case 3: // triggered by relevant commit from LooperThread2
+                    case 3: // Triggered by relevant commit from LooperThread2.
                         assertEquals("Akamaru", dog.getName());
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                // trigger second callback invocation
+                                // Triggers second callback invocation.
                                 looperHandler3.post(new Runnable() {
                                     @Override
                                     public void run() {
@@ -692,9 +692,9 @@ public void run() {
                     case 4:
                         assertEquals("Akamaru", dog.getName());
                         assertEquals(17, dog.getAge());
-                        // posting as an event will give the handler a chance
-                        // to deliver the notification for globalCommitInvocations
-                        // otherwise, test will exit before the callback get a chance to be invoked
+                        // Posting as an event will give the handler a chance
+                        // to deliver the notification for globalCommitInvocations.
+                        // Otherwise, test will exit before the callback get a chance to be invoked.
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -716,7 +716,7 @@ public void run() {
 
     }
 
-    // UC 1 Async RealmObject
+    // UC 1 Async RealmObject.
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_from_different_non_looper_realmobject_async() throws Throwable {
@@ -736,7 +736,7 @@ public void onChange(Realm object) {
             @Override
             public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
-                    case 1:  // triggered by COMPLETED_ASYNC_REALM_OBJECT
+                    case 1:  // Triggered by COMPLETED_ASYNC_REALM_OBJECT.
                         new RealmBackgroundTask(realm.configuration) {
                             @Override
                             protected void doInBackground(Realm realm) {
@@ -746,7 +746,7 @@ protected void doInBackground(Realm realm) {
                         }.awaitOrFail();
                         break;
 
-                    case 2: {// triggered by the irrelevant commit (not affecting Dog table)
+                    case 2: {// Triggered by the irrelevant commit (not affecting Dog table).
                         assertTrue(dog.isLoaded());
                         assertFalse(dog.isValid());
                         new RealmBackgroundTask(realm.configuration) {
@@ -765,7 +765,7 @@ protected void doInBackground(Realm realm) {
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
-                                // trigger second callback invocation
+                                // Triggers second callback invocation.
                                 new Thread() {
                                     @Override
                                     public void run() {
@@ -784,9 +784,9 @@ public void run() {
                     case 4: {
                         assertEquals("Akamaru", dog.getName());
                         assertEquals(17, dog.getAge());
-                        // posting as an event will give the handler a chance
-                        // to deliver the notification for globalCommitInvocations
-                        // otherwise, test will exit before the callback get a chance to be invoked
+                        // Posting as an event will give the handler a chance
+                        // to deliver the notification for globalCommitInvocations.
+                        // Otherwise, test will exit before the callback get a chance to be invoked.
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -803,13 +803,13 @@ public void run() {
         });
     }
 
-    // UC 1 Sync RealmResults
+    // UC 1 Sync RealmResults.
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmresults_sync() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Trigger global Realm change listener
+        // Step 1: Triggers global Realm change listener.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
@@ -820,7 +820,7 @@ public void callback_with_relevant_commit_realmresults_sync() {
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
-                // Step 4: Respond to relevant change
+                // Step 4: Responds to relevant change.
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals(1, dogs.size());
                 assertEquals("Akamaru", dogs.get(0).getName());
@@ -834,20 +834,20 @@ public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
-                        // Step 2: Trigger non-related commit
+                        // Step 2: Triggers non-related commit.
                         realm.beginTransaction();
                         realm.commitTransaction();
                         break;
 
                     case 2:
-                        // Step 3: Trigger related commit
+                        // Step 3: Triggers related commit.
                         realm.beginTransaction();
                         akamaru.setAge(17);
                         realm.commitTransaction();
                         break;
 
                     case 3:
-                        // Step 5: Complete test
+                        // Step 5: Completes test.
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -860,13 +860,13 @@ public void run() {
         });
     }
 
-    // UC 1 Async RealmResults
+    // UC 1 Async RealmResults.
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmresults_async() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Trigger global Realm change listener
+        // Step 1: Triggers global Realm change listener.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
@@ -878,7 +878,7 @@ public void callback_with_relevant_commit_realmresults_async() {
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
-                // Step 4: Respond to relevant change
+                // Step 4: Responds to relevant change.
                 int commits = typebasedCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 2:
@@ -897,20 +897,20 @@ public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
-                        // Step 2: Trigger non-related commit
+                        // Step 2: Triggers non-related commit.
                         realm.beginTransaction();
                         realm.commitTransaction();
                         break;
 
                     case 2:
-                        // Step 3: Trigger related commit
+                        // Step 3: Triggers related commit.
                         realm.beginTransaction();
                         akamaru.setAge(17);
                         realm.commitTransaction();
                         break;
 
                     case 3:
-                        // Step 5: Complete test
+                        // Step 5: Completes test.
                         looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -925,9 +925,9 @@ public void run() {
 
     // ********************************************************************************* //
     // UC 2.
-    // Multiple callbacks should be invoked after a relevant commit
+    // Multiple callbacks should be invoked after a relevant commit.
     // ********************************************************************************* //
-    // UC 2 for Sync RealmObject
+    // UC 2 for Sync RealmObject.
     @Test
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmobject_sync() {
@@ -966,7 +966,7 @@ public void onChange(Dog object) {
         realm.commitTransaction();
     }
 
-    // UC 2 Async RealmObject
+    // UC 2 Async RealmObject.
     @Test
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmobject_async() {
@@ -1008,7 +1008,7 @@ public void onChange(Dog object) {
         realm.commitTransaction();
     }
 
-    // UC 2 Sync RealmResults
+    // UC 2 Sync RealmResults.
     @Test
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmresults_sync() {
@@ -1047,7 +1047,7 @@ public void onChange(RealmResults<Dog> object) {
         realm.commitTransaction();
     }
 
-    // UC 2 Async RealmResults
+    // UC 2 Async RealmResults.
     @Test
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmresults_async() {
@@ -1090,12 +1090,12 @@ public void onChange(RealmResults<Dog> object) {
 
     // ********************************************************************************* //
     // UC 3.
-    // Callback should be invoked when a non Looper thread commits
+    // Callback should be invoked when a non Looper thread commits.
     // ********************************************************************************* //
 
-    // UC 3 for Sync RealmObject
-    // 1. Add listener to RealmObject which is queried synchronized.
-    // 2. Commit transaction in another non-looper thread
+    // UC 3 for Sync RealmObject.
+    // 1. Adds listener to RealmObject which is queried synchronized.
+    // 2. Commits transaction in another non-looper thread.
     // 3. Listener on the RealmObject gets triggered.
     @Test
     @RunTestInLooperThread
@@ -1147,9 +1147,9 @@ public void run() {
         }
     }
 
-    // UC 3 Async RealmObject
-    // 1. Create RealmObject async query
-    // 2. Wait COMPLETED_ASYNC_REALM_OBJECT then commit transaction in another non-looper thread
+    // UC 3 Async RealmObject.
+    // 1. Creates RealmObject async query.
+    // 2. Waits COMPLETED_ASYNC_REALM_OBJECT then commits transaction in another non-looper thread.
     // 3. Listener on the RealmObject gets triggered again.
     @Test
     @RunTestInLooperThread
@@ -1158,7 +1158,7 @@ public void non_looper_thread_commit_realmobject_async() {
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                // Check if the 2nd transaction is committed.
+                // Checks if the 2nd transaction is committed.
                 if (realm.where(Dog.class).count() == 2) {
                     looperThread.postRunnable(new Runnable() {
                         @Override
@@ -1213,9 +1213,9 @@ public void onChange(Dog object) {
         thread.start();
     }
 
-    // UC 3 Sync RealmResults
-    // 1. Add listener to RealmResults which is queried synchronized.
-    // 2. Commit transaction in another non-looper thread
+    // UC 3 Sync RealmResults.
+    // 1. Adds listener to RealmResults which is queried synchronized.
+    // 2. Commits transaction in another non-looper thread.
     // 3. Listener on the RealmResults gets triggered.
     @Test
     @RunTestInLooperThread
@@ -1268,9 +1268,9 @@ public void run() {
         }
     }
 
-    // UC 3 Async RealmResults
-    // 1. Create RealmResults async query
-    // 2. Wait COMPLETED_ASYNC_REALM_RESULTS then commit transaction in another non-looper thread
+    // UC 3 Async RealmResults.
+    // 1. Creates RealmResults async query.
+    // 2. Waits COMPLETED_ASYNC_REALM_RESULTS then commits transaction in another non-looper thread.
     // 3. Listener on the RealmResults gets triggered again.
     @Test
     @RunTestInLooperThread
@@ -1313,7 +1313,7 @@ public void run() {
             public void onChange(RealmResults<Dog> object) {
                 typebasedCommitInvocations.incrementAndGet();
                 if (typebasedCommitInvocations.get() == 1) {
-                    // COMPLETED_ASYNC_REALM_RESULTS arrived
+                    // COMPLETED_ASYNC_REALM_RESULTS arrived.
                     thread.start();
                     try {
                         thread.join();
@@ -1328,7 +1328,7 @@ public void onChange(RealmResults<Dog> object) {
     // ****************************************************************************************** //
     // UC 4.
     // Callback should throw if registered on a non Looper thread.
-    // no tests for async RealmObject & RealmResults, since those already require a Looper thread
+    // No tests for async RealmObject & RealmResults, since those already require a Looper thread.
     // ***************************************************************************************** //
 
     // UC 4 for Realm
@@ -1362,7 +1362,7 @@ public void onChange(Realm object) {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // UC 4 for RealmObject
+    // UC 4 for RealmObject.
     @Test
     public void should_throw_on_non_looper_thread_realmobject() {
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
@@ -1394,7 +1394,7 @@ public void onChange(Dog object) {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // UC 4 RealmObject
+    // UC 4 RealmObject.
     @Test
     public void should_throw_on_non_looper_thread_realmresults() {
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
@@ -1426,14 +1426,14 @@ public void onChange(RealmResults<Dog> object) {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // Test modifying syncRealmResults in RealmResults's change listener
+    // Tests modifying syncRealmResults in RealmResults's change listener.
     @Test
     @RunTestInLooperThread
     public void change_realm_results_map_in_listener() throws InterruptedException {
         final CountDownLatch finishedLatch = new CountDownLatch(2);
 
         final Realm realm = looperThread.realm;
-        // Two results needed to make sure list modification happen while iterating
+        // Two results needed to make sure list modification happen while iterating.
         RealmResults<Owner> results1 = realm.where(Owner.class).findAll();
         RealmResults<Cat> results2 = realm.where(Cat.class).findAll();
         RealmChangeListener listener = new RealmChangeListener() {
@@ -1441,8 +1441,8 @@ public void change_realm_results_map_in_listener() throws InterruptedException {
             public void onChange(Object object) {
                 RealmResults<Owner> results = realm.where(Owner.class).findAll();
                 boolean foundKey = false;
-                // Check if the results has been added to the syncRealmResults in case of the behaviour of
-                // allObjects changes
+                // Checks if the results has been added to the syncRealmResults in case of the behaviour of
+                // allObjects changes.
                 for (WeakReference<RealmResults<? extends RealmModel>> weakReference :
                         realm.handlerController.syncRealmResults.keySet()) {
                     if (weakReference.get() == results) {
@@ -1465,8 +1465,8 @@ public void onChange(Object object) {
         realm.commitTransaction();
     }
 
-    // Build a RealmResults from a RealmList, and delete the RealmList. Test the behavior of ChangeListener on the
-// "invalid" RealmResults.
+    // Builds a RealmResults from a RealmList, and deletes the RealmList. Tests the behavior of ChangeListener on the
+    // "invalid" RealmResults.
     @Test
     @RunTestInLooperThread
     public void changeListener_onResultsBuiltOnDeletedLinkView() {
@@ -1495,16 +1495,16 @@ public void onChange(RealmResults<Dog> object) {
             }
         });
 
-        // Trigger the listener at the first time.
+        // Triggers the listener at the first time.
         realm.beginTransaction();
         allTypes.deleteFromRealm();
         realm.commitTransaction();
 
-        // Try to trigger the listener second time.
+        // Tries to trigger the listener second time.
         realm.beginTransaction();
         realm.commitTransaction();
 
-        // Close the realm and finish the test. This needs to follow the REALM_CHANGED in the queue.
+        // Closes the realm and finishes the test. This needs to follow the REALM_CHANGED in the queue.
         looperThread.postRunnable(new Runnable() {
             @Override
             public void run() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
index 97f3326534..20df1cb38a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
@@ -142,7 +142,7 @@ public void tearDown() {
 
     @Test
     public void unsupportedMethods_unManagedCollections() {
-        // RealmCollection methods
+        // RealmCollection methods.
         for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
             try {
                 switch (method) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
index d74ed31181..48e5847ef3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
@@ -84,11 +84,11 @@ public void tearDown() {
 
     @Test
     public void unsupportedMethods_unManagedCollections() {
-        // RealmCollection methods
+        // RealmCollection methods.
         for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
             try {
                 switch (method) {
-                    // Unsupported methods
+                    // Unsupported methods.
                     case WHERE: collection.where(); break;
                     case MIN: collection.min(AllJavaTypes.FIELD_LONG); break;
                     case MAX: collection.max(AllJavaTypes.FIELD_LONG); break;
@@ -98,7 +98,7 @@ public void unsupportedMethods_unManagedCollections() {
                     case MAX_DATE: collection.maxDate(AllJavaTypes.FIELD_DATE); break;
                     case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
 
-                    // Supported methods
+                    // Supported methods.
                     case IS_VALID: assertTrue(collection.isValid()); continue;
                     case IS_MANAGED: assertFalse(collection.isManaged()); continue;
                 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
index 66ad9a11c8..79552b2dbb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
@@ -16,6 +16,7 @@
 
 package io.realm.entities;
 
+import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.annotations.Ignore;
 
@@ -24,6 +25,14 @@
     public static final int HASHCODE = 1;
 
     private String name;
+    private RealmList<CustomMethods> methods;
+
+    public CustomMethods() {
+    }
+
+    public CustomMethods(String name) {
+        this.name = name;
+    }
 
     public String getName() {
         return name;
@@ -33,20 +42,19 @@ public void setName(String name) {
         this.name = name;
     }
 
-    @Ignore
-    public boolean reverseEquals;
+    public RealmList<CustomMethods> getMethods() {
+        return methods;
+    }
 
     @Override
     public boolean equals(Object o) {
-        if (!(o instanceof CustomMethods)) {
-            return reverseEquals;
-        }
-        CustomMethods other = (CustomMethods) o;
-        if (isManaged() == other.isManaged() && other.name.equals(name)) {
-            return !reverseEquals;
-        } else {
-            return reverseEquals;
-        }
+        if (this == o) return true;
+        if (o == null || !(o instanceof CustomMethods)) return false;
+
+        CustomMethods that = (CustomMethods) o;
+
+        // Only compare name. Managed and unmanaged objects will be equal as long as they have the same value
+        return name != null ? name.equals(that.name) : that.name == null;
     }
 
     @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenameAndAdd.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenameAndAdd.java
new file mode 100644
index 0000000000..bfe41a424b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenameAndAdd.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+
+
+public class MigrationFieldRenameAndAdd extends RealmObject {
+    private String string1; // to be renamed
+    private String string2;
+
+    public String getString1() {
+        return string1;
+    }
+
+    public void setString1(String string1) {
+        this.string1 = string1;
+    }
+
+    public String getString2() {
+        return string2;
+    }
+
+    public void setString2(String string2) {
+        this.string2 = string2;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationIndexedFieldRenamed.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationIndexedFieldRenamed.java
new file mode 100644
index 0000000000..7b48bacb02
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationIndexedFieldRenamed.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+
+public class MigrationIndexedFieldRenamed extends RealmObject {
+    @PrimaryKey
+    public long id;
+    @Index
+    public int oldTestField;
+    public Long testField;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java
index 93372b8aad..8dfdc64114 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java
@@ -45,11 +45,11 @@ public static MockActivityManager newInstance (RealmConfiguration realmConfigura
         return new MockActivityManager(realmConfiguration);
     }
 
-    // simulate a configuration change, that should trigger
+    // simulates a configuration change, that should trigger
     // to recreate the Lifecycle component
     public void sendConfigurationChange () {
         instance.onStop();
-        // create a new instance
+        // creates a new instance
         instance = LifecycleComponentFactory.newInstance(realmConfiguration);
         references.add(new WeakReference<Lifecycle>(instance, queue));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 8245069cb4..e7d133b948 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -381,14 +381,14 @@ public void testNullInputQuery() {
 
 
     public void testShouldFind() {
-        // Create a table
+        // Creates a table.
         Table table = new Table();
 
         table.addColumn(RealmFieldType.STRING, "username");
         table.addColumn(RealmFieldType.INTEGER, "score");
         table.addColumn(RealmFieldType.BOOLEAN, "completed");
 
-        // Insert some values
+        // Inserts some values.
         table.add("Arnold", 420, false);    // 0
         table.add("Jane", 770, false);      // 1 *
         table.add("Erik", 600, false);      // 2
@@ -398,26 +398,26 @@ public void testShouldFind() {
 
         TableQuery query = table.where().greaterThan(new long[]{1}, 600);
 
-        // find first match
+        // Finds first match.
         assertEquals(1, query.find());
         assertEquals(1, query.find());
         assertEquals(1, query.find(0));
         assertEquals(1, query.find(1));
-        // find next
+        // Finds next.
         assertEquals(3, query.find(2));
         assertEquals(3, query.find(3));
-        // find next
+        // Finds next.
         assertEquals(5, query.find(4));
         assertEquals(5, query.find(5));
 
-        // test backwards
+        // Tests backwards.
         assertEquals(5, query.find(4));
         assertEquals(3, query.find(3));
         assertEquals(3, query.find(2));
         assertEquals(1, query.find(1));
         assertEquals(1, query.find(0));
 
-        // test out of range
+        // Tests out of range.
         assertEquals(-1, query.find(6));
         try {  query.find(7);  fail("Exception expected");  } catch (ArrayIndexOutOfBoundsException e) {  }
     }
@@ -442,10 +442,10 @@ public void testQueryWithWrongDataType() {
 
         Table table = TestHelper.getTableWithAllColumnTypes();
 
-        // Query the table
+        // Queries the table.
         TableQuery query = table.where();
 
-        // Compare strings in non string columns
+        // Compares strings in non string columns.
         for (int i = 0; i <= 6; i++) {
             try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
             try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
@@ -455,7 +455,7 @@ public void testQueryWithWrongDataType() {
             try { query.contains(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
         }
 
-        // Compare integer in non integer columns
+        // Compares integer in non integer columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 5) {
                 try { query.equalTo(new long[]{i}, 123);                      assert(false); } catch(IllegalArgumentException e) {}
@@ -468,7 +468,7 @@ public void testQueryWithWrongDataType() {
             }
         }
 
-        // Compare float in non float columns
+        // Compares float in non float columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 4) {
                 try { query.equalTo(new long[]{i}, 123F);                     assert(false); } catch(IllegalArgumentException e) {}
@@ -481,7 +481,7 @@ public void testQueryWithWrongDataType() {
             }
         }
 
-        // Compare double in non double columns
+        // Compares double in non double columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 3) {
                 try { query.equalTo(new long[]{i}, 123D);                     assert(false); } catch(IllegalArgumentException e) {}
@@ -494,14 +494,14 @@ public void testQueryWithWrongDataType() {
             }
         }
 
-        // Compare boolean in non boolean columns
+        // Compares boolean in non boolean columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 1) {
               try { query.equalTo(new long[]{i}, true);                       assert(false); } catch(IllegalArgumentException e) {}
             }
         }
 
-        // Compare date
+        // Compares date.
         /* TODO:
         for (int i = 0; i <= 8; i++) {
             if (i != 2) {
@@ -520,7 +520,7 @@ public void testQueryWithWrongDataType() {
     public void testColumnIndexOutOfBounds() {
         Table table = TestHelper.getTableWithAllColumnTypes();
 
-        // Query the table
+        // Queries the table.
         TableQuery query = table.where();
 
         try { query.minimumInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
@@ -621,12 +621,12 @@ public void testColumnIndexOutOfBounds() {
     public void testQueryOnView() {
         Table table = new Table();
 
-        // Specify the column types and names
+        // Specifies the column types and names.
         table.addColumn(RealmFieldType.STRING, "firstName");
         table.addColumn(RealmFieldType.STRING, "lastName");
         table.addColumn(RealmFieldType.INTEGER, "salary");
 
-        // Add data to the table
+        // Adds data to the table.
         table.add("John", "Lee", 10000);
         table.add("Jane", "Lee", 15000);
         table.add("John", "Anderson", 20000);
@@ -648,12 +648,12 @@ public void testQueryOnView() {
     public void testQueryOnViewWithAlreadyQueriedTable() {
         Table table = new Table();
 
-        // Specify the column types and names
+        // Specifies the column types and names.
         table.addColumn(RealmFieldType.STRING, "firstName");
         table.addColumn(RealmFieldType.STRING, "lastName");
         table.addColumn(RealmFieldType.INTEGER, "salary");
 
-        // Add data to the table
+        // Adds data to the table.
         table.add("John", "Lee", 10000);
         table.add("Jane", "Lee", 15000);
         table.add("John", "Anderson", 20000);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
index 4272b7599e..ae15cbc29d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
@@ -49,23 +49,23 @@ void init() {
     public void testShouldTestSortedIntTable() {
         init();
 
-        // before first entry
+        // Before first entry.
         assertEquals(0, table.lowerBoundLong(0, 0));
         assertEquals(0, table.upperBoundLong(0, 0));
 
-        // find middle match
+        // Finds middle match.
         assertEquals(4, table.lowerBoundLong(0, 40));
         assertEquals(5, table.upperBoundLong(0, 40));
 
-        // find middle (nonexisting)
+        // Finds middle (nonexisting).
         assertEquals(5, table.lowerBoundLong(0, 41));
         assertEquals(5, table.upperBoundLong(0, 41));
 
-        // beyond last entry
+        // Beyond last entry.
         assertEquals(8, table.lowerBoundLong(0, 100));
         assertEquals(8, table.upperBoundLong(0, 100));
 
-        // find last match (duplicated)
+        // Finds last match (duplicated).
         assertEquals(6, table.lowerBoundLong(0, 60));
         assertEquals(8, table.upperBoundLong(0, 60));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
index a7c570267b..1241e4ba64 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
@@ -84,14 +84,14 @@ public void testGenericAddOnTable() {
 
                 Table t = new Table();
 
-                //If the objects matches no exception will be thrown
+                // If the objects matches no exception will be thrown.
                 if (value.get(i).getClass().equals(value.get(j).getClass())) {
                     assertTrue(true);
 
                 } else {
-                    //Add column
+                    // Adds column.
                     t.addColumn(TestHelper.getColumnType(value.get(j)), value.get(j).getClass().getSimpleName());
-                    //Add value
+                    // Adds value.
                     try {
                         t.add(value.get(i));
                         fail("No matching type");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 057b2f3009..ed9f4c41a7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -74,11 +74,11 @@ public void tableToString() {
     public void rowOperationsOnZeroRow(){
 
         Table t = new Table();
-        // Remove rows without columns
+        // Removes rows without columns.
         try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
         try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
 
-        // Column added, remove rows again
+        // Column added, remove rows again.
         t.addColumn(RealmFieldType.STRING, "");
         try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
         try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
@@ -89,7 +89,7 @@ public void rowOperationsOnZeroRow(){
     public void zeroColOperations() {
         Table tableZeroCols = new Table();
 
-        // Add rows
+        // Adds rows.
         try { tableZeroCols.add("val");         fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
         try { tableZeroCols.addEmptyRow();      fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
         try { tableZeroCols.addEmptyRows(10);   fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
@@ -215,7 +215,7 @@ public void getName() {
         //noinspection TryFinallyCanBeTryWithResources
         try {
 
-            // Write transaction must be run so we are sure a db exists with the correct table
+            // Writes transaction must be run so we are sure a db exists with the correct table.
             sharedRealm.beginTransaction();
             sharedRealm.getTable(TABLE_NAME);
             sharedRealm.commitTransaction();
@@ -231,14 +231,14 @@ public void getName() {
     public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
         for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
 
-            // All types supported addSearchIndex and removeSearchIndex
+            // All types supported addSearchIndex and removeSearchIndex.
             boolean exceptionExpected = (
                             t.getColumnType(colIndex) != RealmFieldType.STRING &&
                             t.getColumnType(colIndex) != RealmFieldType.INTEGER &&
                             t.getColumnType(colIndex) != RealmFieldType.BOOLEAN &&
                             t.getColumnType(colIndex) != RealmFieldType.DATE);
 
-            // Try to addSearchIndex()
+            // Tries to addSearchIndex().
             try {
                 t.addSearchIndex(colIndex);
                 if (exceptionExpected) {
@@ -247,9 +247,9 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
             } catch (IllegalArgumentException ignored) {
             }
 
-            // Try to removeSearchIndex()
+            // Tries to removeSearchIndex().
             try {
-                // Currently core will do nothing if the column doesn't have a search index
+                // Currently core will do nothing if the column doesn't have a search index.
                 t.removeSearchIndex(colIndex);
                 if (exceptionExpected) {
                     fail("Expected exception for colIndex " + colIndex);
@@ -258,7 +258,7 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
             }
 
 
-            // Try to hasSearchIndex() for all columnTypes
+            // Tries to hasSearchIndex() for all columnTypes.
             t.hasSearchIndex(colIndex);
         }
     }
@@ -278,17 +278,17 @@ public void tableNumbers() {
         t.addColumn(RealmFieldType.FLOAT, "floatCol");
         t.addColumn(RealmFieldType.STRING, "StringCol");
 
-        // Add 3 rows of data with same values in each column
+        // Adds 3 rows of data with same values in each column.
         t.add(1, 2.0d, 3.0f, "s1");
         t.add(1, 2.0d, 3.0f, "s1");
         t.add(1, 2.0d, 3.0f, "s1");
 
-        // Add other values
+        // Adds other values.
         t.add(10, 20.0d, 30.0f, "s10");
         t.add(100, 200.0d, 300.0f, "s100");
         t.add(1000, 2000.0d, 3000.0f, "s1000");
 
-        // Count instances of values added in the first 3 rows
+        // Counts instances of values added in the first 3 rows.
         assertEquals(3, t.count(0, 1));
         assertEquals(3, t.count(1, 2.0d));
         assertEquals(3, t.count(2, 3.0f));
@@ -297,20 +297,20 @@ public void tableNumbers() {
         assertEquals(3, t.findAllDouble(1, 2.0d).size());
         assertEquals(3, t.findAllFloat(2, 3.0f).size());
 
-        assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1
-        assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2
+        assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1.
+        assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2.
 
-        // Set double and float
+        // Sets double and float.
         t.setDouble(1, 2, -2.0d, false);
         t.setFloat(2, 2, -3.0f, false);
 
-        // Get double tests
+        // Gets double tests.
         assertEquals(-2.0d, t.getDouble(1, 2));
         assertEquals(20.0d, t.getDouble(1, 3));
         assertEquals(200.0d, t.getDouble(1, 4));
         assertEquals(2000.0d, t.getDouble(1, 5));
 
-        // Get float test
+        // Gets float test.
         assertEquals(-3.0f, t.getFloat(2, 2));
         assertEquals(30.0f, t.getFloat(2, 3));
         assertEquals(300.0f, t.getFloat(2, 4));
@@ -345,13 +345,13 @@ public void minimumDate() {
 
     }
 
-    // testing the migration of a string column to be nullable.
+    // Tests the migration of a string column to be nullable.
     @Test
     public void convertToNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
         for (RealmFieldType columnType : columnTypes) {
-            // testing various combinations of column names and nullability
+            // Tests various combinations of column names and nullability.
             String[] columnNames = {"foobar", "__TMP__0"};
             for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
                 for (String columnName : columnNames) {
@@ -427,7 +427,7 @@ public void convertToNotNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
         for (RealmFieldType columnType : columnTypes) {
-            // testing various combinations of column names and nullability
+            // Tests various combinations of column names and nullability.
             String[] columnNames = {"foobar", "__TMP__0"};
             for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
                 for (String columnName : columnNames) {
@@ -513,7 +513,7 @@ else if (columnType == RealmFieldType.INTEGER)
         }
     }
 
-    // add column and read back if it is nullable or not
+    // Adds column and read back if it is nullable or not.
     @Test
     public void isNullable() {
         Table table = new Table();
@@ -526,7 +526,7 @@ public void isNullable() {
 
     @Test
     public void defaultValue_setAndGet() {
-        // t is not used in this test
+        // t is not used in this test.
         t = null;
         final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
         //noinspection TryFinallyCanBeTryWithResources
@@ -544,8 +544,8 @@ public void defaultValue_setAndGet() {
                     new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234f),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, Math.PI),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, 0L)
-                    // currently, LIST does not support default value
-                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // Currently, LIST does not support default value.
+                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -605,7 +605,7 @@ public void defaultValue_setAndGet() {
             }
             sharedRealm.commitTransaction();
 
-            // check if the value can be read after committing transaction
+            // Checks if the value can be read after committing transaction.
             it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
                 Pair<RealmFieldType, Object> columnInfo = it.next();
@@ -649,7 +649,7 @@ public void defaultValue_setAndGet() {
 
     @Test
     public void defaultValue_setMultipleTimes() {
-        // t is not used in this test
+        // t is not used in this test.
         t = null;
         final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
         //noinspection TryFinallyCanBeTryWithResources
@@ -667,8 +667,8 @@ public void defaultValue_setMultipleTimes() {
                     new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
-                    // currently, LIST does not support default value
-                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // Currently, LIST does not support default value.
+                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -682,7 +682,7 @@ public void defaultValue_setMultipleTimes() {
 
             sharedRealm.beginTransaction();
             table.addEmptyRow();
-            table.addEmptyRow(); // for link field update
+            table.addEmptyRow(); // For link field update.
 
             ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
@@ -738,7 +738,7 @@ public void defaultValue_setMultipleTimes() {
             }
             sharedRealm.commitTransaction();
 
-            // check if the value can be read after committing transaction
+            // Checks if the value can be read after committing transaction.
             it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
                 Pair<RealmFieldType, Object> columnInfo = it.next();
@@ -781,7 +781,7 @@ public void defaultValue_setMultipleTimes() {
 
     @Test
     public void defaultValue_overwrittenByNonDefault() {
-        // t is not used in this test
+        // t is not used in this test.
         t = null;
         final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
         //noinspection TryFinallyCanBeTryWithResources
@@ -799,8 +799,8 @@ public void defaultValue_overwrittenByNonDefault() {
                     new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
-                    // currently, LIST does not support default value
-                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // Currently, LIST does not support default value.
+                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -814,9 +814,9 @@ public void defaultValue_overwrittenByNonDefault() {
 
             sharedRealm.beginTransaction();
             table.addEmptyRow();
-            table.addEmptyRow(); // for link field update
+            table.addEmptyRow(); // For link field update.
 
-            // set as default
+            // Sets as default.
             ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
                 Pair<RealmFieldType, Object> columnInfo = it.next();
@@ -854,7 +854,7 @@ public void defaultValue_overwrittenByNonDefault() {
             }
             sharedRealm.commitTransaction();
 
-            // update as non default
+            // Updates as non default.
             sharedRealm.beginTransaction();
             it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
@@ -901,7 +901,7 @@ public void defaultValue_overwrittenByNonDefault() {
             }
             sharedRealm.commitTransaction();
 
-            // check if the value was overwritten
+            // Checks if the value was overwritten.
             it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
                 Pair<RealmFieldType, Object> columnInfo = it.next();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
index 47ed416aaa..fa366ed50d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
@@ -98,7 +98,7 @@ public void setNull() {
         }
         sharedRealm.commitTransaction();
 
-        // check if TableView#setNull() worked as expected
+        // Checks if TableView#setNull() worked as expected
         for (int i = 0; i < table.size(); i++) {
             assertEquals("index: " + i, isOdd(i), table.isNull(STRING_COLUMN_INDEX, i));
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 661e6c1a6d..8ab65d077b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -36,14 +36,14 @@
 
     @Override
     public void setUp() {
-        //Specify table
+        // Specifies table.
         t = new Table();
         t.addColumn(RealmFieldType.STRING, "Name");
         t.addColumn(RealmFieldType.BOOLEAN,   "Study");
         t.addColumn(RealmFieldType.INTEGER,    "Age");
         t.addColumn(RealmFieldType.DATE,   "Birthday");
 
-        //Add data
+        // Adds data.
         t.add("cc", true,  24, date1);
         t.add("dd", false, 35, date2);
         t.add("bb", true,  22, date3);
@@ -56,7 +56,7 @@ public void setUp() {
     }
 
     public void testUnimplementedMethodsShouldFail() {
-        //Get a view containing all rows in table since you can only sort views currently.
+        // Gets a view containing all rows in table since you can only sort views currently.
         TableView view = t.where().findAll();
 
         try { view.upperBoundLong(0, 0); fail("Not implemented yet"); } catch (RuntimeException e ) { }
@@ -67,10 +67,10 @@ public void testUnimplementedMethodsShouldFail() {
 
 
     public void testShouldSortViewDate() {
-        //Get a view containing all rows in table since you can only sort views currently.
+        // Gets a view containing all rows in table since you can only sort views currently.
         TableView view = t.where().findAll();
 
-        //Sort without specifying the order, should default to ascending.
+        // Sorts without specifying the order, should default to ascending.
         view.sort(3);
         assertEquals(date3, view.getDate(3, 0));
         assertEquals(date2, view.getDate(3, 1));
@@ -81,10 +81,10 @@ public void testShouldSortViewDate() {
 
 
     public void testShouldSortViewIntegers() {
-        //Get a view containing all rows in table since you can only sort views currently.
+        // Gets a view containing all rows in table since you can only sort views currently.
         TableView view = t.where().findAll();
 
-        //Sort without specifying the order, should default to ascending.
+        // Sorts without specifying the order, should default to ascending.
         view.sort(2);
         assertEquals(22, view.getLong(2, 0));
         assertEquals(22, view.getLong(2, 1));
@@ -92,7 +92,7 @@ public void testShouldSortViewIntegers() {
         assertEquals(35, view.getLong(2, 3));
         assertEquals("dd", view.getString(0, 3));
 
-        //Sort descending - creating a new view
+        // Sorts descending - creating a new view.
         view.sort(2, Sort.DESCENDING);
         assertEquals(35, view.getLong(2, 0));
         assertEquals(24, view.getLong(2, 1));
@@ -100,7 +100,7 @@ public void testShouldSortViewIntegers() {
         assertEquals(22, view.getLong(2, 3));
         assertEquals("dd", view.getString(0, 0));
 
-        //Sort ascending.
+        // Sorts ascending.
         TableView view2 = t.where().findAll();
         view2.sort(2, Sort.ASCENDING);
         assertEquals(22, view2.getLong(2, 0));
@@ -109,7 +109,7 @@ public void testShouldSortViewIntegers() {
         assertEquals(35, view2.getLong(2, 3));
         assertEquals("dd", view2.getString(0, 3));
 
-        // Check that old view is still the same
+        // Checks that old view is still the same.
         assertEquals(35, view.getLong(2, 0));
         assertEquals(24, view.getLong(2, 1));
         assertEquals(22, view.getLong(2, 2));
@@ -221,10 +221,10 @@ public void testGetSourceRowNoRows() {
         t.addColumn(RealmFieldType.STRING, "");
         t.addColumn(RealmFieldType.INTEGER, "");
         t.addColumn(RealmFieldType.BOOLEAN, "");
-        // No data is added
+        // No data is added.
         TableView v = t.where().findAll();
 
-        // Out of bound
+        // Out of bound.
         try { assertEquals(0, v.getSourceRowIndex(0));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
         try { assertEquals(0, v.getSourceRowIndex(1));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
     }
@@ -232,20 +232,20 @@ public void testGetSourceRowNoRows() {
 
     public void testGetSourceRowEmptyTable() {
         Table t = new Table();
-        // No columns
+        // No columns.
         TableView v = t.where().findAll();
 
-        // Out of bound
+        // Out of bound.
         try { assertEquals(0, v.getSourceRowIndex(0));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
         try { assertEquals(0, v.getSourceRowIndex(1));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
     }
 
 
     public void testShouldSortViewBool() {
-        //Get a view containing all rows in table since you can only sort views currently.
+        // Gets a view containing all rows in table since you can only sort views currently.
         TableView view = t.where().findAll();
 
-        //Sort without specifying the order, should default to ascending.
+        // Sorts without specifying the order, should default to ascending.
         view.sort(1);
         assertEquals(false, view.getBoolean(1, 0));
         assertEquals(false, view.getBoolean(1, 1));
@@ -368,22 +368,22 @@ public void testViewShouldInvalidate() {
         t.add(3);
 
         TableView view = t.where().equalTo(new long[]{0}, 2).findAll();
-        // access view is ok.
+        // Access view is ok.
         assertEquals(1, view.size());
 
-        // access view after change in value is ok
+        // Access view after change in value is ok.
         t.setLong(0, 0, 3, false);
         accessingViewOk(view);
 
-        // access view after additions to table must fail
+        // Access view after additions to table must fail.
         t.add(4);
         accessingViewMustThrow(view);
 
-        // recreate view to access again
+        // Recreates view to access again.
         view = t.where().equalTo(new long[]{0}, 2).findAll();
         accessingViewOk(view);
 
-        // Removing any row in Table should invalidate view
+        // Removing any row in Table should invalidate view.
         t.remove(3);
         accessingViewMustThrow(view);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index 3ba437ac44..cbf00b2ceb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -84,7 +84,7 @@ private Table getTableWithIntegerPrimaryKey() {
         return t;
     }
 
-    // Test that primary key constraints are actually removed
+    // Tests that primary key constraints are actually removed.
     @Test
     public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         RealmConfiguration config = configFactory.createConfigurationBuilder()
@@ -96,14 +96,14 @@ public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         tbl.addColumn(RealmFieldType.STRING, "name");
         tbl.setPrimaryKey("name");
 
-        // Create first entry with name "Foo"
+        // Creates first entry with name "Foo".
         tbl.setString(0, tbl.addEmptyRow(), "Foo", false);
 
         long rowIndex = tbl.addEmptyRow();
         try {
-            tbl.setString(0, rowIndex, "Foo", false); // Try to create 2nd entry with name Foo
+            tbl.setString(0, rowIndex, "Foo", false); // Tries to create 2nd entry with name Foo.
         } catch (RealmPrimaryKeyConstraintException e1) {
-            tbl.setPrimaryKey(""); // Primary key check worked, now remove it and try again.
+            tbl.setPrimaryKey(""); // Primary key check worked, now removes it and tries again.
             try {
                 tbl.setString(0, rowIndex, "Foo", false);
                 return;
@@ -190,7 +190,7 @@ public void migratePrimaryKeyTableIfNeeded_second() throws IOException {
         assertEquals("AnnotationTypes", sharedRealm.getTable("pk").getString(0, 0));
     }
 
-    // See https://github.com/realm/realm-java/issues/1775 .
+    // See https://github.com/realm/realm-java/issues/1775
     // Before 0.84.2, pk table added prefix "class_" to every class's name.
     // After 0.84.2, the pk table should be migrated automatically to remove the "class_".
     // In 0.84.2, the class names in pk table has been renamed to some incorrect names like "Thclass", "Mclass",
@@ -236,14 +236,14 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         long classColumn = pkTable.getColumnIndex("pk_table");
         pkTable.removeSearchIndex(classColumn);
 
-        // Try to add a pk for another table
+        // Tries to add a pk for another table.
         Table table2 = sharedRealm.getTable("TestTable2");
         long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table2.addSearchIndex(column2);
         try {
             table2.setPrimaryKey(column2);
         } catch (RealmError ignored) {
-            // Column has no search index
+            // Column has no search index.
         }
 
         assertFalse(pkTable.hasSearchIndex(classColumn));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index b0b339e230..074f535542 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -175,16 +175,16 @@ public void onSchemaVersionChanged(long currentVersion) {
 
         sharedRealm.beginTransaction();
         try {
-            // listener is not called if there was no schema change
+            // Listener is not called if there was no schema change.
             assertFalse(listenerCalled.get());
 
-            // change the schema version
+            // Changes the schema version.
             sharedRealm.setSchemaVersion(before + 1);
         } finally {
             sharedRealm.commitTransaction();
         }
 
-        // listener is not yet called
+        // Listener is not yet called.
         assertFalse(listenerCalled.get());
 
         sharedRealm.beginTransaction();
@@ -213,18 +213,18 @@ public void onSchemaVersionChanged(long currentVersion) {
         final long before = sharedRealm.getSchemaVersion();
 
         sharedRealm.refresh();
-        // listener is not called if there was no schema change
+        // Listener is not called if there was no schema change.
         assertFalse(listenerCalled.get());
 
         sharedRealm.beginTransaction();
         try {
-            // change the schema version
+            // Changes the schema version.
             sharedRealm.setSchemaVersion(before + 1);
         } finally {
             sharedRealm.commitTransaction();
         }
 
-        // listener is not yet called
+        // Listener is not yet called.
         assertFalse(listenerCalled.get());
 
         sharedRealm.refresh();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index 751158bc98..ab4261f680 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -42,7 +42,7 @@ void init() {
     public void testShouldTestDistinct() {
         init();
 
-        // Must set index before using distinct()
+        // Must set index before using distinct().
         table.addSearchIndex(1);
         assertEquals(true, table.hasSearchIndex(1));
 
@@ -56,14 +56,14 @@ public void testShouldTestDistinct() {
 
 // TODO: parametric test
 /*    *//**
-     * Should throw exception if trying to get distinct on columns where index has not been set
+     * Should throw exception if trying to get distinct on columns where index has not been set.
      * @param index
      *//*
 
     @Test(expectedExceptions = UnsupportedOperationException.class, dataProvider = "columnIndex")
     public void shouldTestDistinctErrorWhenNoIndex(Long index) {
 
-        //Get a table with all available column types
+        // Gets a table with all available column types.
         Table t = TestHelper.getTableWithAllColumnTypes();
 
         TableView view = table.getDistinctView(1);
@@ -81,12 +81,12 @@ public void testShouldTestDistinctErrorWhenIndexOutOfBounds() {
     }
 
     /**
-     * Check that Index can be set on multiple columns, with the String
+     * Checks that Index can be set on multiple columns, with the String.
      * @param
      */
     public void testShouldTestSettingIndexOnMultipleColumns() {
 
-        //Create a table only with String type columns
+        // Creates a table only with String type columns
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "col1");
         t.addColumn(RealmFieldType.STRING, "col2");
@@ -115,10 +115,10 @@ public void testShouldTestSettingIndexOnMultipleColumns() {
     @Test(expectedExceptions = IllegalArgumentException.class, dataProvider = "columnIndex")
     public void shouldTestIndexOnWrongColumnType(Long index) {
 
-        //Get a table with all available column types
+        // Gets a table with all available column types.
         Table t = TestHelper.getTableWithAllColumnTypes();
 
-        //If column type is String, then throw the excepted exception
+        // If column type is String, then throw the excepted exception.
         if (t.getColumnType(index).equals(RealmFieldType.STRING)){
             throw new IllegalArgumentException();
         }
@@ -155,7 +155,7 @@ public void testRemoveSearchIndexNoop() {
         init();
         assertEquals(false, table.hasSearchIndex(1));
 
-        // remove index from non-indexed column is a no-op
+        // Removes index from non-indexed column is a no-op.
         table.removeSearchIndex(1);
         assertEquals(false, table.hasSearchIndex(1));
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
index ce52c272cb..42958d93fc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
@@ -89,40 +89,40 @@ public void testParseISO8601Dates() throws ParseException {
         Date dateZeroMillis = cal.getTime();
         cal.set(Calendar.SECOND, 0);
 
-        // Parse date with short time and decimal second
+        // Parses date with short time and decimal second.
         Date d = JsonUtils.stringToDate("2007-08-13T195123.789Z");
         assertEquals(date, d);
 
-        // Short time without decimal second
+        // Short time without decimal second.
         d = JsonUtils.stringToDate("2007-08-13T195123Z");
         assertEquals(dateZeroMillis, d);
 
-        // GMT+2 with decimal second
+        // GMT+2 with decimal second.
         d = JsonUtils.stringToDate("2007-08-13T215123.789+02:00");
         assertEquals(date, d);
 
-        // Tests without time
+        // Tests without time.
         cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);
         cal.set(Calendar.MILLISECOND, 0);
         cal.setTimeZone(TimeZone.getTimeZone("GMT"));
         Date dateWithoutTime = cal.getTime();
 
-        // Date only with hyphens
+        // Date only with hyphens.
         d = JsonUtils.stringToDate("2007-08-13Z");
         assertEquals(dateWithoutTime, d);
 
-        // Date, no hyphens
+        // Date, no hyphens.
         d = JsonUtils.stringToDate("20070813Z");
         assertEquals(dateWithoutTime, d);
 
-        // Hyphenated Date with empty time
+        // Hyphenated Date with empty time.
         d = JsonUtils.stringToDate("2007-08-13+00:00");
         assertEquals(dateWithoutTime, d);
 
-        // Non-hyphenated date with empty time
+        // Non-hyphenated date with empty time.
         d = JsonUtils.stringToDate("20070813+00:00");
         assertEquals(dateWithoutTime, d);
 
-        // Please see the ISO8601UtilsTest.java file for a full suite of ISO8601 tests
+        // Please see the ISO8601UtilsTest.java file for a full suite of ISO8601 tests.
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index cf4041c3d2..b81238326a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -148,7 +148,7 @@ public void run() {
                     // These exceptions should only come from TestHelper.awaitOrFail()
                     testException = error;
                 } finally {
-                    // Try as hard as possible to close down gracefully, while still keeping all exceptions intact.
+                    // Tries as hard as possible to close down gracefully, while still keeping all exceptions intact.
                     try {
                         after();
                     } catch (Throwable e) {
@@ -220,7 +220,7 @@ public void postRunnableDelayed(Runnable runnable, long delayMillis) {
     }
 
     /**
-     * Tear down logic which is guaranteed to run after the looper test has either completed or failed.
+     * Tears down logic which is guaranteed to run after the looper test has either completed or failed.
      * This will run on the same thread as the looper test.
      */
     public void looperTearDown() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index d02a0ea22b..65e81bdea4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -75,7 +75,7 @@ protected void before() throws Throwable {
 
     @Override
     protected void after() {
-        // Wait all async tasks done to ensure successful deleteRealm call.
+        // Waits all async tasks done to ensure successful deleteRealm call.
         // This will throw when timeout. And the reason of timeout needs to be solved properly.
         TestHelper.waitRealmThreadExecutorFinish();
 
@@ -84,7 +84,7 @@ protected void after() {
                 Realm.deleteRealm(configuration);
             }
         } catch (IllegalStateException e) {
-            // Only throw the exception caused by deleting the opened Realm if the test case itself doesn't throw.
+            // Only throws the exception caused by deleting the opened Realm if the test case itself doesn't throw.
             if (!unitTestFailed) {
                 throw e;
             }
@@ -151,7 +151,7 @@ public void copyRealmFromAssets(Context context, String realmPath, String newNam
     }
 
     public void copyRealmFromAssets(Context context, String realmPath, RealmConfiguration config) throws IOException {
-        // Delete the existing file before copy
+        // Deletes the existing file before copy
         Realm.deleteRealm(config);
 
         File outFile = new File(config.getRealmDirectory(), config.getRealmFileName());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
index 54c724abd2..78c7c18575 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -46,8 +46,8 @@ private Step(int message) {
 
         abstract void run();
 
-        // Pass a null to tell main process that everything is OK.
-        // Otherwise, pass a error String which will be used by assertion in main process.
+        // Passes a null to tell main process that everything is OK.
+        // Otherwise, passes a error String which will be used by assertion in main process.
         protected void response(String error) {
             try {
                 Message msg = Message.obtain(null, message);
@@ -117,7 +117,7 @@ public void handleMessage(Message msg) {
         }
     }
 
-    // Call this function to return the String of current class and line number.
+    // Calls this function to return the String of current class and line number.
     private static String currentLine() {
         StackTraceElement element = new Throwable().getStackTrace()[1];
         return element.getClassName() + " line " + element.getLineNumber() + ": ";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java b/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java
index f630cb8a4a..65005f63c6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java
@@ -51,7 +51,7 @@
     private Throwable exception;
 
     /**
-     * Sets the exception held by this container. This is a one-shot operation.
+     * Sets the exception held by this container. This is an one-shot operation.
      *
      * @param throwable error to save.
      * @throws IllegalStateException if an exception have already been put into this holder.
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index a9646a0bea..54a87b468c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -22,6 +22,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.when;
@@ -39,10 +40,10 @@ public void setUp() {
     @Test
     public void realmLogin() throws URISyntaxException, JSONException {
         Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
-        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.value() + "/default"));
+        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default"));
 
         JSONObject obj = new JSONObject(request.toJson());
-        assertEquals("/" + t.value() + "/default", obj.get("path"));
+        assertEquals("/" + t.identity() + "/default", obj.get("path"));
         assertEquals(t.value(), obj.get("data"));
         assertEquals("realm", obj.get("provider"));
     }
@@ -60,10 +61,10 @@ public void userLogin() throws URISyntaxException, JSONException {
     @Test
     public void userRefresh() throws URISyntaxException, JSONException {
         Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
-        AuthenticateRequest request = AuthenticateRequest.userRefresh(t);
+        AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default"));
 
         JSONObject obj = new JSONObject(request.toJson());
-        assertFalse(obj.has("path"));
+        assertTrue(obj.has("path"));
         assertEquals(t.value(), obj.get("data"));
         assertEquals("realm", obj.get("provider"));
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 58203b7461..35038d786a 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -72,13 +72,6 @@ public void setUp() {
     public void tearDown() throws Exception {
     }
 
-    @Test
-    public void user() {
-//        new SyncConfiguration.Builder(context);
-        // Check that user can be added
-        // That the default local path is correct
-    }
-
     @Test
     public void user_invalidUserThrows() {
         try {
@@ -115,6 +108,47 @@ public void serverUrl_setsFolderAndFileName() {
         }
     }
 
+    @Test
+    public void serverUrl_flexibleInput() {
+        // Check that the serverUrl accept a wide range of input
+        Object[][] fuzzyInput = {
+                // Only path -> Use auth server as basis for server url, but ignore port if set
+                { createTestUser("http://ros.realm.io/auth"),      "/~/default", "realm://ros.realm.io/~/default" },
+                { createTestUser("http://ros.realm.io:7777/auth"), "/~/default", "realm://ros.realm.io/~/default" },
+                { createTestUser("https://ros.realm.io/auth"),     "/~/default", "realms://ros.realm.io/~/default" },
+                { createTestUser("https://127.0.0.1/auth"),        "/~/default", "realms://127.0.0.1/~/default" },
+
+                { createTestUser("http://ros.realm.io/auth"),      "~/default",  "realm://ros.realm.io/~/default" },
+                { createTestUser("http://ros.realm.io:7777/auth"), "~/default",  "realm://ros.realm.io/~/default" },
+                { createTestUser("https://ros.realm.io/auth"),     "~/default",  "realms://ros.realm.io/~/default" },
+                { createTestUser("https://127.0.0.1/auth"),        "~/default",  "realms://127.0.0.1/~/default" },
+
+                // Check that the same name used for server and name doesn't crash
+                { createTestUser("http://ros.realm.io/auth"),      "~/ros.realm.io",  "realm://ros.realm.io/~/ros.realm.io" },
+
+                // Forgot schema -> Use the one from the auth url
+                { createTestUser("http://ros.realm.io/auth"), "ros.realm.io/~/default", "realm://ros.realm.io/~/default" },
+                { createTestUser("http://ros.realm.io/auth"), "//ros.realm.io/~/default", "realm://ros.realm.io/~/default" },
+                { createTestUser("https://ros.realm.io/auth"), "ros.realm.io/~/default", "realms://ros.realm.io/~/default" },
+                { createTestUser("https://ros.realm.io/auth"), "//ros.realm.io/~/default", "realms://ros.realm.io/~/default" },
+
+                // Automatically replace http|https with realm|realms
+                { createTestUser(), "http://ros.realm.io/~/default", "realm://ros.realm.io/~/default" },
+                { createTestUser(), "https://ros.realm.io/~/default", "realms://ros.realm.io/~/default" }
+        };
+
+        for (Object[] test : fuzzyInput) {
+            SyncUser user = (SyncUser) test[0];
+            String serverUrlInput = (String) test[1];
+            String resolvedServerUrl = ((String) test[2]).replace("~", user.getIdentity());
+
+            SyncConfiguration config = new SyncConfiguration.Builder(user, serverUrlInput).build();
+
+            assertEquals(String.format("Input '%s' did not resolve correctly.", serverUrlInput),
+                    resolvedServerUrl, config.getServerUrl().toString());
+        }
+    }
+
     @Test
     public void serverUrl_invalidUrlThrows() {
         String[] invalidUrls = {
@@ -130,7 +164,6 @@ public void serverUrl_invalidUrlThrows() {
             "realm://objectserver.realm.io/~/Αθήνα", // Non-ascii
             "realm://objectserver.realm.io/~/foo/../bar", // .. is not allowed
             "realm://objectserver.realm.io/~/foo/./bar", // . is not allowed
-            "http://objectserver.realm.io/~/default", // wrong scheme
         };
 
         for (String invalidUrl : invalidUrls) {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 27f92b0dce..116fab3a23 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -57,7 +57,7 @@
     @BeforeClass
     public static void initUserStore() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        UserStore userStore = new RealmFileUserStore(InstrumentationRegistry.getTargetContext().getFilesDir().getPath());
+        UserStore userStore = new RealmFileUserStore();
         SyncManager.setUserStore(userStore);
     }
 
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
index da65aab166..5515532e22 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
@@ -48,7 +48,7 @@ public static SpannerConfig getConfiguration(String className) {
         ResultProcessor csvResultProcessor = new CSVResultProcessor(csvFile);
 
         // General configuration for running benchmarks.
-        // Always save result files. CI will determine if it wants to store them.
+        // Always saves result files. CI will determine if it wants to store them.
         SpannerConfig.Builder builder = new SpannerConfig.Builder()
                 .saveResults(resultsDir, className + ".json")
                 .trialsPrExperiment(1)
@@ -62,10 +62,10 @@ public static SpannerConfig getConfiguration(String className) {
                 )
                 .addResultProcessor(csvResultProcessor);
 
-        // Only use baseline file if it exists
+        // Only uses baseline file if it exists.
         if (baselineFile.exists()) {
             builder.useBaseline(baselineFile);
-            // Test that 25. , 50. and 75. percentile don't change by more than 15%
+            // Tests that 25. , 50. and 75. percentile doesn't change by more than 15%.
             builder.percentileFailureLimit(25f, 0.15f);
             builder.percentileFailureLimit(50f, 0.15f);
             builder.percentileFailureLimit(75f, 0.15f);
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
index 9a11c14fb2..f8737f2fb2 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
@@ -31,7 +31,7 @@
  * Converts the result of a benchmark to CSV for easier processing by other data/graph programs.
  *
  * Output is the following.
- * methodname, trialNumber, params, measurements, min, max, average, 25pct, 50pct, 75pct
+ * methodname, trialNumber, params, measurements, min, max, average, 25pct, 50pct, 75pct.
  */
 public class CSVResultProcessor implements ResultProcessor {
 
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index dadf5648c1..5b84b34a76 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -77,7 +77,11 @@ if (NOT EXISTS ${core_lib_PATH})
 endif()
 
 add_library(lib_realm_core STATIC IMPORTED)
-set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH})
+
+# -latomic is not set by default for mips and armv5.
+# See https://code.google.com/p/android/issues/detail?id=182094
+set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH}
+                                                IMPORTED_LINK_INTERFACE_LIBRARIES atomic)
 
 # Sync static library
 set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
@@ -94,7 +98,8 @@ if (NOT EXISTS ${sync_lib_PATH})
     endif()
 endif()
 add_library(lib_realm_sync STATIC IMPORTED)
-set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH})
+set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH}
+                                                IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
 
 # build application's shared lib
 include_directories(${REALM_CORE_DIST_DIR}/include
@@ -172,12 +177,11 @@ endif()
 
 add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC} ${objectstore_sync_SRC})
 add_dependencies(realm-jni jni_headers)
-# -latomic is not set by default for mips. See https://code.google.com/p/android/issues/detail?id=182094
+
 if (build_SYNC)
-# FIXME: The order matters! lib_realm_sync needs to be in front of lib_realm_core!! Find out why!!
-target_link_libraries(realm-jni log android atomic lib_realm_sync lib_realm_core)
+    target_link_libraries(realm-jni log android lib_realm_sync)
 else()
-target_link_libraries(realm-jni log android atomic lib_realm_core)
+    target_link_libraries(realm-jni log android lib_realm_core)
 endif()
 
 # Strip the release so files and backup the unstripped versions
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index e4a0a4a60f..076fb54292 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -85,16 +85,6 @@ Java_io_realm_RealmFileUserStore_nativeLogoutUser (JNIEnv *env, jclass, jstring
 }
 
 
-JNIEXPORT void JNICALL
-Java_io_realm_RealmFileUserStore_nativeConfigureMetaDataSystem (JNIEnv *env, jclass, jstring baseFile)
-{
-    TR_ENTER()
-    try {
-        JStringAccessor base_file_path(env, baseFile); // throws
-        SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
-    } CATCH_STD()
-}
-
 JNIEXPORT jobjectArray JNICALL
 Java_io_realm_RealmFileUserStore_nativeGetAllUsers (JNIEnv *env, jclass)
 {
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 0ebca0f031..2950979535 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 0ebca0f03141f52131d6d9f0e6b2f2e32ab9a56d
+Subproject commit 29509795357df374f88950ee471a57900b97ecdf
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index e35fbdb309..15da4a803c 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -68,7 +68,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (RealmFileException& e) {
-        ss << e.what() << " (" <<  e.underlying() <<  ") in " << file << " line " << line;
+        ss << e.what() << " (" <<  e.underlying() << ") (" << e.path() << ") in " << file << " line " << line;
         ThrowRealmFileException(env, ss.str(), e.kind());
     }
     catch (File::AccessError& e) {
diff --git a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
index b0f1c194ae..f54d8bc330 100644
--- a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
@@ -44,7 +44,7 @@ public void notifyCommitByLocalThread() {
             return;
         }
 
-        // Force any updates on the current thread to the front the queue. Doing this is mostly
+        // Forces any updates on the current thread to the front the queue. Doing this is mostly
         // relevant on the UI thread where it could otherwise process a motion event before the
         // REALM_CHANGED event. This could in turn cause a UI component like ListView to crash. See
         // https://github.com/realm/realm-android-adapters/issues/11 for such a case.
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index f03be41aa0..d3f1a7f70c 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -281,7 +281,7 @@ public void stopWaitForChange() {
         RealmCache.invokeWithLock(new RealmCache.Callback0() {
             @Override
             public void onCall() {
-                // Check if the Realm instance has been closed
+                // Checks if the Realm instance has been closed.
                 if (sharedRealm == null || sharedRealm.isClosed()) {
                     throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
                 }
@@ -378,7 +378,7 @@ protected void checkIfValid() {
             throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
         }
 
-        // Check if we are in the right thread
+        // Checks if we are in the right thread.
         if (threadId != Thread.currentThread().getId()) {
             throw new IllegalStateException(BaseRealm.INCORRECT_THREAD_MESSAGE);
         }
@@ -391,7 +391,7 @@ protected void checkIfInTransaction() {
     }
 
     /**
-     * Check if the Realm is valid and in a transaction.
+     * Checks if the Realm is valid and in a transaction.
      */
     protected void checkIfValidAndInTransaction() {
         if (!isInTransaction()) {
@@ -400,7 +400,7 @@ protected void checkIfValidAndInTransaction() {
     }
 
     /**
-     * Check if the Realm is not built with a SyncRealmConfiguration
+     * Checks if the Realm is not built with a SyncRealmConfiguration.
      */
     void checkNotInSync() {
         if (configuration.isSyncConfiguration()) {
@@ -657,7 +657,7 @@ public void onResult(int count) {
         }
     }
 
-    // Return true if this Realm can receive notifications.
+    // Returns true if this Realm can receive notifications.
     boolean hasValidNotifier() {
         return sharedRealm.realmNotifier != null && sharedRealm.realmNotifier.isValid();
     }
@@ -673,7 +673,7 @@ protected void finalize() throws Throwable {
         super.finalize();
     }
 
-    // Internal delegate for migrations
+    // Internal delegate for migrations.
     protected interface MigrationCallback {
         void migrationComplete();
     }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 619b92ca60..1d35df1b8c 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -402,7 +402,7 @@ public void set(String fieldName, Object value) {
         boolean isString = (value instanceof String);
         String strValue = isString ? (String) value : null;
 
-        // Do implicit conversion if needed
+        // Does implicit conversion if needed.
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         if (isString && type != RealmFieldType.STRING) {
@@ -426,7 +426,7 @@ public void set(String fieldName, Object value) {
         }
     }
 
-    // Automatically finds the appropriate setter based on the objects type
+    // Automatically finds the appropriate setter based on the objects type.
     private void setValue(String fieldName, Object value) {
         Class<?> valueClass = value.getClass();
         if (valueClass == Boolean.class) {
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index fa24bff167..db6c1d3f1b 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -53,19 +53,19 @@
 
     private final static Boolean NO_REALM_QUERY = Boolean.TRUE;
 
-    // Keep a strong reference to the registered RealmChangeListener
-    // user should unregister those listeners
+    // Keeps a strong reference to the registered RealmChangeListener.
+    // User should unregister those listeners.
     final CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>> changeListeners = new CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>>();
 
-    // Keep a weak reference to the registered RealmChangeListener those are Weak since
-    // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener
+    // Keeps a weak reference to the registered RealmChangeListener those are Weak since
+    // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener.
     final List<WeakReference<RealmChangeListener<? extends BaseRealm>>> weakChangeListeners =
             new CopyOnWriteArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>();
 
     final BaseRealm realm;
     private boolean autoRefresh; // Requires a Looper thread to be true.
 
-    // pending update of async queries
+    // Pending update of async queries.
     private Future updateAsyncQueriesTask;
 
     private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueAsyncRealmResults =
@@ -73,19 +73,19 @@
     private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueSyncRealmResults =
             new ReferenceQueue<RealmResults<? extends RealmModel>>();
     final ReferenceQueue<RealmModel> referenceQueueRealmObject = new ReferenceQueue<RealmModel>();
-    // keep a WeakReference list to RealmResults obtained asynchronously in order to update them
+    // Keeps a WeakReference list to RealmResults obtained asynchronously in order to update them
     // RealmQuery is not WeakReferenced to prevent it from being GC'd. RealmQuery should be
     // cleaned if RealmResults is cleaned. we need to keep RealmQuery because it contains the query
     // pointer (to handover for each update) + all the arguments necessary to rerun the query:
     // sorting orders, soring columns, type (findAll, findFirst, findAllSorted etc.)
     final Map<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<? extends RealmModel>> asyncRealmResults =
             new IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<? extends RealmModel>>();
-    // Keep a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
+    // Keeps a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
     // the query in the background for each commit, until we got a valid Row (pointer)
     final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> emptyAsyncRealmObject =
             new ConcurrentHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
 
-    // Keep a reference to the list of sync RealmResults, we'll use it
+    // Keeps a reference to the list of sync RealmResults, we'll use it
     // to deliver type based notification once the shared_group advance
     final IdentitySet<WeakReference<RealmResults<? extends RealmModel>>> syncRealmResults =
             new IdentitySet<WeakReference<RealmResults<? extends RealmModel>>>();
@@ -133,13 +133,13 @@ public boolean handleMessage(Message message) {
                     break;
 
                 case HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES:
-                    // this is called once the background thread completed the update of the async queries
+                    // This is called once the background thread completed the update of the async queries.
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncQueriesUpdate(result);
                     break;
 
                 case HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION:
-                    // Don't fail silently in the background in case of Core exception
+                    // Doesn't fail silently in the background in case of Core exception.
                     throw (Error) message.obj;
 
                 default:
@@ -160,7 +160,7 @@ public boolean handleMessage(Message message) {
      * @param onSuccess onSuccess callback to run for the async transaction that completed.
      */
     public void handleAsyncTransactionCompleted(Runnable onSuccess) {
-        // Same reason as handleMessage()
+        // Same reason as handleMessage().
         if (realm.sharedRealm != null) {
             if (onSuccess != null) {
                 pendingOnSuccessAsyncTransactionCallbacks.add(onSuccess);
@@ -189,7 +189,7 @@ void addChangeListenerAsWeakReference(RealmChangeListener<? extends BaseRealm> l
             WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iterator.next();
             RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
 
-            // Collect all listeners that are GC'ed
+            // Collects all listeners that are GC'ed.
             if (weakListener == null) {
                 if (toRemoveList == null) {
                     toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
@@ -197,7 +197,7 @@ void addChangeListenerAsWeakReference(RealmChangeListener<? extends BaseRealm> l
                 toRemoveList.add(weakRef);
             }
 
-            // Check if Listener already exists
+            // Checks if Listener already exists.
             if (weakListener == listener) {
                 addListener = false;
             }
@@ -217,7 +217,7 @@ void removeWeakChangeListener(RealmChangeListener<? extends BaseRealm> listener)
             WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = weakChangeListeners.get(i);
             RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
 
-            // Collect all listeners that are GC'ed or we need to remove
+            // Collects all listeners that are GC'ed or we need to remove.
             if (weakListener == null || weakListener == listener) {
                 if (toRemoveList == null) {
                     toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
@@ -241,13 +241,13 @@ void removeAllChangeListeners() {
      * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
      */
     private void notifyGlobalListeners() {
-        // notify strong reference listener
+        // Notifies strong reference listener.
         Iterator<RealmChangeListener<? extends BaseRealm>> iteratorStrongListeners = changeListeners.iterator();
-        while (!realm.isClosed() && iteratorStrongListeners.hasNext()) { // every callback could close the realm
+        while (!realm.isClosed() && iteratorStrongListeners.hasNext()) { // Every callback could close the realm.
             RealmChangeListener listener = iteratorStrongListeners.next();
             listener.onChange(realm);
         }
-        // notify weak reference listener (internals)
+        // Notifies weak reference listener (internals).
         Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iteratorWeakListeners = weakChangeListeners.iterator();
         List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         while (!realm.isClosed() && iteratorWeakListeners.hasNext()) {
@@ -300,25 +300,25 @@ private void updateAsyncEmptyRealmObject() {
      */
     void notifyAllListeners(List<RealmResults<? extends RealmModel>> realmResultsToBeNotified) {
 
-        // Notify all RealmResults (async and synchronous).
+        // Notifies all RealmResults (async and synchronous).
         for (Iterator<RealmResults<? extends RealmModel>> it = realmResultsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
             RealmResults<? extends RealmModel> realmResults = it.next();
             realmResults.notifyChangeListeners(false);
         }
 
-        // Notify all loaded RealmObjects
+        // Notifies all loaded RealmObjects.
         notifyRealmObjectCallbacks();
 
-        // Re-run any async single objects that are still not loaded.
+        // Re-runs any async single objects that are still not loaded.
         // TODO: Why is this here? This was not called in `completedAsyncQueriesUpdate()`. Problem?
         if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
             updateAsyncEmptyRealmObject();
         }
 
-        // Notify any completed async transactions
+        // Notifies any completed async transactions.
         notifyAsyncTransactionCallbacks();
 
-        // Trigger global listeners last.
+        // Triggers global listeners last.
         // Note that NotificationTest.callingOrdersOfListeners will fail if orders change.
         notifyGlobalListeners();
     }
@@ -340,7 +340,7 @@ private void collectRealmResultsCallbacks(Iterator<WeakReference<RealmResults<?
             if (realmResults == null) {
                 iterator.remove();
             } else {
-                // Sync the RealmResult so it is completely up to date.
+                // Syncs the RealmResult so it is completely up to date.
                 // This is a prerequisite to calling the listener, so when the listener is finally triggered, all
                 // RealmResults will be up to date.
                 // Local commits can accidentially cause async RealmResults to be notified, so we only want to
@@ -367,7 +367,7 @@ private void notifyRealmObjectCallbacks() {
 
             } else {
                 if (realmObject.realmGet$proxyState().getRow$realm().isAttached()) {
-                    // It should be legal to modify realmObjects in the listener
+                    // It should be legal to modify realmObjects in the listener.
                     objectsToBeNotified.add(realmObject);
                 } else if (realmObject.realmGet$proxyState().getRow$realm() != Row.EMPTY_ROW) {
                     iterator.remove();
@@ -383,25 +383,25 @@ private void notifyRealmObjectCallbacks() {
 
     private void updateAsyncQueries() {
         if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
-            // try to cancel any pending update since we're submitting a new one anyway
+            // Tries to cancel any pending update since we're submitting a new one anyway.
             updateAsyncQueriesTask.cancel(true);
             Realm.asyncTaskExecutor.getQueue().remove(updateAsyncQueriesTask);
             RealmLog.trace("REALM_CHANGED realm: %s cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates", HandlerController.this);
         }
         RealmLog.trace("REALM_CHANGED realm: %s updating async queries, total: %d", HandlerController.this, asyncRealmResults.size());
-        // prepare a QueryUpdateTask to current async queries in this thread
+        // Prepares a QueryUpdateTask to current async queries in this thread.
         QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
                 .realmConfiguration(realm.getConfiguration());
         QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;
 
-        // we iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch)
+        // We iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch).
         Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
         while (iterator.hasNext()) {
             Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>> entry = iterator.next();
             WeakReference<RealmResults<? extends RealmModel>> weakReference = entry.getKey();
             RealmResults<? extends RealmModel> realmResults = weakReference.get();
             if (realmResults == null) {
-                // GC'd instance remove from the list
+                // GC'd instance remove from the list.
                 iterator.remove();
 
             } else {
@@ -410,12 +410,12 @@ private void updateAsyncQueries() {
                         entry.getValue().getArgument());
             }
 
-            // Note: we're passing an WeakRef of a RealmResults to another thread
-            //       this is safe as long as we don't invoke any of the RealmResults methods.
-            //       we're just using it as a Key in an IdentityHashMap (i.e doesn't call
+            // Note: We're passing an WeakRef of a RealmResults to another thread.
+            //       This is safe as long as we don't invoke any of the RealmResults methods.
+            //       We're just using it as a Key in an IdentityHashMap (i.e doesn't call
             //       AbstractList's hashCode, that require accessing objects from another thread)
             //
-            //       watch out when you debug, as you're IDE try to evaluate RealmResults
+            //       Watch out when you debug, as you're IDE try to evaluate RealmResults
             //       which break the Thread confinement constraints.
         }
         if (realmResultsQueryStep != null) {
@@ -432,7 +432,7 @@ private void realmChanged(boolean localCommit) {
         deleteWeakReferences();
         boolean threadContainsAsyncQueries = threadContainsAsyncQueries();
 
-        // Mixing local transactions and async queries has unavoidable race conditions
+        // Mixing local transactions and async queries has unavoidable race conditions.
         if (localCommit && threadContainsAsyncQueries) {
             RealmLog.warn("Mixing asynchronous queries with local writes should be avoided. " +
                     "Realm will convert any async queries to synchronous in order to remain consistent. Use " +
@@ -441,11 +441,11 @@ private void realmChanged(boolean localCommit) {
         }
 
         if (!localCommit && threadContainsAsyncQueries) {
-            // For changes from other threads, swallow the change and re-run async queries first.
+            // For changes from other threads, swallows the change and re-runs async queries first.
             updateAsyncQueries();
         } else {
             // Following cases handled by this:
-            // localCommit && threadContainsAsyncQueries (this is the case the warning above is about)
+            // localCommit && threadContainsAsyncQueries (This is the case the warning above is about.)
             // localCommit && !threadContainsAsyncQueries
             // !localCommit && !threadContainsAsyncQueries
             realm.sharedRealm.refresh();
@@ -471,14 +471,14 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                 SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                 int compare = callerVersionID.compareTo(result.versionID);
                 if (compare == 0) {
-                    // if the RealmResults is empty (has not completed yet) then use the value
-                    // otherwise a task (grouped update) has already updated this RealmResults
+                    // If the RealmResults is empty (has not completed yet) then uses the value,
+                    // Otherwise a task (grouped update) has already updated this RealmResults.
                     if (!realmResults.isLoaded()) {
                         RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s same versions, using results (RealmResults is not loaded)",
                                 weakRealmResults, HandlerController.this);
-                        // swap pointer
+                        // Swaps pointer.
                         realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
-                        // notify callbacks
+                        // Notifies callbacks.
                         realmResults.syncIfNeeded();
                         realmResults.notifyChangeListeners(false);
                     } else {
@@ -487,14 +487,14 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                     }
 
                 } else if (compare > 0) {
-                    // we have two use cases:
-                    // 1- this RealmResults is not empty, this means that after we started the async
+                    // We have two use cases:
+                    // 1- This RealmResults is not empty, this means that after we started the async
                     //    query, we received a REALM_CHANGE that triggered an update of all async queries
                     //    including the last async submitted, so no need to use the provided TableView pointer
-                    //    (or the user forced the sync behaviour .load())
-                    // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread
-                    //    this could happen if the current thread advanced the shared_group (via a write or refresh)
-                    //    this means that we need to rerun the query against a newer worker thread.
+                    //    (or the user forced the sync behaviour .load()).
+                    // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread.
+                    //    This could happen if the current thread advanced the shared_group (via a write or refresh).
+                    //    This means that we need to rerun the query against a newer worker thread.
 
                     if (!realmResults.isLoaded()) { // UC2
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
@@ -518,7 +518,7 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                     }
 
                 } else {
-                    // the caller thread is behind the worker thread,
+                    // The caller thread is behind the worker thread,
                     // no need to rerun the query, since we're going to receive the update signal
                     // & batch update all async queries including this one
                     // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
@@ -532,24 +532,24 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
         SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
         int compare = callerVersionID.compareTo(result.versionID);
         if (compare > 0) {
-            // if the caller thread is more advanced than the worker thread, it means it did a local commit.
+            // If the caller thread is more advanced than the worker thread, it means it did a local commit.
             // This should also have put a REALM_CHANGED event on the Looper queue, so ignoring this result should
             // be safe as all async queries will be rerun when processing the REALM_CHANGED event.
             RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is more advanced, Looper will updates queries", HandlerController.this);
 
         } else {
-            // We're behind or on the same version as the worker thread
+            // We're behind or on the same version as the worker thread.
 
-            // only advance if we're behind
+            // Only advances if we're behind.
             if (compare != 0) {
-                // no need to remove old pointers from TableView, since they're
-                // imperative TV, they will not rerun if the SharedGroup advance
+                // No need to remove old pointers from TableView, since they're
+                // imperative TV, they will not rerun if the SharedGroup advance.
 
                 // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                 RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is behind advance_read", HandlerController.this);
-                // refresh the Realm to the version provided by the worker thread
+                // Refreshes the Realm to the version provided by the worker thread
                 // (advanceRead to the latest version may cause a version mismatch error) preventing us
-                // from importing correctly the handover table view
+                // from importing correctly the handover table view.
                 try {
                     realm.sharedRealm.refresh(result.versionID);
                 } catch (BadVersionException e) {
@@ -567,11 +567,11 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = query.getKey();
                 RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
                 if (realmResults == null) {
-                    // don't update GC'd instance
+                    // Doesn't update GC'd instance.
                     asyncRealmResults.remove(weakRealmResults);
 
                 } else {
-                    // update the instance with the new pointer
+                    // Updates the instance with the new pointer.
                     realmResults.swapTableViewPointer(query.getValue());
                     realmResults.syncIfNeeded();
                     resultsToBeNotified.add(realmResults);
@@ -590,7 +590,7 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
     }
 
     /**
-     * Trigger onSuccess for all completed async transaction.
+     * Triggers onSuccess for all completed async transaction.
      * <p>
      * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
      */
@@ -613,12 +613,12 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
             if (proxy != null) {
                 SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                 int compare = callerVersionID.compareTo(result.versionID);
-                // we always query on the same version
-                // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
-                if (compare == 0) { //same version import the handover
+                // We always query on the same version.
+                // Only two use cases could happen 1. We're on the same version or 2. The caller has advanced in the meanwhile.
+                if (compare == 0) { // Same version import the handover.
                     long rowPointer = result.updatedRow.get(realmObjectWeakReference);
                     if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
-                        // cleanup a previously empty async RealmObject
+                        // Cleanups a previously empty async RealmObject.
                         emptyAsyncRealmObject.remove(realmObjectWeakReference);
                         realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
                     }
@@ -626,15 +626,14 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                     proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                 } else if (compare > 0) {
-                    // the caller has advanced we need to
-                    // retry against the current version of the caller if it's still empty
-                    if (RealmObject.isLoaded(proxy)) { // already completed & has a valid pointer no need to re-run
+                    // The caller has advanced we need to
+                    // retry against the current version of the caller if it's still empty.
+                    if (RealmObject.isValid(proxy)) { // Already completed & has a valid pointer no need to re-run.
                         if (RealmObject.isValid(proxy)) {
                             RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s], realm: %s. " +
                                             "RealmObject is already loaded, just notify it",
                                     realm, HandlerController.this);
                             proxy.realmGet$proxyState().notifyChangeListeners$realm();
-
                         }
                     } else {
                         RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s, realm: %s. " +
@@ -642,7 +641,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                                 proxy, HandlerController.this);
                         Object value = realmObjects.get(realmObjectWeakReference);
                         RealmQuery<? extends RealmModel> realmQuery;
-                        if (value == null || value == NO_REALM_QUERY) { // this is a retry of an empty RealmObject
+                        if (value == null || value == NO_REALM_QUERY) { // This is a retry of an empty RealmObject.
                             realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);
 
                         } else {
@@ -661,11 +660,11 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                         Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
                     }
                 } else {
-                    // should not happen, since the the background thread position itself against the provided version
-                    // and the caller thread can only go forward (advance_read)
+                    // Should not happen, since the the background thread position itself against the provided version
+                    // and the caller thread can only go forward (advance_read).
                     throw new IllegalStateException("Caller thread behind the Worker thread");
                 }
-            } // else: element GC'd in the meanwhile
+            } // else: Element GC'd in the meanwhile.
         }
     }
 
@@ -739,8 +738,8 @@ void addToRealmResults(RealmResults<? extends RealmModel> realmResults) {
         syncRealmResults.add(realmResultsWeakReference);
     }
 
-    // Add to the list of RealmObject to be notified after a commit.
-    // This method will check if the object exists in the list. It won't add the same object multiple times
+    // Adds to the list of RealmObject to be notified after a commit.
+    // This method will check if the object exists in the list. It won't add the same object multiple times.
     <E extends RealmObjectProxy> void addToRealmObjects(E realmObject) {
         for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
             if (ref.get() == realmObject) {
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index af3d807c7a..188753d0c2 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -67,12 +67,12 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
     public void setPendingQuery$realm(Future<Long> pendingQuery) {
         this.pendingQuery = pendingQuery;
         if (isLoaded()) {
-            // the query completed before RealmQuery
+            // The query completed before RealmQuery
             // had a chance to call setPendingQuery to register the pendingQuery (used btw
-            // to determine isLoaded behaviour)
+            // to determine isLoaded behaviour).
             onCompleted$realm();
 
-        } // else, it will be handled by the Realm#handler
+        } // Else, it will be handled by the Realm#handler.
     }
 
     public BaseRealm getRealm$realm() {
@@ -124,10 +124,10 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
         try {
             Long handoverResult = pendingQuery.get();// make the query blocking
             if (handoverResult != 0) {
-                // this may fail with BadVersionException if the caller and/or the worker thread
+                // This may fail with BadVersionException if the caller and/or the worker thread
                 // are not in sync (same shared_group version).
-                // COMPLETED_ASYNC_REALM_OBJECT will be fired by the worker thread
-                // this should handle more complex use cases like retry, ignore etc
+                // COMPLETED_ASYNC_REALM_OBJECT will be fired by the worker thread.
+                // This should handle more complex use cases like retry, ignore etc.
                 onCompleted$realm(handoverResult);
                 notifyChangeListeners$realm();
             } else {
@@ -146,8 +146,8 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
 
     public void onCompleted$realm(long handoverRowPointer) {
         if (handoverRowPointer == 0) {
-            // we'll retry later to update the row pointer, but we consider
-            // the query done
+            // We'll retry later to update the row pointer, but we consider
+            // the query done.
             isCompleted = true;
 
         } else if (!isCompleted || row == Row.EMPTY_ROW) {
@@ -155,7 +155,7 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
             long nativeRowPointer = TableQuery.importHandoverRow(handoverRowPointer, realm.sharedRealm);
             Table table = getTable();
             this.row = table.getUncheckedRowByPointer(nativeRowPointer);
-        }// else: already loaded query no need to import again the pointer
+        } // else: Already loaded query no need to import again the pointer.
     }
 
     /**
@@ -204,7 +204,7 @@ public boolean isUnderConstruction() {
 
     public void setConstructionFinished() {
         underConstruction = false;
-        // only used while construction.
+        // Only used while construction.
         excludeFields = null;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 56b6f52235..2f483be270 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -270,7 +270,7 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] gl
                 try {
                     migrateRealm(configuration, e);
                 } catch (FileNotFoundException fileNotFoundException) {
-                    // Should never happen
+                    // Should never happen.
                     throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
                 }
             }
@@ -288,7 +288,7 @@ static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[]
         final ColumnIndices columnIndices = RealmCache.findColumnIndices(globalCacheArray, requiredVersion);
 
         if (columnIndices != null) {
-            // copy global cache as a Realm local indices cache
+            // Copies global cache as a Realm local indices cache.
             realm.schema.columnIndices = columnIndices.clone();
         } else {
             final boolean syncingConfig = configuration.isSyncConfiguration();
@@ -307,7 +307,7 @@ static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[]
                 }
             }
 
-            // Initialize Realm schema if needed
+            // Initializes Realm schema if needed.
             try {
                 if (!syncingConfig) {
                     initializeRealm(realm);
@@ -341,7 +341,7 @@ private static void initializeRealm(Realm realm) {
 
             final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
-                // Create and validate table
+                // Creates and validates table.
                 if (unversioned) {
                     mediator.createTable(modelClass, realm.sharedRealm);
                 }
@@ -388,7 +388,7 @@ private static void initializeSyncedRealm(Realm realm) {
                 realmObjectSchemas.add(realmObjectSchema);
             }
 
-            // Assumption: when SyncConfiguration then additive schema update mode
+            // Assumption: When SyncConfiguration then additive schema update mode.
             final RealmSchema schema = new RealmSchema(realmObjectSchemas);
             long newVersion = realm.configuration.getSchemaVersion();
             if (realm.sharedRealm.requiresMigration(schema)) {
@@ -602,7 +602,7 @@ private static void initializeSyncedRealm(Realm realm) {
         checkHasPrimaryKey(clazz);
 
         // As we need the primary key value we have to first parse the entire input stream as in the general
-        // case that value might be the last property :(
+        // case that value might be the last property. :(
         Scanner scanner = null;
         try {
             scanner = getFullStringScanner(in);
@@ -759,7 +759,7 @@ private static void initializeSyncedRealm(Realm realm) {
         Table table = schema.getTable(clazz);
         if (table.hasPrimaryKey()) {
             // As we need the primary key value we have to first parse the entire input stream as in the general
-            // case that value might be the last property :(
+            // case that value might be the last property. :(
             Scanner scanner = null;
             try {
                 scanner = getFullStringScanner(inputStream);
@@ -811,7 +811,7 @@ private static void initializeSyncedRealm(Realm realm) {
         checkHasPrimaryKey(clazz);
 
         // As we need the primary key value we have to first parse the entire input stream as in the general
-        // case that value might be the last property :(
+        // case that value might be the last property. :(
         Scanner scanner = null;
         try {
             scanner = getFullStringScanner(in);
@@ -856,13 +856,13 @@ private Scanner getFullStringScanner(InputStream in) {
      * @return the new object.
      * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
      */
-    // called from proxy classes
+    // Called from proxy classes.
     <E extends RealmModel> E createObjectInternal(
             Class<E> clazz,
             boolean acceptDefaultValue,
             List<String> excludeFields) {
         Table table = schema.getTable(clazz);
-        // Check and throw the exception earlier for a better exception message.
+        // Checks and throws the exception earlier for a better exception message.
         if (table.hasPrimaryKey()) {
             throw new RealmException(String.format("'%s' has a primary key, use" +
                     " 'createObject(Class<E>, Object)' instead.", Table.tableNameToClassName(table.getName())));
@@ -884,7 +884,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @throws RealmException if object could not be created due to the primary key being invalid.
      * @throws IllegalStateException if the model class does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
-     *                                  expected value.
+     * expected value.
      */
     public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
         checkIfValid();
@@ -902,8 +902,9 @@ private Scanner getFullStringScanner(InputStream in) {
      * @throws RealmException if object could not be created due to the primary key being invalid.
      * @throws IllegalStateException if the model class does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     * expected value.
      */
-    // called from proxy classes
+    // Called from proxy classes.
     <E extends RealmModel> E createObjectInternal(
             Class<E> clazz,
             Object primaryKeyValue,
@@ -943,7 +944,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @param object {@link io.realm.RealmObject} to copy or update.
      * @return the new or updated RealmObject with all its properties backed by the Realm.
      * @throws java.lang.IllegalArgumentException if the object is {@code null} or doesn't have a Primary key defined
-     *                                            or it belongs to a Realm instance in a different thread.
+     * or it belongs to a Realm instance in a different thread.
      * @see #copyToRealm(RealmModel)
      */
     public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
@@ -980,7 +981,7 @@ private Scanner getFullStringScanner(InputStream in) {
     }
 
     /**
-     * Insert a list of an unmanaged RealmObjects. This is generally faster than {@link #copyToRealm(Iterable)} since it
+     * Inserts a list of an unmanaged RealmObjects. This is generally faster than {@link #copyToRealm(Iterable)} since it
      * doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      * <p>
@@ -1014,7 +1015,7 @@ public void insert(Collection<? extends RealmModel> objects) {
     }
 
     /**
-     * Insert an unmanaged RealmObject. This is generally faster than {@link #copyToRealm(RealmModel)} since it
+     * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyToRealm(RealmModel)} since it
      * doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      * <p>
@@ -1035,7 +1036,7 @@ public void insert(Collection<? extends RealmModel> objects) {
      * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
      *                                transaction.
      * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
-     *                                                                inserted or if a primary key value already exists in the Realm.
+     * inserted or if a primary key value already exists in the Realm.
      * @see #copyToRealm(RealmModel)
      */
     public void insert(RealmModel object) {
@@ -1048,8 +1049,9 @@ public void insert(RealmModel object) {
     }
 
     /**
-     * Insert or update a list of unmanaged RealmObjects. This is generally faster than {@link #copyToRealmOrUpdate(Iterable)} since it
-     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * Inserts or updates a list of unmanaged RealmObjects. This is generally faster than
+     * {@link #copyToRealmOrUpdate(Iterable)} since it doesn't return the inserted elements, and performs minimum
+     * allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      * <p>
      * Please note:
@@ -1084,8 +1086,9 @@ public void insertOrUpdate(Collection<? extends RealmModel> objects) {
     }
 
     /**
-     * Insert or update an unmanaged RealmObject. This is generally faster than {@link #copyToRealmOrUpdate(RealmModel)} since it
-     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * Inserts or updates an unmanaged RealmObject. This is generally faster than
+     * {@link #copyToRealmOrUpdate(RealmModel)} since it doesn't return the inserted elements, and performs minimum
+     * allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      * <p>
      * Please note:
@@ -1117,8 +1120,8 @@ public void insertOrUpdate(RealmModel object) {
 
     /**
      * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
-     * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects
-     * will be either copied or updated.
+     * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced
+     * objects will be either copied or updated.
      * <p>
      * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
@@ -1150,9 +1153,9 @@ public void insertOrUpdate(RealmModel object) {
      * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmModel)},
-     * but all fields will be overridden, not just those that were changed. This includes references to other objects,
-     * and can potentially override changes made by other threads.
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
+     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
+     * This includes references to other objects, and can potentially override changes made by other threads.
      *
      * @param realmObjects RealmObjects to copy.
      * @param <E> type of object.
@@ -1171,10 +1174,10 @@ public void insertOrUpdate(RealmModel object) {
      * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(Iterable)},
-     * but all fields will be overridden, not just those that were changed. This includes references to other objects
-     * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
-     * changes made by other threads.
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
+     * {@link #copyToRealmOrUpdate(Iterable)}, but all fields will be overridden, not just those that were changed.
+     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
+     * reached. This can also potentially override changes made by other threads.
      *
      * @param realmObjects RealmObjects to copy.
      * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
@@ -1182,7 +1185,7 @@ public void insertOrUpdate(RealmModel object) {
      * @param <E> type of object.
      * @return an in-memory detached copy of the RealmObjects.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
-     *                                  {@link DynamicRealmObject}.
+     * {@link DynamicRealmObject}.
      * @see #copyToRealmOrUpdate(Iterable)
      */
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
@@ -1240,7 +1243,7 @@ public void insertOrUpdate(RealmModel object) {
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
-     *                                  {@link DynamicRealmObject}.
+     * {@link DynamicRealmObject}.
      * @see #copyToRealmOrUpdate(RealmModel)
      */
     public <E extends RealmModel> E copyFromRealm(E realmObject, int maxDepth) {
@@ -1419,7 +1422,7 @@ public void run() {
                     }
 
                     final Throwable backgroundException = exception[0];
-                    // Send response as the final step to ensure the bg thread quit before others get the response!
+                    // Sends response as the final step to ensure the bg thread quit before others get the response!
                     if (hasValidNotifier() && !Thread.currentThread().isInterrupted()) {
 
                         if (transactionCommitted) {
@@ -1437,7 +1440,7 @@ public void run() {
                             });
                         }
 
-                        // Send errors directly to the looper, so they don't get intercepted by the HandlerController.
+                        // Sends errors directly to the looper, so they don't get intercepted by the HandlerController.
                         if (backgroundException != null) {
                             if (onError != null) {
                                 sharedRealm.realmNotifier.post(new Runnable() {
@@ -1463,7 +1466,7 @@ public void run() {
                         }
 
                     } else {
-                        // Throw exception in the worker thread if the caller thread terminated
+                        // Throws exception in the worker thread if the caller thread terminated.
                         if (backgroundException != null) {
                             if (backgroundException instanceof RuntimeException) {
                                 //noinspection ThrowFromFinallyBlock
@@ -1623,8 +1626,8 @@ Table getTable(Class<? extends RealmModel> clazz) {
      *
      * @param globalCacheArray global cache of column indices. If it contains an entry for current
      *                         schema version, this method only copies the indices information in the entry.
-     * @return newly created indices information for current schema version. Or {@code null} if
-     *         {@code globalCacheArray} already contains the entry for current schema version.
+     * @return newly created indices information for current schema version. Or {@code null} if {@code globalCacheArray}
+     * already contains the entry for current schema version.
      */
     ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
         final long currentSchemaVersion = sharedRealm.getSchemaVersion();
@@ -1638,7 +1641,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
         ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
                 currentSchemaVersion);
         if (cacheForCurrentVersion == null) {
-            // not found in global cache. create it.
+            // Not found in global cache. create it.
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
             final Map<Class<? extends RealmModel>, ColumnInfo> map;
             map = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 980218b28f..0fa7fbf371 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -107,14 +107,14 @@ private RealmCache(RealmConfiguration config) {
         boolean isCacheInMap = true;
         RealmCache cache = cachesMap.get(configuration.getPath());
         if (cache == null) {
-            // Create a new cache
+            // Creates a new cache.
             cache = new RealmCache(configuration);
             // The new cache should be added to the map later.
             isCacheInMap = false;
 
             copyAssetFileIfNeeded(configuration);
         } else {
-            // Throw the exception if validation failed.
+            // Throws the exception if validation failed.
             cache.validateConfiguration(configuration);
         }
 
@@ -134,7 +134,7 @@ private RealmCache(RealmConfiguration config) {
         }
 
         if (refAndCount.localRealm.get() == null) {
-            // Create a new local Realm instance
+            // Creates a new local Realm instance
             BaseRealm realm;
 
 
@@ -161,7 +161,7 @@ private RealmCache(RealmConfiguration config) {
         if (refCount == 0) {
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
                 final BaseRealm realm = refAndCount.localRealm.get();
-                // store a copy of local ColumnIndices as a global cache.
+                // Stores a copy of local ColumnIndices as a global cache.
                 RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.columnIndices.clone());
             }
             // This is the first instance in current thread, increase the global count.
@@ -172,7 +172,7 @@ private RealmCache(RealmConfiguration config) {
         @SuppressWarnings("unchecked")
         E realm = (E) refAndCount.localRealm.get();
 
-        // Notify SyncPolicy that the Realm has been opened for the first time
+        // Notifies SyncPolicy that the Realm has been opened for the first time
         if (refAndCount.globalCount == 1) {
             ObjectServerFacade.getFacade(configuration.isSyncConfiguration()).realmOpened(configuration);
         }
@@ -204,16 +204,16 @@ static synchronized void release(BaseRealm realm) {
             return;
         }
 
-        // Decrease the local counter.
+        // Decreases the local counter.
         refCount -= 1;
 
         if (refCount == 0) {
             // The last instance in this thread.
-            // Clear local ref & counter
+            // Clears local ref & counter.
             refAndCount.localCount.set(null);
             refAndCount.localRealm.set(null);
 
-            // Clear global counter
+            // Clears global counter.
             refAndCount.globalCount--;
             if (refAndCount.globalCount < 0) {
                 // Should never happen.
@@ -221,9 +221,9 @@ static synchronized void release(BaseRealm realm) {
                         " got corrupted.");
             }
 
-            // Clear the column indices cache if needed
+            // Clears the column indices cache if needed.
             if (realm instanceof Realm && refAndCount.globalCount == 0) {
-                // All typed Realm instances of this file are cleared from cache
+                // All typed Realm instances of this file are cleared from cache.
                 Arrays.fill(cache.typedColumnIndicesArray, null);
             }
 
@@ -255,16 +255,16 @@ static synchronized void release(BaseRealm realm) {
      */
     private void validateConfiguration(RealmConfiguration newConfiguration) {
         if (configuration.equals(newConfiguration)) {
-            // Same configuration objects
+            // Same configuration objects.
             return;
         }
 
-        // Check that encryption keys aren't different. key is not in RealmConfiguration's toString.
+        // Checks that encryption keys aren't different. key is not in RealmConfiguration's toString.
         if (!Arrays.equals(configuration.getEncryptionKey(), newConfiguration.getEncryptionKey())) {
             throw new IllegalArgumentException(DIFFERENT_KEY_MESSAGE);
         } else {
             // A common problem is that people are forgetting to override `equals` in their custom migration class.
-            // Try to detect this problem specifically so we can throw a better error message.
+            // Tries to detect this problem specifically so we can throw a better error message.
             RealmMigration newMigration = newConfiguration.getMigration();
             RealmMigration oldMigration = configuration.getMigration();
             if (oldMigration != null 
@@ -380,7 +380,7 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
                     try {
                         outputStream.close();
                     } catch (IOException e) {
-                        // Ignore this one if there was an exception when close inputStream.
+                        // Ignores this one if there was an exception when close inputStream.
                         if (exceptionWhenClose == null) {
                             exceptionWhenClose = e;
                         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 2eab03463b..0a006b559b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -260,21 +260,21 @@ public int hashCode() {
         return result;
     }
 
-    // Creates the mediator that defines the current schema
+    // Creates the mediator that defines the current schema.
     protected static RealmProxyMediator createSchemaMediator(Set<Object> modules,
                                                              Set<Class<? extends RealmModel>> debugSchema) {
 
-        // If using debug schema, use special mediator
+        // If using debug schema, uses special mediator.
         if (debugSchema.size() > 0) {
             return new FilterableMediator(DEFAULT_MODULE_MEDIATOR, debugSchema);
         }
 
-        // If only one module, use that mediator directly
+        // If only one module, uses that mediator directly.
         if (modules.size() == 1) {
             return getModuleMediator(modules.iterator().next().getClass().getCanonicalName());
         }
 
-        // Otherwise combine all mediators
+        // Otherwise combines all mediators.
         RealmProxyMediator[] mediators = new RealmProxyMediator[modules.size()];
         int i = 0;
         for (Object module : modules) {
@@ -284,7 +284,7 @@ protected static RealmProxyMediator createSchemaMediator(Set<Object> modules,
         return new CompositeMediator(mediators);
     }
 
-    // Finds the mediator associated with a given module
+    // Finds the mediator associated with a given module.
     private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleClassName) {
         String[] moduleNameParts = fullyQualifiedModuleClassName.split("\\.");
         String moduleSimpleName = moduleNameParts[moduleNameParts.length - 1];
@@ -349,7 +349,7 @@ static synchronized boolean isRxJavaAvailable() {
         return rxJavaAvailable;
     }
 
-    // Get the canonical path for a given file
+    // Gets the canonical path for a given file.
     protected static String getCanonicalPath(File realmFile) {
         try {
             return realmFile.getCanonicalPath();
@@ -360,7 +360,7 @@ protected static String getCanonicalPath(File realmFile) {
         }
     }
 
-    // Check if this configuration is a SyncConfiguration instance.
+    // Checks if this configuration is a SyncConfiguration instance.
     boolean isSyncConfiguration() {
         return false;
     }
@@ -369,7 +369,7 @@ boolean isSyncConfiguration() {
      * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
      */
     public static class Builder {
-         // IMPORTANT: When adding any new methods to this class also add them to SyncConfiguration.
+        // IMPORTANT: When adding any new methods to this class also add them to SyncConfiguration.
         private File directory;
         private String fileName;
         private String assetFilePath;
@@ -402,7 +402,7 @@ public Builder() {
             initializeBuilder(context);
         }
 
-        // Setup builder in its initial state
+        // Setups builder in its initial state.
         private void initializeBuilder(Context context) {
             this.directory = context.getFilesDir();
             this.fileName = Realm.DEFAULT_REALM_NAME;
@@ -429,7 +429,7 @@ public Builder name(String filename) {
         }
 
         /**
-         * Specify the directory where the Realm file will be saved. The default value is {@code context.getFiles()}.
+         * Specifies the directory where the Realm file will be saved. The default value is {@code context.getFiles()}.
          * If the directory does not exist, it will be created.
          *
          * @param directory the directory to save the Realm file in. Directory must be writable.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index df514821ef..7adb5b9ae4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -29,7 +29,7 @@
  */
 @Keep
 public enum RealmFieldType {
-    // Make sure numbers match with <realm/column_type.hpp>
+    // Makes sure numbers match with <realm/column_type.hpp>.
     INTEGER(0),
     BOOLEAN(1),
     STRING(2),
@@ -42,7 +42,7 @@
     DOUBLE(10),
     OBJECT(12),
     LIST(13);
-    // BACKLINK(14); Not exposed until needed
+    // BACKLINK(14); Not exposed until needed.
 
     // Primitive array for fast mapping between between native values and their Realm type.
     private static RealmFieldType[] typeList = new RealmFieldType[15];
@@ -71,6 +71,7 @@ public int getNativeValue() {
 
     /**
      * Checks if the given Java object can be converted to the underlying Realm type.
+     *
      * @param obj object to test compatibility on.
      * @return {@code true} if object can be converted to the Realm type, {@code false} otherwise.
      */
@@ -81,7 +82,7 @@ public boolean isValid(Object obj) {
             case 2: return (obj instanceof String);
             case 4: return (obj instanceof byte[] || obj instanceof ByteBuffer);
             case 5: return (obj == null || obj instanceof Object[][]);
-            case 7: return (obj instanceof java.util.Date); // the unused DateTime
+            case 7: return (obj instanceof java.util.Date); // The unused DateTime.
             case 8: return (obj instanceof java.util.Date);
             case 9: return (obj instanceof Float);
             case 10: return (obj instanceof Double);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 1fcb3fedef..d909155433 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -214,6 +214,7 @@ public boolean add(E object) {
      * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
      * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
+     *
      * @param location the index at which to put the specified object.
      * @param object the object to add.
      * @return the previous element at the index.
@@ -720,19 +721,26 @@ public boolean load() {
      */
     @Override
     public boolean contains(Object object) {
-        boolean contains = false;
         if (managedMode) {
             realm.checkIfValid();
+
+            // Deleted objects can never be part of a RealmList
             if (object instanceof RealmObjectProxy) {
                 RealmObjectProxy proxy = (RealmObjectProxy) object;
-                if (proxy.realmGet$proxyState().getRow$realm() != null && realm.getPath().equals(proxy.realmGet$proxyState().getRealm$realm().getPath()) && proxy.realmGet$proxyState().getRow$realm() != InvalidRow.INSTANCE) {
-                    contains = view.contains(proxy.realmGet$proxyState().getRow$realm().getIndex());
+                if (proxy.realmGet$proxyState().getRow$realm() == InvalidRow.INSTANCE) {
+                    return false;
+                }
+            }
+
+            for (E e : this) {
+                if (e.equals(object)) {
+                    return true;
                 }
             }
+            return false;
         } else {
-            contains = unmanagedList.contains(object);
+            return unmanagedList.contains(object);
         }
-        return contains;
     }
 
     /**
@@ -819,14 +827,14 @@ public String toString() {
 
         /**
          * Index of element returned by most recent call to next or
-         * previous.  Reset to -1 if this element is deleted by a call
+         * previous. Resets to -1 if this element is deleted by a call
          * to remove.
          */
         int lastRet = -1;
 
         /**
          * The modCount value that the iterator believes that the backing
-         * List should have.  If this expectation is violated, the iterator
+         * List should have. If this expectation is violated, the iterator
          * has detected concurrent modification.
          */
         int expectedModCount = modCount;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index ed03ec6e4b..f9ff0a7490 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -153,15 +153,16 @@ public final boolean isValid() {
     /**
      * Checks if the query used to find this RealmObject has completed.
      *
-     * Async methods like {@link RealmQuery#findFirstAsync()} return an {@link RealmObject} that represents the future result
-     * of the {@link RealmQuery}. It can be considered similar to a {@link java.util.concurrent.Future} in this regard.
+     * Async methods like {@link RealmQuery#findFirstAsync()} return an {@link RealmObject} that represents the future
+     * result of the {@link RealmQuery}. It can be considered similar to a {@link java.util.concurrent.Future} in this
+     * regard.
      *
      * Once {@code isLoaded()} returns {@code true}, the object represents the query result even if the query
      * didn't find any object matching the query parameters. In this case the {@link RealmObject} will
      * become a "null" object.
      *
-     * "Null" objects represents {@code null}.  An exception is throw if any accessor is called, so it is important to also
-     * check {@link #isValid()} before calling any methods. A common pattern is:
+     * "Null" objects represents {@code null}.  An exception is throw if any accessor is called, so it is important to
+     * also check {@link #isValid()} before calling any methods. A common pattern is:
      *
      * <pre>
      * {@code
@@ -224,7 +225,6 @@ public final boolean isLoaded() {
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
      * This method will return {@code true} if called on an unmanaged object (created outside of Realm).
      *
-     *
      * @param object RealmObject to check.
      * @return {@code true} if the query has completed, {@code false} if the query is in
      * progress.
@@ -360,7 +360,7 @@ public final boolean load() {
                 listeners.add(listener);
             }
             if (isLoaded(proxy)) {
-                // Try to add this object to the realmObjects if it has already been loaded.
+                // Tries to add this object to the realmObjects if it has already been loaded.
                 // For newly created async objects, it will be handled in RealmQuery.findFirstAsync &
                 // HandlerController.completedAsyncRealmObject.
                 realm.handlerController.addToRealmObjects(proxy);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index e4d8115237..9e2322d723 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -143,11 +143,12 @@ public String getClassName() {
     }
 
     /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When {@link RealmObjectSchema#table}
-     * has a primary key, this will transfer the primary key for the new class name.
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
+     * {@link RealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
      *
      * @param className the new name for this class.
-     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56 characters.
+     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
+     * characters.
      * @see RealmSchema#rename(String, String)
      */
     public RealmObjectSchema setClassName(String className) {
@@ -155,7 +156,7 @@ public RealmObjectSchema setClassName(String className) {
         checkEmpty(className);
         String internalTableName = Table.TABLE_PREFIX + className;
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is to long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
         }
         if (realm.sharedRealm.hasTable(internalTableName)) {
             throw new IllegalArgumentException("Class already exists: " + className);
@@ -182,12 +183,13 @@ public RealmObjectSchema setClassName(String className) {
     }
 
     /**
-     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See {@link RealmObject}
-     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.,
-     * {@code Integer.class} instead of {@code int.class}.
+     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
+     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
+     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
      * <p>
-     * To add fields that reference other RealmObjects or RealmLists use {@link #addRealmObjectField(String, RealmObjectSchema)}
-     * or {@link #addRealmListField(String, RealmObjectSchema)} instead.
+     * To add fields that reference other RealmObjects or RealmLists use
+     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
+     * instead.
      *
      * @param fieldName name of the field to add.
      * @param fieldType type of field to add. See {@link RealmObject} for the full list.
@@ -307,7 +309,7 @@ public RealmObjectSchema removeField(String fieldName) {
      * Renames a field from one name to another.
      *
      * @param currentFieldName field name to rename.
-     * @param newFieldName     the new field name.
+     * @param newFieldName the new field name.
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
      */
@@ -336,8 +338,8 @@ public boolean hasField(String fieldName) {
     }
 
     /**
-     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index} annotation
-     * on the field.
+     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
+     * annotation on the field.
      *
      * @param fieldName field to add index to.
      * @return the updated schema.
@@ -378,7 +380,7 @@ public boolean hasIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
      */
     public RealmObjectSchema removeIndex(String fieldName) {
-        realm.checkNotInSync(); // destructive modifications are not permitted
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkLegalName(fieldName);
         checkFieldExists(fieldName);
         long columnIndex = getColumnIndex(fieldName);
@@ -391,7 +393,8 @@ public RealmObjectSchema removeIndex(String fieldName) {
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
-     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field as well.
+     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
+     * as well.
      *
      * @param fieldName field to set as primary key.
      * @return the updated schema.
@@ -415,13 +418,14 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
-     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from the field as well.
+     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
+     * the field as well.
      *
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
      */
     public RealmObjectSchema removePrimaryKey() {
-        realm.checkNotInSync(); // destructive modifications are not permitted
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
         if (!table.hasPrimaryKey()) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
@@ -596,7 +600,7 @@ private void addModifiers(String fieldName, FieldAttribute[] attributes) {
                 // REQUIRED is being handled when adding the column using addField through the nullable parameter.
             }
         } catch (Exception e) {
-            // If something went wrong, revert all attributes
+            // If something went wrong, revert all attributes.
             long columnIndex = getColumnIndex(fieldName);
             if (indexAdded) {
                 table.removeSearchIndex(columnIndex);
@@ -679,7 +683,7 @@ private void checkEmpty(String str) {
         Table table = this.table;
         boolean checkColumnType = validColumnTypes != null && validColumnTypes.length > 0;
         if (fieldDescription.contains(".")) {
-            // Resolve field description down to last field name
+            // Resolves field description down to last field name.
             String[] names = fieldDescription.split("\\.");
             long[] columnIndices = new long[names.length];
             for (int i = 0; i < names.length - 1; i++) {
@@ -696,7 +700,7 @@ private void checkEmpty(String str) {
                 }
             }
 
-            // Check if last field name is a valid field
+            // Checks if last field name is a valid field.
             String columnName = names[names.length - 1];
             long columnIndex = table.getColumnIndex(columnName);
             columnIndices[names.length - 1] = columnIndex;
@@ -774,7 +778,7 @@ public RealmFieldType getFieldType(String fieldName) {
         void apply(DynamicRealmObject obj);
     }
 
-    // Tuple containing data about each supported Java type
+    // Tuple containing data about each supported Java type.
     private static class FieldMetaData {
         public final RealmFieldType realmType;
         public final boolean defaultNullable;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index f42c9734df..29e6f09d4b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -216,7 +216,7 @@ public boolean isValid() {
     public RealmQuery<E> isNull(String fieldName) {
         long columnIndices[] = schema.getColumnIndices(fieldName);
 
-        // checking that fieldName has the correct type is done in C++
+        // Checks that fieldName has the correct type is done in C++.
         this.query.isNull(columnIndices);
         return this;
     }
@@ -232,7 +232,7 @@ public boolean isValid() {
     public RealmQuery<E> isNotNull(String fieldName) {
         long columnIndices[] = schema.getColumnIndices(fieldName);
 
-        // checking that fieldName has the correct type is done in C++
+        // Checks that fieldName has the correct type is done in C++.
         this.query.isNotNull(columnIndices);
         return this;
     }
@@ -431,7 +431,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, String[] values) {
         return in(fieldName, values, Case.SENSITIVE);
@@ -444,7 +445,8 @@ public boolean isValid() {
      * @param values array of values to compare with and it cannot be null or empty.
      * @param casing how casing is handled. {@link Case#INSENSITIVE} works only for the Latin-1 characters.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, String[] values, Case casing) {
         if (values == null || values.length == 0) {
@@ -463,7 +465,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Byte field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Byte field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, Byte[] values) {
         if (values == null || values.length == 0) {
@@ -482,7 +485,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Short field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Short field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, Short[] values) {
         if (values == null || values.length == 0) {
@@ -501,7 +505,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Integer field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Integer field or {@code values} is {@code null}
+     * or empty.
      */
     public RealmQuery<E> in(String fieldName, Integer[] values) {
         if (values == null || values.length == 0) {
@@ -520,7 +525,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Long field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Long field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, Long[] values) {
         if (values == null || values.length == 0) {
@@ -539,7 +545,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Double field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Double field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, Double[] values) {
         if (values == null || values.length == 0) {
@@ -558,7 +565,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Float field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Float field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, Float[] values) {
         if (values == null || values.length == 0) {
@@ -577,7 +585,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Boolean field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Boolean field or {@code values} is {@code null}
+     * or empty.
      */
     public RealmQuery<E> in(String fieldName, Boolean[] values) {
         if (values == null || values.length == 0) {
@@ -596,7 +605,8 @@ public boolean isValid() {
      * @param fieldName the field to compare.
      * @param values array of values to compare with and it cannot be null or empty.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException if the field isn't a Date field or {@code values} is {@code null} or empty.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Date field or {@code values} is {@code null} or
+     * empty.
      */
     public RealmQuery<E> in(String fieldName, Date[] values) {
         if (values == null || values.length == 0) {
@@ -1401,18 +1411,18 @@ public boolean isValid() {
         final long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
         final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
-        // handover the query (to be used by a worker thread)
+        // Handovers the query (to be used by a worker thread).
         final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-        // save query arguments (for future update)
+        // Saves query arguments (for future update).
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_DISTINCT);
         argumentsHolder.columnIndex = columnIndex;
 
-        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
-        // to perform the query
+        // We need to use the same configuration to open a background SharedRealm (i.e Realm)
+        // to perform the query.
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
-        // prepare an empty reference of the RealmResults, so we can return it immediately (promise)
+        // Prepares an empty reference of the RealmResults, so we can return it immediately (promise)
         // then update it once the query completes in the background.
         RealmResults<E> realmResults;
         if (isDynamicQuery()) {
@@ -1466,22 +1476,22 @@ public Long call() throws Exception {
         return realmResults;
     }
 
-    // Find and validate the column index for the field name used to create a distinctive TableView.
+    // Finds and validates the column index for the field name used to create a distinctive TableView.
     static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
-        // Check empty field name
+        // Checks empty field name.
         if (fieldName == null || fieldName.isEmpty()) {
             throw new IllegalArgumentException("Non-empty field name must be provided.");
         }
         long columnIndex = table.getColumnIndex(fieldName);
-        // Check if field exists
+        // Checks if field exists.
         if (columnIndex == -1) {
             throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
         }
-        // Check linked fields
+        // Checks linked fields.
         if (fieldName.contains(".")) {
             throw new IllegalArgumentException("Distinct operation on linked properties is not supported: " + fieldName);
         }
-        // check if the field is indexed
+        // Checks if the field is indexed.
         if (!table.hasSearchIndex(columnIndex)) {
             throw new IllegalArgumentException(String.format("Field name '%s' must be indexed in order to use it for distinct queries.", fieldName));
         }
@@ -1516,13 +1526,13 @@ static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
         return realmResults;
     }
 
-    // find and validate the column indices of fields for building a distinctive TableView with multi-args
+    // Finds and validates the column indices of fields for building a distinctive TableView with multi-args.
     static List<Long> getValidatedColumIndexes(Table table, String firstFieldName, String... remainingFieldNames) {
         List<Long> columnIndexes = new ArrayList<Long>();
-        // find the first index
+        // Finds the first index.
         long firstIndex = getAndValidateDistinctColumnIndex(firstFieldName, table);
         columnIndexes.add(firstIndex);
-        // add remaining of indexes
+        // Adds remaining of indexes.
         if (remainingFieldNames != null && 0 < remainingFieldNames.length) {
             for (String field : remainingFieldNames) {
                 long index = getAndValidateDistinctColumnIndex(field, table);
@@ -1705,17 +1715,17 @@ public long count() {
         checkQueryIsNotReused();
         final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
-        // handover the query (to be used by a worker thread)
+        // Handovers the query (to be used by a worker thread).
         final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-        // save query arguments (for future update)
+        // Saves query arguments (for future update).
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL);
 
-        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
-        // to perform the query
+        // We need to use the same configuration to open a background SharedRealm (i.e Realm)
+        // to perform the query.
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
-        // prepare an empty reference of the RealmResults, so we can return it immediately (promise)
+        // Prepares an empty reference of the RealmResults, so we can return it immediately (promise)
         // then update it once the query completes in the background.
         RealmResults<E> realmResults;
         if (isDynamicQuery()) {
@@ -1736,7 +1746,7 @@ public Long call() throws Exception {
                     try {
                         sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
-                        // Run the query & handover the table view for the caller thread
+                        // Runs the query & handover the table view for the caller thread.
                         // Note: the handoverQueryPointer contains the versionID needed by the SG in order
                         // to import it.
                         long handoverTableViewPointer = TableQuery.findAllWithHandover(sharedRealm,
@@ -1818,17 +1828,17 @@ public Long call() throws Exception {
         checkQueryIsNotReused();
         long columnIndex = getColumnIndexForSort(fieldName);
 
-        // capture the query arguments for future retries & update
+        // Captures the query arguments for future retries & updates.
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_SORTED);
         argumentsHolder.sortOrder = sortOrder;
         argumentsHolder.columnIndex = columnIndex;
 
         final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
-        // handover the query (to be used by a worker thread)
+        // Handovers the query (to be used by a worker thread).
         final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-        // we need to use the same configuration to open a background SharedRealm to perform the query
+        // We need to use the same configuration to open a background SharedRealm to perform the query.
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
         RealmResults<E> realmResults;
@@ -1853,7 +1863,7 @@ public Long call() throws Exception {
 
                         long columnIndex = getColumnIndexForSort(fieldName);
 
-                        // run the query & handover the table view for the caller thread
+                        // Runs the query & handover the table view for the caller thread.
                         long handoverTableViewPointer = TableQuery.findAllSortedWithHandover(sharedRealm,
                                  handoverQueryPointer, columnIndex, sortOrder);
 
@@ -1985,10 +1995,10 @@ private boolean isDynamicQuery() {
         } else {
             final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
-            // Handover the query (to be used by a worker thread)
+            // Handovers the query (to be used by a worker thread).
             final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-            // We need to use the same configuration to open a background SharedRealm to perform the query
+            // We need to use the same configuration to open a background SharedRealm to perform the query.
             final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
             final long indices[] = new long[fieldNames.length];
@@ -1998,12 +2008,12 @@ private boolean isDynamicQuery() {
                 indices[i] = columnIndex;
             }
 
-            // capture the query arguments for future retries & update
+            // Captures the query arguments for future retries & update.
             argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED);
             argumentsHolder.sortOrders = sortOrders;
             argumentsHolder.columnIndices = indices;
 
-            // prepare the promise result
+            // Prepares the promise result.
             RealmResults<E> realmResults;
             if (isDynamicQuery()) {
                 //noinspection unchecked
@@ -2023,7 +2033,7 @@ public Long call() throws Exception {
                         try {
                             sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
-                            // run the query & handover the table view for the caller thread
+                            // Runs the query & handover the table view for the caller thread.
                             long handoverTableViewPointer = TableQuery.findAllMultiSortedWithHandover(sharedRealm,
                                     handoverQueryPointer, indices, sortOrders);
 
@@ -2127,15 +2137,15 @@ public E findFirstAsync() {
         checkQueryIsNotReused();
         final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
-        // handover the query (to be used by a worker thread)
+        // Handovers the query (to be used by a worker thread).
         final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-        // save query arguments (for future update)
+        // Saves query arguments (for future update).
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_FIRST);
 
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
-        // prepare an empty reference of the RealmObject, so we can return it immediately (promise)
+        // Prepares an empty reference of the RealmObject, so we can return it immediately (promise)
         // then update it once the query complete in the background.
         final E result;
         if (isDynamicQuery()) {
@@ -2160,7 +2170,7 @@ public Long call() throws Exception {
                         sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                         long handoverRowPointer = TableQuery.findWithHandover(sharedRealm, handoverQueryPointer);
-                        if (handoverRowPointer == 0) { // empty row
+                        if (handoverRowPointer == 0) { // Empty row.
                             realm.handlerController.addToEmptyAsyncRealmObject(realmObjectWeakReference, RealmQuery.this);
                             realm.handlerController.removeFromAsyncRealmObject(realmObjectWeakReference);
                         }
@@ -2175,7 +2185,7 @@ public Long call() throws Exception {
 
                     } catch (Throwable e) {
                         RealmLog.error(e);
-                        // handler can't throw a checked exception need to wrap it into unchecked Exception
+                        // Handler can't throw a checked exception need to wrap it into unchecked Exception.
                         closeSharedRealmAndSendEventToNotifier(sharedRealm,
                                 weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
@@ -2214,7 +2224,7 @@ private void checkSortParameters(String fieldNames[], final Sort[] sortOrders) {
             throw new IllegalStateException("Your Realm is opened from a thread without a Looper." +
                     " Async queries need a Handler to send results of your query");
         }
-        return new WeakReference<RealmNotifier>(realm.sharedRealm.realmNotifier); // use caller Realm's Looper
+        return new WeakReference<RealmNotifier>(realm.sharedRealm.realmNotifier); // Uses caller Realm's Looper.
     }
 
     // The shared group needs to be closed before sending the message to other threads to avoid timing problems.
@@ -2245,8 +2255,8 @@ private void closeSharedRealmAndSendEventToNotifier(SharedRealm sharedRealm,
         }
     }
 
-    // We need to prevent the user from using the query again (mostly for async)
-    // Ex: if the first query fail with findFirstAsync, if the user reuse the same RealmQuery
+    // We need to prevent the user from using the query again (mostly for async).
+    // Ex: If the first query fail with findFirstAsync, if the user reuse the same RealmQuery
     //     with findAllSorted, argumentsHolder of the first query will be overridden,
     //     which cause any retry to use the findAllSorted argumentsHolder.
     private void checkQueryIsNotReused() {
@@ -2259,7 +2269,7 @@ private long getSourceRowIndexForFirstObject() {
         long tableRowIndex = this.query.find();
         return tableRowIndex;
     }
-    // Get the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
+    // Gets the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
     // or it belongs to the child object.
     private long getColumnIndexForSort(String fieldName) {
         if (fieldName == null || fieldName.isEmpty()) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 6311d45e47..0624795949 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -85,8 +85,8 @@
     private final List<RealmChangeListener<RealmResults<E>>> listeners = new CopyOnWriteArrayList<RealmChangeListener<RealmResults<E>>>();
     private Future<Long> pendingQuery;
     private boolean asyncQueryCompleted = false;
-    // Keep track of changes to the RealmResult. Is updated after a call to `syncIfNeeded()`. Calling notifyListeners will
-    // clear it.
+    // Keeps track of changes to the RealmResult. Is updated after a call to `syncIfNeeded()`. Calling notifyListeners
+    // will clear it.
     private boolean viewUpdated = false;
 
 
@@ -189,14 +189,22 @@ public boolean isManaged() {
      */
     @Override
     public boolean contains(Object object) {
-        boolean contains = false;
-        if (isLoaded() && object instanceof RealmObjectProxy) {
-            RealmObjectProxy proxy = (RealmObjectProxy) object;
-            if (realm.getPath().equals(proxy.realmGet$proxyState().getRealm$realm().getPath()) && proxy.realmGet$proxyState().getRow$realm() != InvalidRow.INSTANCE) {
-                contains = (table.sourceRowIndex(proxy.realmGet$proxyState().getRow$realm().getIndex()) != TableOrView.NO_MATCH);
+        if (isLoaded()) {
+            // Deleted objects can never be part of a RealmResults
+            if (object instanceof RealmObjectProxy) {
+                RealmObjectProxy proxy = (RealmObjectProxy) object;
+                if (proxy.realmGet$proxyState().getRow$realm() == InvalidRow.INSTANCE) {
+                    return false;
+                }
+            }
+
+            for (E e : this) {
+                if (e.equals(object)) {
+                    return true;
+                }
             }
         }
-        return contains;
+        return false;
     }
 
     /**
@@ -781,7 +789,7 @@ public void remove() {
             throw new UnsupportedOperationException("remove() is not supported by RealmResults iterators.");
         }
 
-        protected void checkRealmIsStable() {
+        void checkRealmIsStable() {
             long version = table.getVersion();
             // Any change within a write transaction will immediately update the table version. This means that we
             // cannot depend on the tableVersion heuristic in that case.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 7713b75854..2584b4278f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -102,7 +102,6 @@ public void close() {
      *
      * @param className name of the class
      * @return schema object for that class or {@code null} if the class doesn't exists.
-     *
      */
     public RealmObjectSchema get(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
@@ -160,7 +159,7 @@ public RealmObjectSchema get(String className) {
      * @return a Realm schema object for that class.
      */
     public RealmObjectSchema create(String className) {
-        // adding a class is always permitted
+        // Adding a class is always permitted.
         checkEmpty(className, EMPTY_STRING_MSG);
         if (realm == null) {
             RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
@@ -169,7 +168,7 @@ public RealmObjectSchema create(String className) {
         } else {
             String internalTableName = TABLE_PREFIX + className;
             if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-                throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
+                throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
             }
             if (realm.sharedRealm.hasTable(internalTableName)) {
                 throw new IllegalArgumentException("Class already exists: " + className);
@@ -182,12 +181,12 @@ public RealmObjectSchema create(String className) {
 
     /**
      * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
-     * to it will throw an {@link IllegalStateException}. Remove those classes or fields first.
+     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
      *
      * @param className name of the class to remove.
      */
     public void remove(String className) {
-        realm.checkNotInSync(); // destructive modifications are not permitted
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkEmpty(className, EMPTY_STRING_MSG);
         String internalTableName = TABLE_PREFIX + className;
         checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
@@ -206,7 +205,7 @@ public void remove(String className) {
      * @return a schema object for renamed class.
      */
     public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        realm.checkNotInSync(); // destructive modifications are not permitted
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkEmpty(oldClassName, "Class names cannot be empty or null");
         checkEmpty(newClassName, "Class names cannot be empty or null");
         String oldInternalName = TABLE_PREFIX + oldClassName;
@@ -216,7 +215,7 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
             throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
         }
 
-        // Check if there is a primary key defined for the old class.
+        // Checks if there is a primary key defined for the old class.
         Table oldTable = getTable(oldClassName);
         String pkField = null;
         if (oldTable.hasPrimaryKey()) {
@@ -227,7 +226,7 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
         realm.sharedRealm.renameTable(oldInternalName, newInternalName);
         Table table = realm.sharedRealm.getTable(newInternalName);
 
-        // Set the primary key for the new class if necessary
+        // Sets the primary key for the new class if necessary.
         if (pkField != null) {
             table.setPrimaryKey(pkField);
         }
@@ -289,7 +288,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
         if (table == null) {
             Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
             if (isProxyClass(originalClass, clazz)) {
-                // if passed 'clazz' is the proxy, try again with model class
+                // If passed 'clazz' is the proxy, try again with model class.
                 table = classToTable.get(originalClass);
             }
             if (table == null) {
@@ -297,7 +296,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
                 classToTable.put(originalClass, table);
             }
             if (isProxyClass(originalClass, clazz)) {
-                // 'clazz' is the proxy class for 'originalClass'
+                // 'clazz' is the proxy class for 'originalClass'.
                 classToTable.put(clazz, table);
             }
         }
@@ -309,7 +308,7 @@ RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         if (classSchema == null) {
             Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
             if (isProxyClass(originalClass, clazz)) {
-                // if passed 'clazz' is the proxy, try again with model class
+                // If passed 'clazz' is the proxy, try again with model class.
                 classSchema = classToSchema.get(originalClass);
             }
             if (classSchema == null) {
@@ -318,7 +317,7 @@ RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
                 classToSchema.put(originalClass, classSchema);
             }
             if (isProxyClass(originalClass, clazz)) {
-                // 'clazz' is the proxy class for 'originalClass'
+                // 'clazz' is the proxy class for 'originalClass'.
                 classToSchema.put(clazz, classSchema);
             }
         }
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
index ae187baff1..5d7c3d6f5d 100644
--- a/realm/realm-library/src/main/java/io/realm/Sort.java
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -33,6 +33,7 @@
 
     /**
      * Returns the value for this setting that is used by the underlying query engine.
+     *
      * @return the value used by the underlying query engine to indicate this value.
      */
     public boolean getValue() {
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
index e4bca48d1b..353dabf128 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -33,7 +33,7 @@
          */
         ACCESS_ERROR,
         /**
-         *  Thrown if the history type of the on-disk Realm is unexpected or incompatible.
+         * Thrown if the history type of the on-disk Realm is unexpected or incompatible.
          */
         BAD_HISTORY,
         /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 75acb7df6b..7c36e57512 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -92,7 +92,7 @@ public boolean isNull(long columnIndex) {
     }
 
     /**
-     * Set null to a row pointer with checking if a column is nullable, except when the column type
+     * Sets null to a row pointer with checking if a column is nullable, except when the column type
      * is binary.
      *
      * @param columnIndex 0 based index value of the cell column.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index 3846930296..87ee853674 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -50,7 +50,7 @@ protected final void setIndicesMap(Map<String, Long> indicesMap) {
     /**
      * Copies the column index value from other {@link ColumnInfo} object.
      *
-     * @param other The class of {@code other} must be exactly the same as this instance.
+     * @param other the class of {@code other} must be exactly the same as this instance.
      *              It must not be {@code null}.
      * @throws IllegalArgumentException if {@code other} has different class than this.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java b/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java
index 2e8db788c3..c712fab530 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java
@@ -36,7 +36,7 @@ public void run() {
                 NativeObjectReference reference = (NativeObjectReference) referenceQueue.remove();
                 reference.cleanup();
             } catch (InterruptedException e) {
-                // Restore the interrupted status
+                // Restores the interrupted status.
                 Thread.currentThread().interrupt();
 
                 RealmLog.fatal("The FinalizerRunnable thread has been interrupted." +
diff --git a/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java b/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java
index 2df4ead5d8..127d971012 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java
@@ -18,7 +18,7 @@
 import java.util.IdentityHashMap;
 
 /**
- * Identity based Set, that guarantee store & retrieve in O(1)
+ * Identity based Set, that guarantees store & retrieve in O(1)
  * without a huge overhead in space complexity.
  */
 public class IdentitySet<K> extends IdentityHashMap<K,Integer> {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index f6718b4083..a368e4193d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -141,7 +141,7 @@ public Table getTable() {
     }
 
     /**
-     * Remove all target rows pointed to by links in this link view, and clear this link view.
+     * Removes all target rows pointed to by links in this link view, and clear this link view.
      */
     public void removeAllTargetRows() {
         checkImmutable();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 8bb11bf554..651562b6d3 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -44,14 +44,14 @@
     }
 
     /**
-     * Initialize the Object Server library
+     * Initializes the Object Server library
      * @param context
      */
     public void init(Context context) {
     }
 
     /**
-     * Notify the session for this configuration that a local commit was made.
+     * Notifies the session for this configuration that a local commit was made.
      */
     public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
index f658b1296e..e4b6760ecc 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
@@ -70,7 +70,7 @@ private static String loadLibraryWindows() {
             // Above can't be used on Android.
         }
 //*/
-        // Load debug library first - if available
+        // Loads debug library first - if available.
         String jnilib;
         jnilib = loadCorrectLibrary("realm_jni32d", "realm_jni64d");
         if (jnilib != null) {
@@ -110,10 +110,10 @@ public static void addNativeLibraryPath(String path) {
     // The ClassLoader has a static field (sys_paths) that contains the paths.
     // If that field is set to null, it is initialized automatically.
     // Therefore forcing that field to null will result into the reevaluation of the library path
-    // as soon as loadLibrary() is called
+    // as soon as loadLibrary() is called.
     private static void resetLibraryPath() {
         try {
-            // reset the library path (a hack)
+            // Resets the library path (a hack).
             Field fieldSysPath = ClassLoader.class.getDeclaredField("sys_paths");
             fieldSysPath.setAccessible(true);
             fieldSysPath.set(null, null);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index bd72e4f7b8..7d0f38f253 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -34,7 +34,7 @@
 import io.realm.exceptions.RealmException;
 
 /**
- * Superclass for the RealmProxyMediator class'. This class contain all static methods introduced by the annotation
+ * Superclass for the RealmProxyMediator class. This class contains all static methods introduced by the annotation
  * processor as part of the RealmProxy classes.
  *
  * Classes extending this class act as binders between the static methods inside each RealmProxy and the code at
@@ -45,11 +45,11 @@
 public abstract class RealmProxyMediator {
 
     /**
-     * Create a object schema for the given RealmObject class.
+     * Creates a object schema for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} model class to create object schema for.
      * @param realmSchema the {@link RealmSchema} to associate the object schema with.
-     * @return The object schema.
+     * @return the object schema.
      */
     public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
 
@@ -83,7 +83,7 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
     public abstract List<String> getFieldNames(Class<? extends RealmModel> clazz);
 
     /**
-     * Returns the name that Realm should use for all it's internal tables. This is the un-obfuscated name of the
+     * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated name of the
      * class.
      *
      * @param clazz the {@link RealmObject} class reference.
@@ -98,9 +98,9 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
      * @param clazz the {@link RealmObject} to create {@link RealmObjectProxy} for.
      * @param acceptDefaultValue {@code true} to accept the values set in the constructor, {@code false} otherwise.
      * @param excludeFields the column names whose default value will be ignored if the {@code acceptDefaultValue}
-     *                       is {@code true}. Only {@link io.realm.RealmModel} and {@link io.realm.RealmList}
-     *                       column will respect this.
-     *                       No effects if the {@code acceptDefaultValue} is {@code false}.
+     *                      is {@code true}. Only {@link io.realm.RealmModel} and {@link io.realm.RealmList}
+     *                      column will respect this.
+     *                      No effects if the {@code acceptDefaultValue} is {@code false}.
      * @return created {@link RealmObjectProxy} object.
      */
     public abstract <E extends RealmModel> E newInstance(Class<E> clazz,
@@ -121,18 +121,18 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
      * Copies an unmanaged {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
      * any changes to the original object will not be persisted.
      *
-     * @param realm reference to the {@link Realm} where the object will be copied.
+     * @param realm the reference to the {@link Realm} where the object will be copied.
      * @param object the object to copy properties from.
      * @param update {@code true} if object has a primary key and should try to update already existing data,
-     * {@code false} otherwise.
+     *               {@code false} otherwise.
      * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
      * @return the managed Realm object.
      */
     public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
 
     /**
-     * Insert an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
-     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
+     * since it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      *
      * @param realm reference to the {@link Realm} where the object will be inserted.
@@ -142,8 +142,8 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
     public abstract void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
 
     /**
-     * Insert or update a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
-     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * Inserts or updates a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
+     * since it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      *
      * @param realm reference to the {@link Realm} where the objecs will be inserted.
@@ -153,8 +153,8 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
     public abstract void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
 
     /**
-     * Insert or update a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
-     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * Inserts or updates a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
+     * since it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      *
      * @param realm reference to the {@link Realm} where the objects will be inserted.
@@ -163,8 +163,9 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
     public abstract void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects);
 
     /**
-     * Insert a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
-     * doesn't return the inserted elements, and performs minimum allocations and checks. After being inserted any changes to the original objects will not be persisted.
+     * Inserts a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since
+     * it doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
      *
      * @param realm reference to the {@link Realm} where the objects will be inserted.
      * @param objects Collection of {@link RealmObject} to insert or update. This must not be empty.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index b63f85fd34..023e923bff 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -107,7 +107,7 @@
     /**
      * Returns {@code true} if the field name exists.
      *
-     * @param fieldName Field name to check.
+     * @param fieldName field name to check.
      * @return {@code true} if field name exists, {@code false} otherwise.
      */
     boolean hasColumn(String fieldName);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 9d3868f38e..5037f13d12 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -326,7 +326,7 @@ public boolean compact() {
     }
 
     /**
-     * Update the underlying schema based on the schema description.
+     * Updates the underlying schema based on the schema description.
      * Calling this method must be done from inside a write transaction.
      */
     public void updateSchema(RealmSchema schema, long version) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index b5c210ba29..e518baf8ca 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -146,7 +146,7 @@ public long addColumnLink (RealmFieldType type, String name, Table table) {
     }
 
     /**
-     * Removes a column in the table dynamically. if {@code columnIndex} is smaller than the primary
+     * Removes a column in the table dynamically. If {@code columnIndex} is smaller than the primary
      * key column index, {@link #invalidateCachedPrimaryKeyIndex()} will be called to recalculate the
      * primary key column index.
      *
@@ -157,15 +157,15 @@ public long addColumnLink (RealmFieldType type, String name, Table table) {
      */
     @Override
     public void removeColumn(long columnIndex) {
-        // Check the PK column index before removing a column. We don't know if we're hitting a PK col,
+        // Checks the PK column index before removing a column. We don't know if we're hitting a PK col,
         // but it should be noted that once a column is removed, there is no way we can find whether
         // a PK exists or not.
         final long oldPkColumnIndex = getPrimaryKey();
 
-        // firstly remove a column. If there is no error, we can proceed. Otherwise, it will stop here.
+        // First removes a column. If there is no error, we can proceed. Otherwise, it will stop here.
         nativeRemoveColumn(nativePtr, columnIndex);
 
-        // Check if a PK exists and take actions if there is. This is same as hasPrimaryKey(), but
+        // Checks if a PK exists and takes actions if there is. This is same as hasPrimaryKey(), but
         // this relies on the local cache.
         if (oldPkColumnIndex >= 0) {
 
@@ -195,16 +195,16 @@ public void removeColumn(long columnIndex) {
     @Override
     public void renameColumn(long columnIndex, String newName) {
         verifyColumnName(newName);
-        // get the old column name. We'll assume that the old column name is *NOT* an empty string.
+        // Gets the old column name. We'll assume that the old column name is *NOT* an empty string.
         final String oldName = nativeGetColumnName(nativePtr, columnIndex);
-        // also old pk index. Once a column name changes, there is no way you can find the column name
+        // Also old pk index. Once a column name changes, there is no way you can find the column name
         // by old name.
         final long oldPkColumnIndex = getPrimaryKey();
 
-        // then let's try to rename a column. If an error occurs for some reasons, we'll throw.
+        // Then let's try to rename a column. If an error occurs for some reasons, we'll throw.
         nativeRenameColumn(nativePtr, columnIndex, newName);
 
-        // Rename a primary key. At this point, renaming the column name should have been fine.
+        // Renames a primary key. At this point, renaming the column name should have been fine.
         if (oldPkColumnIndex == columnIndex) {
             try {
                 String className = tableNameToClassName(getName());
@@ -220,7 +220,7 @@ public void renameColumn(long columnIndex, String newName) {
                     throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
                 }
             } catch (Exception e) {
-                // we failed to rename the pk meta table. roll back the column name, not pk meta table
+                // We failed to rename the pk meta table. roll back the column name, not pk meta table
                 // then rethrow.
                 nativeRenameColumn(nativePtr, columnIndex, oldName);
                 throw e;
@@ -365,7 +365,7 @@ public void moveLastOver(long rowIndex) {
     }
 
     /**
-     * Add an empty row to the table which doesn't have a primary key defined.
+     * Adds an empty row to the table which doesn't have a primary key defined.
      * <p>
      * NOTE: To add a table with a primary key defined, use {@link #addEmptyRowWithPrimaryKey(Object)} instead. This
      * won't check if this table has a primary key.
@@ -378,7 +378,7 @@ public long addEmptyRow() {
     }
 
     /**
-     * Add an empty row to the table and set the primary key with the given value. Equivalent to call
+     * Adds an empty row to the table and set the primary key with the given value. Equivalent to call
      * {@link #addEmptyRowWithPrimaryKey(Object, boolean)} with {@code validation = true}.
      *
      * @param primaryKeyValue the primary key value
@@ -389,7 +389,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
     }
 
     /**
-     * Add an empty row to the table and set the primary key with the given value.
+     * Adds an empty row to the table and set the primary key with the given value.
      *
      * @param primaryKeyValue the primary key value.
      * @param validation set to {@code false} to skip all validations. This is currently used by bulk insert which
@@ -406,7 +406,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation
         RealmFieldType type = getColumnType(primaryKeyColumnIndex);
         long rowIndex;
 
-        // Add with primary key initially set
+        // Adds with primary key initially set.
         if (primaryKeyValue == null) {
             switch (type) {
                 case STRING:
@@ -481,7 +481,7 @@ public long addEmptyRows(long rows) {
      * @param values values.
      * @return the row index of the appended row.
      * @deprecated Remove this functions since it doesn't seem to be useful. And this function does deal with tables
-     * withprimary key defined well. Primary key has to be set with `setXxxUnique` as the first thing to do after row
+     * with primary key defined well. Primary key has to be set with `setXxxUnique` as the first thing to do after row
      * added.
      */
     protected long add(Object... values) {
@@ -489,7 +489,7 @@ protected long add(Object... values) {
 
         checkImmutable();
 
-        // Check values types
+        // Checks values types.
         int columns = (int)getColumnCount();
         if (columns != values.length) {
             throw new IllegalArgumentException("The number of value parameters (" +
@@ -503,7 +503,7 @@ protected long add(Object... values) {
             RealmFieldType colType = getColumnType(columnIndex);
             colTypes[columnIndex] = colType;
             if (!colType.isValid(value)) {
-                //String representation of the provided value type
+                // String representation of the provided value type.
                 String providedType;
                 if (value == null) {
                     providedType = "null";
@@ -516,7 +516,7 @@ protected long add(Object... values) {
             }
         }
 
-        // Insert values
+        // Inserts values.
         for (long columnIndex = 0; columnIndex < columns; columnIndex++) {
             Object value = values[(int)columnIndex];
             switch (colTypes[(int)columnIndex]) {
@@ -583,7 +583,7 @@ public long getPrimaryKey() {
         } else {
             Table pkTable = getPrimaryKeyTable();
             if (pkTable == null) {
-                return NO_PRIMARY_KEY; // Free table = No primary key
+                return NO_PRIMARY_KEY; // Free table = No primary key.
             }
 
             String className = tableNameToClassName(getName());
@@ -636,7 +636,7 @@ void checkIntValueIsLegal(long columnIndex, long rowToUpdate, long value) {
         }
     }
 
-    // check if it is ok to use null value for given row and column.
+    // Checks if it is ok to use null value for given row and column.
     void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
         if (isPrimaryKeyColumn(columnIndex)) {
             RealmFieldType type = getColumnType(columnIndex);
@@ -695,7 +695,7 @@ public Date getDate(long columnIndex, long rowIndex) {
     }
 
     /**
-     * Gets the value of a (string )cell.
+     * Gets the value of a (string) cell.
      *
      * @param columnIndex 0 based index value of the column
      * @param rowIndex 0 based index of the row.
@@ -718,7 +718,7 @@ public long getLink(long columnIndex, long rowIndex) {
 
     public Table getLinkTarget(long columnIndex) {
         long nativeTablePointer = nativeGetLinkTarget(nativePtr, columnIndex);
-        // Copy context reference from parent
+        // Copies context reference from parent.
         Table table = new Table(this.sharedRealm, nativeTablePointer);
         return table;
     }
@@ -801,7 +801,7 @@ public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefaul
     }
 
     /**
-     * Set a String value to a cell of Table, pointed by column and row index.
+     * Sets a String value to a cell of Table, pointed by column and row index.
      *
      * @param columnIndex 0 based index value of the cell column.
      * @param rowIndex 0 based index value of the cell row.
@@ -883,7 +883,7 @@ private Table getPrimaryKeyTable() {
     }
 
     /**
-     * Invalidating a cached primary key column index for the table.
+     * Invalidates a cached primary key column index for the table.
      */
     private void invalidateCachedPrimaryKeyIndex() {
         cachedPrimaryKeyColumnIndex = NO_MATCH;
@@ -935,7 +935,7 @@ boolean isImmutable() {
         return sharedRealm != null && !sharedRealm.isInTransaction();
     }
 
-    // This checking should be moved to SharedRealm level
+    // This checking should be moved to SharedRealm level.
     void checkImmutable() {
         if (isImmutable()) {
             throwImmutable();
@@ -1055,7 +1055,7 @@ public long count(long columnIndex, String value) {
     @Override
     public TableQuery where() {
         long nativeQueryPtr = nativeWhere(nativePtr);
-        // Copy context reference from parent
+        // Copies context reference from parent.
         return new TableQuery(this.context, this, nativeQueryPtr);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 58404ee5bf..b9e6aa7a27 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -131,8 +131,6 @@
      * @param rowIndex
      * @return
      */
-    //ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex);
-
     byte[] getBinaryByteArray(long columnIndex, long rowIndex);
 
     /**
@@ -196,9 +194,8 @@
      * @param columnIndex
      * @param rowIndex
      * @param data
+     * @param isDefault
      */
-    //void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data);
-
     void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault);
 
     void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 05cdae38d5..902f4445da 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -76,7 +76,7 @@ public long getNativeFinalizerPtr() {
      * Checks in core if query syntax is valid. Throws exception, if not.
      */
     private void validateQuery() {
-        if (! queryValidated) { // If not yet validated, check if syntax is valid
+        if (!queryValidated) { // If not yet validated, checks if syntax is valid
             String invalidMessage = nativeValidateQuery(nativePtr);
             if (invalidMessage.equals(""))
                 queryValidated = true; // If empty string error message, query is valid
@@ -85,7 +85,7 @@ private void validateQuery() {
         }
     }
 
-    // Query TableView
+    // Query TableView.
     public TableQuery tableview(TableView tv) {
         nativeTableview(nativePtr, tv.nativePtr);
         return this;
@@ -117,7 +117,7 @@ public TableQuery not() {
         return this;
     }
 
-    // Query for integer values.
+    // Queries for integer values.
 
     public TableQuery equalTo(long columnIndexes[], long value) {
         nativeEqual(nativePtr, columnIndexes, value);
@@ -161,7 +161,7 @@ public TableQuery between(long columnIndex[], long value1, long value2) {
         return this;
     }
 
-    // Query for float values.
+    // Queries for float values.
 
     public TableQuery equalTo(long columnIndex[], float value) {
         nativeEqual(nativePtr, columnIndex, value);
@@ -205,7 +205,7 @@ public TableQuery between(long columnIndex[], float value1, float value2) {
         return this;
     }
 
-    // Query for double values.
+    // Queries for double values.
 
     public TableQuery equalTo(long columnIndex[], double value) {
         nativeEqual(nativePtr, columnIndex, value);
@@ -257,7 +257,7 @@ public TableQuery equalTo(long columnIndex[], boolean value) {
         return this;
     }
 
-    // Query for Date values
+    // Queries for Date values.
 
     private final static String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
 
@@ -319,7 +319,7 @@ public TableQuery between(long columnIndex[], Date value1, Date value2){
         return this;
     }
 
-    // Query for Binary values.
+    // Queries for Binary values.
 
     public TableQuery equalTo(long[] columnIndices, byte[] value) {
         nativeEqual(nativePtr, columnIndices, value);
@@ -337,7 +337,7 @@ public TableQuery notEqualTo(long[] columnIndices, byte[] value) {
 
     private final static String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
 
-    // Equal
+    // Equals
     public TableQuery equalTo(long[] columnIndexes, String value, Case caseSensitive) {
         nativeEqual(nativePtr, columnIndexes, value, caseSensitive.getValue());
         queryValidated = false;
@@ -350,7 +350,7 @@ public TableQuery equalTo(long[] columnIndexes, String value) {
         return this;
     }
 
-    // Not Equal
+    // Not Equals
     public TableQuery notEqualTo(long columnIndex[], String value, Case caseSensitive) {
         nativeNotEqual(nativePtr, columnIndex, value, caseSensitive.getValue());
         queryValidated = false;
@@ -462,7 +462,7 @@ public TableView findAll() {
         return new TableView(this.context, this.table, nativeViewPtr, this);
     }
 
-    // handover find* methods
+    // Handovers find* methods.
     // this will use a background SharedGroup to import the query (using the handover object)
     // run the query, and return the table view to the caller SharedGroup using the handover object.
     public static long findAllWithHandover(SharedRealm sharedRealm, long ptrQuery) throws BadVersionException {
@@ -564,7 +564,7 @@ public double averageInt(long columnIndex) {
         return nativeAverageInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    // float aggregation
+    // Float aggregation
 
     public double sumFloat(long columnIndex, long start, long end, long limit) {
         validateQuery();
@@ -602,7 +602,7 @@ public double averageFloat(long columnIndex) {
         return nativeAverageFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    // double aggregation
+    // Double aggregation
 
     public double sumDouble(long columnIndex, long start, long end, long limit) {
         validateQuery();
@@ -640,7 +640,7 @@ public double averageDouble(long columnIndex) {
         return nativeAverageDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    // date aggregation
+    // Date aggregation
 
     public Date maximumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
@@ -689,7 +689,7 @@ public TableQuery isNotNull(long columnIndices[]) {
         return this;
     }
 
-    // count
+    // Count
 
     // TODO: Rename all start, end parameter names to firstRow, lastRow
     public long count(long start, long end, long limit) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index 9c352f08bc..5bf309d3c7 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -426,7 +426,7 @@ public void removeLast() {
         }
     }
 
-    // Search for first match
+    // Searches for first match
     @Override
     public long findFirstLong(long columnIndex, long value){
         return nativeFindFirstInt(nativePtr, columnIndex, value);
@@ -459,7 +459,7 @@ public long findFirstString(long columnIndex, String value){
         return nativeFindFirstString(nativePtr, columnIndex, value);
     }
 
-    // Search for all matches
+    // Searches for all matches
 
     // TODO..
     @Override
@@ -618,7 +618,7 @@ public Date minimumDate(long columnIndex) {
         return new Date(result);
     }
 
-    // Sorting
+    // Sortings
     public void sort(long columnIndex, Sort sortOrder) {
         // Don't check for immutable. Sorting does not modify original table
         nativeSort(nativePtr, columnIndex, sortOrder.getValue());
@@ -723,7 +723,7 @@ public void distinct(long columnIndex) {
     }
 
     /**
-     * If two rows are indentical (for the given set of distinct-columns), then the last row is
+     * If two rows are identical (for the given set of distinct-columns), then the last row is
      * removed unless sorted, in which case the first object is returned.
      * Each time distinct() gets called, it will first fetch the full original TableView contents
      * and then apply distinct() on that, invalidating previous distinct().
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index b5b963f072..7a18693df0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -225,7 +225,7 @@ public void setDate(long columnIndex, Date date) {
     }
 
     /**
-     * Set a string value to a row pointer.
+     * Sets a string value to a row pointer.
      *
      * @param columnIndex 0 based index value of the cell column.
      * @param value the value to to a row
@@ -266,7 +266,7 @@ public boolean isNull(long columnIndex) {
     }
 
     /**
-     * Set null to a row pointer.
+     * Sets null to a row pointer.
      *
      * @param columnIndex 0 based index value of the cell column.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index d262452289..46de7e107e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -36,7 +36,7 @@ public static long getNativeMemUsage() {
     }
     static native long nativeGetMemUsage();
 
-    // Called by JNI. Do not remove
+    // Called by JNI. Do not remove.
     static void javaPrint(String txt) {
         System.out.print(txt);
     }
@@ -51,8 +51,8 @@ public static String getTablePrefix() {
      * was a RealmProxy class.
      */
     public static Class<? extends RealmModel> getOriginalModelClass(Class<? extends RealmModel> clazz) {
-        //This cast is correct because 'clazz' is either the type
-        //generated by RealmProxy or the original type extending directly from RealmObject
+        // This cast is correct because 'clazz' is either the type
+        // generated by RealmProxy or the original type extending directly from RealmObject.
         @SuppressWarnings("unchecked")
         Class<? extends RealmModel> superclass = (Class<? extends RealmModel>) clazz.getSuperclass();
 
@@ -102,8 +102,8 @@ public static boolean deleteRealm(String canonicalPath, File realmFolder, String
         final String management = ".management";
         File managementFolder = new File(realmFolder, realmFileName + management);
 
-        // delete files in management directory and the directory
-        // there is no subfolders in the management directory
+        // Deletes files in management directory and the directory.
+        // There is no subfolders in the management directory.
         File[] files = managementFolder.listFiles();
         if (files != null) {
             for (File file : files) {
@@ -112,7 +112,7 @@ public static boolean deleteRealm(String canonicalPath, File realmFolder, String
         }
         realmDeleted = realmDeleted && managementFolder.delete();
 
-        // delete specific files in root directory
+        // Deletes specific files in root directory.
         return realmDeleted && deletes(canonicalPath, realmFolder, realmFileName);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
index bfdd9bb032..5d9b90636b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
@@ -70,27 +70,27 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
         try {
             int offset = pos.getIndex();
 
-            // extract year
+            // Extracts year.
             int year = parseInt(date, offset, offset += 4);
             if (checkOffset(date, offset, '-')) {
                 offset += 1;
             }
 
-            // extract month
+            // Extracts month.
             int month = parseInt(date, offset, offset += 2);
             if (checkOffset(date, offset, '-')) {
                 offset += 1;
             }
 
-            // extract day
+            // Extracts day.
             int day = parseInt(date, offset, offset += 2);
-            // default time value
+            // Default time value.
             int hour = 0;
             int minutes = 0;
             int seconds = 0;
-            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
+            int milliseconds = 0; // Always use 0 otherwise returned date will include millis of current time.
 
-            // if the value has no time component (and no time zone), we are done
+            // If the value has no time component (and no time zone), we are done.
             boolean hasT = checkOffset(date, offset, 'T');
 
             if (!hasT && (date.length() <= offset)) {
@@ -102,7 +102,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
 
             if (hasT) {
 
-                // extract hours, minutes, seconds and milliseconds
+                // Extracts hours, minutes, seconds and milliseconds.
                 hour = parseInt(date, offset += 1, offset += 2);
                 if (checkOffset(date, offset, ':')) {
                     offset += 1;
@@ -112,20 +112,20 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
                 if (checkOffset(date, offset, ':')) {
                     offset += 1;
                 }
-                // second and milliseconds can be optional
+                // Second and milliseconds can be optional.
                 if (date.length() > offset) {
                     char c = date.charAt(offset);
                     if (c != 'Z' && c != '+' && c != '-') {
                         seconds = parseInt(date, offset, offset += 2);
-                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
-                        // milliseconds can be optional in the format
+                        if (seconds > 59 && seconds < 63) seconds = 59; // Truncates up to 3 leap seconds.
+                        // Milliseconds can be optional in the format.
                         if (checkOffset(date, offset, '.')) {
                             offset += 1;
-                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
-                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
+                            int endOffset = indexOfNonDigit(date, offset + 1); // Assumes at least one digit.
+                            int parseEndOffset = Math.min(endOffset, offset + 3); // Parses up to 3 digits.
                             int fraction = parseInt(date, offset, parseEndOffset);
-                            // compensate for "missing" digits
-                            switch (parseEndOffset - offset) { // number of digits parsed
+                            // Compensates for "missing" digits.
+                            switch (parseEndOffset - offset) { // Number of digits parsed.
                                 case 2:
                                     milliseconds = fraction * 10;
                                     break;
@@ -141,7 +141,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
                 }
             }
 
-            // extract timezone
+            // Extracts timezone.
             if (date.length() <= offset) {
                 throw new IllegalArgumentException("No time zone indicator");
             }
@@ -164,7 +164,6 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
                     //    `java.util.TimeZone` specifically instruct use of GMT as base for
                     //    custom timezones... odd.
                     String timezoneId = "GMT" + timezoneOffset;
-//                    String timezoneId = "UTC" + timezoneOffset;
 
                     timezone = TimeZone.getTimeZone(timezoneId);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java b/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
index 3bc9da984a..b25cd67328 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
@@ -44,14 +44,14 @@
     public static Date stringToDate(String date) {
         if (date == null || date.length() == 0) return null;
 
-        // Check for JSON date
+        // Checks for JSON date.
         Matcher matcher = jsonDate.matcher(date);
         if (matcher.find()) {
             String dateMatch = matcher.group(1);
             return new Date(Long.parseLong(dateMatch));
         }
 
-        // Check for millisecond based date
+        // Checks for millisecond based date.
         if (numericOnly.matcher(date).matches()) {
             try {
                 return new Date(Long.parseLong(date));
@@ -60,9 +60,9 @@ public static Date stringToDate(String date) {
             }
         }
 
-        // Try for ISO8601 date
+        // Tries for ISO8601 date.
         try {
-            parsePosition.setIndex(0); // reset the position each time
+            parsePosition.setIndex(0); // Resets the position each time.
             return ISO8601Utils.parse(date, parsePosition);
         } catch (ParseException e) {
             throw new RealmException(e.getMessage(), e);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 7d943b06a1..4f387d012d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -37,7 +37,7 @@
 public class RealmThreadPoolExecutor extends ThreadPoolExecutor {
     private static final String SYS_CPU_DIR = "/sys/devices/system/cpu/";
 
-    // reduce context switching by using a number of thread proportionate to the number of cores
+    // Reduces context switching by using a number of thread proportionate to the number of cores.
     private static final int CORE_POOL_SIZE = calculateCorePoolSize();
     private static final int QUEUE_SIZE = 100;
 
@@ -60,7 +60,7 @@ public static RealmThreadPoolExecutor newSingleThreadExecutor() {
     }
 
     /**
-     * Try using the number of files named 'cpuNN' in sysfs to figure out the number of
+     * Tries using the number of files named 'cpuNN' in sysfs to figure out the number of
      * processors on this device. `Runtime.getRuntime().availableProcessors()` may return
      * a smaller number when the device is sleeping.
      *
@@ -76,8 +76,8 @@ private static int calculateCorePoolSize() {
     }
 
     /**
-     * @param dirPath A directory path
-     * @param pattern A regex
+     * @param dirPath a directory path
+     * @param pattern a regex
      * @return the number of files, in the `dirPath` directory, whose names match `pattern`
      */
     private static int countFilesInDir(String dirPath, String pattern) {
@@ -174,7 +174,7 @@ public void pause() {
     }
 
     /**
-     * Resume executing any scheduled tasks.
+     * Resumes executing any scheduled tasks.
      */
     public void resume() {
         pauseLock.lock();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index 3374d337be..e2cee9d70f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -178,7 +178,7 @@ public boolean transformerApplied() {
         return originalMediator.transformerApplied();
     }
 
-    // Validate if a model class (not RealmProxy) is part of this Schema.
+    // Validates if a model class (not RealmProxy) is part of this Schema.
     private void checkSchemaHasClass(Class<? extends RealmModel> clazz) {
         if (!allowedClasses.contains(clazz)) {
             throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
diff --git a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
index d39f536486..87a1a98094 100644
--- a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
+++ b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
@@ -69,7 +69,7 @@ public void setTag(String tag) {
 
     @Override
     public int getMinimumNativeDebugLevel() {
-        // Map Android log level to Realms log levels
+        // Maps Android log level to Realms log levels.
         switch (minimumLogLevel) {
             case Log.VERBOSE:   return LogLevel.TRACE;
             case Log.DEBUG:     return LogLevel.DEBUG;
@@ -89,7 +89,7 @@ private void log(int androidLogLevel, Throwable t, String message, Object... arg
         }
         if (message == null) {
             if (t == null) {
-                return; // Ignore event if message is null and there's no throwable.
+                return; // Ignores event if message is null and there's no throwable.
             }
             message = getStackTraceString(t);
         } else {
@@ -101,14 +101,14 @@ private void log(int androidLogLevel, Throwable t, String message, Object... arg
             }
         }
 
-        // Message fit one line. Just print and exit
+        // Message fits one line. Just prints and exits.
         if (message.length() < LOG_ENTRY_MAX_LENGTH) {
             Log.println(androidLogLevel, logTag, message);
             return;
         }
 
         // Message does not fit one line.
-        // Split by line, then ensure each line can fit into Log's maximum length.
+        // Splits by line, then ensures each line can fit into Log's maximum length.
         for (int i = 0, length = message.length(); i < length; i++) {
             int newline = message.indexOf('\n', i);
             newline = newline != -1 ? newline : length;
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index e16d1be4b6..877e8d9e0e 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -353,7 +353,7 @@ public static void fatal(Throwable throwable, String message, Object... args) {
         log(LogLevel.FATAL, throwable, message, args);
     }
 
-    // Format the message, parse the stacktrace of given throwable and pass them to nativeLog.
+    // Formats the message, parses the stacktrace of given throwable and passes them to nativeLog.
     private static void log(int level, Throwable throwable, String message, Object... args) {
         StringBuilder stringBuilder = new StringBuilder();
         if (args != null && args.length > 0) {
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 7c89ecd45a..2a0a090e61 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -67,7 +67,7 @@
         return Observable.create(new Observable.OnSubscribe<Realm>() {
             @Override
             public void call(final Subscriber<? super Realm> subscriber) {
-                // Get instance to make sure that the Realm is open for as long as the
+                // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
@@ -97,7 +97,7 @@ public void call() {
         return Observable.create(new Observable.OnSubscribe<DynamicRealm>() {
             @Override
             public void call(final Subscriber<? super DynamicRealm> subscriber) {
-                // Get instance to make sure that the Realm is open for as long as the
+                // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 final RealmChangeListener<DynamicRealm> listener = new RealmChangeListener<DynamicRealm>() {
@@ -117,7 +117,7 @@ public void call() {
                     }
                 }));
 
-                    // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
                 // value.
                 subscriber.onNext(observableRealm);
             }
@@ -131,7 +131,7 @@ public void call() {
         return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
             @Override
             public void call(final Subscriber<? super RealmResults<E>> subscriber) {
-                // Get instance to make sure that the Realm is open for as long as the
+                // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
@@ -154,7 +154,7 @@ public void call() {
                     }
                 }));
 
-                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
                 // value.
                 subscriber.onNext(results);
             }
@@ -167,7 +167,7 @@ public void call() {
         return Observable.create(new Observable.OnSubscribe<RealmResults<DynamicRealmObject>>() {
             @Override
             public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subscriber) {
-                // Get instance to make sure that the Realm is open for as long as the
+                // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
@@ -190,7 +190,7 @@ public void call() {
                     }
                 }));
 
-                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
                 // value.
                 subscriber.onNext(results);
             }
@@ -217,7 +217,7 @@ public void call() {
         return Observable.create(new Observable.OnSubscribe<E>() {
             @Override
             public void call(final Subscriber<? super E> subscriber) {
-                // Get instance to make sure that the Realm is open for as long as the
+                // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
@@ -240,7 +240,7 @@ public void call() {
                     }
                 }));
 
-                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
                 // value.
                 subscriber.onNext(object);
             }
@@ -253,7 +253,7 @@ public void call() {
         return Observable.create(new Observable.OnSubscribe<DynamicRealmObject>() {
             @Override
             public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
-                // Get instance to make sure that the Realm is open for as long as the
+                // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
@@ -276,7 +276,7 @@ public void call() {
                     }
                 }));
 
-                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
                 // value.
                 subscriber.onNext(object);
             }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
index 5ab8d01656..fcf681a3ec 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -38,14 +38,14 @@ public static void init(Context context) {
         } catch (Exception ignore) {
         }
 
-        // Configure default UserStore
-        UserStore userStore = new RealmFileUserStore(context.getFilesDir().getPath());
-
-        SyncManager.init(appId, userStore);
-
         // init the "sync_manager.cpp" metadata Realm, this is also needed later, when re try
         // to schedule a client reset. in realm-java#master this is already done, when initialising
         // the RealmFileUserStore (not available now on releases)
         SyncManager.nativeConfigureMetaDataSystem(context.getFilesDir().getPath());
+
+        // Configure default UserStore
+        UserStore userStore = new RealmFileUserStore();
+
+        SyncManager.init(appId, userStore);
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index 9ba14bff4e..61a3ad24c5 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -24,9 +24,6 @@
  * A User Store backed by a Realm file to store user.
  */
 public class RealmFileUserStore implements UserStore {
-    protected RealmFileUserStore(String path) {
-        nativeConfigureMetaDataSystem(path);
-    }
 
     /**
      * {@inheritDoc}
@@ -87,9 +84,6 @@ private static SyncUser toSyncUserOrNull(String userJson) {
         return SyncUser.fromJson(userJson);
     }
 
-    // init and load the Metadata Realm containing SyncUsers
-    protected static native void nativeConfigureMetaDataSystem(String baseFile);
-
     // returns json data (token) of the current logged in user
     protected static native String nativeGetCurrentUser();
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 9ee7b0f868..baa076c0f8 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -277,7 +277,8 @@ boolean isSyncConfiguration() {
          *
          * @param user the user for this Realm. An authenticated {@link SyncUser} is required to open any Realm managed
          *             by a Realm Object Server.
-         * @param uri URI identifying the Realm.
+         * @param uri URI identifying the Realm. If only a path like {@code /~/default} is given, the configuration will
+         *            assume the file is located on the same server returned by {@link SyncUser#getAuthenticationUrl()}.
          *
          * @see SyncUser#isValid()
          */
@@ -319,10 +320,44 @@ private void validateAndSet(String uri) {
                 throw new IllegalArgumentException("Invalid URI: " + uri, e);
             }
 
-            // scheme must be realm or realms
-            String scheme = serverUrl.getScheme();
-            if (!scheme.equals("realm") && !scheme.equals("realms")) {
-                throw new IllegalArgumentException("Invalid scheme: " + scheme);
+            try {
+                // Automatically set scheme based on auth server if not set or wrongly set
+                String serverScheme = serverUrl.getScheme();
+                if (serverScheme == null) {
+                    String authProtocol = user.getAuthenticationUrl().getProtocol();
+                    if (authProtocol.equalsIgnoreCase("https")) {
+                        serverScheme = "realms";
+                    } else {
+                        serverScheme = "realm";
+                    }
+                } else if (serverScheme.equalsIgnoreCase("http")) {
+                    serverScheme = "realm";
+                } else if (serverScheme.equalsIgnoreCase("https")) {
+                    serverScheme = "realms";
+                }
+
+                // Automatically set host if one wasn't defined
+                String host = serverUrl.getHost();
+                if (host == null) {
+                    host = user.getAuthenticationUrl().getHost();
+                }
+
+                // Convert relative paths to absolute if required
+                String path = serverUrl.getPath();
+                if (path != null && !path.startsWith("/")) {
+                    path = "/" + path;
+                }
+
+                serverUrl = new URI(serverScheme,
+                        serverUrl.getUserInfo(),
+                        host,
+                        serverUrl.getPort(),
+                        (path != null) ? path.replace(host + "/", "") : null, // Remove host if it accidentially was interpreted as a path segment
+                        serverUrl.getQuery(),
+                        serverUrl.getRawFragment());
+
+            } catch (URISyntaxException e) {
+                throw new IllegalArgumentException("Invalid URI: " + uri, e);
             }
 
             // Detect last path segment as it is the default file name
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index d191e0d278..eac47154eb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -361,7 +361,7 @@ public String toJson() {
      * Returns {@code true} if the user is logged into the Realm Object Server. If this method returns {@code true} it
      * implies that the user has valid credentials that have not expired.
      * <p>
-     * The user might still be have been logged out by the Realm Object Server which will not be detected before the
+     * The user might still have been logged out by the Realm Object Server which will not be detected before the
      * user tries to actively synchronize a Realm. If a logged out user tries to synchronize a Realm, an error will be
      * reported to the {@link SyncSession.ErrorHandler} defined by
      * {@link SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)}.
@@ -407,6 +407,15 @@ public Realm getManagementRealm() {
         return Realm.getInstance(managementConfig.initAndGetManagementRealmConfig(syncUser, this));
     }
 
+    /**
+     * Returns the {@link URL} where this user was authenticated.
+     *
+     * @return {@link URL} where the user was authenticated.
+     */
+    public URL getAuthenticationUrl() {
+        return syncUser.getAuthenticationUrl();
+    }
+
     // Creates the URL to the permission Realm based on the authentication URL.
     private static String getManagementRealmUrl(URL authUrl) {
         String scheme = "realm";
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
index 6b27dfc7d7..e921daec6c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
@@ -56,11 +56,11 @@ public static AuthenticateRequest userLogin(SyncCredentials credentials) {
     /**
      * Generates a request for refreshing a user token.
      */
-    public static AuthenticateRequest userRefresh(Token userToken) {
+    public static AuthenticateRequest userRefresh(Token userToken, URI serverUrl) {
         return new AuthenticateRequest("realm",
                 userToken.value(),
                 SyncManager.APP_ID,
-                null,
+                serverUrl.getPath(),
                 Collections.<String, Object>emptyMap()
         );
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index b217269ad7..3b74558cc6 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -48,7 +48,7 @@
      * Before it expires, the client should try to refresh the token, effectively keeping the user logged in on the
      * Object Server. Failing to do so will cause a "soft logout", where the User will have limited access rights.
      */
-    AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl);
+    AuthenticateResponse refreshUser(Token userToken, URI serverUrl, URL authenticationUrl);
 
     /**
      * Logs out the user on the Object Server by invalidating the refresh token. Each device should be given their
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
index aa613c8357..ab53fff060 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
@@ -44,7 +44,7 @@ protected boolean shouldAbortTask(T response) {
         }
     }
 
-    // Callback when task is have succeeded
+    // Callback when task have succeeded
     protected abstract void onSuccess(T response);
 
     // Callback when task has failed
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index fe580d438b..b4bbb18cde 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -67,9 +67,9 @@ public AuthenticateResponse loginToRealm(Token refreshToken, URI serverUrl, URL
     }
 
     @Override
-    public AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl) {
+    public AuthenticateResponse refreshUser(Token userToken, URI serverUrl, URL authenticationUrl) {
         try {
-            String requestBody = AuthenticateRequest.userRefresh(userToken).toJson();
+            String requestBody = AuthenticateRequest.userRefresh(userToken, serverUrl).toJson();
             return authenticate(authenticationUrl, requestBody);
         } catch (Exception e) {
             return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
index 3d78d24aa5..615e23b5f5 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
@@ -19,6 +19,9 @@
 import java.net.URI;
 import java.util.HashMap;
 import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
@@ -99,6 +102,8 @@
     private long nativeSessionPointer;
     private final ObjectServerUser user;
     RealmAsyncTask networkRequest;
+    private RealmAsyncTask refreshTokenTask;
+    private RealmAsyncTask refreshTokenNetworkRequest;
     NetworkStateReceiver.ConnectionListener networkListener;
     private SyncPolicy syncPolicy;
 
@@ -106,7 +111,9 @@
     private SessionState currentStateDescription;
     private FsmState currentState;
     private SyncSession userSession;
-    private SyncSession publicSession;
+
+    private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
+    private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
 
     /**
      * Creates a new Object Server Session.
@@ -166,6 +173,8 @@ public synchronized void start() {
      * Stops the session. The session can no longer be used.
      */
     public synchronized void stop() {
+        // tries to stop any scheduled access_token refresh
+        clearScheduledAccessTokenRefresh();
         currentState.onStop();
     }
 
@@ -238,6 +247,25 @@ void stopNativeSession() {
             nativeUnbind(nativeSessionPointer);
             nativeSessionPointer = 0;
         }
+        clearScheduledAccessTokenRefresh();
+    }
+
+    // It is an error to call this function before calling Client::bind() state
+    private boolean updateSessionAccessToken(String userToken) {
+        if (nativeSessionPointer != 0 && isBound()) {
+            nativeRefresh(nativeSessionPointer, userToken);
+            return true;
+        }
+        return false;
+    }
+
+    private void clearScheduledAccessTokenRefresh() {
+        if (refreshTokenTask != null) {
+            refreshTokenTask.cancel();
+        }
+        if (refreshTokenNetworkRequest != null) {
+            refreshTokenNetworkRequest.cancel();
+        }
     }
 
     void removeAccessToken() {
@@ -260,6 +288,10 @@ void authenticateRealm(final Runnable onSuccess, final SyncSession.ErrorHandler
         if (networkRequest != null) {
             networkRequest.cancel();
         }
+        // clear any previously scheduled refresh access_token
+        // since we're going to obtain a new refresh_token
+        clearScheduledAccessTokenRefresh();
+
         // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
         Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
             @Override
@@ -279,6 +311,8 @@ protected void onSuccess(AuthenticateResponse response) {
                         configuration.shouldDeleteRealmOnLogout()
                 );
                 user.addRealm(configuration.getServerUrl(), desc);
+                // schedule a token refresh before it expires
+                scheduleRefreshAccessToken(response.getAccessToken().expiresMs());
                 onSuccess.run();
             }
 
@@ -290,6 +324,78 @@ protected void onError(AuthenticateResponse response) {
         networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
     }
 
+    private void scheduleRefreshAccessToken(long expireDateInMs) {
+        // calculate the delay time before which we should refresh the access_token,
+        // we adjust to 10 second to proactively refresh the access_token before the session
+        // hit the expire date on the token
+        long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
+        if (refreshAfter < 0) {
+            // Token already expired
+            RealmLog.debug("Expires time already reached for the access token, refreshing now");
+            refreshAccessToken();
+
+        } else {
+            RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
+            if (refreshTokenTask != null) {
+                refreshTokenTask.cancel();
+            }
+
+            ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
+                @Override
+                public void run() {
+                    refreshAccessToken();
+                }
+            }, refreshAfter, TimeUnit.MILLISECONDS);
+            refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
+        }
+    }
+
+    // Authenticate by getting access tokens for the specific Realm
+    private void refreshAccessToken() {
+        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
+        if (refreshTokenNetworkRequest != null) {
+            refreshTokenNetworkRequest.cancel();
+        }
+        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
+            @Override
+            protected AuthenticateResponse execute() {
+                return authServer.refreshUser(user.getUserToken(), configuration.getServerUrl(), user.getAuthenticationUrl());
+            }
+
+            @Override
+            protected void onSuccess(AuthenticateResponse response) {
+                synchronized (ObjectServerSession.this) {
+                    RealmLog.debug("Access Token refreshed successfully");
+                    if (updateSessionAccessToken(response.getAccessToken().value())) {
+                        RealmLog.debug("Token applied");
+                        // only schedule an update if the token was updated.
+                        // The callback might return will the session state is not BOUND
+                        // in this case we'll wait for the new session state to transition to
+                        // BOUND, which will schedule a refresh in the process
+
+                        // this will also avoid updating a stopped session
+
+                        // replaced the user old access_token
+                        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
+                                response.getAccessToken(),
+                                configuration.getPath(),
+                                configuration.shouldDeleteRealmOnLogout()
+                        );
+                        user.addRealm(configuration.getServerUrl(), desc);
+                        // schedule the next refresh
+                        scheduleRefreshAccessToken(response.getAccessToken().expiresMs());
+                    }
+                }
+            }
+
+            @Override
+            protected void onError(AuthenticateResponse response) {
+                RealmLog.error("Unrecoverable error, while refreshing the access Token (" + response.getError().toString() + ") reschedule will not happen");
+            }
+        });
+        refreshTokenNetworkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
+    }
+
     /**
      * Checks if a user has valid credentials for accessing this Realm.
      *
diff --git a/version.txt b/version.txt
index b4308ebebb..855ff9501e 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-2.4.0-SNAPSHOT
+2.4.0-SNAPSHOT
\ No newline at end of file
