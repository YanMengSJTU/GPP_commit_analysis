diff --git a/CHANGELOG.md b/CHANGELOG.md
index e267c9cde2..3e2532e149 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,10 +1,23 @@
-## 4.3.2 (YYYY-MM-DD)
+## 4.3.3 (2018-01-19)
+
+### Internal
+
+* Downgrade JavaAssist to 3.21.0-GA to fix an issue with a `ClassNotFoundException` at runtime (#5641).
+
+
+## 4.3.2 (2018-01-17)
 
 ### Bug Fixes
 
 * Throws a better exception message when calling `RealmObjectSchema.addField()` with a `RealmModel` class (#3388).
 * Use https for Realm version checker (#4043).
 * Prevent Realms Gradle plugin from transitively forcing specific versions of Google Build Tools onto downstream projects (#5640).
+* [ObjectServer] logging a warning message instead of throwing an exception, when sync report an unknown error code (#5403).
+
+### Enhancements
+
+* [ObjectServer] added support for both Anonymous and Nickname authentication.
+
 
 ### Internal
 
diff --git a/Jenkinsfile b/Jenkinsfile
index e2f45c0704..fec751058f 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -87,7 +87,7 @@ try {
 
                 stage('Static code analysis') {
                   try {
-                    gradle('realm', 'findbugs pmd checkstyle')
+                    gradle('realm', 'findbugs pmd checkstyle -PbuildTargetABIs=${ABIs}')
                   } finally {
                     publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
                     publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
diff --git a/dependencies.list b/dependencies.list
index da2d4d0168..bd4aa3ff41 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -5,5 +5,5 @@ REALM_SYNC_SHA256=d770d639d2b187c15e6d0bc798b909f5b424d61444f1f83f9e56f5be43e96a
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.1.0
+REALM_OBJECT_SERVER_DE_VERSION=2.6.0
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Required.java b/realm-annotations/src/main/java/io/realm/annotations/Required.java
index 2950b0e3de..16750abcf8 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Required.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Required.java
@@ -21,13 +21,20 @@
 import java.lang.annotation.Target;
 
 /**
- * This annotation will mark the field as not nullable. When the field is {@link Required},
- * it cannot be set to {@code null}.
+ * This annotation will mark the field or the element of a primitive {@link io.realm.RealmList} as not nullable.
  * <p>
- * Only {@code Boolean, Byte, Short, Integer, Long, Float, Double, String, byte[], Date} can be annotated
- * with {@link Required}. Compiling will fail when fields with other types have {@link Required} annotation.
- * Fields with primitive types and the {@link io.realm.RealmList} type are required implicitly.
- * Fields with {@link io.realm.RealmObject} type are always nullable.
+ * When a field of type {@code Boolean, Byte, Short, Integer, Long, Float, Double, String, byte[], Date} is annotated
+ * with {@link Required}, it cannot be set to {@code null}.
+ * <p>
+ * Fields with primitive types are implicitly required.
+ * <p>
+ * When a primitive {@link io.realm.RealmList} ({@code RealmList<String>, RealmList<byte[]>, RealmList<Boolean>,
+ * RealmList<Byte>, RealmList<Short>, RealmList<Integer>, RealmList<Long>, RealmList<Float>, RealmList<Double>,
+ * RealmList<Date>}) is annotated with {@link Required}, it cannot contain {@code null} values.
+ * <p>
+ * The {@link io.realm.RealmList} field itself is required always.
+ * <p>
+ * Compiling will fail when fields with other types have {@link Required} annotation.
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index 5fdb8f61c8..eb4789361d 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -61,7 +61,7 @@ dependencies {
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
     compileOnly 'com.android.tools.build:gradle:3.1.0-alpha06'
-    compile 'org.javassist:javassist:3.22.0-GA'
+    compile 'org.javassist:javassist:3.21.0-GA'
 
     testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
         exclude module: 'groovy-all'
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 6faacbfa29..54e8560b88 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -144,7 +144,6 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitGetExpectedObjectSchemaInfo(writer);
         emitCreateColumnInfoMethod(writer);
         emitGetSimpleClassNameMethod(writer);
-        emitGetFieldNamesMethod(writer);
         emitCreateOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
         emitCopyOrUpdateMethod(writer);
@@ -240,15 +239,6 @@ private void emitClassFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine()
                 .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
                 EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");
-
-        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
-        writer.beginInitializer(true)
-            .emitStatement("List<String> fieldNames = new ArrayList<String>(%s)", metadata.getFields().size());
-            for (VariableElement field : metadata.getFields()) {
-                writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
-            }
-        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
-            .endInitializer();
     }
     //@formatter:on
 
@@ -840,15 +830,6 @@ private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException
     }
     //@formatter:on
 
-    //@formatter:off
-    private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-                .emitStatement("return FIELD_NAMES")
-                .endMethod()
-                .emitEmptyLine();
-    }
-    //@formatter:on
-
     //@formatter:off
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 1370de9e12..a667e57590 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -98,7 +98,6 @@ public void generate() throws IOException {
         emitFields(writer);
         emitGetExpectedObjectSchemaInfoMap(writer);
         emitCreateColumnInfoMethod(writer);
-        emitGetFieldNamesMethod(writer);
         emitGetSimpleClassNameMethod(writer);
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
@@ -167,24 +166,6 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "List<String>",
-                "getFieldNames",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz"
-        );
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getFieldNames()", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
     private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index fb00a17894..03e4de06d4 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -121,31 +121,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>(20);
-        fieldNames.add("columnString");
-        fieldNames.add("columnLong");
-        fieldNames.add("columnFloat");
-        fieldNames.add("columnDouble");
-        fieldNames.add("columnBoolean");
-        fieldNames.add("columnDate");
-        fieldNames.add("columnBinary");
-        fieldNames.add("columnMutableRealmInteger");
-        fieldNames.add("columnObject");
-        fieldNames.add("columnRealmList");
-        fieldNames.add("columnStringList");
-        fieldNames.add("columnBinaryList");
-        fieldNames.add("columnBooleanList");
-        fieldNames.add("columnLongList");
-        fieldNames.add("columnIntegerList");
-        fieldNames.add("columnShortList");
-        fieldNames.add("columnByteList");
-        fieldNames.add("columnDoubleList");
-        fieldNames.add("columnFloatList");
-        fieldNames.add("columnDateList");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
 
     private AllTypesColumnInfo columnInfo;
     private ProxyState<some.test.AllTypes> proxyState;
@@ -893,10 +868,6 @@ public static String getSimpleClassName() {
         return "AllTypes";
     }
 
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
     @SuppressWarnings("cast")
     public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index b9573557f8..cb8c2ffb70 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -71,15 +71,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>(4);
-        fieldNames.add("done");
-        fieldNames.add("isReady");
-        fieldNames.add("mCompleted");
-        fieldNames.add("anotherBoolean");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
 
     private BooleansColumnInfo columnInfo;
     private ProxyState<some.test.Booleans> proxyState;
@@ -211,10 +202,6 @@ public static String getSimpleClassName() {
         return "Booleans";
     }
 
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
     @SuppressWarnings("cast")
     public static some.test.Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index bef81c5e86..fecf92e93e 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -182,52 +182,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>(41);
-        fieldNames.add("fieldStringNotNull");
-        fieldNames.add("fieldStringNull");
-        fieldNames.add("fieldBooleanNotNull");
-        fieldNames.add("fieldBooleanNull");
-        fieldNames.add("fieldBytesNotNull");
-        fieldNames.add("fieldBytesNull");
-        fieldNames.add("fieldByteNotNull");
-        fieldNames.add("fieldByteNull");
-        fieldNames.add("fieldShortNotNull");
-        fieldNames.add("fieldShortNull");
-        fieldNames.add("fieldIntegerNotNull");
-        fieldNames.add("fieldIntegerNull");
-        fieldNames.add("fieldLongNotNull");
-        fieldNames.add("fieldLongNull");
-        fieldNames.add("fieldFloatNotNull");
-        fieldNames.add("fieldFloatNull");
-        fieldNames.add("fieldDoubleNotNull");
-        fieldNames.add("fieldDoubleNull");
-        fieldNames.add("fieldDateNotNull");
-        fieldNames.add("fieldDateNull");
-        fieldNames.add("fieldObjectNull");
-        fieldNames.add("fieldStringListNotNull");
-        fieldNames.add("fieldStringListNull");
-        fieldNames.add("fieldBinaryListNotNull");
-        fieldNames.add("fieldBinaryListNull");
-        fieldNames.add("fieldBooleanListNotNull");
-        fieldNames.add("fieldBooleanListNull");
-        fieldNames.add("fieldLongListNotNull");
-        fieldNames.add("fieldLongListNull");
-        fieldNames.add("fieldIntegerListNotNull");
-        fieldNames.add("fieldIntegerListNull");
-        fieldNames.add("fieldShortListNotNull");
-        fieldNames.add("fieldShortListNull");
-        fieldNames.add("fieldByteListNotNull");
-        fieldNames.add("fieldByteListNull");
-        fieldNames.add("fieldDoubleListNotNull");
-        fieldNames.add("fieldDoubleListNull");
-        fieldNames.add("fieldFloatListNotNull");
-        fieldNames.add("fieldFloatListNull");
-        fieldNames.add("fieldDateListNotNull");
-        fieldNames.add("fieldDateListNull");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
 
     private NullTypesColumnInfo columnInfo;
     private ProxyState<some.test.NullTypes> proxyState;
@@ -1753,10 +1707,6 @@ public static String getSimpleClassName() {
         return "NullTypes";
     }
 
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
     @SuppressWarnings("cast")
     public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 80a30b44ef..506273e123 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -47,16 +47,6 @@ public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaIn
         throw getMissingProxyClassException(clazz);
     }
 
-    @Override
-    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
-        checkClass(clazz);
-
-        if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.getFieldNames();
-        }
-        throw getMissingProxyClassException(clazz);
-    }
-
     @Override
     public String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 4473a97537..1ea6822a31 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -65,13 +65,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>(2);
-        fieldNames.add("name");
-        fieldNames.add("age");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
 
     private SimpleColumnInfo columnInfo;
     private ProxyState<some.test.Simple> proxyState;
@@ -165,10 +158,6 @@ public static String getSimpleClassName() {
         return "Simple";
     }
 
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
     @SuppressWarnings("cast")
     public static some.test.Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
index 41e9115fb0..d16d0f5bc7 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
@@ -24,6 +24,7 @@
 import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -107,6 +108,33 @@ public void jwt_invalidInput() {
         }
     }
 
+    @Test
+    public void anonymous() {
+        SyncCredentials creds = SyncCredentials.anonymous();
+        assertEquals(SyncCredentials.IdentityProvider.ANONYMOUS, creds.getIdentityProvider());
+        assertTrue(creds.getUserInfo().isEmpty());
+    }
+
+    @Test
+    public void nickname() {
+        SyncCredentials creds = SyncCredentials.nickname("foo", false);
+        assertEquals(SyncCredentials.IdentityProvider.NICKNAME, creds.getIdentityProvider());
+        assertFalse(creds.getUserInfo().isEmpty());
+        assertFalse((Boolean) creds.getUserInfo().get("is_admin"));
+    }
+
+    @Test
+    public void nickname_invalidInput() {
+        String[] invalidInput = {null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.nickname(input, false);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
     @Test
     public void usernamePassword_register() {
         SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar", true);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index f4dc71ac09..152a993251 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -25,9 +25,12 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -96,17 +99,11 @@ public void removeProgressListener() {
         SyncSession session = SyncManager.getSession(configuration);
         ProgressListener[] listeners = new ProgressListener[] {
                 null,
-                new ProgressListener() {
-                    @Override
-                    public void onChange(Progress progress) {
-                        // Listener 1, not present
-                    }
+                progress -> {
+                    // Listener 1, not present
                 },
-                new ProgressListener() {
-                    @Override
-                    public void onChange(Progress progress) {
-                        // Listener 2, present
-                    }
+                progress -> {
+                    // Listener 2, present
                 }
         };
         session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);
@@ -125,23 +122,20 @@ public void errorHandler_clientResetReported() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
-                            fail("Wrong error " + error.toString());
-                            return;
-                        }
-
-                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
-                        String filePathFromError = handler.getOriginalFile().getAbsolutePath();
-                        String filePathFromConfig = session.getConfiguration().getPath();
-                        assertEquals(filePathFromError, filePathFromConfig);
-                        assertFalse(handler.getBackupFile().exists());
-                        assertTrue(handler.getOriginalFile().exists());
-
-                        looperThread.testComplete();
+                .errorHandler((session, error) -> {
+                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                        fail("Wrong error " + error.toString());
+                        return;
                     }
+
+                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                    String filePathFromError = handler.getOriginalFile().getAbsolutePath();
+                    String filePathFromConfig = session.getConfiguration().getPath();
+                    assertEquals(filePathFromError, filePathFromConfig);
+                    assertFalse(handler.getBackupFile().exists());
+                    assertTrue(handler.getOriginalFile().exists());
+
+                    looperThread.testComplete();
                 })
                 .build();
 
@@ -159,30 +153,27 @@ public void errorHandler_manualExecuteClientReset() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
-                            fail("Wrong error " + error.toString());
-                            return;
-                        }
-
-                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
-                        try {
-                            handler.executeClientReset();
-                            fail("All Realms should be closed before executing Client Reset can be allowed");
-                        } catch(IllegalStateException ignored) {
-                        }
-
-                        // Execute Client Reset
-                        looperThread.closeTestRealms();
-                        handler.executeClientReset();
+                .errorHandler((session, error) -> {
+                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                        fail("Wrong error " + error.toString());
+                        return;
+                    }
 
-                        // Validate that files have been moved
-                        assertFalse(handler.getOriginalFile().exists());
-                        assertTrue(handler.getBackupFile().exists());
-                        looperThread.testComplete();
+                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                    try {
+                        handler.executeClientReset();
+                        fail("All Realms should be closed before executing Client Reset can be allowed");
+                    } catch(IllegalStateException ignored) {
                     }
+
+                    // Execute Client Reset
+                    looperThread.closeTestRealms();
+                    handler.executeClientReset();
+
+                    // Validate that files have been moved
+                    assertFalse(handler.getOriginalFile().exists());
+                    assertTrue(handler.getBackupFile().exists());
+                    looperThread.testComplete();
                 })
                 .build();
 
@@ -200,43 +191,40 @@ public void errorHandler_useBackupSyncConfigurationForClientReset() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
-                            fail("Wrong error " + error.toString());
-                            return;
-                        }
-
-                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
-                        // Execute Client Reset
-                        looperThread.closeTestRealms();
-                        handler.executeClientReset();
-
-                        // Validate that files have been moved
-                        assertFalse(handler.getOriginalFile().exists());
-                        assertTrue(handler.getBackupFile().exists());
-
-                        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
-                        assertNotNull(backupRealmConfiguration);
-                        assertFalse(backupRealmConfiguration.isSyncConfiguration());
-                        assertTrue(backupRealmConfiguration.isRecoveryConfiguration());
-
-                        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
-                        assertFalse(backupRealm.isEmpty());
-                        assertEquals(1, backupRealm.where(StringOnly.class).count());
-                        assertEquals("Foo", backupRealm.where(StringOnly.class).findAll().first().getChars());
-                        backupRealm.close();
-
-                        // opening a Dynamic Realm should also work
-                        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
-                        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
-                        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
-                        assertEquals(1, all.size());
-                        assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
-                        dynamicRealm.close();
-                        looperThread.testComplete();
+                .errorHandler((session, error) -> {
+                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                        fail("Wrong error " + error.toString());
+                        return;
                     }
+
+                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                    // Execute Client Reset
+                    looperThread.closeTestRealms();
+                    handler.executeClientReset();
+
+                    // Validate that files have been moved
+                    assertFalse(handler.getOriginalFile().exists());
+                    assertTrue(handler.getBackupFile().exists());
+
+                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
+                    assertNotNull(backupRealmConfiguration);
+                    assertFalse(backupRealmConfiguration.isSyncConfiguration());
+                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration());
+
+                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+                    assertFalse(backupRealm.isEmpty());
+                    assertEquals(1, backupRealm.where(StringOnly.class).count());
+                    assertEquals("Foo", backupRealm.where(StringOnly.class).findAll().first().getChars());
+                    backupRealm.close();
+
+                    // opening a Dynamic Realm should also work
+                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+                    assertEquals(1, all.size());
+                    assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
+                    dynamicRealm.close();
+                    looperThread.testComplete();
                 })
                 .modules(new StringOnlyModule())
                 .build();
@@ -261,68 +249,65 @@ public void errorHandler_useBackupSyncConfigurationAfterClientReset() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
-                            fail("Wrong error " + error.toString());
-                            return;
-                        }
-
-                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
-                        // Execute Client Reset
-                        looperThread.closeTestRealms();
-                        handler.executeClientReset();
+                .errorHandler((session, error) -> {
+                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                        fail("Wrong error " + error.toString());
+                        return;
+                    }
+
+                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                    // Execute Client Reset
+                    looperThread.closeTestRealms();
+                    handler.executeClientReset();
+
+                    // Validate that files have been moved
+                    assertFalse(handler.getOriginalFile().exists());
+                    assertTrue(handler.getBackupFile().exists());
+
+                    String backupFile = handler.getBackupFile().getAbsolutePath();
+
+                    // this SyncConf doesn't specify any module, it will throw a migration required
+                    // exception since the backup Realm contain only StringOnly table
+                    RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);
+
+                    try {
+                        Realm.getInstance(backupRealmConfiguration);
+                        fail("Expected to throw a Migration required");
+                    } catch (RealmMigrationNeededException expected) {
+                    }
+
+                    // opening a DynamicRealm will work though
+                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
 
-                        // Validate that files have been moved
-                        assertFalse(handler.getOriginalFile().exists());
-                        assertTrue(handler.getBackupFile().exists());
-
-                        String backupFile = handler.getBackupFile().getAbsolutePath();
-
-                        // this SyncConf doesn't specify any module, it will throw a migration required
-                        // exception since the backup Realm contain only StringOnly table
-                        RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);
-
-                        try {
-                            Realm.getInstance(backupRealmConfiguration);
-                            fail("Expected to throw a Migration required");
-                        } catch (RealmMigrationNeededException expected) {
-                        }
-
-                        // opening a DynamicRealm will work though
-                        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
-
-                        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
-                        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
-                        assertEquals(1, all.size());
-                        assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
-
-                        // make sure we can't write to it (read-only Realm)
-                        try {
-                            dynamicRealm.beginTransaction();
-                            fail("Can't perform transactions on read-only Realms");
-                        } catch (IllegalStateException expected) {
-                        }
-                        dynamicRealm.close();
-
-                        try {
-                            SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);
-                            fail("Expected to throw java.lang.Class is not a RealmModule");
-                        } catch (IllegalArgumentException expected) {
-                        }
-
-                        // specifying the module will allow to open the typed Realm
-                        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());
-                        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
-                        assertFalse(backupRealm.isEmpty());
-                        assertEquals(1, backupRealm.where(StringOnly.class).count());
-                        RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();
-                        assertEquals("Foo", allSorted.get(0).getChars());
-                        backupRealm.close();
-
-                        looperThread.testComplete();
+                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+                    assertEquals(1, all.size());
+                    assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
+
+                    // make sure we can't write to it (read-only Realm)
+                    try {
+                        dynamicRealm.beginTransaction();
+                        fail("Can't perform transactions on read-only Realms");
+                    } catch (IllegalStateException expected) {
+                    }
+                    dynamicRealm.close();
+
+                    try {
+                        SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);
+                        fail("Expected to throw java.lang.Class is not a RealmModule");
+                    } catch (IllegalArgumentException expected) {
                     }
+
+                    // specifying the module will allow to open the typed Realm
+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());
+                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+                    assertFalse(backupRealm.isEmpty());
+                    assertEquals(1, backupRealm.where(StringOnly.class).count());
+                    RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();
+                    assertEquals("Foo", allSorted.get(0).getChars());
+                    backupRealm.close();
+
+                    looperThread.testComplete();
                 })
                 .modules(new StringOnlyModule())
                 .build();
@@ -347,46 +332,43 @@ public void errorHandler_useClientResetEncrypted() {
         final byte[] randomKey = TestHelper.getRandomKey();
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                 .encryptionKey(randomKey)
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
-                            fail("Wrong error " + error.toString());
-                            return;
-                        }
-
-                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
-                        // Execute Client Reset
-                        looperThread.closeTestRealms();
-                        handler.executeClientReset();
+                .errorHandler((session, error) -> {
+                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                        fail("Wrong error " + error.toString());
+                        return;
+                    }
 
-                        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
-
-                        // can open encrypted backup Realm
-                        Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
-                        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
-                        RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
-                        assertEquals("Foo", allSorted.get(0).getChars());
-                        backupEncryptedRealm.close();
-
-                        String backupFile = handler.getBackupFile().getAbsolutePath();
-                        // build a conf to open a DynamicRealm
-                        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());
-                        backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
-                        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
-                        allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
-                        assertEquals("Foo", allSorted.get(0).getChars());
-                        backupEncryptedRealm.close();
-
-                        // using wrong key throw
-                        try {
-                            Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));
-                            fail("Expected to throw when using wrong encryption key");
-                        } catch (RealmFileException expected) {
-                        }
-
-                        looperThread.testComplete();
+                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                    // Execute Client Reset
+                    looperThread.closeTestRealms();
+                    handler.executeClientReset();
+
+                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
+
+                    // can open encrypted backup Realm
+                    Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
+                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
+                    RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
+                    assertEquals("Foo", allSorted.get(0).getChars());
+                    backupEncryptedRealm.close();
+
+                    String backupFile = handler.getBackupFile().getAbsolutePath();
+                    // build a conf to open a DynamicRealm
+                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());
+                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
+                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
+                    allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
+                    assertEquals("Foo", allSorted.get(0).getChars());
+                    backupEncryptedRealm.close();
+
+                    // using wrong key throw
+                    try {
+                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));
+                        fail("Expected to throw when using wrong encryption key");
+                    } catch (RealmFileException expected) {
                     }
+
+                    looperThread.testComplete();
                 })
                 .modules(new StringOnlyModule())
                 .build();
@@ -427,4 +409,32 @@ public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedExcept
             realm.close();
         }
     }
+
+    @Test
+    @UiThreadTest
+    public void unrecognizedErrorCode_errorHandler() {
+        AtomicBoolean errorHandlerCalled = new AtomicBoolean(false);
+        configuration = new SyncConfiguration
+                .Builder(user, REALM_URI)
+                .errorHandler((session, error) -> {
+                    errorHandlerCalled.set(true);
+                    assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                    assertEquals(ErrorCode.Category.FATAL, error.getCategory());
+
+                })
+                .build();
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+
+        session.notifySessionError(3, "Unknown Error");
+        RealmLog.remove(testLogger);
+
+        assertTrue(errorHandlerCalled.get());
+        assertEquals("Unknown error code: 3", testLogger.message);
+
+        realm.close();
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 8517ee7f43..9aab0ffd5b 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 8517ee7f4378fe0f54945b3e4973766ff65e455d
+Subproject commit 9aab0ffd5bc7bfc438ec28375ba581cf732f57ee
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 188a6f96b2..58db9cfe46 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -60,14 +60,6 @@
      */
     public abstract ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo);
 
-    /**
-     * Returns a map of non-obfuscated object field names to their internal Realm name.
-     *
-     * @param clazz the {@link RealmObject} class reference.
-     * @return The simple name of an RealmObject class (before it has been obfuscated).
-     */
-    public abstract List<String> getFieldNames(Class<? extends RealmModel> clazz);
-
     /**
      * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated simple name of the
      * class.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 08df441f79..626041c3cb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -76,12 +76,6 @@ public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaIn
         return mediator.createColumnInfo(clazz, osSchemaInfo);
     }
 
-    @Override
-    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
-        RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.getFieldNames(clazz);
-    }
-
     @Override
     protected String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         RealmProxyMediator mediator = getMediator(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index ef9fb5654c..b3ec7decb9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -91,12 +91,6 @@ public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaIn
         return originalMediator.createColumnInfo(clazz, osSchemaInfo);
     }
 
-    @Override
-    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
-        checkSchemaHasClass(clazz);
-        return originalMediator.getFieldNames(clazz);
-    }
-
     @Override
     protected String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         checkSchemaHasClass(clazz);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 24f936108f..8b47653bec 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -19,6 +19,8 @@
 
 import java.io.IOException;
 
+import io.realm.log.RealmLog;
+
 /**
  * This class enumerate all potential errors related to using the Object Server or synchronizing data.
  */
@@ -192,7 +194,8 @@ public static ErrorCode fromInt(int errorCode) {
                 return error;
             }
         }
-        throw new IllegalArgumentException("Unknown error code: " + errorCode);
+        RealmLog.warn("Unknown error code: " + errorCode);
+        return UNKNOWN;
     }
 
     /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 0ff32a6bfe..560bafff7a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -22,6 +22,8 @@
 
 import javax.annotation.Nullable;
 
+import io.realm.internal.Util;
+
 
 /**
  * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm
@@ -110,6 +112,38 @@ public static SyncCredentials jwt(String jwtToken) {
         return new SyncCredentials(jwtToken, IdentityProvider.JWT, null);
     }
 
+    /**
+     * Creates credentials anonymously.
+     *
+     *  Note: logging the user out again means that data is lost with no means of recovery
+     *  and it isn't possible to share the user details across devices.
+     *
+     * @return a set of credentials that can be used to log into the Object Server using
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     */
+    public static SyncCredentials anonymous() {
+        return new SyncCredentials("", IdentityProvider.ANONYMOUS, null);
+    }
+
+    /**
+     * Creates credentials using a nickname.
+     *
+     * Note: This is mainly intended for demo/test, since it's ie. possible to log user
+     * in by just knowing their "nickname" (no password required).
+     * This provider should not be used in production.
+     *
+     * @param nickname that identifies a user
+     * @return a set of credentials that can be used to log into the Object Server using
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if the nickname is either {@code null} or empty.
+     */
+    public static SyncCredentials nickname(String nickname, boolean isAdmin) {
+        assertStringNotEmpty(nickname, "nickname");
+        Map<String, Object> userInfo = new HashMap<String, Object>();
+        userInfo.put("is_admin", isAdmin);
+        return new SyncCredentials(nickname, IdentityProvider.NICKNAME, userInfo);
+    }
+
     /**
      * Creates credentials based on a login with username and password. These credentials will only be verified
      * by the Object Server.
@@ -207,7 +241,7 @@ public static SyncCredentials accessToken(String accessToken, String identifier,
 
     private static void assertStringNotEmpty(String string, String message) {
         //noinspection ConstantConditions
-        if (string == null || "".equals(string)) {
+        if (Util.isEmptyString(string)) {
             throw new IllegalArgumentException("Non-null '" + message + "' required.");
         }
     }
@@ -282,6 +316,16 @@ public String getUserIdentifier() {
          */
         public static final String JWT = "jwt";
 
+        /**
+         * Credentials do not require user/password (anonymous user).
+         */
+        public static final String ANONYMOUS = "anonymous";
+
+        /**
+         * Credentials will be verified with a nickname.
+         */
+        public static final String NICKNAME = "nickname";
+
         /**
          * Credentials will be verified by the Object Server.
          *
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 30555e9628..09f4c8a275 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -34,6 +34,7 @@
 import io.realm.SyncUserInfo;
 import io.realm.TestHelper;
 import io.realm.entities.StringOnly;
+import io.realm.internal.Util;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.objectserver.Token;
 import io.realm.objectserver.utils.Constants;
@@ -123,12 +124,7 @@ public void login_withAccessToken() {
             public void onSuccess(SyncUser user) {
                 assertTrue(user.isAdmin());
                 final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
-                        .errorHandler(new SyncSession.ErrorHandler() {
-                            @Override
-                            public void onError(SyncSession session, ObjectServerError error) {
-                                fail("Session failed: " + error);
-                            }
-                        })
+                        .errorHandler((session, error) -> fail("Session failed: " + error))
                         .build();
 
                 final Realm realm = Realm.getInstance(config);
@@ -144,6 +140,84 @@ public void onError(ObjectServerError error) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void login_withAnonymous() {
+        SyncCredentials credentials = SyncCredentials.anonymous();
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                assertFalse(user.isAdmin());
+                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                        .errorHandler((session, error) -> fail("Session failed: " + error))
+                        .build();
+
+                final Realm realm = Realm.getInstance(config);
+                looperThread.addTestRealm(realm);
+                assertFalse(Util.isEmptyString(config.getUser().getIdentity()));
+                assertTrue(config.getUser().isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail("Login failed: " + error);
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void login_withNickname() {
+        SyncCredentials credentials = SyncCredentials.nickname("foo", false);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                assertFalse(user.isAdmin());
+                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                        .errorHandler((session, error) -> fail("Session failed: " + error))
+                        .build();
+
+                final Realm realm = Realm.getInstance(config);
+                looperThread.addTestRealm(realm);
+                assertFalse(Util.isEmptyString(config.getUser().getIdentity()));
+                assertTrue(config.getUser().isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail("Login failed: " + error);
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void login_withNicknameAsAdmin() {
+        SyncCredentials credentials = SyncCredentials.nickname("foo", true);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                assertTrue(user.isAdmin());
+                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                        .errorHandler((session, error) -> fail("Session failed: " + error))
+                        .build();
+
+                final Realm realm = Realm.getInstance(config);
+                looperThread.addTestRealm(realm);
+                assertFalse(Util.isEmptyString(config.getUser().getIdentity()));
+                assertTrue(config.getUser().isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail("Login failed: " + error);
+            }
+        });
+    }
+
     @Test
     public void loginAsync_errorHandlerThrows() throws InterruptedException {
         final AtomicBoolean errorThrown = new AtomicBoolean(false);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
deleted file mode 100644
index d13f3546d1..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver.suite;
-
-
-import org.junit.runner.RunWith;
-import org.junit.runners.Suite;
-
-import io.realm.SSLConfigurationTests;
-import io.realm.SyncedRealmTests;
-import io.realm.objectserver.AuthTests;
-import io.realm.objectserver.EncryptedSynchronizedRealmTests;
-import io.realm.objectserver.ProcessCommitTests;
-import io.realm.objectserver.ProgressListenerTests;
-import io.realm.SyncSessionTests;
-
-// Test suite includes all integration tests. Makes it easy to run all integration tests in the Android Studio.
-@RunWith(Suite.class)
-@Suite.SuiteClasses({
-        SSLConfigurationTests.class,
-        SyncedRealmTests.class,
-        AuthTests.class,
-        EncryptedSynchronizedRealmTests.class,
-        ProcessCommitTests.class,
-        ProgressListenerTests.class,
-        SyncSessionTests.class})
-public class IntegrationTestSuite {
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index dc0ae46830..e456364cf0 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -36,7 +36,8 @@
     // "Realm could not be deleted errors".
     // FIXME re-adjust timeout after https://github.com/realm/realm-object-server-private/issues/697 is fixed
     private final static OkHttpClient client = new OkHttpClient.Builder()
-            .connectTimeout(2, TimeUnit.MINUTES)
+            .connectTimeout(40, TimeUnit.SECONDS)
+            .readTimeout(40, TimeUnit.SECONDS)// since ROS startup timeout is 30s
             .build();
 
     // adb reverse tcp:8888 tcp:8888
@@ -55,10 +56,6 @@ public static void startSyncServer() throws Exception {
 
         Response response = client.newCall(request).execute();
         if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-        // Work around race condition between starting ROS and logging in first user
-        // See https://github.com/realm/ros/issues/389
-        SystemClock.sleep(2000);
     }
 
     /**
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index bdf1938075..25561bbb7e 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -50,7 +50,7 @@ function waitForRosToInitialize(attempts, onSuccess, onError, startSequence) {
     }
     http.get("http://0.0.0.0:9080/health", function(res) {
         if (res.statusCode != 200) {
-            winston.info("ROS /health/ returned: " + res.statusCode)
+            winston.warn("ROS /health/ returned: " + res.statusCode)
             setTimeout(function() {
                 waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence);
             }, 500);
@@ -58,6 +58,7 @@ function waitForRosToInitialize(attempts, onSuccess, onError, startSequence) {
             onSuccess(startSequence);
         }
     }).on('error', function(err) {
+        winston.warn("ROS /health/ returned an error: " + err)
         // ROS not accepting any connections yet.
         // Errors like ECONNREFUSED 0.0.0.0:9080 will be reported here.
         // Wait a little before trying again (common startup is ~1 second).
@@ -114,8 +115,8 @@ function doStartRealmObjectServer(onSuccess, onError) {
                 winston.info(`${data}`);
             });
 
-            // The interval between every health check is 0.5 second. Give the ROS 15 seconds to get fully initialized.
-            waitForRosToInitialize(30, onSuccess, onError, Date.now());
+            // The interval between every health check is 0.5 second. Give the ROS 30 seconds to get fully initialized.
+            waitForRosToInitialize(60, onSuccess, onError, Date.now());
         }
     });
 }
diff --git a/version.txt b/version.txt
index b2595557b0..932e22fb7f 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.3.2-SNAPSHOT
\ No newline at end of file
+4.3.4-SNAPSHOT
\ No newline at end of file
