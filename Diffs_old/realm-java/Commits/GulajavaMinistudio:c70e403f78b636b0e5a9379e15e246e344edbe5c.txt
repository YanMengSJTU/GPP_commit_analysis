diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5d0bfd1490..608561c02d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,15 +1,35 @@
-## 3.8.0 (YYYY-MM-DD)
+4.0.0-BETA3 (YYYY-MM-DD)
+
+### Internal
+
+* Upgraded to Realm Sync 2.0.0-rc16.
+* Upgraded to Realm Core 3.0.0-rc5.
+
+## 4.0.0-BETA2 (2017-07-27)
+
+### Bug Fixes
+
+* [ObjectServer] Realm no longer throws a native “unsupported instruction” exception in some cases when opening a synced Realm asynchronously (https://github.com/realm/realm-object-store/issues/502).
+
+## 4.0.0-BETA1 (2017-07-13)
 
 ### Breaking Changes
 
+* [ObjectServer] Updated protocol version to 19 which is only compatible with ROS > 2.0.0.
+
 ### Deprecated
 
 ### Enhancements
 
+* Added `static RealmObject.getRealm(RealmModel)`, `RealmObject.getRealm()` and `DynamicRealmObject.getDynamicRealm()` (#4720).
+
 ### Bug Fixes
 
 ### Internal
 
+* Upgraded to Realm Sync 2.0.0-rc12.
+* Upgraded to Realm Core 3.0.0-rc3.
+
 
 ## 3.7.1 (2017-09-07)
 
diff --git a/README.md b/README.md
index fd6eac9bce..566e4cf044 100644
--- a/README.md
+++ b/README.md
@@ -28,7 +28,7 @@ The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/j
 
 ## Using Snapshots
 
-If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [OJO](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-android/)
+If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [Jfrog OSS](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-gradle-plugin/)
 
 ```gradle
 buildscript {
diff --git a/dependencies.list b/dependencies.list
index 5294502a2c..2187414c7a 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,13 +1,13 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.10.8
-REALM_SYNC_SHA256=ee47cbce2bcbd105a27d0a6b64316f8ffcb1a090e697c8025d738ef5917de408
+REALM_SYNC_VERSION=2.0.0-rc16
+REALM_SYNC_SHA256=c20c4e7333f01a3a4ea350cb20b9b7feba95ad4e52d612368b6187b72d518aa1
 
 # Object Server Release used by Integration tests
-# `realm` is stable releases, `realm-testing` is developer builds.
-# https://packagecloud.io/realm/realm?filter=debs
-# https://packagecloud.io/realm/realm-testing?filter=debs
+# Stable releases:  https://packagecloud.io/realm/realm?filter=debs
+# Beta releases:    https://packagecloud.io/realm/realm-beta?filter=debs
+# Developer builds: https://packagecloud.io/realm/realm-testing?filter=debs
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
-# install/use between 'realm' and 'realm-testing', the version below should
+# install/use between 'realm', 'realm-beta' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.8.3-83
+REALM_OBJECT_SERVER_DE_VERSION=2.0.0-rc2-285
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java b/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
index d0f94eeeea..6cb9137fe3 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
@@ -29,11 +29,11 @@
     private String isCompleted;
     private String currentTableVersion;
 
-    public String getRealm() {
+    public String getRealmString() {
         return realm;
     }
 
-    public void setRealm(String realm) {
+    public void setRealmString(String realm) {
         this.realm = realm;
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 568e3b29e2..9877018d9b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -18,6 +18,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.Matchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -56,6 +57,8 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -1158,7 +1161,11 @@ public void getFieldNames() {
                 AllJavaTypes.FIELD_DOUBLE, AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE,
                 AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
         String[] keys = dObjTyped.getFieldNames();
-        assertArrayEquals(expectedKeys, keys);
+        // After the stable ID support, primary key field will be inserted first before others. So even FIELD_STRING is
+        // the first defined field in the class, it will be inserted after FIELD_ID.
+        // See ObjectStore::add_initial_columns #if REALM_HAVE_SYNC_STABLE_IDS branch.
+        assertEquals(expectedKeys.length, keys.length);
+        assertThat(Arrays.asList(expectedKeys), Matchers.hasItems(keys));
     }
 
     @Test
@@ -1259,4 +1266,102 @@ public void testExceptionMessage() {
             assertEquals("Illegal Argument: Field not found: nonExisting", e.getMessage());
         }
     }
+
+    @Test
+    public void getDynamicRealm() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+
+        assertSame(dynamicRealm, object.getDynamicRealm());
+    }
+
+    @Test
+    public void getRealm() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+
+        thrown.expect(IllegalStateException.class);
+        object.getRealm();
+    }
+
+    @Test
+    public void getRealm_closedObjectThrows() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+        dynamicRealm.close();
+        dynamicRealm = null;
+
+        try {
+            object.getDynamicRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(BaseRealm.CLOSED_REALM_MESSAGE, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealmConfiguration_deletedObjectThrows() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+        dynamicRealm.beginTransaction();
+        object.deleteFromRealm();
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.getDynamicRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(RealmObject.MSG_DELETED_OBJECT, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealm_illegalThreadThrows() throws Throwable {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+
+        final CountDownLatch threadFinished = new CountDownLatch(1);
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        final Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    object.getDynamicRealm();
+                    fail();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                } finally {
+                    threadFinished.countDown();
+                }
+            }
+        });
+        thread.start();
+        TestHelper.awaitOrFail(threadFinished);
+
+        final Throwable thrownInTheThread = throwable.get();
+        if (!(thrownInTheThread instanceof IllegalStateException)) {
+            throw thrownInTheThread;
+        }
+        assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, thrownInTheThread.getMessage());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 404b9efe9d..7ece4e46b1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -47,6 +47,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
+import io.realm.entities.pojo.AllTypesRealmModel;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
@@ -61,6 +62,7 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -1377,7 +1379,7 @@ public void execute(Realm realm) {
     @Test
     public void conflictingFieldName_readAndUpdate() {
         final ConflictingFieldName unmanaged = new ConflictingFieldName();
-        unmanaged.setRealm("realm");
+        unmanaged.setRealmString("realm");
         unmanaged.setRow("row");
         unmanaged.setIsCompleted("isCompleted");
         unmanaged.setListeners("listeners");
@@ -1393,7 +1395,7 @@ public void execute(Realm realm) {
 
         // Tests those values are persisted.
         final ConflictingFieldName managed = realm.where(ConflictingFieldName.class).findFirst();
-        assertEquals("realm", managed.getRealm());
+        assertEquals("realm", managed.getRealmString());
         assertEquals("row", managed.getRow());
         assertEquals("isCompleted", managed.getIsCompleted());
         assertEquals("listeners", managed.getListeners());
@@ -1404,7 +1406,7 @@ public void execute(Realm realm) {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                managed.setRealm("realm_updated");
+                managed.setRealmString("realm_updated");
                 managed.setRow("row_updated");
                 managed.setIsCompleted("isCompleted_updated");
                 managed.setListeners("listeners_updated");
@@ -1413,7 +1415,7 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals("realm_updated", managed.getRealm());
+        assertEquals("realm_updated", managed.getRealmString());
         assertEquals("row_updated", managed.getRow());
         assertEquals("isCompleted_updated", managed.getIsCompleted());
         assertEquals("listeners_updated", managed.getListeners());
@@ -1923,4 +1925,153 @@ public void execute(Realm realm) {
             }
         });
     }
+
+    @Test
+    public void getRealm_managedRealmObject() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        assertSame(realm, object.getRealm());
+        assertSame(realm, RealmObject.getRealm(object));
+    }
+
+    @Test
+    public void getRealm_managedRealmModel() {
+        realm.beginTransaction();
+        AllTypesRealmModel object = realm.createObject(AllTypesRealmModel.class, 1L);
+        realm.commitTransaction();
+
+        assertSame(realm, RealmObject.getRealm(object));
+    }
+
+    @Test
+    public void getRealm_DynamicRealmObject() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object = dynamicRealm.createObject("AllTypesRealmModel", 1L);
+            dynamicRealm.commitTransaction();
+
+            try {
+                object.getRealm();
+                fail();
+            } catch (IllegalStateException expected) {
+                assertEquals(RealmObject.MSG_DYNAMIC_OBJECT, expected.getMessage());
+            }
+            try {
+                RealmObject.getRealm(object);
+                fail();
+            } catch (IllegalStateException expected) {
+                assertEquals(RealmObject.MSG_DYNAMIC_OBJECT, expected.getMessage());
+            }
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void getRealm_unmanagedRealmObjectReturnsNull() {
+        assertNull(new AllTypes().getRealm());
+        assertNull(RealmObject.getRealm(new AllTypes()));
+    }
+
+    @Test
+    public void getRealm_unmanagedRealmModelReturnsNull() {
+        assertNull(RealmObject.getRealm(new AllTypesRealmModel()));
+    }
+
+    @Test
+    public void getRealm_null() {
+        try {
+            RealmObject.getRealm(null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(RealmObject.MSG_NULL_OBJECT, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealm_closedObjectThrows() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        realm.close();
+        realm = null;
+
+        try {
+            object.getRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(BaseRealm.CLOSED_REALM_MESSAGE, e.getMessage());
+        }
+        try {
+            RealmObject.getRealm(object);
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(BaseRealm.CLOSED_REALM_MESSAGE, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealmConfiguration_deletedObjectThrows() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        object.deleteFromRealm();
+        realm.commitTransaction();
+
+        try {
+            object.getRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(RealmObject.MSG_DELETED_OBJECT, e.getMessage());
+        }
+        try {
+            RealmObject.getRealm(object);
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(RealmObject.MSG_DELETED_OBJECT, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealm_illegalThreadThrows() throws Throwable {
+        realm.beginTransaction();
+        final AllTypes object = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final CountDownLatch threadFinished = new CountDownLatch(1);
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        final Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    object.getRealm();
+                    fail();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                    threadFinished.countDown();
+                    return;
+                }
+                try {
+                    RealmObject.getRealm(object);
+                    fail();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                } finally {
+                    threadFinished.countDown();
+                }
+            }
+        });
+        thread.start();
+        TestHelper.awaitOrFail(threadFinished);
+
+        final Throwable thrownInTheThread = throwable.get();
+        if (!(thrownInTheThread instanceof IllegalStateException)) {
+            throw thrownInTheThread;
+        }
+        assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, thrownInTheThread.getMessage());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index 0106d8ac2d..6db847312d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -167,6 +167,199 @@ public void create_duplicatedNameThrows() {
         realmSchema.create("Foo");
     }
 
+    @Test
+    public void createWithPrimaryKeyField_string() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.createWithPrimaryKeyField(validClassNames[0], "pkField", String.class);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            // Not nullable
+            RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", String.class, FieldAttribute.REQUIRED);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.STRING, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+
+            realmSchema.remove(validClassName);
+
+            // Nullable
+            objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", String.class);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.STRING, objectSchema.getFieldType("pkField"));
+            assertTrue(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_boxedInteger() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.createWithPrimaryKeyField(validClassNames[0], "pkField", Integer.class);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            // Not nullable
+
+            RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", Integer.class, FieldAttribute.REQUIRED);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+
+            realmSchema.remove(validClassName);
+
+            // Nullable
+
+            objectSchema = realmSchema.createWithPrimaryKeyField(validClassName, "pkField", Integer.class);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertTrue(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_int() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.createWithPrimaryKeyField(validClassNames[0], "pkField", int.class);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            // Not nullable
+
+            RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", int.class, FieldAttribute.REQUIRED);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+
+            realmSchema.remove(validClassName);
+
+            // Nullable
+
+            objectSchema = realmSchema.createWithPrimaryKeyField(validClassName, "pkField", int.class);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_explicitIndexed() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class,
+                FieldAttribute.INDEXED);
+        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass("Foo");
+        assertEquals("pkField", objectSchema.getPrimaryKey());
+        assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+        assertFalse(objectSchema.isNullable("pkField"));
+        assertTrue(objectSchema.hasIndex("pkField"));
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_explicitPrimaryKey() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class,
+                FieldAttribute.PRIMARY_KEY);
+        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass("Foo");
+        assertEquals("pkField", objectSchema.getPrimaryKey());
+        assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+        assertFalse(objectSchema.isNullable("pkField"));
+        assertTrue(objectSchema.hasIndex("pkField"));
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_invalidClassNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        String[] invalidNames = { null, "", TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH + 1) };
+
+        for (String name : invalidNames) {
+            try {
+                realmSchema.createWithPrimaryKeyField(name, "pkField", int.class);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            assertFalse(String.format("'%s' failed", name), realmSchema.contains(name));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_invalidFieldNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        String[] invalidFieldNames = new String[] { null, "", "foo.bar", TestHelper.getRandomString(65) };
+        for (String fieldName : invalidFieldNames) {
+            try {
+                realmSchema.createWithPrimaryKeyField("Foo", fieldName, int.class);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_invalidFieldTypeThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        Class<?>[] fieldTypes = new Class<?>[] {float.class, Float.class, Double.class, double.class, RealmObject.class,
+                RealmList.class, Object.class};
+        for (Class<?> fieldType : fieldTypes) {
+            try {
+                realmSchema.createWithPrimaryKeyField("Foo", "pkField", fieldType);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_duplicatedNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class);
+        thrown.expect(IllegalArgumentException.class);
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class);
+    }
+
     @Test
     public void get() {
         RealmObjectSchema objectSchema = realmSchema.get(AllJavaTypes.CLASS_NAME);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 43329e65d4..75c4a917c7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -355,11 +355,12 @@ public void log(int level, String tag, Throwable throwable, String message) {
         };
     }
 
+    // Generate a random string with only capital letters which is always a valid class/field name.
     public static String getRandomString(int length) {
         Random r = new Random();
         StringBuilder sb = new StringBuilder(length);
         for (int i = 0; i < length; i++) {
-            sb.append((char) r.nextInt(128)); // Restrict to standard ASCII chars.
+            sb.append((char) (r.nextInt(26) + 'A')); // Restrict to capital letters
         }
         return sb.toString();
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
index 8592877b95..ef350a1dee 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
@@ -26,11 +26,11 @@
     private String isCompleted;
     private String currentTableVersion;
 
-    public String getRealm() {
+    public String getRealmString() {
         return realm;
     }
 
-    public void setRealm(String realm) {
+    public void setRealmString(String realm) {
         this.realm = realm;
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index f6f9970675..1b9152b3d6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -66,7 +66,7 @@ public void tearDown() {
     private Table getTableWithStringPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table t = sharedRealm.createTable("TestTable");
+        Table t = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = t.addColumn(RealmFieldType.STRING, "colName", true);
         t.addSearchIndex(column);
         t.setPrimaryKey("colName");
@@ -76,7 +76,7 @@ private Table getTableWithStringPrimaryKey() {
     private Table getTableWithIntegerPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table t = sharedRealm.createTable("TestTable");
+        Table t = sharedRealm.createTable(Table.getTableNameForClass("class_TestTable"));
         long column = t.addColumn(RealmFieldType.INTEGER, "colName");
         t.addSearchIndex(column);
         t.setPrimaryKey("colName");
@@ -91,7 +91,7 @@ public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         SharedRealm sharedRealm = SharedRealm.getInstance(config);
 
         sharedRealm.beginTransaction();
-        Table tbl = sharedRealm.createTable("EmployeeTable");
+        Table tbl = sharedRealm.createTable(Table.getTableNameForClass("EmployeeTable"));
         tbl.addColumn(RealmFieldType.STRING, "name");
         tbl.setPrimaryKey("name");
 
@@ -221,7 +221,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName(
     public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table table = sharedRealm.createTable("TestTable");
+        Table table = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = table.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table.addSearchIndex(column);
         table.setPrimaryKey(column);
@@ -236,7 +236,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         pkTable.removeSearchIndex(classColumn);
 
         // Tries to add a pk for another table.
-        Table table2 = sharedRealm.createTable("TestTable2");
+        Table table2 = sharedRealm.createTable(Table.getTableNameForClass("TestTable2"));
         long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table2.addSearchIndex(column2);
         try {
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/stable_id_migration.realm b/realm/realm-library/src/androidTestObjectServer/assets/stable_id_migration.realm
new file mode 100644
index 0000000000..cda2d88456
Binary files /dev/null and b/realm/realm-library/src/androidTestObjectServer/assets/stable_id_migration.realm differ
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
index bfeea26cfb..b7c6e43b90 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
@@ -25,11 +25,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Set;
+
 import io.realm.entities.StringOnly;
-import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.fail;
@@ -37,14 +40,14 @@
 @RunWith(AndroidJUnit4.class)
 public class SchemaTests {
     @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
     private SyncConfiguration config;
 
     @Before
     public void setUp() {
         SyncUser user = SyncTestUtils.createTestUser();
-        config = new SyncConfiguration.Builder(user, "realm://objectserver.realm.io/~/default").build();
+        config = configFactory.createSyncConfigurationBuilder(user, "realm://objectserver.realm.io/~/default").build();
     }
 
     @After
@@ -128,10 +131,12 @@ public void disallow_removeField() {
         DynamicRealm realm = DynamicRealm.getInstance(config);
         String className = "StringOnly";
         String fieldName = "chars";
+        final RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        assertTrue(objectSchema.hasField(fieldName));
         realm.beginTransaction();
-        assertTrue(realm.getSchema().get(className).hasField(fieldName));
         try {
-            realm.getSchema().get(className).removeField(fieldName);
+            objectSchema.removeField(fieldName);
             fail();
         } catch (IllegalArgumentException ignored) {
         } finally {
@@ -147,12 +152,72 @@ public void allow_addField() {
         String className = "StringOnly";
 
         DynamicRealm realm = DynamicRealm.getInstance(config);
+        final RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
         realm.beginTransaction();
-        realm.getSchema().get(className).addField("foo", String.class);
+        objectSchema.addField("foo", String.class);
         realm.commitTransaction();
 
-        assertTrue(realm.getSchema().get(className).hasField("foo"));
+        assertTrue(objectSchema.hasField("foo"));
+
+        realm.close();
+    }
+
+    @Test
+    public void addPrimaryKey_notAllowed() {
+        // Init schema
+        Realm.getInstance(config).close();
+        String className = "StringOnly";
+        String fieldName = "chars";
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        assertTrue(objectSchema.hasField(fieldName));
+
+        realm.beginTransaction();
+        try {
+            objectSchema.addPrimaryKey(fieldName);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    @Test
+    public void addField_withPrimaryKeyModifier_notAllowed() {
+        // Init schema
+        Realm.getInstance(config).close();
+        String className = "StringOnly";
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+
+        realm.beginTransaction();
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+
+        try {
+            objectSchema.addField("bar", String.class, FieldAttribute.PRIMARY_KEY);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    // Special column "__OID" should be hidden from users.
+    @Test
+    public void getFieldNames_stableIdColumnShouldBeHidden() {
+        String className = "StringOnly";
+        Realm realm = Realm.getInstance(config);
 
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        Set<String> names = objectSchema.getFieldNames();
+        assertEquals(1, names.size());
+        assertEquals(StringOnly.FIELD_CHARS, names.iterator().next());
         realm.close();
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index 78caa6cf8c..a178189e22 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -16,15 +16,19 @@
 
 package io.realm;
 
+import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.io.FileNotFoundException;
+import java.io.IOException;
 
 import io.realm.entities.IndexedFields;
+import io.realm.entities.PrimaryKeyAsInteger;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -33,6 +37,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -100,6 +105,9 @@ public void missingFields_hiddenSilently() {
         schema.create(className)
                 .addField(StringOnly.FIELD_CHARS, String.class)
                 .addField("newField", String.class);
+        // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an
+        // error branch. That is not a real case.
+        dynamicRealm.setVersion(0);
         dynamicRealm.commitTransaction();
         dynamicRealm.close();
 
@@ -117,6 +125,10 @@ public void missingFields_hiddenSilently() {
 
     // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key
     @Test
+    @Ignore("This test will throw earlier when trying to add a PK field. That case is already covered by" +
+            " SchemaTest.addField_withPrimaryKeyModifier_notAllowed(). Although this test will still be valuable for" +
+            "Object Store schema integration.")
+    // FIXME: Enabled this after OS schema integration.
     public void breakingSchemaChange_throws() {
         SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
                 .schema(PrimaryKeyAsString.class)
@@ -193,10 +205,10 @@ public void differentSchemaVersions_rebuildIndexes() {
         dynamicRealm.close();
 
         Realm realm = Realm.getInstance(config); // Opening at different schema version (42) should rebuild indexes
-        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
         try {
-            // FIXME: Object Store doesn't add index to it. Is it expected?
-            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+            RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
+            assertNotNull(indexedFieldsSchema);
+            assertTrue(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
             assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
         } finally {
             realm.close();
@@ -282,4 +294,19 @@ public void moreFieldsThanExpectedIsAllowed() {
         Realm realm = Realm.getInstance(config);
         realm.close();
     }
+
+    // The stable_id_migration.realm is created with sync v1.8.5 with one object created for each object schema.
+    @Test
+    @Ignore("Not supported by sync right now.")
+    public void stableIDMigrationCauseClientReset() throws IOException {
+        SyncConfiguration config = configFactory
+                .createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(StringOnly.class, PrimaryKeyAsString.class, PrimaryKeyAsInteger.class)
+                .name("stable_id_migration.realm")
+                .build();
+        configFactory.copyRealmFromAssets(InstrumentationRegistry.getContext(), "stable_id_migration.realm", config);
+        Realm realm = Realm.getInstance(config);
+        // TODO: Should the local realm be cleaned? It contains one object for each object schema in the realm.
+        realm.close();
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index d7308a6dfd..3cd5a1280d 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -113,6 +113,27 @@ if (build_SYNC)
                                                     IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
 endif()
 
+# Download openssl lib
+#string(TOLOWER "${CMAKE_BUILD_TYPE}" openssl_build_TYPE)
+set(openssl_build_TYPE "release")
+# FIXME Read the openssl version from core when the core/sync release has that information.
+set(openssl_VERSION "1.0.2k")
+set(openssl_FILENAME "openssl-${openssl_build_TYPE}-${openssl_VERSION}-Android-${ANDROID_ABI}")
+set(openssl_URL "http://static.realm.io/downloads/openssl/${openssl_VERSION}/Android/${ANDROID_ABI}/${openssl_FILENAME}.tar.gz")
+
+message(STATUS "Downloading OpenSSL...")
+file(DOWNLOAD "${openssl_URL}" "${PROJECT_BINARY_DIR}/${openssl_FILENAME}.tar.gz")
+
+message(STATUS "Uncompressing OpenSSL...")
+execute_process(COMMAND ${CMAKE_COMMAND} -E tar xfz "${PROJECT_BINARY_DIR}/${openssl_FILENAME}.tar.gz"
+    WORKING_DIRECTORY "${PROJECT_BINARY_DIR}")
+
+message(STATUS "Importing OpenSSL...")
+include(${PROJECT_BINARY_DIR}/${openssl_FILENAME}/openssl.cmake)
+get_target_property(openssl_include_DIR crypto INTERFACE_INCLUDE_DIRECTORIES)
+get_target_property(crypto_LIB crypto IMPORTED_LOCATION)
+get_target_property(ssl_LIB ssl IMPORTED_LOCATION)
+
 # build application's shared lib
 include_directories(${REALM_CORE_DIST_DIR}/include
     ${CMAKE_SOURCE_DIR}
@@ -200,9 +221,9 @@ add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC} ${objectstore_sync_SR
 add_dependencies(realm-jni jni_headers)
 
 if (build_SYNC)
-    target_link_libraries(realm-jni log android lib_realm_sync)
+    target_link_libraries(realm-jni log android lib_realm_sync crypto ssl)
 else()
-    target_link_libraries(realm-jni log android lib_realm_core)
+    target_link_libraries(realm-jni log android lib_realm_core crypto)
 endif()
 
 # Strip the release so files and backup the unstripped versions
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index 00168c501a..3099c70d56 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -17,6 +17,9 @@
 #include "io_realm_internal_OsObject.h"
 
 #include <realm/row.hpp>
+#if REALM_ENABLE_SYNC
+#include <realm/sync/object.hpp>
+#endif
 #include <object_schema.hpp>
 #include <object.hpp>
 #include <shared_realm.hpp>
@@ -165,7 +168,11 @@ static inline size_t do_create_row(jlong shared_realm_ptr, jlong table_ptr)
     auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
     shared_realm->verify_in_write();
+#if REALM_ENABLE_SYNC
+    return sync::create_object(shared_realm->read_group(), table);
+#else
     return table.add_empty_row();
+#endif
 }
 
 static inline size_t do_create_row_with_primary_key(JNIEnv* env, jlong shared_realm_ptr, jlong table_ptr,
@@ -190,7 +197,17 @@ static inline size_t do_create_row_with_primary_key(JNIEnv* env, jlong shared_re
         }
     }
 
-    size_t row_ndx = table.add_empty_row();
+    size_t row_ndx;
+#if REALM_ENABLE_SYNC
+    if (is_pk_null) {
+        row_ndx = sync::create_object_with_primary_key(shared_realm->read_group(), table, util::none);
+    }
+    else {
+        row_ndx = sync::create_object_with_primary_key(shared_realm->read_group(), table,
+                                                       util::Optional<int64_t>(pk_value));
+    }
+#else
+    row_ndx = table.add_empty_row();
 
     if (is_pk_null) {
         table.set_null_unique(pk_column_ndx, row_ndx);
@@ -198,6 +215,7 @@ static inline size_t do_create_row_with_primary_key(JNIEnv* env, jlong shared_re
     else {
         table.set_int_unique(pk_column_ndx, row_ndx, pk_value);
     }
+#endif
     return row_ndx;
 }
 
@@ -224,13 +242,18 @@ static inline size_t do_create_row_with_primary_key(JNIEnv* env, jlong shared_re
         }
     }
 
-    size_t row_ndx = table.add_empty_row();
+    size_t row_ndx;
+#if REALM_ENABLE_SYNC
+    row_ndx = sync::create_object_with_primary_key(shared_realm->read_group(), table, str_accessor);
+#else
+    row_ndx = table.add_empty_row();
     if (pk_value) {
         table.set_string_unique(pk_column_ndx, row_ndx, str_accessor);
     }
     else {
         table.set_string_unique(pk_column_ndx, row_ndx, null{});
     }
+#endif
 
     return row_ndx;
 }
@@ -365,3 +388,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateRowWithStrin
 
     return realm::npos;
 }
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObject_nativeGetObjectIdColumName(JNIEnv* env, jclass)
+{
+// TODO: Remove the macro and get the name from core when core has stable ID support.
+#if REALM_ENABLE_SYNC
+    const char* object_id_column_name = sync::object_id_column_name;
+#else
+    const char* object_id_column_name = "!OID";
+#endif
+    return to_jstring(env, object_id_column_name);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 121419fc35..f5699fa2d5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -38,6 +38,8 @@ using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
+static const char* c_table_name_exists_exception_msg = "Class already exists: '%1'.";
+
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env, jclass,
                                                                      jstring temporary_directory_path)
 {
@@ -288,22 +290,84 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTable(JNIEnv* env, jclass,
                                                                              jlong shared_realm_ptr,
-                                                                             jstring table_name)
+                                                                             jstring j_table_name,
+                                                                             jboolean is_pk_table)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    std::string name_str;
+    std::string table_name;
     try {
-        JStringAccessor name(env, table_name); // throws
-        name_str = name;
+        table_name = JStringAccessor(env, j_table_name); // throws
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->verify_in_write(); // throws
+        Table* table;
+        auto& group = shared_realm->read_group();
+        if (is_pk_table) {
+            // sync::create_table() will add an extra column for stable ID which is not allowed for pk table.
+            table = LangBindHelper::add_table(group, table_name); // throws
+        }
+        else {
+#if REALM_ENABLE_SYNC
+            // Sync doesn't throw when table exists.
+            if (group.has_table(table_name)) {
+                THROW_JAVA_EXCEPTION(
+                    env, JavaExceptionDef::IllegalArgument,
+                    format(c_table_name_exists_exception_msg, table_name.substr(TABLE_PREFIX.length())));
+            }
+            auto table_ref = sync::create_table(group, table_name); // throws
+            table = LangBindHelper::get_table(group, table_ref->get_index_in_group());
+#else
+            table = LangBindHelper::add_table(group, table_name); // throws
+#endif
+        }
+        return reinterpret_cast<jlong>(table);
+    }
+    catch (TableNameInUse& e) {
+        // We need to print the table name, so catch the exception here.
+        std::string class_name_str(table_name.substr(TABLE_PREFIX.length()));
+        ThrowException(env, IllegalArgument, format(c_table_name_exists_exception_msg, class_name_str));
+    }
+    CATCH_STD()
+
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTableWithPrimaryKeyField(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jstring j_table_name, jstring j_field_name, jboolean is_string_type,
+    jboolean is_nullable)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    std::string class_name_str;
+    try {
+        std::string table_name(JStringAccessor(env, j_table_name));
+        class_name_str = std::string(table_name.substr(TABLE_PREFIX.length()));
+        JStringAccessor field_name(env, j_field_name); // throws
         auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         shared_realm->verify_in_write(); // throws
-        Table* table = LangBindHelper::add_table(shared_realm->read_group(), name); // throws
+        DataType pkType = is_string_type ? DataType::type_String : DataType::type_Int;
+        Table* table;
+        auto& group = shared_realm->read_group();
+#if REALM_ENABLE_SYNC
+        // Sync doesn't throw when table exists.
+        if (group.has_table(table_name)) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format(c_table_name_exists_exception_msg, class_name_str));
+        }
+        auto table_ref =
+            sync::create_table_with_primary_key(group, table_name, pkType, field_name, is_nullable);
+        table = LangBindHelper::get_table(group, table_ref->get_index_in_group());
+#else
+        table = LangBindHelper::add_table(group, table_name);
+        size_t column_idx = table->add_column(pkType, field_name, is_nullable);
+        table->add_search_index(column_idx);
+#endif
+        ObjectStore::set_primary_key_for_object(group, class_name_str, field_name);
         return reinterpret_cast<jlong>(table);
     }
     catch (TableNameInUse& e) {
         // We need to print the table name, so catch the exception here.
-        ThrowException(env, IllegalArgument, format("Class already exists: '%1'.", name_str));
+        ThrowException(env, IllegalArgument, format(c_table_name_exists_exception_msg, class_name_str));
     }
     CATCH_STD()
 
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 025c704a26..ad0911e2a4 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -57,9 +57,9 @@
 abstract class BaseRealm implements Closeable {
     private static final String INCORRECT_THREAD_CLOSE_MESSAGE =
             "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
-    private static final String INCORRECT_THREAD_MESSAGE =
+    static final String INCORRECT_THREAD_MESSAGE =
             "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
-    private static final String CLOSED_REALM_MESSAGE =
+    static final String CLOSED_REALM_MESSAGE =
             "This Realm instance has already been closed, making it unusable.";
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 0aa0e5a862..f924430967 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -984,6 +984,23 @@ public String toString() {
         return RealmResults.createDynamicBacklinkResults(realm, (CheckedRow) proxyState.getRow$realm(), realmObjectSchema.getTable(), srcFieldName);
     }
 
+    /**
+     * Returns {@link DynamicRealm} instance where this {@link DynamicRealmObject} belongs.
+     * <p>
+     * You <b>must not</b> call {@link DynamicRealm#close()} against returned instance.
+     *
+     * @return {@link DynamicRealm} instance where this object belongs.
+     * @throws IllegalStateException if this object was deleted or the corresponding {@link DynamicRealm} was already closed.
+     */
+    public DynamicRealm getDynamicRealm() {
+        final BaseRealm realm = realmGet$proxyState().getRealm$realm();
+        realm.checkIfValid();
+        if (!isValid()) {
+            throw new IllegalStateException(MSG_DELETED_OBJECT);
+        }
+        return (DynamicRealm) realm;
+    }
+
     @Override
     public void realm$injectObjectContext() {
         // nothing to do for DynamicRealmObject
diff --git a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
index 5f56104ded..b3d79f7da0 100644
--- a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
@@ -46,6 +46,11 @@ public RealmObjectSchema create(String className) {
         throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
     }
 
+    @Override
+    public RealmObjectSchema createWithPrimaryKeyField(String className, String primaryKeyFieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
     @Override
     public void remove(String className) {
         throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
index e53ec76a07..8514eef8cd 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
@@ -94,6 +94,10 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
             }
         }
 
+        if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+            checkAddPrimaryKeyForSync();
+        }
+
         checkNewFieldName(fieldName);
         boolean nullable = metadata.defaultNullable;
         if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
@@ -184,6 +188,7 @@ public RealmObjectSchema removeIndex(String fieldName) {
 
     @Override
     public RealmObjectSchema addPrimaryKey(String fieldName) {
+        checkAddPrimaryKeyForSync();
         checkLegalName(fieldName);
         checkFieldExists(fieldName);
         if (table.hasPrimaryKey()) {
@@ -287,7 +292,7 @@ private void addModifiers(String fieldName, FieldAttribute[] attributes) {
         }
     }
 
-    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
+    static boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
         //noinspection ConstantConditions
         if (attributeList == null || attributeList.length == 0) {
             return false;
@@ -310,4 +315,10 @@ private void checkFieldNameIsAvailable(String fieldName) {
             throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
         }
     }
+
+    private void checkAddPrimaryKeyForSync() {
+        if (realm.configuration.isSyncConfiguration()) {
+            throw new UnsupportedOperationException("'addPrimaryKey' is not supported by synced Realms.");
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
index e74556b5e5..a661b255bf 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
@@ -55,6 +55,31 @@ public RealmObjectSchema create(String className) {
         return new MutableRealmObjectSchema(realm, this, realm.getSharedRealm().createTable(internalTableName));
     }
 
+    @Override
+    public RealmObjectSchema createWithPrimaryKeyField(String className, String primaryKeyFieldName, Class<?> fieldType,
+                                                       FieldAttribute... attributes) {
+        checkNotEmpty(className, EMPTY_STRING_MSG);
+        RealmObjectSchema.checkLegalName(primaryKeyFieldName);
+        String internalTableName = checkAndGetTableNameFromClassName(className);
+
+        RealmObjectSchema.FieldMetaData metadata = RealmObjectSchema.getSupportedSimpleFields().get(fieldType);
+        if (metadata == null || (metadata.realmType != RealmFieldType.STRING &&
+                metadata.realmType != RealmFieldType.INTEGER)) {
+            throw new IllegalArgumentException(String.format("Realm doesn't support primary key field type '%s'.",
+                    fieldType));
+        }
+        boolean isStringField = (metadata.realmType == RealmFieldType.STRING);
+
+        boolean nullable = metadata.defaultNullable;
+        if (MutableRealmObjectSchema.containsAttribute(attributes, FieldAttribute.REQUIRED)) {
+            nullable = false;
+        }
+
+        return new MutableRealmObjectSchema(realm, this,
+                realm.getSharedRealm().createTableWithPrimaryKey(internalTableName, primaryKeyFieldName,
+                        isStringField, nullable));
+    }
+
     @Override
     public void remove(String className) {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
@@ -105,4 +130,15 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
 
         return objectSchema;
     }
+
+    private String checkAndGetTableNameFromClassName(String className) {
+        if (className.length() > Table.CLASS_NAME_MAX_LENGTH) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US,
+                            "Class name is too long. Limit is %1$d characters: %2$s",
+                            Table.CLASS_NAME_MAX_LENGTH,
+                            className.length()));
+        }
+        return Table.getTableNameForClass(className);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 48f9576d92..020c7f5b07 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -68,6 +68,9 @@
 
 @RealmClass
 public abstract class RealmObject implements RealmModel, ManagableObject {
+    static final String MSG_NULL_OBJECT = "'model' is null.";
+    static final String MSG_DELETED_OBJECT = "the object is already deleted.";
+    static final String MSG_DYNAMIC_OBJECT = "the object is an instance of DynamicRealmObject. Use DynamicRealmObject.getDynamicRealm() instead.";
 
     /**
      * Deletes the object from the Realm it is currently associated to.
@@ -260,7 +263,7 @@ public final boolean isLoaded() {
      */
     @Override
     public boolean isManaged() {
-        return isManaged(this);
+        return RealmObject.isManaged(this);
     }
 
     /**
@@ -286,6 +289,49 @@ public boolean isManaged() {
         return object instanceof RealmObjectProxy;
     }
 
+    /**
+     * Returns {@link Realm} instance where this {@link RealmObject} belongs.
+     * <p>
+     * You <b>must not</b> call {@link Realm#close()} against returned instance.
+     *
+     * @return {@link Realm} instance where this object belongs to or {@code null} if this object is unmanaged.
+     * @throws IllegalStateException if this object is an instance of {@link DynamicRealmObject}
+     * or this object was already deleted or the corresponding {@link Realm} was already closed.
+     */
+    public Realm getRealm() {
+        return getRealm(this);
+    }
+
+    /**
+     * returns {@link Realm} instance where the {@code model} belongs.
+     * <p>
+     * You <b>must not</b> call {@link Realm#close()} against returned instance.
+     *
+     * @param model an {@link RealmModel} instance other than {@link DynamicRealmObject}.
+     * @return {@link Realm} instance where the {@code model} belongs or {@code null} if the {@code model} is unmanaged.
+     * @throws IllegalArgumentException if the {@code model} is {@code null}.
+     * @throws IllegalStateException if the {@code model}  is an instance of {@link DynamicRealmObject}
+     * or this object was already deleted or the corresponding {@link Realm} was already closed.
+     */
+    public static Realm getRealm(RealmModel model) {
+        if (model == null) {
+            throw new IllegalArgumentException(MSG_NULL_OBJECT);
+        }
+        if (model instanceof DynamicRealmObject) {
+            throw new IllegalStateException(MSG_DYNAMIC_OBJECT);
+        }
+        if (!(model instanceof RealmObjectProxy)) {
+            return null;
+        }
+        final BaseRealm realm = ((RealmObjectProxy) model).realmGet$proxyState().getRealm$realm();
+        realm.checkIfValid();
+        if (!RealmObject.isValid(model)) {
+            throw new IllegalStateException(MSG_DELETED_OBJECT);
+        }
+
+        return (Realm) realm;
+    }
+
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index fe4337afed..ab91b6c740 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -26,6 +26,7 @@
 
 import io.realm.annotations.Required;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObject;
 import io.realm.internal.Table;
 import io.realm.internal.fields.FieldDescriptor;
 
@@ -242,7 +243,7 @@ public boolean hasIndex(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
      * has a primary key defined.
-     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable or this method is called on a synced Realm.
      */
     public abstract RealmObjectSchema addPrimaryKey(String fieldName);
 
@@ -354,7 +355,10 @@ public String getPrimaryKey() {
         int columnCount = (int) table.getColumnCount();
         Set<String> columnNames = new LinkedHashSet<>(columnCount);
         for (int i = 0; i < columnCount; i++) {
-            columnNames.add(table.getColumnName(i));
+            String name = table.getColumnName(i);
+            if (!OsObject.isObjectIdColumn(name)) {
+                columnNames.add(name);
+            }
         }
         return columnNames;
     }
@@ -421,6 +425,10 @@ Table getTable() {
         return table;
     }
 
+    static final Map<Class<?>, FieldMetaData> getSupportedSimpleFields() {
+        return SUPPORTED_SIMPLE_FIELDS;
+    }
+
     private SchemaConnector getSchemaConnector() {
         return new SchemaConnector(schema);
     }
@@ -446,7 +454,7 @@ long getFieldIndex(String fieldName) {
         return columnInfo.getColumnIndex(fieldName);
     }
 
-    void checkLegalName(String fieldName) {
+    static void checkLegalName(String fieldName) {
         //noinspection ConstantConditions
         if (fieldName == null || fieldName.isEmpty()) {
             throw new IllegalArgumentException("Field name can not be null or empty");
@@ -454,6 +462,9 @@ void checkLegalName(String fieldName) {
         if (fieldName.contains(".")) {
             throw new IllegalArgumentException("Field name can not contain '.'");
         }
+        if (fieldName.length() > 63) {
+            throw new IllegalArgumentException("Field name is currently limited to max 63 characters.");
+        }
     }
 
     void checkFieldExists(String fieldName) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 2f716193d8..74ca6fafe8 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -29,7 +29,6 @@
 import io.realm.internal.Util;
 import io.realm.internal.util.Pair;
 
-
 /**
  * Class for interacting with the Realm schema. This makes it possible to inspect, add, delete and change the classes in
  * the Realm.
@@ -110,6 +109,22 @@ public void close() {
      */
     public abstract RealmObjectSchema create(String className);
 
+    /**
+     * Adds a new class to the Realm with a primary key field defined.
+     *
+     * @param className           name of the class.
+     * @param primaryKeyFieldName name of the primary key field.
+     * @param fieldType           type of field to add. Only {@code byte}, {@code short}, {@code int}, {@code long}
+     *                            and their boxed types or the {@code String} is supported.
+     * @param attributes          set of attributes for this field. This method implicitly adds
+     *                            {@link FieldAttribute#PRIMARY_KEY} and {@link FieldAttribute#INDEXED} attributes to
+     *                            the field.
+     * @throws UnsupportedOperationException if this {@link RealmSchema} is immutable.
+     * @return a Realm schema object for that class.
+     */
+    public abstract RealmObjectSchema createWithPrimaryKeyField(String className, String primaryKeyFieldName, Class<?> fieldType,
+                                                       FieldAttribute... attributes);
+
     /**
      * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
      * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
index 477982ab3e..651dc416be 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
@@ -31,6 +31,8 @@
 @Keep
 public class OsObject implements NativeObject {
 
+    private static final String OBJECT_ID_COLUMN_NAME = nativeGetObjectIdColumName();
+
     private static class OsObjectChangeSet implements ObjectChangeSet {
         final String[] changedFields;
         final boolean deleted;
@@ -239,6 +241,10 @@ public static long createRowWithPrimaryKey(Table table, Object primaryKeyValue)
         }
     }
 
+    public static boolean isObjectIdColumn(String columnName) {
+        return OBJECT_ID_COLUMN_NAME.equals(columnName);
+    }
+
     // Called by JNI
     @SuppressWarnings("unused")
     private void notifyChangeListeners(String[] changedFields) {
@@ -277,4 +283,7 @@ private static native long nativeCreateNewObjectWithStringPrimaryKey(long shared
     private static native long nativeCreateRowWithStringPrimaryKey(long sharedRealmPtr,
                                                                    long tablePtr, long pk_column_index,
                                                                    String primaryKeyValue);
+
+    // Return sync::object_id_column_name
+    private static native String nativeGetObjectIdColumName();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 400ca571c8..c2a81e4f34 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -26,6 +26,7 @@
 import javax.annotation.Nullable;
 
 import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
@@ -282,7 +283,36 @@ public Table getTable(String name) {
      * @return a created {@link Table} object.
      */
     public Table createTable(String name) {
-        return new Table(this, nativeCreateTable(nativePtr, name));
+        return new Table(this, nativeCreateTable(nativePtr, name, false));
+    }
+
+    /**
+     * Creates a primary key table with then given name. Native assertion will happen if the table with the same name
+     * exists. This function is different from {@link #createTable(String)} which will call {@code create_table()} from
+     * sync to do the creation. This will always call the core's {@code add_table()} to avoid creating the stable id
+     * column for pk table.
+     *
+     * @return a created {@link Table} object.
+     */
+    public Table createPkTable() {
+        return new Table(this, nativeCreateTable(nativePtr, Table.PRIMARY_KEY_TABLE_NAME, true));
+    }
+
+    /**
+     * Creates a {@link Table} and adds a primary key field to it. Native assertion will happen if the table with the
+     * same name exists.
+     *
+     * @param tableName the name of table.
+     * @param primaryKeyFieldName the name of primary key field.
+     * @param isStringType if this is true, the primary key field will be create as a string field. Otherwise it will
+     *                     be created as an integer field.
+     * @param isNullable if the primary key field is nullable or not.
+     * @return a creatd {@link Table} object.
+     */
+    public Table createTableWithPrimaryKey(String tableName, String primaryKeyFieldName, boolean isStringType,
+                                           boolean isNullable) {
+        return new Table(this, nativeCreateTableWithPrimaryKeyField(nativePtr, tableName, primaryKeyFieldName,
+                isStringType, isNullable));
     }
 
     public void renameTable(String oldName, String newName) {
@@ -510,7 +540,15 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
     private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
 
     // Throw IAE if the table exists already.
-    private static native long nativeCreateTable(long nativeSharedRealmPtr, String tableName);
+    // FIXME: isPkTable should be removed after integration with OS schema. All the meta tables should be handled in
+    // the Object Store.
+    private static native long nativeCreateTable(long nativeSharedRealmPtr, String tableName, boolean isPkTable);
+
+    // Throw IAE if the table exists already.
+    // If isStringType is false, the PK field will be created as an integer PK field.
+    private static native long nativeCreateTableWithPrimaryKeyField(long nativeSharedRealmPtr, String tableName,
+                                                                    String primaryKeyFieldName,
+                                                                    boolean isStringType, boolean isNullable);
 
     private static native String nativeGetTableName(long nativeSharedRealmPtr, int index);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 1ef0740dc6..704023bbfe 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -40,7 +40,7 @@
     public static final boolean NOT_NULLABLE = false;
     public static final int NO_MATCH = -1;
 
-    private static final String PRIMARY_KEY_TABLE_NAME = "pk";
+    static final String PRIMARY_KEY_TABLE_NAME = "pk";
     private static final String PRIMARY_KEY_CLASS_COLUMN_NAME = "pk_table";
     private static final long PRIMARY_KEY_CLASS_COLUMN_INDEX = 0;
     private static final String PRIMARY_KEY_FIELD_COLUMN_NAME = "pk_property";
@@ -628,7 +628,7 @@ private Table getPrimaryKeyTable() {
 
         // FIXME: The PK table creation should be handle by Object Store after integration of OS Schema.
         if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
-            sharedRealm.createTable(PRIMARY_KEY_TABLE_NAME);
+            sharedRealm.createPkTable();
         }
 
         Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index 23ab53ade8..3228ee8622 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -5,7 +5,8 @@ ARG ROS_DE_VERSION
 # Add realm repo
 RUN apt-get update -qq \
     && apt-get install -y curl npm \
-    && curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh | bash
+    && curl -s https://packagecloud.io/install/repositories/realm/realm-beta/script.deb.sh | bash
+    #&& curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh | bash
     #&& curl -s https://packagecloud.io/install/repositories/realm/realm-testing/script.deb.sh | bash
 
 # ROS npm dependencies
diff --git a/version.txt b/version.txt
index ca12ba1b1d..1834483b00 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.8.0-SNAPSHOT
\ No newline at end of file
+4.0.0-BETA2-SNAPSHOT
