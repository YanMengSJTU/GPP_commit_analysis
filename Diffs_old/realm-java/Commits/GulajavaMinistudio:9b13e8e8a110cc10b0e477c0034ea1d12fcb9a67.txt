diff --git a/CHANGELOG.md b/CHANGELOG.md
index f4aa85b6ef..ade6fbc4ff 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,18 +1,66 @@
-## 5.5.0 (YYYY-MM-DD)
+## 5.6.0 (YYYY-MM-DD)
+
+### Enhancements
+
+* `@RealmClass("name")` and `@RealmField("name")` can now be used as a shorthand for defining custom name mappings (#6145).
+
+
+## 5.5.1 (YYYY-MM-DD)
+
+### Enhancements
+* Building with Android App Bundle is now supported ([#5977](https://github.com/realm/realm-java/issues/5977)).
+
+### Fixes
+* None
+
+### Compatibility
+* File format: ver. 7 (upgrades automatically from previous formats)
+* Realm Object Server: 3.0.0 or later.
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* Updated ReLinker to 1.3.0.
+
+
+## 5.5.0 (2018-08-31)
 
 ### Enhancements
 
 * [ObjectServer] Added `ConnectionState` enum describing the states a connection can be in.
-* [ObjectServer] Added `SyncSession.isConnected()`.
+* [ObjectServer] Added `SyncSession.isConnected()` and `SyncSession.getConnectionState()`.
 * [ObjectServer] Added support for observing connection changes for a session using `SyncSession.addConnectionChangeListener()` and `SyncSession.removeConnectionChangeListener()`.
-
+* [ObjectServer] Added Kotlin extension property `Realm.syncSession` for synchronized Realms.
+* [ObjectServer] Added Kotlin extension method `Realm.classPermissions<RealmModel>()`.
+* [ObjectServer] Added support for starting and stopping synchronization using `SyncSession.start()` and `SyncSession.stop()` (#6135).
+* [ObjectServer] Added API's for making it easier to work with network proxies (#6163): 
+  * `SyncManager.setAuthorizationHeaderName(String headerName)`
+  * `SyncManager.setAuthorizationHeaderName(String headerName, String host)`
+  * `SyncManager.addCustomRequestHeader(String headerName, String headerValue)`
+  * `SyncManager.addCustomRequestHeader(String headerName, String headerValue, String host)`
+  * `SyncManager.addCustomRequestHeaders(Map<String, String> headers)`
+  * `SyncManager.addCustomRequestHeaders(Map<String, String> headers, String host)`
+  * `SyncConfiguration.Builder.urlPrefix(String prefix)`
+ 
 ### Bug Fixes
 
 * Methods and classes requiring synchronized Realms have been removed from the standard AAR package. They are now only visible when enabling synchronized Realms in Gradle. The methods and classes will still be visible in the source files and docs, but annotated with `@ObjectServer` (#5799).
 
 ### Internal
 
-* Updated to Object Store commit: 97fd03819f398b3c81c8b007feaca8636629050b
+* Updated to Realm Sync 3.9.4
+* Updated to Realm Core 5.8.0
+* Updated to Object Store commit: b0fc2814d9e6061ce5ba1da887aab6cfba4755ca
+
+### Credits
+
+* Thanks to @lucasdornelasv for improving the performance of `Realm.copyToRealm()`, `Realm.copyToRealmOrUpdate()` and `Realm.copyFromRealm()` #(6124). 
+
+
+## 5.4.3 (YYYY-MM-DD)
+
+### Bug Fixes
+
+* [ObjectServer] ProGuard was not configured correctly when working with Subscriptions for Query-based Realms.
 
 
 ## 5.4.2 (2018-08-09)
diff --git a/README.md b/README.md
index 7fb11c6441..231131ca89 100644
--- a/README.md
+++ b/README.md
@@ -67,9 +67,9 @@ In case you don't want to use the precompiled version, you can build Realm yours
 ### Prerequisites
 
  * Download the [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
+ * The latest stable version of Android Studio. Currently [3.1.4](https://developer.android.com/studio/).
  * Download & install the Android SDK **Build-Tools 27.0.2**, **Android Oreo (API 27)** (for example through Android Studio’s **Android SDK Manager**).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
- * If you use Android Studio, Android Studio 3.0 or higher is required.
 
  * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
 You may unzip the file wherever you choose.  For macOS, a suggested location is `~/Library/Android`.  The download will unzip as the directory `android-ndk-r10e`.
diff --git a/dependencies.list b/dependencies.list
index 9becc34d10..9a517e46ef 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,8 +1,16 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=3.8.8
-REALM_SYNC_SHA256=a0cbc5b46dbc3a9351bd002ccbcb07bf2a5fd13f9f1b7ef6ed51df931b46587b
+REALM_SYNC_VERSION=3.9.4
+REALM_SYNC_SHA256=f5f52093270c8d26a4b6ba3790c05425d89786033aa6d061fd74e9a24ecb22d7
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
 REALM_OBJECT_SERVER_VERSION=3.9.9
+
+# Common Android settings across projects
+GRADLE_BUILD_TOOLS=3.1.4
+ANDROID_BUILD_TOOLS=27.0.3
+
+# Common classpath dependencies
+BUILD_INFO_EXTRACTOR_GRADLE=4.7.5
+GRADLE_BINTRAY_PLUGIN=1.8.4
diff --git a/examples/architectureComponentsExample/build.gradle b/examples/architectureComponentsExample/build.gradle
index d44c3d0292..9af0f5f9a3 100644
--- a/examples/architectureComponentsExample/build.gradle
+++ b/examples/architectureComponentsExample/build.gradle
@@ -38,10 +38,10 @@ android {
 }
 
 dependencies {
-    implementation "android.arch.lifecycle:runtime:1.1.0"
-    implementation "android.arch.lifecycle:extensions:1.1.0"
-    annotationProcessor "android.arch.lifecycle:compiler:1.1.0"
-    implementation 'com.android.support:appcompat-v7:27.0.2'
-    implementation 'com.android.support:recyclerview-v7:27.0.2'
-    implementation 'com.android.support:design:27.0.2'
+    implementation "android.arch.lifecycle:runtime:1.1.1"
+    implementation "android.arch.lifecycle:extensions:1.1.1"
+    annotationProcessor "android.arch.lifecycle:compiler:1.1.1"
+    implementation 'com.android.support:appcompat-v7:27.1.1'
+    implementation 'com.android.support:recyclerview-v7:27.1.1'
+    implementation 'com.android.support:design:27.1.1'
 }
diff --git a/examples/build.gradle b/examples/build.gradle
index 85a4b448a7..79fefbdc2d 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,6 +1,8 @@
+def projectDependencies = new Properties()
+projectDependencies.load(new FileInputStream("${rootDir}/../dependencies.list"))
 project.ext.sdkVersion = 27
 project.ext.minSdkVersion = 15
-project.ext.buildTools = '27.0.2'
+project.ext.buildTools = projectDependencies.get("ANDROID_BUILD_TOOLS")
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
@@ -21,6 +23,7 @@ allprojects {
 
     def props = new Properties()
     props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.load(new FileInputStream("${rootDir}/../dependencies.list"))
     props.each { key, val ->
         project.ext.set(key, val)
     }
@@ -33,8 +36,8 @@ allprojects {
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:3.1.0-alpha06'
-            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+            classpath "com.android.tools.build:gradle:${props.get("GRADLE_BUILD_TOOLS")}"
+            classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${props.get('GRADLE_BINTRAY_PLUGIN')}"
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
         }
     }
diff --git a/examples/gradle.properties b/examples/gradle.properties
index 9c2c6c4094..94789e069a 100644
--- a/examples/gradle.properties
+++ b/examples/gradle.properties
@@ -2,13 +2,13 @@ org.gradle.jvmargs=-Xmx2048M
 org.gradle.caching=true
 android.enableD8=true
 
-# disable AAPT2 to work around an issue of Robolectric in unitTestExample https://github.com/robolectric/robolectric/issues/3169
-android.enableAapt2=false
-
 # Gradle sync failed: Due to a limitation of Gradle’s new variant-aware dependency management, loading the Android Gradle plugin in different class loaders leads to a build error.
 # This can occur when the buildscript classpaths that contain the Android Gradle plugin in sub-projects, or included projects in the case of composite builds, are set differently.
 # To resolve this issue, add the Android Gradle plugin to only the buildscript classpath of the top-level build.gradle file.
 # In the case of composite builds, also make sure the build script classpaths that contain the Android Gradle plugin are identical across the main and included projects.
 # If you are using a version of Gradle that has fixed the issue, you can disable this check by setting android.enableBuildScriptClasspathCheck=false in the gradle.properties file.
 # To learn more about this issue, go to https://d.android.com/r/tools/buildscript-classpath-check.html.
-android.enableBuildScriptClasspathCheck=false
\ No newline at end of file
+android.enableBuildScriptClasspathCheck=false
+
+# See https://developer.android.com/studio/build/optimize-your-build#configuration_on_demand
+org.gradle.configureondemand=false
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..0d4a951687 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..7dc503f149 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
diff --git a/examples/multiprocessExample/build.gradle b/examples/multiprocessExample/build.gradle
index 8950b28f94..1a5d7ebf33 100644
--- a/examples/multiprocessExample/build.gradle
+++ b/examples/multiprocessExample/build.gradle
@@ -25,6 +25,6 @@ android {
 }
 
 dependencies {
-    implementation 'com.android.support:appcompat-v7:27.0.2'
+    implementation 'com.android.support:appcompat-v7:27.1.1'
 }
 
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index 6bfde58102..58eca8669f 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -47,8 +47,8 @@ dependencies {
     implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
     implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
     implementation 'com.squareup.retrofit2:retrofit:2.3.0'
-    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
-    implementation 'io.reactivex.rxjava2:rxjava:2.1.5'
+    implementation 'io.reactivex.rxjava2:rxandroid:2.0.2'
+    implementation 'io.reactivex.rxjava2:rxjava:2.1.13'
     implementation 'me.zhanghai.android.materialprogressbar:library:1.1.4'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' //TODO:Can be refactored with Native Android Data Binding
 }
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index f7520d4618..ff0d0d5ccd 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -1,26 +1,6 @@
 apply plugin: 'com.android.application'
 apply plugin: 'realm-android'
 
-// Credit: http://jeremie-martinez.com/2015/05/05/inject-host-gradle/
-def getIP() {
-    InetAddress result = null
-    Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces()
-    while (interfaces.hasMoreElements()) {
-        Enumeration<InetAddress> addresses = interfaces.nextElement().getInetAddresses()
-        while (addresses.hasMoreElements()) {
-            InetAddress address = addresses.nextElement()
-            if (!address.isLoopbackAddress()) {
-                if (address.isSiteLocalAddress()) {
-                    return address.getHostAddress()
-                } else if (result == null) {
-                    result = address
-                }
-            }
-        }
-    }
-    return (result != null ? result : InetAddress.getLocalHost()).getHostAddress()
-}
-
 android {
     compileSdkVersion rootProject.sdkVersion
     buildToolsVersion rootProject.buildTools
@@ -34,18 +14,23 @@ android {
     }
 
     buildTypes {
-        // This will automatically try to detect the IP address of the machine
-        // building the example. It is assumed that this machine is also running
-        // the Object Server. If not, replace 'host' with the IP of the machine
-        // hosting the server. In some cases the wrong IP address will also
-        // be detected. In that case also insert the IP address manually.
-        def host = getIP()
+        // Go to https://cloud.realm.io and copy the URL to your instance. Insert it below.
+        // It will look something like "https://test.us1.cloud.realm.io"
+        //
+        // If you're running a self-hosted version, use the hostname/IP address of the Realm Object
+        // Server, e.g "http://127.0.0.1:9080".
+        def rosUrl = "<INSERT_REALM_OBJECT_SERVER_URL>"
+        def realmAuthUrl = "\"${rosUrl}/auth\""
+        def realmUrl = "\"${rosUrl.replace("http", "realm")}/default\""
+
         debug {
-            buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+            buildConfigField "String", "REALM_AUTH_URL", "${realmAuthUrl}"
+            buildConfigField "String", "REALM_URL", "${realmUrl}"
             minifyEnabled true
         }
         release {
-            buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+            buildConfigField "String", "REALM_AUTH_URL", "${realmAuthUrl}"
+            buildConfigField "String", "REALM_URL", "${realmUrl}"
             minifyEnabled true
             signingConfig signingConfigs.debug
         }
@@ -57,8 +42,8 @@ realm {
 }
 
 dependencies {
-    implementation 'com.android.support:appcompat-v7:27.0.2'
-    implementation 'com.android.support:design:27.0.2'
+    implementation 'com.android.support:appcompat-v7:27.1.1'
+    implementation 'com.android.support:design:27.1.1'
     implementation 'me.zhanghai.android.materialprogressbar:library:1.3.0'
     implementation 'com.jakewharton:butterknife:8.8.1'//TODO:Can be refactored with Native Android Data Binding
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'//TODO:Can be refactored with Native Android Data Binding
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index ce6b051beb..26d129cd2d 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -34,11 +34,13 @@
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import butterknife.OnClick;
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.Progress;
 import io.realm.ProgressListener;
 import io.realm.ProgressMode;
 import io.realm.Realm;
-import io.realm.RealmChangeListener;
+import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
@@ -47,7 +49,6 @@
 import me.zhanghai.android.materialprogressbar.MaterialProgressBar;
 
 public class CounterActivity extends AppCompatActivity {
-    private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
 
     private final ProgressListener downloadListener = new ProgressListener() {
         @Override
@@ -79,7 +80,7 @@ public void run() {
 
     @BindView(R.id.text_counter) TextView counterView;
     @BindView(R.id.progressbar) MaterialProgressBar progressBar;
-    private CRDTCounter counter; // Keep strong reference to counter to keep change listeners alive.
+    private RealmResults<CRDTCounter> counters; // Keep strong reference to counter to keep change listeners alive.
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -95,7 +96,7 @@ protected void onStart() {
         if (user == null) { return; }
 
         // Create a RealmConfiguration for our user
-        SyncConfiguration config = user.createConfiguration(REALM_URL)
+        SyncConfiguration config = user.createConfiguration(BuildConfig.REALM_URL)
                 .initialData(new Realm.Transaction() {
                     @Override
                     public void execute(@Nonnull Realm realm) {
@@ -108,11 +109,16 @@ public void execute(@Nonnull Realm realm) {
         realm = Realm.getInstance(config);
 
         counterView.setText("-");
-        counter = realm.where(CRDTCounter.class).equalTo("name", user.getIdentity()).findFirstAsync();
-        counter.addChangeListener(new RealmChangeListener<CRDTCounter>() {
+        counters = realm.where(CRDTCounter.class).equalTo("name", user.getIdentity()).findAllAsync();
+        counters.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<CRDTCounter>>() {
             @Override
-            public void onChange(@Nonnull CRDTCounter counter) {
-                counterView.setText((!counter.isValid()) ? "-" : String.format(Locale.US, "%d", counter.getCount()));
+            public void onChange(RealmResults<CRDTCounter> counters, OrderedCollectionChangeSet changeSet) {
+                if (counters.isValid() && !counters.isEmpty()) {
+                    CRDTCounter counter = counters.first();
+                    counterView.setText(String.format(Locale.US, "%d", counter.getCount()));
+                } else {
+                    counterView.setText("-");
+                }
             }
         });
 
@@ -132,7 +138,7 @@ protected void onStop() {
         }
         closeRealm();
         user = null;
-        counter = null;
+        counters = null;
     }
 
     @Override
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
index 2f87b3a0bd..d16b593802 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
@@ -34,8 +34,6 @@
 
 
 public class LoginActivity extends AppCompatActivity {
-    private static final String REALM_AUTH_URL = "http://" + BuildConfig.OBJECT_SERVER_IP + ":9080/auth";
-
     @BindView(R.id.input_username) EditText username;
     @BindView(R.id.input_password) EditText password;
     @BindView(R.id.button_login) Button loginButton;
@@ -103,7 +101,7 @@ public void onError(@Nonnull ObjectServerError error) {
             }
         };
 
-        SyncUser.logInAsync(creds, REALM_AUTH_URL, callback);
+        SyncUser.logInAsync(creds, BuildConfig.REALM_AUTH_URL, callback);
     }
 
     @Override
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index 36ccf169ca..63fddcb435 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -35,9 +35,9 @@ android {
 }
 
 dependencies {
-    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
-    implementation 'io.reactivex.rxjava2:rxjava:2.1.0'
-    implementation 'com.android.support:appcompat-v7:27.0.2'
+    implementation 'io.reactivex.rxjava2:rxandroid:2.0.2'
+    implementation 'io.reactivex.rxjava2:rxjava:2.1.13'
+    implementation 'com.android.support:appcompat-v7:27.1.1'
     implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0'
     implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
     implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
index fc69210908..fd08fb3f9a 100644
--- a/examples/secureTokenAndroidKeyStore/build.gradle
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -33,7 +33,7 @@ dependencies {
     androidTestImplementation('com.android.support.test.espresso:espresso-core:3.0.1', {
         exclude group: 'com.android.support', module: 'support-annotations'
     })
-    implementation 'com.android.support:appcompat-v7:27.0.2'
+    implementation 'com.android.support:appcompat-v7:27.1.1'
     testImplementation 'junit:junit:4.12'
     implementation 'io.realm:secure-userstore:1.0.1'
 }
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index c0188a8bb5..967b71f998 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -24,6 +24,5 @@ android {
 }
 
 dependencies {
-    //noinspection GradleDependency
-    implementation 'com.android.support:appcompat-v7:24.0.0'
+    implementation 'com.android.support:appcompat-v7:27.1.1'
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java
index 5e2c6fa749..28afaa64c1 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java
@@ -17,13 +17,13 @@
 package io.realm.examples.threads;
 
 import android.os.Bundle;
-import android.support.v7.app.ActionBarActivity;
+import android.support.v7.app.AppCompatActivity;
 import android.widget.TextView;
 
 import io.realm.Realm;
 import io.realm.examples.threads.model.Person;
 
-public class ReceivingActivity extends ActionBarActivity {
+public class ReceivingActivity extends AppCompatActivity {
 
     private Realm realm;
 
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
index c3774acca1..ce9ce4e35b 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
@@ -23,12 +23,12 @@
 import android.support.v4.app.FragmentTransaction;
 import android.support.v4.view.ViewPager;
 import android.support.v7.app.ActionBar;
-import android.support.v7.app.ActionBarActivity;
+import android.support.v7.app.AppCompatActivity;
 
 import java.util.Locale;
 
 
-public class ThreadExampleActivity extends ActionBarActivity implements android.support.v7.app.ActionBar.TabListener {
+public class ThreadExampleActivity extends AppCompatActivity implements android.support.v7.app.ActionBar.TabListener {
 
     private ViewPager viewPager;
 
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index ddab123c16..ad9010c919 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -22,7 +22,7 @@ android {
             signingConfig signingConfigs.debug
         }
         debug {
-            minifyEnabled true
+            minifyEnabled false
         }
     }
 
@@ -30,13 +30,19 @@ android {
         sourceCompatibility JavaVersion.VERSION_1_8
         targetCompatibility JavaVersion.VERSION_1_8
     }
+
+    testOptions {
+        unitTests {
+            includeAndroidResources = true
+        }
+    }
 }
 
 
 dependencies {
-    implementation 'com.android.support:appcompat-v7:27.0.2'
+    implementation 'com.android.support:appcompat-v7:27.1.1'
 
-    testImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'
+    testImplementation 'io.reactivex.rxjava2:rxjava:2.1.13'
 
     // Testing
     testImplementation 'junit:junit:4.12'
@@ -50,9 +56,9 @@ dependencies {
     testImplementation "org.powermock:powermock-classloading-xstream:1.6.5"
 
 
-    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:runner:1.0.2'
     // Set this dependency to use JUnit 4 rules
-    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.2'
     // Set this dependency to build and run Espresso tests
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
 }
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index f4eb2c691c..bd154d1785 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -1,10 +1,13 @@
 buildscript {
+    def properties = new Properties()
+    properties.load(new FileInputStream("${rootDir}/../dependencies.list"))
+
     repositories {
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:${properties.get('BUILD_INFO_EXTRACTOR_GRADLE')}"
+        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${properties.get('GRADLE_BINTRAY_PLUGIN')}"
     }
 }
 
@@ -16,6 +19,7 @@ apply plugin: 'com.jfrog.bintray'
 
 def props = new Properties()
 props.load(new FileInputStream("${rootDir}/../realm.properties"))
+props.load(new FileInputStream("${rootDir}/../dependencies.list"))
 props.each { key, val ->
     project.ext.set(key, val)
 }
@@ -52,11 +56,11 @@ dependencies {
      and this https://www.littlerobots.nl/blog/Whats-next-for-android-apt/ for more info.
    */
     compile 'com.neenbedankt.gradle.plugins:android-apt:1.8' //TODO: https://www.littlerobots.nl/blog/Whats-next-for-android-apt/
-    compileOnly 'com.android.tools.build:gradle:3.1.0-alpha06'
+    compileOnly "com.android.tools.build:gradle:${props.get("GRADLE_BUILD_TOOLS")}"
 
     testCompile gradleTestKit()
     testCompile 'junit:junit:4.12'
-    testCompile 'com.android.tools.build:gradle:3.1.0-alpha06'
+    testCompile "com.android.tools.build:gradle:${props.get("GRADLE_BUILD_TOOLS")}"
 }
 
 //for Ant filter
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index 1c203b3f04..374d1e4f35 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -39,11 +39,14 @@ class PluginTest {
 
     private Project project
     private String currentVersion
+    private Properties projectDependencies
 
     @Before
     void setUp() {
         project = ProjectBuilder.builder().build()
         currentVersion = new File("../version.txt").text.trim()
+        projectDependencies = new Properties()
+        projectDependencies.load(new FileInputStream("../dependencies.list"))
     }
 
     @Test
@@ -55,7 +58,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:3.1.0-alpha03'
+                classpath "com.android.tools.build:gradle:${projectDependencies.get("GRADLE_BUILD_TOOLS")}"
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
             }
         }
@@ -91,7 +94,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:3.1.0-alpha03'
+                classpath "com.android.tools.build:gradle:${projectDependencies.get("GRADLE_BUILD_TOOLS")}"
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
             }
         }
diff --git a/gradle.properties b/gradle.properties
index 09e1425217..9306f6c0a1 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,3 +1,7 @@
 org.gradle.jvmargs=-XX:MaxPermSize=512m
 org.gradle.caching=true
-android.enableD8=true
\ No newline at end of file
+android.enableD8=true
+
+# See https://issuetracker.google.com/issues/80464216
+# Can be removed when we upgrade to Android Build Tools 3.3.0
+org.gradle.workers.max=1
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
index 0382c346d3..243bdbfef7 100644
--- a/library-benchmarks/build.gradle
+++ b/library-benchmarks/build.gradle
@@ -1,3 +1,6 @@
+def projectDependencies = new Properties()
+projectDependencies.load(new FileInputStream("${rootDir}/../dependencies.list"))
+
 buildscript {
     repositories {
         mavenLocal()
@@ -5,7 +8,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.1.0-alpha06'
+        classpath "com.android.tools.build:gradle:${projectDependencies.get("GRADLE_BUILD_TOOLS")}"
         classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
     }
 }
@@ -28,7 +31,7 @@ apply plugin: 'realm-android'
 
 android {
     compileSdkVersion 27
-    buildToolsVersion "27.0.2"
+    buildToolsVersion ${projectDependencies.get("ANDROID_BUILD_TOOLS")}
 
     defaultConfig {
         minSdkVersion 15
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar and b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
+++ b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/library-build-transformer/README.md b/library-build-transformer/README.md
index 9a9c5ed32d..557bb81777 100644
--- a/library-build-transformer/README.md
+++ b/library-build-transformer/README.md
@@ -38,4 +38,21 @@ Any errors will only be caught at runtime when the actual code is accessed.
 
 * Annotations on super classes will also remove subclasses, but only the first level of inheritance.
 
-* Single enum values cannot be stripped, only the entire enum class.
\ No newline at end of file
+* Single enum values cannot be stripped, only the entire enum class.
+
+## Running unit tests
+
+Running unit tests can be done from the command line by using:
+
+    >./gradlew test
+
+It should also be possible to run tests from IntelliJ CE, however in some cases it will report
+
+    "Cannot find io.realm.buildtransformer.VistitorTests"
+
+This is a bug in IntelliJ and can be fixed by:
+
+1) Close the project in IntelliJ
+2) Delete the folder `.idea`
+3) Re-import the project into IntelliJ
+
diff --git a/library-build-transformer/build.gradle b/library-build-transformer/build.gradle
index a08d4481c9..c744d5219c 100644
--- a/library-build-transformer/build.gradle
+++ b/library-build-transformer/build.gradle
@@ -2,15 +2,17 @@ group 'io.realm'
 version '1.0.0'
 
 buildscript {
-    ext.kotlin_version = '1.2.51'
+    def properties = new Properties()
+    properties.load(new FileInputStream("${projectDir}/../dependencies.list"))
+    ext.kotlin_version = '1.2.61'
 
     repositories {
         mavenCentral()
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:${properties.get('BUILD_INFO_EXTRACTOR_GRADLE')}"
+        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${properties.get('GRADLE_BINTRAY_PLUGIN')}"
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
@@ -45,10 +47,8 @@ dependencies {
     compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${kotlin_version}"
 
     testCompile group:'junit', name:'junit', version:'4.12'
-    testCompile "org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version"
-    testCompile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${kotlin_version}"
-
 }
+
 compileKotlin {
     kotlinOptions.jvmTarget = "1.8"
 }
diff --git a/library-build-transformer/gradle/wrapper/gradle-wrapper.jar b/library-build-transformer/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/library-build-transformer/gradle/wrapper/gradle-wrapper.jar and b/library-build-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-build-transformer/gradle/wrapper/gradle-wrapper.properties b/library-build-transformer/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/library-build-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/library-build-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/RealmBuildTransformer.kt b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/RealmBuildTransformer.kt
index 38511246c4..c213b96fed 100644
--- a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/RealmBuildTransformer.kt
+++ b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/RealmBuildTransformer.kt
@@ -29,6 +29,7 @@ import java.io.File
 typealias ByteCodeTypeDescriptor = String
 typealias QualifiedName = String
 typealias ByteCodeMethodName = String
+typealias FieldName = String
 
 // Package level logger
 val logger: Logger = LoggerFactory.getLogger("realm-build-logger")
diff --git a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/ClassPoolTransformer.kt b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/ClassPoolTransformer.kt
index 49ba7b17c6..bb61436cae 100644
--- a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/ClassPoolTransformer.kt
+++ b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/ClassPoolTransformer.kt
@@ -17,6 +17,7 @@ package io.realm.buildtransformer.asm
 
 import io.realm.buildtransformer.ByteCodeMethodName
 import io.realm.buildtransformer.ByteCodeTypeDescriptor
+import io.realm.buildtransformer.FieldName
 import io.realm.buildtransformer.QualifiedName
 import io.realm.buildtransformer.asm.visitors.AnnotatedCodeStripVisitor
 import io.realm.buildtransformer.asm.visitors.AnnotationVisitor
@@ -44,15 +45,15 @@ class ClassPoolTransformer(annotationQualifiedName: QualifiedName, private val i
      * @return All input files, both those that have been modified and those that have not.
      */
     fun transform(): Set<File> {
-        val (markedClasses, markedMethods) = pass1()
-        return pass2(markedClasses, markedMethods)
+        val (markedClasses, markedMethods, markedFields) = pass1()
+        return pass2(markedClasses, markedMethods, markedFields)
     }
 
     /**
      * Pass 1: Collect all classes, interfaces and enums that contain the given annotation. This include both top-level
      * and inner types.
      */
-    private fun pass1(): Pair<Set<String>, Map<ByteCodeTypeDescriptor, Set<ByteCodeMethodName>>> {
+    private fun pass1(): Triple<Set<String>, Map<ByteCodeTypeDescriptor, Set<ByteCodeMethodName>>, Map<ByteCodeTypeDescriptor, Set<FieldName>>> {
         val metadataCollector = AnnotationVisitor(annotationDescriptor)
         inputClasses.forEach {
             it.inputStream().use {
@@ -60,7 +61,7 @@ class ClassPoolTransformer(annotationQualifiedName: QualifiedName, private val i
                 classReader.accept(metadataCollector, 0)
             }
         }
-        return Pair(metadataCollector.annotatedClasses, metadataCollector.annotatedMethods)
+        return Triple(metadataCollector.annotatedClasses, metadataCollector.annotatedMethods, metadataCollector.annotatedFields)
     }
 
     /**
@@ -68,13 +69,13 @@ class ClassPoolTransformer(annotationQualifiedName: QualifiedName, private val i
      * are instead marked for deletion as deleting the File is the responsibility of the
      * transform API.
      */
-    private fun pass2(markedClasses: Set<String>, markedMethods: Map<ByteCodeTypeDescriptor, Set<ByteCodeMethodName>>): Set<File> {
+    private fun pass2(markedClasses: Set<String>, markedMethods: Map<ByteCodeTypeDescriptor, Set<ByteCodeMethodName>>, markedFields: Map<ByteCodeTypeDescriptor, Set<FieldName>>): Set<File> {
         inputClasses.forEach { classFile ->
             var result = ByteArray(0)
             if (!classFile.shouldBeDeleted) { // Respect previously set delete flag, so avoid doing any work
                 classFile.inputStream().use { inputStream ->
                     val writer = ClassWriter(0) // We don't modify methods so no reason to re-calculate method frames
-                    val classRemover = AnnotatedCodeStripVisitor(annotationDescriptor, markedClasses, markedMethods, writer)
+                    val classRemover = AnnotatedCodeStripVisitor(annotationDescriptor, markedClasses, markedMethods, markedFields, writer)
                     val reader = ClassReader(inputStream)
                     reader.accept(classRemover, 0)
                     result = if (classRemover.deleteClass) ByteArray(0) else writer.toByteArray()
diff --git a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt
index c8ac8c359b..a33f38acb2 100644
--- a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt
+++ b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt
@@ -17,6 +17,7 @@ package io.realm.buildtransformer.asm.visitors
 
 import io.realm.buildtransformer.ByteCodeMethodName
 import io.realm.buildtransformer.ByteCodeTypeDescriptor
+import io.realm.buildtransformer.FieldName
 import io.realm.buildtransformer.logger
 import org.objectweb.asm.*
 import org.objectweb.asm.AnnotationVisitor
@@ -28,14 +29,17 @@ import org.objectweb.asm.AnnotationVisitor
 class AnnotatedCodeStripVisitor(private val annotationDescriptor: String,
                                 private val markedClasses: Set<String>,
                                 private val markedMethods: Map<ByteCodeTypeDescriptor, Set<ByteCodeMethodName>>,
+                                private val markedFields: Map<ByteCodeTypeDescriptor, Set<FieldName>>,
                                 classWriter: ClassVisitor) : ClassVisitor(Opcodes.ASM6, classWriter) {
 
     var deleteClass: Boolean = false
     private lateinit var markedMethodsInClass: Set<ByteCodeMethodName>
+    private lateinit var markedFieldsInClass: Set<FieldName>
 
     override fun visit(version: Int, access: Int, name: String?, signature: String?, superName: String?, interfaces: Array<out String>?) {
         // Only process this class if it or its super class doesn't have the given annotation
         markedMethodsInClass = markedMethods[name!!]!!
+        markedFieldsInClass = markedFields[name]!!
         deleteClass = (markedClasses.contains(name) || markedClasses.contains(superName))
         if (!deleteClass) {
             super.visit(version, access, name, signature, superName, interfaces)
@@ -54,21 +58,12 @@ class AnnotatedCodeStripVisitor(private val annotationDescriptor: String,
         }
     }
 
-    override fun visitField(access: Int, name: String?, descriptor: String?, signature: String?, value: Any?): FieldVisitor {
-        return object: FieldVisitor(api) {
-            var ignoreField = false
-            override fun visitAnnotation(descriptor: String?, visible: Boolean): AnnotationVisitor? {
-                ignoreField = (annotationDescriptor == descriptor)
-                return null
-            }
-            override fun visitEnd() {
-                if (!ignoreField) {
-                    // Call super ClassVisitor directly
-                    this@AnnotatedCodeStripVisitor.cv.visitField(access, name, descriptor, signature, value)
-                } else {
-                    logger.debug("Removing field: $name")
-                }
-            }
+    override fun visitField(access: Int, name: String?, descriptor: String?, signature: String?, value: Any?): FieldVisitor? {
+        return if (!markedFieldsInClass.contains(name)) {
+            super.visitField(access, name, descriptor, signature, value)
+        } else {
+            logger.debug("Removing field: $name")
+            null
         }
     }
 
diff --git a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt
index 75a761c976..b572090148 100644
--- a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt
+++ b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt
@@ -17,11 +17,10 @@ package io.realm.buildtransformer.asm.visitors;
 
 import io.realm.buildtransformer.ByteCodeMethodName
 import io.realm.buildtransformer.ByteCodeTypeDescriptor
+import io.realm.buildtransformer.FieldName
 import io.realm.buildtransformer.logger
+import org.objectweb.asm.*
 import org.objectweb.asm.AnnotationVisitor
-import org.objectweb.asm.ClassVisitor
-import org.objectweb.asm.MethodVisitor
-import org.objectweb.asm.Opcodes
 
 /**
  * ClassVisitor that gather all classes and methods with the given annotation. This is the first
@@ -32,12 +31,16 @@ class AnnotationVisitor(private val annotationDescriptor: String) : ClassVisitor
 
     val annotatedClasses: MutableSet<ByteCodeTypeDescriptor> = mutableSetOf()
     val annotatedMethods: MutableMap<ByteCodeTypeDescriptor, MutableSet<ByteCodeMethodName>> = mutableMapOf()
+    val annotatedFields: MutableMap<ByteCodeTypeDescriptor, MutableSet<FieldName>> = mutableMapOf()
+
     private var internalQualifiedName: String = ""
     private val annotatedMethodsInClass = mutableSetOf<ByteCodeMethodName>()
+    private val annotatedFieldsInClass = mutableSetOf<FieldName>()
 
     override fun visit(version: Int, access: Int, name: String?, signature: String?, superName: String?, interfaces: Array<out String>?) {
         internalQualifiedName = name!!
         annotatedMethods[internalQualifiedName] = annotatedMethodsInClass
+        annotatedFields[internalQualifiedName] = annotatedFieldsInClass
         super.visit(version, access, name, signature, superName, interfaces)
     }
 
@@ -60,6 +63,17 @@ class AnnotationVisitor(private val annotationDescriptor: String) : ClassVisitor
         }
     }
 
+    override fun visitField(access: Int, name: String?, descriptor: String?, signature: String?, value: Any?): FieldVisitor {
+        return object: FieldVisitor(api) {
+            override fun visitAnnotation(descriptor: String?, visible: Boolean): AnnotationVisitor? {
+                if (descriptor == annotationDescriptor) {
+                    annotatedFieldsInClass.add(name!!)
+                }
+                return super.visitAnnotation(descriptor, visible)
+            }
+        }
+    }
+
     override fun visitEnd() {
         annotatedMethods[internalQualifiedName] = annotatedMethodsInClass
         super.visitEnd()
diff --git a/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestFields.java b/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestFields.java
index 3020f7fbd0..b13f4cb492 100644
--- a/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestFields.java
+++ b/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestFields.java
@@ -16,10 +16,13 @@
 package io.realm.buildtransformer.testclasses;
 
 import io.realm.internal.annotations.ObjectServer;
+import io.realm.internal.annotations.CustomAnnotation;
 
 public class SimpleTestFields {
 
     @ObjectServer
     public String field1;
+
+    @CustomAnnotation // Annotations must be written back as well
     public String field2;
 }
diff --git a/library-build-transformer/src/test/java/io/realm/internal/annotations/CustomAnnotation.java b/library-build-transformer/src/test/java/io/realm/internal/annotations/CustomAnnotation.java
new file mode 100644
index 0000000000..c8014e0c4a
--- /dev/null
+++ b/library-build-transformer/src/test/java/io/realm/internal/annotations/CustomAnnotation.java
@@ -0,0 +1,11 @@
+package io.realm.internal.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
+public @interface CustomAnnotation {
+}
diff --git a/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt b/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt
index bd74b33d03..e0f8d25278 100644
--- a/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt
+++ b/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt
@@ -16,14 +16,15 @@
 package io.realm.buildtransformer
 
 import io.realm.buildtransformer.asm.ClassPoolTransformer
+import io.realm.buildtransformer.ext.packageHierarchyRootDir
+import io.realm.buildtransformer.ext.shouldBeDeleted
 import io.realm.buildtransformer.testclasses.*
+import io.realm.internal.annotations.CustomAnnotation
+import org.junit.Assert.*
 import org.junit.Before
 import org.junit.Test
 import java.io.File
 import kotlin.reflect.KClass
-import kotlin.test.assertEquals
-import kotlin.test.assertTrue
-import kotlin.test.fail
 
 class VisitorTests {
 
@@ -41,6 +42,7 @@ class VisitorTests {
         assetDefaultConstructorExists(c)
         assertFieldExists("field2", c)
         assertFieldRemoved("field1", c)
+        assertTrue(c.getField("field2").isAnnotationPresent(CustomAnnotation::class.java))
     }
 
     @Test
@@ -86,7 +88,7 @@ class VisitorTests {
         ).forEach { inputClasses.add(getClassFile(it)) }
         val transformer = ClassPoolTransformer(qualifiedAnnotationName, inputClasses)
         val outputFiles: Set<File> = transformer.transform()
-        assertEquals(1, outputFiles.size) // Only top level file is saved.
+        assertEquals(1, outputFiles.filter { !it.shouldBeDeleted }.size) // Only top level file is saved.
         assertTrue(outputFiles.first().name.endsWith("NestedTestClass.class"))
     }
 
@@ -97,7 +99,7 @@ class VisitorTests {
     private fun assertFieldRemoved(fieldName: String, clazz: Class<*>) {
         try {
             clazz.getField(fieldName)
-            fail("Field $fieldName has not been removed");
+            fail("Field $fieldName has not been removed")
         } catch (e: NoSuchFieldException) {
         }
     }
@@ -126,7 +128,7 @@ class VisitorTests {
         val inputClasses: MutableSet<File> = mutableSetOf()
         pool.forEach { inputClasses.add(getClassFile(it)) }
         val transformer = ClassPoolTransformer(qualifiedAnnotationName, inputClasses)
-        val outputFiles: Set<File> = transformer.transform()
+        val outputFiles: Set<File> = transformer.transform().filter { !it.shouldBeDeleted }.toSet()
         @Suppress("UNCHECKED_CAST")
         return classLoader.loadClass(clazz.java.name, outputFiles) as Class<T>
     }
@@ -137,6 +139,10 @@ class VisitorTests {
 
     private fun getClassFile(clazz: Class<*>): File {
         val filePath = "${clazz.name.replace(".", "/")}.class"
-        return File(classLoader.getResource(filePath).file)
+        val file = File(classLoader.getResource(filePath).file)
+        // Extension properties must be initialized before they can be read
+        file.shouldBeDeleted = false
+        file.packageHierarchyRootDir = ""
+        return file
     }
 }
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index 43628a8f8a..f785066656 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -1,10 +1,13 @@
 buildscript {
+    def properties = new Properties()
+    properties.load(new FileInputStream("${projectDir}/../dependencies.list"))
+
     repositories {
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:${properties.get('BUILD_INFO_EXTRACTOR_GRADLE')}"
+        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${properties.get('GRADLE_BINTRAY_PLUGIN')}"
     }
 }
 
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java b/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
index b4a3abb695..6f284714e8 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
@@ -31,6 +31,16 @@
 @Inherited
 public @interface RealmClass {
 
+    /**
+     * Manually set the internal name used by Realm for this class. If this class is part of
+     * any modules, this will also override any name policy set using
+     * {@link RealmModule#classNamingPolicy()}.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting the name means.
+     * @see #name()
+     */
+    String value() default "";
+
     /**
      * Manually set the internal name used by Realm for this class. If this class is part of
      * any modules, this will also override any name policy set using
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmField.java b/realm-annotations/src/main/java/io/realm/annotations/RealmField.java
index 0cdc67f6fd..bd665ee0d9 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmField.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmField.java
@@ -30,6 +30,15 @@
 @Inherited
 public @interface RealmField {
 
+    /**
+     * Manually set the internal name used by Realm for this field. This will override any
+     * {@link RealmNamingPolicy} set on the class or the module.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting the name means.
+     * @see #name()
+     */
+    String value() default "";
+
     /**
      * Manually set the internal name used by Realm for this field. This will override any
      * {@link RealmNamingPolicy} set on the class or the module.
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index c92b91f248..c0fc6bc89b 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -1,12 +1,15 @@
 buildscript {
-    ext.kotlin_version = '1.2.40'
+    def properties = new Properties()
+    properties.load(new FileInputStream("${projectDir}/../dependencies.list"))
+
+    ext.kotlin_version = '1.2.50'
     repositories {
         google()
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:${properties.get('BUILD_INFO_EXTRACTOR_GRADLE')}"
+        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${properties.get('GRADLE_BINTRAY_PLUGIN')}"
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
@@ -20,7 +23,6 @@ allprojects {
 }
 
 apply plugin: 'kotlin'
-apply plugin: 'groovy'
 apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'maven-publish'
@@ -62,14 +64,12 @@ sourceSets {
 dependencies {
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
+    compileOnly "com.android.tools.build:gradle:${properties.get("GRADLE_BUILD_TOOLS")}"
     compileOnly 'com.android.tools.build:gradle:3.1.1'
     compile 'org.javassist:javassist:3.21.0-GA'
     compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${kotlin_version}"
 
-    testCompile localGroovy()
-    testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
-        exclude module: 'groovy-all'
-    }
+    testCompile 'junit:junit:4.12'
 }
 
 // for Ant filter
@@ -83,10 +83,6 @@ task generateVersionClass(type: Copy) {
 }
 
 compileJava.dependsOn generateVersionClass
-compileGroovy.dependsOn = compileGroovy.taskDependencies.values - 'compileJava'
-compileKotlin.dependsOn compileGroovy
-compileKotlin.classpath += files(compileGroovy.destinationDir)
-classes.dependsOn compileKotlin
 
 def commonPom = {
     licenses {
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
deleted file mode 100644
index e9abb6b751..0000000000
--- a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.transformer
-
-import io.realm.annotations.Ignore
-import javassist.*
-import javassist.bytecode.AnnotationsAttribute
-import javassist.bytecode.CodeIterator
-import javassist.bytecode.ConstPool
-import javassist.bytecode.Opcode
-import javassist.bytecode.annotation.Annotation
-import spock.lang.Specification
-
-import java.lang.reflect.Modifier
-
-class BytecodeModifierTest extends Specification {
-    def "AddRealmAccessors"() {
-        setup: 'generate an empty class'
-        def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('testClass')
-
-        and: 'add a field'
-        def ctField = new CtField(CtClass.intType, 'age', ctClass)
-        ctClass.addField(ctField)
-
-        when: 'the accessors are added'
-        BytecodeModifier.addRealmAccessors(ctClass)
-
-        then: 'the accessors are generated'
-        def ctMethods = ctClass.getDeclaredMethods()
-        def methodNames = ctMethods.name
-        methodNames.contains('realmGet$age')
-        methodNames.contains('realmSet$age')
-
-        and: 'the accessors are public'
-        ctMethods.each {
-            it.getModifiers() == Modifier.PUBLIC
-        }
-    }
-
-    // https://github.com/realm/realm-java/issues/3469
-    def "AddRealmAccessors_duplicateSetter"() {
-        setup: 'generate an empty class'
-        def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('testClass')
-
-        and: 'add a field'
-        def ctField = new CtField(CtClass.intType, 'age', ctClass)
-        ctClass.addField(ctField)
-
-        and: 'add a setter'
-        def setter = CtNewMethod.setter('realmSet$age', ctField)
-        ctClass.addMethod(setter)
-
-        when: 'addRealmAccessors is called'
-        BytecodeModifier.addRealmAccessors(ctClass)
-
-        then: 'a getter for the field is generated'
-        def ctMethods = ctClass.getDeclaredMethods()
-        def methodNames = ctMethods.name
-        methodNames.contains('realmGet$age')
-
-        and: 'the setter is not changed'
-        ctMethods.find {it.name.equals('realmSet$age')} == setter
-
-        and: 'the accessors are public'
-        ctMethods.each {
-            it.getModifiers() == Modifier.PUBLIC
-        }
-    }
-
-    // https://github.com/realm/realm-java/issues/3469
-    def "AddRealmAccessors_duplicateGetter"() {
-        setup: 'generate an empty class'
-        def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('testClass')
-
-        and: 'add a field'
-        def ctField = new CtField(CtClass.intType, 'age', ctClass)
-        ctClass.addField(ctField)
-
-        and: 'add a getter'
-        def getter = CtNewMethod.getter('realmGet$age', ctField)
-        ctClass.addMethod(getter)
-
-        when: 'addRealmAccessors is called'
-        BytecodeModifier.addRealmAccessors(ctClass)
-
-        then: 'a setter for the field is generated'
-        def ctMethods = ctClass.getDeclaredMethods()
-        def methodNames = ctMethods.name
-        methodNames.contains('realmSet$age')
-
-        and: 'the getter is not changed'
-        ctMethods.find {it.name.equals('realmGet$age')} == getter
-
-        and: 'the accessors are public'
-        ctMethods.each {
-            it.getModifiers() == Modifier.PUBLIC
-        }
-    }
-
-    def "AddRealmAccessors_IgnoreAnnotation"() {
-        setup: 'generate an empty class'
-        def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('TestClass')
-        def constPool = new ConstPool('TestClass')
-
-        and: 'add a field with @Ignore'
-        def ctField = new CtField(CtClass.intType, 'age', ctClass)
-        ctClass.addField(ctField)
-        def attr = new AnnotationsAttribute(constPool, AnnotationsAttribute.visibleTag)
-        def ignoreAnnotation = new Annotation(Ignore.class.name, constPool)
-        attr.addAnnotation(ignoreAnnotation)
-        ctField.fieldInfo.addAttribute(attr)
-
-        when: 'Try to add the accessor'
-        BytecodeModifier.addRealmAccessors(ctClass)
-
-        then: 'the accessor should not be generated'
-        def ctMethods = ctClass.getDeclaredMethods()
-        def methodNames = ctMethods.name
-        !methodNames.contains('realmGet$age')
-        !methodNames.contains('realmSet$age')
-    }
-
-    def "UseRealmAccessors"() {
-        setup: 'generate an empty class'
-        def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('TestClass')
-
-        and: 'add a field'
-        def ctField = new CtField(CtClass.intType, 'age', ctClass)
-        ctClass.addField(ctField)
-
-        and: 'add a method that uses such field'
-        def ctMethod = CtNewMethod.make('public boolean canDrive() { return this.age >= 18; }', ctClass)
-        ctClass.addMethod(ctMethod)
-
-        and: 'realm accessors are added'
-        BytecodeModifier.addRealmAccessors(ctClass)
-
-        when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(classPool, ctClass, [ctField])
-
-        then: 'the field is not used and getter is called in the method '
-        !isFieldRead(ctMethod) && hasMethodCall(ctMethod)
-    }
-
-    def "UseRealmAccessors_fieldAccessConstructorIsTransformed"() {
-        setup: 'generate an empty class'
-        def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('TestClass')
-
-        and: 'add a field'
-        def ctField = new CtField(CtClass.intType, 'age', ctClass)
-        ctClass.addField(ctField)
-
-        and: 'add a method that sets such field'
-        def ctMethod = CtNewMethod.make('private void setupAge(int age) { this.age = age; }', ctClass)
-        ctClass.addMethod(ctMethod)
-
-        and: 'add a default constructor that uses the method'
-        def ctDefaultConstructor = CtNewConstructor.make('public TestClass() { int myAge = this.age; }', ctClass)
-        ctClass.addConstructor(ctDefaultConstructor)
-
-        and: 'add a non-default constructor that uses the method'
-        def ctNonDefaultConstructor = CtNewConstructor.make('public TestClass(TestClass other) { int otherAge = other.age; }', ctClass)
-        ctClass.addConstructor(ctNonDefaultConstructor)
-
-        and: 'realm accessors are added'
-        BytecodeModifier.addRealmAccessors(ctClass)
-
-        when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(classPool, ctClass, [ctField])
-
-        then: 'the field is not used in the method anymore'
-        !isFieldRead(ctDefaultConstructor) && hasMethodCall(ctDefaultConstructor) &&
-                !isFieldRead(ctNonDefaultConstructor) && hasMethodCall(ctNonDefaultConstructor)
-    }
-
-    private static def isFieldRead(CtBehavior behavior) {
-        def methodInfo = behavior.getMethodInfo()
-        def codeAttribute = methodInfo.getCodeAttribute()
-
-        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
-            int index = ci.next()
-            int op = ci.byteAt(index)
-            if (op == Opcode.GETFIELD) {
-                return true
-            }
-        }
-        return false
-    }
-
-    private static def hasMethodCall(CtBehavior behavior) {
-        def methodInfo = behavior.getMethodInfo()
-        def codeAttribute = methodInfo.getCodeAttribute()
-
-        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
-            int index = ci.next()
-            int op = ci.byteAt(index)
-            if (op == Opcode.INVOKEVIRTUAL) {
-                return true
-            }
-        }
-        return false
-    }
-}
diff --git a/realm-transformer/src/test/kotlin/io/realm/transformer/ByteCodeModifierTest.kt b/realm-transformer/src/test/kotlin/io/realm/transformer/ByteCodeModifierTest.kt
new file mode 100644
index 0000000000..0abb726cec
--- /dev/null
+++ b/realm-transformer/src/test/kotlin/io/realm/transformer/ByteCodeModifierTest.kt
@@ -0,0 +1,238 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import io.realm.annotations.Ignore
+import javassist.*
+import javassist.bytecode.AnnotationsAttribute
+import javassist.bytecode.ConstPool
+import javassist.bytecode.Opcode
+import javassist.bytecode.annotation.Annotation
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import java.lang.reflect.Modifier
+
+class ByteCodeModifierTest {
+
+    @Test
+    fun addRealmAccessors() {
+        // Generate an empty class
+        val classPool = ClassPool.getDefault()
+        val ctClass = classPool.makeClass("testClass")
+
+        // Add a field
+        val ctField = CtField(CtClass.intType, "age", ctClass)
+        ctClass.addField(ctField)
+
+        // The accessors are added
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        // The accessors are generated
+        val ctMethods = ctClass.declaredMethods
+        val methodNames = ctMethods.map { it.name }
+        assertTrue(methodNames.contains("realmGet\$age"))
+        assertTrue(methodNames.contains("realmSet\$age"))
+
+        // The accessors are public
+        ctMethods.forEach {
+            assertTrue(it.modifiers == Modifier.PUBLIC)
+        }
+    }
+
+    // https://github.com/realm/realm-java/issues/3469
+    @Test
+    fun addRealmAccessors_duplicateSetter() {
+        // Generate an empty class
+        val classPool = ClassPool.getDefault()
+        val ctClass = classPool.makeClass("testClass")
+
+        // Add a field
+        val ctField = CtField(CtClass.intType, "age", ctClass)
+        ctClass.addField(ctField)
+
+        // Add a setter
+        val setter = CtNewMethod.setter("realmSet\$age", ctField)
+        ctClass.addMethod(setter)
+
+        // addRealmAccessors is called
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        // a getter for the field is generated
+        val ctMethods = ctClass.declaredMethods
+        val methodNames = ctMethods.map { it.name }
+        assertTrue(methodNames.contains("realmGet\$age"))
+
+        // the setter is not changed
+        assertTrue(ctMethods.find { it.name == "realmSet\$age" } == setter)
+
+        // accessors are public
+        ctMethods.forEach {
+            assertTrue(it.modifiers == Modifier.PUBLIC)
+        }
+    }
+
+    // https://github.com/realm/realm-java/issues/3469
+    @Test
+    fun addRealmAccessors_duplicateGetter() {
+        // Generate an empty class
+        val classPool = ClassPool.getDefault()
+        val ctClass = classPool.makeClass("testClass")
+
+        // Add a field
+        val ctField = CtField(CtClass.intType, "age", ctClass)
+        ctClass.addField(ctField)
+
+        // Add a getter
+        val setter = CtNewMethod.setter("realmGet\$age", ctField)
+        ctClass.addMethod(setter)
+
+        // addRealmAccessors is called
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        // a setter for the field is generated
+        val ctMethods = ctClass.declaredMethods
+        val methodNames = ctMethods.map { it.name }
+        assertTrue(methodNames.contains("realmSet\$age"))
+
+        // the getter is not changed
+        assertTrue(ctMethods.find { it.name == "realmGet\$age" } == setter)
+
+        // accessors are public
+        ctMethods.forEach {
+            assertTrue(it.modifiers == Modifier.PUBLIC)
+        }
+    }
+
+    @Test
+    fun addRealmAccessors_ignoreAnnotation() {
+        // Generate an empty class
+        val classPool = ClassPool.getDefault()
+        val ctClass = classPool.makeClass("testClass")
+        val constPool = ConstPool("TestClass")
+
+        // Add a field with @Ignore
+        val ctField = CtField(CtClass.intType, "age", ctClass)
+        ctClass.addField(ctField)
+        val attr = AnnotationsAttribute(constPool, AnnotationsAttribute.visibleTag)
+        val ignoreAnnotation = Annotation(Ignore::class.java.name, constPool)
+        attr.addAnnotation(ignoreAnnotation)
+        ctField.fieldInfo.addAttribute(attr)
+
+        // Try to add the accessor
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        // the accessor should not be generated
+        // a setter for the field is generated
+        val ctMethods = ctClass.declaredMethods
+        val methodNames = ctMethods.map { it.name }
+        assertFalse(methodNames.contains("realmSet\$age"))
+        assertFalse(methodNames.contains("realmGet\$age"))
+    }
+
+    @Test
+    fun userRealmAccessors() {
+        // Generate an empty class
+        val classPool = ClassPool.getDefault()
+        val ctClass = classPool.makeClass("testClass")
+
+        // Add a field
+        val ctField = CtField(CtClass.intType, "age", ctClass)
+        ctClass.addField(ctField)
+
+        // Add a method that uses such field
+        val ctMethod = CtNewMethod.make("public boolean canDrive() { return this.age >= 18; }", ctClass)
+        ctClass.addMethod(ctMethod)
+
+        // Realm accessors are called
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        // the field use is replaced by the accessor
+        BytecodeModifier.useRealmAccessors(classPool, ctClass, listOf(ctField))
+
+        // the field is not used and getter is called in the method
+        assertTrue(!isFieldRead(ctMethod) && hasMethodCall(ctMethod))
+    }
+
+    fun userRealmAccessors_fieldAccessConstructorIsTransformed() {
+        // Generate an empty class
+        val classPool = ClassPool.getDefault()
+        val ctClass = classPool.makeClass("testClass")
+        val constPool = ConstPool("TestClass")
+
+        // Add a field with @Ignore
+        val ctField = CtField(CtClass.intType, "age", ctClass)
+        ctClass.addField(ctField)
+
+        // Add a method sets such field
+        val ctMethod = CtNewMethod.make("private void setupAge(int age) { this.age = age; }", ctClass)
+        ctClass.addMethod(ctMethod)
+
+        // Add a default constructor that uses the method
+        val ctDefaultConstructor = CtNewConstructor.make("public TestClass() { int myAge = this.age; }", ctClass)
+        ctClass.addConstructor(ctDefaultConstructor)
+
+        // Add a non-default constructor that uses the method
+        val ctNonDefaultConstructor = CtNewConstructor.make("public TestClass(TestClass other) { int otherAge = other.age; }", ctClass)
+        ctClass.addConstructor(ctNonDefaultConstructor)
+
+        // Realm accessors are added
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        // the field use is replaced by the accessor
+        BytecodeModifier.useRealmAccessors(classPool, ctClass, listOf(ctField))
+
+        // the field is not used in the method anymore
+        assertTrue(!isFieldRead(ctDefaultConstructor)
+                && hasMethodCall(ctDefaultConstructor)
+                && !isFieldRead(ctNonDefaultConstructor)
+                && hasMethodCall(ctNonDefaultConstructor))
+    }
+
+    private fun isFieldRead(behavior: CtBehavior): Boolean {
+        val methodInfo = behavior.methodInfo
+        val codeAttribute = methodInfo.codeAttribute
+
+        val it = codeAttribute.iterator()
+        var index = 0;
+        while (it.hasNext()) {
+            val op: Int = it.byteAt(index)
+            index = it.next()
+            if (op == Opcode.GETFIELD) {
+                return true;
+            }
+        }
+        return false
+    }
+
+    private fun hasMethodCall(behavior: CtBehavior): Boolean {
+        val methodInfo = behavior.methodInfo
+        val codeAttribute = methodInfo.codeAttribute
+
+        val it = codeAttribute.iterator()
+        var index = 0;
+        while (it.hasNext()) {
+            val op: Int = it.byteAt(index)
+            index = it.next()
+            if (op == Opcode.INVOKEVIRTUAL) {
+                return true;
+            }
+        }
+        return false
+    }
+
+}
diff --git a/realm.properties b/realm.properties
index 4567c707cc..1a1be59f2f 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=4.4.1
+gradleVersion=4.9
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index af6f32dd91..53ffc2de3a 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,9 +1,7 @@
-project.ext.minSdkVersion = 9
-project.ext.compileSdkVersion = 26
-project.ext.buildToolsVersion = '27.0.2'
-
 buildscript {
-    ext.kotlin_version = '1.2.40'
+    def projectDependencies = new Properties()
+    projectDependencies.load(new FileInputStream("${rootDir}/../dependencies.list"))
+    ext.kotlin_version = '1.2.50'
     ext.dokka_version = '0.9.16'
     repositories {
         mavenLocal()
@@ -14,14 +12,14 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.1.0-alpha06'
+        classpath "com.android.tools.build:gradle:${projectDependencies.get('GRADLE_BUILD_TOOLS')}"
         classpath 'de.undercouch:gradle-download-task:3.3.0'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0'
         classpath 'com.novoda:gradle-android-command-plugin:1.7.1'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.4'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.2'
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.4'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
+        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:${projectDependencies.get('BUILD_INFO_EXTRACTOR_GRADLE')}"
+        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:${projectDependencies.get('GRADLE_BINTRAY_PLUGIN')}"
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
         classpath "io.realm:realm-library-build-transformer:${file('../version.txt').text.trim()}"
         classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.13'
@@ -37,6 +35,12 @@ allprojects {
         project.ext.set(key, val)
     }
 
+    def projectDependencies = new Properties()
+    projectDependencies.load(new FileInputStream("${rootDir}/../dependencies.list"))
+    project.ext.minSdkVersion = 9
+    project.ext.compileSdkVersion = 26
+    project.ext.buildToolsVersion = projectDependencies.get("ANDROID_BUILD_TOOLS")
+
     group = 'io.realm'
     version = file("${rootDir}/../version.txt").text.trim()
     repositories {
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index 01b8bf6b1f..99340b4ad1 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 57c7d2d22b..bd24854fe8 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm/kotlin-extensions/build.gradle b/realm/kotlin-extensions/build.gradle
index e3da497fe3..4f7841a9ae 100644
--- a/realm/kotlin-extensions/build.gradle
+++ b/realm/kotlin-extensions/build.gradle
@@ -54,7 +54,16 @@ android {
         main.java.srcDirs += 'src/main/kotlin'
         androidTest.java.srcDirs += ['src/androidTest/kotlin', '../realm-library/src/testUtils/java']
         objectServer.java.srcDirs += 'src/objectServer/kotlin'
-        androidTestObjectServer.java.srcDirs += 'src/androidTestObjectServer/kotlin'
+        androidTestObjectServer.java.srcDirs += [
+                'src/androidTestObjectServer/kotlin',
+                '../realm-library/src/testUtils/java',
+                '../realm-library/src/testUtils/kotlin',
+                '../realm-library/src/syncTestUtils/java',
+        ]
+    }
+    compileOptions {
+        targetCompatibility 1.8
+        sourceCompatibility 1.8
     }
 }
 
@@ -66,6 +75,11 @@ dependencies {
     androidTestImplementation 'com.android.support.test:rules:1.0.2'
     kaptAndroidTest project(':realm-annotations-processor')
     androidTestImplementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
+    androidTestObjectServerImplementation 'com.squareup.okhttp3:okhttp:3.9.0'
+    androidTestObjectServerImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'
+    androidTestObjectServerImplementation 'com.google.code.findbugs:jsr305:3.0.2'
+
+
 }
 
 repositories {
diff --git a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt
index eebd34cf20..e15e68fe5b 100644
--- a/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt
+++ b/realm/kotlin-extensions/src/androidTest/kotlin/io/realm/KotlinRealmTests.kt
@@ -19,14 +19,12 @@ import org.junit.runner.RunWith
 class KotlinRealmTests {
 
     @Suppress("MemberVisibilityCanPrivate")
-    @get:Rule
-    val configFactory = TestRealmConfigurationFactory()
+    @Rule @JvmField val configFactory = TestRealmConfigurationFactory()
 
     private lateinit var realm: Realm
 
     @Before
     fun setUp() {
-        Realm.init(InstrumentationRegistry.getTargetContext())
         realm = Realm.getInstance(configFactory.createConfiguration())
     }
 
diff --git a/realm/kotlin-extensions/src/androidTestObjectServer/kotlin/io/realm/kotlin/KotlinSyncedRealmTests.kt b/realm/kotlin-extensions/src/androidTestObjectServer/kotlin/io/realm/kotlin/KotlinSyncedRealmTests.kt
new file mode 100644
index 0000000000..9750686ee9
--- /dev/null
+++ b/realm/kotlin-extensions/src/androidTestObjectServer/kotlin/io/realm/kotlin/KotlinSyncedRealmTests.kt
@@ -0,0 +1,71 @@
+package io.realm.kotlin
+
+import android.support.test.InstrumentationRegistry
+import android.support.test.runner.AndroidJUnit4
+import io.realm.Realm
+import io.realm.SyncConfiguration
+import io.realm.SyncManager
+import io.realm.TestSyncConfigurationFactory
+import io.realm.entities.SimpleClass
+import io.realm.objectserver.utils.Constants
+import io.realm.SyncTestUtils
+import org.junit.After
+import org.junit.Assert.*
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@RunWith(AndroidJUnit4::class)
+class KotlinSyncedRealmTests {
+
+    @get:Rule
+    val configFactory = TestSyncConfigurationFactory()
+
+
+    private lateinit var realm: Realm
+
+    @Before
+    fun setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext())
+        val user = SyncTestUtils.createTestUser()
+        realm = Realm.getInstance(configFactory.createSyncConfigurationBuilder(user, Constants.DEFAULT_REALM).build())
+    }
+
+    @After
+    fun tearDown() {
+        realm.close()
+    }
+
+    @Test
+    fun syncSession() {
+        assertEquals(SyncManager.getSession(realm.configuration as SyncConfiguration), realm.syncSession)
+    }
+
+    @Test
+    fun syncSession_throwsForNonSyncRealm() {
+        realm.close()
+        realm = Realm.getInstance(configFactory.createConfiguration())
+        try {
+            realm.syncSession
+            fail()
+        } catch (ignored: IllegalStateException) {
+        }
+    }
+
+    @Test
+    fun classPermissions() {
+        assertNotNull(realm.classPermissions<SimpleClass>())
+    }
+
+    @Test
+    fun classPermissions_throwsForNonSyncRealm() {
+        realm.close()
+        realm = Realm.getInstance(configFactory.createConfiguration())
+        try {
+            realm.classPermissions<SimpleClass>()
+            fail()
+        } catch (ignored: IllegalStateException) {
+        }
+    }
+}
diff --git a/realm/kotlin-extensions/src/objectServer/kotlin/io/realm/kotlin/SyncedRealmExtensions.kt b/realm/kotlin-extensions/src/objectServer/kotlin/io/realm/kotlin/SyncedRealmExtensions.kt
new file mode 100644
index 0000000000..b7a29fe64b
--- /dev/null
+++ b/realm/kotlin-extensions/src/objectServer/kotlin/io/realm/kotlin/SyncedRealmExtensions.kt
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.kotlin
+
+import io.realm.Realm
+import io.realm.RealmModel
+import io.realm.SyncConfiguration
+import io.realm.SyncManager
+import io.realm.SyncSession
+import io.realm.sync.permissions.ClassPermissions
+
+
+/**
+ * Returns the [SyncSession] associated with this Realm.
+ *
+ * @return the [SyncSession] associated with this Realm.
+ * @throws IllegalStateException if the Realm is not a synchronized Realm.
+ */
+val Realm.syncSession: SyncSession
+    get() {
+        if (!(this.configuration is SyncConfiguration)) {
+            throw IllegalStateException("This method is only available on synchronized Realms")
+        }
+        return SyncManager.getSession(this.configuration as SyncConfiguration)
+    }
+
+/**
+ * Returns all permissions associated with the given class. Attach a change listener using
+ * [ClassPermissions.addChangeListener] to be notified about any future changes.
+ *
+ * @return the permissions for the given class or `null` if no permissions where found.
+ * @throws RealmException if the class is not part of this Realms schema.
+ * @throws IllegalStateException if the Realm is not a synchronized Realm.
+ */
+inline fun <reified T : RealmModel> Realm.classPermissions(): ClassPermissions {
+    if (!(this.configuration is SyncConfiguration)) {
+        throw java.lang.IllegalStateException("This method is only available on synchronized Realms")
+    }
+    return this.getPermissions(T::class.java)
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index bcbb25cf26..03f3fa523f 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -307,8 +307,10 @@ public boolean generate(ModuleMetaData moduleMetaData) {
 
         RealmClass realmClassAnnotation = classType.getAnnotation(RealmClass.class);
         // If name has been specifically set, it should override any module policy.
-        if (!realmClassAnnotation.name().equals("")) {
+        if (!realmClassAnnotation.name().isEmpty()) {
             internalClassName = realmClassAnnotation.name();
+        } else if (!realmClassAnnotation.value().isEmpty()) {
+            internalClassName = realmClassAnnotation.value();
         } else {
             internalClassName = moduleClassNameFormatter.convert(javaClassName);
         }
@@ -581,14 +583,15 @@ private boolean categorizeField(Element element) {
     private String getInternalFieldName(VariableElement field, NameConverter defaultConverter) {
         RealmField nameAnnotation = field.getAnnotation(RealmField.class);
         if (nameAnnotation != null) {
-            String declaredName = nameAnnotation.name();
-            if (!declaredName.equals("")) {
-                return declaredName;
-            } else {
-                Utils.note(String.format("Empty internal name defined on @RealmField. " +
-                        "Falling back to named used by Java model class: %s", field.getSimpleName()), field);
-                return field.getSimpleName().toString();
+            if (!nameAnnotation.name().isEmpty()) {
+                return nameAnnotation.name();
             }
+            if (!nameAnnotation.value().isEmpty()) {
+                return nameAnnotation.value();
+            }
+            Utils.note(String.format("Empty internal name defined on @RealmField. " +
+                    "Falling back to named used by Java model class: %s", field.getSimpleName()), field);
+            return field.getSimpleName().toString();
         } else {
             return defaultConverter.convert(field.getSimpleName().toString());
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java
index 0b0972fa0f..e7507ee3f5 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java
@@ -23,7 +23,7 @@
 /**
  * Class with only a custom name
  */
-@RealmClass(name = "customName")
+@RealmClass("customName")
 public class NamePolicyClassOnly extends RealmObject {
 
     public String firstName;
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java
index 1109fb5e21..a4c2259126 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java
@@ -25,7 +25,7 @@
  */
 public class NamePolicyFieldNameOnly extends RealmObject {
 
-    @RealmField(name = "first_name")
+    @RealmField("first_name")
     public String firstName;
     public String lastName;
 }
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 7573d814bf..791b2bc3d7 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -103,10 +103,10 @@ android {
 
     sourceSets {
         androidTest {
-            java.srcDirs += ['src/androidTest/kotlin', 'src/testUtils/java']
+            java.srcDirs += ['src/androidTest/kotlin', 'src/testUtils/java', 'src/testUtils/kotlin']
         }
         androidTestObjectServer {
-            java.srcDirs += 'src/syncIntegrationTest/java'
+            java.srcDirs += ['src/syncIntegrationTest/java', 'src/syncTestUtils/java']
             assets.srcDirs += ['src/syncIntegrationTest/assets/']
         }
     }
@@ -211,7 +211,7 @@ dependencies {
 
     api "io.realm:realm-annotations:${version}"
     implementation 'com.google.code.findbugs:jsr305:3.0.2'
-    implementation 'com.getkeepsafe.relinker:relinker:1.2.2'
+    implementation 'com.getkeepsafe.relinker:relinker:1.3.0'
 
     kapt project(':realm-annotations-processor') // See https://github.com/realm/realm-java/issues/5799
     objectServerImplementation 'com.squareup.okhttp3:okhttp:3.9.0'
@@ -219,8 +219,8 @@ dependencies {
     kaptAndroidTest project(':realm-annotations-processor')
     androidTestImplementation fileTree(dir: 'testLibs', include: ['*.jar'])
     androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.5'
-    androidTestImplementation 'com.android.support.test:runner:1.0.1'
-    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'com.android.support.test:rules:1.0.2'
     androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
     androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestImplementation 'org.hamcrest:hamcrest-library:1.3'
diff --git a/realm/realm-library/gradle.properties b/realm/realm-library/gradle.properties
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java b/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
index e4c23cbce0..829c3386db 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
@@ -25,11 +25,13 @@
 
 import io.realm.entities.realmname.ClassNameOverrideModulePolicy;
 import io.realm.entities.realmname.ClassWithPolicy;
+import io.realm.entities.realmname.ClassWithValueDefinedNames;
 import io.realm.entities.realmname.CustomRealmNamesModule;
 import io.realm.entities.realmname.FieldNameOverrideClassPolicy;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -206,6 +208,18 @@ public void dynamicSchemaReturnsInternalNames() {
         }
     }
 
+    // Verify that names using the default value() parameter on annotations are used correctly
+    @Test
+    public void valueParameterDefinedNamesInsteadOfExplicit() {
+        RealmSchema schema = realm.getSchema();
+        assertTrue(schema.contains(ClassWithValueDefinedNames.REALM_CLASS_NAME));
+        assertFalse(schema.contains(ClassWithValueDefinedNames.JAVA_CLASS_NAME));
+
+        RealmObjectSchema classSchema = schema.get(ClassWithValueDefinedNames.REALM_CLASS_NAME);
+        assertTrue(classSchema.hasField(ClassWithValueDefinedNames.REALM_FIELD_NAME));
+        assertFalse(classSchema.hasField(ClassWithValueDefinedNames.JAVA_FIELD_NAME));
+    }
+
     //
     // Dynamic Realm tests
     //
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassWithValueDefinedNames.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassWithValueDefinedNames.java
new file mode 100644
index 0000000000..fd35858876
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassWithValueDefinedNames.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities.realmname;
+
+import io.realm.RealmObject;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmField;
+
+@RealmClass("my-class-name")
+public class ClassWithValueDefinedNames extends RealmObject {
+
+    public static final String JAVA_CLASS_NAME = "ClassWithValueDefinedNames";
+    public static final String REALM_CLASS_NAME = "my-class-name";
+
+    public static final String JAVA_FIELD_NAME = "field";
+    public static final String REALM_FIELD_NAME = "my-field-name";
+
+    @RealmField("my-field-name")
+    public String field;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java
index ec11780ecf..89e6bc5b2f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java
@@ -18,11 +18,14 @@
 import io.realm.annotations.RealmModule;
 import io.realm.annotations.RealmNamingPolicy;
 
-@RealmModule(classes = {
-        ClassNameOverrideModulePolicy.class,
-        ClassWithPolicy.class,
-        DefaultPolicyFromModule.class,
-        FieldNameOverrideClassPolicy.class },
+@RealmModule(classes =
+        {
+            ClassNameOverrideModulePolicy.class,
+            ClassWithPolicy.class,
+            ClassWithValueDefinedNames.class,
+            DefaultPolicyFromModule.class,
+            FieldNameOverrideClassPolicy.class
+        },
         classNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES,
         fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES
 )
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
index 290a2133e4..ad2fdd9539 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
@@ -17,6 +17,8 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -25,6 +27,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.RealmConfiguration;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static junit.framework.Assert.assertEquals;
@@ -40,6 +44,16 @@
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
+    @Before
+    public void setUp() {
+        RealmLog.setLevel(LogLevel.ERROR);
+    }
+
+    @After
+    public void tearDown() {
+        RealmLog.setLevel(LogLevel.WARN);
+    }
+
     @Test
     public void callWithLock() {
         RealmConfiguration config = configFactory.createConfiguration();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
index 9d8a431a99..e9333fb789 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
@@ -16,7 +16,10 @@
  */
 package io.realm.internal.android;
 
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.text.ParseException;
 import java.util.Calendar;
@@ -26,9 +29,17 @@
 
 import io.realm.exceptions.RealmException;
 
-public class JsonUtilsTest extends AndroidTestCase {
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class JsonUtilsTest {
 
-    public void testParseNullAndEmptyDateIsNull() {
+    @Test
+    public void parseNullAndEmptyDateIsNull() {
         Date output = JsonUtils.stringToDate(null);
         assertNull("Null input should output a null date object", output);
 
@@ -36,7 +47,8 @@ public void testParseNullAndEmptyDateIsNull() {
         assertNull("Empty string input should output a null date object", output);
     }
 
-    public void testParseMillisToDate() {
+    @Test
+    public void parseMillisToDate() {
         Date originalDate = Calendar.getInstance().getTime();
         long dateTimeInMillis = originalDate.getTime();
         Date output = JsonUtils.stringToDate(String.valueOf(dateTimeInMillis));
@@ -44,21 +56,24 @@ public void testParseMillisToDate() {
         assertTrue("Dates should match", output.equals(originalDate));
     }
 
-    public void testParseJsonDateToDate() {
+    @Test
+    public void parseJsonDateToDate() {
         String jsonDate = "/Date(1198908717056)/"; // 2007-12-27T23:11:57.056
         Date output = JsonUtils.stringToDate(jsonDate);
 
         assertEquals(1198908717056L, output.getTime());
     }
 
-    public void testNegativeLongDate() {
+    @Test
+    public void negativeLongDate() {
         long timeInMillis = -631152000L; // Jan 1, 1950
         Date output = JsonUtils.stringToDate(String.valueOf(timeInMillis));
 
         assertEquals("Should be Jan 1, 1950 in millis", timeInMillis, output.getTime());
     }
 
-    public void testParseInvalidDateShouldThrowRealmException() {
+    @Test
+    public void parseInvalidDateShouldThrowRealmException() {
         String invalidLongDate = "123abc";
         try {
             Date d = JsonUtils.stringToDate(invalidLongDate);
@@ -69,7 +84,8 @@ public void testParseInvalidDateShouldThrowRealmException() {
         }
     }
 
-    public void testParseInvalidNumericDateShouldThrowRealmException() {
+    @Test
+    public void parseInvalidNumericDateShouldThrowRealmException() {
         String invalidLongDate = "2342347289374398342759873495743"; // not a date.
         try {
             Date d = JsonUtils.stringToDate(invalidLongDate);
@@ -80,7 +96,8 @@ public void testParseInvalidNumericDateShouldThrowRealmException() {
         }
     }
 
-    public void testParseISO8601Dates() throws ParseException {
+    @Test
+    public void parseISO8601Dates() throws ParseException {
         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);
         cal.setTimeZone(TimeZone.getTimeZone("GMT"));
         cal.set(Calendar.MILLISECOND, 789);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index 957a1f196a..492acda0ea 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -18,7 +18,6 @@
 import io.realm.internal.network.AuthenticateRequest;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.objectserver.Token;
-import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
index 21471813c2..79eb7fd407 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
@@ -37,7 +37,7 @@
 import io.realm.sync.permissions.RealmPrivileges;
 import io.realm.sync.permissions.Role;
 
-import static io.realm.util.SyncTestUtils.createTestUser;
+import static io.realm.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
index e1c613eb86..f91bd6520e 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
@@ -28,7 +28,6 @@
 import java.util.Set;
 
 import io.realm.entities.StringOnly;
-import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 6ea9d4956b..472c26a581 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -30,14 +30,13 @@
 
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmFileException;
-import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.sync.permissions.ObjectPermissionsModule;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 
-import static io.realm.util.SyncTestUtils.createTestUser;
+import static io.realm.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -469,4 +468,12 @@ public void isConnected_falseForInvalidUser() {
         }
     }
 
+    @Test
+    public void close_doesNotThrowIfCalledWhenRealmIsClosed() {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+        realm.close();
+        session.stop();
+        assertEquals(SyncSession.State.INACTIVE, session.getState());
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index c1d65abc22..8b3438af3c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -37,10 +37,9 @@
 import io.realm.entities.StringOnly;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
-import io.realm.util.SyncTestUtils;
 
-import static io.realm.util.SyncTestUtils.createNamedTestUser;
-import static io.realm.util.SyncTestUtils.createTestUser;
+import static io.realm.SyncTestUtils.createNamedTestUser;
+import static io.realm.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
@@ -485,7 +484,7 @@ public void getDefaultConfiguration_throwsIfNotLoggedIn() {
 
     @Test
     public void getDefaultConfiguration_isFullySynchronized() {
-        SyncUser user = SyncTestUtils.createTestUser();
+        SyncUser user = createTestUser();
         SyncConfiguration config = user.getDefaultConfiguration();
         assertFalse(config.isFullySynchronizedRealm());
     }
@@ -513,7 +512,7 @@ public void automatic_convertsAuthUrl() {
             String authUrl = (String) test[0];
             String realmUrl = (String) test[1];
 
-            SyncUser user = SyncTestUtils.createTestUser(authUrl);
+            SyncUser user = createTestUser(authUrl);
             SyncConfiguration config = user.getDefaultConfiguration();
             URI url = config.getServerUrl();
             assertEquals(realmUrl, url.toString());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 2ec72220e6..82be4408c3 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -26,14 +27,19 @@
 import org.junit.runner.RunWith;
 
 import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
 
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestRealmConfigurationFactory;
 
-import static io.realm.util.SyncTestUtils.createTestUser;
+import static io.realm.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -78,6 +84,7 @@ public boolean isActive(String identity, String authenticationUrl) {
                 return true;
             }
         };
+        SyncManager.reset();
     }
 
     @After
@@ -87,6 +94,7 @@ public void tearDown() {
         for (SyncUser syncUser : userStore.allUsers()) {
             userStore.remove(syncUser.getIdentity(), syncUser.getAuthenticationUrl().toString());
         }
+        SyncManager.reset();
     }
 
     @Test
@@ -160,6 +168,8 @@ public void loggedOut(SyncUser user) {
 
     @Test
     public void session() throws IOException {
+        BaseRealm.applicationContext = null;
+        Realm.init(InstrumentationRegistry.getTargetContext());
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         SyncConfiguration config = user.createConfiguration(url)
@@ -172,4 +182,167 @@ public void session() throws IOException {
 
         realm.close();
     }
+
+    private void tryCase(Runnable runnable) {
+        try {
+            runnable.run();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void setAuthorizationHeaderName_illegalArgumentsThrows() {
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.setAuthorizationHeaderName(null));
+        tryCase(() -> SyncManager.setAuthorizationHeaderName(""));
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.setAuthorizationHeaderName(null, "myhost"));
+        tryCase(() -> SyncManager.setAuthorizationHeaderName("", "myhost"));
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.setAuthorizationHeaderName("myheader", null));
+        tryCase(() -> SyncManager.setAuthorizationHeaderName("myheader", ""));
+    }
+
+    @Test
+    public void setAuthorizationHeaderName() throws URISyntaxException {
+        SyncManager.setAuthorizationHeaderName("foo");
+        assertEquals("foo", SyncManager.getAuthorizationHeaderName(new URI("http://localhost")));
+    }
+
+    @Test
+    public void setAuthorizationHeaderName_hostOverrideGlobal() throws URISyntaxException {
+        SyncManager.setAuthorizationHeaderName("foo");
+        SyncManager.setAuthorizationHeaderName("bar", "localhost");
+        assertEquals("bar", SyncManager.getAuthorizationHeaderName(new URI("http://localhost")));
+    }
+
+    @Test
+    public void getAuthorizationHeaderName_ignoreHostCasing() throws URISyntaxException {
+        SyncManager.setAuthorizationHeaderName("foo", "lOcAlHoSt");
+        assertEquals("foo", SyncManager.getAuthorizationHeaderName(new URI("http://localhost")));
+        assertEquals("foo", SyncManager.getAuthorizationHeaderName(new URI("http://LOCALHOST")));
+    }
+
+    @Test
+    public void addCustomRequestHeader_illegalArgumentThrows() {
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.addCustomRequestHeader(null, "val"));
+        tryCase(() -> SyncManager.addCustomRequestHeader("", "val"));
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.addCustomRequestHeader("header", null));
+
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.addCustomRequestHeader(null, "val", "localhost"));
+        tryCase(() -> SyncManager.addCustomRequestHeader("", "val", "localhost"));
+        //noinspection ConstantConditions
+        tryCase(() -> SyncManager.addCustomRequestHeader("header", "value", null));
+        tryCase(() -> SyncManager.addCustomRequestHeader("header", "value", ""));
+    }
+
+    @Test
+    public void addCustomRequestHeaders_illegalArgumentThrows() {
+        tryCase(() -> SyncManager.addCustomRequestHeaders(null));
+        tryCase(() -> SyncManager.addCustomRequestHeaders(Collections.emptyMap(), null));
+        tryCase(() -> SyncManager.addCustomRequestHeaders(Collections.emptyMap(), ""));
+    }
+
+    @Test
+    public void addCustomRequestHeader() throws URISyntaxException {
+        SyncManager.addCustomRequestHeader("header1", "val1");
+        SyncManager.addCustomRequestHeader("header2", "val2");
+        Map<String, String> headers = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
+        assertEquals(2, headers.size());
+        Map.Entry<String, String> header = headers.entrySet().iterator().next();
+        assertEquals("header1", header.getKey());
+        assertEquals("val1", header.getValue());
+    }
+
+    @Test
+    public void addCustomRequestHeader_hostOverrideGlobal() throws URISyntaxException {
+        SyncManager.addCustomRequestHeader("header1", "val1");
+        SyncManager.addCustomRequestHeader("header1", "val2", "localhost");
+        Map<String, String> headers = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
+        assertEquals(1, headers.size());
+        Map.Entry<String, String> header = headers.entrySet().iterator().next();
+        assertEquals("header1", header.getKey());
+        assertEquals("val2", header.getValue());
+    }
+
+    @Test
+    public void addCustomRequestHeader_ignoreCasingForHost() throws URISyntaxException {
+        SyncManager.addCustomRequestHeader("header1", "val1", "lOcAlHoSt");
+        SyncManager.addCustomRequestHeader("header2", "val2", "LOCALHOST");
+        Map<String, String> headers = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
+        assertEquals(2, headers.size());
+    }
+
+    @Test
+    public void addCustomHeaders() throws URISyntaxException {
+        Map<String, String> inputHeaders = new LinkedHashMap<>();
+        inputHeaders.put("header1", "value1");
+        inputHeaders.put("header2", "value2");
+        SyncManager.addCustomRequestHeaders(inputHeaders);
+        Map<String, String> outputHeaders = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
+        assertEquals(2, outputHeaders.size());
+        Iterator<Map.Entry<String, String>> it = outputHeaders.entrySet().iterator();
+        Map.Entry<String, String> header1 = it.next();
+        assertEquals("header1", header1.getKey());
+        assertEquals("value1", header1.getValue());
+        Map.Entry<String, String> header2 = it.next();
+        assertEquals("header2", header2.getKey());
+        assertEquals("value2", header2.getValue());
+    }
+
+    @Test
+    public void addCustomHeaders_hostOverrideGlobal() throws URISyntaxException {
+        Map<String, String> inputHeaders = new LinkedHashMap<>();
+        inputHeaders.put("header1", "val1");
+        SyncManager.addCustomRequestHeaders(inputHeaders);
+        inputHeaders.put("header1", "val2");
+        SyncManager.addCustomRequestHeaders(inputHeaders, "localhost");
+        Map<String, String> outputHeaders = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
+        assertEquals(1, outputHeaders.size());
+        Map.Entry<String, String> header = outputHeaders.entrySet().iterator().next();
+        assertEquals("header1", header.getKey());
+        assertEquals("val2", header.getValue());
+    }
+
+    @Test
+    public void addCustomHeader_combinesSingleAndMultiple() throws URISyntaxException {
+        Map<String, String> inputHeaders1 = new LinkedHashMap<>();
+        inputHeaders1.put("header1", "val1");
+        Map<String, String> inputHeaders2 = new LinkedHashMap<>();
+        inputHeaders2.put("header2", "val2");
+
+        SyncManager.addCustomRequestHeader("header3", "val3");
+        SyncManager.addCustomRequestHeaders(inputHeaders1);
+        SyncManager.addCustomRequestHeader("header4", "val4", "realm.io");
+        SyncManager.addCustomRequestHeaders(inputHeaders2, "realm.io");
+
+        Map<String, String> localhostHeaders = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
+        assertEquals(2, localhostHeaders.size());
+        Iterator<Map.Entry<String, String>> it = localhostHeaders.entrySet().iterator();
+        Map.Entry<String, String> item = it.next();
+        assertEquals("header3", item.getKey());
+        assertEquals("val3", item.getValue());
+        item = it.next();
+        assertEquals("header1", item.getKey());
+        assertEquals("val1", item.getValue());
+
+        Map<String, String> realmioHeaders = SyncManager.getCustomRequestHeaders(new URI("http://realm.io"));
+        it = realmioHeaders.entrySet().iterator();
+        assertEquals(4, realmioHeaders.size());
+        item = it.next();
+        assertEquals("header3", item.getKey());
+        assertEquals("val3", item.getValue());
+        item = it.next();
+        assertEquals("header1", item.getKey());
+        assertEquals("val1", item.getValue());
+        item = it.next();
+        assertEquals("header4", item.getKey());
+        assertEquals("val4", item.getValue());
+        item = it.next();
+        assertEquals("header2", item.getKey());
+        assertEquals("val2", item.getValue());
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 136470a0bc..8388761106 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -53,11 +53,10 @@
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.util.SyncTestUtils;
 
-import static io.realm.util.SyncTestUtils.createNamedTestUser;
-import static io.realm.util.SyncTestUtils.createTestAdminUser;
-import static io.realm.util.SyncTestUtils.createTestUser;
+import static io.realm.SyncTestUtils.createNamedTestUser;
+import static io.realm.SyncTestUtils.createTestAdminUser;
+import static io.realm.SyncTestUtils.createTestUser;
 import static junit.framework.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
@@ -94,15 +93,10 @@
     @Rule
     public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
 
-    @BeforeClass
-    public static void initUserStore() {
-        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        UserStore userStore = new RealmFileUserStore();
-        SyncManager.setUserStore(userStore);
-    }
-
     @Before
     public void setUp() {
+        BaseRealm.applicationContext = null;
+        Realm.init(InstrumentationRegistry.getTargetContext());
         UserStore userStore = SyncManager.getUserStore();
         for (SyncUser syncUser : userStore.allUsers()) {
             userStore.remove(syncUser.getIdentity(), syncUser.getAuthenticationUrl().toString());
@@ -174,7 +168,7 @@ public void toAndFromJson() {
     public void currentUser_returnsNullIfUserExpired() {
         // Add an expired user to the user store
         UserStore userStore = SyncManager.getUserStore();
-        userStore.put(SyncTestUtils.createTestUser(Long.MIN_VALUE));
+        userStore.put(createTestUser(Long.MIN_VALUE));
 
         // Invalid users should not be returned when asking the for the current user
         assertNull(SyncUser.current());
@@ -219,7 +213,7 @@ private AuthenticateResponse getNewRandomUser() {
     @Test
     public void currentUser_clearedOnLogout() {
         // Add 1 valid user to the user store
-        SyncUser user = SyncTestUtils.createTestUser(Long.MAX_VALUE);
+        SyncUser user = createTestUser(Long.MAX_VALUE);
         UserStore userStore = SyncManager.getUserStore();
         userStore.put(user);
 
@@ -242,8 +236,8 @@ public void all_empty() {
     public void all_validUsers() {
         // Add 1 expired user and 1 valid user to the user store
         UserStore userStore = SyncManager.getUserStore();
-        userStore.put(SyncTestUtils.createTestUser(Long.MIN_VALUE));
-        userStore.put(SyncTestUtils.createTestUser(Long.MAX_VALUE));
+        userStore.put(createTestUser(Long.MIN_VALUE));
+        userStore.put(createTestUser(Long.MAX_VALUE));
 
         Map<String, SyncUser> users = SyncUser.all();
         assertEquals(1, users.size());
@@ -262,7 +256,7 @@ public void isAdmin() {
     @Test
     public void isAdmin_allUsers() {
         UserStore userStore = SyncManager.getUserStore();
-        SyncUser user = SyncTestUtils.createTestAdminUser();
+        SyncUser user = createTestAdminUser();
         assertTrue(user.isAdmin());
         userStore.put(user);
 
@@ -284,7 +278,7 @@ public void currentUser_returnsUserAfterLogin() {
 
     @Test
     public void toString_returnDescription() {
-        SyncUser user = SyncTestUtils.createTestUser("http://objectserver.realm.io/auth");
+        SyncUser user = createTestUser("http://objectserver.realm.io/auth");
         String str = user.toString();
         assertTrue(str != null && !str.isEmpty());
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index af07ef5986..138d4a239d 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -35,13 +35,12 @@
 import io.realm.entities.IndexedFields;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.exceptions.IncompatibleSyncedFileException;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.OsRealmConfig;
 import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.OsSharedRealm;
-import io.realm.exceptions.IncompatibleSyncedFileException;
 import io.realm.objectserver.utils.StringOnlyModule;
-import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
index 0494a395ae..d1f1f9e5a7 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
@@ -28,12 +28,10 @@
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
-import io.realm.internal.util.Pair;
 import io.realm.objectserver.model.PartialSyncObjectA;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 140e8e5f1d..89849efc4f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -330,3 +330,34 @@ JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeRemoveConnectionListener(
     }
     CATCH_STD()
 }
+
+JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeStart(JNIEnv* env, jclass, jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+        if (!session) {
+            // FIXME: We should lift this restriction
+            ThrowException(env, IllegalState,
+            "Cannot call start() before a session is "
+            "created. A session will be created after the first call to Realm.getInstance().");
+            return;
+        }
+        session->revive_if_needed();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeStop(JNIEnv* env, jclass, jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+        if (session) {
+            session->log_out();
+        }
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index cdd27c396a..78c3e4d2dc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -250,7 +250,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeEnableChangeNo
 #if REALM_ENABLE_SYNC
 JNIEXPORT jstring JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSyncConfig(
     JNIEnv* env, jclass, jlong native_ptr, jstring j_sync_realm_url, jstring j_auth_url, jstring j_user_id,
-    jstring j_refresh_token, jboolean j_is_partial, jbyte j_session_stop_policy)
+    jstring j_refresh_token, jboolean j_is_partial, jbyte j_session_stop_policy, jstring j_url_prefix,
+    jstring j_custom_auth_header_name, jobjectArray j_custom_headers_array)
 {
     TR_ENTER_PTR(native_ptr)
     auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
@@ -323,8 +324,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSe
             user = SyncManager::shared().get_user(sync_user_identifier, refresh_token);
         }
 
-
-
         SyncSessionStopPolicy session_stop_policy = static_cast<SyncSessionStopPolicy>(j_session_stop_policy);
 
         JStringAccessor realm_url(env, j_sync_realm_url);
@@ -333,13 +332,32 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSe
         config.sync_config->bind_session_handler = std::move(bind_handler);
         config.sync_config->error_handler = std::move(error_handler);
         config.sync_config->is_partial = (j_is_partial == JNI_TRUE);
+
+        if (j_url_prefix) {
+            JStringAccessor url_prefix(env, j_url_prefix);
+            config.sync_config->url_prefix = realm::util::Optional<std::string>(url_prefix);
+        }
+
+        if (j_custom_auth_header_name) {
+            JStringAccessor custom_auth_header_name(env, j_custom_auth_header_name);
+            config.sync_config->authorization_header_name = realm::util::Optional<std::string>(custom_auth_header_name);
+        }
+
+        if (j_custom_headers_array) {
+            jsize count = env->GetArrayLength(j_custom_headers_array);
+            for (int i = 0; i < count; i = i + 2) {
+                JStringAccessor key(env, (jstring) env->GetObjectArrayElement(j_custom_headers_array, i));
+                JStringAccessor value(env, (jstring) env->GetObjectArrayElement(j_custom_headers_array, i + 1));
+                config.sync_config->custom_http_headers[std::string(key)] = std::string(value);
+            }
+        }
+
         if (!config.encryption_key.empty()) {
             config.sync_config->realm_encryption_key = std::array<char, 64>();
             std::copy_n(config.encryption_key.begin(), 64, config.sync_config->realm_encryption_key->begin());
         }
 
         return to_jstring(env, config.sync_config->realm_url().c_str());
-
     }
     CATCH_STD()
     return nullptr;
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 97fd03819f..b0fc2814d9 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 97fd03819f398b3c81c8b007feaca8636629050b
+Subproject commit b0fc2814d9e6061ce5ba1da887aab6cfba4755ca
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index d6f25dbc53..f1d21efeaf 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -66,10 +66,8 @@
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
-import io.realm.internal.UncheckedRow;
 import io.realm.internal.Util;
 import io.realm.internal.annotations.ObjectServer;
 import io.realm.internal.async.RealmAsyncTaskImpl;
@@ -77,7 +75,6 @@
 import io.realm.sync.permissions.ClassPermissions;
 import io.realm.sync.permissions.ClassPrivileges;
 import io.realm.sync.permissions.RealmPermissions;
-import io.realm.sync.permissions.RealmPrivileges;
 import io.realm.sync.permissions.Role;
 
 /**
@@ -1057,8 +1054,13 @@ private Scanner getFullStringScanner(InputStream in) {
         if (objects == null) {
             return new ArrayList<>();
         }
+        ArrayList realmObjects;
+        if (objects instanceof Collection) {
+            realmObjects = new ArrayList<>(((Collection) objects).size());
+        } else {
+            realmObjects = new ArrayList<>();
+        }
         Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
-        ArrayList<E> realmObjects = new ArrayList<>();
         for (E object : objects) {
             checkNotNullObject(object);
             realmObjects.add(copyOrUpdate(object, false, cache));
@@ -1228,8 +1230,13 @@ public void insertOrUpdate(RealmModel object) {
             return new ArrayList<>(0);
         }
 
+        ArrayList realmObjects;
+        if (objects instanceof Collection) {
+            realmObjects = new ArrayList<>(((Collection) objects).size());
+        } else {
+            realmObjects = new ArrayList<>();
+        }
         Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
-        ArrayList<E> realmObjects = new ArrayList<>();
         for (E object : objects) {
             checkNotNullObject(object);
             realmObjects.add(copyOrUpdate(object, true, cache));
@@ -1287,7 +1294,12 @@ public void insertOrUpdate(RealmModel object) {
             return new ArrayList<>(0);
         }
 
-        ArrayList<E> unmanagedObjects = new ArrayList<>();
+        ArrayList unmanagedObjects;
+        if (realmObjects instanceof Collection) {
+            unmanagedObjects = new ArrayList<>(((Collection) realmObjects).size());
+        } else {
+            unmanagedObjects = new ArrayList<>();
+        }
         Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index df194d2f83..c4982b0d82 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -66,8 +66,8 @@ public void init(Context context) {
     public void realmClosed(RealmConfiguration configuration) {
     }
 
-    public Object[] getUserAndServerUrl(RealmConfiguration config) {
-        return new Object[8];
+    public Object[] getSyncConfigurationOptions(RealmConfiguration config) {
+        return new Object[11];
     }
 
     public static ObjectServerFacade getFacade(boolean needSyncFacade) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index 8b731071c6..3240ddd7e8 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -18,6 +18,7 @@
 
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.Map;
 
 import javax.annotation.Nullable;
 
@@ -189,7 +190,7 @@ private OsRealmConfig(final RealmConfiguration config,
         NativeContext.dummyContext.addReference(this);
 
         // Retrieve Sync settings first. We need syncRealmUrl to identify if this is a SyncConfig
-        Object[] syncConfigurationOptions = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(realmConfiguration);
+        Object[] syncConfigurationOptions = ObjectServerFacade.getSyncFacadeIfPossible().getSyncConfigurationOptions(realmConfiguration);
         String syncUserIdentifier = (String) syncConfigurationOptions[0];
         String syncRealmUrl = (String) syncConfigurationOptions[1];
         String syncRealmAuthUrl = (String) syncConfigurationOptions[2];
@@ -198,6 +199,22 @@ private OsRealmConfig(final RealmConfiguration config,
         String syncSslTrustCertificatePath = (String) syncConfigurationOptions[5];
         Byte sessionStopPolicy = (Byte) syncConfigurationOptions[6];
         boolean isPartial = (Boolean.TRUE.equals(syncConfigurationOptions[7]));
+        String urlPrefix = (String)(syncConfigurationOptions[8]);
+        String customAuthorizationHeaderName = (String)(syncConfigurationOptions[9]);
+
+        // Convert the headers into a String array to make it easier to send through JNI
+        // [key1, value1, key2, value2, ...]
+        //noinspection unchecked
+        Map<String, String> customHeadersMap = (Map<String, String>) (syncConfigurationOptions[10]);
+        String[] customHeaders = new String[customHeadersMap != null ? customHeadersMap.size() * 2 : 0];
+        if (customHeadersMap != null) {
+            int i = 0;
+            for (Map.Entry<String, String> entry : customHeadersMap.entrySet()) {
+                customHeaders[i] = entry.getKey();
+                customHeaders[i + 1] = entry.getValue();
+                i = i + 2;
+            }
+        }
 
         // Set encryption key
         byte[] key = config.getEncryptionKey();
@@ -242,8 +259,17 @@ private OsRealmConfig(final RealmConfiguration config,
         URI resolvedRealmURI  = null;
         // Set sync config
         if (syncRealmUrl != null) {
-            String resolvedSyncRealmUrl = nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
-                    syncRefreshToken, isPartial, sessionStopPolicy);
+            String resolvedSyncRealmUrl = nativeCreateAndSetSyncConfig(
+                    nativePtr,
+                    syncRealmUrl,
+                    syncRealmAuthUrl,
+                    syncUserIdentifier,
+                    syncRefreshToken,
+                    isPartial,
+                    sessionStopPolicy,
+                    urlPrefix,
+                    customAuthorizationHeaderName,
+                    customHeaders);
             try {
                 resolvedRealmURI = new URI(resolvedSyncRealmUrl);
             } catch (URISyntaxException e) {
@@ -292,8 +318,11 @@ private native void nativeSetSchemaConfig(long nativePtr, byte schemaMode, long
 
     private static native void nativeEnableChangeNotification(long nativePtr, boolean enableNotification);
 
-    private static native String nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl,
-                                                            String authUrl, String userId, String refreshToken, boolean isPartial, byte sessionStopPolicy);
+    private static native String nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl, String authUrl,
+                                                              String userId, String refreshToken, boolean isPartial,
+                                                              byte sessionStopPolicy, String urlPrefix,
+                                                              String customAuthorizationHeaderName,
+                                                              String[] customHeaders);
 
     private static native void nativeSetSyncConfigSslSettings(long nativePtr,
                                                               boolean validateSsl, String trustCertificatePath);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java b/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
index 608f91f601..adbc7b4804 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
@@ -24,6 +24,7 @@
 import io.realm.internal.ObserverPairList;
 import io.realm.internal.OsResults;
 
+@KeepMember
 public class OsSubscription implements NativeObject {
 
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 876c10cac7..a2ccd4363f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -27,7 +27,9 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.Locale;
+import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -106,46 +108,38 @@
     private final SyncSession.ErrorHandler errorHandler;
     private final boolean deleteRealmOnLogout;
     private final boolean syncClientValidateSsl;
-    @Nullable
-    private final String serverCertificateAssetName;
-    @Nullable
-    private final String serverCertificateFilePath;
+    @Nullable private final String serverCertificateAssetName;
+    @Nullable private final String serverCertificateFilePath;
     private final boolean waitForInitialData;
     private final OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy;
     private final boolean isPartial;
+    @Nullable private final String syncUrlPrefix;
 
     private SyncConfiguration(File directory,
-                                String filename,
-                                String canonicalPath,
-                                @Nullable
-                                String assetFilePath,
-                                @Nullable
-                                byte[] key,
-                                long schemaVersion,
-                                @Nullable
-                                RealmMigration migration,
-                                boolean deleteRealmIfMigrationNeeded,
-                                OsRealmConfig.Durability durability,
-                                RealmProxyMediator schemaMediator,
-                                @Nullable
-                                RxObservableFactory rxFactory,
-                                @Nullable
-                                Realm.Transaction initialDataTransaction,
-                                boolean readOnly,
-                                SyncUser user,
-                                URI serverUrl,
-                                SyncSession.ErrorHandler errorHandler,
-                                boolean deleteRealmOnLogout,
-                                boolean syncClientValidateSsl,
-                                @Nullable
-                                String serverCertificateAssetName,
-                                @Nullable
-                                String serverCertificateFilePath,
-                                boolean waitForInitialData,
-                                OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy,
-                                boolean isPartial,
-                                CompactOnLaunchCallback compactOnLaunch
-    ) {
+                              String filename,
+                              String canonicalPath,
+                              @Nullable String assetFilePath,
+                              @Nullable byte[] key,
+                              long schemaVersion,
+                              @Nullable RealmMigration migration,
+                              boolean deleteRealmIfMigrationNeeded,
+                              OsRealmConfig.Durability durability,
+                              RealmProxyMediator schemaMediator,
+                              @Nullable RxObservableFactory rxFactory,
+                              @Nullable Realm.Transaction initialDataTransaction,
+                              boolean readOnly,
+                              SyncUser user,
+                              URI serverUrl,
+                              SyncSession.ErrorHandler errorHandler,
+                              boolean deleteRealmOnLogout,
+                              boolean syncClientValidateSsl,
+                              @Nullable String serverCertificateAssetName,
+                              @Nullable String serverCertificateFilePath,
+                              boolean waitForInitialData,
+                              OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy,
+                              boolean isPartial,
+                              CompactOnLaunchCallback compactOnLaunch,
+                              @Nullable String syncUrlPrefix) {
         super(directory,
                 filename,
                 canonicalPath,
@@ -173,6 +167,7 @@ private SyncConfiguration(File directory,
         this.waitForInitialData = waitForInitialData;
         this.sessionStopPolicy = sessionStopPolicy;
         this.isPartial = isPartial;
+        this.syncUrlPrefix = syncUrlPrefix;
     }
 
     /**
@@ -452,6 +447,14 @@ public boolean isFullySynchronizedRealm() {
         return !isPartial;
     }
 
+    /**
+     * Returns the url prefix used when establishing a sync connection to the Realm Object Server.
+     */
+    @Nullable
+    public String getUrlPrefix() {
+        return syncUrlPrefix;
+    }
+
     /**
      * Builder used to construct instances of a SyncConfiguration in a fluent manner.
      */
@@ -489,6 +492,7 @@ public boolean isFullySynchronizedRealm() {
         private OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy = OsRealmConfig.SyncSessionStopPolicy.AFTER_CHANGES_UPLOADED;
         private boolean isPartial = true; // Partial Synchronization is enabled by default
         private CompactOnLaunchCallback compactOnLaunch;
+        private String syncUrlPrefix = null;
 
         /**
          * Creates an instance of the Builder for the SyncConfiguration. This SyncConfiguration
@@ -1006,6 +1010,23 @@ public Builder waitForInitialRemoteData() {
             return this;
         }
 
+        /**
+         * The prefix that is prepended to the path in the HTTP request that initiates a sync
+         * connection to the Realm Object Server. The value specified must match the server’s
+         * configuration otherwise the device will not be able to create a connection. If no value
+         * is specified then the default {@code /realm-sync} path is used.
+         *
+         * @param urlPrefix The prefix to append to the sync connection url.
+         * @see <a href="https://docs.realm.io/platform/guides/learn-realm-sync-and-integrate-with-a-proxy#adding-a-custom-proxy">Adding a custom proxy</a>
+         */
+        public SyncConfiguration.Builder urlPrefix(String urlPrefix) {
+            if (Util.isEmptyString(urlPrefix)) {
+                throw new IllegalArgumentException("Non-empty 'urlPrefix' required");
+            }
+            this.syncUrlPrefix = urlPrefix;
+            return this;
+        }
+
         private String MD5(String in) {
             try {
                 MessageDigest digest = MessageDigest.getInstance("MD5");
@@ -1158,7 +1179,8 @@ public SyncConfiguration build() {
                     waitForServerChanges,
                     sessionStopPolicy,
                     isPartial,
-                    compactOnLaunch
+                    compactOnLaunch,
+                    syncUrlPrefix
             );
         }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index ce556daad1..93ac40bbfb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -28,6 +28,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -130,6 +131,12 @@ public void onError(SyncSession session, ObjectServerError error) {
     private static volatile AuthenticationServer authServer = new OkHttpAuthenticationServer();
     private static volatile UserStore userStore;
 
+    // Header configuration
+    private static String globalAuthorizationHeaderName = "Authorization"; // authorization header name if no host-defined header is available
+    private static Map<String, String> hostRestrictedAuthorizationHeaderName = new HashMap<>(); // authorization header name for the given host
+    private static Map<String, String> globalCustomHeaders = new HashMap<>();
+    private static Map<String, Map<String, String>> hostRestrictedCustomHeaders = new HashMap<>();
+
     private static NetworkStateReceiver.ConnectionListener networkListener = new NetworkStateReceiver.ConnectionListener() {
         @Override
         public void onChange(boolean connectionAvailable) {
@@ -276,6 +283,148 @@ public static synchronized SyncSession getOrCreateSession(SyncConfiguration sync
         return session;
     }
 
+    /**
+     * Sets the name of the HTTP header used to send authorization data in when making requests to
+     * all Realm Object Servers used by the app. These servers must have been configured to expect a
+     * custom authorization header.
+     * <p>
+     * The default authorization header is named "Authorization".
+     *
+     * @param headerName name of the header.
+     * @throws IllegalArgumentException if a null or empty header is provided.
+     * @see <a href="https://docs.realm.io/platform/guides/learn-realm-sync-and-integrate-with-a-proxy#adding-a-custom-proxy">Adding a custom proxy</a>
+     */
+    public static synchronized void setAuthorizationHeaderName(String headerName) {
+        checkNotEmpty(headerName, "headerName");
+        authServer.setAuthorizationHeaderName(headerName, null);
+        globalAuthorizationHeaderName = headerName;
+    }
+
+    /**
+     * Sets the name of the HTTP header used to send authorization data in when making requests to
+     * the Realm Object Server running on the defined {@code host}. This server must have been
+     * configured to expect a custom authorization header.
+     * <p>
+     * The default authorization header is named "Authorization".
+     *
+     * @param headerName name of the header.
+     * @param host if this is provided, the authorization header name will only be used on this particular host.
+     *             Example of valid values: "localhost", "127.0.0.1" and "myinstance.us1.cloud.realm.io".
+     * @throws IllegalArgumentException if a {@code null} or empty header and/or host is provided.
+     * @see <a href="https://docs.realm.io/platform/guides/learn-realm-sync-and-integrate-with-a-proxy#adding-a-custom-proxy">Adding a custom proxy</a>
+     */
+
+    public static synchronized void setAuthorizationHeaderName(String headerName, String host) {
+        checkNotEmpty(headerName, "headerName");
+        checkNotEmpty(host, "host");
+        host = host.toLowerCase(Locale.US);
+        authServer.setAuthorizationHeaderName(headerName, host);
+        hostRestrictedAuthorizationHeaderName.put(host, headerName);
+    }
+
+    /**
+     * Adds an extra HTTP header to append to every request to a Realm Object Server.
+     *
+     * @param headerName the name of the header.
+     * @param headerValue the value of header.
+     * @throws IllegalArgumentException if a non-empty {@code headerName} is provided or a null {@code headerValue}.
+     */
+    public static synchronized void addCustomRequestHeader(String headerName, String headerValue) {
+        checkNotEmpty(headerName, "headerName");
+        checkNotNull(headerValue, "headerValue");
+        authServer.addHeader(headerName, headerValue, null);
+        globalCustomHeaders.put(headerName, headerValue);
+    }
+
+    /**
+     * Adds an extra HTTP header to append to every request to a Realm Object Server.
+     *
+     * @param headerName the name of the header.
+     * @param headerValue the value of header.
+     * @param host if this is provided, the this header will only be used on this particular host.
+     *             Example of valid values: "localhost", "127.0.0.1" and "myinstance.us1.cloud.realm.io".
+     * @throws IllegalArgumentException If an non-empty {@code headerName}, {@code headerValue} or {@code host} is provided.
+     */
+    public static synchronized void addCustomRequestHeader(String headerName, String headerValue, String host) {
+        checkNotEmpty(headerName, "headerName");
+        checkNotNull(headerValue, "headerValue");
+        checkNotEmpty(host, "host");
+
+        // Headers
+        host = host.toLowerCase(Locale.US);
+        authServer.addHeader(headerName, headerValue, host);
+        Map<String, String> headers = hostRestrictedCustomHeaders.get(host);
+        if (headers == null) {
+            headers = new LinkedHashMap<>();
+            hostRestrictedCustomHeaders.put(host, headers);
+        }
+        headers.put(headerName, headerValue);
+    }
+
+    /**
+     * Adds extra HTTP headers to append to every request to a Realm Object Server.
+     *
+     * @param headers map of (headerName, headerValue) pairs.
+     * @throws IllegalArgumentException If any of the headers provided are illegal.
+     */
+    public static synchronized void addCustomRequestHeaders(@Nullable Map<String, String> headers) {
+        if (headers != null) {
+            for (Map.Entry<String, String> entry : headers.entrySet()) {
+                addCustomRequestHeader(entry.getKey(), entry.getValue());
+            }
+        }
+    }
+
+    /**
+     * Adds extra HTTP headers to append to every request to a Realm Object Server.
+     *
+     * @param headers map of (headerName, headerValue) pairs.
+     * @param host if this is provided, the this header will only be used on this particular host.
+     *             Example of valid values: "localhost", "127.0.0.1" and "myinstance.us1.cloud.realm.io".
+     * @throws IllegalArgumentException If any of the headers provided are illegal.
+     */
+    public static synchronized void addCustomRequestHeaders(@Nullable Map<String, String> headers, String host) {
+        if (Util.isEmptyString(host)) {
+            throw new IllegalArgumentException("Non-empty 'host' required");
+        }
+        host = host.toLowerCase(Locale.US);
+        if (headers != null) {
+            for (Map.Entry<String, String> entry : headers.entrySet()) {
+                addCustomRequestHeader(entry.getKey(), entry.getValue(), host);
+            }
+        }
+    }
+
+    /**
+     * Returns the authentication header name used for the http request to the given url.
+     *
+     * @param objectServerUrl Url to get header for.
+     * @return the authorization header name used by http requests to this url.
+     */
+    public static synchronized String getAuthorizationHeaderName(URI objectServerUrl) {
+        String host = objectServerUrl.getHost().toLowerCase(Locale.US);
+        String hostRestrictedHeader = hostRestrictedAuthorizationHeaderName.get(host);
+        return (hostRestrictedHeader != null) ? hostRestrictedHeader : globalAuthorizationHeaderName;
+    }
+
+    /**
+     * Returns all the custom headers added to requests to the given url.
+     *
+     * @return all defined custom headers used when making http requests to the given url.
+     * f
+     */
+    public static synchronized Map<String, String> getCustomRequestHeaders(URI serverSyncUrl) {
+        Map<String, String> headers = new LinkedHashMap<>(globalCustomHeaders);
+        String host = serverSyncUrl.getHost().toLowerCase(Locale.US);
+        Map<String, String> hostHeaders = hostRestrictedCustomHeaders.get(host);
+        if (hostHeaders != null) {
+            for (Map.Entry<String, String> entry : hostHeaders.entrySet()) {
+                headers.put(entry.getKey(), entry.getValue());
+            }
+        }
+        return headers;
+    }
+
     /**
      * Remove the wrapped Java session.
      * @param syncConfiguration configuration object for the synchronized Realm.
@@ -303,6 +452,7 @@ private static synchronized void removeSession(SyncConfiguration syncConfigurati
      * @return the all valid sessions belonging to the user.
      */
     static List<SyncSession> getAllSessions(SyncUser syncUser) {
+        //noinspection ConstantConditions
         if (syncUser == null) {
             throw new IllegalArgumentException("A non-empty 'syncUser' is required.");
         }
@@ -553,6 +703,18 @@ private static X509Certificate buildCertificateFromPEM(String pem) throws IOExce
         }
     }
 
+    private static void checkNotEmpty(String headerName, String varName) {
+        if (Util.isEmptyString(headerName)) {
+            throw new IllegalArgumentException("Non-empty '" + varName +"' required.");
+        }
+    }
+
+    private static void checkNotNull(@Nullable String val, String varName) {
+        if (val == null) {
+            throw new IllegalArgumentException("Non-null'" + varName +"' required.");
+        }
+    }
+
     /**
      * Resets the SyncManger and clear all existing users.
      * This will also terminate all sessions.
@@ -562,6 +724,11 @@ private static X509Certificate buildCertificateFromPEM(String pem) throws IOExce
     static synchronized void reset() {
         nativeReset();
         sessions.clear();
+        hostRestrictedAuthorizationHeaderName.clear();
+        globalAuthorizationHeaderName = "Authorization";
+        hostRestrictedCustomHeaders.clear();
+        globalCustomHeaders.clear();
+        authServer.clearCustomHeaderSettings();
     }
 
     /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index f099649332..08cfd937e2 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -510,6 +510,37 @@ public void uploadAllLocalChanges() throws InterruptedException {
         }
     }
 
+    /**
+     * Attempts to start the session and enable synchronization with the Realm Object Server.
+     * <p>
+     * This happens automatically when opening the Realm instance, so doing it manually should only
+     * be needed if the session was stopped using {@link #stop()}.
+     * <p>
+     * If the session was already started, calling this method will do nothing.
+     * <p>
+     * A session is considered started if {@link #getState()} returns either {@link State#ACTIVE} or
+     * {@link State#WAITING_FOR_ACCESS_TOKEN}. If the session is {@link State#DYING}, the session
+     * will be moved back to {@link State#ACTIVE}.
+     *
+     * @see #getState()
+     * @see #stop()
+     */
+    public synchronized void start() {
+        nativeStart(configuration.getPath());
+    }
+
+    /**
+     * Stops any synchronization with the Realm Object Server until the Realm is re-opened again
+     * after fully closing it.
+     * <p>
+     * Synchronization can be re-enabled by calling {@link #start()} again.
+     * <p>
+     * If the session is already stopped, calling this method will do nothing.
+     */
+    public synchronized void stop() {
+        nativeStop(configuration.getPath());
+    }
+
     void setResolvedRealmURI(URI resolvedRealmURI) {
         this.resolvedRealmURI = resolvedRealmURI;
     }
@@ -859,4 +890,6 @@ public void throwExceptionIfNeeded() {
     private native boolean nativeWaitForUploadCompletion(int callbackId, String localRealmPath);
     private static native byte nativeGetState(String localRealmPath);
     private static native byte nativeGetConnectionState(String localRealmPath);
+    private static native void nativeStart(String localRealmPath);
+    private static native void nativeStop(String localRealmPath);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index fc34b1df5d..c1c05f31c9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -23,6 +23,7 @@
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.Map;
 
 import io.realm.RealmConfiguration;
 import io.realm.SyncConfiguration;
@@ -85,7 +86,7 @@ public void realmClosed(RealmConfiguration configuration) {
     }
 
     @Override
-    public Object[] getUserAndServerUrl(RealmConfiguration config) {
+    public Object[] getSyncConfigurationOptions(RealmConfiguration config) {
         if (config instanceof SyncConfiguration) {
             SyncConfiguration syncConfig = (SyncConfiguration) config;
             SyncUser user = syncConfig.getUser();
@@ -94,9 +95,24 @@ public void realmClosed(RealmConfiguration configuration) {
             String syncRealmAuthUrl = user.getAuthenticationUrl().toString();
             String rosSerializedUser = user.toJson();
             byte sessionStopPolicy = syncConfig.getSessionStopPolicy().getNativeValue();
-            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath(), sessionStopPolicy, !syncConfig.isFullySynchronizedRealm()};
+            String urlPrefix = syncConfig.getUrlPrefix();
+            String customAuthorizationHeaderName = SyncManager.getAuthorizationHeaderName(syncConfig.getServerUrl());
+            Map<String, String> customHeaders = SyncManager.getCustomRequestHeaders(syncConfig.getServerUrl());
+            return new Object[]{
+                    rosUserIdentity,
+                    rosServerUrl,
+                    syncRealmAuthUrl,
+                    rosSerializedUser,
+                    syncConfig.syncClientValidateSsl(),
+                    syncConfig.getServerCertificateFilePath(),
+                    sessionStopPolicy,
+                    !syncConfig.isFullySynchronizedRealm(),
+                    urlPrefix,
+                    customAuthorizationHeaderName,
+                    customHeaders
+            };
         } else {
-            return new Object[8];
+            return new Object[11];
         }
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 1e33ab0d0f..7c608791dd 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -19,6 +19,8 @@
 import java.net.URI;
 import java.net.URL;
 
+import javax.annotation.Nullable;
+
 import io.realm.SyncCredentials;
 import io.realm.SyncUser;
 import io.realm.internal.objectserver.Token;
@@ -30,6 +32,24 @@
  * only responsible for executing a given network request.
  */
 public interface AuthenticationServer {
+
+    /**
+     * Overrides the default header name used to send Realm Object Server credentials.
+     * The Realm Object Server must be setup to handle this specifically.
+     */
+    void setAuthorizationHeaderName(String headerName, @Nullable String host);
+
+    /**
+     * Add a custom header that should be applied to all HTTP requests made by the authentication
+     * server.
+     */
+    void addHeader(String headerName, String headerValue, @Nullable String host);
+
+    /**
+     * Clear any custom header settings (Authorization and others).
+     */
+    void clearCustomHeaderSettings();
+
     /**
      * Login a User on the Object Server. This will create a "UserToken" (Currently called RefreshToken) that acts as
      * the users credentials.
@@ -93,4 +113,5 @@
      * Complete an email confirmation by sending the token contained in the email.
      */
     UpdateAccountResponse confirmEmail(String confirmationToken, URL authenticationUrl);
+
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 0b3fc3ab44..3f51da45cc 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -16,22 +16,34 @@
 
 package io.realm.internal.network;
 
+import android.util.Log;
+
+import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
+import javax.annotation.Nullable;
+
 import io.realm.SyncCredentials;
 import io.realm.internal.Util;
 import io.realm.internal.objectserver.Token;
+import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
+import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okio.Buffer;
 
 public class OkHttpAuthenticationServer implements AuthenticationServer {
 
@@ -40,17 +52,82 @@
     private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
     private static final String ACTION_LOOKUP_USER_ID = "users/:provider:/:providerId:"; // Auth end point for looking up user id
     private static final String ACTION_UPDATE_ACCOUNT = "password/updateAccount"; // Password reset and email confirmation
+    private static final Charset UTF8 = Charset.forName("UTF-8");
 
     private final OkHttpClient client = new OkHttpClient.Builder()
             .connectTimeout(15, TimeUnit.SECONDS)
             .writeTimeout(15, TimeUnit.SECONDS)
             .readTimeout(30, TimeUnit.SECONDS)
+            .addInterceptor(new Interceptor() {
+                @Override
+                public Response intercept(Chain chain) throws IOException {
+                    Request request = chain.request();
+                    if (RealmLog.getLevel() <= LogLevel.TRACE) {
+                        StringBuilder sb = new StringBuilder(request.method());
+                        sb.append(' ');
+                        sb.append(request.url());
+                        sb.append('\n');
+                        sb.append(request.headers());
+                        if (request.body() != null) {
+                            // Stripped down version of https://github.com/square/okhttp/blob/master/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+                            // We only expect request context to be JSON.
+                            Buffer buffer = new Buffer();
+                            request.body().writeTo(buffer);
+                            sb.append(buffer.readString(UTF8));
+                        }
+                        RealmLog.trace("HTTP Request = \n%s", sb);
+                    }
+                    return chain.proceed(request);
+                }
+            })
             // using custom Connection Pool to evict idle connection after 5 seconds rather than 5 minutes (which is the default)
             // keeping idle connection on the pool will prevent the ROS to be stopped, since the HttpUtils#stopSyncServer query
             // will not return before the tests timeout (ex 10 seconds for AuthTests)
             .connectionPool(new ConnectionPool(5, 5, TimeUnit.SECONDS))
             .build();
 
+    private Map<String, Map<String, String>> customHeaders = new LinkedHashMap<>();
+    private Map<String, String> customAuthorizationHeaders = new HashMap<>();
+
+    public OkHttpAuthenticationServer() {
+        initHeaders();
+    }
+
+    private void initHeaders() {
+        customAuthorizationHeaders.put("", "Authorization"); // Default value for authorization header
+        customHeaders.put("", new LinkedHashMap<>()); // Add holder for headers used across all hosts
+    }
+
+    @Override
+    public void setAuthorizationHeaderName(String headerName, @Nullable String host) {
+        if (Util.isEmptyString(host)) {
+            customAuthorizationHeaders.put("", headerName);
+        } else {
+            customAuthorizationHeaders.put(host, headerName);
+        }
+    }
+
+    @Override
+    public void addHeader(String headerName, String headerValue, @Nullable String host) {
+        if (Util.isEmptyString(host)) {
+            customHeaders.get("").put(headerName, headerValue);
+        } else {
+            Map<String, String> headers = customHeaders.get(host);
+            if (headers == null) {
+                headers = new LinkedHashMap<>();
+                customHeaders.put(host, headers);
+            }
+            headers.put(headerName, headerValue);
+        }
+    }
+
+    @Override
+    public void clearCustomHeaderSettings() {
+        customAuthorizationHeaders.clear();
+        customHeaders.clear();
+        initHeaders();
+    }
+
     /**
      * Authenticate the given credentials on the specified Realm Authentication Server.
      */
@@ -237,9 +314,28 @@ private UpdateAccountResponse updateAccount(URL updateAccountUrl, String request
                 .addHeader("Content-Type", "application/json")
                 .addHeader("Accept", "application/json");
 
+        // Add custom headers used by all hosts
+        for (Map.Entry<String, String> entry : customHeaders.get("").entrySet()) {
+            builder.addHeader(entry.getKey(), entry.getValue());
+        }
+
+        // add custom headers used by specific host (may override g
+        Map<String, String> customHeaders = this.customHeaders.get(url.getHost());
+        if (customHeaders != null) {
+            for (Map.Entry<String, String> entry : customHeaders.entrySet()) {
+                builder.addHeader(entry.getKey(), entry.getValue());
+            }
+        }
+
         // Only add Authorization header for those API's that require it.
+        // Use the defined custom authorization name if one is available for this host.
         if (!Util.isEmptyString(authToken)) {
-            builder.addHeader("Authorization", authToken);
+            String headerName = customAuthorizationHeaders.get(url.getHost());
+            if (headerName != null) {
+                builder.addHeader(headerName, authToken);
+            } else {
+                builder.addHeader(customAuthorizationHeaders.get(""), authToken);
+            }
         }
 
         return builder;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
index 90c95223cd..78954747f7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -56,29 +56,6 @@
 
     protected ConfigurationWrapper configurationFactory = new ConfigurationWrapper(looperThread);
 
-    static {
-        // Attempt to combat issues with the sync meta data Realm not being correctly cleaned
-    }
-
-    protected void prepareEnvironmentForTest() throws IOException {
-        deleteRosFiles();
-        if (BaseRealm.applicationContext != null) {
-            // Realm was already initialized. Reset all internal state
-            // in order to be able fully re-initialize.
-
-            // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
-            // causing the SyncUser to remain in memory.
-            // They're actually not persisted into disk.
-            // move this call to 'tearDown' to clean in-memory & on-disk users
-            // once https://github.com/realm/realm-object-store/issues/207 is resolved
-            SyncManager.reset();
-            BaseRealm.applicationContext = null; // Required for Realm.init() to work
-        }
-        Realm.init(InstrumentationRegistry.getContext());
-        originalLogLevel = RealmLog.getLevel();
-        RealmLog.setLevel(LogLevel.DEBUG);
-    }
-
     /**
      * Starts a new ROS instance that can be used for testing.
      */
@@ -102,37 +79,7 @@ protected static void stopSyncServer() {
             Log.e(HttpUtils.TAG, "Failed to stop Sync Server: " + Util.getStackTrace(e));
         }
     }
-
-    /**
-     * Tries to restore the environment as best as possible after a test.
-     */
-    protected void restoreEnvironmentAfterTest() {
-        // Block until all users are logged out
-        UserFactory.logoutAllUsers();
-
-        // Reset log level
-        RealmLog.setLevel(originalLogLevel);
-    }
-
-    // Cleanup filesystem to make sure nothing lives for the next test.
-    // Failing to do so might lead to DIVERGENT_HISTORY errors being thrown if Realms from
-    // previous tests are being accessed.
-    private static void deleteRosFiles() throws IOException {
-        File rosFiles = new File(InstrumentationRegistry.getContext().getFilesDir(),"realm-object-server");
-        deleteFile(rosFiles);
-    }
-
-    private static void deleteFile(File file) throws IOException {
-        if (file.isDirectory()) {
-            for (File c : file.listFiles()) {
-                deleteFile(c);
-            }
-        }
-        if (!file.delete()) {
-            throw new IllegalStateException("Failed to delete file or directory: " + file.getAbsolutePath());
-        }
-    }
-
+    
     // Returns a valid SyncConfiguration usable by tests
     // FIXME: WARNING: Do not use `SyncTestRealmConfigurationFactory`, but use this. Refactor later.
     protected static class ConfigurationWrapper {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
index e25225fbbe..7578de0cf1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
@@ -18,21 +18,21 @@
     @Before
     public void setupTest() throws IOException {
         startSyncServer();
-        prepareEnvironmentForTest();
+        SyncTestUtils.prepareEnvironmentForTest();
     }
 
     @After
     public void teardownTest() {
         if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
             // Non-looper tests can reset here
-            restoreEnvironmentAfterTest();
+            SyncTestUtils.restoreEnvironmentAfterTest();
             stopSyncServer();
         } else {
             // Otherwise we need to wait for the test to complete
             looperThread.runAfterTest(new Runnable() {
                 @Override
                 public void run() {
-                    restoreEnvironmentAfterTest();
+                    SyncTestUtils.restoreEnvironmentAfterTest();
                     stopSyncServer();
                 }
             });
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
index aa720b15de..aea2b68327 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
@@ -44,20 +44,20 @@ public static void tearDownTestClass() throws Exception {
 
     @Before
     public void setupTest() throws IOException {
-        prepareEnvironmentForTest();
+        SyncTestUtils.prepareEnvironmentForTest();
     }
 
     @After
     public void teardownTest() {
         if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
             // Non-looper tests can reset here
-            restoreEnvironmentAfterTest();
+            SyncTestUtils.restoreEnvironmentAfterTest();
         } else {
             // Otherwise we need to wait for the test to complete
             looperThread.runAfterTest(new Runnable() {
                 @Override
                 public void run() {
-                    restoreEnvironmentAfterTest();
+                    SyncTestUtils.restoreEnvironmentAfterTest();
                 }
             });
         }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index c14df626b9..0f47cbd7d1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -26,7 +26,6 @@
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -36,9 +35,40 @@
 
 @RunWith(AndroidJUnit4.class)
 public class SyncSessionTests extends StandardIntegrationTest {
+
     @Rule
     public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
+    private interface SessionCallback {
+        void onReady(SyncSession session);
+    }
+
+    private SyncSession getSession() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        looperThread.closeAfterTest(Realm.getInstance(syncConfiguration));
+        return SyncManager.getSession(syncConfiguration);
+    }
+
+    private void getActiveSession(SessionCallback callback) {
+        SyncSession session = getSession();
+        if (session.isConnected()) {
+            callback.onReady(session);
+        } else {
+            session.addConnectionChangeListener(new ConnectionListener() {
+                @Override
+                public void onChange(ConnectionState oldState, ConnectionState newState) {
+                    if (newState == ConnectionState.CONNECTED) {
+                        session.removeConnectionChangeListener(this);
+                        callback.onReady(session);
+                    }
+                }
+            });
+        }
+    }
+
     @Test(timeout=3000)
     public void getState_active() {
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
@@ -513,18 +543,13 @@ public void run() {
     @Test
     @RunTestInLooperThread
     public void registerConnectionListener() {
-        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        SyncConfiguration syncConfiguration = configFactory
-                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .build();
-        Realm realm = Realm.getInstance(syncConfiguration);
-        SyncSession session = SyncManager.getSession(syncConfiguration);
+        SyncSession session = getSession();
         session.addConnectionChangeListener((oldState, newState) -> {
             if (newState == ConnectionState.DISCONNECTED) {
                 looperThread.testComplete();
             }
         });
-        realm.close();
+        session.stop();
     }
 
     @Test
@@ -556,22 +581,47 @@ public void removeConnectionListener() {
     @Test
     @RunTestInLooperThread
     public void isConnected() {
-        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        SyncConfiguration syncConfiguration = configFactory
-                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .build();
-        looperThread.closeAfterTest(Realm.getInstance(syncConfiguration));
-        SyncSession session = SyncManager.getSession(syncConfiguration);
-        if (session.isConnected()) {
+        getActiveSession(session -> {
+            assertEquals(session.getConnectionState(), ConnectionState.CONNECTED);
+            assertTrue(session.isConnected());
             looperThread.testComplete();
-        } else {
-            session.addConnectionChangeListener(((oldState, newState) -> {
-                if (newState == ConnectionState.CONNECTED) {
-                    assertEquals(session.getConnectionState(), ConnectionState.CONNECTED);
-                    assertTrue(session.isConnected());
-                    looperThread.testComplete();
-                }
-            }));
-        }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void stopStartSession() {
+        getActiveSession(session -> {
+            assertEquals(SyncSession.State.ACTIVE, session.getState());
+            session.stop();
+            assertEquals(SyncSession.State.INACTIVE, session.getState());
+            session.start();
+            assertNotEquals(SyncSession.State.INACTIVE, session.getState());
+            looperThread.testComplete();
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void start_multipleTimes() {
+        getActiveSession(session -> {
+            session.start();
+            assertEquals(SyncSession.State.ACTIVE, session.getState());
+            session.start();
+            assertEquals(SyncSession.State.ACTIVE, session.getState());
+            looperThread.testComplete();
+        });
+    }
+
+
+    @Test
+    @RunTestInLooperThread
+    public void stop_multipleTimes() {
+        SyncSession session = getSession();
+        session.stop();
+        assertEquals(SyncSession.State.INACTIVE, session.getState());
+        session.stop();
+        assertEquals(SyncSession.State.INACTIVE, session.getState());
+        looperThread.testComplete();
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index d5a4e520c2..b47a848564 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -33,9 +33,10 @@
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.OsRealmConfig;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -346,4 +347,96 @@ public void defaultRealm() throws InterruptedException {
             user.logOut();
         }
     }
+
+    // Check that custom headers and auth header renames are correctly used for HTTP requests
+    // performed from Java.
+    @Test
+    @RunTestInLooperThread
+    public void javaRequestCustomHeaders() {
+        SyncManager.addCustomRequestHeader("Foo", "bar");
+        SyncManager.setAuthorizationHeaderName("RealmAuth");
+        runJavaRequestCustomHeadersTest();
+    }
+
+    // Check that custom headers and auth header renames are correctly used for HTTP requests
+    // performed from Java.
+    @Test
+    @RunTestInLooperThread
+    public void javaRequestCustomHeaders_specificHost() {
+        SyncManager.addCustomRequestHeader("Foo", "bar", Constants.HOST);
+        SyncManager.setAuthorizationHeaderName("RealmAuth", Constants.HOST);
+        runJavaRequestCustomHeadersTest();
+    }
+
+    private void runJavaRequestCustomHeadersTest() {
+        SyncCredentials credentials = SyncCredentials.nickname("test", false);
+
+        RealmLog.setLevel(LogLevel.ALL);
+        RealmLog.add((level, tag, throwable, message) -> {
+            if (level == LogLevel.TRACE
+                    && message.contains("Foo: bar")
+                    && message.contains("RealmAuth: ")) {
+                looperThread.testComplete();
+            }});
+
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        try {
+            user.changePassword("foo");
+        } catch (ObjectServerError e) {
+            if (e.getErrorCode() != ErrorCode.INVALID_CREDENTIALS) {
+                throw e;
+            }
+        }
+    }
+
+    // Test that auth header renaming, custom headers and url prefix are all propagated correctly
+    // to Sync. There really isn't a way to create a proper integration test since ROS used for testing
+    // isn't configured to accept such requests. Instead we inspect the log from Sync which will
+    // output the headers in TRACE mode.
+    @Test
+    @RunTestInLooperThread
+    public void syncAuthHeaderAndUrlPrefix() {
+        SyncManager.setAuthorizationHeaderName("TestAuth");
+        SyncManager.addCustomRequestHeader("Test", "test");
+        runSyncAuthHeadersAndUrlPrefixTest();
+    }
+
+    // Test that auth header renaming, custom headers and url prefix are all propagated correctly
+    // to Sync. There really isn't a way to create a proper integration test since ROS used for testing
+    // isn't configured to accept such requests. Instead we inspect the log from Sync which will
+    // output the headers in TRACE mode.
+    @Test
+    @RunTestInLooperThread
+    public void syncAuthHeaderAndUrlPrefix_specificHost() {
+        SyncManager.setAuthorizationHeaderName("TestAuth", Constants.HOST);
+        SyncManager.addCustomRequestHeader("Test", "test", Constants.HOST);
+        runSyncAuthHeadersAndUrlPrefixTest();
+    }
+
+    private void runSyncAuthHeadersAndUrlPrefixTest() {
+        SyncCredentials credentials = SyncCredentials.nickname("test", false);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.DEFAULT_REALM)
+                .urlPrefix("/foo")
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        RealmLog.error(error.toString());
+                    }
+                })
+                .build();
+
+        RealmLog.setLevel(LogLevel.ALL);
+        RealmLog.add((level, tag, throwable, message) -> {
+            if (tag.equals("REALM_SYNC")
+                    && message.contains("GET /foo/%2Fdefault%2F__partial%")
+                    && message.contains("TestAuth: Realm-Access-Token version=1")
+                    && message.contains("Test: test")) {
+                looperThread.testComplete();
+            }
+        });
+        Realm realm = Realm.getInstance(config);
+        looperThread.closeAfterTest(realm);
+    }
+
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 61f6ea1d15..6dda502edc 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -30,6 +30,7 @@
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
+import io.realm.SyncTestUtils;
 import io.realm.SyncUser;
 import io.realm.SyncUserInfo;
 import io.realm.TestHelper;
@@ -41,7 +42,6 @@
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index c0e1ae5cea..7f9f185107 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -17,6 +17,7 @@
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
+import io.realm.SyncTestUtils;
 import io.realm.SyncUser;
 import io.realm.TestHelper;
 import io.realm.entities.StringOnly;
@@ -24,7 +25,6 @@
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
-import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
index 6865121afa..3585330c64 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
@@ -14,6 +14,7 @@
 import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
+import io.realm.SyncTestUtils;
 import io.realm.SyncUser;
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
@@ -24,7 +25,6 @@
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.util.SyncTestUtils;
 
 import static org.hamcrest.number.OrderingComparison.greaterThan;
 import static org.junit.Assert.assertEquals;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java
similarity index 71%
rename from realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
rename to realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java
index 61a1dbd3a0..b11a8ebea1 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java
@@ -14,11 +14,15 @@
  * limitations under the License.
  */
 
-package io.realm.util;
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
 
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import java.io.File;
+import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.UUID;
@@ -33,6 +37,9 @@
 import io.realm.UserStore;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.objectserver.Token;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.UserFactory;
 
 public class SyncTestUtils {
 
@@ -41,6 +48,7 @@
 
     private final static Method SYNC_MANAGER_GET_USER_STORE_METHOD;
     private final static Method SYNC_USER_GET_ACCESS_TOKEN_METHOD;
+    private static int originalLogLevel; // Should only be modified by prepareEnvironmentForTest and restoreEnvironmentAfterTest
     static {
         try {
             SYNC_MANAGER_GET_USER_STORE_METHOD = SyncManager.class.getDeclaredMethod("getUserStore");
@@ -52,6 +60,55 @@
         }
     }
 
+    public static void prepareEnvironmentForTest() throws IOException {
+        deleteRosFiles();
+        if (BaseRealm.applicationContext != null) {
+            // Realm was already initialized. Reset all internal state
+            // in order to be able fully re-initialize.
+
+            // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
+            // causing the SyncUser to remain in memory.
+            // They're actually not persisted into disk.
+            // move this call to 'tearDown' to clean in-memory & on-disk users
+            // once https://github.com/realm/realm-object-store/issues/207 is resolved
+            SyncManager.reset();
+            BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        }
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        originalLogLevel = RealmLog.getLevel();
+        RealmLog.setLevel(LogLevel.DEBUG);
+    }
+
+    /**
+     * Tries to restore the environment as best as possible after a test.
+     */
+    public static void restoreEnvironmentAfterTest() {
+        // Block until all users are logged out
+        UserFactory.logoutAllUsers();
+
+        // Reset log level
+        RealmLog.setLevel(originalLogLevel);
+    }
+
+    // Cleanup filesystem to make sure nothing lives for the next test.
+    // Failing to do so might lead to DIVERGENT_HISTORY errors being thrown if Realms from
+    // previous tests are being accessed.
+    private static void deleteRosFiles() throws IOException {
+        File rosFiles = new File(InstrumentationRegistry.getContext().getFilesDir(),"realm-object-server");
+        deleteFile(rosFiles);
+    }
+
+    private static void deleteFile(File file) throws IOException {
+        if (file.isDirectory()) {
+            for (File c : file.listFiles()) {
+                deleteFile(c);
+            }
+        }
+        if (!file.delete()) {
+            throw new IllegalStateException("Failed to delete file or directory: " + file.getAbsolutePath());
+        }
+    }
+
     public static SyncUser createTestAdminUser() {
         return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java b/realm/realm-library/src/syncTestUtils/java/io/realm/TestSyncConfigurationFactory.java
similarity index 100%
rename from realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
rename to realm/realm-library/src/syncTestUtils/java/io/realm/TestSyncConfigurationFactory.java
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/Constants.java
similarity index 100%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
rename to realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/Constants.java
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java
similarity index 91%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
rename to realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java
index d8d7d6de35..dc7aa345cb 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java
@@ -45,10 +45,15 @@
     private String userName;
     private static UserFactory instance;
     private static RealmConfiguration configuration;
-    static {
-        RealmConfiguration.Builder builder = new RealmConfiguration.Builder().name("user-factory.realm");
-        ObjectServerFacade.getSyncFacadeIfPossible().addSupportForObjectLevelPermissions(builder);
-        configuration = builder.build();
+
+    // Run initializer here to make it possible to ensure that Realm.init has been called.
+    // It is unpredictable when the static initializer is running
+    private static synchronized void initFactory(boolean forceReset) {
+        if (configuration == null || forceReset) {
+            RealmConfiguration.Builder builder = new RealmConfiguration.Builder().name("user-factory.realm");
+            ObjectServerFacade.getSyncFacadeIfPossible().addSupportForObjectLevelPermissions(builder);
+            configuration = builder.build();
+        }
     }
 
     private UserFactory(String userName) {
@@ -102,7 +107,7 @@ public static SyncUser createNicknameUser(String authUrl, String nickname, boole
     // Since we don't have a reliable way to reset the sync server and client, just use a new user factory for every
     // test case.
     public static void resetInstance() {
-        instance = null;
+        initFactory(true);
         Realm realm = Realm.getInstance(configuration);
         UserFactoryStore store = realm.where(UserFactoryStore.class).findFirst();
         realm.beginTransaction();
@@ -112,6 +117,7 @@ public static void resetInstance() {
         store.setUserName(UUID.randomUUID().toString());
         realm.commitTransaction();
         realm.close();
+        instance = null;
     }
 
     // The @Before method will be called before the looper tests finished. We need to find a better place to call this.
@@ -125,6 +131,7 @@ public static void clearInstance()  {
 
     public static synchronized UserFactory getInstance() {
         if (instance == null)  {
+            initFactory(false);
             Realm realm = Realm.getInstance(configuration);
             UserFactoryStore store = realm.where(UserFactoryStore.class).findFirst();
             if (store == null || store.getUserName() == null) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java b/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactoryStore.java
similarity index 100%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java
rename to realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactoryStore.java
diff --git a/realm/realm-library/src/androidTest/kotlin/io/realm/entities/AllKotlinTypes.kt b/realm/realm-library/src/testUtils/kotlin/io/realm/entities/AllKotlinTypes.kt
similarity index 100%
rename from realm/realm-library/src/androidTest/kotlin/io/realm/entities/AllKotlinTypes.kt
rename to realm/realm-library/src/testUtils/kotlin/io/realm/entities/AllKotlinTypes.kt
diff --git a/tools/sync_test_server/integration-test-command-server.js b/tools/sync_test_server/integration-test-command-server.js
index 71d4fa6179..f11c0cb7a3 100755
--- a/tools/sync_test_server/integration-test-command-server.js
+++ b/tools/sync_test_server/integration-test-command-server.js
@@ -141,21 +141,29 @@ function stopRealmObjectServer(onSuccess, onError) {
         onSuccess("No ROS process found or the process has been killed before");
     }
     if (syncServerChildProcess) {
-        syncServerChildProcess.on('exit', function(code) {
-            // Manually kill sub process started by node that actually runs ROS.
-            // It is not killed when killing the process running NPM
-            exec('fuser -k 9443/tcp', (error, stdout, stderr) => {
-                if (error) {
-                    onError(error)
-                    return;
-                }
-                winston.info(`command-server: Stopping process: '${stdout}'`)
-                syncServerChildProcess.removeAllListeners('exit');
-                syncServerChildProcess = null;
-                onSuccess();
+
+        // Work-around for https://github.com/realm/realm-java/issues/6137
+        // Pull the log file before removing it and output all of it to this process
+        // so we can capture it. This means the logs won't show up until ROS is stopped
+        exec('cat /ros/log.txt', (error, stdout, stderr) => {
+            winston.info(`Realm Object Server Logs:\n${stdout}`);
+            syncServerChildProcess.on('exit', function(code) {
+                // Manually kill sub process started by node that actually runs ROS.
+                // It is not killed when killing the process running NPM
+                exec('fuser -k 9443/tcp', (error, stdout, stderr) => {
+                    if (error) {
+                        onError(error)
+                        return;
+                    }
+                    winston.info(`command-server: Stopping process: '${stdout}'`)
+                    syncServerChildProcess.removeAllListeners('exit');
+                    syncServerChildProcess = null;
+                    onSuccess();
+                });
             });
+            syncServerChildProcess.kill('SIGINT');
         });
-        syncServerChildProcess.kill('SIGINT');
+
     }
 }
 
diff --git a/version.txt b/version.txt
index a26d4d9728..df4bca0bb7 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.5.0-SNAPSHOT
\ No newline at end of file
+5.6.0-SNAPSHOT
\ No newline at end of file
