diff --git a/CHANGELOG.md b/CHANGELOG.md
index f0f357215f..826a4c9524 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 ## 3.6.0 (YYYY-MM-DD)
 
+### Breaking Changes
+
+* [ObjectServer] `SyncUser.logout()` no longer throws an exception when associated Realms instances are not closed (#4962).
+
 ### Deprecated
 
 * [ObjectServer] `SyncUser#retrieveUser` and `SyncUser#retrieveUserAsync` replaced by `SyncUser#retrieveInfoForUser`
@@ -17,7 +21,10 @@ and `SyncUser#retrieveInfoForUserAsync` which returns a `SyncUserInfo` with mode
 ### Bug Fixes
 
 ### Internal
+* [ObjectServer] removed `ObjectServerUser` and its inner classes, in a step to reduce `SyncUser` complexity (#3741).
+* [ObjectServer] changed the `SyncSessionStopPolicy` to `AfterChangesUploaded` to align with other binding and to prevent use cases where the Realm might be deleted before the last changes get synchronized (#5028).
 
+* Upgraded Realm Sync to 1.10.8
 
 ## 3.5.1 (YYYY-MM-DD)
 
diff --git a/dependencies.list b/dependencies.list
index a732c8eea7..5294502a2c 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.10.5
-REALM_SYNC_SHA256=c93caa9b0ff1391550ce6b68ab3822fea7e6ae921498a3ebf3a5e6b17c56fa9b
+REALM_SYNC_VERSION=1.10.8
+REALM_SYNC_SHA256=ee47cbce2bcbd105a27d0a6b64316f8ffcb1a090e697c8025d738ef5917de408
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
@@ -10,4 +10,4 @@ REALM_SYNC_SHA256=c93caa9b0ff1391550ce6b68ab3822fea7e6ae921498a3ebf3a5e6b17c56fa
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
 # install/use between 'realm' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.8.1-149
+REALM_OBJECT_SERVER_DE_VERSION=1.8.3-83
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 773812b833..34173d9739 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -11,6 +11,7 @@ buildscript {
 
 apply plugin: 'com.android.application'
 apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-kapt'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
diff --git a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
index 67d71fee30..167ab982fd 100644
--- a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
+++ b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
@@ -23,7 +23,6 @@
 
 import com.example.securetokenandroidkeystore.R;
 
-import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -35,7 +34,6 @@
 import io.realm.SyncManager;
 import io.realm.SyncUser;
 import io.realm.android.SecureUserStore;
-import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 
 /**
@@ -97,24 +95,16 @@ private void buildSyncConf() {
 
     // Helpers
     private final static String USER_TOKEN = UUID.randomUUID().toString();
-    private final static String REALM_TOKEN = UUID.randomUUID().toString();
 
     private static SyncUser createTestUser(long expires) {
         Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
-        Token accessToken = new Token(REALM_TOKEN, "JohnDoe", "/foo", expires, new Token.Permission[]{Token.Permission.DOWNLOAD});
-        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
-
         JSONObject obj = new JSONObject();
         try {
-            JSONArray realmList = new JSONArray();
             JSONObject realmDesc = new JSONObject();
             realmDesc.put("uri", "realm://objectserver.realm.io/default");
-            realmDesc.put("description", desc.toJson());
-            realmList.put(realmDesc);
 
             obj.put("authUrl", "http://objectserver.realm.io/auth");
             obj.put("userToken", userToken.toJson());
-            obj.put("realms", realmList);
             return SyncUser.fromJson(obj.toString());
         } catch (JSONException e) {
             throw new RuntimeException(e);
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index bbf96f55d0..ff5f58d9cc 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -2,6 +2,7 @@ import java.security.MessageDigest
 
 apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-kapt'
 apply plugin: 'com.github.dcendents.android-maven'
 apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
diff --git a/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt b/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt
index 7948a10918..f53a8e0423 100644
--- a/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt
+++ b/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt
@@ -25,7 +25,6 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
-import kotlin.reflect.full.memberProperties
 
 /**
  * This class tests how Kotlin classes are interpreted by Realm and exposed in the RealmSchema
@@ -50,7 +49,7 @@ class KotlinSchemaTests {
 
     @Test
     fun kotlinTypeNonNull() {
-        val objSchema = realm.getSchema().get(AllKotlinTypes::class.simpleName)!!
+        val objSchema = realm.schema.get(AllKotlinTypes::class.simpleName)!!
 
         // Document current nullability. Ideally all should be non-nullable. This is currently
         // not the case.
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index 54a87b468c..bdadf6211c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -39,7 +39,7 @@ public void setUp() {
 
     @Test
     public void realmLogin() throws URISyntaxException, JSONException {
-        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
+        Token t = SyncTestUtils.createTestUser().getAccessToken();
         AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default"));
 
         JSONObject obj = new JSONObject(request.toJson());
@@ -60,7 +60,7 @@ public void userLogin() throws URISyntaxException, JSONException {
 
     @Test
     public void userRefresh() throws URISyntaxException, JSONException {
-        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
+        Token t = SyncTestUtils.createTestUser().getAccessToken();
         AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default"));
 
         JSONObject obj = new JSONObject(request.toJson());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 853d888d33..ee9b216eb3 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -25,8 +25,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestSyncConfigurationFactory;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index cb91b68f15..40e8f831f9 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -31,17 +31,25 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.Calendar;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Iterator;
 import java.util.UUID;
 
+import io.realm.entities.StringOnly;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
@@ -50,6 +58,7 @@
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static junit.framework.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -60,6 +69,20 @@
 @RunWith(AndroidJUnit4.class)
 public class SyncUserTests {
 
+    private static final URL authUrl;
+    private static final Constructor<SyncUser> SYNC_USER_CONSTRUCTOR;
+    static {
+        try {
+            authUrl = new URL("http://localhost/auth");
+            SYNC_USER_CONSTRUCTOR = SyncUser.class.getDeclaredConstructor(Token.class, URL.class);
+            SYNC_USER_CONSTRUCTOR.setAccessible(true);
+        } catch (MalformedURLException e) {
+            throw new ExceptionInInitializerError(e);
+        } catch (NoSuchMethodException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
@@ -81,6 +104,45 @@ public void setUp() {
         SyncManager.reset();
     }
 
+    private static SyncUser createFakeUser(String id) {
+        final Token token = new Token("token_value", id, "path_value", Long.MAX_VALUE, null);
+        try {
+            return SYNC_USER_CONSTRUCTOR.newInstance(token, authUrl);
+        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
+            fail(e.getMessage());
+        }
+        return null;
+    }
+
+    @Test
+    public void equals_validUser() {
+        final SyncUser user1 = createFakeUser("id_value");
+        final SyncUser user2 = createFakeUser("id_value");
+        assertTrue(user1.equals(user2));
+    }
+
+    @Test
+    public void equals_loggedOutUser() {
+        final SyncUser user1 = createFakeUser("id_value");
+        final SyncUser user2 = createFakeUser("id_value");
+        user1.logout();
+        user2.logout();
+        assertTrue(user1.equals(user2));
+    }
+
+    @Test
+    public void hashCode_validUser() {
+        final SyncUser user = createFakeUser("id_value");
+        assertNotEquals(0, user.hashCode());
+    }
+
+    @Test
+    public void hashCode_loggedOutUser() {
+        final SyncUser user = createFakeUser("id_value");
+        user.logout();
+        assertNotEquals(0, user.hashCode());
+    }
+
     @Test
     public void toAndFromJson() {
         SyncUser user1 = createTestUser();
@@ -407,4 +469,66 @@ public void allSessions() {
         realm2.close();
         assertEquals(0, user.allSessions().size());
     }
+
+    // JSON format changed in 3.6.0 (removed unnecessary fields), this regression test
+    // makes sure we can still deserialize a valid SyncUser from the old format.
+    @Test
+    public void fromJson_WorkWithRemovedObjectServerUser() {
+        String oldSyncUserJSON = "{\"authUrl\":\"http:\\/\\/192.168.1.151:9080\\/auth\",\"userToken\":{\"token\":\"eyJpZGVudGl0eSI6IjY4OWQ5MGMxNDIyYTIwMmZkNTljNDYwM2M0ZTRmNmNjIiwiZXhwaXJlcyI6MTgxNjM1ODE4NCwiYXBwX2lkIjoiaW8ucmVhbG0ucmVhbG10YXNrcyIsImFjY2VzcyI6WyJyZWZyZXNoIl0sImlzX2FkbWluIjpmYWxzZSwic2FsdCI6MC4yMTEwMjQyNDgwOTEyMzg1NH0=:lEDa83o1zu8rkwdZVpTyunLHh1wmjxPPSGmZQNxdEM7xDmpbiU7V+8dgDWGevJNHMFluNDAOmrcAOI9TLfhI4rMDl70NI1K9rv\\/Aeq5uIOzq\\/Gf7JTeTUKY5Z7yRoppd8NArlNBKesLFxzdLRlfm1hflF9wH23xQXA19yUZ67JIlkhDPL5e3bau8O3Pr\\/St0unW3KzPOiZUk1l9KRrs2iMCCiXCfq4rf6rp7B2M7rBUMQm68GnB1Ot7l1CblxEWcREcbpyhBKTWIOFRGMwg2TW\\/zRR3cRNglx+ZC4FOeO0mfkX+nf+slyFODAnQkOzPZcGO8xc3I1emafX58Wl\\/Guw==\",\"token_data\":{\"identity\":\"689d90c1422a202fd59c4603c4e4f6cc\",\"path\":\"\",\"expires\":1816358184,\"access\":[\"unknown\"],\"is_admin\":false}},\"realms\":[]}";
+        SyncUser syncUser = SyncUser.fromJson(oldSyncUserJSON);
+
+        // Note: we can't call isValid() and expect it to be true
+        //       since the user is not persisted in the UserStore
+        //       isValid() requires SyncManager.getUserStore().isActive(identity)
+        //       to return true as well.
+        Token accessToken = syncUser.getAccessToken();
+        assertNotNull(accessToken);
+        // refresh token should expire in 10 years (July 23, 2027)
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(accessToken.expiresMs());
+        int day = calendar.get(Calendar.DAY_OF_MONTH);
+        int month = calendar.get(Calendar.MONTH);
+        int year = calendar.get(Calendar.YEAR);
+
+        assertEquals(23, day);
+        assertEquals(Calendar.JULY, month);
+        assertEquals(2027, year);
+
+        assertEquals("http://192.168.1.151:9080/auth", syncUser.getAuthenticationUrl().toString());
+    }
+
+    @Test
+    @Ignore("until https://github.com/realm/realm-java/issues/5097 is fixed")
+    public void logoutUserShouldDeleteRealmAfterRestart() throws InterruptedException {
+        SyncManager.reset();
+        BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        Realm.init(InstrumentationRegistry.getTargetContext());
+
+        SyncUser user = createTestUser();
+        SyncConfiguration syncConfiguration = new SyncConfiguration
+                .Builder(user, "realm://127.0.0.1:9080/~/tests")
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(syncConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("1");
+            }
+        });
+        user.logout();
+        realm.close();
+
+        final File realmPath = new File (syncConfiguration.getPath());
+        assertTrue(realmPath.exists());
+
+        // simulate an app restart
+        SyncManager.reset();
+        BaseRealm.applicationContext = null;
+        Realm.init(InstrumentationRegistry.getTargetContext());
+
+        //now the file should be deleted
+        assertFalse(realmPath.exists());
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java
deleted file mode 100644
index aa68bf09f7..0000000000
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal.objectserver;
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(AndroidJUnit4.class)
-public class ObjectServerUserTests {
-
-    private static final URL authUrl;
-
-    static {
-        try {
-            authUrl = new URL("http://localhost/auth");
-        } catch (MalformedURLException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
-
-    private static ObjectServerUser createFakeUser(String id) {
-        final Token token = new Token("token_value", id, "path_value", Long.MAX_VALUE, null);
-        return new ObjectServerUser(token, authUrl);
-    }
-
-    @Test
-    public void equals_validUser() {
-        final ObjectServerUser user1 = createFakeUser("id_value");
-        final ObjectServerUser user2 = createFakeUser("id_value");
-        assertTrue(user1.equals(user2));
-    }
-
-    @Test
-    public void equals_loggedOutUser() {
-        final ObjectServerUser user1 = createFakeUser("id_value");
-        final ObjectServerUser user2 = createFakeUser("id_value");
-        user1.clearTokens();
-        user2.clearTokens();
-        assertTrue(user1.equals(user2));
-    }
-
-    @Test
-    public void hashCode_validUser() {
-        final ObjectServerUser user = createFakeUser("id_value");
-        assertNotEquals(0, user.hashCode());
-    }
-
-    @Test
-    public void hashCode_loggedOutUser() {
-        final ObjectServerUser user = createFakeUser("id_value");
-        user.clearTokens();
-        assertNotEquals(0, user.hashCode());
-    }
-}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index 87d856956e..167bb3b3a1 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -16,7 +16,6 @@
 
 package io.realm.util;
 
-import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -30,25 +29,13 @@
 import io.realm.SyncUser;
 import io.realm.UserStore;
 import io.realm.internal.network.AuthenticateResponse;
-import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 
 public class SyncTestUtils {
 
     public static final String USER_TOKEN = UUID.randomUUID().toString();
-    public static final String REALM_TOKEN = UUID.randomUUID().toString();
     public static final String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
 
-    private final static Method SYNC_MANAGER_RESET_METHOD;
-    static {
-        try {
-            SYNC_MANAGER_RESET_METHOD = SyncManager.class.getDeclaredMethod("reset");
-            SYNC_MANAGER_RESET_METHOD.setAccessible(true);
-        } catch (NoSuchMethodException e) {
-            throw new AssertionError(e);
-        }
-    }
-
     private final static Method SYNC_MANAGER_GET_USER_STORE_METHOD;
     static {
         try {
@@ -59,51 +46,36 @@
         }
     }
 
-    public static SyncUser createRandomTestUser() {
-        return createTestUser(UUID.randomUUID().toString(),
-                UUID.randomUUID().toString(),
-                UUID.randomUUID().toString(),
-                DEFAULT_AUTH_URL,
-                Long.MAX_VALUE,
-                false);
-    }
-
     public static SyncUser createTestAdminUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
     }
 
     public static SyncUser createTestUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createTestUser(long expires) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, expires, false);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, expires, false);
     }
 
     public static SyncUser createTestUser(String authUrl) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, UUID.randomUUID().toString(), authUrl, Long.MAX_VALUE, false);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), authUrl, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createNamedTestUser(String userIdentifier) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
+        return createTestUser(USER_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
-    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String userIdentifier, String authUrl, long expires, boolean isAdmin) {
+    public static SyncUser createTestUser(String userTokenValue, String userIdentifier, String authUrl, long expires, boolean isAdmin) {
         Token userToken = new Token(userTokenValue, userIdentifier, null, expires, null, isAdmin);
-        Token accessToken = new Token(realmTokenValue, userIdentifier, "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
-        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
 
         JSONObject obj = new JSONObject();
         try {
-            JSONArray realmList = new JSONArray();
             JSONObject realmDesc = new JSONObject();
             realmDesc.put("uri", "realm://objectserver.realm.io/default");
-            realmDesc.put("description", desc.toJson());
-            realmList.put(realmDesc);
 
             obj.put("authUrl", authUrl);
             obj.put("userToken", userToken.toJson());
-            obj.put("realms", realmList);
             SyncUser syncUser = SyncUser.fromJson(obj.toString());
             // persist the user to the ObjectStore sync metadata, to simulate real login, otherwise SyncUser.isValid will
             // "throw IllegalArgumentException: User not authenticated or authentication expired." since
@@ -130,31 +102,10 @@ public static AuthenticateResponse createLoginResponse(String userTokenValue, St
         }
     }
 
-    public static AuthenticateResponse createRefreshResponse() {
-        try {
-            Token userToken = new Token(USER_TOKEN, "JohnDoe", null, Long.MAX_VALUE, null);
-            JSONObject response = new JSONObject();
-            response.put("refresh_token", userToken.toJson());
-            return AuthenticateResponse.from(response.toString());
-        } catch (JSONException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
     public static AuthenticateResponse createErrorResponse(ErrorCode code) {
         return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
     }
 
-    public static void resetSyncMetadata() {
-        try {
-            SYNC_MANAGER_RESET_METHOD.invoke(null);
-        } catch (InvocationTargetException e) {
-            throw new AssertionError(e);
-        } catch (IllegalAccessException e) {
-            throw new AssertionError(e);
-        }
-    }
-
     private static void addToUserStore(SyncUser user) {
         try {
             UserStore userStore = (UserStore) SYNC_MANAGER_GET_USER_STORE_METHOD.invoke(null);
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index dd391c2b26..d34e026d87 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -46,7 +46,12 @@ struct AndroidClientListener : public realm::BindingCallbackThreadObserver {
 
     void will_destroy_thread() override
     {
-        Log::d("SyncClient thread destroyed");
+        // avoid allocating any NewString if we have a pending exception
+        // otherwise a "JNI called with pending exception" will be called
+        if (JniUtils::get_env(true)->ExceptionCheck() == JNI_FALSE) {
+            Log::d("SyncClient thread destroyed");
+        }
+
         // Failing to detach the JVM before closing the thread will crash on ART
         JniUtils::detach_current_thread();
     }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 04d02f305a..fd36c60fc8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -40,7 +40,10 @@ using namespace realm::jni_util;
 static_assert(SchemaMode::Automatic ==
                   static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC),
               "");
-static_assert(SchemaMode::ReadOnly ==
+static_assert(SchemaMode::Immutable ==
+                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_IMMUTABLE),
+              "");
+static_assert(SchemaMode::ReadOnlyAlternative ==
                   static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY),
               "");
 static_assert(SchemaMode::ResetFile ==
@@ -86,7 +89,7 @@ class JniConfigWrapper {
         static JavaMethod java_error_callback_method(env, sync_manager_class, "notifyErrorHandler",
                                                      "(ILjava/lang/String;Ljava/lang/String;)V", true);
         static JavaMethod java_bind_session_method(env, sync_manager_class, "bindSessionWithConfig",
-                                                   "(Ljava/lang/String;)Ljava/lang/String;", true);
+                                                   "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", true);
 
         // error handler will be called form the sync client thread
         auto error_handler = [=](std::shared_ptr<SyncSession> session, SyncError error) {
@@ -117,7 +120,7 @@ class JniConfigWrapper {
             JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
 
             jstring access_token_string = (jstring)env->CallStaticObjectMethod(
-                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()));
+                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()), to_jstring(env, session->user()->refresh_token().c_str()));
             if (access_token_string) {
                 // reusing cached valid token
                 JStringAccessor access_token(env, access_token_string);
@@ -149,7 +152,7 @@ class JniConfigWrapper {
 
         JStringAccessor realm_url(env, sync_realm_url);
         m_config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
-            user, realm_url, SyncSessionStopPolicy::Immediately, std::move(bind_handler), std::move(error_handler),
+            user, realm_url, SyncSessionStopPolicy::AfterChangesUploaded, std::move(bind_handler), std::move(error_handler),
             nullptr, sync_encryption_key, to_bool(sync_client_validate_ssl), ssl_trust_certificate_path});
 #else
         REALM_UNREACHABLE();
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 50cf5ee583..2274604de9 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 50cf5ee58366065fa3faca266c371bedc29dc2c7
+Subproject commit 2274604de9c1b34667a78246d86437f64ae6896f
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 44d4be3840..e9ef74c7ea 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -82,13 +82,15 @@ public static File getTemporaryDirectory() {
     }
 
     private static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
-    private static final byte SCHEMA_MODE_VALUE_READONLY = 1;
-    private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 2;
-    private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 3;
-    private static final byte SCHEMA_MODE_VALUE_MANUAL = 4;
+    private static final byte SCHEMA_MODE_VALUE_IMMUTABLE = 1;
+    private static final byte SCHEMA_MODE_VALUE_READONLY = 2;
+    private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 3;
+    private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 4;
+    private static final byte SCHEMA_MODE_VALUE_MANUAL = 5;
 
     private enum SchemaMode {
         SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
+        SCHEMA_MODE_IMMUTABLE(SCHEMA_MODE_VALUE_IMMUTABLE),
         SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
         SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
         SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index 7c53227952..255acb0218 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -24,7 +24,7 @@
 
 
 /**
- * A User Store backed by a Realm file to store user.
+ * A User Store backed by a Realm file to store users.
  */
 public class RealmFileUserStore implements UserStore {
 
@@ -35,7 +35,7 @@
     public void put(SyncUser user) {
         String userJson = user.toJson();
         // create or update token (userJson) using identity
-        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString());
+        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getAuthenticationUrl().toString());
     }
 
     /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 2d8b7a6acb..4ba4d0e5d9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -342,13 +342,13 @@ private static synchronized void notifyProgressListener(String localRealmPath, l
      * @return a valid cached {@code access_token} if available or null.
      */
     @SuppressWarnings("unused")
-    private synchronized static String bindSessionWithConfig(String sessionPath) {
+    private synchronized static String bindSessionWithConfig(String sessionPath, String refreshToken) {
         final SyncSession syncSession = sessions.get(sessionPath);
         if (syncSession == null) {
             RealmLog.error("Matching Java SyncSession could not be found for: " + sessionPath);
         } else {
             try {
-                return syncSession.getAccessToken(authServer);
+                return syncSession.getAccessToken(authServer, refreshToken);
             } catch (Exception exception) {
                 RealmLog.error(exception);
             }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index af09b7508d..cd17ab390b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -16,6 +16,9 @@
 
 package io.realm;
 
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.net.URI;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
@@ -33,13 +36,13 @@
 
 import io.realm.internal.Keep;
 import io.realm.internal.SyncObjectServerFacade;
+import io.realm.internal.Util;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.NetworkStateReceiver;
-import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
@@ -464,10 +467,10 @@ private void checkIfNotOnMainThread(String errorMessage) {
     }
 
     // Return the access token for the Realm this Session is connected to.
-    String getAccessToken(final AuthenticationServer authServer) {
+    String getAccessToken(final AuthenticationServer authServer, String refreshToken) {
         // check first if there's a valid access_token we can return immediately
-        if (getUser().getSyncUser().isRealmAuthenticated(configuration)) {
-            Token accessToken = getUser().getSyncUser().getAccessToken(configuration.getServerUrl());
+        if (getUser().isRealmAuthenticated(configuration)) {
+            Token accessToken = getUser().getAccessToken(configuration);
             // start refreshing this token if a refresh is not going on
             if (!onGoingAccessTokenQuery.getAndSet(true)) {
                 scheduleRefreshAccessToken(authServer, accessToken.expiresMs());
@@ -475,6 +478,19 @@ String getAccessToken(final AuthenticationServer authServer) {
             return accessToken.value();
 
         } else {
+            // check and update if we received a new refresh_token
+            if (!Util.isEmptyString(refreshToken)) {
+                try {
+                    JSONObject refreshTokenJSON = new JSONObject(refreshToken);
+                    Token newRefreshToken = Token.from(refreshTokenJSON.getJSONObject("userToken"));
+                    if (newRefreshToken.hashCode() != getUser().getAccessToken().hashCode()) {
+                        RealmLog.debug("Session[%s]: Access token updated", configuration.getPath());
+                        getUser().setRefreshToken(newRefreshToken);
+                    }
+                } catch (JSONException e) {
+                    RealmLog.error(e,"Session[%s]: Can not parse the refresh_token into a valid JSONObject: ", configuration.getPath());
+                }
+            }
             if (!onGoingAccessTokenQuery.getAndSet(true)) {
                 if (NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {
                     authenticateRealm(authServer);
@@ -526,16 +542,9 @@ protected AuthenticateResponse execute() {
             protected void onSuccess(AuthenticateResponse response) {
                 RealmLog.debug("Session[%s]: Access token acquired", configuration.getPath());
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                    ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
-                            response.getAccessToken(),
-                            configuration.getPath(),
-                            configuration.shouldDeleteRealmOnLogout()
-                    );
                     URI realmUrl = configuration.getServerUrl();
-                    getUser().getSyncUser().addRealm(realmUrl, desc);
-                    String token = getUser().getSyncUser().getAccessToken(realmUrl).value();
-                    // schedule a token refresh before it expires
-                    if (nativeRefreshAccessToken(configuration.getPath(), token, realmUrl.toString())) {
+                    getUser().addRealm(configuration, response.getAccessToken());
+                    if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {
                         scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
 
                     } else {
@@ -582,7 +591,7 @@ private void scheduleRefreshAccessToken(final AuthenticationServer authServer, l
         ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
             @Override
             public void run() {
-                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenTask.isCancelled()) {
                     refreshAccessToken(authServer);
                 }
             }
@@ -599,7 +608,7 @@ private void refreshAccessToken(final AuthenticationServer authServer) {
             @Override
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                    return authServer.refreshUser(getUser().getSyncUser().getUserToken(), configuration.getServerUrl(), getUser().getSyncUser().getAuthenticationUrl());
+                    return authServer.refreshUser(getUser().getAccessToken(), configuration.getServerUrl(), getUser().getAuthenticationUrl());
                 }
                 return null;
             }
@@ -607,18 +616,12 @@ protected AuthenticateResponse execute() {
             @Override
             protected void onSuccess(AuthenticateResponse response) {
                 synchronized (SyncSession.this) {
-                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenNetworkRequest.isCancelled()) {
                         RealmLog.debug("Access Token refreshed successfully, Sync URL: " + configuration.getServerUrl());
                         URI realmUrl = configuration.getServerUrl();
                         if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {
-                            // replaced the user old access_token
-                            ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
-                                    response.getAccessToken(),
-                                    configuration.getPath(),
-                                    configuration.shouldDeleteRealmOnLogout()
-                            );
-                            getUser().getSyncUser().addRealm(realmUrl, desc);
-
+                            // replace the user old access_token
+                            getUser().addRealm(configuration, response.getAccessToken());
                             // schedule the next refresh
                             scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
                         }
@@ -637,13 +640,14 @@ protected void onError(AuthenticateResponse response) {
         refreshTokenNetworkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
     }
 
-    private void clearScheduledAccessTokenRefresh() {
+    void clearScheduledAccessTokenRefresh() {
         if (refreshTokenTask != null) {
             refreshTokenTask.cancel();
         }
         if (refreshTokenNetworkRequest != null) {
             refreshTokenNetworkRequest.cancel();
         }
+        onGoingAccessTokenQuery.set(false);
     }
 
     // Wrapper class for handling the async operations of the underlying SyncSession calling
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 7f8e82aa4f..acafd13393 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -16,11 +16,9 @@
 
 package io.realm;
 
-import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.File;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -47,7 +45,6 @@
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.LogoutResponse;
 import io.realm.internal.network.LookupUserIdResponse;
-import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
 import io.realm.permissions.PermissionModule;
@@ -65,15 +62,19 @@
  * as sensitive data.
  */
 public class SyncUser {
+    private final String identity;
+    private Token refreshToken;
+    private final URL authenticationUrl;
+    // maps all RealmConfiguration and accessToken, using this SyncUser.
+    private final Map<SyncConfiguration, Token> realms = new HashMap<SyncConfiguration, Token>();
 
     private static class ManagementConfig {
         private SyncConfiguration managementRealmConfig;
 
-        synchronized SyncConfiguration initAndGetManagementRealmConfig(
-                ObjectServerUser syncUser, final SyncUser user) {
+        synchronized SyncConfiguration initAndGetManagementRealmConfig(final SyncUser user) {
             if (managementRealmConfig == null) {
                 managementRealmConfig = new SyncConfiguration.Builder(
-                        user, getManagementRealmUrl(syncUser.getAuthenticationUrl()))
+                        user, getManagementRealmUrl(user.getAuthenticationUrl()))
                         .errorHandler(new SyncSession.ErrorHandler() {
                             @Override
                             public void onError(SyncSession session, ObjectServerError error) {
@@ -95,13 +96,12 @@ public void onError(SyncSession session, ObjectServerError error) {
         }
     }
 
-
     private final ManagementConfig managementConfig = new ManagementConfig();
 
-    private final ObjectServerUser syncUser;
-
-    private SyncUser(ObjectServerUser user) {
-        this.syncUser = user;
+    SyncUser(Token refreshToken, URL authenticationUrl) {
+        this.identity = refreshToken.identity();
+        this.authenticationUrl = authenticationUrl;
+        this.refreshToken = refreshToken;
     }
 
     /**
@@ -150,21 +150,11 @@ public static SyncUser fromJson(String user) {
             JSONObject obj = new JSONObject(user);
             URL authUrl = new URL(obj.getString("authUrl"));
             Token userToken = Token.from(obj.getJSONObject("userToken"));//TODO rename to refresh_token
-            ObjectServerUser syncUser = new ObjectServerUser(userToken, authUrl);
-            JSONArray realmTokens = obj.getJSONArray("realms");
-            for (int i = 0; i < realmTokens.length(); i++) {
-                JSONObject token = realmTokens.getJSONObject(i);
-                URI uri = new URI(token.getString("uri"));
-                ObjectServerUser.AccessDescription realmDesc = ObjectServerUser.AccessDescription.fromJson(token.getJSONObject("description"));
-                syncUser.addRealm(uri, realmDesc);
-            }
-            return new SyncUser(syncUser);
+            return new SyncUser(userToken, authUrl);
         } catch (JSONException e) {
             throw new IllegalArgumentException("Could not parse user json: " + user, e);
         } catch (MalformedURLException e) {
             throw new IllegalArgumentException("URL in JSON not valid: " + user, e);
-        } catch (URISyntaxException e) {
-            throw new IllegalArgumentException("URI is not valid: " + user, e);
         }
     }
 
@@ -205,8 +195,7 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
                 result = server.loginUser(credentials, authUrl);
             }
             if (result.isValid()) {
-                ObjectServerUser syncUser = new ObjectServerUser(result.getRefreshToken(), authUrl);
-                SyncUser user = new SyncUser(syncUser);
+                SyncUser user = new SyncUser(result.getRefreshToken(), authUrl);
                 RealmLog.info("Succeeded authenticating user.\n%s", user);
                 SyncManager.getUserStore().put(user);
                 SyncManager.notifyUserLoggedIn(user);
@@ -243,63 +232,61 @@ public SyncUser run() throws ObjectServerError {
     }
 
     /**
-     * Logs out the user from the Realm Object Server. Once the Object Server has confirmed the logout any registered
-     * {@link AuthenticationListener} will be notified and user credentials will be deleted from this device.
+     * Log a user out, destroying their server state, unregistering them from the SDK, and removing
+     * any synced Realms associated with them, from on-disk storage on next app launch (or directly
+     * if all instances are closed).
+     * If the user is already logged out or in an error state, this method does nothing.
      *
-     * @throws IllegalStateException if any Realms owned by this user is still open. They should be closed before
-     * logging out.
-     */
-    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
-     <p>
-     Any Realms owned by the user will be deleted if {@link SyncConfiguration.Builder#deleteRealmOnLogout()} is
-     also set.
+     * This method should be called whenever the application is committed to not using a user again
+     * unless they are recreated. Failing to call this method may result in unused files and metadata
+     * needlessly taking up space.
+     *
+     * Once the Object Server has confirmed the logout any registered {@link AuthenticationListener}
+     * will be notified and user credentials will be deleted from this device.
      */
+//    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
+//     <p>
+//     Any Realms owned by the user will be deleted, when the application restart.
+//     */
+    // this is a fire and forget, end user should not worry about the state of the async query
+    @SuppressWarnings("FutureReturnValueIgnored")
     public void logout() {
         // Acquire lock to prevent users creating new instances
         synchronized (Realm.class) {
-            if (!syncUser.isLoggedIn()) {
-                return; // Already local/global logout status
-            }
-
-            // Ensure that we can log out. If any Realm file is still open we should abort before doing anything
-            // else.
-            Collection<SyncSession> sessions = syncUser.getSessions();
-            for (SyncSession session : sessions) {
-                SyncConfiguration config = session.getConfiguration();
-                if (Realm.getGlobalInstanceCount(config) > 0) {
-                    throw new IllegalStateException("A Realm controlled by this user is still open. Close all Realms " +
-                            "before logging out: " + config.getPath());
-                }
+            if (!SyncManager.getUserStore().isActive(identity, authenticationUrl.toString())) {
+                return; // Already logged out status
             }
 
-            SyncManager.getUserStore().remove(syncUser.getIdentity(), getAuthenticationUrl().toString());
+            // Mark the user as logged out in the ObjectStore
+            SyncManager.getUserStore().remove(identity, authenticationUrl.toString());
 
-            // Delete all Realms if needed.
-            for (ObjectServerUser.AccessDescription desc : syncUser.getRealms()) {
-                // FIXME: This will always be false since SyncConfiguration.Builder.deleteRealmOnLogout() is
-                // disabled. Make sure this works for Realm opened in the client thread/other processes.
-                if (desc.deleteOnLogout) {
-                    File realmFile = new File(desc.localPath);
-                    if (realmFile.exists() && !Util.deleteRealm(desc.localPath, realmFile.getParentFile(), realmFile.getName())) {
-                        RealmLog.error("Could not delete Realm when user logged out: " + desc.localPath);
-                    }
+            // invalidate all pending refresh_token queries
+            for (SyncConfiguration syncConfiguration : realms.keySet()) {
+                SyncSession session = SyncManager.getSession(syncConfiguration);
+                if (session != null) {
+                    session.clearScheduledAccessTokenRefresh();
                 }
             }
 
             // Remove all local tokens, preventing further connections.
-            final Token userToken = syncUser.getUserToken();
-            syncUser.clearTokens();
-            syncUser.localLogout();
+            // don't remove identity as this SyncUser might be re-activated and we need
+            // to avoid throwing a mismatch SyncConfiguration in RealmCache if we have
+            // the similar SyncConfiguration using the same identity, but with different (new)
+            // refresh-token.
+            realms.clear();
 
             // Finally revoke server token. The local user is logged out in any case.
             final AuthenticationServer server = SyncManager.getAuthServer();
+            // don't reference directly the refreshToken inside the revoke request
+            // as it may revoke the newly acquired and refresh_token
+            final Token refreshTokenToBeRevoked = refreshToken;
+
             ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
-            //noinspection unused
-            final Future<?> future = networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
+            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
 
                 @Override
                 protected LogoutResponse execute() {
-                    return server.logout(userToken, getAuthenticationUrl());
+                    return server.logout(refreshTokenToBeRevoked, getAuthenticationUrl());
                 }
 
                 @Override
@@ -331,7 +318,7 @@ public void changePassword(final String newPassword) throws ObjectServerError {
             throw new IllegalArgumentException("Not-null 'newPassword' required.");
         }
         AuthenticationServer authServer = SyncManager.getAuthServer();
-        ChangePasswordResponse response = authServer.changePassword(getSyncUser().getUserToken(), newPassword, getAuthenticationUrl());
+        ChangePasswordResponse response = authServer.changePassword(refreshToken, newPassword, getAuthenticationUrl());
         if (!response.isValid()) {
             throw response.getError();
         }
@@ -369,7 +356,7 @@ public void changePassword(final String userId, final String newPassword) throws
             }
 
             AuthenticationServer authServer = SyncManager.getAuthServer();
-            ChangePasswordResponse response = authServer.changePassword(getSyncUser().getUserToken(), userId, newPassword, getAuthenticationUrl());
+            ChangePasswordResponse response = authServer.changePassword(refreshToken, userId, newPassword, getAuthenticationUrl());
             if (!response.isValid()) {
                 throw response.getError();
             }
@@ -461,7 +448,7 @@ public SyncUser retrieveUser(final String provider, final String providerId) thr
         }
 
         AuthenticationServer authServer = SyncManager.getAuthServer();
-        LookupUserIdResponse response = authServer.retrieveUser(getSyncUser().getUserToken(), provider, providerId, getAuthenticationUrl());
+        LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerId, getAuthenticationUrl());
         if (!response.isValid()) {
             // the endpoint returns a 404 if it can't honor the query, either because
             // - provider is not valid
@@ -478,11 +465,9 @@ public SyncUser retrieveUser(final String provider, final String providerId) thr
             if (syncUser != null) {
                 return syncUser;
             } else {
-                // build an SynUser without a token
+                // build a SynUser without a token
                 Token refreshToken = new Token(null, response.getUserId(), null, 0, null, response.isAdmin());
-                ObjectServerUser objectServerUser = new ObjectServerUser(refreshToken, getAuthenticationUrl());
-                objectServerUser.localLogout();
-                return new SyncUser(objectServerUser);
+                return new SyncUser(refreshToken, getAuthenticationUrl());
             }
         }
     }
@@ -540,7 +525,7 @@ public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final
         }
 
         AuthenticationServer authServer = SyncManager.getAuthServer();
-        LookupUserIdResponse response = authServer.retrieveUser(getSyncUser().getUserToken(), provider, providerUserIdentity, getAuthenticationUrl());
+        LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerUserIdentity, getAuthenticationUrl());
         if (!response.isValid()) {
             // the endpoint returns a 404 if it can't honor the query, either because
             // - provider is not valid
@@ -605,7 +590,14 @@ private static void checkLooperThread(String errorMessage) {
      * @see #fromJson(String)
      */
     public String toJson() {
-        return syncUser.toJson();
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("authUrl", authenticationUrl);
+            obj.put("userToken", refreshToken.toJson());
+            return obj.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException("Could not convert SyncUser to JSON", e);
+        }
     }
 
     /**
@@ -620,9 +612,7 @@ public String toJson() {
      * @return {@code true} if the User is logged into the Realm Object Server, {@code false} otherwise.
      */
     public boolean isValid() {
-        Token userToken = getSyncUser().getUserToken();
-        return userToken != null && userToken.expiresMs() > System.currentTimeMillis() &&
-                SyncManager.getUserStore().isActive(getIdentity(), getAuthenticationUrl().toString());
+        return refreshToken != null && refreshToken.expiresMs() > System.currentTimeMillis() && SyncManager.getUserStore().isActive(identity, authenticationUrl.toString());
     }
 
     /**
@@ -633,7 +623,7 @@ public boolean isValid() {
      * @return {@code true} if the user is an administrator on the Realm Object Server, {@code false} otherwise.
      */
     public boolean isAdmin() {
-        return syncUser.isAdmin();
+        return refreshToken.isAdmin();
     }
 
     /**
@@ -644,7 +634,7 @@ public boolean isAdmin() {
      * {@code null} is returned.
      */
     public String getIdentity() {
-        return syncUser.getIdentity();
+        return identity;
     }
 
     /**
@@ -654,7 +644,11 @@ public String getIdentity() {
      * @return the user's access token. If this user has logged out or the login has expired {@code null} is returned.
      */
     public Token getAccessToken() {
-        return syncUser.getUserToken();
+        return refreshToken;
+    }
+
+    void setRefreshToken(Token refreshToken) {
+        this.refreshToken = refreshToken;
     }
 
     /**
@@ -666,7 +660,7 @@ public Token getAccessToken() {
      * @see <a href="https://realm.io/docs/realm-object-server/#permissions">How to control permissions</a>
      */
     public Realm getManagementRealm() {
-        return Realm.getInstance(managementConfig.initAndGetManagementRealmConfig(syncUser, this));
+        return Realm.getInstance(managementConfig.initAndGetManagementRealmConfig(this));
     }
 
     /**
@@ -678,13 +672,31 @@ public Realm getManagementRealm() {
         return SyncManager.getAllSessions(this);
     }
 
+    /**
+     * Checks if the user has access to the given Realm. Being authenticated means that the
+     * user is known by the Realm Object Server and have been granted access to the given Realm.
+     *
+     * Authenticating will happen automatically as part of opening a Realm.
+     */
+    boolean isRealmAuthenticated(SyncConfiguration configuration) {
+        Token token = realms.get(configuration);
+        return token != null && token.expiresMs() > System.currentTimeMillis();
+    }
+
+    Token getAccessToken(SyncConfiguration configuration) {
+        return realms.get(configuration);
+    }
+
+    void addRealm(SyncConfiguration syncConfiguration, Token accessToken) {
+        realms.put(syncConfiguration, accessToken);
+    }
     /**
      * Returns the {@link URL} where this user was authenticated.
      *
      * @return {@link URL} where the user was authenticated.
      */
     public URL getAuthenticationUrl() {
-        return syncUser.getAuthenticationUrl();
+        return authenticationUrl;
     }
 
     // Creates the URL to the permission Realm based on the authentication URL.
@@ -701,38 +713,38 @@ private static String getManagementRealmUrl(URL authUrl) {
         }
     }
 
+    // what defines a user is it's identity(Token) and authURL (as required by the constructor)
+    //
+    // not the list of Realms it's managing, furthermore, trying to include the `realms` in the `hashCode` will
+    // end in a StackOverFlow, since we need to calculate the `hashCode` of the SyncConfiguration which itself
+    // contains a reference to the SyncUser.
     @Override
     public boolean equals(Object o) {
-        if (this == o) { return true; }
-        if (o == null || getClass() != o.getClass()) { return false; }
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
 
-        SyncUser user = (SyncUser) o;
-
-        return syncUser.equals(user.syncUser);
+        SyncUser syncUser = (SyncUser) o;
 
+        if (!identity.equals(syncUser.identity)) return false;
+        return authenticationUrl.toExternalForm().equals(syncUser.authenticationUrl.toExternalForm());
     }
 
     @Override
     public int hashCode() {
-        return syncUser.hashCode();
+        int result = identity.hashCode();
+        result = 31 * result + authenticationUrl.toExternalForm().hashCode();
+        return result;
     }
 
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder("{");
-        sb.append("UserId: ").append(syncUser.getIdentity());
+        sb.append("UserId: ").append(identity);
         sb.append(", AuthUrl: ").append(getAuthenticationUrl());
-        sb.append(", IsValid: ").append(isValid());
-        sb.append(", Sessions: ").append(syncUser.getSessions().size());
         sb.append("}");
         return sb.toString();
     }
 
-    // Expose internal representation for other package protected classes
-    ObjectServerUser getSyncUser() {
-        return syncUser;
-    }
-
     // Class wrapping requests made against the auth server. Is also responsible for calling with success/error on the
     // correct thread.
     private static abstract class Request<T> {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index 051c9f4aa1..4de59a8788 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -32,7 +32,6 @@
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.network.NetworkStateReceiver;
-import io.realm.log.RealmLog;
 
 @SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
 @Keep
@@ -88,18 +87,7 @@ public void realmClosed(RealmConfiguration configuration) {
     public Object[] getUserAndServerUrl(RealmConfiguration config) {
         if (config instanceof SyncConfiguration) {
             SyncConfiguration syncConfig = (SyncConfiguration) config;
-            // make sure the user is still valid
             SyncUser user = syncConfig.getUser();
-            if (!user.isValid()) {
-                if (!SyncManager.getUserStore().isActive(user.getIdentity(), user.getAuthenticationUrl().toString())) {
-                    throw new IllegalStateException("The SyncUser is already logged out and can not use the provided configuration to open a Realm.");
-                } else {
-                    // user was not logged out but the `refresh_token` is not longer valid
-                    // the user will still get a stall version of Realm, that will work offline
-                    // but not sync.
-                    RealmLog.warn("The provided configuration uses an expired SyncUser token, this Realm instance will work offline.");
-                }
-            }
             String rosServerUrl = syncConfig.getServerUrl().toString();
             String rosUserIdentity = user.getIdentity();
             String syncRealmAuthUrl = user.getAuthenticationUrl().toString();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
deleted file mode 100644
index a5e731bf34..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.net.URI;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import io.realm.SyncConfiguration;
-import io.realm.SyncSession;
-
-/**
- * Internal representation of a user on the Realm Object Server.
- * The public API is defined by {@link io.realm.SyncUser}.
- */
-public class ObjectServerUser {
-
-    private final String identity;
-    private Token refreshToken;
-    private URL authenticationUrl;
-    private Map<URI, AccessDescription> realms = new HashMap<URI, AccessDescription>();
-    private List<SyncSession> sessions = new ArrayList<SyncSession>();
-    private boolean loggedIn;
-
-    /**
-     * Create a new Realm Object Server User
-     */
-    public ObjectServerUser(Token refreshToken, URL authenticationUrl) {
-        this.identity = refreshToken.identity();
-        this.authenticationUrl = authenticationUrl;
-        this.refreshToken = refreshToken;
-        this.loggedIn = true;
-    }
-
-    private void setRefreshToken(final Token refreshToken) {
-        // TODO Shouldn't we check if the identity of the new refreshToken is the same with previous identity?
-        this.refreshToken = refreshToken; // Replace any existing token. TODO re-save the user with latest token.
-    }
-
-    /**
-     * Checks if the user has access to the given Realm. Being authenticated means that the
-     * user is know by the Realm Object Server and have been granted access to the given Realm.
-     *
-     * Authenticating will happen automatically as part of opening a Realm.
-     */
-    public boolean isRealmAuthenticated(SyncConfiguration configuration) {
-        Token token = getAccessToken(configuration.getServerUrl());
-        return token != null && token.expiresMs() > System.currentTimeMillis();
-    }
-
-    public String toJson() {
-        JSONObject obj = new JSONObject();
-        try {
-            obj.put("authUrl", authenticationUrl);
-            obj.put("userToken", refreshToken.toJson());
-            JSONArray realmList = new JSONArray();
-            for (Map.Entry<URI, AccessDescription> entry : realms.entrySet()) {
-                JSONObject token = new JSONObject();
-                token.put("uri", entry.getKey().toString());
-                token.put("description", entry.getValue().toJson());
-                realmList.put(token);
-            }
-            obj.put("realms", realmList);
-            return obj.toString();
-        } catch (JSONException e) {
-            throw new RuntimeException("Could not convert User to JSON", e);
-        }
-    }
-
-    public String getIdentity() {
-        return identity;
-    }
-
-    /**
-     * Return the access token for a given Realm URL or null if none was found
-     */
-    public Token getAccessToken(URI serverUrl) {
-        AccessDescription accessDescription = realms.get(serverUrl);
-        return (accessDescription != null) ? accessDescription.accessToken : null;
-    }
-
-    void removeAccessToken(URI serverUrl) {
-        realms.remove(serverUrl);
-    }
-
-    public void addRealm(URI uri, AccessDescription description) {
-        realms.put(uri, description);
-    }
-
-    // When a session is started, add it to the user so it can be tracked
-    public void addSession(SyncSession session) {
-        sessions.add(session);
-    }
-
-    /**
-     * Adds an access token to this user.
-     * <p>
-     * An access token is a token granting access to one remote Realm. Access Tokens are normally fetched transparently
-     * when opening a Realm, but using this method it is possible to add tokens upfront if they have been fetched or
-     * created manually.
-     *
-     * @param uri {@link java.net.URI} pointing to a remote Realm.
-     * @param accessToken
-     */
-    public void addRealm(URI uri, String accessToken, String localPath, boolean deleteOnLogout) {
-        if (uri == null || accessToken == null) {
-            throw new IllegalArgumentException("Non-null 'uri' and 'accessToken' required.");
-        }
-        uri = SyncUtil.getFullServerUrl(uri, identity);
-
-        // Optimistically create a long-lived token with all permissions. If this is incorrect the Object Server
-        // will reject it anyway. If tokens are added manually it is up to the user to ensure they are also used
-        // correctly.
-        Token token = new Token(accessToken, null, uri.toString(), Long.MAX_VALUE, Token.Permission.values());
-        addRealm(uri, new AccessDescription(token, localPath, deleteOnLogout));
-    }
-
-    public URL getAuthenticationUrl() {
-        return authenticationUrl;
-    }
-
-    public Token getUserToken() {
-        return refreshToken;
-    }
-
-    public List<SyncSession> getSessions() {
-        return sessions;
-    }
-
-    // TODO merge this method into localLogout(). See https://github.com/realm/realm-java/pull/3642#discussion_r96818800
-    public void clearTokens() {
-        realms.clear();
-        refreshToken = null;
-    }
-
-    public boolean isLoggedIn() {
-        return loggedIn;
-    }
-
-    // Local Logout means that the user is no longer able to create new sync configurations,
-    // nor synchronize changes
-    public void localLogout() {
-        loggedIn = false;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        ObjectServerUser syncUser = (ObjectServerUser) o;
-
-        if (!identity.equals(syncUser.identity)) return false;
-        if (refreshToken == null) {
-            if (syncUser.refreshToken != null) return false;
-        } else {
-            if (!refreshToken.equals(syncUser.refreshToken)) return false;
-        }
-        if (!authenticationUrl.toString().equals(syncUser.authenticationUrl.toString())) return false;
-        return realms.equals(syncUser.realms);
-    }
-
-    @Override
-    public int hashCode() {
-        int result = identity.hashCode();
-        result = 31 * result + (refreshToken == null ? 0 : refreshToken.hashCode());
-        result = 31 * result + authenticationUrl.toString().hashCode();
-        result = 31 * result + realms.hashCode();
-        return result;
-    }
-
-    public Collection<AccessDescription> getRealms() {
-        return realms.values();
-    }
-
-    public boolean isAdmin() {
-        return refreshToken.isAdmin();
-    }
-
-    // Wrapper for all Realm data needed by a User that might get serialized.
-    public static class AccessDescription {
-        public Token accessToken;
-        public String localPath;
-        public boolean deleteOnLogout;
-
-        public AccessDescription(Token accessToken, String localPath, boolean deleteOnLogout) {
-            this.accessToken = accessToken;
-            this.localPath = localPath;
-            this.deleteOnLogout = deleteOnLogout;
-        }
-
-        public static AccessDescription fromJson(JSONObject json) {
-            try {
-                Token token = Token.from(json.getJSONObject("accessToken"));
-                String localPath = json.getString("localPath");
-                boolean deleteOnLogout = json.getBoolean("deleteOnLogout");
-                return new AccessDescription(token, localPath, deleteOnLogout);
-            } catch (JSONException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        public JSONObject toJson() {
-            try {
-                JSONObject obj = new JSONObject();
-                obj.put("accessToken", accessToken.toJson());
-                obj.put("localPath", localPath);
-                obj.put("deleteOnLogout", deleteOnLogout);
-                return obj;
-            } catch (JSONException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            AccessDescription that = (AccessDescription) o;
-
-            if (deleteOnLogout != that.deleteOnLogout) return false;
-            if (!accessToken.equals(that.accessToken)) return false;
-            return localPath.equals(that.localPath);
-
-        }
-
-        @Override
-        public int hashCode() {
-            int result = accessToken.hashCode();
-            result = 31 * result + localPath.hashCode();
-            result = 31 * result + (deleteOnLogout ? 1 : 0);
-            return result;
-        }
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
deleted file mode 100644
index 9d6b8f1e23..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-/**
- * Helper class for Object Server classes.
- */
-public class SyncUtil {
-
-    /**
-     * Fully resolve an URL so all placeholder objects are replaced with the user identity.
-     */
-    public static URI getFullServerUrl(URI serverUrl, String userIdentity) {
-        try {
-            return new URI(serverUrl.toString().replace("/~/", "/" + userIdentity + "/"));
-        } catch (URISyntaxException e) {
-            throw new IllegalArgumentException("Could not replace '/~/' with a valid user ID.", e);
-        }
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index 8b79a0776a..fc834ea91c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -26,7 +26,6 @@
 import java.io.File;
 import java.util.Random;
 import java.util.UUID;
-import java.util.concurrent.TimeUnit;
 
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 49c83e60d6..c2c982888e 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -2,16 +2,22 @@
 
 import android.os.Handler;
 import android.os.Looper;
+import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Assert;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.lang.reflect.Field;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -27,20 +33,34 @@
 import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.SyncUserInfo;
+import io.realm.entities.StringOnly;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.objectserver.Token;
 import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestSyncConfigurationFactory;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.greaterThan;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 
 @RunWith(AndroidJUnit4.class)
 public class AuthTests extends BaseIntegrationTest {
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
     @Test
     public void login_userNotExist() {
@@ -95,6 +115,7 @@ public void onError(ObjectServerError error) {
     }
 
     // FIXME: https://github.com/realm/realm-java/issues/4711
+    // fail may be related to this issue https://github.com/realm/realm-java/issues/5068
     @Test
     @RunTestInLooperThread
     @Ignore("This fails expectSimpleCommit for some reasons, needs to be FIXED ASAP.")
@@ -261,56 +282,81 @@ public void onError(ObjectServerError error) {
     }
 
     @Test
+    @RunTestInLooperThread
     public void changePassword_throwWhenUserIsLoggedOut() {
         String username = UUID.randomUUID().toString();
         String password = "password";
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
         SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        user.logout();
+        SyncManager.addAuthenticationListener(new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                // callback is happening on different thread, all assertions needs to be done on looper thread
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        fail("loggedIn should not be invoked");
+                    }
+                });
+            }
 
-        thrown.expect(ObjectServerError.class);
-        user.changePassword("new-password");
+            @Override
+            public void loggedOut(SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                try {
+                    user.changePassword("new-password");
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            fail("changePassword should throw ObjectServerError (INVALID CREDENTIALS)");
+                        }
+                    });
+                } catch (ObjectServerError expected) {
+                }
+                looperThread.testComplete();
+            }
+        });
+        user.logout();
     }
 
-    // Cached instances of RealmConfiguration should not be allowed to be used if the user is no longer valid
     @Test
-    public void cachedInstanceShouldThrowIfUserBecomeInvalid() throws InterruptedException {
+    public void cachedInstanceShouldNotThrowIfRefreshTokenExpires() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
 
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncUser user = spy(SyncUser.login(credentials, Constants.AUTH_URL));
+
+        when(user.isValid()).thenReturn(true, false);
+
         final RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
         Realm realm = Realm.getInstance(configuration);
 
-        user.logout();
         assertFalse(user.isValid());
+        verify(user, times(2)).isValid();
 
         final CountDownLatch backgroundThread = new CountDownLatch(1);
-        // Should throw when using the invalid configuration form a different thread
+        // Should not throw when using an expired refresh_token form a different thread
+        // It should be able to open a Realm with an expired token
         new Thread() {
             @Override
             public void run() {
-                try {
-                    Realm.getInstance(configuration);
-                    fail("Invalid SyncConfiguration should throw");
-                } catch (IllegalStateException expected) {
-                } finally {
-                    backgroundThread.countDown();
-                }
+                Realm instance = Realm.getInstance(configuration);
+                instance.close();
+                backgroundThread.countDown();
             }
         }.start();
 
         backgroundThread.await();
 
-        // it is ok to return the cached instance, since this use case is legit
-        // user refresh token can timeout, or the token can be revoked from ROS
-        // while running the Realm instance. So it doesn't make sense to break this behaviour
+        // It should be possible to open a cached Realm with expired token
         Realm cachedInstance = Realm.getInstance(configuration);
         assertNotNull(cachedInstance);
 
         realm.close();
         cachedInstance.close();
+        user.logout();
     }
 
     @Test
@@ -342,7 +388,7 @@ public void buildingSyncConfigurationShouldThrowIfInvalidUser() {
         }
     }
 
-    // using a logout user should throw
+    // using a logout user should not throw
     @Test
     public void usingConfigurationWithInvalidUserShouldThrow() {
         String username = UUID.randomUUID().toString();
@@ -354,26 +400,16 @@ public void usingConfigurationWithInvalidUserShouldThrow() {
         user.logout();
         assertFalse(user.isValid());
 
-        try {
-            Realm.getInstance(configuration);
-            fail("SyncUser is not longer valid, it should not be possible to get a Realm instance");
-        } catch (IllegalStateException expected) {
-        }
+        Realm instance = Realm.getInstance(configuration);
+        instance.close();
     }
 
     @Test
     public void logout_currentUserMoreThanOne() {
-        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        final RealmConfiguration config1 = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
-                .build();
+        UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncUser.currentUser().logout();
-        SyncUser user2 = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        try {
-            Realm.getInstance(config1);
-            fail("SyncUser is not longer valid, it should not be possible to get a Realm instance");
-        } catch (IllegalStateException expected) {
-        }
-        assertEquals(user2, SyncUser.currentUser());
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        assertEquals(user, SyncUser.currentUser());
     }
 
     // logging out 'user' should have the same impact on other instance(s) of the same user
@@ -464,6 +500,98 @@ public void singleUserCanBeLoggedInAndOutRepeatedly() {
         }
     }
 
+    @Test
+    public void revokedRefreshTokenIsNotSameAfterLogin() throws InterruptedException {
+        final String uniqueName = UUID.randomUUID().toString();
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        Token revokedRefreshToken = user.getAccessToken();
+
+        user.logout();
+
+        credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+        SyncUser loggedInUser = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        // still comparing the same user
+        Assert.assertEquals(revokedRefreshToken.identity(), loggedInUser.getAccessToken().identity());
+        // different tokens
+        assertNotEquals(revokedRefreshToken.value(), loggedInUser.getAccessToken().value());
+    }
+
+    // The pre-emptive token refresh subsystem should function, and properly refresh the access token.
+    // WARNING: this test can fail if there's a difference between the server's and device's clock, causing the
+    // refresh access token to be too far in time.
+    @Test(timeout = 30000)
+    public void preemptiveTokenRefresh() throws NoSuchFieldException, IllegalAccessException, InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+
+        // make the access tokens map accessible
+        Field realmsField = SyncUser.class.getDeclaredField("realms");
+        realmsField.setAccessible(true);
+        @SuppressWarnings("unchecked") // using reflection
+        Map<SyncConfiguration, Token> accessTokens = (Map<SyncConfiguration, Token>) realmsField.get(user);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        Assert.fail(error.getErrorMessage());
+                    }
+                })
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        // create and wait for a transaction to be uploaded,
+        // this guarantees that an accessToken is available
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("1");
+            }
+        });
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.uploadAllLocalChanges();
+
+        assertFalse(accessTokens.isEmpty());
+        Assert.assertEquals(1, accessTokens.size());
+        Map.Entry<SyncConfiguration, Token> entry = accessTokens.entrySet().iterator().next();
+        Assert.assertEquals(syncConfiguration, entry.getKey());
+
+        final Token accessToken = entry.getValue();
+        Assert.assertNotNull(accessToken);
+
+        // getting refresh token delay
+        Field refreshTokenTaskField = SyncSession.class.getDeclaredField("refreshTokenTask");
+        refreshTokenTaskField.setAccessible(true);
+        RealmAsyncTaskImpl task = (RealmAsyncTaskImpl) refreshTokenTaskField.get(session);
+        Field pendingTaskField = RealmAsyncTaskImpl.class.getDeclaredField("pendingTask");
+        pendingTaskField.setAccessible(true);
+        ScheduledFuture<?> pendingTask = (ScheduledFuture<?>) pendingTaskField.get(task);
+        long nextRefreshTokenRefreshQueryDelay = pendingTask.getDelay(TimeUnit.MILLISECONDS);
+
+        // current configuration 'realm-java/tools/sync_test_server/configuration.yml'
+        // is setting the access token to expire every 20 seconds 'access_token: 20'
+        // we wait approximately actually 10 seconds since the SyncSession.REFRESH_MARGIN_DELAY is 10s
+        SystemClock.sleep(nextRefreshTokenRefreshQueryDelay);
+
+        // allow 3 seconds for the query to perform and complete
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(3));
+
+        Token newAccessToken = accessTokens.get(syncConfiguration);
+
+        assertThat("new Token is not expired", newAccessToken.expiresMs(), greaterThan(System.currentTimeMillis()));
+        assertNotEquals(accessToken, newAccessToken);
+
+        // refresh_token identity is the same
+        Assert.assertEquals(user.getAccessToken().identity(), newAccessToken.identity());
+        Assert.assertEquals(accessToken.identity(), newAccessToken.identity());
+
+        realm.close();
+    }
+
     @Test
     public void retrieve() {
         final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index dc83c2f862..5d02db4426 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -2,13 +2,14 @@
 
 import android.os.SystemClock;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
@@ -21,6 +22,7 @@
 import io.realm.SyncUser;
 import io.realm.TestHelper;
 import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmError;
 import io.realm.exceptions.RealmFileException;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
@@ -95,10 +97,8 @@ public void onError(SyncSession session, ObjectServerError error) {
     }
 
     // If an encrypted synced Realm is re-opened with the wrong key, throw an exception.
-    // TODO: enable again once https://github.com/realm/realm-java/pull/4707 is merged
-    @Ignore("This test crash the Sync client thread")
     @Test
-    public void setEncryptionKey_shouldCrashIfKeyNotProvided() {
+    public void setEncryptionKey_shouldCrashIfKeyNotProvided() throws InterruptedException {
         // STEP 1: open a synced Realm using a local encryption key
         String username = UUID.randomUUID().toString();
         String password = "password";
@@ -126,8 +126,22 @@ public void onError(SyncSession session, ObjectServerError error) {
         realm.commitTransaction();
 
         // STEP 2: make sure the changes gets to the server
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
-        realm.close(); // Realm is not deleted, just closed
+        SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
+
+        final CountDownLatch backgroundException = new CountDownLatch(1);
+        final AtomicBoolean exceptionThrown = new AtomicBoolean(false);
+
+        Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+            @Override
+            public void uncaughtException(Thread t, Throwable e) {
+                if (e instanceof RealmError && e.getMessage().contains("An exception has been thrown on the sync client thread")) {
+                    exceptionThrown.set(true);
+                }
+                backgroundException.countDown();
+            }
+        });
+        realm.close();
         user.logout();
 
         // STEP 3: try to open again the Realm without the encryption key should fail
@@ -148,6 +162,11 @@ public void onError(SyncSession session, ObjectServerError error) {
             fail("It should not be possible to open the Realm without the encryption key set previously.");
         } catch (RealmFileException ignored) {
         }
+
+        TestHelper.awaitOrFail(backgroundException);
+        // restore default handler
+        Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
+        assertTrue("Sync Client Thread should throw an exception", exceptionThrown.get());
     }
 
     // If client B encrypts its synced Realm, client A should be able to access that Realm with a different encryption key.
@@ -230,10 +249,10 @@ public void onError(SyncSession session, ObjectServerError error) {
         assertEquals("Hi Alice", allSortedAdmin.get(0).getChars());
         assertEquals("Hi Bob", allSortedAdmin.get(1).getChars());
 
+        adminRealm.close();
         adminUser.logout();
-        user.logout();
 
         realm.close();
-        adminRealm.close();
+        user.logout();
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
index a46591ca58..3d344f46b5 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
@@ -1,27 +1,39 @@
 package io.realm.objectserver;
 
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
 import android.os.SystemClock;
-import android.support.test.annotation.UiThreadTest;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.TimeUnit;
+import java.util.Arrays;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
 
 import io.realm.BaseIntegrationTest;
 import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
+import io.realm.TestHelper;
 import io.realm.entities.AllTypes;
+import io.realm.entities.StringOnly;
 import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestSyncConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
@@ -29,12 +41,11 @@
     @Rule
     public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
-    @Test
+    @Test(timeout=3000)
     public void getState_active() {
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncConfiguration syncConfiguration = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .waitForInitialRemoteData()
                 .build();
         Realm realm = Realm.getInstance(syncConfiguration);
 
@@ -42,44 +53,45 @@ public void getState_active() {
 
         // make sure the `access_token` is acquired. otherwise we can still be
         // in WAITING_FOR_ACCESS_TOKEN state
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));
+        while(session.getState() != SyncSession.State.ACTIVE) {
+            SystemClock.sleep(200);
+        }
 
-        assertEquals(SyncSession.State.ACTIVE, session.getState());
         realm.close();
     }
 
     @Test
-    public void getState_inactive() {
+    public void getState_throwOnClosedSession() {
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncConfiguration syncConfiguration = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .waitForInitialRemoteData()
                 .build();
         Realm realm = Realm.getInstance(syncConfiguration);
 
         SyncSession session = SyncManager.getSession(syncConfiguration);
-        user.logout();
-        assertEquals(SyncSession.State.INACTIVE, session.getState());
-
         realm.close();
+        user.logout();
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage("Could not find session, Realm was probably closed");
+        session.getState();
     }
 
     @Test
-    public void getState_closedRealm() {
+    public void getState_loggedOut() {
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncConfiguration syncConfiguration = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .waitForInitialRemoteData()
                 .build();
         Realm realm = Realm.getInstance(syncConfiguration);
 
         SyncSession session = SyncManager.getSession(syncConfiguration);
+
+        user.logout();
+
+        SyncSession.State state = session.getState();
+        assertEquals(SyncSession.State.INACTIVE, state);
+
         realm.close();
-        try {
-            session.getState();
-            fail("Realm was closed, getState should not return");
-        } catch (IllegalStateException expected) {
-        }
     }
 
     @Test
@@ -106,4 +118,274 @@ public void uploadDownloadAllChanges() throws InterruptedException {
         assertEquals(1, adminRealm.where(AllTypes.class).count());
         adminRealm.close();
     }
+
+    // check that logging out a SyncUser used by different Realm will
+    // affect all associated sessions.
+    @Test(timeout=5000)
+    public void logout_sameSyncUserMultipleSessions() {
+        String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user =  SyncUser.login(credentials, Constants.AUTH_URL);
+
+        SyncConfiguration syncConfiguration1 = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm1 = Realm.getInstance(syncConfiguration1);
+
+        SyncConfiguration syncConfiguration2 = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL_2)
+                .build();
+        Realm realm2 = Realm.getInstance(syncConfiguration2);
+
+        SyncSession session1 = SyncManager.getSession(syncConfiguration1);
+        SyncSession session2 = SyncManager.getSession(syncConfiguration2);
+
+        // make sure the `access_token` is acquired. otherwise we can still be
+        // in WAITING_FOR_ACCESS_TOKEN state
+        while(session1.getState() != SyncSession.State.ACTIVE || session2.getState() != SyncSession.State.ACTIVE) {
+            SystemClock.sleep(200);
+        }
+        assertEquals(SyncSession.State.ACTIVE, session1.getState());
+        assertEquals(SyncSession.State.ACTIVE, session2.getState());
+        assertNotEquals(session1, session2);
+
+        assertEquals(session1.getUser(), session2.getUser());
+
+        user.logout();
+
+        assertEquals(SyncSession.State.INACTIVE, session1.getState());
+        assertEquals(SyncSession.State.INACTIVE, session2.getState());
+
+        credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+        SyncUser.login(credentials, Constants.AUTH_URL);
+
+        // reviving the sessions
+        assertEquals(SyncSession.State.WAITING_FOR_ACCESS_TOKEN, session1.getState());
+        assertEquals(SyncSession.State.WAITING_FOR_ACCESS_TOKEN, session2.getState());
+
+        realm1.close();
+        realm2.close();
+    }
+
+    // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
+    @Test
+    public void logBackResumeUpload() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .build();
+        final Realm realm = Realm.getInstance(syncConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("1");
+            }
+        });
+
+        final SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.uploadAllLocalChanges();
+
+        user.logout();
+
+        // add a commit while we're still offline
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("2");
+            }
+        });
+
+        final CountDownLatch testCompleted = new CountDownLatch(1);
+
+        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
+        handlerThread.start();
+        Looper looper = handlerThread.getLooper();
+        Handler handler = new Handler(looper);
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                // access the Realm from an different path on the device (using admin user), then monitor
+                // when the offline commits get synchronized
+                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                        .modules(new StringOnlyModule())
+                        .waitForInitialRemoteData()
+                        .build();
+                final Realm adminRealm = Realm.getInstance(adminConfig);
+
+                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+                RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
+                    @Override
+                    public void onChange(RealmResults<StringOnly> stringOnlies) {
+                        if (stringOnlies.size() == 2) {
+                            Assert.assertEquals("1", stringOnlies.get(0).getChars());
+                            Assert.assertEquals("2", stringOnlies.get(1).getChars());
+                            adminRealm.close();
+                            testCompleted.countDown();
+                            handlerThread.quit();
+                        }
+                    }
+                };
+                all.addChangeListener(realmChangeListener);
+
+                // login again to re-activate the user
+                SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+                // this login will re-activate the logged out user, and resume all it's pending sessions
+                // the OS will trigger bindSessionWithConfig with the new refresh_token, in order to obtain
+                // a new access_token.
+                SyncUser.login(credentials, Constants.AUTH_URL);
+            }
+        });
+
+        TestHelper.awaitOrFail(testCompleted, 60);
+    }
+
+    // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
+    // this test validate the behaviour of SyncSessionStopPolicy::AfterChangesUploaded
+    @Test
+    public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final char[] chars = new char[1_000_000];// 2MB
+        Arrays.fill(chars, '.');
+        final String twoMBString = new String(chars);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        realm.beginTransaction();
+        // upload 50MB
+        for (int i = 0; i < 25; i++) {
+            realm.createObject(StringOnly.class).setChars(twoMBString);
+        }
+        realm.commitTransaction();
+        realm.close();
+
+        final CountDownLatch testCompleted = new CountDownLatch(1);
+
+        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
+        handlerThread.start();
+        Looper looper = handlerThread.getLooper();
+        Handler handler = new Handler(looper);
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                // using an admin user to open the Realm on different path on the device to monitor when all the uploads are done
+                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                        .modules(new StringOnlyModule())
+                        .build();
+                final Realm adminRealm = Realm.getInstance(adminConfig);
+                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();
+                RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
+                    @Override
+                    public void onChange(RealmResults<StringOnly> stringOnlies) {
+                        if (stringOnlies.size() == 25) {
+                            for (int i = 0; i < 25; i++) {
+                                assertEquals(1_000_000, stringOnlies.get(i).getChars().length());
+                            }
+                            adminRealm.close();
+                            testCompleted.countDown();
+                            handlerThread.quit();
+                        }
+                    }
+                };
+                all.addChangeListener(realmChangeListener);
+            }
+        });
+
+        TestHelper.awaitOrFail(testCompleted, 60);
+
+        user.logout();
+        realm.close();
+    }
+
+    // A Realm that was opened before a user logged out should be able to resume downloading if the user logs back in.
+    @Test
+    public void downloadChangesWhenRealmOutOfScope() throws InterruptedException {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("1");
+        realm.commitTransaction();
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.uploadAllLocalChanges();
+
+        // Log out the user.
+        user.logout();
+
+        // Log the user back in.
+        credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+        SyncUser.login(credentials, Constants.AUTH_URL);
+
+        // now let the admin upload some commits
+        final CountDownLatch backgroundUpload = new CountDownLatch(1);
+
+        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
+        handlerThread.start();
+        Looper looper = handlerThread.getLooper();
+        Handler handler = new Handler(looper);
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                // using an admin user to open the Realm on different path on the device then some commits
+                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                        .modules(new StringOnlyModule())
+                        .waitForInitialRemoteData()
+                        .build();
+
+                final Realm adminRealm = Realm.getInstance(adminConfig);
+                adminRealm.beginTransaction();
+                adminRealm.createObject(StringOnly.class).setChars("2");
+                adminRealm.createObject(StringOnly.class).setChars("3");
+                adminRealm.commitTransaction();
+
+                try {
+                    SyncManager.getSession(adminConfig).uploadAllLocalChanges();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                    fail(e.getMessage());
+                }
+
+                backgroundUpload.countDown();
+                handlerThread.quit();
+            }
+        });
+
+        TestHelper.awaitOrFail(backgroundUpload, 60);
+        // Resume downloading
+        session.downloadAllServerChanges();
+        realm.refresh();//FIXME not calling refresh will still point to the previous version of the Realm count == 1
+        assertEquals(3, realm.where(StringOnly.class).count());
+        realm.close();
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index f1956b5251..d2be7cbc90 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -21,7 +21,7 @@
     public static final String USER_REALM = "realm://127.0.0.1:9080/~/tests";
     public static final String USER_REALM_SECURE = "realms://127.0.0.1:9443/~/tests";
     public static final String SYNC_SERVER_URL = "realm://127.0.0.1:9080/~/tests";
-    public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
+    public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/~/tests2";
 
     public static final String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
     public static final String AUTH_URL = AUTH_SERVER_URL + "auth";
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
index e3440d05bb..a0e17934b2 100644
--- a/tools/sync_test_server/configuration.yml
+++ b/tools/sync_test_server/configuration.yml
@@ -62,7 +62,10 @@ auth:
     ## The validity duration for Access Tokens. This should be a fairly small
     ## number, especially if you are concerned with revocations being applied
     ## quickly. This value is represented in seconds. Default: 1 minute.
-    # access_token: 60
+    ##
+    ## WARNING : Changing this value may impact the timeout of the refresh
+    ##           token test (AuthTests#preemptiveTokenRefresh)
+    access_token: 20
 
   providers:
     ## Providers of authentication tokens. Each provider has a configuration
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index 18d2139081..8905ec397c 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -7,6 +7,26 @@ const exec = require('child_process').exec;
 var http = require('http');
 var dispatcher = require('httpdispatcher');
 
+// this query is used to check if ROS has started
+// while waiting for a permanante fix in https://github.com/realm/realm-object-server/issues/1297.
+// query should return 200 with the JSON payload Ex: {"version":"1.8.1","flavor":"developer","setupRequired":true}
+var options = {
+  hostname: '127.0.0.1',
+  port: 9080,
+  path: '/api/info',
+  method: 'GET'
+};
+
+function tryUntilROSStart(options, callback) {
+    var req = http.request(options, function(res) {
+        callback(null, res);
+    });
+    req.on('error', function(e) {
+        tryUntilROSStart(options, callback);
+    });
+    req.end();
+}
+
 // Automatically track and cleanup files at exit
 temp.track();
 
@@ -34,12 +54,6 @@ function handleRequest(request, response) {
 var syncServerChildProcess = null;
 
 function startRealmObjectServer(done) {
-    // Hack for checking the ROS is fully initialized.
-    // Consider the ROS is initialized fully only if log below shows twice
-    // "client: Closing Realm file: /tmp/ros117521-7-1eiqt7a/internal_data/permission/__auth.realm"
-    // https://github.com/realm/realm-object-server/issues/1297
-    var logFindingCounter = 2
-
     stopRealmObjectServer(function(err) {
         if(err) {
           return;
@@ -56,12 +70,6 @@ function startRealmObjectServer(done) {
                         { env: env, cwd: path});
                 // local config:
                 syncServerChildProcess.stdout.on('data', (data) => {
-                    if (logFindingCounter != 0 && /client: Closing Realm file: .*__auth.realm/.test(data)) {
-                        if (logFindingCounter == 1) {
-                            done()
-                        }
-                        logFindingCounter--
-                    }
                     winston.info(`stdout: ${data}`);
                 });
 
@@ -72,6 +80,11 @@ function startRealmObjectServer(done) {
                 syncServerChildProcess.on('close', (code) => {
                     winston.info(`child process exited with code ${code}`);
                 });
+
+                tryUntilROSStart(options, function(err, resp) {
+                    winston.info('>>>>>>>>>>>>>>>>>>> [ROS] server started <<<<<<<<<<<<<<<<<<<');
+                    done()
+                });
             }
         });
     });
@@ -94,7 +107,7 @@ function stopRealmObjectServer(callback) {
 dispatcher.onGet("/start", function(req, res) {
     startRealmObjectServer(() => {
         res.writeHead(200, {'Content-Type': 'text/plain'});
-        res.end('Starting a server');
+        res.end('Server started');
     })
 });
 
