diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3e2532e149..aab89cd4b6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,10 @@
+## 4.4.0 (YYYY-MM-DD)
+
+### Enhancements
+
+* Added support for mapping between a Java name and the underlying name in the Realm file using `@RealmModule`, `@RealmClass` and `@RealmField` annotations (#5280).
+
+
 ## 4.3.3 (2018-01-19)
 
 ### Internal
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java b/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
index d0ab776fbb..b4a3abb695 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
@@ -23,9 +23,29 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+/**
+ * Interface used to mark a class that can be persisted by Realm.
+ */
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 @Inherited
 public @interface RealmClass {
 
+    /**
+     * Manually set the internal name used by Realm for this class. If this class is part of
+     * any modules, this will also override any name policy set using
+     * {@link RealmModule#classNamingPolicy()}.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting the name means.
+     */
+    String name() default "";
+
+    /**
+     * The naming policy applied to all fields in this class. The default policy is {@link RealmNamingPolicy#NO_POLICY}.
+     * <p>
+     * It is possible to override the naming policy for each field by using the {@link RealmField} annotation.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting this policy means.
+     */
+    RealmNamingPolicy fieldNamingPolicy() default RealmNamingPolicy.NO_POLICY;
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmField.java b/realm-annotations/src/main/java/io/realm/annotations/RealmField.java
new file mode 100644
index 0000000000..0cdc67f6fd
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmField.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.annotations;
+
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotation used on fields in Realm model classes. It describes metadata about the field.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+@Inherited
+public @interface RealmField {
+
+    /**
+     * Manually set the internal name used by Realm for this field. This will override any
+     * {@link RealmNamingPolicy} set on the class or the module.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting the name means.
+     */
+    String name() default "";
+}
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
index c8690de362..2928b1cd22 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -93,4 +93,29 @@
      * an exception.
      */
     Class<?>[] classes() default {};
+
+    /**
+     * The naming policy applied to all classes part of this module. The default policy is {@link RealmNamingPolicy#NO_POLICY}.
+     * To define a naming policy for all fields in the classes, use {@link #fieldNamingPolicy()}.
+     * <p>
+     * It is possible to override the naming policy specified in the module in each class using the {@link RealmClass}
+     * annotation.
+     * <p>
+     * If a class is part of multiple modules, the same naming policy must be applied to both modules, otherwise
+     * an error will be thrown.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting this policy means.
+     */
+    RealmNamingPolicy classNamingPolicy() default RealmNamingPolicy.NO_POLICY;
+
+    /**
+     * The naming policy applied to all field names in all classes part of this module. The default policy is
+     * {@link RealmNamingPolicy#NO_POLICY}. To define a naming policy for class names, use {@link #classNamingPolicy()}.
+     * <p>
+     * It is possible to override this naming policy using either {@link RealmClass#fieldNamingPolicy()} or
+     * {@link RealmField#name()}.
+     *
+     * @see io.realm.annotations.RealmNamingPolicy for more information about what setting this policy means.
+     */
+    RealmNamingPolicy fieldNamingPolicy() default RealmNamingPolicy.NO_POLICY;
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmNamingPolicy.java b/realm-annotations/src/main/java/io/realm/annotations/RealmNamingPolicy.java
new file mode 100644
index 0000000000..2e2aac3608
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmNamingPolicy.java
@@ -0,0 +1,170 @@
+package io.realm.annotations;
+
+/**
+ * This enum defines the possible ways class and field names can be mapped from what is used in Java
+ * to the name used internally in the Realm file.
+ * <p>
+ * Examples where this is useful:
+ * <ul>
+ *      <li>
+ *          To support two model classes with the same simple name but in different packages.
+ *      </li>
+ *      <li>
+ *          To make it easier to work with cross platform schemas as naming conventions are different.
+ *      </li>
+ *      <li>
+ *          To use a Java class name that is longer than the 57 character limit enforced by Realm.
+ *      </li>
+ *      <li>
+ *          To change a field name in Java without forcing app users through a migration process.
+ *      </li>
+ * </ul>
+ *
+ * Depending on where the policy is applied, it will have slightly different semantics:
+ * <ul>
+ *     <li>
+ *         If applied to {@link RealmModule#classNamingPolicy} all classes part of that module
+ *         will be affected. If a class is part of multiple modules, the same naming policy must be
+ *         applied to both modules, otherwise an error will be thrown.
+ *     </li>
+ *     <li>
+ *         If applied to {@link RealmModule#fieldNamingPolicy} all persistable fields in all classes
+ *         part of this module will be affected.
+ *     </li>
+ *
+ *      <li>
+ *          If applied to {@link RealmClass#fieldNamingPolicy} all fields in that class will be
+ *          affected. This will override any field naming policy specified on a module.
+ *      </li>
+ * </ul>
+ * <p>
+ * An example of this:
+ * <pre>
+ * {@code
+ * \@RealmClass(name = "__person", fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
+ * public class Person implements RealmModel { // is converted to "__person" internally
+ *     public string firstName; // Is converted to "first_name" internally
+ * }
+ * }
+ * </pre>
+ * <p>
+ * Choosing an internal name that differs from the name used in the Java model classes has the
+ * following implications:
+ * <ul>
+ *      <li>
+ *          Queries on {@code DynamicRealm} must use the internal name. Queries on normal {@code Realm}
+ *          instances must continue to use the name as it is defined in the Java class.
+ *      </li>
+ *      <li>
+ *          Migrations must use the internal name when creating classes and fields.
+ *      </li>
+ *      <li>
+ *          Schema errors reported will use the internal names.
+ *      </li>
+ * </ul>
+ * <p>
+ * When automatically converting Java variable names, each variable name is normalized by splitting
+ * it into a list of words that are then joined using the rules of the target format. The following
+ * heuristics are used for determining what constitutes a "word".
+ * <ol>
+ *     <li>
+ *         Anytime a {@code _} or {@code $} is encountered.
+ *         Examples are "_FirstName", "_First_Name" and "$First$Name" which all becomes "First" and "Name".
+ *     </li>
+ *     <li>
+ *         Anytime you switch from a lower case character to an upper case character as
+ *         identified by {@link Character#isUpperCase(int)} and {@link Character#isLowerCase(int)}.
+ *         Example is "FirstName" which becomes "First" and "Name".
+ *     </li>
+ *     <li>
+ *         Anytime you switch from more than one uppercase character to a lower case one. The last
+ *         upper case letter is assumed to be part of the next word. This is identified by using
+ *         {@link Character#isUpperCase(int)} and {@link Character#isLowerCase(int)}.
+ *         Example is "FIRSTName" which becomes "FIRST" and "Name.
+ *     </li>
+ *     <li>
+ *         Some characters like emojiis are neither uppercase nor lowercase characters, so they will
+ *         be part of the current word.
+ *         Examples are "myüòÅ" and "MYüòÅ" which are both treated as one word.
+ *     </li>
+ *     <li>
+ *         Hungarian notation, i.e. variable names starting with lowercase "m" followed by uppercase
+ *         letter is stripped and not considered part of any word.
+ *         Example is "mFirstName" and "mFIRSTName" which becomes "First" and "Name.
+ *     </li>
+ * </ol>
+ * <p>
+ * Note that changing the internal name does <i>NOT</i> affect importing data from JSON. The JSON
+ * data must still follow the names as defined in the Realm Java class.
+ * <p>
+ * When it comes to parsing JSON using standard libraries like Moshi, GSON or Jackson it is
+ * important to keep in mind that these libraries define the transformation from JSON to Java
+ * while setting internal Realm names define the transformation from Java to the Realm file.
+ * <p>
+ * This means that if you want to import data into Realm from JSON using these libraries you still
+ * need to provide the annotations from both the JSON parser library and Realm.
+ * <p>
+ * Using Moshi, it would look something like this:
+ * <pre>
+ * {@code
+ * public class Person extends RealmObject {
+ *     \@Json(name = "first_name") // Name used in JSON input.
+ *     \@RealmField(name = "first_name") // Name used internally in the Realm file.
+ *     public string firstName; // name used in Java
+ * }
+ * }
+ * </pre>
+ *
+ * @see RealmModule
+ * @see RealmClass
+ * @see RealmField
+ */
+public enum RealmNamingPolicy {
+
+    /**
+     * No policy is applied. This policy will not override any policy set on a parent element, e.g.
+     * if set in {@link RealmClass#fieldNamingPolicy}, the module policy will still apply to field
+     * names.
+     * <p>
+     * If two modules disagree on the policy and one of them is {@code NO_POLICY}, the other will
+     * be chosen without an error being thrown.
+     * <p>
+     * This policy is the default.
+     */
+    NO_POLICY,
+
+    /**
+     * The name in the Java model class is used as is internally.
+     */
+    IDENTITY,
+
+    /**
+     * The name in the Java model class is converted to camelCase, i.e. all words are joined
+     * together with the first letter in the first word lower cased, and the first letter of
+     * all subsequent words upper cased. This is the standard naming schema in Java, Kotlin, Swift
+     * and JavaScript.
+     * <p>
+     * Examples: "firstName", "FirstName", "mFirstName", "FIRST_NAME", "First$Name" all becomes
+     * "firstName".
+     */
+    CAMEL_CASE,
+
+    /**
+     * The name in the Java model class is converted to PascalCase, i.e. all words are joined
+     * together with the first letter of all words upper cased. This is the default naming scheme
+     * in .NET.
+     * <p>
+     * Examples: "firstName", "FirstName", "mFirstName", "FIRST_NAME", "First$Name" all becomes
+     * "FirstName".
+     */
+    PASCAL_CASE,
+
+    /**
+     * The name in the Java model class is converted lowercase with each word separated by {@code _}.
+     * This is the default naming scheme in C++.
+     * <p>
+     * Examples: "firstName", "FirstName", "mFirstName", "FIRST_NAME", "First$Name" all becomes
+     * "first_name".
+     */
+    LOWER_CASE_WITH_UNDERSCORES
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.java
new file mode 100644
index 0000000000..c500785d67
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Wrapper around all Realm model classes metadata found during processing. It also
+ * allows easy lookup for specific class data.
+ */
+public class ClassCollection {
+
+    // These three collections should always stay in sync
+    private Map<String, ClassMetaData> simpleNameClassMap = new LinkedHashMap<>();
+    private Map<String, ClassMetaData> qualifiedNameClassMap = new LinkedHashMap<>();
+    private Set<ClassMetaData> classSet = new LinkedHashSet<>();
+
+    public void addClass(ClassMetaData metadata) {
+        classSet.add(metadata);
+        simpleNameClassMap.put(metadata.getSimpleJavaClassName(), metadata);
+        qualifiedNameClassMap.put(metadata.getFullyQualifiedClassName(), metadata);
+    }
+
+    public Set<ClassMetaData> getClasses() {
+        return Collections.unmodifiableSet(classSet);
+    }
+
+    public ClassMetaData getClassFromSimpleName(String simpleJavaClassName) {
+        ClassMetaData data = simpleNameClassMap.get(simpleJavaClassName);
+        if (data == null) {
+            throw new NullPointerException("Class " + simpleJavaClassName + " was not found");
+        }
+        return data;
+    }
+
+    public ClassMetaData getClassFromQualifiedName(String qualifiedJavaClassName) {
+        ClassMetaData data = qualifiedNameClassMap.get(qualifiedJavaClassName);
+        if (data == null) {
+            throw new NullPointerException("Class " + qualifiedJavaClassName + " was not found");
+        }
+        return data;
+    }
+
+    public int size() {
+        return classSet.size();
+    }
+
+    public boolean containsQualifiedClass(String qualifiedClassName) {
+        return qualifiedNameClassMap.containsKey(qualifiedClassName);
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index cb8b7a54c7..8fc5378619 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -44,7 +44,11 @@
 import io.realm.annotations.Index;
 import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
 import io.realm.annotations.Required;
+import io.realm.processor.nameconverter.NameConverter;
 
 
 /**
@@ -52,14 +56,15 @@
  */
 public class ClassMetaData {
     private static final String OPTION_IGNORE_KOTLIN_NULLABILITY = "realm.ignoreKotlinNullability";
+    private static final int MAX_CLASSNAME_LENGTH = 57;
 
     private final TypeElement classType; // Reference to model class.
-    private final String className; // Model class simple name.
-    private final List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
-    private final List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
+    private final String javaClassName; // Model class simple name as defined in Java.
+    private final List<RealmFieldElement> fields = new ArrayList<RealmFieldElement>(); // List of all fields in the class except those @Ignored.
+    private final List<RealmFieldElement> indexedFields = new ArrayList<RealmFieldElement>(); // list of all fields marked @Index.
     private final Set<Backlink> backlinks = new HashSet<Backlink>();
-    private final Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
-    private final Set<VariableElement> nullableValueListFields = new HashSet<VariableElement>(); // Set of fields whose elements can be nullable
+    private final Set<RealmFieldElement> nullableFields = new HashSet<RealmFieldElement>(); // Set of fields which can be nullable
+    private final Set<RealmFieldElement> nullableValueListFields = new HashSet<RealmFieldElement>(); // Set of fields whose elements can be nullable
 
     private String packageName; // package name for model class.
     private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
@@ -67,17 +72,19 @@
     private boolean containsToString;
     private boolean containsEquals;
     private boolean containsHashCode;
+    private String internalClassName;
 
     private final List<TypeMirror> validPrimaryKeyTypes;
     private final List<TypeMirror> validListValueTypes;
     private final Types typeUtils;
     private final Elements elements;
+    private NameConverter defaultFieldNameFormatter;
 
     private final boolean ignoreKotlinNullability;
 
     public ClassMetaData(ProcessingEnvironment env, TypeMirrors typeMirrors, TypeElement clazz) {
         this.classType = clazz;
-        this.className = clazz.getSimpleName().toString();
+        this.javaClassName = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
         elements = env.getElementUtils();
 
@@ -125,8 +132,15 @@ public String toString() {
         return "class " + getFullyQualifiedClassName();
     }
 
-    public String getSimpleClassName() {
-        return className;
+    public String getSimpleJavaClassName() {
+        return javaClassName;
+    }
+
+    /**
+     * Returns the name that Realm Core uses when saving data from this Java class.
+     */
+    public String getInternalClassName() {
+        return internalClassName;
     }
 
     public String getPackageName() {
@@ -134,10 +148,10 @@ public String getPackageName() {
     }
 
     public String getFullyQualifiedClassName() {
-        return packageName + "." + className;
+        return packageName + "." + javaClassName;
     }
 
-    public List<VariableElement> getFields() {
+    public List<RealmFieldElement> getFields() {
         return Collections.unmodifiableList(fields);
     }
 
@@ -153,7 +167,7 @@ public String getInternalSetter(String fieldName) {
         return "realmSet$" + fieldName;
     }
 
-    public List<VariableElement> getIndexedFields() {
+    public List<RealmFieldElement> getIndexedFields() {
         return Collections.unmodifiableList(indexedFields);
     }
 
@@ -252,9 +266,10 @@ public VariableElement getDeclaredField(String fieldName) {
      * Builds the meta data structures for this class. Any errors or messages will be
      * posted on the provided Messager.
      *
+     * @param moduleMetaData pre-processed module meta data.
      * @return True if meta data was correctly created and processing can continue, false otherwise.
      */
-    public boolean generate() {
+    public boolean generate(ModuleMetaData moduleMetaData) {
         // Get the package of the class
         Element enclosingElement = classType.getEnclosingElement();
         if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
@@ -262,6 +277,7 @@ public boolean generate() {
             return false;
         }
 
+        // Check if the @RealmClass is considered valid with respect to the type hierarchy
         TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
         if (!parentElement.toString().equals("java.lang.Object") && !parentElement.toString().equals("io.realm.RealmObject")) {
             Utils.error("Valid model classes must either extend RealmObject or implement RealmModel.", classType);
@@ -271,6 +287,31 @@ public boolean generate() {
         PackageElement packageElement = (PackageElement) enclosingElement;
         packageName = packageElement.getQualifiedName().toString();
 
+        // Determine naming rules for this class
+        String qualifiedClassName = packageName + "." + javaClassName;
+        NameConverter moduleClassNameFormatter = moduleMetaData.getClassNameFormatter(qualifiedClassName);
+        defaultFieldNameFormatter = moduleMetaData.getFieldNameFormatter(qualifiedClassName);
+
+        RealmClass realmClassAnnotation = classType.getAnnotation(RealmClass.class);
+        // If name has been specifically set, it should override any module policy.
+        if (!realmClassAnnotation.name().equals("")) {
+            internalClassName = realmClassAnnotation.name();
+        } else {
+            internalClassName = moduleClassNameFormatter.convert(javaClassName);
+        }
+        if (internalClassName.length() > MAX_CLASSNAME_LENGTH) {
+            Utils.error(String.format(Locale.US, "Internal class name is too long. Class '%s' " +
+                    "is converted to '%s', which is longer than the maximum allowed of %d characters",
+                    javaClassName, internalClassName, 57));
+            return false;
+        }
+
+        // If field name policy has been explicitly set, override the module field name policy
+        if (realmClassAnnotation.fieldNamingPolicy() != RealmNamingPolicy.NO_POLICY) {
+            defaultFieldNameFormatter = Utils.getNameFormatter(realmClassAnnotation.fieldNamingPolicy());
+        }
+
+        // Categorize and check the rest of the file
         if (!categorizeClassElements()) { return false; }
         if (!checkCollectionTypes()) { return false; }
         if (!checkReferenceTypes()) { return false; }
@@ -300,7 +341,7 @@ private boolean categorizeClassElements() {
         }
 
         if (fields.size() == 0) {
-            Utils.error(String.format(Locale.US, "Class \"%s\" must contain at least 1 persistable field.", className));
+            Utils.error(String.format(Locale.US, "Class \"%s\" must contain at least 1 persistable field.", javaClassName));
         }
 
         return true;
@@ -414,7 +455,7 @@ private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
             Utils.error(String.format(Locale.US,
                     "Class \"%s\" must declare a public constructor with no arguments if it contains custom constructors.",
-                    className));
+                    javaClassName));
             return false;
         } else {
             return true;
@@ -430,7 +471,7 @@ private boolean checkForFinalFields() {
                 continue;
             }
 
-            Utils.error(String.format(Locale.US, "Class \"%s\" contains illegal final field \"%s\".", className,
+            Utils.error(String.format(Locale.US, "Class \"%s\" contains illegal final field \"%s\".", javaClassName,
                     field.getSimpleName().toString()));
 
             return false;
@@ -443,7 +484,7 @@ private boolean checkForVolatileFields() {
             if (field.getModifiers().contains(Modifier.VOLATILE)) {
                 Utils.error(String.format(Locale.US,
                         "Class \"%s\" contains illegal volatile field \"%s\".",
-                        className,
+                        javaClassName,
                         field.getSimpleName().toString()));
                 return false;
             }
@@ -452,31 +493,47 @@ private boolean checkForVolatileFields() {
     }
 
     private boolean categorizeField(Element element) {
-        VariableElement field = (VariableElement) element;
+        VariableElement fieldRef = (VariableElement) element;
 
         // completely ignore any static fields
-        if (field.getModifiers().contains(Modifier.STATIC)) { return true; }
+        if (fieldRef.getModifiers().contains(Modifier.STATIC)) { return true; }
 
         // Ignore fields marked with @Ignore or if they are transient
-        if (field.getAnnotation(Ignore.class) != null || field.getModifiers().contains(Modifier.TRANSIENT)) {
+        if (fieldRef.getAnnotation(Ignore.class) != null || fieldRef.getModifiers().contains(Modifier.TRANSIENT)) {
             return true;
         }
 
+        // Determine name for field
+        String internalFieldName = getInternalFieldName(fieldRef, defaultFieldNameFormatter);
+        RealmFieldElement field = new RealmFieldElement(fieldRef, internalFieldName);
+
         if (field.getAnnotation(Index.class) != null) {
             if (!categorizeIndexField(element, field)) { return false; }
         }
 
         // @Required annotation of RealmList field only affects its value type, not field itself.
         if (Utils.isRealmList(field)) {
+            boolean hasRequiredAnnotation = hasRequiredAnnotation(field);
+            final List<? extends TypeMirror> listGenericType = ((DeclaredType) field.asType()).getTypeArguments();
+            boolean containsRealmModelClasses = (!listGenericType.isEmpty() && Utils.isRealmModel(listGenericType.get(0)));
+
+            // @Required not allowed if the list contains Realm model classes
+            if (hasRequiredAnnotation && containsRealmModelClasses) {
+                Utils.error("@Required not allowed on RealmList's that contain other Realm model classes.");
+                return false;
+            }
+
+            // @Required thus only makes sense for RealmLists with primitive types
             // We only check @Required annotation. @org.jetbrains.annotations.NotNull annotation should not affect nullability of the list values.
-            if (!hasRequiredAnnotation(field)) {
-                final List<? extends TypeMirror> fieldTypeArguments = ((DeclaredType) field.asType()).getTypeArguments();
-                if (fieldTypeArguments.isEmpty() || !Utils.isRealmModel(fieldTypeArguments.get(0))) {
+            if (!hasRequiredAnnotation) {
+                if (!containsRealmModelClasses) {
                     nullableValueListFields.add(field);
                 }
             }
         } else if (isRequiredField(field)) {
-            categorizeRequiredField(element, field);
+            if (!checkBasicRequiredAnnotationUsage(element, field)) {
+                return false;
+            }
         } else {
             // The field doesn't have the @Required and @org.jetbrains.annotations.NotNull annotation.
             // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
@@ -508,6 +565,22 @@ private boolean categorizeField(Element element) {
         return true;
     }
 
+    private String getInternalFieldName(VariableElement field, NameConverter defaultConverter) {
+        RealmField nameAnnotation = field.getAnnotation(RealmField.class);
+        if (nameAnnotation != null) {
+            String declaredName = nameAnnotation.name();
+            if (!declaredName.equals("")) {
+                return declaredName;
+            } else {
+                Utils.note(String.format("Empty internal name defined on @RealmField. " +
+                        "Falling back to named used by Java model class: %s", field.getSimpleName()), field);
+                return field.getSimpleName().toString();
+            }
+        } else {
+            return defaultConverter.convert(field.getSimpleName().toString());
+        }
+    }
+
     /**
      * This method only checks if the field has {@code @Required} annotation.
      * In most cases, you should use {@link #isRequiredField(VariableElement)} to take into account
@@ -549,13 +622,13 @@ private boolean isRequiredField(VariableElement field) {
 
     // The field has the @Index annotation. It's only valid for column types:
     // STRING, DATE, INTEGER, BOOLEAN, and RealmMutableInteger
-    private boolean categorizeIndexField(Element element, VariableElement variableElement) {
+    private boolean categorizeIndexField(Element element, RealmFieldElement fieldElement) {
         boolean indexable = false;
 
-        if (Utils.isMutableRealmInteger(variableElement)) {
+        if (Utils.isMutableRealmInteger(fieldElement)) {
             indexable = true;
         } else {
-            Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(variableElement.asType().toString());
+            Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldElement.asType().toString());
             if (realmType != null) {
                 switch (realmType) {
                     case STRING:
@@ -568,7 +641,7 @@ private boolean categorizeIndexField(Element element, VariableElement variableEl
         }
 
         if (indexable) {
-            indexedFields.add(variableElement);
+            indexedFields.add(fieldElement);
             return true;
         }
 
@@ -577,17 +650,18 @@ private boolean categorizeIndexField(Element element, VariableElement variableEl
     }
 
     // The field has the @Required annotation
-    private void categorizeRequiredField(Element element, VariableElement variableElement) {
+    // Returns `true` if the field could be correctly validated, `false` if an error was reported.
+    private boolean checkBasicRequiredAnnotationUsage(Element element, VariableElement variableElement) {
         if (Utils.isPrimitiveType(variableElement)) {
             Utils.error(String.format(Locale.US,
                     "@Required or @NotNull annotation is unnecessary for primitive field \"%s\".", element));
-            return;
+            return false;
         }
 
         if (Utils.isRealmModel(variableElement)) {
             Utils.error(String.format(Locale.US,
                     "Field \"%s\" with type \"%s\" cannot be @Required or @NotNull.", element, element.asType()));
-            return;
+            return false;
         }
 
         // Should never get here - user should remove @Required
@@ -596,34 +670,38 @@ private void categorizeRequiredField(Element element, VariableElement variableEl
                     "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
                     element,
                     element.asType()));
+
+            return false;
         }
+
+        return true;
     }
 
     // The field has the @PrimaryKey annotation. It is only valid for
     // String, short, int, long and must only be present one time
-    private boolean categorizePrimaryKeyField(VariableElement variableElement) {
+    private boolean categorizePrimaryKeyField(RealmFieldElement fieldElement) {
         if (primaryKey != null) {
             Utils.error(String.format(Locale.US,
                     "A class cannot have more than one @PrimaryKey. Both \"%s\" and \"%s\" are annotated as @PrimaryKey.",
                     primaryKey.getSimpleName().toString(),
-                    variableElement.getSimpleName().toString()));
+                    fieldElement.getSimpleName().toString()));
             return false;
         }
 
-        TypeMirror fieldType = variableElement.asType();
+        TypeMirror fieldType = fieldElement.asType();
         if (!isValidPrimaryKeyType(fieldType)) {
             Utils.error(String.format(Locale.US,
                     "Field \"%s\" with type \"%s\" cannot be used as primary key. See @PrimaryKey for legal types.",
-                    variableElement.getSimpleName().toString(),
+                    fieldElement.getSimpleName().toString(),
                     fieldType));
             return false;
         }
 
-        primaryKey = variableElement;
+        primaryKey = fieldElement;
 
         // Also add as index. All types of primary key can be indexed.
-        if (!indexedFields.contains(variableElement)) {
-            indexedFields.add(variableElement);
+        if (!indexedFields.contains(fieldElement)) {
+            indexedFields.add(fieldElement);
         }
 
         return true;
@@ -657,5 +735,10 @@ private boolean isValidPrimaryKeyType(TypeMirror type) {
         }
         return false;
     }
+
+    public Element getClassElement() {
+        return classType;
+    }
+
 }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index af2bf3cc35..aa4ef4ad8c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -16,6 +16,7 @@
 
 package io.realm.processor;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
@@ -31,35 +32,67 @@
 import javax.lang.model.element.TypeElement;
 
 import io.realm.annotations.RealmModule;
+import io.realm.annotations.RealmNamingPolicy;
+import io.realm.processor.nameconverter.NameConverter;
 
 
 /**
  * Utility class for holding metadata for the Realm modules.
+ * <p>
+ * Modules are inherently difficult to process because a model class can be part of multiple modules
+ * that contain information required by the model class (e.g. class/field naming policies). At the
+ * same time, the module will need the data from processed model classes to fully complete its
+ * analysis (e.g. to ensure that only valid Realm model classes are added to the module).
+ * <p>
+ * For this reason, processing modules are separated into 3 steps:
+ * <ol>
+ *  <li>
+ *      Pre-processing. Done by calling {@link #preProcess(Set)}, which will do an initial parse
+ *      of the modules and build up all information it can before processing any model classes.
+ *  </li>
+ *  <li>
+ *      Process model classes. See {@link ClassMetaData#generate(ModuleMetaData)}.
+ *  </li>
+ *  <li>
+ *      Post-processing. Done by calling {@link #postProcess(ClassCollection)}. All modules can now
+ *      be fully verified, and all metadata required to output module files can be generated.
+ *  </li>
+ * </ol>
  */
 public class ModuleMetaData {
 
-    private final Set<ClassMetaData> availableClasses;
+    // Pre-processing
+    // <FullyQualifiedModuleClassName, X>
+    private Set<String> globalModules = new HashSet<>(); // All modules with `allClasses = true` set
+    private Map<String, Set<String>> specificClassesModules = new HashMap<>(); // Modules with classes specifically named
+    private Map<String, RealmNamingPolicy> classNamingPolicy = new HashMap<String, RealmNamingPolicy>();
+    private Map<String, RealmNamingPolicy> fieldNamingPolicy = new HashMap<String, RealmNamingPolicy>();
+    private Map<String, RealmModule> moduleAnnotations = new HashMap<>();
+
+    // Post-processing
+    // <FullyQualifiedModuleClassName, X>
     private Map<String, Set<ClassMetaData>> modules = new HashMap<String, Set<ClassMetaData>>();
     private Map<String, Set<ClassMetaData>> libraryModules = new HashMap<String, Set<ClassMetaData>>();
-    private Map<String, ClassMetaData> classMetaData = new HashMap<String, ClassMetaData>(); // <FullyQualifiedClassName, ClassMetaData>
-    private boolean shouldCreateDefaultModule;
 
-    public ModuleMetaData(Set<ClassMetaData> availableClasses) {
-        this.availableClasses = availableClasses;
-        for (ClassMetaData classMetaData : availableClasses) {
-            this.classMetaData.put(classMetaData.getFullyQualifiedClassName(), classMetaData);
-        }
-    }
+    private boolean shouldCreateDefaultModule;
 
     /**
-     * Builds the meta data structures for this class. Any errors or messages will be posted on the provided Messager.
+     * Builds all meta data structures that can be calculated before processing any model classes.
+     * Any errors or messages will be posted on the provided Messager.
      *
-     * @return True if meta data was correctly created and processing can continue, false otherwise.
+     * @return True if meta data was correctly created and processing of model classes can continue, false otherwise.
      */
-    public boolean generate(Set<? extends Element> clazzes) {
+    public boolean preProcess(Set<? extends Element> moduleClasses) {
+
+        // Tracks all module settings with `allClasses` enabled
+        Set<ModulePolicyInfo> globalModuleInfo = new HashSet<>();
+
+        // Tracks which modules a class was mentioned in by name using `classes = { ... }`
+        // <Qualified
+        Map<String, List<ModulePolicyInfo>> classSpecificModuleInfo = new HashMap<>();
 
         // Check that modules are setup correctly
-        for (Element classElement : clazzes) {
+        for (Element classElement : moduleClasses) {
             String classSimpleName = classElement.getSimpleName().toString();
 
             // Check that the annotation is only applied to a class
@@ -69,38 +102,136 @@ public boolean generate(Set<? extends Element> clazzes) {
             }
 
             // Check that allClasses and classes are not set at the same time
-            RealmModule module = classElement.getAnnotation(RealmModule.class);
+            RealmModule moduleAnnoation = classElement.getAnnotation(RealmModule.class);
             Utils.note("Processing module " + classSimpleName);
-            if (module.allClasses() && hasCustomClassList(classElement)) {
+            if (moduleAnnoation.allClasses() && hasCustomClassList(classElement)) {
                 Utils.error("Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in " + classSimpleName);
                 return false;
             }
 
-            // Check that classes added are proper Realm model classes
-            String qualifiedName = ((TypeElement) classElement).getQualifiedName().toString();
-            Set<ClassMetaData> classes;
-            if (module.allClasses()) {
-                classes = availableClasses;
-            } else {
-                classes = new LinkedHashSet<ClassMetaData>();
-                Set<String> classNames = getClassMetaDataFromModule(classElement);
-                for (String fullyQualifiedClassName : classNames) {
-                    ClassMetaData metadata = classMetaData.get(fullyQualifiedClassName);
-                    if (metadata == null) {
-                        Utils.error(Utils.stripPackage(fullyQualifiedClassName) + " could not be added to the module. " +
-                                "Only classes extending RealmObject, which are part of this project, can be added.");
+            // Validate that naming policies are correctly configured.
+            if (!validateNamingPolicies(globalModuleInfo, classSpecificModuleInfo, (TypeElement) classElement, moduleAnnoation)) {
+                return false;
+            }
+
+            moduleAnnotations.put(((TypeElement) classElement).getQualifiedName().toString(), moduleAnnoation);
+        }
+
+        return true;
+    }
+
+    /**
+     * Validates that the class/field naming policy for this module is correct.
+     *
+     * @param globalModuleInfo list of all modules with `allClasses` set
+     * @param classSpecificModuleInfo map of explicit classes and which modules they are explicitly mentioned in.
+     * @param classElement class element currently being validated
+     * @param moduleAnnotation annotation on this class.
+     * @return {@code true} if everything checks out, {@code false} if an error was found and reported.
+     */
+    private boolean validateNamingPolicies(Set<ModulePolicyInfo> globalModuleInfo, Map<String, List<ModulePolicyInfo>> classSpecificModuleInfo, TypeElement classElement, RealmModule moduleAnnotation) {
+        RealmNamingPolicy classNamePolicy = moduleAnnotation.classNamingPolicy();
+        RealmNamingPolicy fieldNamePolicy = moduleAnnotation.fieldNamingPolicy();
+        String qualifiedModuleClassName = classElement.getQualifiedName().toString();
+        ModulePolicyInfo moduleInfo = new ModulePolicyInfo(qualifiedModuleClassName, classNamePolicy, fieldNamePolicy);
+
+        // The difference between `allClasses` and a list of classes is a bit tricky at this stage
+        // as we haven't processed the full list of classes yet. We therefore need to treat
+        // each case specifically :(
+        // We do not compare against the default module as it is always configured correctly
+        // with NO_POLICY, meaning it will not trigger any errors.
+        if (moduleAnnotation.allClasses()) {
+            // Check for conflicts with all other modules with `allClasses` set.
+            for (ModulePolicyInfo otherModuleInfo : globalModuleInfo) {
+                if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
+                    return false;
+                }
+            }
+
+            // Check for conflicts with specifically named classes. This can happen if another
+            // module is listing specific classes with another policy.
+            for (Map.Entry<String, List<ModulePolicyInfo>> classPolicyInfo : classSpecificModuleInfo.entrySet()) {
+                for (ModulePolicyInfo otherModuleInfo : classPolicyInfo.getValue()) {
+                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
                         return false;
                     }
-                    classes.add(metadata);
                 }
             }
 
-            // Create either a Library or App module
-            if (module.library()) {
-                libraryModules.put(qualifiedName, classes);
-            } else {
-                modules.put(qualifiedName, classes);
+            // Everything checks out. Add moduleInfo so we can track it for the next module.
+            globalModuleInfo.add(moduleInfo);
+            globalModules.add(qualifiedModuleClassName);
+
+        } else {
+            // We need to verify each class in the modules class list
+            Set<String> classNames = getClassListFromModule(classElement);
+            for (String qualifiedClassName : classNames) {
+
+                // Check that no other module with `allClasses` conflict with this specific
+                // class configuration
+                for (ModulePolicyInfo otherModuleInfo : globalModuleInfo) {
+                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
+                        return false;
+                    }
+                }
+
+                // Check that this specific class isn't conflicting with another module
+                // specifically mentioning it using `classes = { ... }`
+                List<ModulePolicyInfo> otherModules = classSpecificModuleInfo.get(qualifiedClassName);
+                if (otherModules != null) {
+                    for (ModulePolicyInfo otherModuleInfo : otherModules) {
+                        if (checkAndReportPolicyConflict(qualifiedClassName, moduleInfo, otherModuleInfo)) {
+                            return false;
+                        }
+                    }
+                }
+
+                // Keep track of the specific class for other module checks. We only
+                // need to track the latest module seen as previous errors would have been
+                // caught in a previous iteration of the loop.
+                if (!classSpecificModuleInfo.containsKey(qualifiedClassName)) {
+                    classSpecificModuleInfo.put(qualifiedClassName, new ArrayList<>());
+                }
+                classSpecificModuleInfo.get(qualifiedClassName).add(moduleInfo);
+            }
+            specificClassesModules.put(qualifiedModuleClassName, classNames);
+        }
+
+        classNamingPolicy.put(qualifiedModuleClassName, classNamePolicy);
+        fieldNamingPolicy.put(qualifiedModuleClassName, fieldNamePolicy);
+        return true;
+    }
+
+    /**
+     * All model classes have now been processed and the final validation of modules can occur.
+     * Any errors or messages will be posted on the provided Messager.
+     *
+     * @param modelClasses all Realm model classes found by the annotation processor.
+     * @return {@code true} if the module is valid, {@code false} otherwise.
+     */
+    public boolean postProcess(ClassCollection modelClasses) {
+
+        // Process all global modules
+        for (String qualifiedModuleClassName : globalModules) {
+            Set<ClassMetaData> classData = new LinkedHashSet<>();
+            classData.addAll(modelClasses.getClasses());
+            defineModule(qualifiedModuleClassName, classData);
+        }
+
+        // Process all modules with specific classes
+        for (Map.Entry<String, Set<String>> module : specificClassesModules.entrySet()) {
+            String qualifiedModuleClassName = module.getKey();
+            Set<ClassMetaData> classData = new LinkedHashSet<>();
+            for (String qualifiedModelClassName : module.getValue()) {
+                if (!modelClasses.containsQualifiedClass(qualifiedModelClassName)) {
+                    Utils.error(Utils.stripPackage(qualifiedModelClassName) + " could not be added to the module. " +
+                            "Only classes extending RealmObject or implementing RealmModel, which are part of this project, can be added.");
+                    return false;
+
+                }
+                classData.add(modelClasses.getClassFromQualifiedName(qualifiedModelClassName));
             }
+            defineModule(qualifiedModuleClassName, classData);
         }
 
         // Check that app and library modules are not mixed
@@ -112,19 +243,80 @@ public boolean generate(Set<? extends Element> clazzes) {
         // Create default Realm module if needed.
         // Note: Kotlin will trigger the annotation processor even if no Realm annotations are used.
         // The DefaultRealmModule should not be created in this case either.
-        if (libraryModules.size() == 0 && availableClasses.size() > 0) {
+        if (libraryModules.size() == 0 && modelClasses.size() > 0) {
             shouldCreateDefaultModule = true;
             String defaultModuleName = Constants.REALM_PACKAGE_NAME + "." + Constants.DEFAULT_MODULE_CLASS_NAME;
-            modules.put(defaultModuleName, availableClasses);
+            modules.put(defaultModuleName, modelClasses.getClasses());
         }
 
         return true;
     }
 
+    private void defineModule(String qualifiedModuleClassName, Set<ClassMetaData> classData) {
+        if (!classData.isEmpty()) {
+            if (moduleAnnotations.get(qualifiedModuleClassName).library()) {
+                libraryModules.put(qualifiedModuleClassName, classData);
+            } else {
+                modules.put(qualifiedModuleClassName, classData);
+            }
+        }
+    }
+
+    // Checks if two modules have policy conflicts. Returns true if a conflict was found and reported.
+    private boolean checkAndReportPolicyConflict(ModulePolicyInfo moduleInfo, ModulePolicyInfo otherModuleInfo) {
+        return checkAndReportPolicyConflict(null, moduleInfo, otherModuleInfo);
+    }
+
+    /**
+     * Check for name policy conflicts and report the error if found.
+     *
+     * @param className optional class name if a specific class is being checked.
+     * @param moduleInfo current module.
+     * @param otherModuleInfo already processed module.
+     * @return {@code true} if any errors was reported, {@code false} otherwise.
+     */
+    private boolean checkAndReportPolicyConflict(String className, ModulePolicyInfo moduleInfo, ModulePolicyInfo otherModuleInfo) {
+        boolean foundErrors = false;
+
+        // Check class naming policy
+        RealmNamingPolicy classPolicy = moduleInfo.classNamePolicy;
+        RealmNamingPolicy otherClassPolicy = otherModuleInfo.classNamePolicy;
+        if (classPolicy != RealmNamingPolicy.NO_POLICY
+                && otherClassPolicy != RealmNamingPolicy.NO_POLICY
+                && classPolicy != otherClassPolicy) {
+            Utils.error(String.format("The modules %s and %s disagree on the class naming policy%s: %s vs. %s. " +
+                            "They same policy must be used.",
+                    moduleInfo.qualifiedModuleClassName,
+                    otherModuleInfo.qualifiedModuleClassName,
+                    (className != null) ? " for " + className : "",
+                    classPolicy,
+                    otherClassPolicy));
+            foundErrors = true;
+        }
+
+        // Check field naming policy
+        RealmNamingPolicy fieldPolicy = moduleInfo.fieldNamePolicy;
+        RealmNamingPolicy otherFieldPolicy = otherModuleInfo.fieldNamePolicy;
+        if (fieldPolicy != RealmNamingPolicy.NO_POLICY
+                && otherFieldPolicy != RealmNamingPolicy.NO_POLICY
+                && fieldPolicy != otherFieldPolicy) {
+            Utils.error(String.format("The modules %s and %s disagree on the field naming policy%s: %s vs. %s. " +
+                            "They same policy should be used.",
+                    moduleInfo.qualifiedModuleClassName,
+                    otherModuleInfo.qualifiedModuleClassName,
+                    (className != null) ? " for " + className : "",
+                    fieldPolicy,
+                    otherFieldPolicy));
+            foundErrors = true;
+        }
+
+        return foundErrors;
+    }
+
     // Detour needed to access the class elements in the array
     // See http://blog.retep.org/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/
     @SuppressWarnings("unchecked")
-    private Set<String> getClassMetaDataFromModule(Element classElement) {
+    private Set<String> getClassListFromModule(Element classElement) {
         AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
         AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
         Set<String> classes = new HashSet<String>();
@@ -191,4 +383,84 @@ private AnnotationValue getAnnotationValue(AnnotationMirror annotationMirror) {
     public boolean shouldCreateDefaultModule() {
         return shouldCreateDefaultModule;
     }
+
+    /**
+     * Only available after {@link #preProcess(Set)} has run.
+     * Returns the module name policy the given name.
+     */
+    public NameConverter getClassNameFormatter(String qualifiedClassName) {
+        // We already validated that module definitions all agree on the same name policy
+        // so just find first match
+        if (!globalModules.isEmpty()) {
+            return Utils.getNameFormatter(classNamingPolicy.get(globalModules.iterator().next()));
+        }
+
+        // No global modules found, so find match in modules specifically listing the class.
+        // We already validated that all modules agree on the converter, so just find first match.
+        for (Map.Entry<String, Set<String>> moduleInfo : specificClassesModules.entrySet()) {
+            if (moduleInfo.getValue().contains(qualifiedClassName)) {
+                return Utils.getNameFormatter(classNamingPolicy.get(moduleInfo.getKey()));
+            }
+        }
+
+        // No policy was provided anywhere for this class
+        return Utils.getNameFormatter(RealmNamingPolicy.NO_POLICY);
+    }
+
+
+    /**
+     * Only available after {@link #preProcess(Set)} has run.
+     *
+     * Returns the module name policy the field names.
+     *
+     * @param qualifiedClassName
+     */
+    public NameConverter getFieldNameFormatter(String qualifiedClassName) {
+        // We already validated that module definitions all agree on the same name policy
+        // so just find first match
+        if (!globalModules.isEmpty()) {
+            return Utils.getNameFormatter(fieldNamingPolicy.get(globalModules.iterator().next()));
+        }
+
+        for (Map.Entry<String, Set<String>> moduleInfo : specificClassesModules.entrySet()) {
+            if (moduleInfo.getValue().contains(qualifiedClassName)) {
+                return Utils.getNameFormatter(fieldNamingPolicy.get(moduleInfo.getKey()));
+            }
+        }
+
+        return Utils.getNameFormatter(RealmNamingPolicy.NO_POLICY);
+    }
+
+    // Tuple helper class
+    private class ModulePolicyInfo {
+        public final String qualifiedModuleClassName;
+        public final RealmNamingPolicy classNamePolicy;
+        public final RealmNamingPolicy fieldNamePolicy;
+
+        public ModulePolicyInfo(String qualifiedModuleClassName, RealmNamingPolicy classNamePolicy, RealmNamingPolicy fieldNamePolicy) {
+            this.qualifiedModuleClassName = qualifiedModuleClassName;
+            this.classNamePolicy = classNamePolicy;
+            this.fieldNamePolicy = fieldNamePolicy;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            ModulePolicyInfo that = (ModulePolicyInfo) o;
+
+            if (!qualifiedModuleClassName.equals(that.qualifiedModuleClassName)) return false;
+            if (classNamePolicy != that.classNamePolicy) return false;
+            return fieldNamePolicy == that.fieldNamePolicy;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = qualifiedModuleClassName.hashCode();
+            result = 31 * result + classNamePolicy.hashCode();
+            result = 31 * result + fieldNamePolicy.hashCode();
+            return result;
+        }
+    }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.java
new file mode 100644
index 0000000000..578766bc81
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Wrapper for {@link javax.lang.model.element.VariableElement} that makes it possible to add
+ * additional metadata.
+ */
+public class RealmFieldElement implements VariableElement {
+
+    private final VariableElement fieldReference;
+    private final String internalFieldName; // Name used for this field internally in Realm.
+
+    public RealmFieldElement(VariableElement fieldReference, String internalFieldName) {
+        this.fieldReference = fieldReference;
+        this.internalFieldName = internalFieldName;
+    }
+
+    public VariableElement getFieldReference() {
+        return fieldReference;
+    }
+
+    /**
+     * Returns the name that Realm Core uses internally when saving data to this field.
+     * {@link #getSimpleName()} returns the name in the Java class.
+     */
+    public String getInternalFieldName() {
+        return internalFieldName;
+    }
+
+    public Set<Modifier> getModifiers() {
+        return fieldReference.getModifiers();
+    }
+
+    public TypeMirror asType() {
+        return fieldReference.asType();
+    }
+
+    @Override
+    public ElementKind getKind() {
+        return null;
+    }
+
+    @Override
+    public Object getConstantValue() {
+        return fieldReference.getConstantValue();
+    }
+
+    /**
+     * Returns the name for this field in the Java class.
+     * {@link #getInternalFieldName()} returns the name used by Realm Core for the same field.
+     */
+    @Override
+    public Name getSimpleName() {
+        return fieldReference.getSimpleName();
+    }
+
+    @Override
+    public Element getEnclosingElement() {
+        return fieldReference.getEnclosingElement();
+    }
+
+    @Override
+    public List<? extends Element> getEnclosedElements() {
+        return fieldReference.getEnclosedElements();
+    }
+
+    @Override
+    public List<? extends AnnotationMirror> getAnnotationMirrors() {
+        return fieldReference.getAnnotationMirrors();
+    }
+
+    @Override
+    public <A extends Annotation> A getAnnotation(Class<A> aClass) {
+        return fieldReference.getAnnotation(aClass);
+    }
+
+    @Override
+    public <A extends Annotation> A[] getAnnotationsByType(Class<A> aClass) {
+        return fieldReference.getAnnotationsByType(aClass);
+    }
+
+    @Override
+    public <R, P> R accept(ElementVisitor<R, P> elementVisitor, P p) {
+        return fieldReference.accept(elementVisitor, p);
+    }
+
+    @Override
+    public String toString() {
+        // Mimics the behaviour of the standard implementation of VariableElement `toString()`
+        // Some methods in RealmProxyClassGenerator depended on this.
+        return getSimpleName().toString();
+    }
+
+    public String getJavaName() {
+        return getSimpleName().toString();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 713ab6b2ef..c557e866a3 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -19,7 +19,6 @@
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -66,14 +65,12 @@
  * <li>A RealmObjectProxy object is created for each class annotated with {@link io.realm.annotations.RealmClass}. This
  * proxy extends the original RealmObject class and rewires all field access to point to the native Realm memory instead of
  * Java memory. It also adds some static helper methods to the class.</li>
- * <p>
  * <li>The annotation processor is either in "library" mode or in "app" mode. This is defined by having a class
  * annotated with @RealmModule(library = true). It is not allowed to have both a class with library = true and
  * library = false in the same IntelliJ module and it will cause the annotation processor to throw an exception. If no
  * library modules are defined, we will create a DefaultRealmModule containing all known RealmObjects and with the
  * {@code @RealmModule} annotation. Realm automatically knows about this module, but it is still possible for users to create
  * their own modules with a subset of model classes.</li>
- * <p>
  * <li>For each class annotated with @RealmModule a matching Mediator class is created (including the default one). This
  * class has an interface that matches the static helper methods for the proxy classes. All access to these static
  * helper methods should be done through this Mediator.</li>
@@ -119,6 +116,7 @@
  */
 @SupportedAnnotationTypes({
         "io.realm.annotations.RealmClass",
+        "io.realm.annotations.RealmField",
         "io.realm.annotations.Ignore",
         "io.realm.annotations.Index",
         "io.realm.annotations.PrimaryKey",
@@ -130,10 +128,11 @@
 
     // Don't consume annotations. This allows 3rd party annotation processors to run.
     private static final boolean CONSUME_ANNOTATIONS = false;
+    private static final boolean ABORT = true; // Abort the annotation processor by consuming all annotations
 
+    private final ClassCollection classCollection = new ClassCollection(); // Metadata for all classes found
+    private ModuleMetaData moduleMetaData; // Metadata for all modules found
 
-    // List of all fields maintained by Realm (RealmResults)
-    private final Set<ClassMetaData> classesToValidate = new LinkedHashSet<ClassMetaData>();
     // List of backlinks
     private final Set<Backlink> backlinksToValidate = new HashSet<Backlink>();
 
@@ -153,27 +152,29 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             RealmVersionChecker.getInstance(processingEnv).executeRealmVersionUpdate();
         }
 
-        if (roundEnv.errorRaised()) { return true; }
+        if (roundEnv.errorRaised()) { return ABORT; }
 
         if (!hasProcessedModules) {
             Utils.initialize(processingEnv);
+            TypeMirrors typeMirrors = new TypeMirrors(processingEnv);
 
-            if (!processAnnotations(roundEnv)) { return true; }
-
+            // Build up internal metadata while validating as much as possible
+            if (!preProcessModules(roundEnv)) { return ABORT; }
+            if (!processClassAnnotations(roundEnv, typeMirrors)) { return ABORT; }
+            if (!postProcessModules()) { return ABORT; }
+            if (!validateBacklinks()) { return ABORT; }
             hasProcessedModules = true;
-            if (!processModules(roundEnv)) { return true; }
-        }
 
-        if (roundEnv.processingOver()) {
-            if (!validateBacklinks()) { return true; }
+            // Create all files
+            if (!createProxyClassFiles(typeMirrors)) { return ABORT; }
+            if (!createModuleFiles(roundEnv)) { return ABORT; }
         }
 
         return CONSUME_ANNOTATIONS;
     }
 
     // Create all proxy classes
-    private boolean processAnnotations(RoundEnvironment roundEnv) {
-        final TypeMirrors typeMirrors = new TypeMirrors(processingEnv);
+    private boolean processClassAnnotations(RoundEnvironment roundEnv, TypeMirrors typeMirrors) {
 
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
@@ -192,39 +193,28 @@ private boolean processAnnotations(RoundEnvironment roundEnv) {
             ClassMetaData metadata = new ClassMetaData(processingEnv, typeMirrors, (TypeElement) classElement);
             if (!metadata.isModelClass()) { continue; }
 
-            Utils.note("Processing class " + metadata.getSimpleClassName());
-            if (!metadata.generate()) { return false; }
+            Utils.note("Processing class " + metadata.getSimpleJavaClassName());
+            if (!metadata.generate(moduleMetaData)) { return false; }
 
-            classesToValidate.add(metadata);
+            classCollection.addClass(metadata);
             backlinksToValidate.addAll(metadata.getBacklinkFields());
-
-            RealmProxyInterfaceGenerator interfaceGenerator = new RealmProxyInterfaceGenerator(processingEnv, metadata);
-            try {
-                interfaceGenerator.generate();
-            } catch (IOException e) {
-                Utils.error(e.getMessage(), classElement);
-            }
-
-            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, typeMirrors, metadata);
-            try {
-                sourceCodeGenerator.generate();
-            } catch (IOException e) {
-                Utils.error(e.getMessage(), classElement);
-            } catch (UnsupportedOperationException e) {
-                Utils.error(e.getMessage(), classElement);
-            }
         }
 
         return true;
     }
 
-    // Returns true if modules was processed successfully, false otherwise
-    private boolean processModules(RoundEnvironment roundEnv) {
-        ModuleMetaData moduleMetaData = new ModuleMetaData(classesToValidate);
-        if (!moduleMetaData.generate(roundEnv.getElementsAnnotatedWith(RealmModule.class))) {
-            return false;
-        }
+    // Returns true if modules were processed successfully, false otherwise
+    private boolean preProcessModules(RoundEnvironment roundEnv) {
+        moduleMetaData = new ModuleMetaData();
+        return moduleMetaData.preProcess(roundEnv.getElementsAnnotatedWith(RealmModule.class));
+    }
 
+    // Returns true of modules where succesfully validated, false otherwise
+    private boolean postProcessModules() {
+        return moduleMetaData.postProcess(classCollection);
+    }
+
+    private boolean createModuleFiles(RoundEnvironment roundEnv) {
         // Create default module if needed
         if (moduleMetaData.shouldCreateDefaultModule()) {
             if (!createDefaultModule()) {
@@ -242,6 +232,27 @@ private boolean processModules(RoundEnvironment roundEnv) {
         return true;
     }
 
+    private boolean createProxyClassFiles(TypeMirrors typeMirrors) {
+        for (ClassMetaData metadata : classCollection.getClasses()) {
+            RealmProxyInterfaceGenerator interfaceGenerator = new RealmProxyInterfaceGenerator(processingEnv, metadata);
+            try {
+                interfaceGenerator.generate();
+            } catch (IOException e) {
+                Utils.error(e.getMessage(), metadata.getClassElement());
+                return false;
+            }
+
+            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, typeMirrors, metadata, classCollection);
+            try {
+                sourceCodeGenerator.generate();
+            } catch (IOException | UnsupportedOperationException e) {
+                Utils.error(e.getMessage(), metadata.getClassElement());
+                return false;
+            }
+        }
+        return true;
+    }
+
     private boolean createDefaultModule() {
         Utils.note("Creating DefaultRealmModule");
         DefaultModuleGenerator defaultModuleGenerator = new DefaultModuleGenerator(processingEnv);
@@ -278,13 +289,8 @@ private boolean createMediator(String simpleModuleName, Set<ClassMetaData> modul
     private boolean validateBacklinks() {
         boolean allValid = true;
 
-        Map<String, ClassMetaData> realmClasses = new HashMap<String, ClassMetaData>(classesToValidate.size());
-        for (ClassMetaData classData : classesToValidate) {
-            realmClasses.put(classData.getFullyQualifiedClassName(), classData);
-        }
-
         for (Backlink backlink : backlinksToValidate) {
-            ClassMetaData clazz = realmClasses.get(backlink.getSourceClass());
+            ClassMetaData clazz = classCollection.getClassFromQualifiedName(backlink.getSourceClass());
 
             // If the class is not here it might be part of some other compilation unit.
             if (clazz == null) { continue; }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 54e8560b88..1a002e258d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -78,21 +78,25 @@
     private final ProcessingEnvironment processingEnvironment;
     private final TypeMirrors typeMirrors;
     private final ClassMetaData metadata;
-    private final String simpleClassName;
-    private final String qualifiedClassName;
+    private final ClassCollection classCollection;
+    private final String simpleJavaClassName;
+    private final String qualifiedJavaClassName;
+    private final String internalClassName;
     private final String interfaceName;
     private final String qualifiedGeneratedClassName;
     private final boolean suppressWarnings;
 
-    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, TypeMirrors typeMirrors, ClassMetaData metadata) {
+    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, TypeMirrors typeMirrors, ClassMetaData metadata, ClassCollection classes) {
         this.processingEnvironment = processingEnvironment;
         this.typeMirrors = typeMirrors;
         this.metadata = metadata;
-        this.simpleClassName = metadata.getSimpleClassName();
-        this.qualifiedClassName = metadata.getFullyQualifiedClassName();
-        this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
+        this.classCollection = classes;
+        this.simpleJavaClassName = metadata.getSimpleJavaClassName();
+        this.qualifiedJavaClassName = metadata.getFullyQualifiedClassName();
+        this.internalClassName = metadata.getInternalClassName();
+        this.interfaceName = Utils.getProxyInterfaceName(simpleJavaClassName);
         this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
-                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));
+                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleJavaClassName));
 
         // See the configuration for the debug build type,
         //  in the realm-library project, for an example of how to set this flag.
@@ -125,7 +129,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 qualifiedGeneratedClassName, // full qualified name of the item to generate
                 "class",                     // the type of the item
                 EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                qualifiedClassName,          // class to extend
+                qualifiedJavaClassName,          // class to extend
                 "RealmObjectProxy",          // interfaces to implement
                 interfaceName)
                 .emitEmptyLine();
@@ -183,16 +187,19 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
                 "OsSchemaInfo", "schemaInfo");
         writer.emitStatement("super(%s)", metadata.getFields().size());
         writer.emitStatement("OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"%1$s\")",
-                simpleClassName);
-        for (VariableElement field : metadata.getFields()) {
+                internalClassName);
+        for (RealmFieldElement field : metadata.getFields()) {
             writer.emitStatement(
-                    "this.%1$sIndex = addColumnDetails(\"%1$s\", objectSchemaInfo)",
-                    field.getSimpleName().toString());
+                    "this.%1$sIndex = addColumnDetails(\"%1$s\", \"%2$s\", objectSchemaInfo)",
+                    field.getJavaName(),
+                    field.getInternalFieldName());
         }
         for (Backlink backlink : metadata.getBacklinkFields()) {
             writer.emitStatement(
                     "addBacklinkDetails(schemaInfo, \"%s\", \"%s\", \"%s\")",
-                    backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
+                    backlink.getTargetField(),
+                    classCollection.getClassFromQualifiedName(backlink.getSourceClass()).getInternalClassName(),
+                    backlink.getSourceField());
         }
         writer.endConstructor()
                 .emitEmptyLine();
@@ -246,7 +253,7 @@ private void emitClassFields(JavaWriter writer) throws IOException {
     private void emitInstanceFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine()
                 .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
-                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
+                .emitField("ProxyState<" + qualifiedJavaClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isMutableRealmInteger(variableElement)) {
@@ -277,7 +284,7 @@ private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement var
                                 + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
                                 + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
                                 + "}",
-                        qualifiedClassName, columnIndexVarName(variableElement)));
+                        qualifiedJavaClassName, columnIndexVarName(variableElement)));
     }
     //@formatter:on
 
@@ -668,7 +675,7 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
                 .endControlFlow()
                 .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
                 .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
-                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
+                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedJavaClassName)
                 .emitStatement("proxyState.setRealm$realm(context.getRealm())")
                 .emitStatement("proxyState.setRow$realm(context.getRow())")
                 .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
@@ -724,31 +731,32 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
 
         writer.emitStatement(
                 "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)",
-                this.simpleClassName, persistedFields, computedFields);
+                internalClassName, persistedFields, computedFields);
 
         // For each field generate corresponding table index constant
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
+        for (RealmFieldElement field : metadata.getFields()) {
+            String fieldName = field.getInternalFieldName();
 
             Constants.RealmFieldType fieldType = getRealmTypeChecked(field);
             switch (fieldType) {
-                case NOTYPE:
+                case NOTYPE: {
                     // Perhaps this should fail quickly?
                     break;
-
-                case OBJECT:
+                }
+                case OBJECT: {
                     String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
+                    String internalClassName = classCollection.getClassFromSimpleName(fieldTypeSimpleName).getInternalClassName();
                     writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
-                            fieldName, fieldTypeSimpleName);
+                            fieldName, internalClassName);
                     break;
-
-                case LIST:
-                    // only for model list.
+                }
+                case LIST: {
                     String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                    String internalClassName = classCollection.getClassFromSimpleName(genericTypeSimpleName).getInternalClassName(); // FIXME support for raw data
                     writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
-                            fieldName, genericTypeSimpleName);
+                            fieldName, internalClassName);
                     break;
-
+                }
                 case INTEGER_LIST:
                 case BOOLEAN_LIST:
                 case STRING_LIST:
@@ -788,7 +796,7 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
         }
         for (Backlink backlink: metadata.getBacklinkFields()) {
             writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
-                    backlink.getTargetField(), backlink.getSimpleSourceClass(), backlink.getSourceField());
+                    backlink.getTargetField(), classCollection.getClassFromSimpleName(backlink.getSimpleSourceClass()).getInternalClassName(), backlink.getSourceField());
         }
         writer.emitStatement("return builder.build()");
         writer.endMethod()
@@ -824,7 +832,7 @@ private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
     //@formatter:off
     private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("String", "getSimpleClassName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-                .emitStatement("return \"%s\"", simpleClassName)
+                .emitStatement("return \"%s\"", internalClassName)
                 .endMethod()
                 .emitEmptyLine();
     }
@@ -833,10 +841,10 @@ private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException
     //@formatter:off
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                qualifiedClassName, // Return type
+                qualifiedJavaClassName, // Return type
                 "copyOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
+                "Realm", "realm", qualifiedJavaClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
         writer
@@ -857,7 +865,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
                 .beginControlFlow("if (cachedRealmObject != null)")
-                    .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+                    .emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
                 .endControlFlow()
                 .emitEmptyLine();
 
@@ -865,12 +873,12 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
             writer.emitStatement("return copy(realm, object, update, cache)");
         } else {
             writer
-                    .emitStatement("%s realmObject = null", qualifiedClassName)
+                    .emitStatement("%s realmObject = null", qualifiedJavaClassName)
                     .emitStatement("boolean canUpdate = update")
                     .beginControlFlow("if (canUpdate)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
                     .emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                        columnInfoClassName(), columnInfoClassName(), qualifiedClassName)
+                        columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
                     .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
 
             String primaryKeyGetter = metadata.getPrimaryKeyGetter();
@@ -908,7 +916,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                         .beginControlFlow("try")
                             .emitStatement(
                                 "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
-                                qualifiedClassName)
+                                    qualifiedJavaClassName)
                             .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
                             .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                         .nextControlFlow("finally")
@@ -1047,7 +1055,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                 "long", // Return type
                 "insert", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+                "Realm", "realm", qualifiedJavaClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
         );
 
         // If object is already in the Realm there is nothing to update
@@ -1056,10 +1064,10 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                 .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                 .endControlFlow();
 
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
         writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
 
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
@@ -1140,17 +1148,17 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                 "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
         );
 
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
         writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
         }
-        writer.emitStatement("%s object = null", qualifiedClassName);
+        writer.emitStatement("%s object = null", qualifiedJavaClassName);
 
         writer.beginControlFlow("while (objects.hasNext())")
-                .emitStatement("object = (%s) objects.next()", qualifiedClassName);
+                .emitStatement("object = (%s) objects.next()", qualifiedJavaClassName);
         writer.beginControlFlow("if (cache.containsKey(object))")
                 .emitStatement("continue")
                 .endControlFlow();
@@ -1234,7 +1242,7 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                 "long", // Return type
                 "insertOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+                "Realm", "realm", qualifiedJavaClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
         );
 
         // If object is already in the Realm there is nothing to update
@@ -1243,10 +1251,10 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                 .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                 .endControlFlow();
 
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
         writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
 
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
@@ -1347,17 +1355,17 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                 "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
         );
 
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
         writer.emitStatement("long tableNativePtr = table.getNativePtr()");
         writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
         }
-        writer.emitStatement("%s object = null", qualifiedClassName);
+        writer.emitStatement("%s object = null", qualifiedJavaClassName);
 
         writer.beginControlFlow("while (objects.hasNext())");
-        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
+        writer.emitStatement("object = (%s) objects.next()", qualifiedJavaClassName);
         writer.beginControlFlow("if (cache.containsKey(object))")
                 .emitStatement("continue")
                 .endControlFlow();
@@ -1518,14 +1526,14 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
 
     private void emitCopyMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                qualifiedClassName, // Return type
+                qualifiedJavaClassName, // Return type
                 "copy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", qualifiedJavaClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
 
         writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
         writer.beginControlFlow("if (cachedRealmObject != null)")
-                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+                .emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
                 .endControlFlow();
 
 
@@ -1533,10 +1541,10 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 .emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
-                    qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
+                    qualifiedJavaClassName, qualifiedJavaClassName, interfaceName, metadata.getPrimaryKeyGetter());
         } else {
             writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
-                    qualifiedClassName, qualifiedClassName);
+                    qualifiedJavaClassName, qualifiedJavaClassName);
         }
         writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
 
@@ -1613,25 +1621,25 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
     //@formatter:off
     private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                qualifiedClassName, // Return type
+                qualifiedJavaClassName, // Return type
                 "createDetachedCopy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
+                qualifiedJavaClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
         writer
                 .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                 .emitStatement("return null")
                 .endControlFlow()
                 .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-                .emitStatement("%s unmanagedObject", qualifiedClassName)
+                .emitStatement("%s unmanagedObject", qualifiedJavaClassName)
                 .beginControlFlow("if (cachedObject == null)")
-                .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
+                .emitStatement("unmanagedObject = new %s()", qualifiedJavaClassName)
                 .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
                 .nextControlFlow("else")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                 .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
-                .emitStatement("return (%s) cachedObject.object", qualifiedClassName)
+                .emitStatement("return (%s) cachedObject.object", qualifiedJavaClassName)
                 .endControlFlow()
-                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedClassName)
+                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedJavaClassName)
                 .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow();
 
@@ -1695,10 +1703,10 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
         }
 
         writer.beginMethod(
-                qualifiedClassName, // Return type
+                qualifiedJavaClassName, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", qualifiedJavaClassName, "realmObject", qualifiedJavaClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
 
         writer
                 .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
@@ -1784,9 +1792,9 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                 .beginControlFlow("if (!RealmObject.isValid(this))")
                 .emitStatement("return \"Invalid object\"")
                 .endControlFlow();
-        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleClassName);
+        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleJavaClassName);
 
-        Collection<VariableElement> fields = metadata.getFields();
+        Collection<RealmFieldElement> fields = metadata.getFields();
         int i = fields.size() - 1;
         for (VariableElement field : fields) {
             String fieldName = field.getSimpleName().toString();
@@ -1860,8 +1868,8 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         if (metadata.containsEquals()) {
             return;
         }
-        String proxyClassName = Utils.getProxyClassName(simpleClassName);
-        String otherObjectVarName = "a" + simpleClassName;
+        String proxyClassName = Utils.getProxyClassName(simpleJavaClassName);
+        String otherObjectVarName = "a" + simpleJavaClassName;
         writer.emitAnnotation("Override")
                 .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
                 .emitStatement("if (this == o) return true")
@@ -1886,7 +1894,7 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
     private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
-                qualifiedClassName,
+                qualifiedJavaClassName,
                 "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
@@ -1904,15 +1912,15 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         if (!metadata.hasPrimaryKey()) {
             buildExcludeFieldsList(writer, metadata.getFields());
             writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
-                    qualifiedClassName, qualifiedClassName);
+                    qualifiedJavaClassName, qualifiedJavaClassName);
         } else {
             String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
             writer
-                .emitStatement("%s obj = null", qualifiedClassName)
+                .emitStatement("%s obj = null", qualifiedJavaClassName)
                 .beginControlFlow("if (update)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
                     .emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                        columnInfoClassName(), columnInfoClassName(), qualifiedClassName)
+                        columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
                     .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()))
                     .emitStatement("long rowIndex = Table.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
@@ -1938,7 +1946,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                     .beginControlFlow("try")
                         .emitStatement(
                                 "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
-                                qualifiedClassName)
+                                qualifiedJavaClassName)
                         .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
                     .nextControlFlow("finally")
                         .emitStatement("objectContext.clear()")
@@ -1951,7 +1959,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
             String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
             RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
-                    qualifiedClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
+                    qualifiedJavaClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
             writer.endControlFlow();
         }
         //@formatter:on
@@ -2013,7 +2021,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         writer.emitEmptyLine();
     }
 
-    private void buildExcludeFieldsList(JavaWriter writer, Collection<VariableElement> fields) throws IOException {
+    private void buildExcludeFieldsList(JavaWriter writer, Collection<RealmFieldElement> fields) throws IOException {
         for (VariableElement field : fields) {
             if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
                 final String fieldName = field.getSimpleName().toString();
@@ -2030,7 +2038,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
         writer.beginMethod(
-                qualifiedClassName,
+                qualifiedJavaClassName,
                 "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JsonReader", "reader"),
@@ -2039,13 +2047,13 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("boolean jsonHasPrimaryKey = false");
         }
-        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
+        writer.emitStatement("final %s obj = new %s()", qualifiedJavaClassName, qualifiedJavaClassName);
         writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
         writer.beginControlFlow("if (false)");
-        Collection<VariableElement> fields = metadata.getFields();
+        Collection<RealmFieldElement> fields = metadata.getFields();
         for (VariableElement field : fields) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
@@ -2114,7 +2122,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
     }
 
     private String columnInfoClassName() {
-        return simpleClassName + "ColumnInfo";
+        return simpleJavaClassName + "ColumnInfo";
     }
 
     private String columnIndexVarName(VariableElement variableElement) {
@@ -2129,7 +2137,7 @@ private String fieldIndexVariableReference(VariableElement variableElement) {
         return "columnInfo." + columnIndexVarName(variableElement);
     }
 
-    private static int countModelOrListFields(Collection<VariableElement> fields) {
+    private static int countModelOrListFields(Collection<RealmFieldElement> fields) {
         int count = 0;
         for (VariableElement f : fields) {
             if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
index ebe68a616c..25cbe13a41 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
@@ -38,7 +38,7 @@
     public RealmProxyInterfaceGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metaData) {
         this.processingEnvironment = processingEnvironment;
         this.metaData = metaData;
-        this.className = metaData.getSimpleClassName();
+        this.className = metaData.getSimpleJavaClassName();
     }
 
     public void generate() throws IOException {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index a667e57590..5081c513bf 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -40,8 +40,10 @@
 public class RealmProxyMediatorGenerator {
     private final String className;
     private final ProcessingEnvironment processingEnvironment;
-    private final List<String> qualifiedModelClasses = new ArrayList<String>();
-    private final List<String> qualifiedProxyClasses = new ArrayList<String>();
+    private final List<String> qualifiedModelClasses = new ArrayList<>();
+    private final List<String> qualifiedProxyClasses = new ArrayList<>();
+    private final List<String> internalClassNames = new ArrayList<>();
+
 
     public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
             String className, Set<ClassMetaData> classesToValidate) {
@@ -49,9 +51,10 @@ public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
         this.className = className;
 
         for (ClassMetaData metadata : classesToValidate) {
-            String simpleName = metadata.getSimpleClassName();
+            String simpleName = metadata.getSimpleJavaClassName();
             qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
             qualifiedProxyClasses.add(REALM_PACKAGE_NAME + "." + getProxyClassName(simpleName));
+            internalClassNames.add(metadata.getInternalClassName());
         }
     }
 
@@ -177,7 +180,7 @@ private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException
         emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getSimpleClassName()", qualifiedProxyClasses.get(i));
+                writer.emitStatement("return \"%s\"", internalClassNames.get(i));
             }
         }, writer);
         writer.endMethod();
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 7e7a274af1..5884c70818 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -17,13 +17,20 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
+import io.realm.annotations.RealmNamingPolicy;
+import io.realm.processor.nameconverter.CamelCaseConverter;
+import io.realm.processor.nameconverter.LowerCaseWithSeparatorConverter;
+import io.realm.processor.nameconverter.NameConverter;
+import io.realm.processor.nameconverter.IdentityConverter;
+import io.realm.processor.nameconverter.PascalCaseConverter;
+
 
 /**
  * Utility methods working with the Realm processor.
  */
 public class Utils {
 
-    public static Types typeUtils;
+    private static Types typeUtils;
     private static Messager messager;
     private static TypeMirror realmInteger;
     private static DeclaredType realmList;
@@ -54,10 +61,6 @@ public static boolean isDefaultConstructor(Element constructor) {
         return false;
     }
 
-    public static String lowerFirstChar(String input) {
-        return input.substring(0, 1).toLowerCase() + input.substring(1);
-    }
-
     public static String getProxyClassSimpleName(VariableElement field) {
         if (typeUtils.isAssignable(field.asType(), realmList)) {
             return getProxyClassName(getGenericTypeSimpleName(field));
@@ -175,7 +178,7 @@ public static boolean isRealmList(VariableElement field) {
     }
 
     /**
-     * @return {@code true} if a given field type is {@code RealmList} and its element type is {@Code RealmObject},
+     * @return {@code true} if a given field type is {@code RealmList} and its element type is {@code RealmObject},
      * {@code false} otherwise.
      */
     public static boolean isRealmModelList(VariableElement field) {
@@ -209,7 +212,26 @@ public static boolean isRealmModel(Element field) {
      * @return {@code true} if a given type is {@code RealmModel}, {@code false} otherwise.
      */
     public static boolean isRealmModel(TypeMirror type) {
+        // This will return the wrong result if a model class doesn't exist at all, but
+        // the compiler will catch that eventually.
         return typeUtils.isAssignable(type, realmModel);
+//        // Not sure what is happening here, but typeUtils.isAssignable("Foo", realmModel)
+//        // returns true even if Foo doesn't exist. No idea why this is happening.
+//        // For now punt on the problem and check the direct supertype which should be either
+//        // RealmObject or RealmModel.
+//        // Original implementation: ``
+//        //
+//        // Theory: It looks like if `type` has the internal TypeTag.ERROR (internal API) it
+//        // automatically translate to being assignable to everything. Possible some Java Specification
+//        // rule taking effect. In our case, however we can do better since all Realm classes
+//        // must be in the same compilation unit, so we should be able to look the type up.
+//        for (TypeMirror typeMirror : typeUtils.directSupertypes(type)) {
+//            String supertype = typeMirror.toString();
+//            if (supertype.equals("io.realm.RealmObject") || supertype.equals("io.realm.RealmModel")) {
+//                return true;
+//            }
+//        }
+//        return false;
     }
 
     public static boolean isRealmResults(VariableElement field) {
@@ -320,6 +342,11 @@ public static String stripPackage(String fullyQualifiedClassName) {
     }
 
     public static void error(String message, Element element) {
+        if (element instanceof RealmFieldElement) {
+            // Element is being cast to Symbol internally which breaks any implementors of the
+            // Element interface. This is a hack to work around that. Bad bad Oracle
+            element = ((RealmFieldElement) element).getFieldReference();
+        }
         messager.printMessage(Diagnostic.Kind.ERROR, message, element);
     }
 
@@ -327,6 +354,15 @@ public static void error(String message) {
         messager.printMessage(Diagnostic.Kind.ERROR, message);
     }
 
+    public static void note(String message, Element element) {
+        if (element instanceof RealmFieldElement) {
+            // Element is being cast to Symbol internally which breaks any implementors of the
+            // Element interface. This is a hack to work around that. Bad bad Oracle
+            element = ((RealmFieldElement) element).getFieldReference();
+        }
+        messager.printMessage(Diagnostic.Kind.NOTE, message, element);
+    }
+
     public static void note(String message) {
         messager.printMessage(Diagnostic.Kind.NOTE, message);
     }
@@ -339,4 +375,19 @@ public static String getProxyInterfaceName(String className) {
         return className + Constants.INTERFACE_SUFFIX;
     }
 
+    public static NameConverter getNameFormatter(RealmNamingPolicy policy) {
+        if (policy == null) {
+            return new IdentityConverter();
+        }
+        switch (policy) {
+            case NO_POLICY: return new IdentityConverter();
+            case IDENTITY: return new IdentityConverter();
+            case LOWER_CASE_WITH_UNDERSCORES: return new LowerCaseWithSeparatorConverter('_');
+            case CAMEL_CASE: return new CamelCaseConverter();
+            case PASCAL_CASE: return new PascalCaseConverter();
+            default:
+                throw new IllegalArgumentException("Unknown policy: " + policy);
+        }
+    }
+
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.java
new file mode 100644
index 0000000000..f060cf2a41
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter;
+
+/**
+ * Converter that converts input to "camelCase".
+ */
+public class CamelCaseConverter implements NameConverter {
+
+    private final WordTokenizer tokenizer = new WordTokenizer();
+
+    @Override
+    public String convert(String name) {
+        String[] words = tokenizer.split(name);
+        StringBuilder output = new StringBuilder();
+        boolean firstWordEmitted = false;
+        for (int i = 0; i < words.length; i++) {
+            String word = words[i].toLowerCase();
+            if (firstWordEmitted) {
+                int codepoint = word.codePointAt(0);
+                output.appendCodePoint(Character.toUpperCase(codepoint));
+                output.append(word.substring(Character.charCount(codepoint)));
+            } else {
+                output.append(word);
+                firstWordEmitted = true;
+            }
+        }
+
+        return output.toString();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.java
new file mode 100644
index 0000000000..4408407c3a
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter;
+
+/**
+ * Converter that doesn't do any conversion when translating from Java to Realm.
+ *
+ * @see io.realm.annotations.RealmNamingPolicy#IDENTITY
+ */
+public class IdentityConverter implements NameConverter {
+
+    @Override
+    public String convert(String name) {
+        return name;
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.java
new file mode 100644
index 0000000000..3be7b191a3
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter;
+
+/**
+ * Converter that converts input to lower case with a defined separator character.
+ */
+public class LowerCaseWithSeparatorConverter implements NameConverter {
+
+    private final WordTokenizer tokenizer = new WordTokenizer();
+    private final char separator;
+
+    public LowerCaseWithSeparatorConverter(char separator) {
+        this.separator = separator;
+    }
+
+    @Override
+    public String convert(String name) {
+        String[] words = tokenizer.split(name);
+        StringBuilder output = new StringBuilder();
+        for (int i = 0; i < words.length; i++) {
+            String word = words[i].toLowerCase();
+            output.append(word);
+            if (i < words.length - 1) {
+                output.append(separator);
+            }
+        }
+
+        return output.toString();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.java
new file mode 100644
index 0000000000..593adf48ce
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter;
+
+/**
+ * Interface for converters that can implement a given naming policy.
+ *
+ * @see io.realm.annotations.RealmNamingPolicy
+ */
+public interface NameConverter {
+    /**
+     * Converts the {@code name} so it matches the {@link io.realm.annotations.RealmNamingPolicy}.
+     *
+     * @param name string to convert.
+     * @return the converted string.
+     */
+    String convert(String name);
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.java
new file mode 100644
index 0000000000..3849a72f64
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter;
+
+/**
+ * Converter that converts input to "PascalCase".
+ */
+public class PascalCaseConverter implements NameConverter {
+
+    private final WordTokenizer tokenizer = new WordTokenizer();
+
+    @Override
+    public String convert(String name) {
+        String[] words = tokenizer.split(name);
+        StringBuilder output = new StringBuilder();
+        for (int i = 0; i < words.length; i++) {
+            String word = words[i].toLowerCase();
+            int codepoint = word.codePointAt(0);
+            output.appendCodePoint(Character.toUpperCase(codepoint));
+            output.append(word.substring(Character.charCount(codepoint)));
+        }
+
+        return output.toString();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.java
new file mode 100644
index 0000000000..9a1e3caa27
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Segments a Java variable name into component words.
+ *
+ * Java variable names must follow the rules described in:
+ * https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.8
+ *
+ * In this implementation we treat word separators as any of the following:
+ * <ol>
+ *     <li>
+ *         Anytime a {@code _} or {@code $} is encountered.
+ *         Example is "_FooBar" or "_Foo$Bar" which both becomes "Foo" and "Bar".
+ *     </li>
+ *     <li>
+ *         Anytime you switch from a lower case character to an upper case character as
+ *         identified by a `Character.isUpperCase(codepoint)` and `Character.isLowerCase(codepoint)`.
+ *         Example is "FooBar" which becomes "Foo" and "Bar".
+ *     </li>
+ *     <li>
+ *         Anytime you switch from more than one uppercase character to a lower case one. As
+ *         identified by `Character.isUpperCase(codepoint)` and `Character.isLowerCase(codepoint)`.
+ *         Example is "FOOBar" which becomes "FOO" and "Bar.
+ *     </li>
+ *     <li>
+ *         Some characters like emojiis are neither uppercase or lowercase characters, so they will
+ *         not trigger any of the above rules.
+ *         Examples are "myüòÅ" and "MYüòÅ" which are both treated as one word.
+ *     </li>
+ *     <li>
+ *         Hungarian notation, i.e. strings starting with lowercase "m" followed by uppercase letter
+ *         is stripped and not considered part of any word.
+ *     </li>
+ * </ol>
+ */
+public class WordTokenizer {
+
+    /**
+     * Segments a string into words as described above
+     */
+    String[] split(String str) {
+        if (str == null || str.isEmpty()) {
+            return new String[0];
+        }
+
+        Integer previousCodepoint;
+        Integer currentCodepoint = null;
+        int length = str.length();
+        int offset = 0;
+        StringBuilder currentWord = new StringBuilder();
+        List<String> words = new ArrayList<>();
+        Boolean wordAllUpperCase = null;
+        int lastCodePointCharLength = 0;
+        while (offset < length) {
+            previousCodepoint = currentCodepoint;
+            currentCodepoint = str.codePointAt(offset);
+            int currentCharCount = Character.charCount(currentCodepoint);
+            boolean previousCodePointUpperCase = previousCodepoint != null && Character.isUpperCase(previousCodepoint);
+            boolean previousCodePointLowerCase = previousCodepoint != null && Character.isLowerCase(previousCodepoint);
+            boolean currentCodePointUpperCase = Character.isUpperCase(currentCodepoint);
+            boolean currentCodePointLowerCase = Character.isLowerCase(currentCodepoint);
+
+            // Separator char encountered not part of any word, but indicate a boundary
+            if (currentCodepoint == '_' || currentCodepoint == '$') {
+                if (currentWord.length() > 0) {
+                    words.add(currentWord.toString());
+                    currentWord.setLength(0);
+                }
+
+                wordAllUpperCase = null;
+                offset += currentCharCount;
+                lastCodePointCharLength = 0;
+                continue;
+            }
+
+            // Change between lower case and upper case indicate a word boundary
+            if (previousCodePointLowerCase && currentCodePointUpperCase) {
+                if (currentWord.length() > 0) {
+                    words.add(currentWord.toString());
+                    currentWord.setLength(0);
+                    currentWord.appendCodePoint(currentCodepoint);
+                }
+
+                wordAllUpperCase = true;
+                offset += currentCharCount;
+                lastCodePointCharLength = currentCharCount;
+                continue;
+            }
+
+            // Change between upper case and lower case indicated a word boundary on the previous
+            // char if multiple upper case characters where encountered.
+            if (currentWord.length() > 1
+                    && (wordAllUpperCase != null && wordAllUpperCase)
+                    && previousCodePointUpperCase && currentCodePointLowerCase) {
+                words.add(currentWord.substring(0, currentWord.length() - lastCodePointCharLength));
+                currentWord.substring(0, currentWord.length() - lastCodePointCharLength);
+                currentWord.delete(0, currentWord.length() - lastCodePointCharLength);
+                currentWord.appendCodePoint(currentCodepoint);
+
+                wordAllUpperCase = false;
+                offset += currentCharCount;
+                lastCodePointCharLength = currentCharCount;
+                continue;
+            }
+
+            // Add codepoint to current word
+            currentWord.appendCodePoint(currentCodepoint);
+            wordAllUpperCase = currentCodePointUpperCase && (wordAllUpperCase == null || wordAllUpperCase);
+            offset += currentCharCount;
+            lastCodePointCharLength = currentCharCount;
+        }
+
+        // Add final word when exiting loop
+        if (currentWord.length() > 0) {
+            words.add(currentWord.toString());
+        }
+
+        // Remove hungarian notation if found
+        if (words.get(0).equals("m")) {
+            words.remove(0);
+        }
+
+        String[] result = new String[words.size()];
+        words.toArray(result);
+        return result;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/NameConverterTests.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/NameConverterTests.java
new file mode 100644
index 0000000000..8465d0d28c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/NameConverterTests.java
@@ -0,0 +1,149 @@
+package io.realm.processor;
+
+import org.junit.Test;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import io.realm.processor.nameconverter.CamelCaseConverter;
+import io.realm.processor.nameconverter.LowerCaseWithSeparatorConverter;
+import io.realm.processor.nameconverter.NameConverter;
+import io.realm.processor.nameconverter.PascalCaseConverter;
+
+import static org.junit.Assert.assertEquals;
+
+public class NameConverterTests {
+
+    @Test
+    public void camelCase() {
+        NameConverter converter = new CamelCaseConverter();
+        Map<String, String> values = new LinkedHashMap<String, String>() {{
+            // <JavaName, InternalName>
+            put("camelCase", "camelCase");
+            put("PascalCase", "pascalCase");
+            put("mHungarianNotation", "hungarianNotation");
+            put("_PascalCaseWithStartingSeparator", "pascalCaseWithStartingSeparator");
+            put("_camelCaseWithStartingSeparator", "camelCaseWithStartingSeparator");
+            put("ALL_CAPS_WITH_SEPARATOR", "allCapsWithSeparator");
+            put("ALLCAPS", "allcaps");
+            put("_ALL_CAPS_WITH_STARTING_SEPARATOR", "allCapsWithStartingSeparator");
+            put("alllower", "alllower");
+            put("all_lower_with_separator", "allLowerWithSeparator");
+
+            // $ Separator
+            put("$generatedNames", "generatedNames");
+            put("generatedNames$", "generatedNames");
+            put("generated$Names", "generatedNames");
+
+            // Non-ascii chars
+            put("œÄPi", "œÄPi");
+            put("NonAscii√Ü√∏√Ö", "nonAscii√Ü√∏√Ö");
+
+            // Multiple upper case letters
+            put("HTMLFile", "htmlFile");
+            put("aHTMLFile", "aHtmlFile");
+            put("_HTMLFile", "htmlFile");
+
+            // Emojiis are neither upper case nor lower case (Smiley)
+            put("\uD83D\uDE01", "\uD83D\uDE01");
+            put("m\uD83D\uDE01", "m\uD83D\uDE01");
+            put("M\uD83D\uDE01", "m\uD83D\uDE01");
+            put("\uD83D\uDE01Smiley", "\uD83D\uDE01smiley");
+            put("_\uD83D\uDE01smiley", "\uD83D\uDE01smiley");
+        }};
+
+        for (Map.Entry<String, String> entry : values.entrySet()) {
+            assertEquals(entry.getValue(), converter.convert(entry.getKey()));
+        }
+    }
+
+    @Test
+    public void pascalCase() {
+        NameConverter converter = new PascalCaseConverter();
+        Map<String, String> values = new LinkedHashMap<String, String>() {{
+            // <JavaName, InternalName>
+            put("camelCase", "CamelCase");
+            put("PascalCase", "PascalCase");
+            put("mHungarianNotation", "HungarianNotation");
+            put("_PascalCaseWithStartingSeparator", "PascalCaseWithStartingSeparator");
+            put("_camelCaseWithStartingSeparator", "CamelCaseWithStartingSeparator");
+            put("ALL_CAPS_WITH_SEPARATOR", "AllCapsWithSeparator");
+            put("ALLCAPS", "Allcaps");
+            put("_ALL_CAPS_WITH_STARTING_SEPARATOR", "AllCapsWithStartingSeparator");
+            put("alllower", "Alllower");
+            put("all_lower_with_separator", "AllLowerWithSeparator");
+
+            // $ Separator
+            put("$generatedNames", "GeneratedNames");
+            put("generatedNames$", "GeneratedNames");
+            put("generated$Names", "GeneratedNames");
+
+            // Non-ascii chars
+            put("œÄPi", "Œ†Pi");
+            put("NonAscii√Ü√∏√Ö", "NonAscii√Ü√∏√Ö");
+
+            // Multiple upper case letters
+            put("HTMLFile", "HtmlFile");
+            put("aHTMLFile", "AHtmlFile");
+            put("_HTMLFile", "HtmlFile");
+
+            // Emojiis are neither upper case nor lower case (Smiley)
+            put("\uD83D\uDE01", "\uD83D\uDE01");
+            put("m\uD83D\uDE01", "M\uD83D\uDE01");
+            put("M\uD83D\uDE01", "M\uD83D\uDE01");
+            put("\uD83D\uDE01Smiley", "\uD83D\uDE01smiley");
+            put("_\uD83D\uDE01smiley", "\uD83D\uDE01smiley");
+        }};
+
+        for (Map.Entry<String, String> entry : values.entrySet()) {
+            assertEquals(entry.getValue(), converter.convert(entry.getKey()));
+        }
+    }
+
+    @Test
+    public void lowerCaseWithUnderscore() {
+        NameConverter converter = new LowerCaseWithSeparatorConverter('_');
+        Map<String, String> values = new LinkedHashMap<String, String>() {{
+            // <JavaName, InternalName>
+            // Common naming schemes using ASCII chars
+            put("camelCase", "camel_case");
+            put("PascalCase", "pascal_case");
+            put("mHungarianNotation", "hungarian_notation");
+            put("_mHungarianNotation", "hungarian_notation");
+            put("mHungarian_mNotation", "hungarian_m_notation");
+            put("_PascalCaseWithStartingSeparator", "pascal_case_with_starting_separator");
+            put("_camelCaseWithStartingSeparator", "camel_case_with_starting_separator");
+            put("ALL_CAPS_WITH_SEPARATOR", "all_caps_with_separator");
+            put("ALLCAPS", "allcaps");
+            put("_ALL_CAPS_WITH_STARTING_SEPARATOR", "all_caps_with_starting_separator");
+            put("alllower", "alllower");
+            put("all_lower_with_separator", "all_lower_with_separator");
+
+            // $ Separator
+            put("$generatedNames", "generated_names");
+            put("generatedNames$", "generated_names");
+            put("generated$Names", "generated_names");
+
+            // Non-ascii chars
+            put("œÄPi", "œÄ_pi");
+            put("NonAscii√Ü√∏√Ö", "non_ascii_√¶√∏_√•");
+
+            // Multiple upper case letters
+            put("HTMLFile", "html_file");
+            put("aHTMLFile", "a_html_file");
+            put("_HTMLFile", "html_file");
+
+            // Emojiis are neither upper case nor lower case (Smiley)
+            put("\uD83D\uDE01", "\uD83D\uDE01");
+            put("m\uD83D\uDE01", "m\uD83D\uDE01");
+            put("M\uD83D\uDE01", "m\uD83D\uDE01");
+            put("\uD83D\uDE01Smiley", "\uD83D\uDE01smiley");
+            put("_\uD83D\uDE01smiley", "\uD83D\uDE01smiley");
+        }};
+
+        for (Map.Entry<String, String> entry : values.entrySet()) {
+            assertEquals(entry.getValue(), converter.convert(entry.getKey()));
+        }
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
index 76a8f61ffd..46448a3a0c 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
@@ -131,7 +131,7 @@ public void failsOnLinkingObjectsWithRequiredFields() throws IOException {
                 .that(Arrays.asList(backlinksTarget, javaFileObject))
                 .processedWith(new RealmProcessor())
                 .failsToCompile()
-                .withErrorContaining("cannot be @Required");
+                .withErrorContaining("The @LinkingObjects field ");
     }
 
     @Test
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmNameTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmNameTest.java
new file mode 100644
index 0000000000..033cae1101
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmNameTest.java
@@ -0,0 +1,113 @@
+package io.realm.processor;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+public class RealmNameTest {
+
+    // Check that a class only with class name policy compiles
+    @Test
+    public void compileOnlyClassNamePolicyFile() {
+        ASSERT.about(javaSource())
+                .that(JavaFileObjects.forResource("some/test/NamePolicyClassOnly.java"))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    // Check that a class only with a field name policy compiles
+    @Test
+    public void compileOnlyFieldNamePolicyFile() {
+        ASSERT.about(javaSource())
+                .that(JavaFileObjects.forResource("some/test/NamePolicyFieldNameOnly.java"))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    // Check that things compile if there is only a module with name policies defined
+    @Test
+    public void compileModuleWithNamePolicyFile() {
+        ASSERT.about(javaSource())
+                .that(JavaFileObjects.forResource("some/test/NamePolicyModule.java"))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    // Check the effect of setting both module class/field name policies, class name, field
+    // name policy and explicit names on fields (i.e = Specific class name + field name should win.
+    @Test
+    public void compareProcessedNamingPolicyClassFile() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(
+                    JavaFileObjects.forResource("some/test/NamePolicyModule.java"),
+                    JavaFileObjects.forResource("some/test/NamePolicyMixedClassSettings.java"),
+                    JavaFileObjects.forResource("some/test/NamePolicyFieldNameOnly.java"),
+                    JavaFileObjects.forResource("some/test/NamePolicyClassOnly.java")
+                ))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError()
+                .and()
+                .generatesSources(JavaFileObjects.forResource("io/realm/NamePolicyMixedClassSettingsRealmProxy.java"));
+    }
+
+    // Check the effect of module default on a class with no settings itself
+    @Test
+    public void compareProcessedDefaultClassFile() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(
+                        JavaFileObjects.forResource("some/test/NamePolicyModule.java"),
+                        JavaFileObjects.forResource("some/test/NamePolicyModuleDefaults.java")
+                ))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError()
+                .and()
+                .generatesSources(JavaFileObjects.forResource("io/realm/NamePolicyModuleDefaultsRealmProxy.java"));
+    }
+
+    // Check that trying to compile two modules with different policies using `allClasses = true` will fail.
+    @Test
+    public void compileModulesWithConflictingPoliciesForAllClassesFails() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(
+                        JavaFileObjects.forResource("some/test/NamePolicyConflictingModuleDefinitionsForAllClasses.java"),
+                        JavaFileObjects.forResource("some/test/Simple.java")
+                ))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("disagree on the class naming policy");
+    }
+
+    // Check that trying to compile two modules with different policies using `classes = { ... }` will fail.
+    @Test
+    public void compileModulesWithConflictingPoliciesForNamedClassesFails() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(
+                        JavaFileObjects.forResource("some/test/NamePolicyConflictingModuleDefinitionsForNamedClasses.java"),
+                        JavaFileObjects.forResource("some/test/Simple.java")
+                ))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("disagree on the class naming policy");
+    }
+
+    // Check that trying to compile two modules with different policies using a mix of `allClasses`
+    // and `classes = { ... }` will fail.
+    @Test
+    public void compileModulesWithConflictingPoliciesAndMixedClassDefinitionsFails() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(
+                        JavaFileObjects.forResource("some/test/NamePolicyConflictingModuleDefinitionsForMixedDefinitions.java"),
+                        JavaFileObjects.forResource("some/test/Simple.java")
+                ))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("disagree on the class naming policy");
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 9907db2b3c..ec043729e6 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -343,7 +343,7 @@ public void compileRequiredTypes() throws IOException {
 
         for (String fieldType : validPrimaryKeyFieldTypes) {
             RealmSyntheticTestClass javaFileObject =
-                    new RealmSyntheticTestClass.Builder().name("ValidPrimaryKeyType").field("testField", fieldType, "Required").build();
+                    new RealmSyntheticTestClass.Builder().name("ValidRequiredType").field("testField", fieldType, "Required").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -354,14 +354,16 @@ public void compileRequiredTypes() throws IOException {
     // Not supported "Required" annotation types
     @Test
     public void compileInvalidRequiredTypes() throws IOException {
-        final String[] validPrimaryKeyFieldTypes = {"byte", "short", "int", "long", "float", "double",
+        final String[] invalidRequiredAnnotationFieldTypes = {"byte", "short", "int", "long", "float", "double",
                 "boolean", "RealmList<Simple>", "Simple"};
 
-        for (String fieldType : validPrimaryKeyFieldTypes) {
-            RealmSyntheticTestClass javaFileObject =
-                    new RealmSyntheticTestClass.Builder().name("ValidPrimaryKeyType").field("testField", fieldType, "Required").build();
-            ASSERT.about(javaSource())
-                    .that(javaFileObject)
+        for (String fieldType : invalidRequiredAnnotationFieldTypes) {
+            RealmSyntheticTestClass javaFileObject = new RealmSyntheticTestClass.Builder()
+                    .name("InvalidRequiredType")
+                    .field("testField", fieldType, "Required")
+                    .build();
+            ASSERT.about(javaSources())
+                    .that(Arrays.asList(simpleModel, javaFileObject))
                     .processedWith(new RealmProcessor())
                     .failsToCompile();
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 03e4de06d4..4351c458c9 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -60,26 +60,26 @@
         AllTypesColumnInfo(OsSchemaInfo schemaInfo) {
             super(20);
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("AllTypes");
-            this.columnStringIndex = addColumnDetails("columnString", objectSchemaInfo);
-            this.columnLongIndex = addColumnDetails("columnLong", objectSchemaInfo);
-            this.columnFloatIndex = addColumnDetails("columnFloat", objectSchemaInfo);
-            this.columnDoubleIndex = addColumnDetails("columnDouble", objectSchemaInfo);
-            this.columnBooleanIndex = addColumnDetails("columnBoolean", objectSchemaInfo);
-            this.columnDateIndex = addColumnDetails("columnDate", objectSchemaInfo);
-            this.columnBinaryIndex = addColumnDetails("columnBinary", objectSchemaInfo);
-            this.columnMutableRealmIntegerIndex = addColumnDetails("columnMutableRealmInteger", objectSchemaInfo);
-            this.columnObjectIndex = addColumnDetails("columnObject", objectSchemaInfo);
-            this.columnRealmListIndex = addColumnDetails("columnRealmList", objectSchemaInfo);
-            this.columnStringListIndex = addColumnDetails("columnStringList", objectSchemaInfo);
-            this.columnBinaryListIndex = addColumnDetails("columnBinaryList", objectSchemaInfo);
-            this.columnBooleanListIndex = addColumnDetails("columnBooleanList", objectSchemaInfo);
-            this.columnLongListIndex = addColumnDetails("columnLongList", objectSchemaInfo);
-            this.columnIntegerListIndex = addColumnDetails("columnIntegerList", objectSchemaInfo);
-            this.columnShortListIndex = addColumnDetails("columnShortList", objectSchemaInfo);
-            this.columnByteListIndex = addColumnDetails("columnByteList", objectSchemaInfo);
-            this.columnDoubleListIndex = addColumnDetails("columnDoubleList", objectSchemaInfo);
-            this.columnFloatListIndex = addColumnDetails("columnFloatList", objectSchemaInfo);
-            this.columnDateListIndex = addColumnDetails("columnDateList", objectSchemaInfo);
+            this.columnStringIndex = addColumnDetails("columnString", "columnString", objectSchemaInfo);
+            this.columnLongIndex = addColumnDetails("columnLong", "columnLong", objectSchemaInfo);
+            this.columnFloatIndex = addColumnDetails("columnFloat", "columnFloat", objectSchemaInfo);
+            this.columnDoubleIndex = addColumnDetails("columnDouble", "columnDouble", objectSchemaInfo);
+            this.columnBooleanIndex = addColumnDetails("columnBoolean", "columnBoolean", objectSchemaInfo);
+            this.columnDateIndex = addColumnDetails("columnDate", "columnDate", objectSchemaInfo);
+            this.columnBinaryIndex = addColumnDetails("columnBinary", "columnBinary", objectSchemaInfo);
+            this.columnMutableRealmIntegerIndex = addColumnDetails("columnMutableRealmInteger", "columnMutableRealmInteger", objectSchemaInfo);
+            this.columnObjectIndex = addColumnDetails("columnObject", "columnObject", objectSchemaInfo);
+            this.columnRealmListIndex = addColumnDetails("columnRealmList", "columnRealmList", objectSchemaInfo);
+            this.columnStringListIndex = addColumnDetails("columnStringList", "columnStringList", objectSchemaInfo);
+            this.columnBinaryListIndex = addColumnDetails("columnBinaryList", "columnBinaryList", objectSchemaInfo);
+            this.columnBooleanListIndex = addColumnDetails("columnBooleanList", "columnBooleanList", objectSchemaInfo);
+            this.columnLongListIndex = addColumnDetails("columnLongList", "columnLongList", objectSchemaInfo);
+            this.columnIntegerListIndex = addColumnDetails("columnIntegerList", "columnIntegerList", objectSchemaInfo);
+            this.columnShortListIndex = addColumnDetails("columnShortList", "columnShortList", objectSchemaInfo);
+            this.columnByteListIndex = addColumnDetails("columnByteList", "columnByteList", objectSchemaInfo);
+            this.columnDoubleListIndex = addColumnDetails("columnDoubleList", "columnDoubleList", objectSchemaInfo);
+            this.columnFloatListIndex = addColumnDetails("columnFloatList", "columnFloatList", objectSchemaInfo);
+            this.columnDateListIndex = addColumnDetails("columnDateList", "columnDateList", objectSchemaInfo);
             addBacklinkDetails(schemaInfo, "parentObjects", "AllTypes", "columnObject");
         }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index cb8c2ffb70..f0a55dba46 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -43,10 +43,10 @@
         BooleansColumnInfo(OsSchemaInfo schemaInfo) {
             super(4);
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Booleans");
-            this.doneIndex = addColumnDetails("done", objectSchemaInfo);
-            this.isReadyIndex = addColumnDetails("isReady", objectSchemaInfo);
-            this.mCompletedIndex = addColumnDetails("mCompleted", objectSchemaInfo);
-            this.anotherBooleanIndex = addColumnDetails("anotherBoolean", objectSchemaInfo);
+            this.doneIndex = addColumnDetails("done", "done", objectSchemaInfo);
+            this.isReadyIndex = addColumnDetails("isReady", "isReady", objectSchemaInfo);
+            this.mCompletedIndex = addColumnDetails("mCompleted", "mCompleted", objectSchemaInfo);
+            this.anotherBooleanIndex = addColumnDetails("anotherBoolean", "anotherBoolean", objectSchemaInfo);
         }
 
         BooleansColumnInfo(ColumnInfo src, boolean mutable) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NamePolicyMixedClassSettingsRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NamePolicyMixedClassSettingsRealmProxy.java
new file mode 100644
index 0000000000..5b37b1c93c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NamePolicyMixedClassSettingsRealmProxy.java
@@ -0,0 +1,443 @@
+package io.realm;
+
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.util.JsonReader;
+import android.util.JsonToken;
+import io.realm.ProxyUtils;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+@SuppressWarnings("all")
+public class NamePolicyMixedClassSettingsRealmProxy extends some.test.NamePolicyMixedClassSettings
+        implements RealmObjectProxy, NamePolicyMixedClassSettingsRealmProxyInterface {
+
+    static final class NamePolicyMixedClassSettingsColumnInfo extends ColumnInfo {
+        long firstNameIndex;
+        long lastNameIndex;
+
+        NamePolicyMixedClassSettingsColumnInfo(OsSchemaInfo schemaInfo) {
+            super(2);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("customName");
+            this.firstNameIndex = addColumnDetails("firstName", "first_name", objectSchemaInfo);
+            this.lastNameIndex = addColumnDetails("lastName", "LastName", objectSchemaInfo);
+        }
+
+        NamePolicyMixedClassSettingsColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
+        }
+
+        @Override
+        protected final ColumnInfo copy(boolean mutable) {
+            return new NamePolicyMixedClassSettingsColumnInfo(this, mutable);
+        }
+
+        @Override
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final NamePolicyMixedClassSettingsColumnInfo src = (NamePolicyMixedClassSettingsColumnInfo) rawSrc;
+            final NamePolicyMixedClassSettingsColumnInfo dst = (NamePolicyMixedClassSettingsColumnInfo) rawDst;
+            dst.firstNameIndex = src.firstNameIndex;
+            dst.lastNameIndex = src.lastNameIndex;
+        }
+    }
+
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
+
+    private NamePolicyMixedClassSettingsColumnInfo columnInfo;
+    private ProxyState<some.test.NamePolicyMixedClassSettings> proxyState;
+
+    NamePolicyMixedClassSettingsRealmProxy() {
+        proxyState.setConstructionFinished();
+    }
+
+    @Override
+    public void realm$injectObjectContext() {
+        if (this.proxyState != null) {
+            return;
+        }
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (NamePolicyMixedClassSettingsColumnInfo) context.getColumnInfo();
+        this.proxyState = new ProxyState<some.test.NamePolicyMixedClassSettings>(this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
+    }
+
+    @Override
+    @SuppressWarnings("cast")
+    public String realmGet$firstName() {
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.firstNameIndex);
+    }
+
+    @Override
+    public void realmSet$firstName(String value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.firstNameIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.firstNameIndex, row.getIndex(), value, true);
+            return;
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        if (value == null) {
+            proxyState.getRow$realm().setNull(columnInfo.firstNameIndex);
+            return;
+        }
+        proxyState.getRow$realm().setString(columnInfo.firstNameIndex, value);
+    }
+
+    @Override
+    @SuppressWarnings("cast")
+    public String realmGet$lastName() {
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.lastNameIndex);
+    }
+
+    @Override
+    public void realmSet$lastName(String value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.lastNameIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.lastNameIndex, row.getIndex(), value, true);
+            return;
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        if (value == null) {
+            proxyState.getRow$realm().setNull(columnInfo.lastNameIndex);
+            return;
+        }
+        proxyState.getRow$realm().setString(columnInfo.lastNameIndex, value);
+    }
+
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("customName", 2, 0);
+        builder.addPersistedProperty("first_name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("LastName", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
+    }
+
+    public static NamePolicyMixedClassSettingsColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new NamePolicyMixedClassSettingsColumnInfo(schemaInfo);
+    }
+
+    public static String getSimpleClassName() {
+        return "customName";
+    }
+
+    @SuppressWarnings("cast")
+    public static some.test.NamePolicyMixedClassSettings createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        final List<String> excludeFields = Collections.<String> emptyList();
+        some.test.NamePolicyMixedClassSettings obj = realm.createObjectInternal(some.test.NamePolicyMixedClassSettings.class, true, excludeFields);
+
+        final NamePolicyMixedClassSettingsRealmProxyInterface objProxy = (NamePolicyMixedClassSettingsRealmProxyInterface) obj;
+        if (json.has("firstName")) {
+            if (json.isNull("firstName")) {
+                objProxy.realmSet$firstName(null);
+            } else {
+                objProxy.realmSet$firstName((String) json.getString("firstName"));
+            }
+        }
+        if (json.has("lastName")) {
+            if (json.isNull("lastName")) {
+                objProxy.realmSet$lastName(null);
+            } else {
+                objProxy.realmSet$lastName((String) json.getString("lastName"));
+            }
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("cast")
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static some.test.NamePolicyMixedClassSettings createUsingJsonStream(Realm realm, JsonReader reader)
+            throws IOException {
+        final some.test.NamePolicyMixedClassSettings obj = new some.test.NamePolicyMixedClassSettings();
+        final NamePolicyMixedClassSettingsRealmProxyInterface objProxy = (NamePolicyMixedClassSettingsRealmProxyInterface) obj;
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (false) {
+            } else if (name.equals("firstName")) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$firstName((String) reader.nextString());
+                } else {
+                    reader.skipValue();
+                    objProxy.realmSet$firstName(null);
+                }
+            } else if (name.equals("lastName")) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$lastName((String) reader.nextString());
+                } else {
+                    reader.skipValue();
+                    objProxy.realmSet$lastName(null);
+                }
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return realm.copyToRealm(obj);
+    }
+
+    public static some.test.NamePolicyMixedClassSettings copyOrUpdate(Realm realm, some.test.NamePolicyMixedClassSettings object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
+        }
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.NamePolicyMixedClassSettings) cachedRealmObject;
+        }
+
+        return copy(realm, object, update, cache);
+    }
+
+    public static some.test.NamePolicyMixedClassSettings copy(Realm realm, some.test.NamePolicyMixedClassSettings newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.NamePolicyMixedClassSettings) cachedRealmObject;
+        }
+
+        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+        some.test.NamePolicyMixedClassSettings realmObject = realm.createObjectInternal(some.test.NamePolicyMixedClassSettings.class, false, Collections.<String>emptyList());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+
+        NamePolicyMixedClassSettingsRealmProxyInterface realmObjectSource = (NamePolicyMixedClassSettingsRealmProxyInterface) newObject;
+        NamePolicyMixedClassSettingsRealmProxyInterface realmObjectCopy = (NamePolicyMixedClassSettingsRealmProxyInterface) realmObject;
+
+        realmObjectCopy.realmSet$firstName(realmObjectSource.realmGet$firstName());
+        realmObjectCopy.realmSet$lastName(realmObjectSource.realmGet$lastName());
+        return realmObject;
+    }
+
+    public static long insert(Realm realm, some.test.NamePolicyMixedClassSettings object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.NamePolicyMixedClassSettings.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyMixedClassSettingsColumnInfo columnInfo = (NamePolicyMixedClassSettingsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyMixedClassSettings.class);
+        long rowIndex = OsObject.createRow(table);
+        cache.put(object, rowIndex);
+        String realmGet$firstName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$firstName();
+        if (realmGet$firstName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+        }
+        String realmGet$lastName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$lastName();
+        if (realmGet$lastName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+        }
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NamePolicyMixedClassSettings.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyMixedClassSettingsColumnInfo columnInfo = (NamePolicyMixedClassSettingsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyMixedClassSettings.class);
+        some.test.NamePolicyMixedClassSettings object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NamePolicyMixedClassSettings) objects.next();
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$firstName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$firstName();
+            if (realmGet$firstName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+            }
+            String realmGet$lastName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$lastName();
+            if (realmGet$lastName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.NamePolicyMixedClassSettings object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.NamePolicyMixedClassSettings.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyMixedClassSettingsColumnInfo columnInfo = (NamePolicyMixedClassSettingsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyMixedClassSettings.class);
+        long rowIndex = OsObject.createRow(table);
+        cache.put(object, rowIndex);
+        String realmGet$firstName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$firstName();
+        if (realmGet$firstName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.firstNameIndex, rowIndex, false);
+        }
+        String realmGet$lastName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$lastName();
+        if (realmGet$lastName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.lastNameIndex, rowIndex, false);
+        }
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NamePolicyMixedClassSettings.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyMixedClassSettingsColumnInfo columnInfo = (NamePolicyMixedClassSettingsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyMixedClassSettings.class);
+        some.test.NamePolicyMixedClassSettings object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NamePolicyMixedClassSettings) objects.next();
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$firstName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$firstName();
+            if (realmGet$firstName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.firstNameIndex, rowIndex, false);
+            }
+            String realmGet$lastName = ((NamePolicyMixedClassSettingsRealmProxyInterface) object).realmGet$lastName();
+            if (realmGet$lastName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.lastNameIndex, rowIndex, false);
+            }
+        }
+    }
+
+    public static some.test.NamePolicyMixedClassSettings createDetachedCopy(some.test.NamePolicyMixedClassSettings realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+        if (currentDepth > maxDepth || realmObject == null) {
+            return null;
+        }
+        CacheData<RealmModel> cachedObject = cache.get(realmObject);
+        some.test.NamePolicyMixedClassSettings unmanagedObject;
+        if (cachedObject == null) {
+            unmanagedObject = new some.test.NamePolicyMixedClassSettings();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+        } else {
+            // Reuse cached object or recreate it because it was encountered at a lower depth.
+            if (currentDepth >= cachedObject.minDepth) {
+                return (some.test.NamePolicyMixedClassSettings) cachedObject.object;
+            }
+            unmanagedObject = (some.test.NamePolicyMixedClassSettings) cachedObject.object;
+            cachedObject.minDepth = currentDepth;
+        }
+        NamePolicyMixedClassSettingsRealmProxyInterface unmanagedCopy = (NamePolicyMixedClassSettingsRealmProxyInterface) unmanagedObject;
+        NamePolicyMixedClassSettingsRealmProxyInterface realmSource = (NamePolicyMixedClassSettingsRealmProxyInterface) realmObject;
+        unmanagedCopy.realmSet$firstName(realmSource.realmGet$firstName());
+        unmanagedCopy.realmSet$lastName(realmSource.realmGet$lastName());
+
+        return unmanagedObject;
+    }
+
+    @Override
+    @SuppressWarnings("ArrayToString")
+    public String toString() {
+        if (!RealmObject.isValid(this)) {
+            return "Invalid object";
+        }
+        StringBuilder stringBuilder = new StringBuilder("NamePolicyMixedClassSettings = proxy[");
+        stringBuilder.append("{firstName:");
+        stringBuilder.append(realmGet$firstName() != null ? realmGet$firstName() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{lastName:");
+        stringBuilder.append(realmGet$lastName() != null ? realmGet$lastName() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append("]");
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public ProxyState<?> realmGet$proxyState() {
+        return proxyState;
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = proxyState.getRealm$realm().getPath();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        long rowIndex = proxyState.getRow$realm().getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        NamePolicyMixedClassSettingsRealmProxy aNamePolicyMixedClassSettings = (NamePolicyMixedClassSettingsRealmProxy)o;
+
+        String path = proxyState.getRealm$realm().getPath();
+        String otherPath = aNamePolicyMixedClassSettings.proxyState.getRealm$realm().getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
+
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        String otherTableName = aNamePolicyMixedClassSettings.proxyState.getRow$realm().getTable().getName();
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
+
+        if (proxyState.getRow$realm().getIndex() != aNamePolicyMixedClassSettings.proxyState.getRow$realm().getIndex()) return false;
+
+        return true;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NamePolicyModuleDefaultsRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NamePolicyModuleDefaultsRealmProxy.java
new file mode 100644
index 0000000000..b1aaceae87
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NamePolicyModuleDefaultsRealmProxy.java
@@ -0,0 +1,443 @@
+package io.realm;
+
+
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.util.JsonReader;
+import android.util.JsonToken;
+import io.realm.ProxyUtils;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+@SuppressWarnings("all")
+public class NamePolicyModuleDefaultsRealmProxy extends some.test.NamePolicyModuleDefaults
+        implements RealmObjectProxy, NamePolicyModuleDefaultsRealmProxyInterface {
+
+    static final class NamePolicyModuleDefaultsColumnInfo extends ColumnInfo {
+        long firstNameIndex;
+        long lastNameIndex;
+
+        NamePolicyModuleDefaultsColumnInfo(OsSchemaInfo schemaInfo) {
+            super(2);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("NamePolicyModuleDefaults");
+            this.firstNameIndex = addColumnDetails("firstName", "FirstName", objectSchemaInfo);
+            this.lastNameIndex = addColumnDetails("lastName", "LastName", objectSchemaInfo);
+        }
+
+        NamePolicyModuleDefaultsColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
+        }
+
+        @Override
+        protected final ColumnInfo copy(boolean mutable) {
+            return new NamePolicyModuleDefaultsColumnInfo(this, mutable);
+        }
+
+        @Override
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final NamePolicyModuleDefaultsColumnInfo src = (NamePolicyModuleDefaultsColumnInfo) rawSrc;
+            final NamePolicyModuleDefaultsColumnInfo dst = (NamePolicyModuleDefaultsColumnInfo) rawDst;
+            dst.firstNameIndex = src.firstNameIndex;
+            dst.lastNameIndex = src.lastNameIndex;
+        }
+    }
+
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
+
+    private NamePolicyModuleDefaultsColumnInfo columnInfo;
+    private ProxyState<some.test.NamePolicyModuleDefaults> proxyState;
+
+    NamePolicyModuleDefaultsRealmProxy() {
+        proxyState.setConstructionFinished();
+    }
+
+    @Override
+    public void realm$injectObjectContext() {
+        if (this.proxyState != null) {
+            return;
+        }
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (NamePolicyModuleDefaultsColumnInfo) context.getColumnInfo();
+        this.proxyState = new ProxyState<some.test.NamePolicyModuleDefaults>(this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
+    }
+
+    @Override
+    @SuppressWarnings("cast")
+    public String realmGet$firstName() {
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.firstNameIndex);
+    }
+
+    @Override
+    public void realmSet$firstName(String value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.firstNameIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.firstNameIndex, row.getIndex(), value, true);
+            return;
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        if (value == null) {
+            proxyState.getRow$realm().setNull(columnInfo.firstNameIndex);
+            return;
+        }
+        proxyState.getRow$realm().setString(columnInfo.firstNameIndex, value);
+    }
+
+    @Override
+    @SuppressWarnings("cast")
+    public String realmGet$lastName() {
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.lastNameIndex);
+    }
+
+    @Override
+    public void realmSet$lastName(String value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.lastNameIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.lastNameIndex, row.getIndex(), value, true);
+            return;
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        if (value == null) {
+            proxyState.getRow$realm().setNull(columnInfo.lastNameIndex);
+            return;
+        }
+        proxyState.getRow$realm().setString(columnInfo.lastNameIndex, value);
+    }
+
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("NamePolicyModuleDefaults", 2, 0);
+        builder.addPersistedProperty("FirstName", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("LastName", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
+    }
+
+    public static NamePolicyModuleDefaultsColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new NamePolicyModuleDefaultsColumnInfo(schemaInfo);
+    }
+
+    public static String getSimpleClassName() {
+        return "NamePolicyModuleDefaults";
+    }
+
+    @SuppressWarnings("cast")
+    public static some.test.NamePolicyModuleDefaults createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        final List<String> excludeFields = Collections.<String> emptyList();
+        some.test.NamePolicyModuleDefaults obj = realm.createObjectInternal(some.test.NamePolicyModuleDefaults.class, true, excludeFields);
+
+        final NamePolicyModuleDefaultsRealmProxyInterface objProxy = (NamePolicyModuleDefaultsRealmProxyInterface) obj;
+        if (json.has("firstName")) {
+            if (json.isNull("firstName")) {
+                objProxy.realmSet$firstName(null);
+            } else {
+                objProxy.realmSet$firstName((String) json.getString("firstName"));
+            }
+        }
+        if (json.has("lastName")) {
+            if (json.isNull("lastName")) {
+                objProxy.realmSet$lastName(null);
+            } else {
+                objProxy.realmSet$lastName((String) json.getString("lastName"));
+            }
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("cast")
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static some.test.NamePolicyModuleDefaults createUsingJsonStream(Realm realm, JsonReader reader)
+            throws IOException {
+        final some.test.NamePolicyModuleDefaults obj = new some.test.NamePolicyModuleDefaults();
+        final NamePolicyModuleDefaultsRealmProxyInterface objProxy = (NamePolicyModuleDefaultsRealmProxyInterface) obj;
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (false) {
+            } else if (name.equals("firstName")) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$firstName((String) reader.nextString());
+                } else {
+                    reader.skipValue();
+                    objProxy.realmSet$firstName(null);
+                }
+            } else if (name.equals("lastName")) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$lastName((String) reader.nextString());
+                } else {
+                    reader.skipValue();
+                    objProxy.realmSet$lastName(null);
+                }
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return realm.copyToRealm(obj);
+    }
+
+    public static some.test.NamePolicyModuleDefaults copyOrUpdate(Realm realm, some.test.NamePolicyModuleDefaults object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
+        }
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.NamePolicyModuleDefaults) cachedRealmObject;
+        }
+
+        return copy(realm, object, update, cache);
+    }
+
+    public static some.test.NamePolicyModuleDefaults copy(Realm realm, some.test.NamePolicyModuleDefaults newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.NamePolicyModuleDefaults) cachedRealmObject;
+        }
+
+        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+        some.test.NamePolicyModuleDefaults realmObject = realm.createObjectInternal(some.test.NamePolicyModuleDefaults.class, false, Collections.<String>emptyList());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+
+        NamePolicyModuleDefaultsRealmProxyInterface realmObjectSource = (NamePolicyModuleDefaultsRealmProxyInterface) newObject;
+        NamePolicyModuleDefaultsRealmProxyInterface realmObjectCopy = (NamePolicyModuleDefaultsRealmProxyInterface) realmObject;
+
+        realmObjectCopy.realmSet$firstName(realmObjectSource.realmGet$firstName());
+        realmObjectCopy.realmSet$lastName(realmObjectSource.realmGet$lastName());
+        return realmObject;
+    }
+
+    public static long insert(Realm realm, some.test.NamePolicyModuleDefaults object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.NamePolicyModuleDefaults.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyModuleDefaultsColumnInfo columnInfo = (NamePolicyModuleDefaultsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyModuleDefaults.class);
+        long rowIndex = OsObject.createRow(table);
+        cache.put(object, rowIndex);
+        String realmGet$firstName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$firstName();
+        if (realmGet$firstName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+        }
+        String realmGet$lastName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$lastName();
+        if (realmGet$lastName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+        }
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NamePolicyModuleDefaults.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyModuleDefaultsColumnInfo columnInfo = (NamePolicyModuleDefaultsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyModuleDefaults.class);
+        some.test.NamePolicyModuleDefaults object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NamePolicyModuleDefaults) objects.next();
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$firstName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$firstName();
+            if (realmGet$firstName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+            }
+            String realmGet$lastName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$lastName();
+            if (realmGet$lastName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.NamePolicyModuleDefaults object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.NamePolicyModuleDefaults.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyModuleDefaultsColumnInfo columnInfo = (NamePolicyModuleDefaultsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyModuleDefaults.class);
+        long rowIndex = OsObject.createRow(table);
+        cache.put(object, rowIndex);
+        String realmGet$firstName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$firstName();
+        if (realmGet$firstName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.firstNameIndex, rowIndex, false);
+        }
+        String realmGet$lastName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$lastName();
+        if (realmGet$lastName != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.lastNameIndex, rowIndex, false);
+        }
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NamePolicyModuleDefaults.class);
+        long tableNativePtr = table.getNativePtr();
+        NamePolicyModuleDefaultsColumnInfo columnInfo = (NamePolicyModuleDefaultsColumnInfo) realm.getSchema().getColumnInfo(some.test.NamePolicyModuleDefaults.class);
+        some.test.NamePolicyModuleDefaults object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NamePolicyModuleDefaults) objects.next();
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$firstName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$firstName();
+            if (realmGet$firstName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.firstNameIndex, rowIndex, realmGet$firstName, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.firstNameIndex, rowIndex, false);
+            }
+            String realmGet$lastName = ((NamePolicyModuleDefaultsRealmProxyInterface) object).realmGet$lastName();
+            if (realmGet$lastName != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.lastNameIndex, rowIndex, realmGet$lastName, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.lastNameIndex, rowIndex, false);
+            }
+        }
+    }
+
+    public static some.test.NamePolicyModuleDefaults createDetachedCopy(some.test.NamePolicyModuleDefaults realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+        if (currentDepth > maxDepth || realmObject == null) {
+            return null;
+        }
+        CacheData<RealmModel> cachedObject = cache.get(realmObject);
+        some.test.NamePolicyModuleDefaults unmanagedObject;
+        if (cachedObject == null) {
+            unmanagedObject = new some.test.NamePolicyModuleDefaults();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+        } else {
+            // Reuse cached object or recreate it because it was encountered at a lower depth.
+            if (currentDepth >= cachedObject.minDepth) {
+                return (some.test.NamePolicyModuleDefaults) cachedObject.object;
+            }
+            unmanagedObject = (some.test.NamePolicyModuleDefaults) cachedObject.object;
+            cachedObject.minDepth = currentDepth;
+        }
+        NamePolicyModuleDefaultsRealmProxyInterface unmanagedCopy = (NamePolicyModuleDefaultsRealmProxyInterface) unmanagedObject;
+        NamePolicyModuleDefaultsRealmProxyInterface realmSource = (NamePolicyModuleDefaultsRealmProxyInterface) realmObject;
+        unmanagedCopy.realmSet$firstName(realmSource.realmGet$firstName());
+        unmanagedCopy.realmSet$lastName(realmSource.realmGet$lastName());
+
+        return unmanagedObject;
+    }
+
+    @Override
+    @SuppressWarnings("ArrayToString")
+    public String toString() {
+        if (!RealmObject.isValid(this)) {
+            return "Invalid object";
+        }
+        StringBuilder stringBuilder = new StringBuilder("NamePolicyModuleDefaults = proxy[");
+        stringBuilder.append("{firstName:");
+        stringBuilder.append(realmGet$firstName() != null ? realmGet$firstName() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{lastName:");
+        stringBuilder.append(realmGet$lastName() != null ? realmGet$lastName() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append("]");
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public ProxyState<?> realmGet$proxyState() {
+        return proxyState;
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = proxyState.getRealm$realm().getPath();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        long rowIndex = proxyState.getRow$realm().getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        NamePolicyModuleDefaultsRealmProxy aNamePolicyModuleDefaults = (NamePolicyModuleDefaultsRealmProxy)o;
+
+        String path = proxyState.getRealm$realm().getPath();
+        String otherPath = aNamePolicyModuleDefaults.proxyState.getRealm$realm().getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
+
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        String otherTableName = aNamePolicyModuleDefaults.proxyState.getRow$realm().getTable().getName();
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
+
+        if (proxyState.getRow$realm().getIndex() != aNamePolicyModuleDefaults.proxyState.getRow$realm().getIndex()) return false;
+
+        return true;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index fecf92e93e..e7af4b8897 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -80,47 +80,47 @@
         NullTypesColumnInfo(OsSchemaInfo schemaInfo) {
             super(41);
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("NullTypes");
-            this.fieldStringNotNullIndex = addColumnDetails("fieldStringNotNull", objectSchemaInfo);
-            this.fieldStringNullIndex = addColumnDetails("fieldStringNull", objectSchemaInfo);
-            this.fieldBooleanNotNullIndex = addColumnDetails("fieldBooleanNotNull", objectSchemaInfo);
-            this.fieldBooleanNullIndex = addColumnDetails("fieldBooleanNull", objectSchemaInfo);
-            this.fieldBytesNotNullIndex = addColumnDetails("fieldBytesNotNull", objectSchemaInfo);
-            this.fieldBytesNullIndex = addColumnDetails("fieldBytesNull", objectSchemaInfo);
-            this.fieldByteNotNullIndex = addColumnDetails("fieldByteNotNull", objectSchemaInfo);
-            this.fieldByteNullIndex = addColumnDetails("fieldByteNull", objectSchemaInfo);
-            this.fieldShortNotNullIndex = addColumnDetails("fieldShortNotNull", objectSchemaInfo);
-            this.fieldShortNullIndex = addColumnDetails("fieldShortNull", objectSchemaInfo);
-            this.fieldIntegerNotNullIndex = addColumnDetails("fieldIntegerNotNull", objectSchemaInfo);
-            this.fieldIntegerNullIndex = addColumnDetails("fieldIntegerNull", objectSchemaInfo);
-            this.fieldLongNotNullIndex = addColumnDetails("fieldLongNotNull", objectSchemaInfo);
-            this.fieldLongNullIndex = addColumnDetails("fieldLongNull", objectSchemaInfo);
-            this.fieldFloatNotNullIndex = addColumnDetails("fieldFloatNotNull", objectSchemaInfo);
-            this.fieldFloatNullIndex = addColumnDetails("fieldFloatNull", objectSchemaInfo);
-            this.fieldDoubleNotNullIndex = addColumnDetails("fieldDoubleNotNull", objectSchemaInfo);
-            this.fieldDoubleNullIndex = addColumnDetails("fieldDoubleNull", objectSchemaInfo);
-            this.fieldDateNotNullIndex = addColumnDetails("fieldDateNotNull", objectSchemaInfo);
-            this.fieldDateNullIndex = addColumnDetails("fieldDateNull", objectSchemaInfo);
-            this.fieldObjectNullIndex = addColumnDetails("fieldObjectNull", objectSchemaInfo);
-            this.fieldStringListNotNullIndex = addColumnDetails("fieldStringListNotNull", objectSchemaInfo);
-            this.fieldStringListNullIndex = addColumnDetails("fieldStringListNull", objectSchemaInfo);
-            this.fieldBinaryListNotNullIndex = addColumnDetails("fieldBinaryListNotNull", objectSchemaInfo);
-            this.fieldBinaryListNullIndex = addColumnDetails("fieldBinaryListNull", objectSchemaInfo);
-            this.fieldBooleanListNotNullIndex = addColumnDetails("fieldBooleanListNotNull", objectSchemaInfo);
-            this.fieldBooleanListNullIndex = addColumnDetails("fieldBooleanListNull", objectSchemaInfo);
-            this.fieldLongListNotNullIndex = addColumnDetails("fieldLongListNotNull", objectSchemaInfo);
-            this.fieldLongListNullIndex = addColumnDetails("fieldLongListNull", objectSchemaInfo);
-            this.fieldIntegerListNotNullIndex = addColumnDetails("fieldIntegerListNotNull", objectSchemaInfo);
-            this.fieldIntegerListNullIndex = addColumnDetails("fieldIntegerListNull", objectSchemaInfo);
-            this.fieldShortListNotNullIndex = addColumnDetails("fieldShortListNotNull", objectSchemaInfo);
-            this.fieldShortListNullIndex = addColumnDetails("fieldShortListNull", objectSchemaInfo);
-            this.fieldByteListNotNullIndex = addColumnDetails("fieldByteListNotNull", objectSchemaInfo);
-            this.fieldByteListNullIndex = addColumnDetails("fieldByteListNull", objectSchemaInfo);
-            this.fieldDoubleListNotNullIndex = addColumnDetails("fieldDoubleListNotNull", objectSchemaInfo);
-            this.fieldDoubleListNullIndex = addColumnDetails("fieldDoubleListNull", objectSchemaInfo);
-            this.fieldFloatListNotNullIndex = addColumnDetails("fieldFloatListNotNull", objectSchemaInfo);
-            this.fieldFloatListNullIndex = addColumnDetails("fieldFloatListNull", objectSchemaInfo);
-            this.fieldDateListNotNullIndex = addColumnDetails("fieldDateListNotNull", objectSchemaInfo);
-            this.fieldDateListNullIndex = addColumnDetails("fieldDateListNull", objectSchemaInfo);
+            this.fieldStringNotNullIndex = addColumnDetails("fieldStringNotNull", "fieldStringNotNull", objectSchemaInfo);
+            this.fieldStringNullIndex = addColumnDetails("fieldStringNull", "fieldStringNull", objectSchemaInfo);
+            this.fieldBooleanNotNullIndex = addColumnDetails("fieldBooleanNotNull", "fieldBooleanNotNull", objectSchemaInfo);
+            this.fieldBooleanNullIndex = addColumnDetails("fieldBooleanNull", "fieldBooleanNull", objectSchemaInfo);
+            this.fieldBytesNotNullIndex = addColumnDetails("fieldBytesNotNull", "fieldBytesNotNull", objectSchemaInfo);
+            this.fieldBytesNullIndex = addColumnDetails("fieldBytesNull", "fieldBytesNull", objectSchemaInfo);
+            this.fieldByteNotNullIndex = addColumnDetails("fieldByteNotNull", "fieldByteNotNull", objectSchemaInfo);
+            this.fieldByteNullIndex = addColumnDetails("fieldByteNull", "fieldByteNull", objectSchemaInfo);
+            this.fieldShortNotNullIndex = addColumnDetails("fieldShortNotNull", "fieldShortNotNull", objectSchemaInfo);
+            this.fieldShortNullIndex = addColumnDetails("fieldShortNull", "fieldShortNull", objectSchemaInfo);
+            this.fieldIntegerNotNullIndex = addColumnDetails("fieldIntegerNotNull", "fieldIntegerNotNull", objectSchemaInfo);
+            this.fieldIntegerNullIndex = addColumnDetails("fieldIntegerNull", "fieldIntegerNull", objectSchemaInfo);
+            this.fieldLongNotNullIndex = addColumnDetails("fieldLongNotNull", "fieldLongNotNull", objectSchemaInfo);
+            this.fieldLongNullIndex = addColumnDetails("fieldLongNull", "fieldLongNull", objectSchemaInfo);
+            this.fieldFloatNotNullIndex = addColumnDetails("fieldFloatNotNull", "fieldFloatNotNull", objectSchemaInfo);
+            this.fieldFloatNullIndex = addColumnDetails("fieldFloatNull", "fieldFloatNull", objectSchemaInfo);
+            this.fieldDoubleNotNullIndex = addColumnDetails("fieldDoubleNotNull", "fieldDoubleNotNull", objectSchemaInfo);
+            this.fieldDoubleNullIndex = addColumnDetails("fieldDoubleNull", "fieldDoubleNull", objectSchemaInfo);
+            this.fieldDateNotNullIndex = addColumnDetails("fieldDateNotNull", "fieldDateNotNull", objectSchemaInfo);
+            this.fieldDateNullIndex = addColumnDetails("fieldDateNull", "fieldDateNull", objectSchemaInfo);
+            this.fieldObjectNullIndex = addColumnDetails("fieldObjectNull", "fieldObjectNull", objectSchemaInfo);
+            this.fieldStringListNotNullIndex = addColumnDetails("fieldStringListNotNull", "fieldStringListNotNull", objectSchemaInfo);
+            this.fieldStringListNullIndex = addColumnDetails("fieldStringListNull", "fieldStringListNull", objectSchemaInfo);
+            this.fieldBinaryListNotNullIndex = addColumnDetails("fieldBinaryListNotNull", "fieldBinaryListNotNull", objectSchemaInfo);
+            this.fieldBinaryListNullIndex = addColumnDetails("fieldBinaryListNull", "fieldBinaryListNull", objectSchemaInfo);
+            this.fieldBooleanListNotNullIndex = addColumnDetails("fieldBooleanListNotNull", "fieldBooleanListNotNull", objectSchemaInfo);
+            this.fieldBooleanListNullIndex = addColumnDetails("fieldBooleanListNull", "fieldBooleanListNull", objectSchemaInfo);
+            this.fieldLongListNotNullIndex = addColumnDetails("fieldLongListNotNull", "fieldLongListNotNull", objectSchemaInfo);
+            this.fieldLongListNullIndex = addColumnDetails("fieldLongListNull", "fieldLongListNull", objectSchemaInfo);
+            this.fieldIntegerListNotNullIndex = addColumnDetails("fieldIntegerListNotNull", "fieldIntegerListNotNull", objectSchemaInfo);
+            this.fieldIntegerListNullIndex = addColumnDetails("fieldIntegerListNull", "fieldIntegerListNull", objectSchemaInfo);
+            this.fieldShortListNotNullIndex = addColumnDetails("fieldShortListNotNull", "fieldShortListNotNull", objectSchemaInfo);
+            this.fieldShortListNullIndex = addColumnDetails("fieldShortListNull", "fieldShortListNull", objectSchemaInfo);
+            this.fieldByteListNotNullIndex = addColumnDetails("fieldByteListNotNull", "fieldByteListNotNull", objectSchemaInfo);
+            this.fieldByteListNullIndex = addColumnDetails("fieldByteListNull", "fieldByteListNull", objectSchemaInfo);
+            this.fieldDoubleListNotNullIndex = addColumnDetails("fieldDoubleListNotNull", "fieldDoubleListNotNull", objectSchemaInfo);
+            this.fieldDoubleListNullIndex = addColumnDetails("fieldDoubleListNull", "fieldDoubleListNull", objectSchemaInfo);
+            this.fieldFloatListNotNullIndex = addColumnDetails("fieldFloatListNotNull", "fieldFloatListNotNull", objectSchemaInfo);
+            this.fieldFloatListNullIndex = addColumnDetails("fieldFloatListNull", "fieldFloatListNull", objectSchemaInfo);
+            this.fieldDateListNotNullIndex = addColumnDetails("fieldDateListNotNull", "fieldDateListNotNull", objectSchemaInfo);
+            this.fieldDateListNullIndex = addColumnDetails("fieldDateListNull", "fieldDateListNull", objectSchemaInfo);
         }
 
         NullTypesColumnInfo(ColumnInfo src, boolean mutable) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 506273e123..efb8bd8dab 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -52,7 +52,7 @@ public String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.getSimpleClassName();
+            return "AllTypes";
         }
         throw getMissingProxyClassException(clazz);
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 1ea6822a31..1039391788 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -41,8 +41,8 @@
         SimpleColumnInfo(OsSchemaInfo schemaInfo) {
             super(2);
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Simple");
-            this.nameIndex = addColumnDetails("name", objectSchemaInfo);
-            this.ageIndex = addColumnDetails("age", objectSchemaInfo);
+            this.nameIndex = addColumnDetails("name", "name", objectSchemaInfo);
+            this.ageIndex = addColumnDetails("age", "age", objectSchemaInfo);
         }
 
         SimpleColumnInfo(ColumnInfo src, boolean mutable) {
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java
new file mode 100644
index 0000000000..0b0972fa0f
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyClassOnly.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package some.test;
+
+import io.realm.annotations.RealmClass;
+import io.realm.RealmObject;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+/**
+ * Class with only a custom name
+ */
+@RealmClass(name = "customName")
+public class NamePolicyClassOnly extends RealmObject {
+
+    public String firstName;
+    public String lastName;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForAllClasses.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForAllClasses.java
new file mode 100644
index 0000000000..0b2d6f94d1
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForAllClasses.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import io.realm.annotations.RealmModule;
+import io.realm.annotations.RealmNamingPolicy;
+import some.test.AllTypes;
+
+public class NamePolicyConflictingModuleDefinitionsForAllClasses {
+
+    @RealmModule(allClasses = true,
+            classNamingPolicy = RealmNamingPolicy.IDENTITY,
+            fieldNamingPolicy = RealmNamingPolicy.IDENTITY)
+    public class MyModule1 {
+
+    }
+
+    @RealmModule(allClasses = true,
+            classNamingPolicy = RealmNamingPolicy.CAMEL_CASE,
+            fieldNamingPolicy = RealmNamingPolicy.CAMEL_CASE)
+    public class MyModule2 {
+
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForMixedDefinitions.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForMixedDefinitions.java
new file mode 100644
index 0000000000..95cce279b5
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForMixedDefinitions.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import io.realm.annotations.RealmModule;
+import io.realm.annotations.RealmNamingPolicy;
+import some.test.Simple;
+
+public class NamePolicyConflictingModuleDefinitionsForMixedDefinitions {
+
+    @RealmModule(classes = { Simple.class },
+            classNamingPolicy = RealmNamingPolicy.IDENTITY,
+            fieldNamingPolicy = RealmNamingPolicy.IDENTITY)
+    public class MyModule1 {
+
+    }
+
+    @RealmModule(allClasses = true,
+            classNamingPolicy = RealmNamingPolicy.CAMEL_CASE,
+            fieldNamingPolicy = RealmNamingPolicy.CAMEL_CASE)
+    public class MyModule2 {
+
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForNamedClasses.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForNamedClasses.java
new file mode 100644
index 0000000000..cf072d1dd0
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyConflictingModuleDefinitionsForNamedClasses.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import io.realm.annotations.RealmModule;
+import io.realm.annotations.RealmNamingPolicy;
+import some.test.Simple;
+
+public class NamePolicyConflictingModuleDefinitionsForNamedClasses {
+
+    @RealmModule(classes = { Simple.class },
+            classNamingPolicy = RealmNamingPolicy.IDENTITY,
+            fieldNamingPolicy = RealmNamingPolicy.IDENTITY)
+    public class MyModule1 {
+
+    }
+
+    @RealmModule(classes = { Simple.class },
+            classNamingPolicy = RealmNamingPolicy.CAMEL_CASE,
+            fieldNamingPolicy = RealmNamingPolicy.CAMEL_CASE)
+    public class MyModule2 {
+
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java
new file mode 100644
index 0000000000..1109fb5e21
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyFieldNameOnly.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package some.test;
+
+import io.realm.annotations.RealmClass;
+import io.realm.RealmObject;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+/**
+ * Class with only a field name annotation
+ */
+public class NamePolicyFieldNameOnly extends RealmObject {
+
+    @RealmField(name = "first_name")
+    public String firstName;
+    public String lastName;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyMixedClassSettings.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyMixedClassSettings.java
new file mode 100644
index 0000000000..3281a82a23
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyMixedClassSettings.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package some.test;
+
+import io.realm.annotations.RealmClass;
+import io.realm.RealmObject;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+/**
+ * Class with mixed settings class/field name settings
+ */
+@RealmClass(name = "customName", fieldNamingPolicy = RealmNamingPolicy.PASCAL_CASE)
+public class NamePolicyMixedClassSettings extends RealmObject {
+
+    @RealmField(name = "first_name")
+    public String firstName;
+    public String lastName;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyModule.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyModule.java
new file mode 100644
index 0000000000..ce903bd6bb
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package some.test;
+
+import io.realm.annotations.RealmModule;
+import io.realm.annotations.RealmNamingPolicy;
+
+@RealmModule(allClasses = true, classNamingPolicy = RealmNamingPolicy.PASCAL_CASE, fieldNamingPolicy = RealmNamingPolicy.PASCAL_CASE)
+public class NamePolicyModule {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyModuleDefaults.java b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyModuleDefaults.java
new file mode 100644
index 0000000000..cf6e7cc46f
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NamePolicyModuleDefaults.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+/**
+ * Class which inherit all naming policies from the module.
+ */
+public class NamePolicyModuleDefaults extends RealmObject {
+    public String firstName;
+    public String lastName;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java b/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
new file mode 100644
index 0000000000..a49f7393a3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.realmname.ClassNameOverrideModulePolicy;
+import io.realm.entities.realmname.ClassWithPolicy;
+import io.realm.entities.realmname.CustomRealmNamesModule;
+import io.realm.entities.realmname.FieldNameOverrideClassPolicy;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * This class contains tests for checking that changing the internal Realm name
+ * works correctly.
+ */
+@RunWith(AndroidJUnit4.class)
+public class CustomRealmNameTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .modules(new CustomRealmNamesModule())
+                .build();
+        realm = Realm.getInstance(config);
+        dynamicRealm = DynamicRealm.getInstance(config);
+    }
+
+
+    @After
+    public void tearDown() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
+        if (dynamicRealm != null && !dynamicRealm.isClosed()) {
+            dynamicRealm.close();
+        }
+    }
+
+    //
+    // Build checks
+    //
+
+    // Check that the module policy is used as the default for class and field names
+    @Test
+    public void modulePolicy_defaultPolicy() {
+        assertTrue(realm.getSchema().contains("default_policy_from_module"));
+        RealmObjectSchema classSchema = realm.getSchema().get("default_policy_from_module");
+        assertTrue(classSchema.hasField("camel_case"));
+    }
+
+    // Check that field name policies on classes override those from modules
+    @Test
+    public void classFieldPolicy_overrideModuleFieldPolicy() {
+        assertTrue(realm.getSchema().contains(ClassWithPolicy.CLASS_NAME));
+        RealmObjectSchema classSchema = realm.getSchema().get(ClassWithPolicy.CLASS_NAME);
+        for (String field : ClassWithPolicy.ALL_FIELDS) {
+            assertTrue(field + " was not found.", classSchema.hasField(field));
+        }
+    }
+
+    // Check that explicit class name override both module and class policies
+    @Test
+    public void className_overrideModuleClassPolicy() {
+        assertTrue(realm.getSchema().contains(ClassNameOverrideModulePolicy.CLASS_NAME));
+    }
+
+    // Check that a explicitly setting a field name overrides a class field name policy
+    @Test
+    public void fieldName_overrideClassPolicy() {
+        RealmObjectSchema classSchema = realm.getSchema().get(FieldNameOverrideClassPolicy.CLASS_NAME);
+        assertTrue(classSchema.hasField(FieldNameOverrideClassPolicy.FIELD_CAMEL_CASE));
+    }
+
+    // Check that a explicitly setting a field name overrides a module field name policy
+    @Test
+    public void fieldName_overrideModulePolicy() {
+        RealmObjectSchema classSchema = realm.getSchema().get(FieldNameOverrideClassPolicy.CLASS_NAME);
+        assertTrue(classSchema.hasField(FieldNameOverrideClassPolicy.FIELD_CAMEL_CASE));
+    }
+
+    //
+    // Query tests
+    //
+    // Mostly smoke test, as we only want to test that the query system correctly maps between
+    // Java field names and cores.
+    //
+    @Test
+    public void typedQueryWithJavaNames() {
+        RealmResults<ClassWithPolicy> results = realm.where(ClassWithPolicy.class)
+                .equalTo("camelCase", "foo") // Java name in model class
+                .equalTo("parents.PascalCase", 1) // Backlinks also uses java names
+                .sort("mHungarian") // Sorting uses Java names
+                .distinctValues("customName") // Distinct uses Java names
+                .findAll();
+        assertTrue(results.isEmpty());
+    }
+
+    @Test
+    public void typedQueryWithInternalNamesThrows() {
+
+        // Normal predicates
+        try {
+            realm.where(ClassWithPolicy.class).equalTo(ClassWithPolicy.FIELD_CAMEL_CASE, "");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        // Sorting
+        try {
+            realm.where(ClassWithPolicy.class).sort(ClassWithPolicy.FIELD_CAMEL_CASE);
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        // Distinct
+        try {
+            realm.where(ClassWithPolicy.class).distinctValues(ClassWithPolicy.FIELD_CAMEL_CASE);
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        // Backlinks do not exist as internal fields that can be queried
+    }
+
+
+    @Test
+    public void dynamicQueryWithInternalNames() {
+        // Backlink queries not supported on dynamic queries
+        RealmResults<DynamicRealmObject> results = dynamicRealm.where(ClassWithPolicy.CLASS_NAME)
+                .equalTo(ClassWithPolicy.FIELD_CAMEL_CASE, "foo") // Normal queries use internal names
+                .sort(ClassWithPolicy.FIELD_M_HUNGARIAN) // Sorting uses internal names
+                .distinctValues(ClassWithPolicy.FIELD_CUSTOM_NAME) // Distinct uses internal names
+                .findAll();
+        assertTrue(results.isEmpty());
+    }
+
+    @Test
+    public void dynamicQueryWithJavaNamesThrows() {
+        try {
+            dynamicRealm.where(ClassWithPolicy.CLASS_NAME).equalTo("camelCase", "");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        // Sorting
+        try {
+            dynamicRealm.where(ClassWithPolicy.CLASS_NAME).sort("camelCase");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        // Distinct
+        try {
+            dynamicRealm.where(ClassWithPolicy.CLASS_NAME).distinctValues("camelCase");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    //
+    // Schema tests
+    //
+    @Test
+    public void typedSchemaReturnsInternalNames() {
+        RealmSchema schema = realm.getSchema();
+        assertTrue(schema.contains(ClassWithPolicy.CLASS_NAME));
+        RealmObjectSchema classSchema = schema.get(ClassWithPolicy.CLASS_NAME);
+        assertEquals(ClassWithPolicy.ALL_FIELDS.size(), classSchema.getFieldNames().size());
+        for (String fieldName : ClassWithPolicy.ALL_FIELDS) {
+            assertTrue("Could not find: " + fieldName, classSchema.hasField(fieldName));
+        }
+    }
+
+    @Test
+    public void dynamicSchemaReturnsInternalNames() {
+        RealmSchema schema = realm.getSchema();
+        assertTrue(schema.contains(ClassWithPolicy.CLASS_NAME));
+        RealmObjectSchema classSchema = schema.get(ClassWithPolicy.CLASS_NAME);
+        assertEquals(ClassWithPolicy.ALL_FIELDS.size(), classSchema.getFieldNames().size());
+        for (String fieldName : ClassWithPolicy.ALL_FIELDS) {
+            assertTrue("Could not find: " + fieldName, classSchema.hasField(fieldName));
+        }
+    }
+
+    //
+    // Dynamic Realm tests
+    //
+    @Test
+    public void createObjects() {
+        dynamicRealm.executeTransaction(r -> {
+            // Use internal name
+            DynamicRealmObject obj = r.createObject(ClassWithPolicy.CLASS_NAME);
+            assertNotNull(obj);
+        });
+    }
+
+
+    //
+    // Realm tests
+    //
+    @Test
+    public void copyOrUpdate() {
+        realm.executeTransaction(r -> {
+            ClassWithPolicy obj = new ClassWithPolicy();
+            try {
+                r.copyToRealmOrUpdate(obj); // Verify that we correctly check that a primary key is missing
+                fail();
+            } catch (IllegalArgumentException e) {
+                assertTrue(e.getMessage().startsWith("A RealmObject with no @PrimaryKey cannot be updated"));
+            }
+        });
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassNameOverrideModulePolicy.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassNameOverrideModulePolicy.java
new file mode 100644
index 0000000000..2ed523910c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassNameOverrideModulePolicy.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities.realmname;
+
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+// Class will inherit RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES from the module `CustomRealmNamesModule`
+@RealmClass(name = "class-name-override", fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
+public class ClassNameOverrideModulePolicy extends RealmObject {
+
+    // Expected internal names
+    public static final String CLASS_NAME = "class-name-override";
+    public static final String FIELD_CAMEL_CASE = "camel_case";
+    public static final String FIELD_PASCAL_CASE = "pascal_case";
+    public static final String FIELD_M_HUNGARIAN = "hungarian";
+    public static final String FIELD_ALLCAPS = "allcaps";
+    public static final String FIELD_ALLLOWER = "alllower";
+    public static final String FIELD_WITH_UNDERSCORES = "with_underscores";
+    public static final String FIELD_WITH_SPECIAL_CHARS = "internal_var";
+    public static final String FIELD_CUSTOM_NAME = "a different name";
+    public static final List<String> ALL_FIELDS = Arrays.asList(
+            FIELD_CAMEL_CASE,
+            FIELD_PASCAL_CASE,
+            FIELD_M_HUNGARIAN,
+            FIELD_ALLCAPS,
+            FIELD_ALLLOWER,
+            FIELD_WITH_UNDERSCORES,
+            FIELD_WITH_SPECIAL_CHARS,
+            FIELD_CUSTOM_NAME
+    );
+
+    public String camelCase;
+    public int PascalCase;
+    public boolean mHungarian;
+    public boolean ALLCAPS;
+    public boolean alllower;
+    public boolean with_underscores;
+    public RealmList<ClassWithPolicy> $_internalVar;
+    @RealmField(name = "a different name") // This will override the class policy
+    public String customName;
+}
+
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassWithPolicy.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassWithPolicy.java
new file mode 100644
index 0000000000..8af0c469b3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/ClassWithPolicy.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities.realmname;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+@RealmClass(fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
+public class ClassWithPolicy extends RealmObject {
+
+    public static final String CLASS_NAME = "class_with_policy";
+    public static final String FIELD_CAMEL_CASE = "camel_case";
+    public static final String FIELD_PASCAL_CASE = "pascal_case";
+    public static final String FIELD_M_HUNGARIAN = "hungarian";
+    public static final String FIELD_ALLCAPS = "allcaps";
+    public static final String FIELD_ALLLOWER = "alllower";
+    public static final String FIELD_FIRST_CAPS = "first_caps";
+    public static final String FIELD_WITH_UNDERSCORES = "with_underscores";
+    public static final String FIELD_WITH_SPECIAL_CHARS = "internal_var";
+    public static final String FIELD_CUSTOM_NAME = "a different name";
+    public static final List<String> ALL_FIELDS = Arrays.asList(
+            FIELD_CAMEL_CASE,
+            FIELD_PASCAL_CASE,
+            FIELD_M_HUNGARIAN,
+            FIELD_ALLCAPS,
+            FIELD_ALLLOWER,
+            FIELD_FIRST_CAPS,
+            FIELD_WITH_UNDERSCORES,
+            FIELD_WITH_SPECIAL_CHARS,
+            FIELD_CUSTOM_NAME
+    );
+
+    public String camelCase;
+    public int PascalCase;
+    public boolean mHungarian;
+    public byte[] ALLCAPS;
+    public Date alllower;
+    public long FIRSTCaps;
+    public ClassWithPolicy with_underscores;
+    public RealmList<ClassWithPolicy> $_internalVar;
+    @RealmField(name = "a different name")
+    public String customName;
+
+    @LinkingObjects("with_underscores")
+    public final RealmResults<ClassWithPolicy> parents = null;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java
new file mode 100644
index 0000000000..ec11780ecf
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/CustomRealmNamesModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities.realmname;
+
+import io.realm.annotations.RealmModule;
+import io.realm.annotations.RealmNamingPolicy;
+
+@RealmModule(classes = {
+        ClassNameOverrideModulePolicy.class,
+        ClassWithPolicy.class,
+        DefaultPolicyFromModule.class,
+        FieldNameOverrideClassPolicy.class },
+        classNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES,
+        fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES
+)
+public class CustomRealmNamesModule {
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/DefaultPolicyFromModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/DefaultPolicyFromModule.java
new file mode 100644
index 0000000000..925b865852
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/DefaultPolicyFromModule.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities.realmname;
+
+import io.realm.RealmObject;
+
+public class DefaultPolicyFromModule extends RealmObject {
+    public String camelCase; // case formatter should be inherited from CustomRealmNamesModule
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/FieldNameOverrideClassPolicy.java b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/FieldNameOverrideClassPolicy.java
new file mode 100644
index 0000000000..5be787f68b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/realmname/FieldNameOverrideClassPolicy.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities.realmname;
+
+import io.realm.RealmObject;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.RealmNamingPolicy;
+
+@RealmClass(fieldNamingPolicy = RealmNamingPolicy.PASCAL_CASE)
+public class FieldNameOverrideClassPolicy extends RealmObject {
+
+    public static final String CLASS_NAME = "field_name_override_class_policy";
+    public static final String FIELD_CAMEL_CASE = "camel_case";
+
+    @RealmField(name = FIELD_CAMEL_CASE)
+    public String camelCase;
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java
index 48c3e67d4e..46b8507beb 100644
--- a/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java
@@ -18,6 +18,7 @@
 
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.Table;
+import io.realm.internal.fields.FieldDescriptor;
 
 /**
  * Immutable {@link RealmObjectSchema}.
@@ -104,4 +105,17 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
     public RealmObjectSchema transform(Function function) {
         throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
     }
+
+    /**
+     * Returns a field descriptor based on Java field names found in model classes.
+     *
+     * @param publicJavaNameDescription field name or linked field description
+     * @param validColumnTypes valid field type for the last field in a linked field
+     * @return the corresponding FieldDescriptor.
+     * @throws IllegalArgumentException if a proper FieldDescriptor could not be created.
+     */
+    @Override
+    FieldDescriptor getColumnIndices(String publicJavaNameDescription, RealmFieldType... validColumnTypes) {
+        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), publicJavaNameDescription, validColumnTypes);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
index b3d79f7da0..7740f4899e 100644
--- a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
@@ -20,7 +20,9 @@
 import io.realm.internal.Table;
 
 /**
- * Immutable {@link RealmSchema}.
+ * Immutable {@link RealmSchema} used by {@link Realm}.
+ *
+ * @see MutableRealmSchema for schema support for {@link DynamicRealm}.
  */
 class ImmutableRealmSchema extends RealmSchema {
 
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
index 8015c22c75..277a665446 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
@@ -22,6 +22,7 @@
 
 import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
+import io.realm.internal.fields.FieldDescriptor;
 
 /**
  * Mutable {@link RealmObjectSchema}.
@@ -291,6 +292,19 @@ public RealmObjectSchema transform(Function function) {
         return this;
     }
 
+    /**
+     * Returns a field descriptor based on the internal field names found in the Realm file.
+     *
+     * @param internalColumnNameDescription internal column name or internal linked column name description.
+     * @param validColumnTypes valid field type for the last field in a linked field
+     * @return the corresponding FieldDescriptor.
+     * @throws IllegalArgumentException if a proper FieldDescriptor could not be created.
+     */
+    @Override
+    FieldDescriptor getColumnIndices(String internalColumnNameDescription, RealmFieldType... validColumnTypes) {
+        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), internalColumnNameDescription, validColumnTypes);
+    }
+
     // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
     private void addModifiers(String fieldName, FieldAttribute[] attributes) {
         boolean indexAdded = false;
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
index 10f060b24e..83c0c72ec0 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
@@ -22,7 +22,9 @@
 import io.realm.internal.Table;
 
 /**
- * Mutable {@link RealmSchema}.
+ * Mutable {@link RealmSchema} used by {@link DynamicRealm}.
+ *
+ * @see ImmutableRealmSchema for schema support for {@link Realm}.
  */
 class MutableRealmSchema extends RealmSchema {
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 338e194e51..8ce435b4b6 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -424,9 +424,7 @@ public RealmFieldType getFieldType(String fieldName) {
      * @param validColumnTypes valid field type for the last field in a linked field
      * @return a FieldDescriptor
      */
-    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
-    }
+    abstract FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes);
 
     RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
         long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
@@ -464,7 +462,7 @@ Table getTable() {
         return SUPPORTED_SIMPLE_FIELDS;
     }
 
-    private SchemaConnector getSchemaConnector() {
+    protected final SchemaConnector getSchemaConnector() {
         return new SchemaConnector(schema);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 07bceca628..d90b47c31d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -88,7 +88,7 @@ public ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * Returns the {@link ColumnInfo} for the passed class name.
+     * Returns the {@link ColumnInfo} for the provided internal class name.
      *
      * @param simpleClassName the simple name of the class for which to get the ColumnInfo.
      * @return the corresponding {@link ColumnInfo} object.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index 1825e855b9..3c88cd5f3b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -90,7 +90,8 @@ public String toString() {
     }
 
 
-    private final Map<String, ColumnDetails> indicesMap;
+    private final Map<String, ColumnDetails> indicesFromJavaFieldNames;
+    private final Map<String, ColumnDetails> indicesFromColumnNames;
     private final boolean mutable;
 
     /**
@@ -109,15 +110,16 @@ protected ColumnInfo(int mapSize) {
      * @param mutable false to make this instance effectively final
      */
     protected ColumnInfo(@Nullable ColumnInfo src, boolean mutable) {
-        this((src == null) ? 0 : src.indicesMap.size(), mutable);
+        this((src == null) ? 0 : src.indicesFromJavaFieldNames.size(), mutable);
         // ColumnDetails are immutable and may be re-used.
         if (src != null) {
-            indicesMap.putAll(src.indicesMap);
+            indicesFromJavaFieldNames.putAll(src.indicesFromJavaFieldNames);
         }
     }
 
     private ColumnInfo(int mapSize, boolean mutable) {
-        this.indicesMap = new HashMap<>(mapSize);
+        this.indicesFromJavaFieldNames = new HashMap<>(mapSize);
+        this.indicesFromColumnNames = new HashMap<>(mapSize);
         this.mutable = mutable;
     }
 
@@ -135,8 +137,8 @@ public final boolean isMutable() {
      *
      * @return column index.
      */
-    public long getColumnIndex(String columnName) {
-        ColumnDetails details = indicesMap.get(columnName);
+    public long getColumnIndex(String javaFieldName) {
+        ColumnDetails details = indicesFromJavaFieldNames.get(javaFieldName);
         return (details == null) ? -1 : details.columnIndex;
     }
 
@@ -146,8 +148,8 @@ public long getColumnIndex(String columnName) {
      * @return {@link ColumnDetails} or {@code null} if not found.
      */
     @Nullable
-    public ColumnDetails getColumnDetails(String columnName) {
-        return indicesMap.get(columnName);
+    public ColumnDetails getColumnDetails(String javaFieldName) {
+        return indicesFromJavaFieldNames.get(javaFieldName);
     }
 
     /**
@@ -165,22 +167,36 @@ public void copyFrom(ColumnInfo src) {
             throw new NullPointerException("Attempt to copy null ColumnInfo");
         }
 
-        indicesMap.clear();
-        indicesMap.putAll(src.indicesMap);
+        indicesFromJavaFieldNames.clear();
+        indicesFromJavaFieldNames.putAll(src.indicesFromJavaFieldNames);
+        indicesFromColumnNames.clear();
+        indicesFromColumnNames.putAll(src.indicesFromColumnNames);
         copy(src, this);
     }
 
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder("ColumnInfo[");
-        buf.append(mutable).append(",");
-        if (indicesMap != null) {
+        buf.append("mutable="+mutable).append(",");
+        if (indicesFromJavaFieldNames != null) {
+            buf.append("JavaFieldNames=[");
             boolean commaNeeded = false;
-            for (Map.Entry<String, ColumnDetails> entry : indicesMap.entrySet()) {
+            for (Map.Entry<String, ColumnDetails> entry : indicesFromJavaFieldNames.entrySet()) {
                 if (commaNeeded) { buf.append(","); }
                 buf.append(entry.getKey()).append("->").append(entry.getValue());
                 commaNeeded = true;
             }
+            buf.append("]");
+        }
+        if (indicesFromColumnNames != null) {
+            buf.append(", InternalFieldNames=[");
+            boolean commaNeeded = false;
+            for (Map.Entry<String, ColumnDetails> entry : indicesFromColumnNames.entrySet()) {
+                if (commaNeeded) { buf.append(","); }
+                buf.append(entry.getKey()).append("->").append(entry.getValue());
+                commaNeeded = true;
+            }
+            buf.append("]");
         }
         return buf.append("]").toString();
     }
@@ -212,13 +228,16 @@ public String toString() {
      * <p>
      * No validation done here.  Presuming that all necessary validation takes place in {@code Proxy.validateTable}.
      *
-     * @param columnName The name of the column whose index is sought.
+     * @param javaFieldName The name of the java field name.
+     * @param internalColumnName The underlying column name in the Realm file for the Java field name.
      * @param objectSchemaInfo the {@link OsObjectSchemaInfo} for the corresponding {@code RealmObject}.
-     * @return the index of the column in the table
+     * @return the index of the column in the table.
      */
-    protected final long addColumnDetails(String columnName, OsObjectSchemaInfo objectSchemaInfo) {
-        Property property = objectSchemaInfo.getProperty(columnName);
-        indicesMap.put(columnName, new ColumnDetails(property));
+    protected final long addColumnDetails(String javaFieldName, String internalColumnName, OsObjectSchemaInfo objectSchemaInfo) {
+        Property property = objectSchemaInfo.getProperty(internalColumnName);
+        ColumnDetails cd = new ColumnDetails(property);
+        indicesFromJavaFieldNames.put(javaFieldName, cd);
+        indicesFromColumnNames.put(internalColumnName, cd);
         return property.getColumnIndex();
     }
 
@@ -228,13 +247,13 @@ protected final long addColumnDetails(String columnName, OsObjectSchemaInfo obje
      * Must be called from within the subclass constructor, to maintain the effectively-final contract.
      *
      * @param schemaInfo the {@link OsSchemaInfo} of the corresponding {@code Realm} instance.
-     * @param columnName The name of the backlink column.
+     * @param javaFieldName The name of the backlink column.
      * @param sourceTableName The name of the backlink source class.
-     * @param sourceColumnName The name of the backlink source field.
+     * @param sourceJavaFieldName The name of the backlink source field.
      */
-    protected final void addBacklinkDetails(OsSchemaInfo schemaInfo, String columnName, String sourceTableName, String sourceColumnName) {
-        long columnIndex = schemaInfo.getObjectSchemaInfo(sourceTableName).getProperty(sourceColumnName).getColumnIndex();
-        indicesMap.put(columnName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
+    protected final void addBacklinkDetails(OsSchemaInfo schemaInfo, String javaFieldName, String sourceTableName, String sourceJavaFieldName) {
+        long columnIndex = schemaInfo.getObjectSchemaInfo(sourceTableName).getProperty(sourceJavaFieldName).getColumnIndex();
+        indicesFromJavaFieldNames.put(javaFieldName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
     }
 
     /**
@@ -245,6 +264,6 @@ protected final void addBacklinkDetails(OsSchemaInfo schemaInfo, String columnNa
      */
     @SuppressWarnings("ReturnOfCollectionOrArrayField")
     public Map<String, ColumnDetails> getIndicesMap() {
-        return indicesMap;
+        return indicesFromJavaFieldNames;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
index 0849a2e30b..3f6a47336b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
@@ -1,4 +1,3 @@
-package io.realm.internal.fields;
 /*
  * Copyright 2017 Realm Inc.
  *
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package io.realm.internal.fields;
 
 import java.util.List;
 import java.util.Locale;
@@ -23,16 +23,19 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.NativeObject;
 
-
 /**
  * Parses the passed field description (@see parseFieldDescription(String) and returns the information
  * necessary for RealmQuery predicates to select the specified records.
  * Because the values returned by this method will, immediately, be handed to native code, they are
- * in coordinated arrays, not a List&lt;ColumnDeatils&gt;
+ * in coordinated arrays, not a List&lt;ColumnDetails&gt;
  * There are two kinds of records.  If return[1][i] is NativeObject.NULLPTR, return[0][i] contains
  * the column index for the i-th element in the dotted field description path.
  * If return[1][i] is *not* NativeObject.NULLPTR, it is a pointer to the source table for a backlink
  * and return[0][i] is the column index of the source column in that table.
+ *
+ * This class only understands how to parse field descriptions consisting of Java field names as
+ * given in the model classes. If a field is specified using internal column names, like e.g.
+ * queries done on a {@link io.realm.DynamicRealm} use {@link DynamicFieldDescriptor} instead.
  */
 class CachedFieldDescriptor extends FieldDescriptor {
     private final SchemaProxy schema;
@@ -41,7 +44,7 @@
     /**
      * @param schema the associated Realm Schema
      * @param className the starting Table: where(Table.class)
-     * @param fieldDescription fieldName or link path to a field name.
+     * @param fieldDescription fieldName or link path to a field name using field names from Java model classes
      */
     CachedFieldDescriptor(SchemaProxy schema, String className, String fieldDescription, Set<RealmFieldType> validInternalColumnTypes, Set<RealmFieldType> validFinalColumnTypes) {
         super(fieldDescription, validInternalColumnTypes, validFinalColumnTypes);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
index 7328073b28..70997e36a5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
@@ -26,6 +26,9 @@
 /**
  * A field descriptor that uses dynamic table lookup.
  * Use when cache cannot be trusted...
+ *
+ * This class only understands how to parse field descriptions consisting of internal column names,
+ * if a field is specified using Java model class names, use {@link CachedFieldDescriptor} instead.
  */
 class DynamicFieldDescriptor extends FieldDescriptor {
     private final Table table;
@@ -34,7 +37,7 @@
      * Build a dynamic field descriptor for the passed field description string.
      *
      * @param table the start table.
-     * @param fieldDescription the field description.
+     * @param fieldDescription the field description using internal columns.
      * @param validInternalColumnTypes valid types for the last field in the field description.
      * @param validFinalColumnTypes valid types for the last field in the field description.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
index 41f0e51aa1..6d3857bb88 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
@@ -97,7 +97,14 @@ public static FieldDescriptor createStandardFieldDescriptor(
             Table table,
             String fieldDescription,
             RealmFieldType... validFinalColumnTypes) {
-        return createFieldDescriptor(schema, table, fieldDescription, null, new HashSet<>(Arrays.asList(validFinalColumnTypes)));
+
+        return createFieldDescriptor(
+                schema,
+                table,
+                fieldDescription,
+                null,
+                new HashSet<>(Arrays.asList(validFinalColumnTypes))
+        );
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 626041c3cb..137ba6605d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -46,6 +46,7 @@
 public class CompositeMediator extends RealmProxyMediator {
 
     private final Map<Class<? extends RealmModel>, RealmProxyMediator> mediators;
+    private final Map<String, Class<? extends RealmModel>> internalClassNames = new HashMap<>();
 
     public CompositeMediator(RealmProxyMediator... mediators) {
         final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<>();
@@ -53,7 +54,23 @@ public CompositeMediator(RealmProxyMediator... mediators) {
         if (mediators != null) {
             for (RealmProxyMediator mediator : mediators) {
                 for (Class<? extends RealmModel> realmClass : mediator.getModelClasses()) {
+                    // Verify that the module doesn't contain conflicting definitions for the same
+                    // underlying internal name. Can only happen if we add a module from a library
+                    // and a module from the app at the same time.
+                    String newInternalName = mediator.getSimpleClassName(realmClass);
+                    Class existingClass = internalClassNames.get(newInternalName);
+                    if (existingClass != null && !existingClass.equals(realmClass)) {
+                         throw new IllegalStateException(String.format("It is not allowed for two different " +
+                                 "model classes to share the same internal name in Realm. The " +
+                                 "classes %s and %s are being included from the modules '%s' and '%s' " +
+                                 "and they share the same internal name '%s'.", existingClass, realmClass,
+                                 tempMediators.get(existingClass), mediator,
+                                 newInternalName));
+                    }
+
+                    // Store mapping between
                     tempMediators.put(realmClass, mediator);
+                    internalClassNames.put(newInternalName, realmClass);
                 }
             }
         }
@@ -62,8 +79,7 @@ public CompositeMediator(RealmProxyMediator... mediators) {
 
     @Override
     public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
-        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
-                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = new HashMap<>();
         for (RealmProxyMediator mediator : mediators.values()) {
             infoMap.putAll(mediator.getExpectedObjectSchemaInfoMap());
         }
diff --git a/version.txt b/version.txt
index 932e22fb7f..84980dc3fe 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.3.4-SNAPSHOT
\ No newline at end of file
+4.4.0-SNAPSHOT
\ No newline at end of file
