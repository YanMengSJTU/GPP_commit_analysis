diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2572de7365..18d5167ed2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,29 +1,17 @@
-## 4.0.0 (YYYY-MM-DD)
+## 4.1.0 (YYYY-MM-DD)
 
 ## Breaking Changes
 
 ## Enhancements
 
-* All Realm annotations are now kept at runtime, allowing runtime tools access to them (#5344).
-* Speedup schema initialization when a Realm file is first accessed (#5391).
-
 ## Bug Fixes
 
-* Assigning a managed object's own list to itself would accidentally clear it (#5395).
-* Don't try to acquire `ApplicationContext` if not available in `Realm.init(Context)` (#5389).
-* Removing and re-adding a changelistener from inside a changelistener sometimes caused notifications to be missed (#5411).
-
 ## Internal
 
-* Upgraded to Realm Sync 2.0.0.
-* Upgraded to Realm Core 4.0.2.
-* Upgraded to OkHttp 3.9.0 .
-* Upgraded to RxJava 2.1.4 .
-
-## Credits
+### Credits
 
 
-## 4.0.0-RC1 (2017-10-03)
+## 4.0.0 (2016-10-16)
 
 ## Breaking Changes
 
@@ -60,20 +48,28 @@ The internal file format has been upgraded. Opening an older Realm will upgrade
 * Added `RealmResults.asChangesetObservable()` that emits the pair `(results, changeset)` (#4277).
 * Added `RealmList.asChangesetObservable()` that emits the pair `(list, changeset)` (#4277).
 * Added `RealmObject.asChangesetObservable()` that emits the pair `(object, changeset)` (#4277).
+* All Realm annotations are now kept at runtime, allowing runtime tools access to them (#5344).
+* Speedup schema initialization when a Realm file is first accessed (#5391).
 
 ## Bug Fixes
 
 * [ObjectServer] Exposing a `RealmConfiguration` that allows a user to open the backup Realm after the client reset (#4759/#5223).
 * [ObjectServer] Realm no longer throws a native “unsupported instruction” exception in some cases when opening a synced Realm asynchronously (https://github.com/realm/realm-object-store/issues/502).
+* [ObjectServer] Fixed "Cannot open the read only Realm" issue when get`PermissionManager` (#5414).
 * Throw `IllegalArgumentException` instead of `IllegalStateException` when calling string/binary data setters if the data length exceeds the limit.
 * Added support for ISO8601 2-digit time zone designators (#5309).
 * "Bad File Header" caused by the device running out of space while compacting the Realm (#5011).
 * `RealmQuery.equalTo()` failed to find null values on an indexed field if using Case.INSENSITIVE (#5299).
+* Assigning a managed object's own list to itself would accidentally clear it (#5395).
+* Don't try to acquire `ApplicationContext` if not available in `Realm.init(Context)` (#5389).
+* Removing and re-adding a changelistener from inside a changelistener sometimes caused notifications to be missed (#5411).
 
 ## Internal
 
-* Upgraded to Realm Sync 2.0.0-rc27.
-* Upgraded to Realm Core 4.0.1.
+* Upgraded to Realm Sync 2.0.2.
+* Upgraded to Realm Core 4.0.2.
+* Upgraded to OkHttp 3.9.0.
+* Upgraded to RxJava 2.1.4.
 * Use Object Store to create the primary key table.
 
 ### Credits
diff --git a/Jenkinsfile b/Jenkinsfile
index e93e987237..a5b2845569 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -45,7 +45,7 @@ try {
           rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
         }
 
-	    rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
+	    rosContainer = rosEnv.run()
 
         try {
               buildEnv.inside("-e HOME=/tmp " +
@@ -116,6 +116,7 @@ try {
                 }
               }
         } finally {
+              archiveRosLog(rosContainer.id)
               sh "docker logs ${rosContainer.id}"
               rosContainer.stop()
         }
@@ -173,6 +174,16 @@ def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
   sh 'rm logcat.txt'
 }
 
+def archiveRosLog(String id) {
+  sh "docker cp ${id}:/tmp/ros-testing-server.log ./ros.log"
+  zip([
+      'zipFile': 'roslog.zip',
+      'archive': true,
+      'glob' : 'ros.log'
+  ])
+  sh 'rm ros.log'
+}
+
 def sendMetrics(String metricName, String metricValue, Map<String, String> tags) {
   def tagsString = getTagsString(tags)
   withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
diff --git a/dependencies.list b/dependencies.list
index d997db1ea9..838c222f42 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,9 +1,9 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=2.0.0
-REALM_SYNC_SHA256=2d3661cdb94d6509b4a43d6daab17c9223fbb1e6608e317205bd61b4ef1b9516
+REALM_SYNC_VERSION=2.0.2
+REALM_SYNC_SHA256=33c9dace6dc280712101110895d38509bbca74fdb31ba31b61dc0ad383472b03
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.0-rc.5
+REALM_OBJECT_SERVER_DE_VERSION=2.0.0-rc.11
 
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index a33fb1158e..eb1d5f79e2 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -91,7 +91,8 @@ use_realm_core(${build_SYNC} "${REALM_CORE_DIST_DIR}" "${CORE_SOURCE_PATH}")
 set(openssl_build_TYPE "release")
 # FIXME Read the openssl version from core when the core/sync release has that information.
 set(openssl_VERSION "1.0.2k")
-set(openssl_FILENAME "openssl-${openssl_build_TYPE}-${openssl_VERSION}-Android-${ANDROID_ABI}")
+set(openssl_BUILD_NUMBER "1")
+set(openssl_FILENAME "openssl-${openssl_build_TYPE}-${openssl_VERSION}-${openssl_BUILD_NUMBER}-Android-${ANDROID_ABI}")
 set(openssl_URL "http://static.realm.io/downloads/openssl/${openssl_VERSION}/Android/${ANDROID_ABI}/${openssl_FILENAME}.tar.gz")
 
 message(STATUS "Downloading OpenSSL...")
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 5081ecfbc4..7825f3c72e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -1802,8 +1802,7 @@ public long count() {
     }
 
     /**
-     * Finds all objects that fulfill the query conditions and sorted by specific field name.
-     * This method is only available from a Looper thread.
+     * Finds all objects that fulfill the query conditions. This method is only available from a Looper thread.
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
index dff2d1f602..9d1acc3527 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
@@ -102,7 +102,7 @@ protected Cache initialValue() {
     }
 
     private enum RealmType {
-//        DEFAULT_PERMISSION_REALM("__starpermissions", true),
+        DEFAULT_PERMISSION_REALM("__wildcardpermissions", true),
         PERMISSION_REALM("__permission", false),
         MANAGEMENT_REALM("__management", false);
 
@@ -128,7 +128,7 @@ public boolean isGlobalRealm() {
     // Used to track the lifecycle of the PermissionManager
     private RealmAsyncTask managementRealmOpenTask;
     private RealmAsyncTask permissionRealmOpenTask;
-//    private RealmAsyncTask defaultPermissionRealmOpenTask;
+    private RealmAsyncTask defaultPermissionRealmOpenTask;
     private boolean openInProgress = false;
     private boolean closed;
 
@@ -136,10 +136,10 @@ public boolean isGlobalRealm() {
     private Handler handler = new Handler();
     final SyncConfiguration managementRealmConfig;
     final SyncConfiguration permissionRealmConfig;
-//    final SyncConfiguration defaultPermissionRealmConfig;
+    final SyncConfiguration defaultPermissionRealmConfig;
     private Realm permissionRealm;
     private Realm managementRealm;
-//    private Realm defaultPermissionRealm;
+    private Realm defaultPermissionRealm;
 
     // Task list used to queue tasks until the underlying Realms are done opening (or failed doing so).
     private Deque<PermissionManagerTask> delayedTasks = new LinkedList<>();
@@ -155,7 +155,7 @@ public boolean isGlobalRealm() {
     private final Object errorLock = new Object();
     private volatile ObjectServerError permissionRealmError = null;
     private volatile ObjectServerError managementRealmError = null;
-//    private volatile ObjectServerError defaultPermissionRealmError = null;
+    private volatile ObjectServerError defaultPermissionRealmError = null;
 
     // A client reset was encountered in one of the Realms.
     // This has invalidated the PermissionManager and it must be closed as soon as possible.
@@ -166,7 +166,7 @@ public boolean isGlobalRealm() {
     // Cached result of the permission query. This will be filled, once the first PermissionAsyncTask has loaded
     // the result.
     private RealmResults<Permission> userPermissions;
-//    private RealmResults<Permission> defaultPermissions;
+    private RealmResults<Permission> defaultPermissions;
     private RealmResults<PermissionOffer> offers;
 
     /**
@@ -211,21 +211,22 @@ public void onError(SyncSession session, ObjectServerError error) {
                 .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .build();
 
-//        defaultPermissionRealmConfig = new SyncConfiguration.Builder(
-//                user, getRealmUrl(RealmType.DEFAULT_PERMISSION_REALM, user.getAuthenticationUrl()))
-//                .errorHandler(new SyncSession.ErrorHandler() {
-//                    @Override
-//                    public void onError(SyncSession session, ObjectServerError error) {
-//                        synchronized (errorLock) {
-//                            defaultPermissionRealmError = error;
-//                        }
-//                    }
-//                })
-//                .modules(new PermissionModule())
-//                .waitForInitialRemoteData()
-//                .readOnly()
-//                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
-//                .build();
+        defaultPermissionRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.DEFAULT_PERMISSION_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        RealmLog.error("Error in __wildcardpermissions:\n" + error.toString());
+                        synchronized (errorLock) {
+                            defaultPermissionRealmError = error;
+                        }
+                    }
+                })
+                .modules(new PermissionModule())
+                .waitForInitialRemoteData()
+                .readOnly()
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
     }
 
     /**
@@ -251,11 +252,10 @@ public RealmAsyncTask getPermissions(PermissionsCallback callback) {
      * live query result, that will be auto-updated like any other {@link RealmResults}.
      * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
      */
-    RealmAsyncTask getDefaultPermissions(PermissionsCallback callback) {
+    public RealmAsyncTask getDefaultPermissions(PermissionsCallback callback) {
         checkIfValid();
         checkCallbackNotNull(callback);
-        return null;
-        // return addTask(new GetDefaultPermissionsAsyncTask(this, callback));
+        return addTask(new GetDefaultPermissionsAsyncTask(this, callback));
     }
 
     /**
@@ -424,30 +424,30 @@ public void onError(Throwable exception) {
                     }
                 }
             });
-//            defaultPermissionRealmOpenTask = Realm.getInstanceAsync(defaultPermissionRealmConfig, new Realm.Callback() {
-//                @Override
-//                public void onSuccess(Realm realm) {
-//                    defaultPermissionRealm = realm;
-//                    defaultPermissionRealmOpenTask = null;
-//                    checkIfRealmsAreOpenedAndRunDelayedTasks();
-//                }
-//
-//                @Override
-//                public void onError(Throwable exception) {
-//                    synchronized (errorLock) {
-//                        defaultPermissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
-//                        defaultPermissionRealmOpenTask = null;
-//                        checkIfRealmsAreOpenedAndRunDelayedTasks();
-//                    }
-//                }
-//            });
+            defaultPermissionRealmOpenTask = Realm.getInstanceAsync(defaultPermissionRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    defaultPermissionRealm = realm;
+                    defaultPermissionRealmOpenTask = null;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        defaultPermissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        defaultPermissionRealmOpenTask = null;
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
         }
     }
 
     private void checkIfRealmsAreOpenedAndRunDelayedTasks() {
         synchronized (errorLock) {
             if ((permissionRealm != null || permissionRealmError != null)
-//                && (defaultPermissionRealm != null || defaultPermissionRealmError != null)
+                && (defaultPermissionRealm != null || defaultPermissionRealmError != null)
                 && (managementRealm != null || managementRealmError != null)) {
                 openInProgress = false;
                 runDelayedTasks();
@@ -509,10 +509,10 @@ public void close() {
             permissionRealmOpenTask.cancel();
             permissionRealmOpenTask = null;
         }
-//        if (defaultPermissionRealmOpenTask != null) {
-//            defaultPermissionRealmOpenTask.cancel();
-//            defaultPermissionRealmOpenTask = null;
-//        }
+        if (defaultPermissionRealmOpenTask != null) {
+            defaultPermissionRealmOpenTask.cancel();
+            defaultPermissionRealmOpenTask = null;
+        }
 
         // If Realms are opened. Close them.
         if (managementRealm != null) {
@@ -522,9 +522,9 @@ public void close() {
         if (permissionRealm != null) {
             permissionRealm.close();
         }
-//        if (defaultPermissionRealm != null) {
-//            defaultPermissionRealm.close();
-//        }
+        if (defaultPermissionRealm != null) {
+            defaultPermissionRealm.close();
+        }
     }
 
     /**
@@ -615,54 +615,55 @@ void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
         }
     }
 
-//    // Task responsible for loading the Default Permissions result and returning it to the user.
-//    // The Permission result is not considered available until the query has completed.
-//    private class GetDefaultPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
-//
-//        private final PermissionsCallback callback;
-//        // Prevent permissions from being GC'ed until fully loaded.
-//        private RealmResults<Permission> loadingPermissions;
-//
-//        GetDefaultPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
-//            super(permissionManager, callback);
-//            this.callback = callback;
-//        }
-//
-//        @Override
-//        public void run() {
-//            if (checkAndReportInvalidState()) { return; }
-//            if (defaultPermissions != null) {
-//                notifyCallbackWithSuccess(defaultPermissions);
-//            } else {
-//                // Start loading permissions.
-//                // TODO Right now multiple getPermission() calls will result in multiple
-//                // queries being executed. The first one to return will be the one returned
-//                // by all callbacks.
-//                loadingPermissions = permissionRealm.where(Permission.class).findAllAsync();
-//                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
-//                    @Override
-//                    public void onChange(RealmResults <Permission> loadedPermissions) {
-//                        if (loadedPermissions.size() > 0) {
-//                            loadingPermissions.removeChangeListener(this);
-//                            if (checkAndReportInvalidState()) { return; }
-//                            if (defaultPermissions == null) {
-//                                defaultPermissions = loadedPermissions;
-//                            }
-//                            notifyCallbackWithSuccess(defaultPermissions);
-//                        }
-//                    }
-//                });
-//            }
-//        }
-//
-//        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
-//            try {
-//               callback.onSuccess(permissions);
-//            } finally {
-//                activeTasks.remove(this);
-//            }
-//        }
-//    }
+    // Task responsible for loading the Default Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetDefaultPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final PermissionsCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<Permission> loadingPermissions;
+
+        GetDefaultPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (defaultPermissions != null) {
+                notifyCallbackWithSuccess(defaultPermissions);
+            } else {
+                // Start loading permissions.
+                // TODO Right now multiple getPermission() calls will result in multiple
+                // queries being executed. The first one to return will be the one returned
+                // by all callbacks.
+                loadingPermissions = defaultPermissionRealm.where(Permission.class).findAllAsync();
+                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults <Permission> loadedPermissions) {
+                        // Wildcard permissions should contain 1 Realm as the default, namely __wildcardpermissions
+                        if (loadedPermissions.size() > 0) {
+                            loadingPermissions.removeChangeListener(this);
+                            if (checkAndReportInvalidState()) { return; }
+                            if (defaultPermissions == null) {
+                                defaultPermissions = loadedPermissions;
+                            }
+                            notifyCallbackWithSuccess(defaultPermissions);
+                        }
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
+            try {
+               callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
 
     // Class encapsulating setting a Permission by writing a PermissionChange and waiting for it to
     // be processed.
@@ -1026,10 +1027,10 @@ protected final boolean checkAndReportInvalidState() {
                 // Only hold lock while making a safe copy of current error state
                 managementErrorHappened = (permissionManager.managementRealmError != null);
                 permissionErrorHappened = (permissionManager.permissionRealmError != null);
-//                defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
+                defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
                 managementError = permissionManager.managementRealmError;
                 permissionError = permissionManager.permissionRealmError;
-//                defaultPermissionError = permissionManager.defaultPermissionRealmError;
+                defaultPermissionError = permissionManager.defaultPermissionRealmError;
             }
 
             // Everything seems valid
@@ -1061,12 +1062,12 @@ protected final boolean checkAndReportInvalidState() {
                 permissionManager.clientReset = true;
             }
 
-//            if (defaultPermissionErrorHappened && defaultPermissionError instanceof ClientResetRequiredError) {
-//                ClientResetRequiredError cr = (ClientResetRequiredError) defaultPermissionError;
-//                permissionManager.defaultPermissionRealm.close();
-//                cr.executeClientReset();
-//                permissionManager.clientReset = true;
-//            }
+            if (defaultPermissionErrorHappened && defaultPermissionError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) defaultPermissionError;
+                permissionManager.defaultPermissionRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
 
             // Handle errors
             Map<String, ObjectServerError> errors = new LinkedHashMap<>();
@@ -1075,7 +1076,7 @@ protected final boolean checkAndReportInvalidState() {
             } else {
                 if (managementErrorHappened) { errors.put("Management Realm", managementError); }
                 if (permissionErrorHappened) { errors.put("Permission Realm", permissionError); }
-//                if (defaultPermissionErrorHappened) { errors.put("Default Permission Realm", defaultPermissionError); }
+                if (defaultPermissionErrorHappened) { errors.put("Default Permission Realm", defaultPermissionError); }
             }
             notifyCallbackWithError(combineRealmErrors(errors)); // This will remove the task from the task list
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
index 770ae872c4..70e76c7b65 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
@@ -106,6 +106,7 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore
     public void getPermissions_updatedWithNewRealms() {
         final PermissionManager pm = user.getPermissionManager();
         looperThread.closeAfterTest(pm);
@@ -152,6 +153,7 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore
     public void getPermissions_updatedWithNewRealms_stressTest() {
         final int TEST_SIZE = 10;
         final PermissionManager pm = user.getPermissionManager();
@@ -243,7 +245,6 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore("Wait for default permission Realm support")
     public void getPermissions_addTaskAfterClientReset() {
         final PermissionManager pm = user.getPermissionManager();
         looperThread.closeAfterTest(pm);
@@ -428,7 +429,6 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore("See https://github.com/realm/ros/issues/520")
     public void getDefaultPermissions_returnLoadedResults() {
         PermissionManager pm = user.getPermissionManager();
         looperThread.closeAfterTest(pm);
@@ -436,7 +436,7 @@ public void getDefaultPermissions_returnLoadedResults() {
             @Override
             public void onSuccess(RealmResults<Permission> permissions) {
                 assertTrue(permissions.isLoaded());
-                assertInitialPermissions(permissions);
+                assertInitialDefaultPermissions(permissions);
                 looperThread.testComplete();
             }
 
@@ -449,7 +449,6 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore("See https://github.com/realm/ros/issues/520")
     public void getDefaultPermissions_noLongerValidWhenPermissionManagerIsClosed() {
         final PermissionManager pm = user.getPermissionManager();
         pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
@@ -481,7 +480,6 @@ public void getDefaultPermissions_updatedWithNewRealms() {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore("See https://github.com/realm/ros/issues/520")
     public void getDefaultPermissions_closed() throws IOException {
         PermissionManager pm = user.getPermissionManager();
         pm.close();
@@ -1210,4 +1208,8 @@ private void assertInitialPermissions(RealmResults<Permission> permissions) {
         assertEquals("Could not find __permissions Realm", 1, permissions.where().endsWith("path", "__permission").count());
         assertEquals("Could not find __management Realm", 1, permissions.where().endsWith("path", "__management").count());
     }
+
+    private void assertInitialDefaultPermissions(RealmResults<Permission> permissions) {
+        assertEquals("Could not find __wildcardpermissions Realm", 1, permissions.where().endsWith("path", "__wildcardpermissions").count());
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index 8d16609bee..ab943c1e3c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -39,7 +39,6 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-@Ignore("See https://github.com/realm/ros/issues/240")
 public class SSLConfigurationTests extends StandardIntegrationTest {
 
     @Rule
@@ -65,12 +64,12 @@ public void trustedRootCA() throws InterruptedException {
         SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
         realm.close();
         user.logout();
-        Realm.deleteRealm(configOld);
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
                 .schema(StringOnly.class)
                 .waitForInitialRemoteData()
                 .trustedRootCA("trusted_ca.pem")
@@ -106,12 +105,12 @@ public void withoutSSLVerification() throws InterruptedException {
         SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
         realm.close();
         user.logout();
-        Realm.deleteRealm(configOld);
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
                 .schema(StringOnly.class)
                 .waitForInitialRemoteData()
                 .disableSSLVerification()
@@ -147,12 +146,12 @@ public void trustedRootCA_syncShouldFailWithoutTrustedCA() throws InterruptedExc
         SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
         realm.close();
         user.logout();
-        Realm.deleteRealm(configOld);
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
                 .schema(StringOnly.class)
                 .build();
         realm = Realm.getInstance(config);
@@ -170,6 +169,7 @@ public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        int originalLevel = RealmLog.getLevel();
         RealmLog.add(testLogger);
         RealmLog.setLevel(LogLevel.WARN);
 
@@ -181,6 +181,8 @@ public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
 
         assertEquals("SSL Verification is disabled, the provided server certificate will not be used.",
                 testLogger.message);
+        RealmLog.remove(testLogger);
+        RealmLog.setLevel(originalLevel);
     }
 
     @Test
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 21399cc133..7fce3b7a02 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -7,6 +7,7 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -115,6 +116,7 @@ public void uploadDownloadAllChanges() throws InterruptedException {
     }
 
     @Test
+    @Ignore()
     public void interruptWaits() throws InterruptedException {
         final SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
@@ -307,6 +309,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
     // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
     // this test validate the behaviour of SyncSessionStopPolicy::AfterChangesUploaded
     @Test
+    @Ignore()
     public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index 97cd798d1b..8a936242db 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -6,7 +6,7 @@ ARG ROS_DE_VERSION
 RUN npm install -g realm-object-server@$ROS_DE_VERSION -S
 
 # Install test server dependencies
-RUN npm install winston temp httpdispatcher@1.0.0 fs-extra
+RUN npm install winston temp httpdispatcher@1.0.0 fs-extra moment
 
 COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem configuration.yml /
 COPY ros-testing-server.js /usr/bin/
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index d199e33677..6225970ad2 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -7,6 +7,7 @@ const exec = require('child_process').exec;
 var http = require('http');
 var dispatcher = require('httpdispatcher');
 var fs = require('fs-extra');
+var moment = require('moment')
 
 // Automatically track and cleanup files at exit
 temp.track();
@@ -15,9 +16,16 @@ if (process. argv. length <= 2) {
     console.log("Usage: " + __filename + " somefile.log");
     process.exit(-1);
 }
+
 const logFile = process.argv[2];
 winston.level = 'debug';
-winston.add(winston.transports.File, { filename: logFile });
+winston.add(winston.transports.File, {
+    filename: logFile,
+    json: false,
+    formatter: function(options) {
+        return moment().format('YYYY-MM-DD HH:mm:ss.SSSS') + ' ' + (undefined !== options.message ? options.message : '');
+    }
+});
 
 const PORT = 8888;
 
@@ -64,6 +72,7 @@ function startRealmObjectServer(onSuccess, onError) {
             var env = Object.create( process.env );
             winston.info(env.NODE_ENV);
             env.NODE_ENV = 'development';
+            env.JENKINS = 1; // Skip email check in ROS
 
             // Manually cleanup Global Notifier State
             // See https://github.com/realm/ros/issues/437#issuecomment-335380095
@@ -80,18 +89,22 @@ function startRealmObjectServer(onSuccess, onError) {
             syncServerChildProcess = spawn('ros',
                     ['start',
                         '--data', path,
-                        // '--loglevel', 'detail', // Enable when debugging
+                        '--loglevel', 'detail',
+                        '--https',
+                        '--https-key', '/127_0_0_1-server.key.pem',
+                        '--https-cert', '/127_0_0_1-chain.crt.pem',
+                        '--https-port', '9443',
                         '--access-token-ttl', '20' //WARNING : Changing this value may impact the timeout of the refresh token test (AuthTests#preemptiveTokenRefresh)
                     ],
                     { env: env, cwd: path});
 
             // local config:
             syncServerChildProcess.stdout.on('data', (data) => {
-                winston.info(`stdout: ${data}`);
+                winston.info(`${data}`);
             });
 
             syncServerChildProcess.stderr.on('data', (data) => {
-                winston.info(`stderr: ${data}`);
+                winston.info(`${data}`);
             });
 
             waitForRosToInitialize(20, onSuccess, onError);
diff --git a/version.txt b/version.txt
index 94ae9ee1fa..83a328a922 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.0.0-SNAPSHOT
+4.1.0-SNAPSHOT
\ No newline at end of file
