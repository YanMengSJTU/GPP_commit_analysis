diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4eb2c28380..e3fee3baeb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,10 @@
 ## Breaking Changes
 
 * Calling `distinct()` on a sorted `RealmResults` no longer clears the sorting (#3503).
+* [ObjectServer] Removed deprecated APIs `SyncUser.retrieveUser()` and `SyncUser.retrieveUserAsync()`. Use `SyncUser.retrieveInfoForUser()` and `retrieveInfoForUserAsync()` instead.
+* Removed deprecated APIs `RealmSchema.close()` and `RealmObjectSchema.close()`. Those don't have to be called anymore.
+* Removed deprecated API `RealmResults.removeChangeListeners()`. Use `RealmResults.removeAllChangeListeners()` instead.
+* Removed deprecated API `RealmObject.removeChangeListeners()`. Use `RealmObject.removeAllChangeListeners()` instead.
 
 ## Deprecated
 
@@ -35,6 +39,7 @@
 
 * Upgraded to Realm Sync 2.0.0-rc16.
 * Upgraded to Realm Core 3.0.0-rc5.
+* Always use Object Store to create primary key table.
 
 ## 4.0.0-BETA2 (2017-07-27)
 
diff --git a/Jenkinsfile b/Jenkinsfile
index 84261d4ceb..e93e987237 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -55,6 +55,7 @@ try {
                   "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
                   "-v ${env.HOME}/.android:/tmp/.android " +
                   "-v ${env.HOME}/ccache:/tmp/.ccache " +
+                  "-e REALM_CORE_DOWNLOAD_DIR=/tmp/.gradle " +
                   "--network container:${rosContainer.id}") {
                 stage('JVM tests') {
                   try {
diff --git a/dependencies.list b/dependencies.list
index 91cfac3223..0025e7c835 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -5,4 +5,4 @@ REALM_SYNC_SHA256=5e09e54e68e78683e006898f5a703f80e0ee49492fb0f9dc2384fcbbb9f02f
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.0-alpha.34
+REALM_OBJECT_SERVER_DE_VERSION=2.0.0-alpha.35
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 9bfd5a7845..8b2ea52b8d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -1319,10 +1319,10 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
             writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
             if (Utils.isString(metadata.getPrimaryKey())) {
                 writer.emitStatement(
-                        "rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue)");
+                        "rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue)");
             } else {
                 writer.emitStatement(
-                        "rowIndex = OsObject.createRowWithPrimaryKey(table, ((%s) object).%s())",
+                        "rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, ((%s) object).%s())",
                         interfaceName, primaryKeyGetter);
             }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 994bef3d5d..3a914bf064 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -786,7 +786,7 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
         if (rowIndex == Table.NO_MATCH) {
-            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
+            rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
         } else {
             Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
         }
@@ -854,7 +854,7 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
             }
             if (rowIndex == Table.NO_MATCH) {
-                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
+                rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
             } else {
                 Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
             }
@@ -915,7 +915,7 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
         if (rowIndex == Table.NO_MATCH) {
-            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
+            rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
         }
         cache.put(object, rowIndex);
         Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
@@ -991,7 +991,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
             }
             if (rowIndex == Table.NO_MATCH) {
-                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
+                rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
             }
             cache.put(object, rowIndex);
             Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 555e1c1466..5b8cf56418 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -31,6 +31,7 @@
 
 import io.realm.entities.IOSAllTypes;
 import io.realm.entities.IOSChild;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -81,7 +82,7 @@ public void iOSDataTypes() throws IOException {
             RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
             // Verifies metadata.
             Table table = realm.getTable(IOSAllTypes.class);
-            assertTrue(table.hasPrimaryKey());
+            assertEquals("id", OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), IOSAllTypes.CLASS_NAME));
             assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
             // Iterative check.
             for (int i = 0; i < 10; i++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index 3e18d70e5a..e2d0a4b959 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -30,11 +30,13 @@
 import io.realm.entities.PrimaryKeyAsLong;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -99,76 +101,6 @@ public void index() {
         assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexDate")));
     }
 
-    // Tests migrating primary key from string to long with existing data.
-    @Test
-    public void primaryKey_migration_long() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
-            obj.setId(i);
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsString.class);
-        table.setPrimaryKey("id");
-        assertEquals(1, table.getPrimaryKey());
-        realm.cancelTransaction();
-    }
-
-    // Tests migrating primary key from string to long with existing data.
-    @Test
-    public void primaryKey_migration_longDuplicateValues() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
-            obj.setId(1); // Creates duplicate values.
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsString.class);
-        try {
-            table.setPrimaryKey("id");
-            fail("It should not be possible to set a primary key column which already contains duplicate values.");
-        } catch (IllegalArgumentException ignored) {
-            assertEquals(0, table.getPrimaryKey());
-        } finally {
-            realm.cancelTransaction();
-        }
-    }
-
-    // Tests migrating primary key from long to str with existing data.
-    @Test
-    public void primaryKey_migration_string() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
-            obj.setName("String" + i);
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsLong.class);
-        table.setPrimaryKey("name");
-        assertEquals(1, table.getPrimaryKey());
-        realm.cancelTransaction();
-    }
-
-    // Tests migrating primary key from long to str with existing data.
-    @Test
-    public void primaryKey_migration_stringDuplicateValues() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
-            obj.setName("String"); // Creates duplicate values.
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsLong.class);
-        try {
-            table.setPrimaryKey("name");
-            fail("It should not be possible to set a primary key column which already contains duplicate values.");
-        } catch (IllegalArgumentException ignored) {
-            assertEquals(0, table.getPrimaryKey());
-        } finally {
-            realm.cancelTransaction();
-        }
-    }
-
     @Test
     public void primaryKey_checkPrimaryKeyOnCreate() {
         realm.beginTransaction();
@@ -197,11 +129,11 @@ public void primaryKey_errorOnInsertingSameObject() {
     @Test
     public void primaryKey_isIndexed() {
         Table table = realm.getTable(PrimaryKeyAsString.class);
-        assertTrue(table.hasPrimaryKey());
+        assertNotNull(OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), PrimaryKeyAsString.CLASS_NAME));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("name")));
 
         table = realm.getTable(PrimaryKeyAsLong.class);
-        assertTrue(table.hasPrimaryKey());
+        assertNotNull(OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), PrimaryKeyAsLong.CLASS_NAME));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 923581bc45..91e0d6945b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -62,6 +62,7 @@
 import io.realm.entities.migration.MigrationPosteriorIndexOnly;
 import io.realm.entities.migration.MigrationPriorIndexOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.migration.MigrationPrimaryKey;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -98,6 +99,18 @@ public void tearDown() {
         }
     }
 
+    private void assertPKField(Realm realm, String className, String expectedName, long expectedIndex) {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, className);
+        assertNotNull(pkField);
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        assertTrue(objectSchema.hasField(expectedName));
+        assertEquals(expectedName, pkField);
+        //noinspection ConstantConditions
+        assertEquals(expectedIndex,
+                realm.sharedRealm.getTable(Table.getTableNameForClass(className)).getColumnIndex(pkField));
+    }
+
     @Test
     public void getInstance_realmClosedAfterMigrationException() throws IOException {
         String REALM_NAME = "default0.realm";
@@ -371,10 +384,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationClassRenamed.CLASS_NAME, MigrationClassRenamed.FIELD_PRIMARY,
+                MigrationClassRenamed.DEFAULT_PRIMARY_INDEX);
         // Old schema does not exist.
         assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
     }
@@ -440,10 +452,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationClassRenamed.CLASS_NAME, MigrationClassRenamed.FIELD_PRIMARY,
+                MigrationClassRenamed.DEFAULT_PRIMARY_INDEX);
         // Old schema does not exist.
         assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
     }
@@ -553,10 +564,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
         Table table = realm.getSchema().getTable(MigrationPosteriorIndexOnly.class);
 
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationPosteriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationPosteriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationPosteriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationPosteriorIndexOnly.CLASS_NAME, MigrationPosteriorIndexOnly.FIELD_PRIMARY
+                , MigrationPosteriorIndexOnly.DEFAULT_PRIMARY_INDEX);
     }
 
     // Removing fields after a pk field does not affect the pk.
@@ -580,10 +590,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
         Table table = realm.getSchema().getTable(MigrationPriorIndexOnly.class);
 
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationPriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationPriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationPriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationPriorIndexOnly.CLASS_NAME, MigrationPriorIndexOnly.FIELD_PRIMARY
+                , MigrationPriorIndexOnly.DEFAULT_PRIMARY_INDEX);
     }
 
     // Renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys.
@@ -606,13 +615,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationFieldRenamed.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationFieldRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-
-        RealmObjectSchema objectSchema = realm.getSchema().get(MigrationFieldRenamed.CLASS_NAME);
-        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
-        assertEquals(MigrationFieldRenamed.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+        assertPKField(realm, MigrationFieldRenamed.CLASS_NAME, MigrationFieldRenamed.FIELD_PRIMARY,
+                MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX);
     }
 
     private void createObjectsWithOldPrimaryKey(final String className, final boolean insertNullValue) {
@@ -672,13 +677,10 @@ public void apply(DynamicRealmObject obj) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationFieldTypeToInt.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationFieldTypeToInt.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationFieldTypeToInt.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertPKField(realm, MigrationFieldTypeToInt.CLASS_NAME, MigrationFieldTypeToInt.FIELD_PRIMARY,
+                MigrationFieldTypeToInt.DEFAULT_PRIMARY_INDEX);
 
-        RealmObjectSchema objectSchema = realm.getSchema().get(MigrationFieldTypeToInt.CLASS_NAME);
-        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
-        assertEquals(MigrationFieldTypeToInt.FIELD_PRIMARY, objectSchema.getPrimaryKey());
         assertEquals(1, realm.where(MigrationFieldTypeToInt.class).count());
         assertEquals(12, realm.where(MigrationFieldTypeToInt.class).findFirst().fieldIntPrimary);
     }
@@ -720,13 +722,10 @@ public void apply(DynamicRealmObject obj) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationFieldTypeToInteger.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationFieldTypeToInteger.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertPKField(realm, MigrationFieldTypeToInteger.CLASS_NAME, MigrationFieldTypeToInteger.FIELD_PRIMARY,
+                MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX);
 
-        RealmObjectSchema objectSchema = realm.getSchema().get(MigrationFieldTypeToInteger.CLASS_NAME);
-        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
-        assertEquals(MigrationFieldTypeToInteger.FIELD_PRIMARY, objectSchema.getPrimaryKey());
         assertEquals(2, realm.where(MigrationFieldTypeToInteger.class).count());
 
         // not-null value
@@ -740,6 +739,95 @@ public void apply(DynamicRealmObject obj) {
                              .count());
     }
 
+    @Test
+    public void modifyPrimaryKeyFieldTypeFromIntToStringInMigration() {
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmObjectSchema objectSchema  = realm.getSchema().get(PrimaryKeyAsString.CLASS_NAME);
+                assertNotNull(objectSchema);
+                assertEquals(PrimaryKeyAsString.FIELD_ID, objectSchema.getPrimaryKey());
+                objectSchema.removePrimaryKey().addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
+            }
+        };
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .schema(PrimaryKeyAsString.class)
+                .schemaVersion(1)
+                .migration(migration)
+                .build();
+
+        // Create the schema and set the int field as primary key
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        dynamicRealm.beginTransaction();
+        RealmSchema schema = dynamicRealm.getSchema();
+        schema.create(PrimaryKeyAsString.CLASS_NAME)
+                .addField(PrimaryKeyAsString.FIELD_ID, long.class, FieldAttribute.PRIMARY_KEY)
+                .addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
+        dynamicRealm.createObject(PrimaryKeyAsString.CLASS_NAME, 0)
+                .setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "string0");
+        dynamicRealm.createObject(PrimaryKeyAsString.CLASS_NAME, 1)
+                .setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "string1");
+        dynamicRealm.setVersion(0);
+        dynamicRealm.commitTransaction();
+
+        // Run migration
+        realm = Realm.getInstance(configuration);
+        RealmObjectSchema objectSchema = realm.getSchema().get(PrimaryKeyAsString.CLASS_NAME);
+        assertNotNull(objectSchema);
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
+        RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class)
+                .findAllSorted(PrimaryKeyAsString.FIELD_ID);
+        assertEquals(2, results.size());
+        assertEquals("string0", results.get(0).getName());
+        assertEquals("string1", results.get(1).getName());
+    }
+
+    @Test
+    public void modifyPrimaryKeyFieldTypeFromStringToInt() {
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmObjectSchema objectSchema  = realm.getSchema().get(PrimaryKeyAsInteger.CLASS_NAME);
+                assertNotNull(objectSchema);
+                assertEquals(PrimaryKeyAsInteger.FIELD_NAME, objectSchema.getPrimaryKey());
+                objectSchema.removePrimaryKey().addPrimaryKey(PrimaryKeyAsInteger.FIELD_ID);
+            }
+        };
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .schema(PrimaryKeyAsInteger.class)
+                .schemaVersion(1)
+                .migration(migration)
+                .build();
+
+        // Create the schema and set the String field as primary key
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        dynamicRealm.beginTransaction();
+        RealmSchema schema = dynamicRealm.getSchema();
+        schema.create(PrimaryKeyAsInteger.CLASS_NAME)
+                .addField(PrimaryKeyAsInteger.FIELD_ID, int.class)
+                .addField(PrimaryKeyAsInteger.FIELD_NAME, String.class, FieldAttribute.PRIMARY_KEY);
+        dynamicRealm.createObject(PrimaryKeyAsInteger.CLASS_NAME, "string0")
+                .setInt(PrimaryKeyAsInteger.FIELD_ID, 0);
+        dynamicRealm.createObject(PrimaryKeyAsInteger.CLASS_NAME, "string1")
+                .setInt(PrimaryKeyAsInteger.FIELD_ID, 1);
+        dynamicRealm.setVersion(0);
+        dynamicRealm.commitTransaction();
+
+        // Run migration
+        realm = Realm.getInstance(configuration);
+
+        RealmObjectSchema objectSchema = realm.getSchema().get(PrimaryKeyAsInteger.CLASS_NAME);
+        assertNotNull(objectSchema);
+        assertEquals(PrimaryKeyAsInteger.FIELD_ID, objectSchema.getPrimaryKey());
+        RealmResults<PrimaryKeyAsInteger> results = realm.where(PrimaryKeyAsInteger.class)
+                .findAllSorted(PrimaryKeyAsInteger.FIELD_ID);
+        assertEquals(2, results.size());
+        assertEquals(0, results.get(0).getId());
+        assertEquals(1, results.get(1).getId());
+    }
+
     @Test
     public void settingPrimaryKeyWithObjectSchema() {
         // Creates v0 of the Realm.
@@ -804,7 +892,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         realm = Realm.getInstance(realmConfig);
         Table table = realm.getTable(AnnotationTypes.class);
         assertEquals(3, table.getColumnCount());
-        assertTrue(table.hasPrimaryKey());
+        assertEquals("id", OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), "AnnotationTypes"));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index d72618711b..dedb61e2ba 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -496,7 +496,7 @@ public void addPrimaryKeyFieldModifier_duplicateValues() {
                 fail();
             } catch (IllegalArgumentException e) {
                 // Checks if message reports correct field name.
-                assertTrue(e.getMessage().contains("\"" + fieldName + "\""));
+                assertThat(e.getMessage(), CoreMatchers.containsString(fieldName));
             }
             schema.removeField(fieldName);
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 0c6f6523ae..35456d248c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -2554,47 +2554,6 @@ public void isNotNull_listFieldThrows() {
         }
     }
 
-    @Ignore("Disabled because it is time consuming")
-    @Test
-    public void largeRealmMultipleThreads() throws InterruptedException {
-        final int nObjects = 500000;
-        final int nThreads = 3;
-        final CountDownLatch latch = new CountDownLatch(nThreads);
-
-        realm.beginTransaction();
-        realm.delete(StringOnly.class);
-        for (int i = 0; i < nObjects; i++) {
-            StringOnly stringOnly = realm.createObject(StringOnly.class);
-            stringOnly.setChars(String.format("string %d", i));
-        }
-        realm.commitTransaction();
-
-
-        for (int i = 0; i < nThreads; i++) {
-            Thread thread = new Thread(
-                    new Runnable() {
-                        @Override
-                        @SuppressWarnings("ElementsCountedInLoop")
-                        public void run() {
-                            RealmConfiguration realmConfig = configFactory.createConfiguration();
-                            Realm realm = Realm.getInstance(realmConfig);
-                            RealmResults<StringOnly> realmResults = realm.where(StringOnly.class).findAll();
-                            int n = 0;
-                            for (StringOnly ignored : realmResults) {
-                                n = n + 1;
-                            }
-                            assertEquals(nObjects, n);
-                            realm.close();
-                            latch.countDown();
-                        }
-                    }
-            );
-            thread.start();
-        }
-
-        TestHelper.awaitOrFail(latch);
-    }
-
     @Test
     public void isValid_tableQuery() {
         final RealmQuery<AllTypes> query = realm.where(AllTypes.class);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index 6db847312d..52442d9351 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -99,7 +99,6 @@ public void setUp() {
 
     @After
     public void tearDown() {
-        realm.cancelTransaction();
         realm.close();
     }
 
@@ -561,4 +560,48 @@ public void rename_shouldUpdateDynamicCache() {
         assertSame(foo, bar);
         assertEquals("bar", bar.getClassName());
     }
+
+    @Test
+    public void rename_newNameExists() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage(
+                CoreMatchers.containsString("Cat cannot be renamed because the new class already exists"));
+        realmSchema.rename("Cat", "Dog");
+    }
+
+    @Test
+    public void mutableMethodsCalled_notInTransaction() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
+        realm.cancelTransaction();
+
+        try {
+            realmSchema.create("Foo");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+
+        try {
+            realmSchema.createWithPrimaryKeyField("Foo", "PK", String.class);
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+
+        try {
+            realmSchema.remove("Cat");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+
+        try {
+            realmSchema.rename("Cat", "Foo1");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 75c4a917c7..d253569dcb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -58,6 +58,7 @@
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.internal.Collection;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmThreadPoolExecutor;
@@ -72,7 +73,6 @@
     public static final int VERY_SHORT_WAIT_SECS = 1;
     public static final int SHORT_WAIT_SECS = 10;
     public static final int STANDARD_WAIT_SECS = 100;
-    public static final int LONG_WAIT_SECS = 1000;
 
     private static final Charset UTF_8 = Charset.forName("UTF-8");
     private static final Random RANDOM = new Random();
@@ -879,30 +879,6 @@ public static void initNullTypesTableExcludes(DynamicRealm realm, String excludi
         realm.commitTransaction();
     }
 
-    public static void populateForMultiSort(Realm typedRealm) {
-        DynamicRealm dynamicRealm = DynamicRealm.getInstance(typedRealm.getConfiguration());
-        populateForMultiSort(dynamicRealm);
-        dynamicRealm.close();
-        typedRealm.waitForChange();
-    }
-
-    public static void populateForMultiSort(DynamicRealm realm) {
-        realm.beginTransaction();
-        realm.delete(AllTypes.CLASS_NAME);
-        DynamicRealmObject object1 = realm.createObject(AllTypes.CLASS_NAME);
-        object1.setLong(AllTypes.FIELD_LONG, 5);
-        object1.setString(AllTypes.FIELD_STRING, "Adam");
-
-        DynamicRealmObject object2 = realm.createObject(AllTypes.CLASS_NAME);
-        object2.setLong(AllTypes.FIELD_LONG, 4);
-        object2.setString(AllTypes.FIELD_STRING, "Brian");
-
-        DynamicRealmObject object3 = realm.createObject(AllTypes.CLASS_NAME);
-        object3.setLong(AllTypes.FIELD_LONG, 4);
-        object3.setString(AllTypes.FIELD_STRING, "Adam");
-        realm.commitTransaction();
-    }
-
     public static void populateSimpleAllTypesPrimaryKey(Realm realm) {
         realm.beginTransaction();
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
index db36d1a8e9..771035d7c7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
@@ -24,6 +24,8 @@
 
 public class IOSAllTypes extends RealmObject {
 
+    public final static String CLASS_NAME = "IOSAllTypes";
+
     @PrimaryKey
     private long id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
index c54aa7b6fa..acc955ed01 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
@@ -23,6 +23,7 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsInteger";
     public static final String FIELD_ID = "id";
+    public static final String FIELD_NAME= "name";
 
     @PrimaryKey
     private int id;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index 2c6b451d71..52e5711b8b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -76,12 +76,20 @@ public void tearDown() {
     private SharedRealm getSharedRealm() {
         OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
                 .autoUpdateNotification(true);
-        return SharedRealm.getInstance(configBuilder);
+        SharedRealm sharedRealm = SharedRealm.getInstance(configBuilder);
+        sharedRealm.beginTransaction();
+        OsObjectStore.setSchemaVersion(sharedRealm, OsObjectStore.SCHEMA_NOT_VERSIONED);
+        sharedRealm.commitTransaction();
+        return sharedRealm;
+    }
+
+    private Table getTable(SharedRealm sharedRealm) {
+        return sharedRealm.getTable(Table.getTableNameForClass("test_table"));
     }
 
     private void populateData() {
         sharedRealm.beginTransaction();
-        table = sharedRealm.createTable("test_table");
+        table = sharedRealm.createTable(Table.getTableNameForClass("test_table"));
         // Specify the column types and names
         long columnIdx = table.addColumn(RealmFieldType.STRING, "firstName");
         table.addSearchIndex(columnIdx);
@@ -127,7 +135,7 @@ public void run() {
 
     private void addRow(SharedRealm sharedRealm) {
         sharedRealm.beginTransaction();
-        table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
         OsObject.createRow(table);
         sharedRealm.commitTransaction();
     }
@@ -154,7 +162,7 @@ public void constructor_queryIsValidated() {
     public void constructor_queryOnDeletedTable() {
         TableQuery query = table.where();
         sharedRealm.beginTransaction();
-        sharedRealm.removeTable(table.getName());
+        assertTrue(OsObjectStore.deleteTableForObject(sharedRealm, table.getClassName()));
         sharedRealm.commitTransaction();
         // Query should be checked before creating OS Results.
         thrown.expect(IllegalStateException.class);
@@ -246,7 +254,7 @@ public void distinct() {
     @RunTestInLooperThread
     public void addListener_shouldBeCalledToReturnTheQueryResults() {
         final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
         looperThread.keepStrongReference(collection);
@@ -267,7 +275,7 @@ public void onChange(Collection collection1) {
     public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
         final AtomicBoolean onChangeCalled = new AtomicBoolean(false);
         final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
         collection.addListener(collection, new RealmChangeListener<Collection>() {
@@ -335,7 +343,7 @@ public void onChange(Collection element) {
     @RunTestInLooperThread
     public void addListener_queryNotReturned() {
         final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
         looperThread.keepStrongReference(collection);
@@ -356,7 +364,7 @@ public void onChange(Collection collection1) {
     @RunTestInLooperThread
     public void addListener_queryReturned() {
         final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
         looperThread.keepStrongReference(collection);
@@ -380,7 +388,7 @@ public void onChange(Collection collection1) {
     @RunTestInLooperThread
     public void addListener_triggeredByLocalCommit() {
         final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
         final AtomicInteger listenerCounter = new AtomicInteger(0);
 
         final Collection collection = new Collection(sharedRealm, table.where());
@@ -461,7 +469,7 @@ public void collectionIterator_invalid_nonLooperThread_byRefresh() {
     @RunTestInLooperThread
     public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
         final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
+        Table table = getTable(sharedRealm);
         final Collection collection = new Collection(sharedRealm, table.where());
         final TestIterator iterator = new TestIterator(collection);
         looperThread.keepStrongReference(collection);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
deleted file mode 100644
index fdfaa4cdf9..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmFieldType;
-import io.realm.TestHelper;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static org.junit.Assert.assertEquals;
-
-
-@RunWith(AndroidJUnit4.class)
-public class JNISortedLongTest {
-
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-
-    @SuppressWarnings("FieldCanBeLocal")
-    private RealmConfiguration config;
-    private SharedRealm sharedRealm;
-    private Table table;
-
-    @Before
-    public void setUp() throws Exception {
-        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        config = configFactory.createConfiguration();
-        sharedRealm = SharedRealm.getInstance(config);
-    }
-
-    @After
-    public void tearDown() {
-        if (sharedRealm != null && !sharedRealm.isClosed()) {
-            sharedRealm.close();
-        }
-    }
-
-    private void init() {
-        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
-            @Override
-            public void execute(Table table) {
-                table.addColumn(RealmFieldType.INTEGER, "number");
-                table.addColumn(RealmFieldType.STRING, "name");
-
-                TestHelper.addRowWithValues(table, 1, "A");
-                TestHelper.addRowWithValues(table, 10, "B");
-                TestHelper.addRowWithValues(table, 20, "C");
-                TestHelper.addRowWithValues(table, 30, "B");
-                TestHelper.addRowWithValues(table, 40, "D");
-                TestHelper.addRowWithValues(table, 50, "D");
-                TestHelper.addRowWithValues(table, 60, "D");
-                TestHelper.addRowWithValues(table, 60, "D");
-            }
-        });
-
-        assertEquals(8, table.size());
-    }
-
-    @Test
-    public void shouldTestSortedIntTable() {
-        init();
-
-        // Before first entry.
-        assertEquals(0, table.lowerBoundLong(0, 0));
-        assertEquals(0, table.upperBoundLong(0, 0));
-
-        // Finds middle match.
-        assertEquals(4, table.lowerBoundLong(0, 40));
-        assertEquals(5, table.upperBoundLong(0, 40));
-
-        // Finds middle (nonexisting).
-        assertEquals(5, table.lowerBoundLong(0, 41));
-        assertEquals(5, table.upperBoundLong(0, 41));
-
-        // Beyond last entry.
-        assertEquals(8, table.lowerBoundLong(0, 100));
-        assertEquals(8, table.upperBoundLong(0, 100));
-
-        // Finds last match (duplicated).
-        assertEquals(6, table.lowerBoundLong(0, 60));
-        assertEquals(8, table.upperBoundLong(0, 60));
-
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index b63e45dd41..7614175792 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -73,20 +73,22 @@ public void tearDown() {
     private Table getTableWithStringPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
+        OsObjectStore.setSchemaVersion(sharedRealm,0); // Create meta table
         Table t = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = t.addColumn(RealmFieldType.STRING, "colName", true);
         t.addSearchIndex(column);
-        t.setPrimaryKey("colName");
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable", "colName");
         return t;
     }
 
     private Table getTableWithIntegerPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
+        OsObjectStore.setSchemaVersion(sharedRealm,0); // Create meta table
         Table t = sharedRealm.createTable(Table.getTableNameForClass("class_TestTable"));
         long column = t.addColumn(RealmFieldType.INTEGER, "colName");
         t.addSearchIndex(column);
-        t.setPrimaryKey("colName");
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable", "colName");
         return t;
     }
 
@@ -101,7 +103,6 @@ private Table getTableWithIntegerPrimaryKey() {
      *    RealmPrimaryKeyConstraintException anyway. Unclear why.
      */
     @Test
-    @Ignore("See https://github.com/realm/realm-java/issues/5231")
     public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .name("removeConstraints").build();
@@ -182,8 +183,7 @@ public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
         assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
         sharedRealm.commitTransaction();
         Table t = sharedRealm.getTable("class_AnnotationTypes");
-        assertTrue(t.hasPrimaryKey());
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals("id", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "AnnotationTypes"));
         assertEquals(RealmFieldType.STRING, sharedRealm.getTable("pk").getColumnType(0));
     }
 
@@ -195,8 +195,7 @@ public void migratePrimaryKeyTableIfNeeded_second() throws IOException {
         assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
         sharedRealm.commitTransaction();
         Table t = sharedRealm.getTable("class_AnnotationTypes");
-        assertTrue(t.hasPrimaryKey());
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals("id", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "AnnotationTypes"));
         assertEquals("AnnotationTypes", sharedRealm.getTable("pk").getString(0, 0));
     }
 
@@ -232,13 +231,14 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName(
     public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
+        OsObjectStore.setSchemaVersion(sharedRealm,0); // Create meta table
         Table table = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = table.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table.addSearchIndex(column);
-        table.setPrimaryKey(column);
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable", "PKColumn");
         sharedRealm.commitTransaction();
 
-        assertEquals(table.getPrimaryKey(), table.getColumnIndex("PKColumn"));
+        assertEquals("PKColumn", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "TestTable"));
         // Now we have a pk table with search index.
 
         sharedRealm.beginTransaction();
@@ -251,7 +251,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table2.addSearchIndex(column2);
         try {
-            table2.setPrimaryKey(column2);
+            OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable2", "PKColumn");
         } catch (IllegalStateException ignored) {
             // Column has no search index.
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index 42ba2a3110..98ff45c0df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -107,34 +107,6 @@ public void isInTransaction_returnFalseWhenRealmClosed() {
         sharedRealm = null;
     }
 
-    @Test
-    public void removeTable() {
-        sharedRealm.beginTransaction();
-        sharedRealm.createTable("TableToRemove");
-        assertTrue(sharedRealm.hasTable("TableToRemove"));
-        sharedRealm.removeTable("TableToRemove");
-        assertFalse(sharedRealm.hasTable("TableToRemove"));
-        sharedRealm.commitTransaction();
-    }
-
-    @Test
-    public void removeTable_notInTransactionThrows() {
-        sharedRealm.beginTransaction();
-        sharedRealm.createTable("TableToRemove");
-        sharedRealm.commitTransaction();
-        thrown.expect(IllegalStateException.class);
-        sharedRealm.removeTable("TableToRemove");
-    }
-
-    @Test
-    public void removeTable_tableNotExist() {
-        sharedRealm.beginTransaction();
-        assertFalse(sharedRealm.hasTable("TableToRemove"));
-        thrown.expect(RealmError.class);
-        sharedRealm.removeTable("TableToRemove");
-        sharedRealm.cancelTransaction();
-    }
-
     @Test
     public void renameTable() {
         sharedRealm.beginTransaction();
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index a178189e22..f866cd1c9b 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -32,6 +32,7 @@
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsObjectStore;
 import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 3cd5a1280d..5948d3b29d 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -44,6 +44,7 @@ set(classes_LIST
     io.realm.internal.OsObjectSchemaInfo io.realm.internal.Collection
     io.realm.internal.NativeObjectReference io.realm.internal.OsCollectionChangeSet
     io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
+    io.realm.internal.OsObjectStore
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
index a07c5415f4..4b864a0b6f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
@@ -109,3 +109,19 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetPrope
     CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetPrimaryKeyProperty(JNIEnv* env, jclass,
+                                                                                              jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        auto* property = object_schema.primary_key_property();
+        if (property) {
+            return reinterpret_cast<jlong>(new Property(*property));
+        }
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
new file mode 100644
index 0000000000..f63b7f937d
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsObjectStore.h"
+
+#include <object_store.hpp>
+#include <shared_realm.hpp>
+
+#include "util.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::util;
+using namespace realm::_impl;
+
+// FIXME: Enable after https://github.com/realm/realm-object-store/pull/550 merged
+//static_assert(io_realm_internal_OsObjectStore_SCHEMA_NOT_VERSIONED == static_cast<jlong>(ObjectStore::NotVersioned),
+//              "");
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectStore_nativeSetPrimaryKeyForObject(JNIEnv* env, jclass,
+                                                                                          jlong shared_realm_ptr,
+                                                                                          jstring j_class_name,
+                                                                                          jstring j_pk_field_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name_accessor(env, j_class_name);
+        JStringAccessor pk_field_name_accessor(env, j_pk_field_name);
+
+        auto table = ObjectStore::table_for_object_type(shared_realm->read_group(), class_name_accessor);
+        if (!table) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format("Class '%1' doesn't exist.", StringData(class_name_accessor)));
+        }
+
+        if (j_pk_field_name) {
+            // Not removal, check the column.
+            auto pk_column_ndx = table->get_column_index(pk_field_name_accessor);
+            if (pk_column_ndx == realm::npos) {
+                THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                     format("Field '%1' doesn't exist in Class '%2'.",
+                                            StringData(pk_field_name_accessor), StringData(class_name_accessor)));
+            }
+
+            // Check valid column type
+            auto field_type = table->get_column_type(pk_column_ndx);
+            if (field_type != type_Int && field_type != type_String) {
+                THROW_JAVA_EXCEPTION(
+                    env, JavaExceptionDef::IllegalArgument,
+                    format("Field '%1' is not a valid primary key type.", StringData(pk_field_name_accessor)));
+            }
+
+            // Check duplicated values. The pk field must have been indexed before set as a PK.
+            if (table->get_distinct_view(pk_column_ndx).size() != table->size()) {
+                THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                     format("Field '%1' cannot be set as primary key since there are duplicated "
+                                            "values for field '%1' in Class '%2'.",
+                                            StringData(pk_field_name_accessor), StringData(class_name_accessor)));
+            }
+        }
+        shared_realm->verify_in_write();
+        ObjectStore::set_primary_key_for_object(shared_realm->read_group(), class_name_accessor,
+                                                pk_field_name_accessor);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectStore_nativeGetPrimaryKeyForObject(JNIEnv* env, jclass,
+                                                                                             jlong shared_realm_ptr,
+                                                                                             jstring j_class_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name_accessor(env, j_class_name);
+        StringData pk_field_name =
+            ObjectStore::get_primary_key_for_object(shared_realm->read_group(), class_name_accessor);
+        return pk_field_name.size() == 0 ? nullptr : to_jstring(env, pk_field_name);
+    }
+    CATCH_STD()
+    return nullptr;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectStore_nativeSetSchemaVersion(JNIEnv* env, jclass,
+                                                                                   jlong shared_realm_ptr,
+                                                                                   jlong schema_version)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->verify_in_write();
+        ObjectStore::set_schema_version(shared_realm->read_group(), schema_version);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectStore_nativeGetSchemaVersion(JNIEnv* env, jclass,
+                                                                                    jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        return ObjectStore::get_schema_version(shared_realm->read_group());
+    }
+    CATCH_STD()
+    return ObjectStore::NotVersioned;
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsObjectStore_nativeDeleteTableForObject(JNIEnv* env, jclass,
+                                                                                        jlong shared_realm_ptr,
+                                                                                        jstring j_class_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name_accessor(env, j_class_name);
+        shared_realm->verify_in_write();
+        if (!ObjectStore::table_for_object_type(shared_realm->read_group(), class_name_accessor)) {
+            return JNI_FALSE;
+        }
+        ObjectStore::delete_data_for_object(shared_realm->read_group(), class_name_accessor);
+        return JNI_TRUE;
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 37babfa46e..7cf19d9600 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -172,38 +172,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEn
     return static_cast<jlong>(NULL);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv* env, jclass,
-                                                                            jlong shared_realm_ptr)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
-    }
-    CATCH_STD()
-    return static_cast<jlong>(ObjectStore::NotVersioned);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv* env, jclass,
-                                                                           jlong shared_realm_ptr, jlong version)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        if (!shared_realm->is_in_transaction()) {
-            std::ostringstream ss;
-            ss << "Cannot set schema version when the realm is not in transaction.";
-            ThrowException(env, IllegalState, ss.str());
-            return;
-        }
-
-        ObjectStore::set_schema_version(shared_realm->read_group(), static_cast<uint64_t>(version));
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv* env, jclass,
                                                                             jlong shared_realm_ptr)
 {
@@ -291,8 +259,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTable(JNIEnv* env, jclass,
                                                                              jlong shared_realm_ptr,
-                                                                             jstring j_table_name,
-                                                                             jboolean is_pk_table)
+                                                                             jstring j_table_name)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -303,24 +270,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTable(JNI
         shared_realm->verify_in_write(); // throws
         Table* table;
         auto& group = shared_realm->read_group();
-        if (is_pk_table) {
-            // sync::create_table() will add an extra column for stable ID which is not allowed for pk table.
-            table = LangBindHelper::add_table(group, table_name); // throws
-        }
-        else {
 #if REALM_ENABLE_SYNC
-            // Sync doesn't throw when table exists.
-            if (group.has_table(table_name)) {
-                THROW_JAVA_EXCEPTION(
-                    env, JavaExceptionDef::IllegalArgument,
-                    format(c_table_name_exists_exception_msg, table_name.substr(TABLE_PREFIX.length())));
-            }
-            auto table_ref = sync::create_table(group, table_name); // throws
-            table = LangBindHelper::get_table(group, table_ref->get_index_in_group());
+        // Sync doesn't throw when table exists.
+        if (group.has_table(table_name)) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format(c_table_name_exists_exception_msg, table_name.substr(TABLE_PREFIX.length())));
+        }
+        auto table_ref = sync::create_table(group, table_name); // throws
+        table = LangBindHelper::get_table(group, table_ref->get_index_in_group());
 #else
-            table = LangBindHelper::add_table(group, table_name); // throws
+        table = LangBindHelper::add_table(group, table_name); // throws
 #endif
-        }
         return reinterpret_cast<jlong>(table);
     }
     catch (TableNameInUse& e) {
@@ -426,26 +386,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIE
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv* env, jclass,
-                                                                            jlong shared_realm_ptr,
-                                                                            jstring table_name)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        JStringAccessor name(env, table_name);
-        if (!shared_realm->is_in_transaction()) {
-            std::ostringstream ss;
-            ss << "Class " << name << " cannot be removed when the realm is not in transaction.";
-            ThrowException(env, IllegalState, ss.str());
-            return;
-        }
-        shared_realm->read_group().remove_table(name);
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 51fb04384d..a0f0e96fe4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -37,6 +37,9 @@ static_assert(io_realm_internal_Table_MAX_BINARY_SIZE == Table::max_binary_size,
 
 static const char* c_null_values_cannot_set_required_msg = "The primary key field '%1' has 'null' values stored.  It "
                                                            "cannot be converted to a '@Required' primary key field.";
+static const size_t CLASS_COLUMN_INDEX = 0; // ObjectStore::c_primaryKeyObjectClassColumnIndex
+static const size_t FIELD_COLUMN_INDEX = 1; // ObjectStore::c_primaryKeyPropertyNameColumnIndex
+
 
 static void finalize_table(jlong ptr);
 
@@ -691,19 +694,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeIncrementLong(JNIEnv*
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                        jlong columnIndex, jlong rowIndex,
-                                                                        jlong value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int)) {
-        return;
-    }
-    try {
-        TBL(nativeTablePtr)->set_int_unique(S(columnIndex), S(rowIndex), value);
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(JNIEnv* env, jclass, jlong nativeTablePtr,
                                                                      jlong columnIndex, jlong rowIndex,
                                                                      jboolean value, jboolean isDefault)
@@ -762,28 +752,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(JNIEnv* env,
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                          jlong columnIndex, jlong rowIndex,
-                                                                          jstring value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String)) {
-        return;
-    }
-    try {
-        if (value == nullptr) {
-            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
-                return;
-            }
-            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), null{});
-        }
-        else {
-            JStringAccessor value2(env, value); // throws
-            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
-        }
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(JNIEnv* env, jclass, jlong nativeTablePtr,
                                                                        jlong columnIndex, jlong rowIndex,
                                                                        jlong timestampValue, jboolean isDefault)
@@ -850,27 +818,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(JNIEnv* env, j
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNullUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                        jlong columnIndex, jlong rowIndex)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
-        return;
-    }
-    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex)) {
-        return;
-    }
-    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex)) {
-        return;
-    }
-
-    try {
-        pTable->set_null_unique(S(columnIndex), S(rowIndex));
-    }
-    CATCH_STD()
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                      jlong index)
 {
@@ -1128,117 +1075,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(JNIEnv*
 
 // FindAll
 
-
-// FIXME: reenable when find_first_timestamp() is implemented
-/*
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
-        return 0;
-    try {
-        TableView* pTableView = new TableView(TBL(nativeTablePtr)->find_all_timestamp(S(columnIndex),
-from_milliseconds(dateTimeValue)));
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
-    return 0;
-}
-*/
-
-
-// experimental
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLowerBoundInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                         jlong columnIndex, jlong value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-
-    Table* pTable = TBL(nativeTablePtr);
-    try {
-        return static_cast<jlong>(pTable->lower_bound_int(S(columnIndex), S(value)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-// experimental
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                         jlong columnIndex, jlong value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-
-    Table* pTable = TBL(nativeTablePtr);
-    try {
-        return static_cast<jlong>(pTable->upper_bound_int(S(columnIndex), S(value)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
 //
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(JNIEnv* env, jobject,
-                                                                              jlong nativeTablePtr,
-                                                                              jlongArray columnIndices,
-                                                                              jbooleanArray ascending)
-{
-    Table* pTable = TBL(nativeTablePtr);
-
-    JLongArrayAccessor long_arr(env, columnIndices);
-    JBooleanArrayAccessor bool_arr(env, ascending);
-    jsize arr_len = long_arr.size();
-    jsize asc_len = bool_arr.size();
-
-    if (arr_len == 0) {
-        ThrowException(env, IllegalArgument, "You must provide at least one field name.");
-        return 0;
-    }
-    if (asc_len == 0) {
-        ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
-        return 0;
-    }
-    if (arr_len != asc_len) {
-        ThrowException(env, IllegalArgument, "Number of column indices and sort orders do not match.");
-        return 0;
-    }
-
-    std::vector<std::vector<size_t>> indices(S(arr_len));
-    std::vector<bool> ascendings(S(arr_len));
-
-    for (int i = 0; i < arr_len; ++i) {
-        if (!TBL_AND_COL_INDEX_VALID(env, pTable, S(long_arr[i]))) {
-            return 0;
-        }
-        int colType = pTable->get_column_type(S(long_arr[i]));
-        switch (colType) {
-            case type_Int:
-            case type_Bool:
-            case type_String:
-            case type_Double:
-            case type_Float:
-            case type_Timestamp:
-                indices[i] = std::vector<size_t>{S(long_arr[i])};
-                ascendings[i] = S(bool_arr[i]);
-                break;
-            default:
-                ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, "
-                                                     "int, long and their boxed variants.");
-                return 0;
-        }
-    }
-
-    try {
-        TableView* pTableView = new TableView(pTable->get_sorted_view(SortDescriptor(*pTable, indices, ascendings)));
-        return reinterpret_cast<jlong>(pTableView);
-    }
-    CATCH_STD()
-    return 0;
-}
-
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
     try {
@@ -1252,143 +1090,12 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(JNIEnv* env
     return nullptr;
 }
 
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table)) {
-        return nullptr;
-    }
-
-    // Write table to string in JSON format
-    try {
-        ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        table->to_json(ss);
-        const string str = ss.str();
-        return to_jstring(env, str);
-    }
-    CATCH_STD()
-    return nullptr;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(JNIEnv*, jobject, jlong nativeTablePtr)
 {
     TR_ENTER_PTR(nativeTablePtr)
     return to_jbool(TBL(nativeTablePtr)->is_attached()); // noexcept
 }
 
-// Checks if the primary key column contains any duplicate values, making it ineligible as a
-// primary key.
-static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
-{
-    size_t column_index = table->get_column_index(column_name);
-    if (column_index == realm::not_found) {
-        std::ostringstream error_msg;
-        error_msg << table->get_name() << " does not contain the field \"" << column_name << "\"";
-        ThrowException(env, IllegalArgument, error_msg.str());
-    }
-    DataType column_type = table->get_column_type(column_index);
-    TableView results = table->get_sorted_view(column_index);
-
-    switch (column_type) {
-        case type_Int:
-            if (results.size() > 1) {
-                int64_t val = results.get_int(column_index, 0);
-                for (size_t i = 1; i < results.size(); i++) {
-                    int64_t next_val = results.get_int(column_index, i);
-                    if (val == next_val) {
-                        std::ostringstream error_msg;
-                        error_msg << "Field \"" << column_name << "\" cannot be a primary key, ";
-                        error_msg << "it already contains duplicate values: " << val;
-                        ThrowException(env, IllegalArgument, error_msg.str());
-                        return false;
-                    }
-                    else {
-                        val = next_val;
-                    }
-                }
-            }
-            return true;
-
-        case type_String:
-            if (results.size() > 1) {
-                string str = results.get_string(column_index, 0);
-                for (size_t i = 1; i < results.size(); i++) {
-                    string next_str = results.get_string(column_index, i);
-                    if (str.compare(next_str) == 0) {
-                        std::ostringstream error_msg;
-                        error_msg << "Field \"" << column_name << "\" cannot be a primary key, ";
-                        error_msg << "it already contains duplicate values: " << str;
-                        ThrowException(env, IllegalArgument, error_msg.str());
-                        return false;
-                    }
-                    else {
-                        str = next_str;
-                    }
-                }
-            }
-            return true;
-
-        default:
-            std::ostringstream error_msg;
-            error_msg << "Invalid primary key type for column: " << column_name;
-            ThrowException(env, IllegalArgument, error_msg.str());
-            return false;
-    }
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(JNIEnv* env, jobject,
-                                                                         jlong nativePrivateKeyTablePtr,
-                                                                         jlong nativeTablePtr, jstring columnName)
-{
-    try {
-        Table* table = TBL(nativeTablePtr);
-        Table* pk_table = TBL(nativePrivateKeyTablePtr);
-        const std::string table_name(table->get_name().substr(TABLE_PREFIX.length())); // Remove "class_" prefix
-        size_t row_index =
-            pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
-
-        if (columnName == NULL || env->GetStringLength(columnName) == 0) {
-            // No primary key provided => remove previous set keys
-            if (row_index != realm::not_found) {
-                pk_table->remove(row_index);
-            }
-            return io_realm_internal_Table_NO_PRIMARY_KEY;
-        }
-        else {
-            JStringAccessor new_primary_key_column_name(env, columnName);
-            size_t primary_key_column_index = table->get_column_index(new_primary_key_column_name);
-            if (row_index == realm::not_found) {
-                // No primary key is currently set
-                if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
-                    row_index = pk_table->add_empty_row();
-                    pk_table->set_string_unique(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index,
-                                                table_name);
-                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index,
-                                         new_primary_key_column_name);
-                }
-            }
-            else {
-                // Primary key already exists
-                // We only wish to check for duplicate values if a column isn't already a primary key
-                StringData current_primary_key =
-                    pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index);
-                if (new_primary_key_column_name != current_primary_key) {
-                    if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
-                        pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index,
-                                             new_primary_key_column_name);
-                    }
-                }
-            }
-
-            return static_cast<jlong>(primary_key_column_index);
-        }
-    }
-    CATCH_STD()
-    return 0;
-}
-
 // 1) Fixes interop issue with Cocoa Realm where the Primary Key table had different types.
 // This affects:
 // - All Realms created by Cocoa and used by Realm-android up to 0.80.1
@@ -1411,9 +1118,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(JNIEnv*
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded(
     JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
 {
-    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
-    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
-
     auto group = reinterpret_cast<Group*>(groupNativePtr);
     Table* pk_table = TBL(privateKeyTableNativePtr);
     jboolean changed = JNI_FALSE;
@@ -1464,10 +1168,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
 JNIEXPORT jboolean JNICALL
 Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv*, jclass, jlong primaryKeyTableNativePtr)
 {
-
-    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
-    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
-
     Table* pk_table = TBL(primaryKeyTableNativePtr);
 
     // Fix wrong types (string, int) -> (string, string)
@@ -1496,23 +1196,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema(JNIE
     return to_jbool(*TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor());
 }
 
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    bool valid = (TBL(nativeTablePtr) != nullptr);
-    if (valid) {
-        if (!TBL(nativeTablePtr)->is_attached()) {
-            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
-            return 0;
-        }
-    }
-    try {
-        return static_cast<jlong>(TBL(nativeTablePtr)->get_version_counter());
-    }
-    CATCH_STD()
-    return 0;
-}
-
 static void finalize_table(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index cd819a8608..6ba0f39a8b 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -35,6 +35,7 @@
 import io.realm.internal.CheckedRow;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.OsRealmConfig;
 import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmProxyMediator;
@@ -75,7 +76,7 @@
     // Which RealmCache is this Realm associated to. It is null if the Realm instance is opened without being put into a
     // cache. It is also null if the Realm is closed.
     private RealmCache realmCache;
-    protected SharedRealm sharedRealm;
+    public SharedRealm sharedRealm;
     private boolean shouldCloseSharedRealm;
     private SharedRealm.SchemaChangedCallback schemaChangedCallback = new SharedRealm.SchemaChangedCallback() {
         @Override
@@ -476,7 +477,7 @@ public RealmConfiguration getConfiguration() {
      * @return the schema version for the Realm file backing this Realm.
      */
     public long getVersion() {
-        return sharedRealm.getSchemaVersion();
+        return OsObjectStore.getSchemaVersion(sharedRealm);
     }
 
     /**
@@ -535,11 +536,6 @@ public boolean isEmpty() {
         return sharedRealm.isEmpty();
     }
 
-    // package protected so unit tests can access it
-    void setVersion(long version) {
-        sharedRealm.setSchemaVersion(version);
-    }
-
     /**
      * Returns the schema for this Realm.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 1dec0499b0..ec14a7169e 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -23,6 +23,7 @@
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.log.RealmLog;
@@ -51,8 +52,28 @@
 
     private final RealmSchema schema;
 
-    private DynamicRealm(RealmCache cache) {
+    private DynamicRealm(final RealmCache cache) {
         super(cache, null);
+        RealmCache.invokeWithGlobalRefCount(cache.getConfiguration(), new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                if (count > 0)  {
+                    return;
+                }
+                if (cache.getConfiguration().isReadOnly()) {
+                    return;
+                }
+                if (OsObjectStore.getSchemaVersion(sharedRealm) != OsObjectStore.SCHEMA_NOT_VERSIONED) {
+                    return;
+                }
+                sharedRealm.beginTransaction();
+                if (OsObjectStore.getSchemaVersion(sharedRealm) == OsObjectStore.SCHEMA_NOT_VERSIONED) {
+                    // To initialize the meta table.
+                    OsObjectStore.setSchemaVersion(sharedRealm, OsObjectStore.SCHEMA_NOT_VERSIONED);
+                }
+                sharedRealm.commitTransaction();
+            }
+        });
         this.schema = new MutableRealmSchema(this);
     }
 
@@ -111,11 +132,12 @@ public static RealmAsyncTask getInstanceAsync(RealmConfiguration configuration,
     public DynamicRealmObject createObject(String className) {
         checkIfValid();
         Table table = schema.getTable(className);
+        String pkField = OsObjectStore.getPrimaryKeyForObject(sharedRealm, className);
         // Check and throw the exception earlier for a better exception message.
-        if (table.hasPrimaryKey()) {
+        if (pkField != null) {
             throw new RealmException(String.format(Locale.US,
-                    "'%s' has a primary key, use" +
-                    " 'createObject(String, Object)' instead.", className));
+                    "'%s' has a primary key field '%s', use  'createObject(String, Object)' instead.",
+                    className, pkField));
         }
 
         return new DynamicRealmObject(this, CheckedRow.getFromRow(OsObject.create(table)));
@@ -274,6 +296,19 @@ public RealmSchema getSchema() {
         return schema;
     }
 
+    /**
+     * Set the schema version of this dynamic realm to the given version number. If the meta table doesn't exist, this
+     * will create the meta table first.
+     * <p>
+     * NOTE: This API is for internal testing only. Except testing, the schema version should always be set by the
+     * Object Store during schema initialization or migration.
+     *
+     * @param version the schema version to be set.
+     */
+    void setVersion(long version) {
+        OsObjectStore.setSchemaVersion(sharedRealm, version);
+    }
+
     /**
      * Encapsulates a Realm transaction.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
index 8514eef8cd..2281c0ff8a 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
@@ -18,8 +18,10 @@
 
 import java.util.Locale;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 
 /**
@@ -52,18 +54,17 @@ public RealmObjectSchema setClassName(String className) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
         // in case this table has a primary key, we need to transfer it after renaming the table.
-        String oldTableName = null;
-        String pkField = null;
-        if (table.hasPrimaryKey()) {
-            oldTableName = table.getName();
-            pkField = getPrimaryKey();
-            table.setPrimaryKey(null);
-        }
         //noinspection ConstantConditions
-        realm.sharedRealm.renameTable(table.getName(), internalTableName);
-        if (pkField != null && !pkField.isEmpty()) {
+        @Nonnull String oldTableName = table.getName();
+        @Nonnull String oldClassName = table.getClassName();
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, oldClassName);
+        if (pkField != null) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, oldClassName, null);
+        }
+        realm.sharedRealm.renameTable(oldTableName, internalTableName);
+        if (pkField != null) {
             try {
-                table.setPrimaryKey(pkField);
+                OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, className, pkField);
             } catch (Exception e) {
                 // revert the table name back when something goes wrong
                 //noinspection ConstantConditions
@@ -139,8 +140,9 @@ public RealmObjectSchema removeField(String fieldName) {
             throw new IllegalStateException(fieldName + " does not exist.");
         }
         long columnIndex = getColumnIndex(fieldName);
-        if (table.getPrimaryKey() == columnIndex) {
-            table.setPrimaryKey(null);
+        String className = getClassName();
+        if (fieldName.equals(OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, className))) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, className, fieldName);
         }
         table.removeColumn(columnIndex);
         return this;
@@ -191,29 +193,33 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
         checkAddPrimaryKeyForSync();
         checkLegalName(fieldName);
         checkFieldExists(fieldName);
-        if (table.hasPrimaryKey()) {
-            throw new IllegalStateException("A primary key is already defined");
+        String currentPKField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName());
+        if (currentPKField != null) {
+            throw new IllegalStateException(
+                    String.format(Locale.ENGLISH, "Field '%s' has been already defined as primary key.",
+                            currentPKField));
         }
-        table.setPrimaryKey(fieldName);
         long columnIndex = getColumnIndex(fieldName);
         if (!table.hasSearchIndex(columnIndex)) {
             // No exception will be thrown since adding PrimaryKey implies the column has an index.
             table.addSearchIndex(columnIndex);
         }
+        OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, getClassName(), fieldName);
         return this;
     }
 
     @Override
     public RealmObjectSchema removePrimaryKey() {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
-        if (!table.hasPrimaryKey()) {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName());
+        if (pkField == null) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
-        long columnIndex = table.getPrimaryKey();
+        long columnIndex = table.getColumnIndex(pkField);
         if (table.hasSearchIndex(columnIndex)) {
             table.removeSearchIndex(columnIndex);
         }
-        table.setPrimaryKey("");
+        OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, getClassName(), null);
         return this;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
index a661b255bf..8d36769f95 100644
--- a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
@@ -18,6 +18,7 @@
 
 import java.util.Locale;
 
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 
 /**
@@ -85,12 +86,9 @@ public void remove(String className) {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkNotEmpty(className, EMPTY_STRING_MSG);
         String internalTableName = Table.getTableNameForClass(className);
-        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
-        Table table = getTable(className);
-        if (table.hasPrimaryKey()) {
-            table.setPrimaryKey(null);
+        if (!OsObjectStore.deleteTableForObject(realm.getSharedRealm(), className)) {
+            throw new IllegalArgumentException("Cannot remove class because it is not in this Realm: " + className);
         }
-        realm.getSharedRealm().removeTable(internalTableName);
         removeFromClassNameToSchemaMap(internalTableName);
     }
 
@@ -107,11 +105,9 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
         }
 
         // Checks if there is a primary key defined for the old class.
-        Table oldTable = getTable(oldClassName);
-        String pkField = null;
-        if (oldTable.hasPrimaryKey()) {
-            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
-            oldTable.setPrimaryKey(null);
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, oldClassName);
+        if (pkField != null) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, oldClassName, null);
         }
 
         realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
@@ -119,7 +115,7 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
 
         // Sets the primary key for the new class if necessary.
         if (pkField != null) {
-            table.setPrimaryKey(pkField);
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, newClassName, pkField);
         }
 
         RealmObjectSchema objectSchema = removeFromClassNameToSchemaMap(oldInternalName);
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index bd85dd7bb3..f95bb86647 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -55,6 +55,8 @@
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmNotifier;
@@ -765,8 +767,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
         }
         checkIfValid();
         E realmObject;
-        Table table = schema.getTable(clazz);
-        if (table.hasPrimaryKey()) {
+
+        if (OsObjectStore.getPrimaryKeyForObject(
+                sharedRealm, configuration.getSchemaMediator().getSimpleClassName(clazz)) != null) {
             // As we need the primary key value we have to first parse the entire input stream as in the general
             // case that value might be the last property. :(
             Scanner scanner = null;
@@ -873,7 +876,8 @@ private Scanner getFullStringScanner(InputStream in) {
             List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         // Checks and throws the exception earlier for a better exception message.
-        if (table.hasPrimaryKey()) {
+        if (OsObjectStore.getPrimaryKeyForObject(
+                sharedRealm, configuration.getSchemaMediator().getSimpleClassName(clazz)) != null) {
             throw new RealmException(String.format(Locale.US, "'%s' has a primary key, use" +
                     " 'createObject(Class<E>, Object)' instead.", table.getClassName()));
         }
@@ -1560,7 +1564,10 @@ public void delete(Class<? extends RealmModel> clazz) {
     }
 
     private void checkHasPrimaryKey(Class<? extends RealmModel> clazz) {
-        if (!schema.getTable(clazz).hasPrimaryKey()) {
+        String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
+        OsObjectSchemaInfo objectSchemaInfo = sharedRealm.getSchemaInfo().getObjectSchemaInfo(className);
+
+        if (objectSchemaInfo.getPrimaryKeyProperty() == null) {
             throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 9eaf1645e6..78499e64b5 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -35,6 +35,7 @@
 
 import io.realm.internal.InvalidRow;
 import io.realm.internal.OsList;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.rx.CollectionChange;
 
@@ -291,7 +292,8 @@ private E copyToRealmIfNeeded(E object) {
 
         // At this point the object can only be a typed object, so the backing Realm cannot be a DynamicRealm.
         Realm realm = (Realm) this.realm;
-        if (realm.getTable(object.getClass()).hasPrimaryKey()) {
+        if (OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(),
+                realm.getConfiguration().getSchemaMediator().getSimpleClassName(object.getClass())) != null) {
             return realm.copyToRealmOrUpdate(object);
         } else {
             return realm.copyToRealm(object);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 6de1183104..2b6162e6aa 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -605,16 +605,6 @@ public final void removeChangeListener(RealmChangeListener listener) {
         removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<>(listener));
     }
 
-    /**
-     * Removes all registered listeners.
-     *
-     * @deprecated Use {@link #removeAllChangeListeners()} instead.
-     */
-    @Deprecated
-    public final void removeChangeListeners() {
-        RealmObject.removeChangeListeners(this);
-    }
-
     /**
      * Removes all registered listeners.
      */
@@ -622,18 +612,6 @@ public final void removeAllChangeListeners() {
         RealmObject.removeAllChangeListeners(this);
     }
 
-    /**
-     * Removes all registered listeners from the given RealmObject.
-     *
-     * @param object RealmObject to remove all listeners from.
-     * @throws IllegalArgumentException if object is {@code null} or isn't managed by Realm.
-     * @deprecated Use {@link RealmObject#removeAllChangeListeners(RealmModel)} instead.
-     */
-    @Deprecated
-    public static <E extends RealmModel> void removeChangeListeners(E object) {
-        removeAllChangeListeners(object);
-    }
-
     /**
      * Removes all registered listeners from the given RealmObject.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index ab91b6c740..30a584b996 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -27,6 +27,7 @@
 import io.realm.annotations.Required;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.internal.fields.FieldDescriptor;
 
@@ -94,13 +95,6 @@
         this.columnInfo = columnInfo;
     }
 
-    /**
-     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
-     */
-    @Deprecated
-    public void close() {
-    }
-
     /**
      * Returns the name of the RealmObject class being represented by this schema.
      * <p>
@@ -319,8 +313,8 @@ public boolean isNullable(String fieldName) {
      * @see #addPrimaryKey(String)
      */
     public boolean isPrimaryKey(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return columnIndex == table.getPrimaryKey();
+        checkFieldExists(fieldName);
+        return fieldName.equals(OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName()));
     }
 
     /**
@@ -330,7 +324,7 @@ public boolean isPrimaryKey(String fieldName) {
      * @see io.realm.annotations.PrimaryKey
      */
     public boolean hasPrimaryKey() {
-        return table.hasPrimaryKey();
+        return OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName()) != null;
     }
 
     /**
@@ -340,10 +334,11 @@ public boolean hasPrimaryKey() {
      * @throws IllegalStateException if the class doesn't have a primary key defined.
      */
     public String getPrimaryKey() {
-        if (!table.hasPrimaryKey()) {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName());
+        if (pkField == null) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
-        return table.getColumnName(table.getPrimaryKey());
+        return pkField;
     }
 
     /**
@@ -400,7 +395,9 @@ RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean
 
         if (indexed) { table.addSearchIndex(columnIndex); }
 
-        if (primary) { table.setPrimaryKey(name); }
+        if (primary) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, getClassName(), name);
+        }
 
         return this;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 4b61f799bb..0619784ffa 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -233,15 +233,6 @@ public void removeAllChangeListeners() {
         collection.removeAllListeners();
     }
 
-    /**
-     * Use {@link #removeAllChangeListeners()} instead.
-     */
-    @SuppressWarnings("unused")
-    @Deprecated
-    public void removeChangeListeners() {
-        removeAllChangeListeners();
-    }
-
     /**
      * Removes the specified change listener.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 74ca6fafe8..9830514072 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -64,13 +64,6 @@
         this.columnIndices = columnIndices;
     }
 
-    /**
-     * @deprecated {@link RealmSchema} doesn't have to be released manually.
-     */
-    @Deprecated
-    public void close() {
-    }
-
     /**
      * Returns the {@link RealmObjectSchema} for a given class. If this {@link RealmSchema} is immutable, an immutable
      * {@link RealmObjectSchema} will be returned. Otherwise, it returns an mutable {@link RealmObjectSchema}.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
index 651dc416be..8422bc5bfb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
@@ -174,11 +174,11 @@ public static long createRow(Table table) {
     }
 
     private static long getAndVerifyPrimaryKeyColumnIndex(Table table) {
-        long primaryKeyColumnIndex = table.getPrimaryKey();
-        if (primaryKeyColumnIndex == Table.NO_PRIMARY_KEY) {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(table.getSharedRealm(), table.getClassName());
+        if (pkField == null) {
             throw new IllegalStateException(table.getName() + " has no primary key defined.");
         }
-        return primaryKeyColumnIndex;
+        return table.getColumnIndex(pkField);
     }
 
     // TODO: consider to return a OsObject instead when integrating with Object Store's object accessor.
@@ -218,10 +218,12 @@ public static UncheckedRow createWithPrimaryKey(Table table, @Nullable Object pr
      * This is used for the fast bulk insertion.
      *
      * @param table the table where the object is created.
+     * @param primaryKeyColumnIndex the column index of primary key field.
+     * @param primaryKeyValue the primary key value.
      * @return a newly created {@code UncheckedRow}.
      */
-    public static long createRowWithPrimaryKey(Table table, Object primaryKeyValue) {
-        long primaryKeyColumnIndex = getAndVerifyPrimaryKeyColumnIndex(table);
+    // FIXME: Proxy could just pass the pk index here which is much faster.
+    public static long createRowWithPrimaryKey(Table table, long primaryKeyColumnIndex, Object primaryKeyValue) {
         RealmFieldType type = table.getColumnType(primaryKeyColumnIndex);
         final SharedRealm sharedRealm = table.getSharedRealm();
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
index 58892d9630..36c7e9aef5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -19,6 +19,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmFieldType;
 
 /**
@@ -145,6 +147,17 @@ public Property getProperty(String propertyName) {
         return new Property(nativeGetProperty(nativePtr, propertyName));
     }
 
+    /**
+     * Returns the primary key property for this {@code ObjectSchema}.
+     *
+     * @return a {@link Property} object of the primary key property, {@code null} if this {@code ObjectSchema} doesn't
+     * contains a primary key.
+     */
+    public @Nullable Property getPrimaryKeyProperty() {
+        long propertyPtr = nativeGetPrimaryKeyProperty(nativePtr);
+        return propertyPtr == 0 ? null : new Property(nativeGetPrimaryKeyProperty(nativePtr));
+    }
+
     @Override
     public long getNativePtr() {
         return nativePtr;
@@ -165,4 +178,7 @@ public long getNativeFinalizerPtr() {
 
     // Throw ISE if the property doesn't exist.
     private static native long nativeGetProperty(long nativePtr, String propertyName);
+
+    // Return nullptr if it doesn't have a primary key.
+    private static native long nativeGetPrimaryKeyProperty(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
new file mode 100644
index 0000000000..5e05a43310
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+/**
+ * Java wrapper for methods in object_store.hpp.
+ */
+public class OsObjectStore {
+
+    public final static long SCHEMA_NOT_VERSIONED = -1;
+
+    /**
+     * Sets the primary key field for the given class.
+     * <p>
+     * NOTE: The search index has to be added to the field before calling this method.
+     *
+     * @throws IllegalStateException if it is not in a transaction.
+     * @throws IllegalStateException if the given class doesn't exist.
+     * @throws IllegalStateException if the given field doesn't exist.
+     * @throws IllegalStateException if the given field is not a valid type for primary key.
+     * @throws IllegalStateException if there are duplicated values for the given field.
+     */
+    public static void setPrimaryKeyForObject(SharedRealm sharedRealm, String className,
+                                              @Nullable String primaryKeyFieldName) {
+        nativeSetPrimaryKeyForObject(sharedRealm.getNativePtr(), className, primaryKeyFieldName);
+    }
+
+    public static @Nullable String getPrimaryKeyForObject(SharedRealm sharedRealm, String className) {
+        return nativeGetPrimaryKeyForObject(sharedRealm.getNativePtr(), className);
+    }
+
+    /**
+     * Sets the schema version to the given {@link SharedRealm}. This method will create meta tables if they don't exist.
+     * @throws IllegalStateException if it is not in a transaction.
+     */
+    public static void setSchemaVersion(SharedRealm sharedRealm, long schemaVersion) {
+        nativeSetSchemaVersion(sharedRealm.getNativePtr(), schemaVersion);
+    }
+
+    /**
+     * Returns the schema version of the given {@link SharedRealm}. If meta tables don't exist, this will return
+     * {@link #SCHEMA_NOT_VERSIONED}.
+     */
+    public static long getSchemaVersion(SharedRealm sharedRealm) {
+        return nativeGetSchemaVersion(sharedRealm.getNativePtr());
+    }
+
+    /**
+     * Deletes the table with the given class name.
+     *
+     * @return {@code true} if the table has been deleted. {@code false} if the table doesn't exist.
+     * @throws IllegalStateException if it is not in a transaction.
+     */
+    public static boolean deleteTableForObject(SharedRealm sharedRealm, String className) {
+        return nativeDeleteTableForObject(sharedRealm.getNativePtr(), className);
+    }
+
+    private native static void nativeSetPrimaryKeyForObject(long sharedRealmPtr, String className,
+                                                             @Nullable String primaryKeyFieldName);
+
+    private native static @Nullable String nativeGetPrimaryKeyForObject(long sharedRealmPtr, String className);
+
+    private native static void nativeSetSchemaVersion(long sharedRealmPtr, long schemaVersion);
+
+    private native static long nativeGetSchemaVersion(long sharedRealmPtr);
+
+    private native static boolean nativeDeleteTableForObject(long sharedRealmPtr, String className);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 54777969ac..7bc1a37072 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -70,14 +70,28 @@
 
     /**
      * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated name of the
-     * class.
+     * class with the Realm table prefix.
      *
      * @param clazz the {@link RealmObject} class reference.
-     * @return the simple name of an RealmObject class (before it has been obfuscated).
+     * @return the simple name of an RealmObject class (before it has been obfuscated) with Realm table prefix.
      * @throws java.lang.NullPointerException if null is given as argument.
+     * @deprecated use {{@link #getSimpleClassName(Class)}} instead.
      */
+    @Deprecated
     public abstract String getTableName(Class<? extends RealmModel> clazz);
 
+    /**
+     * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated simple name of the
+     * class.
+     *
+     * @param clazz the {@link RealmObject} class reference.
+     * @return the simple name of an RealmObject class (before it has been obfuscated).
+     */
+    public String getSimpleClassName(Class<? extends RealmModel> clazz) {
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        return Table.getClassNameForTable(getTableName(originalClass));
+    }
+
     /**
      * Creates a new instance of an {@link RealmObjectProxy} for the given RealmObject class.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 6f4e971551..6165ce00d0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -48,9 +48,6 @@ public static void initialize(File tempDirectory) {
             // already initialized
             return;
         }
-        if (tempDirectory == null) {
-            throw new IllegalArgumentException("'tempDirectory' must not be null.");
-        }
 
         String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
         if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
@@ -246,14 +243,6 @@ public boolean isInTransaction() {
         return nativeIsInTransaction(nativePtr);
     }
 
-    public void setSchemaVersion(long schemaVersion) {
-        nativeSetVersion(nativePtr, schemaVersion);
-    }
-
-    public long getSchemaVersion() {
-        return nativeGetVersion(nativePtr);
-    }
-
     // FIXME: This should be removed, migratePrimaryKeyTableIfNeeded is using it which should be in Object Store instead?
     long getGroupNative() {
         return nativeReadGroup(nativePtr);
@@ -283,19 +272,7 @@ public Table getTable(String name) {
      * @return a created {@link Table} object.
      */
     public Table createTable(String name) {
-        return new Table(this, nativeCreateTable(nativePtr, name, false));
-    }
-
-    /**
-     * Creates a primary key table with then given name. Native assertion will happen if the table with the same name
-     * exists. This function is different from {@link #createTable(String)} which will call {@code create_table()} from
-     * sync to do the creation. This will always call the core's {@code add_table()} to avoid creating the stable id
-     * column for pk table.
-     *
-     * @return a created {@link Table} object.
-     */
-    public Table createPkTable() {
-        return new Table(this, nativeCreateTable(nativePtr, Table.PRIMARY_KEY_TABLE_NAME, true));
+        return new Table(this, nativeCreateTable(nativePtr, name));
     }
 
     /**
@@ -319,10 +296,6 @@ public void renameTable(String oldName, String newName) {
         nativeRenameTable(nativePtr, oldName, newName);
     }
 
-    public void removeTable(String name) {
-        nativeRemoveTable(nativePtr, name);
-    }
-
     public String getTableName(int index) {
         return nativeGetTableName(nativePtr, index);
     }
@@ -524,10 +497,6 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
 
     private static native boolean nativeIsInTransaction(long nativeSharedRealmPtr);
 
-    private static native long nativeGetVersion(long nativeSharedRealmPtr);
-
-    private static native void nativeSetVersion(long nativeSharedRealmPtr, long version);
-
     private static native long nativeReadGroup(long nativeSharedRealmPtr);
 
     private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
@@ -540,9 +509,7 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
     private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
 
     // Throw IAE if the table exists already.
-    // FIXME: isPkTable should be removed after integration with OS schema. All the meta tables should be handled in
-    // the Object Store.
-    private static native long nativeCreateTable(long nativeSharedRealmPtr, String tableName, boolean isPkTable);
+    private static native long nativeCreateTable(long nativeSharedRealmPtr, String tableName);
 
     // Throw IAE if the table exists already.
     // If isStringType is false, the PK field will be created as an integer PK field.
@@ -556,8 +523,6 @@ private static native long nativeCreateTableWithPrimaryKeyField(long nativeShare
 
     private static native void nativeRenameTable(long nativeSharedRealmPtr, String oldTableName, String newTableName);
 
-    private static native void nativeRemoveTable(long nativeSharedRealmPtr, String tableName);
-
     private static native long nativeSize(long nativeSharedRealmPtr);
 
     private static native void nativeWriteCopy(long nativeSharedRealmPtr, String path, @Nullable byte[] key);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 6162d8d820..cb2f9b551f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -21,7 +21,6 @@
 import javax.annotation.Nullable;
 
 import io.realm.RealmFieldType;
-import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 
 
@@ -30,7 +29,7 @@
  * (define/insert/delete/update) a table has. All the native communications to the Realm C++ library are also handled by
  * this class.
  */
-public class Table implements TableSchema, NativeObject {
+public class Table implements NativeObject {
 
     private static final String TABLE_PREFIX = Util.getTablePrefix();
     private static final int TABLE_NAME_MAX_LENGTH = 63; // Max length of table names
@@ -41,11 +40,6 @@
     public static final int NO_MATCH = -1;
 
     static final String PRIMARY_KEY_TABLE_NAME = "pk";
-    private static final String PRIMARY_KEY_CLASS_COLUMN_NAME = "pk_table";
-    private static final long PRIMARY_KEY_CLASS_COLUMN_INDEX = 0;
-    private static final String PRIMARY_KEY_FIELD_COLUMN_NAME = "pk_property";
-    private static final long PRIMARY_KEY_FIELD_COLUMN_INDEX = 1;
-    public static final long NO_PRIMARY_KEY = -2;
 
     public static final int MAX_BINARY_SIZE = 0xFFFFF8 - 8/*array header size*/;
     public static final int MAX_STRING_SIZE = 0xFFFFF8 - 8/*array header size*/ - 1;
@@ -56,7 +50,6 @@
     private final NativeContext context;
 
     private final SharedRealm sharedRealm;
-    private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
     Table(Table parent, long nativePointer) {
         this(parent.sharedRealm, nativePointer);
@@ -117,7 +110,6 @@ public long addColumn(RealmFieldType type, String name, boolean isNullable) {
      *
      * @return the index of the new column.
      */
-    @Override
     public long addColumn(RealmFieldType type, String name) {
         return addColumn(type, name, false);
     }
@@ -133,40 +125,30 @@ public long addColumnLink(RealmFieldType type, String name, Table table) {
     }
 
     /**
-     * Removes a column in the table dynamically. If {@code columnIndex} is smaller than the primary
-     * key column index, {@link #invalidateCachedPrimaryKeyIndex()} will be called to recalculate the
-     * primary key column index.
+     * Removes a column in the table dynamically.
      * <p>
-     * <p>It should be noted if {@code columnIndex} is the same as the primary key column index,
+     * It should be noted if {@code columnIndex} is the same as the primary key column index,
      * the primary key column is removed from the meta table.
      *
      * @param columnIndex the column index to be removed.
      */
-    @Override
     public void removeColumn(long columnIndex) {
+        final String className = getClassName();
         // Checks the PK column index before removing a column. We don't know if we're hitting a PK col,
         // but it should be noted that once a column is removed, there is no way we can find whether
         // a PK exists or not.
-        final long oldPkColumnIndex = getPrimaryKey();
+        final String columnName = getColumnName(columnIndex);
+        final String pkName = OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName());
 
         // First removes a column. If there is no error, we can proceed. Otherwise, it will stop here.
         nativeRemoveColumn(nativePtr, columnIndex);
 
-        // Checks if a PK exists and takes actions if there is. This is same as hasPrimaryKey(), but
-        // this relies on the local cache.
-        if (oldPkColumnIndex >= 0) {
-
+        // Checks if a PK exists and takes actions if there is.
+        if (columnName.equals(pkName)) {
             // In case we're hitting PK column, we should remove the PK as it is either 1) a user has
             // forgotten to remove PK or 2) removeColumn gets called before setPrimaryKey(null) is called.
             // Since there is no danger in removing PK twice, we'll do it here to be on safe side.
-            if (oldPkColumnIndex == columnIndex) {
-                setPrimaryKey(null);
-
-                // But if you remove a column with a smaller index than that of PK column, you need to
-                // recalculate the PK column index as core could have changed its column index.
-            } else if (oldPkColumnIndex > columnIndex) {
-                invalidateCachedPrimaryKeyIndex();
-            }
+            OsObjectStore.setPrimaryKeyForObject(sharedRealm, className, null);
         }
     }
 
@@ -177,34 +159,20 @@ public void removeColumn(long columnIndex) {
      * @param columnIndex the column index to be renamed.
      * @param newName a new name replacing the old column name.
      * @throws IllegalArgumentException if {@code newFieldName} is an empty string, or exceeds field name length limit.
-     * @throws IllegalStateException if a PrimaryKey column name could not be found in the meta table, but {@link #getPrimaryKey()} returns an index.
      */
-    @Override
     public void renameColumn(long columnIndex, String newName) {
         verifyColumnName(newName);
         // Gets the old column name. We'll assume that the old column name is *NOT* an empty string.
         final String oldName = nativeGetColumnName(nativePtr, columnIndex);
-        // Also old pk index. Once a column name changes, there is no way you can find the column name
-        // by old name.
-        final long oldPkColumnIndex = getPrimaryKey();
+        final String pkName = OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName());
 
         // Then let's try to rename a column. If an error occurs for some reasons, we'll throw.
         nativeRenameColumn(nativePtr, columnIndex, newName);
 
         // Renames a primary key. At this point, renaming the column name should have been fine.
-        if (oldPkColumnIndex == columnIndex) {
+        if (oldName.equals(pkName)) {
             try {
-                Table pkTable = getPrimaryKeyTable();
-                if (pkTable == null) {
-                    throw new IllegalStateException(
-                            "Table is not created from a SharedRealm, primary key is not available");
-                }
-                long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getClassName());
-                if (pkRowIndex != NO_MATCH) {
-                    nativeSetString(pkTable.nativePtr, PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName, false);
-                } else {
-                    throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
-                }
+                OsObjectStore.setPrimaryKeyForObject(sharedRealm, getClassName(), newName);
             } catch (Exception e) {
                 // We failed to rename the pk meta table. roll back the column name, not pk meta table
                 // then rethrow.
@@ -335,36 +303,6 @@ public void moveLastOver(long rowIndex) {
         nativeMoveLastOver(nativePtr, rowIndex);
     }
 
-    private boolean isPrimaryKeyColumn(long columnIndex) {
-        return columnIndex == getPrimaryKey();
-    }
-
-    /**
-     * Returns the column index for the primary key.
-     *
-     * @return the column index or {@code #NO_MATCH} if no primary key is set.
-     */
-    public long getPrimaryKey() {
-        if (cachedPrimaryKeyColumnIndex >= 0 || cachedPrimaryKeyColumnIndex == NO_PRIMARY_KEY) {
-            return cachedPrimaryKeyColumnIndex;
-        } else {
-            Table pkTable = getPrimaryKeyTable();
-            if (pkTable == null) {
-                return NO_PRIMARY_KEY; // Free table = No primary key.
-            }
-
-            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getClassName());
-            if (rowIndex != NO_MATCH) {
-                String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
-                cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
-            } else {
-                cachedPrimaryKeyColumnIndex = NO_PRIMARY_KEY;
-            }
-
-            return cachedPrimaryKeyColumnIndex;
-        }
-    }
-
     /**
      * Checks if a given column is a primary key column.
      *
@@ -372,53 +310,7 @@ public long getPrimaryKey() {
      * @return {@code true} if column is a primary key, {@code false} otherwise.
      */
     private boolean isPrimaryKey(long columnIndex) {
-        return columnIndex >= 0 && columnIndex == getPrimaryKey();
-    }
-
-    /**
-     * Checks if a table has a primary key.
-     *
-     * @return {@code true} if primary key is defined, {@code false} otherwise.
-     */
-    public boolean hasPrimaryKey() {
-        return getPrimaryKey() >= 0;
-    }
-
-    void checkStringValueIsLegal(long columnIndex, long rowToUpdate, String value) {
-        if (isPrimaryKey(columnIndex)) {
-            long rowIndex = findFirstString(columnIndex, value);
-            if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
-                throwDuplicatePrimaryKeyException(value);
-            }
-        }
-    }
-
-    void checkIntValueIsLegal(long columnIndex, long rowToUpdate, long value) {
-        if (isPrimaryKeyColumn(columnIndex)) {
-            long rowIndex = findFirstLong(columnIndex, value);
-            if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
-                throwDuplicatePrimaryKeyException(value);
-            }
-        }
-    }
-
-    // Checks if it is ok to use null value for given row and column.
-    void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
-        if (isPrimaryKeyColumn(columnIndex)) {
-            RealmFieldType type = getColumnType(columnIndex);
-            switch (type) {
-                case STRING:
-                case INTEGER:
-                    long rowIndex = findFirstNull(columnIndex);
-                    if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException("null");
-                    }
-                    break;
-                default:
-                    // Since it is sufficient to check the existence of duplicated null values
-                    // on PrimaryKey in supported types only, this part is left empty.
-            }
-        }
+        return getColumnName(columnIndex).equals(OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName()));
     }
 
     /**
@@ -529,7 +421,6 @@ public CheckedRow getCheckedRow(long index) {
 
     public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
-        checkIntValueIsLegal(columnIndex, rowIndex, value);
         nativeSetLong(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
@@ -567,13 +458,11 @@ public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefaul
      * @param rowIndex 0 based index value of the cell row.
      * @param value a String value to set in the cell.
      */
-    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault) {
+    public void setString(long columnIndex, long rowIndex, @Nullable String value, boolean isDefault) {
         checkImmutable();
         if (value == null) {
-            checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
             nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
         } else {
-            checkStringValueIsLegal(columnIndex, rowIndex, value);
             nativeSetString(nativePtr, columnIndex, rowIndex, value, isDefault);
         }
     }
@@ -590,7 +479,6 @@ public void setLink(long columnIndex, long rowIndex, long value, boolean isDefau
 
     public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
         checkImmutable();
-        checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
         nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
     }
 
@@ -604,54 +492,6 @@ public void removeSearchIndex(long columnIndex) {
         nativeRemoveSearchIndex(nativePtr, columnIndex);
     }
 
-    /**
-     * Defines a primary key for this table. This needs to be called manually before inserting data into the table.
-     *
-     * @param columnName the name of the field that will function primary key. "" or {@code null} will remove any
-     * previous set magic key.
-     * @throws io.realm.exceptions.RealmException if it is not possible to set the primary key due to the column
-     * not having distinct values (i.e. violating the primary key constraint).
-     */
-    public void setPrimaryKey(@Nullable String columnName) {
-        Table pkTable = getPrimaryKeyTable();
-        if (pkTable == null) {
-            throw new RealmException("Primary keys are only supported if Table is part of a Group");
-        }
-        cachedPrimaryKeyColumnIndex = nativeSetPrimaryKey(pkTable.nativePtr, nativePtr, columnName);
-    }
-
-    public void setPrimaryKey(long columnIndex) {
-        setPrimaryKey(nativeGetColumnName(nativePtr, columnIndex));
-    }
-
-    private Table getPrimaryKeyTable() {
-        if (sharedRealm == null) {
-            return null;
-        }
-
-        // FIXME: The PK table creation should be handle by Object Store after integration of OS Schema.
-        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
-            sharedRealm.createPkTable();
-        }
-
-        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
-        if (pkTable.getColumnCount() == 0) {
-            checkImmutable();
-            long columnIndex = pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
-            pkTable.addSearchIndex(columnIndex);
-            pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
-        }
-
-        return pkTable;
-    }
-
-    /**
-     * Invalidates a cached primary key column index for the table.
-     */
-    private void invalidateCachedPrimaryKeyIndex() {
-        cachedPrimaryKeyColumnIndex = NO_MATCH;
-    }
-
     /*
      * 1) Migration required to fix https://github.com/realm/realm-java/issues/1059
      * This will convert INTEGER column to the corresponding STRING column if needed.
@@ -773,15 +613,6 @@ public long findFirstNull(long columnIndex) {
         return nativeFindFirstNull(nativePtr, columnIndex);
     }
 
-    // Experimental feature
-    public long lowerBoundLong(long columnIndex, long value) {
-        return nativeLowerBoundInt(nativePtr, columnIndex, value);
-    }
-
-    public long upperBoundLong(long columnIndex, long value) {
-        return nativeUpperBoundInt(nativePtr, columnIndex, value);
-    }
-
     //
 
     /**
@@ -804,10 +635,6 @@ public String getClassName() {
         return getClassNameForTable(getName());
     }
 
-    public String toJson() {
-        return nativeToJson(nativePtr);
-    }
-
     @Override
     public String toString() {
         long columnCount = getColumnCount();
@@ -817,10 +644,6 @@ public String toString() {
             stringBuilder.append(getName());
             stringBuilder.append(" ");
         }
-        if (hasPrimaryKey()) {
-            String pkFieldName = getColumnName(getPrimaryKey());
-            stringBuilder.append("has \'").append(pkFieldName).append("\' field as a PrimaryKey, and ");
-        }
         stringBuilder.append("contains ");
         stringBuilder.append(columnCount);
         stringBuilder.append(" columns: ");
@@ -857,24 +680,6 @@ public boolean hasSameSchema(Table table) {
         return nativeHasSameSchema(this.nativePtr, table.nativePtr);
     }
 
-    /**
-     * Checks if a given table name is a name for a model table.
-     */
-    public static boolean isModelTable(String tableName) {
-        return tableName.startsWith(TABLE_PREFIX);
-    }
-
-    /**
-     * Reports the current versioning counter for the table. The versioning counter is guaranteed to
-     * change when the contents of the table changes after advance_read() or promote_to_write(), or
-     * immediately after calls to methods which change the table.
-     *
-     * @return version_counter for the table.
-     */
-    public long getVersion() {
-        return nativeVersion(nativePtr);
-    }
-
     @Nullable
     public static String getClassNameForTable(@Nullable String name) {
         if (name == null) { return null; }
@@ -925,8 +730,6 @@ public static String getTableNameForClass(String name) {
 
     private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
 
-    private native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
-
     private native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
 
     private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
@@ -951,8 +754,6 @@ public static String getTableNameForClass(String name) {
 
     public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
 
-    public static native void nativeSetLongUnique(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-
     public static native void nativeIncrementLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
 
     public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value, boolean isDefault);
@@ -965,19 +766,12 @@ public static String getTableNameForClass(String name) {
 
     public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value, boolean isDefault);
 
-    public static native void nativeSetStringUnique(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-
     public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex, boolean isDefault);
 
-    // Use nativeSetStringUnique(null) for String column!
-    public static native void nativeSetNullUnique(long nativeTablePtr, long columnIndex, long rowIndex);
-
     public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data, boolean isDefault);
 
     public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
 
-    private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, @Nullable String columnName);
-
     private static native boolean nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
 
     private static native boolean nativePrimaryKeyTableNeedsMigration(long primaryKeyTableNativePtr);
@@ -1016,19 +810,9 @@ public static String getTableNameForClass(String name) {
 
     public static native long nativeFindFirstNull(long nativeTablePtr, long columnIndex);
 
-    // FIXME: Disabled in cpp code, see comments there
-    // private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
-    private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
-
-    private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
-
     private native String nativeGetName(long nativeTablePtr);
 
-    private native String nativeToJson(long nativeTablePtr);
-
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
 
-    private native long nativeVersion(long nativeTablePtr);
-
     private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
deleted file mode 100644
index 47200f336d..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-
-import io.realm.RealmFieldType;
-
-
-public interface TableSchema {
-
-    long addColumn(RealmFieldType type, String name);
-
-    void removeColumn(long columnIndex);
-
-    void renameColumn(long columnIndex, String newName);
-
-    /*
-    // FIXME the column information classes should be here as well.
-    // There is currently no path based implementation in core, so we should consider adding them with Spec, or wait for a core implementation.
-
-    long getColumnCount();
-
-    String getColumnName(long columnIndex);
-
-    long getColumnIndex(String name);
-
-    ColumnType getColumnType(long columnIndex);
-    */
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index 4cdf1e9712..d17c236ee2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -182,7 +182,6 @@ public OsList getLinkList(long columnIndex) {
     @Override
     public void setLong(long columnIndex, long value) {
         parent.checkImmutable();
-        getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
         nativeSetLong(nativePtr, columnIndex, value);
     }
 
@@ -225,10 +224,8 @@ public void setDate(long columnIndex, Date date) {
     public void setString(long columnIndex, @Nullable String value) {
         parent.checkImmutable();
         if (value == null) {
-            getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
             nativeSetNull(nativePtr, columnIndex);
         } else {
-            getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
             nativeSetString(nativePtr, columnIndex, value);
         }
     }
@@ -264,7 +261,6 @@ public boolean isNull(long columnIndex) {
     @Override
     public void setNull(long columnIndex) {
         parent.checkImmutable();
-        getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
         nativeSetNull(nativePtr, columnIndex);
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 23a60d532a..2b24ec28d4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -421,85 +421,6 @@ public SyncUser run() {
         }.start();
     }
 
-    /**
-     * Helper method for Admin users in order to lookup a {@code SyncUser} using the identity provider and the used username.
-     *
-     * @param provider identity providers {@link io.realm.SyncCredentials.IdentityProvider} used when the account was created.
-     * @param providerId username or email used to create the account for the first time,
-     *                   what is needed will depend on what type of {@link SyncCredentials} was used.
-     *
-     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
-     * of an {@code invalid} provider or {@code providerId}.
-     * @throws ObjectServerError in case of an error.
-     * @deprecated as of release 3.6.0, replaced by {@link #retrieveInfoForUser(String, String)}}
-     */
-    @Deprecated
-    public SyncUser retrieveUser(final String provider, final String providerId) throws ObjectServerError {
-        if (Util.isEmptyString(provider)) {
-            throw new IllegalArgumentException("Not-null 'provider' required.");
-        }
-
-        if (Util.isEmptyString(providerId)) {
-            throw new IllegalArgumentException("None empty 'providerId' required.");
-        }
-
-        if (!isAdmin()) {
-            throw new IllegalArgumentException("SyncUser needs to be admin in order to lookup other users ID.");
-        }
-
-        AuthenticationServer authServer = SyncManager.getAuthServer();
-        LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerId, getAuthenticationUrl());
-        if (!response.isValid()) {
-            // the endpoint returns a 404 if it can't honor the query, either because
-            // - provider is not valid
-            // - provider_id is not valid
-            // - token used is not an admin one
-            // in this case we should return null instead of throwing
-            if (response.getError().getErrorCode() == ErrorCode.NOT_FOUND) {
-                return null;
-            } else {
-                throw response.getError();
-            }
-        } else {
-            SyncUser syncUser = SyncManager.getUserStore().get(response.getUserId(), getAuthenticationUrl().toString());
-            if (syncUser != null) {
-                return syncUser;
-            } else {
-                // build a SynUser without a token
-                Token refreshToken = new Token(null, response.getUserId(), null, 0, null, response.isAdmin());
-                return new SyncUser(refreshToken, getAuthenticationUrl());
-            }
-        }
-    }
-
-    /**
-     * Asynchronously lookup a {@code SyncUser} using the identity provider and the used username.
-     * This is for Admin users only.
-     *
-     * @param provider identity providers {@link io.realm.SyncCredentials.IdentityProvider} used when the account was created.
-     * @param providerId  username or email used to create the account for the first time,
-     *                    what is needed will depend on what type of {@link SyncCredentials} was used.
-     * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
-     * as this method is called on.
-     * @return representation of the async task that can be used to cancel it if needed.
-     * @deprecated as of release 3.6.0, replaced by {@link #retrieveInfoForUserAsync(String, String, RequestCallback)}}
-     */
-    @Deprecated
-    public RealmAsyncTask retrieveUserAsync(final String provider, final String providerId, final Callback callback) {
-        checkLooperThread("Asynchronously retrieving user id is only possible from looper threads.");
-        //noinspection ConstantConditions
-        if (callback == null) {
-            throw new IllegalArgumentException("Non-null 'callback' required.");
-        }
-
-        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
-            @Override
-            public SyncUser run() {
-                return retrieveUser(provider, providerId);
-            }
-        }.start();
-    }
-
     /**
      * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), look up and return user information for that user.
      *
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
index 6ca1f3aef1..827ec0746a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
@@ -56,9 +56,9 @@ private ChangePasswordRequest(String token, String newPassword, String userID) {
     public String toJson() {
         try {
             JSONObject request = new JSONObject();
-            request.put("newPassword", newPassword);
+            request.put("new_password", newPassword);
             if (userID != null) {
-                request.put("userId", userID);
+                request.put("user_id", userID);
             }
             return request.toString();
         } catch (JSONException e) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
index eb60bd4890..a9d93d7c93 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
@@ -34,8 +34,8 @@
  */
 public class LookupUserIdResponse extends AuthServerResponse {
 
-    private static final String JSON_FIELD_USER_ID = "userId";
-    private static final String JSON_FIELD_USER_IS_ADMIN = "isAdmin";
+    private static final String JSON_FIELD_USER_ID = "user_id";
+    private static final String JSON_FIELD_USER_IS_ADMIN = "is_admin";
     private static final String JSON_FIELD_METADATA =  "metadata";
 
     private final String userId;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 537bf257bd..256df2f2aa 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -112,11 +112,8 @@ public void onError(ObjectServerError error) {
         });
     }
 
-    // FIXME: https://github.com/realm/realm-java/issues/4711
-    // fail may be related to this issue https://github.com/realm/realm-java/issues/5068
     @Test
     @RunTestInLooperThread
-    @Ignore("This fails expectSimpleCommit for some reasons, needs to be FIXED ASAP.")
     public void login_withAccessToken() {
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
         SyncCredentials credentials = SyncCredentials.accessToken(adminUser.getAccessToken().value(), "custom-admin-user", adminUser.isAdmin());
@@ -135,16 +132,8 @@ public void onError(SyncSession session, ObjectServerError error) {
 
                 final Realm realm = Realm.getInstance(config);
                 looperThread.addTestRealm(realm);
-
-                // FIXME: Right now we have no Java API for detecting when a session is established
-                // So we optimistically assume it has been connected after 1 second.
-                looperThread.postRunnableDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        assertTrue(SyncManager.getSession(config).getUser().isValid());
-                        looperThread.testComplete();
-                    }
-                }, 1000);
+                assertTrue(config.getUser().isValid());
+                looperThread.testComplete();
             }
 
             @Override
@@ -196,6 +185,7 @@ public void onError(ObjectServerError error) {
     }
 
     @Test
+    @Ignore("Wait for https://github.com/realm/ros/issues/335")
     public void changePassword() {
         String username = UUID.randomUUID().toString();
         String originalPassword = "password";
@@ -215,6 +205,7 @@ public void changePassword() {
     }
 
     @Test
+    @Ignore("See https://github.com/realm/ros/issues/335")
     public void changePassword_using_admin() {
         String username = UUID.randomUUID().toString();
         String originalPassword = "password";
@@ -242,6 +233,7 @@ public void changePassword_using_admin() {
 
     @Test
     @RunTestInLooperThread
+    @Ignore("Wait for https://github.com/realm/ros/issues/335")
     public void changePassword_using_admin_async() {
         final String username = UUID.randomUUID().toString();
         final String originalPassword = "password";
@@ -606,6 +598,7 @@ public void execute(Realm realm) {
     }
 
     @Test
+    @Ignore("Wait for https://github.com/realm/ros/issues/333")
     public void retrieve() {
         final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
 
@@ -629,6 +622,7 @@ public void retrieve() {
     // retrieving a logged out user
     @Test
     @RunTestInLooperThread
+    @Ignore("Wait for https://github.com/realm/ros/issues/333")
     public void retrieve_logout() {
         final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
 
@@ -696,6 +690,7 @@ public void retrieve_invalidProvider() {
     }
 
     @Test
+    @Ignore("Wait for https://github.com/realm/ros/issues/333")
     public void retrieve_notAdmin() {
         final String username1 = UUID.randomUUID().toString();
         final String password1 = "password";
@@ -719,6 +714,7 @@ public void retrieve_notAdmin() {
 
     @Test
     @RunTestInLooperThread
+    @Ignore("Wait for https://github.com/realm/ros/issues/333")
     public void retrieve_async() {
         final String username = UUID.randomUUID().toString();
         final String password = "password";
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index beb5c0cb06..a669b7dda4 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -92,23 +92,7 @@ public static SyncUser createAdminUser(String authUrl) {
         // `admin` required as user identifier to be granted admin rights.
         // ROS 2.0 comes with a default admin user named "realm-admin" with password "".
         SyncCredentials credentials = SyncCredentials.usernamePassword("realm-admin", "", false);
-        int attempts = 3;
-        while (attempts > 0) {
-            attempts--;
-            try {
-                return SyncUser.login(credentials, authUrl);
-            } catch (ObjectServerError e) {
-                // ROS default admin user might not be created yet, we need to retry.
-                // Remove this work-around when https://github.com/realm/ros/issues/282
-                // is fixed.
-                if (e.getErrorCode() != ErrorCode.INVALID_CREDENTIALS) {
-                    throw e;
-                }
-                SystemClock.sleep(1000);
-            }
-        }
-
-        throw new IllegalStateException("Could not login 'realm-admin'");
+        return SyncUser.login(credentials, authUrl);
     }
 
     // Since we don't have a reliable way to reset the sync server and client, just use a new user factory for every
@@ -165,8 +149,10 @@ public void run() {
                 for (SyncUser user : users.values()) {
                     user.logout();
                 }
-                SystemClock.sleep(2000); // Remove when https://github.com/realm/ros/issues/304 is fixed
+                // FIXME https://github.com/realm/ros/issues/338
+                SystemClock.sleep(2000);
                 allUsersLoggedOut.countDown();
+
             }
         });
         TestHelper.awaitOrFail(allUsersLoggedOut);
