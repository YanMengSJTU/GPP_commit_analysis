diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7474350814..a8b2312880 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -5,6 +5,7 @@
 ### Enhancements
 
 * [ObjectServer] Added support for `SyncUser.isAdmin()` (#4353).
+* [ObjectServer] Added support for changing passwords through `SyncUser.changePassword()` (#4423).
 * Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore` annotation (#4279).
 * Added `Realm.refresh()` and `DynamicRealm.refresh()` (#3476).
 
@@ -12,6 +13,8 @@
 
 ### Internal
 
+* Use separated locks for different `RealmCache`s ($4551).
+
 ## 3.1.4
 
 ## Bug fixes
diff --git a/dependencies.list b/dependencies.list
index 06db1eeb3f..7a9a09482c 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -10,4 +10,4 @@ REALM_SYNC_SHA256=e8a973dbe6ab33ac49d3d0e45d6b63d69cec8d1d87d9a2311fcdd02767f76c
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
 # install/use between 'realm' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.3.0-294
+REALM_OBJECT_SERVER_DE_VERSION=1.4.0-302
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index a548e407de..737177a801 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.1'
+    ext.kotlin_version = '1.1.2-2'
     repositories {
         jcenter()
         mavenCentral()
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index 778186e266..dcc0165a06 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -43,6 +43,7 @@ dependencies {
     compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'
     compile 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'
     compile 'com.jakewharton.timber:timber:4.1.0'
-    compile 'com.jakewharton:butterknife:7.0.1'
+    compile 'com.jakewharton:butterknife:8.5.1'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
     compile 'me.zhanghai.android.materialprogressbar:library:1.1.4'
 }
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
index 2356f04a76..5222153ecf 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
@@ -27,7 +27,7 @@
 import android.widget.ProgressBar;
 import android.widget.TextView;
 
-import butterknife.Bind;
+import butterknife.BindView;
 import butterknife.ButterKnife;
 import io.realm.examples.newsreader.R;
 import io.realm.examples.newsreader.model.Model;
@@ -37,10 +37,10 @@
 
     private static final String KEY_STORY_ID = "key.storyId";
 
-    @Bind(R.id.details_text) TextView detailsView;
-    @Bind(R.id.read_text) TextView readView;
-    @Bind(R.id.date_text) TextView dateView;
-    @Bind(R.id.loader_view) ProgressBar loaderView;
+    @BindView(R.id.details_text) TextView detailsView;
+    @BindView(R.id.read_text) TextView readView;
+    @BindView(R.id.date_text) TextView dateView;
+    @BindView(R.id.loader_view) ProgressBar loaderView;
 
     private Toolbar toolbar;
     private DetailsPresenter presenter;
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
index b7c81a6c88..fd6030a7c0 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
@@ -34,7 +34,7 @@
 
 import java.util.List;
 
-import butterknife.Bind;
+import butterknife.BindView;
 import butterknife.ButterKnife;
 import io.realm.examples.newsreader.R;
 import io.realm.examples.newsreader.model.Model;
@@ -43,10 +43,10 @@
 
 public class MainActivity extends AppCompatActivity {
 
-    @Bind(R.id.refresh_view) SwipeRefreshLayout refreshView;
-    @Bind(R.id.list_view) ListView listView;
-    @Bind(R.id.progressbar) MaterialProgressBar progressBar;
-    @Bind(R.id.spinner) Spinner spinner;
+    @BindView(R.id.refresh_view) SwipeRefreshLayout refreshView;
+    @BindView(R.id.list_view) ListView listView;
+    @BindView(R.id.progressbar) MaterialProgressBar progressBar;
+    @BindView(R.id.spinner) Spinner spinner;
 
     MainPresenter presenter = new MainPresenter(this, Model.getInstance());
     private ArrayAdapter<NYTimesStory> adapter;
@@ -169,7 +169,7 @@ public View getView(int position, View convertView, ViewGroup parent) {
         }
 
         static class ViewHolder {
-            @Bind(android.R.id.text1) TextView titleView;
+            @BindView(android.R.id.text1) TextView titleView;
             public ViewHolder(View view) {
                 ButterKnife.bind(this, view);
             }
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index 8a42675c8a..e3080cda9f 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -62,6 +62,6 @@ realm {
 dependencies {
     compile 'com.android.support:support-v4:25.2.0'
     compile 'com.android.support:design:25.2.0'
-    compile 'com.jakewharton:butterknife:8.3.0'
-    annotationProcessor 'com.jakewharton:butterknife-compiler:8.3.0'
+    compile 'com.jakewharton:butterknife:8.5.1'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
index c3b567d105..79148eacc4 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
@@ -28,6 +28,8 @@
 import android.widget.SeekBar;
 import android.widget.TextView;
 
+import java.lang.ref.WeakReference;
+
 import io.realm.Realm;
 import io.realm.examples.threads.model.Score;
 
@@ -56,7 +58,7 @@ public void onClick(View v) {
                     asyncTask.cancel(true);
                 }
 
-                asyncTask = new ImportAsyncTask();
+                asyncTask = new ImportAsyncTask(AsyncTaskFragment.this);
                 asyncTask.execute();
             }
         });
@@ -64,6 +66,14 @@ public void onClick(View v) {
         return rootView;
     }
 
+    @Override
+    public void onStop() {
+        super.onStop();
+        if (asyncTask != null) {
+            asyncTask.cancel(false);
+        }
+    }
+
     private void showStatus(String txt) {
         Log.i(TAG, txt);
         TextView tv = new TextView(getActivity());
@@ -80,7 +90,13 @@ private void showStatus(String txt) {
     // UI thread. This means that it is not possible to reuse RealmObjects or RealmResults created
     // in doInBackground() in the other methods. Nor is it possible to use RealmObjects as Progress
     // or Result objects.
-    private class ImportAsyncTask extends AsyncTask<Void, Integer, Integer> {
+    private static class ImportAsyncTask extends AsyncTask<Void, Integer, Integer> {
+
+        private final WeakReference<AsyncTaskFragment> fragmentRef;
+
+        ImportAsyncTask(AsyncTaskFragment outerFragment) {
+            fragmentRef = new WeakReference<AsyncTaskFragment>(outerFragment);
+        }
 
         @Override
         protected Integer doInBackground(Void... params) {
@@ -106,16 +122,25 @@ public void execute(Realm realm) {
 
         @Override
         protected void onPreExecute() {
-            logsView.removeAllViews();
-            progressView.setVisibility(View.VISIBLE);
-            showStatus("Starting import");
+            final AsyncTaskFragment fragment = fragmentRef.get();
+            if (fragment == null || fragment.isDetached()) {
+                cancel(false);
+                return;
+            }
+            fragment.logsView.removeAllViews();
+            fragment.progressView.setVisibility(View.VISIBLE);
+            fragment.showStatus("Starting import");
         }
 
         @Override
         protected void onPostExecute(Integer sum) {
-            progressView.setVisibility(View.GONE);
-            showStatus(TEST_OBJECTS + " objects imported.");
-            showStatus("The total score is : " + sum);
+            final AsyncTaskFragment fragment = fragmentRef.get();
+            if (fragment == null || fragment.isDetached()) {
+                return;
+            }
+            fragment.progressView.setVisibility(View.GONE);
+            fragment.showStatus(TEST_OBJECTS + " objects imported.");
+            fragment.showStatus("The total score is : " + sum);
         }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 580eda8f48..9c0ed01755 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -180,10 +180,10 @@ public void onChange(Realm object) {
 
     @Test
     public void notificationsNumber() throws InterruptedException, ExecutionException {
+        final CountDownLatch isReady = new CountDownLatch(1);
+        final CountDownLatch isRealmOpen = new CountDownLatch(1);
         final AtomicInteger counter = new AtomicInteger(0);
-        final AtomicBoolean isReady = new AtomicBoolean(false);
         final Looper[] looper = new Looper[1];
-        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
         final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -201,12 +201,12 @@ public Boolean call() throws Exception {
                     looper[0] = Looper.myLooper();
                     realm = Realm.getInstance(realmConfig);
                     realm.addChangeListener(listener);
-                    isReady.set(true);
+                    isReady.countDown();
                     Looper.loop();
                 } finally {
                     if (realm != null) {
                         realm.close();
-                        isRealmOpen.set(false);
+                        isRealmOpen.countDown();
                     }
                 }
                 return true;
@@ -214,10 +214,7 @@ public Boolean call() throws Exception {
         });
 
         // Waits until the looper in the background thread is started.
-        while (!isReady.get()) {
-            Thread.sleep(5);
-        }
-        Thread.sleep(100);
+        TestHelper.awaitOrFail(isReady);
 
         // Triggers OnRealmChanged on background thread.
         realm = Realm.getInstance(realmConfig);
@@ -235,9 +232,7 @@ public Boolean call() throws Exception {
         }
 
         // Waits until the Looper thread is actually closed.
-        while (isRealmOpen.get()) {
-            Thread.sleep(5);
-        }
+        TestHelper.awaitOrFail(isRealmOpen);
 
         assertEquals(1, counter.get());
         RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
@@ -262,7 +257,8 @@ public Boolean call() throws Exception {
                 if (dogs.size() != 0) {
                     return false;
                 }
-                addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages.
+                // Wait for main thread to add update messages.
+                addHandlerMessages.await(TestHelper.VERY_SHORT_WAIT_SECS, TimeUnit.SECONDS);
 
                 // Creates a Handler for the thread now. All message and references for the notification handler will be
                 // cleared once we call close().
@@ -292,7 +288,7 @@ public void run() {
         });
 
         // Waits until the looper is started on a background thread.
-        backgroundLooperStarted.await(1, TimeUnit.SECONDS);
+        backgroundLooperStarted.await(TestHelper.VERY_SHORT_WAIT_SECS, TimeUnit.SECONDS);
 
         // Executes a transaction that will trigger a Realm update.
         Realm realm = Realm.getInstance(realmConfig);
@@ -544,8 +540,8 @@ public void onChange(Realm object) {
         realm.commitTransaction();
         // Any REALM_CHANGED message should now only reach the open Handler on Thread1.
         try {
-            // TODO: Waiting 5 seconds is not a reliable condition. Figure out a better way for this.
-            if (!handlerNotified.await(5, TimeUnit.SECONDS)) {
+            // TODO: Waiting a few seconds is not a reliable condition. Figure out a better way for this.
+            if (!handlerNotified.await(TestHelper.SHORT_WAIT_SECS,  TimeUnit.SECONDS)) {
                 fail("Handler didn't receive message");
             }
         } finally {
@@ -573,11 +569,8 @@ public void run() {
                 realm.setAutoRefresh(false);
                 TestHelper.quitLooperOrFail();
                 backgroundLooperStartedAndStopped.countDown();
-                try {
-                    mainThreadCommitCompleted.await();
-                } catch (InterruptedException e) {
-                    fail("Thread interrupted"); // This will prevent backgroundThreadStopped from being called.
-                }
+                // This will prevent backgroundThreadStopped from being called.
+                TestHelper.awaitOrFail(mainThreadCommitCompleted);
                 realm.close();
                 backgroundThreadStopped.countDown();
             }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 546c1eb423..d04ed040bf 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -1126,20 +1126,16 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
         new Thread() {
             @Override
             public void run() {
-                try {
-                    queriesCompleted.await();
-                    Realm bgRealm = Realm.getInstance(realm.getConfiguration());
-
-                    bgRealm.beginTransaction();
-                    bgRealm.createObject(AllTypes.class);
-                    bgRealm.createObject(AnnotationIndexTypes.class);
-                    bgRealm.commitTransaction();
-
-                    bgRealm.close();
-                    bgRealmClosedLatch.countDown();
-                } catch (InterruptedException e) {
-                    fail(e.getMessage());
-                }
+                TestHelper.awaitOrFail(queriesCompleted);
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+
+                bgRealm.beginTransaction();
+                bgRealm.createObject(AllTypes.class);
+                bgRealm.createObject(AnnotationIndexTypes.class);
+                bgRealm.commitTransaction();
+
+                bgRealm.close();
+                bgRealmClosedLatch.countDown();
             }
         }.start();
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index 1085a371b6..a02c2b9006 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -191,7 +191,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         testRealm.close();
 
         // 2. Deletes the old Realm.
-        Realm.deleteRealm(config);
+        assertTrue(Realm.deleteRealm(config));
 
         // 3. Renames the new file to the old file name.
         assertTrue(copiedRealm.renameTo(new File(config.getRealmDirectory(), REALM_NAME)));
@@ -255,42 +255,113 @@ public void run() {
         });
         thread.start();
 
-        closeLatch.await();
+        TestHelper.awaitOrFail(closeLatch);
         RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(1));
         realmA.close();
         RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(0));
     }
 
+    @Test
+    public void getInstance_differentConfigurationsShouldNotBlockEachOther() throws InterruptedException {
+        final CountDownLatch bgThreadStarted = new CountDownLatch(1);
+        final CountDownLatch realm2CreatedLatch = new CountDownLatch(1);
+
+        final RealmConfiguration config1 = configFactory.createConfigurationBuilder()
+                .name("config1.realm")
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        bgThreadStarted.countDown();
+                        TestHelper.awaitOrFail(realm2CreatedLatch);
+                    }
+                })
+                .build();
+
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
+                .name("config2.realm")
+                .build();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(config1);
+                realm.close();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgThreadStarted);
+        Realm realm = Realm.getInstance(config2);
+        realm2CreatedLatch.countDown();
+        realm.close();
+        thread.join();
+    }
+
     @Test
     public void releaseCacheInOneThread() {
         // Tests release typed Realm instance.
         Realm realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         Realm realmB = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
-        RealmCache.release(realmA);
+        realmA.close();
         assertNotNull(realmA.sharedRealm);
-        RealmCache.release(realmB);
+        realmB.close();
         assertNull(realmB.sharedRealm);
         // No crash but warning in the log.
-        RealmCache.release(realmB);
+        realmB.close();
 
         // Tests release dynamic Realm instance.
         DynamicRealm dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
         DynamicRealm dynamicRealmB = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
-        RealmCache.release(dynamicRealmA);
+        dynamicRealmA.close();
         assertNotNull(dynamicRealmA.sharedRealm);
-        RealmCache.release(dynamicRealmB);
+        dynamicRealmB.close();
         assertNull(dynamicRealmB.sharedRealm);
         // No crash but warning in the log.
-        RealmCache.release(dynamicRealmB);
+        dynamicRealmB.close();
 
         // Tests both typed Realm and dynamic Realm in same thread.
         realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig, DynamicRealm.class);
-        RealmCache.release(realmA);
+        realmA.close();
         assertNull(realmA.sharedRealm);
-        RealmCache.release(dynamicRealmA);
+        dynamicRealmA.close();
         assertNull(realmA.sharedRealm);
     }
+
+    // The DynamicRealm and Realm with the same Realm path should share the same RealmCache
+    @Test
+    public void typedRealmAndDynamicRealmShareTheSameCache() {
+        final String DB_NAME = "same_name.realm";
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
+                .name(DB_NAME)
+                .build();
+
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
+                .name(DB_NAME)
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        // Because of config1 doesn't have initialData block, these two configurations are not the same.
+                        // So if a Realm is created with config1, then create another Realm with config2 should just
+                        // fail before executing this block.
+                        fail();
+                    }
+                })
+                .build();
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config1);
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            dynamicRealm.close();
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index 8fd06f3310..1b41af1114 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -217,7 +217,7 @@ public void run() {
 
                 // Waits until Realm instance closed in main thread.
                 try {
-                    realmInMainClosedLatch.await(3, TimeUnit.SECONDS);
+                    realmInMainClosedLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     threadError[0] = new AssertionFailedError("Worker thread was interrupted.");
                     realm.close();
@@ -232,7 +232,7 @@ public void run() {
 
 
         // Waits until the worker thread started.
-        workerCommittedLatch.await(3, TimeUnit.SECONDS);
+        workerCommittedLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // Refreshes will be ran in the next loop, manually refreshes it here.
@@ -253,7 +253,7 @@ public void run() {
         realmInMainClosedLatch.countDown();
 
         // Waits until the worker thread finished.
-        workerClosedLatch.await(3, TimeUnit.SECONDS);
+        workerClosedLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index c4e597eb45..76c5c4c377 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -38,6 +38,7 @@
 import io.realm.entities.AllTypes;
 import io.realm.services.RemoteProcessService;
 
+
 // This is built for testing multi processes related cases.
 // To build a test case, create an InterprocessHandler in your test case. This handler will run in the newly
 // created thread's Looper. Remember to call Looper.loop() to start handling messages.
@@ -97,7 +98,7 @@ public void run() {
         });
 
         thread.start();
-        latch.await();
+        TestHelper.awaitOrFail(latch);
 
         if (throwableArray[0] != null) {
             throw throwableArray[0];
@@ -161,7 +162,7 @@ protected void setUp() throws Exception {
         serviceStartLatch = new CountDownLatch(1);
         Intent intent = new Intent(getContext(), RemoteProcessService.class);
         getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
-        assertTrue(serviceStartLatch.await(10, TimeUnit.SECONDS));
+        assertTrue(serviceStartLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS));
     }
 
     @Override
@@ -205,7 +206,7 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
     // be retained by the system to be used next time.
     // Use getRemoteProcessInfo if you want to check the existence of remote process.
     private ActivityManager.RunningServiceInfo getServiceInfo() {
-        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager manager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
         List<ActivityManager.RunningServiceInfo> serviceInfoList = manager.getRunningServices(Integer.MAX_VALUE);
         for (ActivityManager.RunningServiceInfo service : serviceInfoList) {
             if (RemoteProcessService.class.getName().equals(service.service.getClassName())) {
@@ -217,7 +218,7 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
 
     // Gets the remote process info if it is alive.
     private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
-        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager manager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
         List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
         for (ActivityManager.RunningAppProcessInfo info : processInfoList) {
             if (info.processName.equals(getContext().getPackageName() + ":remote")) {
@@ -255,12 +256,12 @@ public void handleMessage(Message msg) {
                             ActivityManager.RunningAppProcessInfo processInfo = getRemoteProcessInfo();
                             if (processInfo != null && processInfo.pid == servicePid && i >= 6) {
                                 // The process is still alive.
-                                assertTrue(false);
+                                fail("Process is still alive");
                             } else if (processInfo == null || processInfo.pid != servicePid) {
                                 // The process is gone.
                                 break;
                             }
-                            Thread.sleep(500, 0);
+                            Thread.sleep(500);
                         }
                     } catch (InterruptedException e) {
                         e.printStackTrace();
@@ -288,7 +289,8 @@ public void run() {
 
                 // Step A
                 triggerServiceStep(RemoteProcessService.stepCreateInitialRealm_A);
-            }}) {
+            }
+        }) {
 
             @Override
             public void handleMessage(Message msg) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index c3b2944f1b..f99ae25334 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -714,10 +714,7 @@ public void run() {
                 realm.commitTransaction();
 
                 createLatch.countDown();
-                try {
-                    testEndLatch.await();
-                } catch (InterruptedException ignored) {
-                }
+                TestHelper.awaitOrFail(testEndLatch);
 
                 // 3. Closes Realm in this thread and finishes.
                 realm.close();
@@ -725,7 +722,7 @@ public void run() {
         };
         thread.start();
 
-        createLatch.await();
+        TestHelper.awaitOrFail(createLatch);
         // 2. Sets created object to target.
         realm.beginTransaction();
         try {
@@ -869,10 +866,7 @@ public void run() {
                 realm.commitTransaction();
 
                 createLatch.countDown();
-                try {
-                    testEndLatch.await();
-                } catch (InterruptedException ignored) {
-                }
+                TestHelper.awaitOrFail(testEndLatch);
 
                 // 3. Close Realm in this thread and finishes.
                 realm.close();
@@ -880,7 +874,7 @@ public void run() {
         };
         thread.start();
 
-        createLatch.await();
+        TestHelper.awaitOrFail(createLatch);
         // 2. Sets created object to target.
         realm.beginTransaction();
         try {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index e11ad67955..8be7cc00fa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -70,12 +70,12 @@
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
-    protected final static int TEST_DATA_SIZE = 10;
-    protected final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
+    private final static int TEST_DATA_SIZE = 10;
+    private final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
 
     private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
 
-    protected Realm realm;
+    private Realm realm;
 
     @Before
     public void setUp() throws Exception {
@@ -2624,7 +2624,7 @@ public void run() {
             thread.start();
         }
 
-        latch.await();
+        TestHelper.awaitOrFail(latch);
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 3bbe104e97..53517f3c8c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -61,6 +61,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
@@ -1985,10 +1986,7 @@ public void deleteRealm() throws InterruptedException {
             public void run() {
                 Realm realm = Realm.getInstance(configuration);
                 bgThreadReadyLatch.countDown();
-                try {
-                    readyToCloseLatch.await();
-                } catch (InterruptedException ignored) {
-                }
+                TestHelper.awaitOrFail(readyToCloseLatch);
                 realm.close();
                 closedLatch.countDown();
             }
@@ -2006,7 +2004,7 @@ public void run() {
         readyToCloseLatch.countDown();
 
         realm.close();
-        closedLatch.await();
+        TestHelper.awaitOrFail(closedLatch);
         // Now we get log files back!
         assertTrue(tempDirRenamed.renameTo(tempDir));
 
@@ -2593,7 +2591,7 @@ public void run() {
         thatThread.start();
 
         // Timeout should never happen.
-        latch.await();
+        TestHelper.awaitOrFail(latch);
         if (threadAssertionError[0] != null) {
             throw threadAssertionError[0];
         }
@@ -2631,7 +2629,7 @@ public void run() {
         thatThread.start();
 
         // Timeout should never happen.
-        latch.await();
+        TestHelper.awaitOrFail(latch);
         if (threadAssertionError[0] != null) {
             throw threadAssertionError[0];
         }
@@ -2707,7 +2705,7 @@ public void closingRealmWhileOtherThreadIsOpeningRealm() throws Exception {
             @Override
             public void run() {
                 try {
-                    startLatch.await();
+                    startLatch.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     exception.add(e);
                     return;
@@ -2736,7 +2734,7 @@ public void run() {
             realm = null;
         }
 
-        endLatch.await();
+        TestHelper.awaitOrFail(endLatch);
 
         if (!exception.isEmpty()) {
             throw exception.get(0);
@@ -2763,7 +2761,7 @@ public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 realmOpenedInBgLatch.countDown();
                 try {
-                    realmClosedInFgLatch.await();
+                    realmClosedInFgLatch.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     exception.add(e);
                     realm.close();
@@ -2774,7 +2772,7 @@ public void run() {
                 realm.beginTransaction();
                 transBeganInBgLatch.countDown();
                 try {
-                    fgFinishedLatch.await();
+                    fgFinishedLatch.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     exception.add(e);
                 }
@@ -2786,16 +2784,16 @@ public void run() {
         });
         thread.start();
 
-        realmOpenedInBgLatch.await();
+        TestHelper.awaitOrFail(realmOpenedInBgLatch);
         // Step 3: Closes all realm instances in foreground thread.
         realm.close();
         realmClosedInFgLatch.countDown();
-        transBeganInBgLatch.await();
+        TestHelper.awaitOrFail(transBeganInBgLatch);
 
         // Step 5: Gets a new Realm instance in foreground.
         realm = Realm.getInstance(realmConfig);
         fgFinishedLatch.countDown();
-        bgFinishedLatch.await();
+        TestHelper.awaitOrFail(bgFinishedLatch);
 
         if (!exception.isEmpty()) {
             throw exception.get(0);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 090f048cb8..a688249e8c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -31,7 +31,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
@@ -67,6 +66,10 @@
 import static junit.framework.Assert.fail;
 
 public class TestHelper {
+    public static final int VERY_SHORT_WAIT_SECS = 1;
+    public static final int SHORT_WAIT_SECS = 10;
+    public static final int STANDARD_WAIT_SECS = 100;
+    public static final int LONG_WAIT_SECS = 1000;
 
     private static final Charset UTF_8 = Charset.forName("UTF-8");
     private static final Random RANDOM = new Random();
@@ -779,14 +782,14 @@ public static void populateForDistinctFieldsOrder(Realm realm, long numberOfBloc
     }
 
     public static void awaitOrFail(CountDownLatch latch) {
-        awaitOrFail(latch, 300);
+        awaitOrFail(latch, STANDARD_WAIT_SECS);
     }
 
     public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
         try {
             if (android.os.Debug.isDebuggerConnected()) {
-                // If we are debugging the tests, just waits without a timeout. In case we are stopping at a break point
-                // and timeout happens.
+                // If we are debugging the tests, just waits without a timeout.
+                // Don't want a timeout while we are stopped at a break point.
                 latch.await();
             } else if (!latch.await(numberOfSeconds, TimeUnit.SECONDS)) {
                 fail("Test took longer than " + numberOfSeconds + " seconds");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java b/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
index cc570efb8d..fc6a06f19b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
@@ -21,6 +21,8 @@
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.TestHelper;
+
 
 /**
  * Utility class for running a task on a non-looper background thread.
@@ -62,7 +64,7 @@ public void run() {
         }, "RealmBackgroundTask").start();
 
         try {
-            if (!jobDone.await(10, TimeUnit.SECONDS)) {
+            if (!jobDone.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS)) {
                 exceptionHolder.setError("Job timed out!");
             }
         } catch (InterruptedException e) {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index fe69cfff36..487a95ff54 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -17,12 +17,14 @@
 package io.realm;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
 import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.mockito.invocation.InvocationOnMock;
@@ -38,6 +40,7 @@
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
 
 import static io.realm.util.SyncTestUtils.createTestAdminUser;
@@ -57,6 +60,12 @@
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
     @BeforeClass
     public static void initUserStore() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
@@ -268,4 +277,39 @@ public void login_appendAuthSegment() {
             SyncManager.setAuthServerImpl(originalServer);
         }
     }
+
+    @Test
+    public void changePassword_nullThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        user.changePassword(null);
+    }
+
+    @Test
+    public void changePasswordAsync_nonLooperThreadThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalStateException.class);
+        user.changePasswordAsync(null, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePasswordAsync_nullCallbackThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        user.changePasswordAsync("new-password", null);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 047a29377a..54aa59d27f 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -31,7 +31,6 @@
 import io.realm.internal.CheckedRow;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
-import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
@@ -69,20 +68,33 @@
 
     final long threadId;
     protected final RealmConfiguration configuration;
+    // Which RealmCache is this Realm associated to. It is null if the Realm instance is opened without being put into a
+    // cache. It is also null if the Realm is closed.
+    private RealmCache realmCache;
     protected SharedRealm sharedRealm;
 
     protected final StandardRealmSchema schema;
 
-    protected BaseRealm(RealmConfiguration configuration) {
+    // Create a realm instance and associate it to a RealmCache.
+    BaseRealm(RealmCache cache) {
+        this(cache.getConfiguration());
+        this.realmCache = cache;
+    }
+
+    // Create a realm instance without associating it to any RealmCache.
+    BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
+        this.realmCache = null;
 
         this.sharedRealm = SharedRealm.getInstance(configuration,
                 !(this instanceof Realm) ? null :
                         new SharedRealm.SchemaVersionListener() {
                             @Override
                             public void onSchemaVersionChanged(long currentVersion) {
-                                RealmCache.updateSchemaCache((Realm) BaseRealm.this);
+                                if (realmCache != null) {
+                                    realmCache.updateSchemaCache((Realm) BaseRealm.this);
+                                }
                             }
                         }, true);
         this.schema = new StandardRealmSchema(this);
@@ -277,16 +289,20 @@ public boolean waitForChange() {
      * @throws IllegalStateException if the {@link io.realm.Realm} instance has already been closed.
      */
     public void stopWaitForChange() {
-        RealmCache.invokeWithLock(new RealmCache.Callback0() {
-            @Override
-            public void onCall() {
-                // Checks if the Realm instance has been closed.
-                if (sharedRealm == null || sharedRealm.isClosed()) {
-                    throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+        if (realmCache != null) {
+            realmCache.invokeWithLock(new RealmCache.Callback0() {
+                @Override
+                public void onCall() {
+                    // Checks if the Realm instance has been closed.
+                    if (sharedRealm == null || sharedRealm.isClosed()) {
+                        throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+                    }
+                    sharedRealm.stopWaitForChange();
                 }
-                sharedRealm.stopWaitForChange();
-            }
-        });
+            });
+        } else {
+            throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+        }
     }
 
     /**
@@ -432,13 +448,18 @@ public void close() {
             throw new IllegalStateException(INCORRECT_THREAD_CLOSE_MESSAGE);
         }
 
-        RealmCache.release(this);
+        if (realmCache != null) {
+            realmCache.release(this);
+        } else {
+            doClose();
+        }
     }
 
     /**
      * Closes the Realm instances and all its resources without checking the {@link RealmCache}.
      */
     void doClose() {
+        realmCache = null;
         if (sharedRealm != null) {
             sharedRealm.close();
             sharedRealm = null;
@@ -505,9 +526,8 @@ public RealmSchema getSchema() {
     <E extends RealmModel> E get(Class<E> clazz, long rowIndex, boolean acceptDefaultValue, List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         UncheckedRow row = table.getUncheckedRow(rowIndex);
-        E result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
+        return configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
                 acceptDefaultValue, excludeFields);
-        return result;
     }
 
     // Used by RealmList/RealmResults
@@ -623,7 +643,9 @@ public void onResult(int count) {
                 RealmMigration realmMigration = (migration == null) ? configuration.getMigration() : migration;
                 DynamicRealm realm = null;
                 try {
-                    realm = DynamicRealm.getInstance(configuration);
+                    // Create a DynamicRealm WITHOUT putting it into a RealmCache to avoid recursive locks and call init
+                    // steps multiple times (copy asset file / initialData transaction).
+                    realm = DynamicRealm.createInstance(configuration);
                     realm.beginTransaction();
                     long currentVersion = realm.getVersion();
                     realmMigration.migrate(realm, currentVersion, configuration.getSchemaVersion());
@@ -656,6 +678,9 @@ protected void finalize() throws Throwable {
                     "Realm %s is being finalized without being closed, " +
                     "this can lead to running out of native memory.", configuration.getPath()
             );
+            if (realmCache != null) {
+                realmCache.leak();
+            }
         }
         super.finalize();
     }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 3a4f79ea94..92284eb561 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -45,6 +45,10 @@
  */
 public class DynamicRealm extends BaseRealm {
 
+    private DynamicRealm(RealmCache cache) {
+        super(cache);
+    }
+
     private DynamicRealm(RealmConfiguration configuration) {
         super(configuration);
     }
@@ -204,6 +208,15 @@ public void executeTransaction(Transaction transaction) {
      *
      * @return a {@link DynamicRealm} instance.
      */
+    static DynamicRealm createInstance(RealmCache cache) {
+        return new DynamicRealm(cache);
+    }
+
+    /**
+     * Create a {@link DynamicRealm} instance without associating it to any RealmCache.
+     *
+     * @return a {@link DynamicRealm} instance.
+     */
     static DynamicRealm createInstance(RealmConfiguration configuration) {
         return new DynamicRealm(configuration);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index c57121d600..6853f95759 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -134,11 +134,11 @@
     /**
      * The constructor is private to enforce the use of the static one.
      *
-     * @param configuration the {@link RealmConfiguration} used to open the Realm.
+     * @param cache the {@link RealmCache} associated to this Realm instance.
      * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
      */
-    Realm(RealmConfiguration configuration) {
-        super(configuration);
+    private Realm(RealmCache cache) {
+        super(cache);
     }
 
     /**
@@ -309,16 +309,13 @@ public static void removeDefaultConfiguration() {
     /**
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
-     * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param globalCacheArray if this is not {@code null} and contains an entry for current schema version,
-     * the {@link BaseRealm#schema#columnIndices} will be initialized with the copy of
-     * the entry. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated
-     * from the Realm file.
+     * @param cache the {@link RealmCache} where to create the realm in.
      * @return a {@link Realm} instance.
      */
-    static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
+    static Realm createInstance(RealmCache cache) {
+        RealmConfiguration configuration = cache.getConfiguration();
         try {
-            return createAndValidate(configuration, globalCacheArray);
+            return createAndValidateFromCache(cache);
 
         } catch (RealmMigrationNeededException e) {
             if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
@@ -334,17 +331,19 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] gl
                 }
             }
 
-            return createAndValidate(configuration, globalCacheArray);
+            return createAndValidateFromCache(cache);
         }
     }
 
-    private static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
-        Realm realm = new Realm(configuration);
+    private static Realm createAndValidateFromCache(RealmCache cache) {
+        Realm realm = new Realm(cache);
+        RealmConfiguration configuration = realm.configuration;
 
         final long currentVersion = realm.getVersion();
         final long requiredVersion = configuration.getSchemaVersion();
 
-        final ColumnIndices columnIndices = RealmCache.findColumnIndices(globalCacheArray, requiredVersion);
+        final ColumnIndices columnIndices = RealmCache.findColumnIndices(cache.getTypedColumnIndicesArray(),
+                requiredVersion);
 
         if (columnIndices != null) {
             // Copies global cache as a Realm local indices cache.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index b4cab8a8ec..dc00ba5032 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -19,10 +19,15 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.ref.WeakReference;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.EnumMap;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.ColumnIndices;
@@ -76,28 +81,67 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
     // Separated references and counters for typed Realm and dynamic Realm.
     private final EnumMap<RealmCacheType, RefAndCount> refAndCountMap;
 
-    final private RealmConfiguration configuration;
+    // Path to the Realm file to identify this cache.
+    private final String realmPath;
+
+    // This will be only valid if getTotalGlobalRefCount() > 0.
+    // NOTE: We do reset this when globalCount reaches 0, but if exception thrown in doCreateRealmOrGetFromCache at the
+    // first time when globalCount == 0, this could have a non-null value but it will be reset when the next
+    // doCreateRealmOrGetFromCache is called with globalCount == 0.
+    private RealmConfiguration configuration;
 
     // Column indices are cached to speed up opening typed Realm. If a Realm instance is created in one thread, creating
     // Realm instances in other threads doesn't have to initialize the column indices again.
     private static final int MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY = 4;
     private final ColumnIndices[] typedColumnIndicesArray = new ColumnIndices[MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY];
 
-    // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
-    // are not allowed and an exception will be thrown when trying to add it to the cache map.
-    private static final Map<String, RealmCache> cachesMap = new HashMap<>();
+    // Realm path will be used to identify different RealmCaches. Different Realm configurations with same path
+    // are not allowed and an exception will be thrown when trying to add it to the cache list.
+    // A weak ref is used to hold the RealmCache instance. The weak ref entry will be cleared if and only if there
+    // is no Realm instance holding a strong ref to it and there is no Realm instance associated it is BEING created.
+    private static final List<WeakReference<RealmCache>> cachesList = new LinkedList<WeakReference<RealmCache>>();
+
+    // See leak()
+    // isLeaked flag is used to avoid adding strong ref multiple times without iterating the list.
+    private final AtomicBoolean isLeaked = new AtomicBoolean(false);
+    // Keep strong ref to the leaked RealmCache
+    @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
+    private static final Collection<RealmCache> leakedCaches = new ConcurrentLinkedQueue<RealmCache>();
 
     private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
     private static final String WRONG_REALM_CLASS_MESSAGE = "The type of Realm class must be Realm or DynamicRealm.";
 
-    private RealmCache(RealmConfiguration config) {
-        configuration = config;
+    private RealmCache(String path) {
+        realmPath = path;
         refAndCountMap = new EnumMap<>(RealmCacheType.class);
         for (RealmCacheType type : RealmCacheType.values()) {
             refAndCountMap.put(type, new RefAndCount());
         }
     }
 
+    private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
+        RealmCache cacheToReturn = null;
+        synchronized (cachesList) {
+            Iterator<WeakReference<RealmCache>> it = cachesList.iterator();
+
+            while (it.hasNext()) {
+                RealmCache cache = it.next().get();
+                if (cache == null) {
+                    // Clear the entry if there is no one holding the RealmCache.
+                    it.remove();
+                } else if (cache.realmPath.equals(realmPath)) {
+                    cacheToReturn = cache;
+                }
+            }
+
+            if (cacheToReturn == null && createIfNotExist) {
+                cacheToReturn = new RealmCache(realmPath);
+                cachesList.add(new WeakReference<RealmCache>(cacheToReturn));
+            }
+        }
+        return cacheToReturn;
+    }
+
     /**
      * Creates a new Realm instance or get an existing instance for current thread.
      *
@@ -105,35 +149,44 @@ private RealmCache(RealmConfiguration config) {
      * @param realmClass class of {@link Realm} or {@link DynamicRealm} to be created in or gotten from the cache.
      * @return the {@link Realm} or {@link DynamicRealm} instance.
      */
-    static synchronized <E extends BaseRealm> E createRealmOrGetFromCache(RealmConfiguration configuration,
+    static <E extends BaseRealm> E createRealmOrGetFromCache(RealmConfiguration configuration,
+            Class<E> realmClass) {
+        RealmCache cache = getCache(configuration.getPath(), true);
+
+        return cache.doCreateRealmOrGetFromCache(configuration, realmClass);
+    }
+
+    private synchronized <E extends BaseRealm> E doCreateRealmOrGetFromCache(RealmConfiguration configuration,
             Class<E> realmClass) {
-        boolean isCacheInMap = true;
-        RealmCache cache = cachesMap.get(configuration.getPath());
-        if (cache == null) {
-            // Creates a new cache.
-            cache = new RealmCache(configuration);
-            // The new cache should be added to the map later.
-            isCacheInMap = false;
 
+        RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.valueOf(realmClass));
+
+        if (getTotalGlobalRefCount() == 0) {
             copyAssetFileIfNeeded(configuration);
-        } else {
-            // Throws the exception if validation failed.
-            cache.validateConfiguration(configuration);
-        }
 
-        RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realmClass));
+            SharedRealm sharedRealm = null;
+            try {
+                sharedRealm = SharedRealm.getInstance(configuration);
+                if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
+                    sharedRealm.beginTransaction();
+                    if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
+                        sharedRealm.commitTransaction();
+                    } else {
+                        sharedRealm.cancelTransaction();
+                    }
+                }
 
-        if (refAndCount.globalCount == 0) {
-            SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
-            if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
-                sharedRealm.beginTransaction();
-                if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
-                    sharedRealm.commitTransaction();
-                } else {
-                    sharedRealm.cancelTransaction();
+            } finally {
+                if (sharedRealm != null) {
+                    sharedRealm.close();
                 }
             }
-            sharedRealm.close();
+
+            // We are holding the lock, and we can set the invalidated configuration since there is no global ref to it.
+            this.configuration = configuration;
+        } else {
+            // Throws exception if validation failed.
+            validateConfiguration(configuration);
         }
 
         if (refAndCount.localRealm.get() == null) {
@@ -142,39 +195,30 @@ private RealmCache(RealmConfiguration config) {
 
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
-                realm = Realm.createInstance(configuration, cache.typedColumnIndicesArray);
+                realm = Realm.createInstance(this);
             } else if (realmClass == DynamicRealm.class) {
-                realm = DynamicRealm.createInstance(configuration);
+                realm = DynamicRealm.createInstance(this);
             } else {
                 throw new IllegalArgumentException(WRONG_REALM_CLASS_MESSAGE);
             }
 
             // The Realm instance has been created without exceptions. Cache and reference count can be updated now.
-
-            // The cache is not in the map yet. Add it to the map after the Realm instance created successfully.
-            if (!isCacheInMap) {
-                cachesMap.put(configuration.getPath(), cache);
-            }
             refAndCount.localRealm.set(realm);
             refAndCount.localCount.set(0);
-        }
 
-        Integer refCount = refAndCount.localCount.get();
-        if (refCount == 0) {
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
-                final BaseRealm realm = refAndCount.localRealm.get();
                 // Stores a copy of local ColumnIndices as a global cache.
-                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.cloneColumnIndices());
+                RealmCache.storeColumnIndices(typedColumnIndicesArray, realm.schema.cloneColumnIndices());
             }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
         }
-        refAndCount.localCount.set(refCount + 1);
 
-        @SuppressWarnings("unchecked")
-        E realm = (E) refAndCount.localRealm.get();
+        Integer refCount = refAndCount.localCount.get();
+        refAndCount.localCount.set(refCount + 1);
 
-        return realm;
+        //noinspection unchecked
+        return (E) refAndCount.localRealm.get();
     }
 
     /**
@@ -183,22 +227,16 @@ private RealmCache(RealmConfiguration config) {
      *
      * @param realm Realm instance to be released from cache.
      */
-    static synchronized void release(BaseRealm realm) {
+    synchronized void release(BaseRealm realm) {
         String canonicalPath = realm.getPath();
-        RealmCache cache = cachesMap.get(canonicalPath);
-        Integer refCount = null;
-        RefAndCount refAndCount = null;
-
-        if (cache != null) {
-            refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realm.getClass()));
-            refCount = refAndCount.localCount.get();
-        }
+        RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.valueOf(realm.getClass()));
+        Integer refCount = refAndCount.localCount.get();
         if (refCount == null) {
             refCount = 0;
         }
 
         if (refCount <= 0) {
-            RealmLog.warn("%s has been closed already.", canonicalPath);
+            RealmLog.warn("%s has been closed already. refCount is %s", canonicalPath, refCount);
             return;
         }
 
@@ -222,20 +260,18 @@ static synchronized void release(BaseRealm realm) {
             // Clears the column indices cache if needed.
             if (realm instanceof Realm && refAndCount.globalCount == 0) {
                 // All typed Realm instances of this file are cleared from cache.
-                Arrays.fill(cache.typedColumnIndicesArray, null);
-            }
-
-            int totalRefCount = 0;
-            for (RealmCacheType type : RealmCacheType.values()) {
-                totalRefCount += cache.refAndCountMap.get(type).globalCount;
+                Arrays.fill(typedColumnIndicesArray, null);
             }
 
             // No more local reference to this Realm in current thread, close the instance.
             realm.doClose();
 
-            // No more instance of typed Realm and dynamic Realm. Remove the configuration from cache.
-            if (totalRefCount == 0) {
-                cachesMap.remove(canonicalPath);
+            // No more instance of typed Realm and dynamic Realm.
+            if (getTotalGlobalRefCount() == 0) {
+                // We keep the cache in the caches list even when its global counter reaches 0. It will be reused when
+                // next time a Realm instance with the same path is opened. By not removing it, the lock on
+                // cachesList is not needed here.
+                configuration = null;
                 ObjectServerFacade.getFacade(realm.getConfiguration().isSyncConfiguration())
                         .realmClosed(realm.getConfiguration());
             }
@@ -287,17 +323,23 @@ private void validateConfiguration(RealmConfiguration newConfiguration) {
      * @param configuration the {@link RealmConfiguration} of {@link Realm} or {@link DynamicRealm}.
      * @param callback the callback will be executed with the global reference count.
      */
-    static synchronized void invokeWithGlobalRefCount(RealmConfiguration configuration, Callback callback) {
-        RealmCache cache = cachesMap.get(configuration.getPath());
-        if (cache == null) {
-            callback.onResult(0);
-            return;
-        }
-        int totalRefCount = 0;
-        for (RealmCacheType type : RealmCacheType.values()) {
-            totalRefCount += cache.refAndCountMap.get(type).globalCount;
+    static void invokeWithGlobalRefCount(RealmConfiguration configuration, Callback callback) {
+        // NOTE: Although getCache is locked on the cacheMap, this whole method needs to be lock with it as
+        // well. Since we need to ensure there is no Realm instance can be opened when this method is called (for
+        // deleteRealm).
+        // Recursive lock cannot be avoided here.
+        synchronized (cachesList) {
+            RealmCache cache = getCache(configuration.getPath(), false);
+            if (cache == null) {
+                callback.onResult(0);
+                return;
+            }
+            cache.doInvokeWithGlobalRefCount(callback);
         }
-        callback.onResult(totalRefCount);
+    }
+
+    private synchronized void doInvokeWithGlobalRefCount(Callback callback) {
+        callback.onResult(getTotalGlobalRefCount());
     }
 
     /**
@@ -305,19 +347,14 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
      *
      * @param realm the instance that contains the schema cache to be updated.
      */
-    static synchronized void updateSchemaCache(Realm realm) {
-        final RealmCache cache = cachesMap.get(realm.getPath());
-        if (cache == null) {
-            // Called during initialization. just skip it.
-            return;
-        }
-        final RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.TYPED_REALM);
+    synchronized void updateSchemaCache(Realm realm) {
+        final RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.TYPED_REALM);
         if (refAndCount.localRealm.get() == null) {
             // Called during initialization. just skip it.
             // We can reach here if the DynamicRealm instance is initialized first.
             return;
         }
-        final ColumnIndices[] globalCacheArray = cache.typedColumnIndicesArray;
+        final ColumnIndices[] globalCacheArray = typedColumnIndicesArray;
         final ColumnIndices createdCacheEntry = realm.updateSchemaCache(globalCacheArray);
         if (createdCacheEntry != null) {
             RealmCache.storeColumnIndices(globalCacheArray, createdCacheEntry);
@@ -329,7 +366,7 @@ static synchronized void updateSchemaCache(Realm realm) {
      *
      * @param callback the callback will be executed.
      */
-    static synchronized void invokeWithLock(Callback0 callback) {
+    synchronized void invokeWithLock(Callback0 callback) {
         callback.onCall();
     }
 
@@ -394,17 +431,18 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
     }
 
     static int getLocalThreadCount(RealmConfiguration configuration) {
-        RealmCache cache = cachesMap.get(configuration.getPath());
+        RealmCache cache = getCache(configuration.getPath(), false);
         if (cache == null) {
             return 0;
-        } else {
-            int totalRefCount = 0;
-            for (RealmCacheType type : RealmCacheType.values()) {
-                Integer localCount = cache.refAndCountMap.get(type).localCount.get();
-                totalRefCount += (localCount != null) ? localCount : 0;
-            }
-            return totalRefCount;
         }
+
+        // Access local ref count only, no need to by synchronized.
+        int totalRefCount = 0;
+        for (RefAndCount refAndCount : cache.refAndCountMap.values()) {
+            Integer localCount = refAndCount.localCount.get();
+            totalRefCount += (localCount != null) ? localCount : 0;
+        }
+        return totalRefCount;
     }
 
     /**
@@ -453,4 +491,34 @@ private static int storeColumnIndices(ColumnIndices[] array, ColumnIndices colum
         array[candidateIndex] = columnIndices;
         return candidateIndex;
     }
+
+    public RealmConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public ColumnIndices[] getTypedColumnIndicesArray() {
+        return typedColumnIndicesArray;
+    }
+
+    /**
+     * @return the total global ref count.
+     */
+    private int getTotalGlobalRefCount() {
+        int totalRefCount = 0;
+        for (RefAndCount refAndCount : refAndCountMap.values()) {
+            totalRefCount += refAndCount.globalCount;
+        }
+
+        return totalRefCount;
+    }
+
+    /**
+     * If a Realm instance is GCed but `Realm.close()` is not called before, we still want to track the cache for
+     * debugging. Adding them to the list to keep the strong ref of the cache to prevent the cache gets GCed.
+     */
+    void leak() {
+        if (!isLeaked.getAndSet(true)) {
+            leakedCaches.add(this);
+        }
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index ec1d2f0ba2..9dcbcfd680 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -35,10 +35,14 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
 
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.Util;
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.internal.android.AndroidRealmNotifier;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ChangePasswordResponse;
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.LogoutResponse;
 import io.realm.internal.objectserver.ObjectServerUser;
@@ -46,6 +50,7 @@
 import io.realm.log.RealmLog;
 import io.realm.permissions.PermissionModule;
 
+
 /**
  * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
  * providers (Facebook, Google, etc.).
@@ -101,7 +106,7 @@ private SyncUser(ObjectServerUser user) {
      * A user is invalidated when he/she logs out or the user's access token expires.
      *
      * @return current {@link SyncUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has
-     *         expired.
+     * expired.
      * @throws IllegalStateException if multiple users are logged in.
      */
     public static SyncUser currentUser() {
@@ -134,7 +139,6 @@ public static SyncUser currentUser() {
      * Loads a user that has previously been serialized using {@link #toJson()}.
      *
      * @param user JSON string representing the user.
-     *
      * @return the user object.
      * @throws IllegalArgumentException if the JSON couldn't be converted to a valid {@link SyncUser} object.
      */
@@ -221,55 +225,18 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
      * @param credentials credentials to use.
      * @param authenticationUrl server that the user is authenticated against.
      * @param callback callback when login has completed or failed. The callback will always happen on the same thread
-     *                 as this this method is called on.
+     * as this this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
      * @throws IllegalArgumentException if not on a Looper thread.
      */
     public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback callback) {
-        if (Looper.myLooper() == null) {
-            throw new IllegalStateException("Asynchronous login is only possible from looper threads.");
-        }
-        final Handler handler = new Handler(Looper.myLooper());
-        ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
-        Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {
+        checkLooperThread("Asynchronous login is only possible from looper threads.");
+        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
             @Override
-            public void run() {
-                try {
-                    SyncUser user = login(credentials, authenticationUrl);
-                    postSuccess(user);
-                } catch (ObjectServerError e) {
-                    postError(e);
-                }
-            }
-
-            private void postError(final ObjectServerError error) {
-                if (callback != null) {
-                    handler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            try {
-                                callback.onError(error);
-                            } catch (Exception e) {
-                                RealmLog.info("onError has thrown an exception but is ignoring it: %s",
-                                        Util.getStackTrace(e));
-                            }
-                        }
-                    });
-                }
+            public SyncUser run() throws ObjectServerError {
+                return login(credentials, authenticationUrl);
             }
-
-            private void postSuccess(final SyncUser user) {
-                if (callback != null) {
-                    handler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            callback.onSuccess(user);
-                        }
-                    });
-                }
-            }
-        });
-
-        return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);
+        }.start();
     }
 
     /**
@@ -277,7 +244,7 @@ public void run() {
      * {@link AuthenticationListener} will be notified and user credentials will be deleted from this device.
      *
      * @throws IllegalStateException if any Realms owned by this user is still open. They should be closed before
-     *         logging out.
+     * logging out.
      */
     /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
      <p>
@@ -329,7 +296,7 @@ public void logout() {
 
                 @Override
                 protected LogoutResponse execute() {
-                    return server.logout(userToken, syncUser.getAuthenticationUrl());
+                    return server.logout(userToken, getAuthenticationUrl());
                 }
 
                 @Override
@@ -345,6 +312,58 @@ protected void onError(LogoutResponse response) {
         }
     }
 
+    /**
+     * Changes this user's password. This is done synchronously and involves the network, so calling this method on the
+     * Android UI thread will always crash.
+     * <p>
+     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param newPassword the user's new password.
+     * @throws ObjectServerError if the password could not be changed.
+     */
+    public void changePassword(String newPassword) throws ObjectServerError {
+        if (newPassword == null) {
+            throw new IllegalArgumentException("Not-null 'newPassword' required.");
+        }
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        ChangePasswordResponse response = authServer.changePassword(getSyncUser().getUserToken(), newPassword, getAuthenticationUrl());
+        if (!response.isValid()) {
+            throw response.getError();
+        }
+    }
+
+    /**
+     * Changes this user's password asynchronously.
+     * <p>
+     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param newPassword the user's new password.
+     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalArgumentException if not on a Looper thread.
+     */
+    public RealmAsyncTask changePasswordAsync(final String newPassword, final Callback callback) {
+        checkLooperThread("Asynchronous changing password is only possible from looper threads.");
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public SyncUser run() {
+                changePassword(newPassword);
+                return SyncUser.this;
+            }
+        }.start();
+    }
+
+    private static void checkLooperThread(String errorMessage) {
+        AndroidCapabilities capabilities = new AndroidCapabilities();
+        capabilities.checkCanDeliverNotification(errorMessage);
+    }
+
     /**
      * Returns a JSON token representing this user.
      * <p>
@@ -352,8 +371,7 @@ protected void onError(LogoutResponse response) {
      * should be treated as sensitive data.
      *
      * @return JSON string representing this user. It can be converted back into a real user object using
-     *         {@link #fromJson(String)}.
-     *
+     * {@link #fromJson(String)}.
      * @see #fromJson(String)
      */
     public String toJson() {
@@ -392,7 +410,7 @@ public boolean isAdmin() {
      * among all users on the Realm Object Server.
      *
      * @return identity of the user on the Realm Object Server. If the user has logged out or the login has expired
-     *         {@code null} is returned.
+     * {@code null} is returned.
      */
     public String getIdentity() {
         return syncUser.getIdentity();
@@ -446,8 +464,8 @@ private static String getManagementRealmUrl(URL authUrl) {
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
 
         SyncUser user = (SyncUser) o;
 
@@ -464,7 +482,7 @@ public int hashCode() {
     public String toString() {
         StringBuilder sb = new StringBuilder("{");
         sb.append("UserId: ").append(syncUser.getIdentity());
-        sb.append(", AuthUrl: ").append(syncUser.getAuthenticationUrl());
+        sb.append(", AuthUrl: ").append(getAuthenticationUrl());
         sb.append(", IsValid: ").append(isValid());
         sb.append(", Sessions: ").append(syncUser.getSessions().size());
         sb.append("}");
@@ -476,8 +494,72 @@ ObjectServerUser getSyncUser() {
         return syncUser;
     }
 
+    // Class wrapping requests made against the auth server. Is also responsible for calling with success/error on the
+    // correct thread.
+    private static abstract class Request {
+
+        private final Callback callback;
+        private final RealmNotifier handler;
+        private final ThreadPoolExecutor networkPoolExecutor;
+
+        public Request(ThreadPoolExecutor networkPoolExecutor, Callback callback) {
+            this.callback = callback;
+            this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());
+            this.networkPoolExecutor = networkPoolExecutor;
+        }
+
+        // Implements the request. Return the current sync user if the request succeeded. Otherwise throw an error.
+        public abstract SyncUser run() throws ObjectServerError;
+
+        // Start the request
+        public RealmAsyncTask start() {
+            Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        postSuccess(Request.this.run());
+                    } catch (ObjectServerError e) {
+                        postError(e);
+                    } catch (Throwable e) {
+                        postError(new ObjectServerError(ErrorCode.UNKNOWN, "Unexpected error", e));
+                    }
+                }
+            });
+            return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);
+        }
+
+        private void postError(final ObjectServerError error) {
+            boolean errorHandled = false;
+            if (callback != null) {
+                Runnable action = new Runnable() {
+                    @Override
+                    public void run() {
+                        callback.onError(error);
+                    }
+                };
+                errorHandled = handler.post(action);
+            }
+
+            if (!errorHandled) {
+                RealmLog.error(error, "An error was thrown, but could not be handled.");
+            }
+        }
+
+        private void postSuccess(final SyncUser user) {
+            if (callback != null) {
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        callback.onSuccess(user);
+                    }
+                });
+            }
+        }
+    }
+
     public interface Callback {
         void onSuccess(SyncUser user);
+
         void onError(ObjectServerError error);
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
index a5ad8e9190..c6d2c47045 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
@@ -24,7 +24,7 @@
 /**
  * Base class for all response types from the Realm Authentication Server.
  */
-public class AuthServerResponse {
+public abstract class AuthServerResponse {
 
     protected ObjectServerError error;
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 3b74558cc6..9b9c24c25e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -56,4 +56,9 @@
      * logged out as well.
      */
     LogoutResponse logout(Token userToken, URL authenticationUrl);
+
+    /**
+     * Changes a user's password.
+     */
+    ChangePasswordResponse changePassword(Token userToken, String newPassword, URL authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
new file mode 100644
index 0000000000..65f4886f47
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import io.realm.internal.objectserver.Token;
+
+/**
+ * This class encapsulates a request to change the password for a user on the Realm Authentication Server. It is
+ * responsible for constructing the JSON understood by the Realm Authentication Server.
+ */
+public class ChangePasswordRequest {
+
+    private final String token;
+    private final String newPassword;
+
+    public static ChangePasswordRequest create(Token userToken, String newPassword) {
+        return new ChangePasswordRequest(userToken.value(), newPassword);
+    }
+
+    private ChangePasswordRequest(String token, String newPassword) {
+        this.token = token;
+        this.newPassword = newPassword;
+    }
+
+    /**
+     * Converts the request into a JSON payload.
+     */
+    public String toJson() {
+        try {
+            JSONObject request = new JSONObject();
+            request.put("token", token);
+            request.put("password", newPassword);
+            return request.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordResponse.java
new file mode 100644
index 0000000000..4fc951d3e5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordResponse.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `/auth/password`
+ */
+public class ChangePasswordResponse extends AuthServerResponse {
+
+    public static ChangePasswordResponse from(Response response) {
+        if (response.isSuccessful()) {
+            return new ChangePasswordResponse();
+        }
+        try {
+            String serverResponse = response.body().string();
+            return new ChangePasswordResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new ChangePasswordResponse(error);
+        }
+    }
+
+    public static ChangePasswordResponse createFailure(ObjectServerError objectServerError) {
+        return new ChangePasswordResponse(objectServerError);
+    }
+
+    private ChangePasswordResponse() {
+        this.error = null;
+    }
+
+    private ChangePasswordResponse(ObjectServerError error) {
+        this.error = error;
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
index 8cb67b56a9..49a30ade75 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
@@ -29,7 +29,7 @@
 
     private final String token;
 
-    public static LogoutRequest revoke(Token userToken) {
+    public static LogoutRequest create(Token userToken) {
         return new LogoutRequest(userToken.value());
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 40148acb8a..46afe6e82c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -36,6 +36,8 @@
 public class OkHttpAuthenticationServer implements AuthenticationServer {
 
     public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
+    private static final String ACTION_LOGOUT = "revoke"; // Auth end point for logging out users
+    private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
 
     private final OkHttpClient client = new OkHttpClient.Builder()
             .connectTimeout(10, TimeUnit.SECONDS)
@@ -79,47 +81,63 @@ public AuthenticateResponse refreshUser(Token userToken, URI serverUrl, URL auth
     @Override
     public LogoutResponse logout(Token userToken, URL authenticationUrl) {
         try {
-            String requestBody = LogoutRequest.revoke(userToken).toJson();
-            return logout(buildLogoutUrl(authenticationUrl), requestBody);
+            String requestBody = LogoutRequest.create(userToken).toJson();
+            return logout(buildActionUrl(authenticationUrl, ACTION_LOGOUT), requestBody);
         } catch (Exception e) {
             return LogoutResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
         }
     }
 
-    private static URL buildLogoutUrl(URL authenticationUrl) {
+    @Override
+    public ChangePasswordResponse changePassword(Token userToken, String newPassword, URL authenticationUrl) {
+        try {
+            String requestBody = ChangePasswordRequest.create(userToken, newPassword).toJson();
+            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), requestBody);
+        } catch (Throwable e) {
+            return ChangePasswordResponse.createFailure(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    // Builds the URL for a specific auth endpoint
+    private static URL buildActionUrl(URL authenticationUrl, String action) {
         final String baseUrlString = authenticationUrl.toExternalForm();
         try {
-            if (baseUrlString.endsWith("/")) {
-                return new URL(baseUrlString + "revoke");
-            } else {
-                return new URL(baseUrlString + "/revoke");
-            }
+            String separator = baseUrlString.endsWith("/") ? "" : "/";
+            return new URL(baseUrlString + separator + action);
         } catch (MalformedURLException e) {
             throw new RuntimeException(e);
         }
     }
 
     private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
-        Request request = new Request.Builder()
-                .url(authenticationUrl)
-                .addHeader("Content-Type", "application/json")
-                .addHeader("Accept", "application/json")
-                .post(RequestBody.create(JSON, requestBody))
-                .build();
+        RealmLog.debug("Network request (authenticate): " + authenticationUrl);
+        Request request = newAuthRequest(authenticationUrl).post(RequestBody.create(JSON, requestBody)).build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return AuthenticateResponse.from(response);
     }
 
     private LogoutResponse logout(URL logoutUrl, String requestBody) throws Exception {
-        Request request = new Request.Builder()
-                .url(logoutUrl)
-                .addHeader("Content-Type", "application/json")
-                .addHeader("Accept", "application/json")
-                .post(RequestBody.create(JSON, requestBody))
-                .build();
+        RealmLog.debug("Network request (logout): " + logoutUrl);
+        Request request = newAuthRequest(logoutUrl).post(RequestBody.create(JSON, requestBody)).build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return LogoutResponse.from(response);
     }
+
+    private ChangePasswordResponse changePassword(URL changePasswordUrl, String requestBody) throws Exception {
+        RealmLog.debug("Network request (changePassword): " + changePasswordUrl);
+        Request request = newAuthRequest(changePasswordUrl).put(RequestBody.create(JSON, requestBody)).build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return ChangePasswordResponse.from(response);
+    }
+
+    private Request.Builder newAuthRequest(URL url) {
+        return new Request.Builder()
+                .url(url)
+                .addHeader("Content-Type", "application/json")
+                .addHeader("Accept", "application/json");
+    }
+
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 354e365a09..6e3373d29a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -1,13 +1,20 @@
 package io.realm.objectserver;
 
+import android.os.Handler;
+import android.os.Looper;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
@@ -17,8 +24,6 @@
 import io.realm.SyncManager;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
-import io.realm.log.LogLevel;
-import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
@@ -35,6 +40,9 @@
     @Rule
     public RunInLooperThread looperThread = new RunInLooperThread();
 
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
     @Test
     public void login_userNotExist() {
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
@@ -126,35 +134,76 @@ public void onError(ObjectServerError error) {
         });
     }
 
-    // The error handler throws an exception but it is ignored (but logged). That means, this test should not
-    // pass and not be stopped by an IllegalArgumentException.
     @Test
-    @RunTestInLooperThread
-    public void loginAsync_errorHandlerThrows() {
-        // set log level to info to make sure the IllegalArgumentException
-        // thrown in the test is visible in Logcat
-        final int defaultLevel = RealmLog.getLevel();
-        RealmLog.setLevel(LogLevel.INFO);
-        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
-            @Override
-            public void onSuccess(SyncUser user) {
-                fail();
-            }
+    public void loginAsync_errorHandlerThrows() throws InterruptedException {
+        final AtomicBoolean errorThrown = new AtomicBoolean(false);
 
+        // Create custom Looper thread to be able to check for errors thrown when processing Looper events.
+        Thread t = new Thread(new Runnable() {
+            private volatile Handler handler;
             @Override
-            public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
-                throw new IllegalArgumentException("BOOM");
+            public void run() {
+                Looper.prepare();
+                try {
+                    handler = new Handler();
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+                            SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+                                @Override
+                                public void onSuccess(SyncUser user) {
+                                    fail();
+                                }
+
+                                @Override
+                                public void onError(ObjectServerError error) {
+                                    assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
+                                    throw new IllegalArgumentException("BOOM");
+                                }
+                            });
+                        }
+                    });
+                    Looper.loop(); //
+                } catch (IllegalArgumentException e) {
+                    errorThrown.set(true);
+                }
             }
         });
+        t.start();
+        t.join(TimeUnit.SECONDS.toMillis(10));
+        assertTrue(errorThrown.get());
+    }
 
-        looperThread.postRunnableDelayed(new Runnable() {
-            @Override
-            public void run() {
-                RealmLog.setLevel(defaultLevel);
-                looperThread.testComplete();
-            }
-        }, 1000);
+    @Test
+    public void changePassword() {
+        String username = UUID.randomUUID().toString();
+        String originalPassword = "password";
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
+        SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userOld.isValid());
+
+        // Change password and try to log in with new password
+        String newPassword = "new-password";
+        userOld.changePassword(newPassword);
+        userOld.logout();
+        credentials = SyncCredentials.usernamePassword(username, newPassword, false);
+        SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        assertTrue(userNew.isValid());
+        assertEquals(userOld.getIdentity(), userNew.getIdentity());
+    }
+
+    @Test
+    public void changePassword_throwWhenUserIsLoggedOut() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        user.logout();
+
+        thrown.expect(ObjectServerError.class);
+        user.changePassword("new-password");
     }
+
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
index 764b511ee7..79081d405a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
@@ -23,16 +23,21 @@
 
 import io.realm.Realm;
 import io.realm.SyncManager;
+import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.HttpUtils;
 
 class BaseIntegrationTest {
 
+    private static int originalLogLevel;
+
     @BeforeClass
     public static void setUp () throws Exception {
         SyncManager.Debug.skipOnlineChecking = true;
         try {
             Realm.init(InstrumentationRegistry.getContext());
+            originalLogLevel = RealmLog.getLevel();
+            RealmLog.setLevel(LogLevel.DEBUG);
             HttpUtils.startSyncServer();
         } catch (Exception e) {
             // Throwing an exception from this method will crash JUnit. Instead just log it.
@@ -45,6 +50,7 @@ public static void setUp () throws Exception {
     public static void tearDown () throws Exception {
         try {
             HttpUtils.stopSyncServer();
+            RealmLog.setLevel(originalLogLevel);
         } catch (Exception e) {
             RealmLog.error("Failed to stop Sync Server", e);
         }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index e5347effc8..02d9ddf64c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -18,9 +18,11 @@
 
 public class Constants {
 
-    public static String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
-    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
+    public static final String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
+    public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
 
-    public static String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
-    public static String AUTH_URL = AUTH_SERVER_URL + "auth";
+    public static final String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
+    public static final String AUTH_URL = AUTH_SERVER_URL + "auth";
+
+    public static final long TEST_TIMEOUT_SECS = 300;
 }
