diff --git a/CHANGELOG.md b/CHANGELOG.md
index e3fee3baeb..5cffb2de46 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -7,6 +7,8 @@
 * Removed deprecated APIs `RealmSchema.close()` and `RealmObjectSchema.close()`. Those don't have to be called anymore.
 * Removed deprecated API `RealmResults.removeChangeListeners()`. Use `RealmResults.removeAllChangeListeners()` instead.
 * Removed deprecated API `RealmObject.removeChangeListeners()`. Use `RealmObject.removeAllChangeListeners()` instead.
+* `SyncUser.Callback` to becomes generic.
+* Removed `SyncUser.getAccessToken` method from public API, and rename it to `getRefreshToken`.
 
 ## Deprecated
 
@@ -33,7 +35,7 @@
 ### Bug Fixes
 
 * Throw `IllegalArgumentException` instead of `IllegalStateException` when calling string/binary data setters if the data length exceeds the limit.
-* Exposing a `RealmConfiguration` that allows a user to open the backup Realm after the client reset (#4759).
+* Exposing a `RealmConfiguration` that allows a user to open the backup Realm after the client reset (#4759/#5223).
 
 ### Internal
 
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
index 73793b1edf..9bf5479f15 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
@@ -78,7 +78,7 @@ public void login(boolean createUser) {
         String password = this.password.getText().toString();
 
         SyncCredentials creds = SyncCredentials.usernamePassword(username, password, createUser);
-        SyncUser.Callback callback = new SyncUser.Callback() {
+        SyncUser.Callback<SyncUser> callback = new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(@Nonnull SyncUser user) {
                 progressDialog.dismiss();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index 7614175792..08fda9f32b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -179,9 +179,7 @@ public void addEmptyRowWithPrimaryKeyLong() {
     public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
         configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
         sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
-        sharedRealm.commitTransaction();
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
         Table t = sharedRealm.getTable("class_AnnotationTypes");
         assertEquals("id", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "AnnotationTypes"));
         assertEquals(RealmFieldType.STRING, sharedRealm.getTable("pk").getColumnType(0));
@@ -191,9 +189,7 @@ public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
     public void migratePrimaryKeyTableIfNeeded_second() throws IOException {
         configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
         sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
-        sharedRealm.commitTransaction();
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
         Table t = sharedRealm.getTable("class_AnnotationTypes");
         assertEquals("id", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "AnnotationTypes"));
         assertEquals("AnnotationTypes", sharedRealm.getTable("pk").getString(0, 0));
@@ -213,9 +209,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName(
 
         configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
         sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
-        sharedRealm.commitTransaction();
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
 
         Table table = sharedRealm.getTable("pk");
         for (int i = 0; i < table.size(); i++) {
@@ -255,13 +249,17 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         } catch (IllegalStateException ignored) {
             // Column has no search index.
         }
+        sharedRealm.commitTransaction();
 
         assertFalse(pkTable.hasSearchIndex(classColumn));
 
         Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
         assertTrue(pkTable.hasSearchIndex(classColumn));
+
+        sharedRealm.beginTransaction();
         // Now it works.
         table2.addSearchIndex(column2);
-        sharedRealm.cancelTransaction();
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable2", "PKColumn");
+        sharedRealm.commitTransaction();
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index d262d92e07..66827fa920 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -32,7 +32,6 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import io.realm.CompactOnLaunchCallback;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index bdadf6211c..a7fff7a2ef 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -39,7 +39,7 @@ public void setUp() {
 
     @Test
     public void realmLogin() throws URISyntaxException, JSONException {
-        Token t = SyncTestUtils.createTestUser().getAccessToken();
+        Token t = SyncTestUtils.createTestUser().getRefreshToken();
         AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default"));
 
         JSONObject obj = new JSONObject(request.toJson());
@@ -60,7 +60,7 @@ public void userLogin() throws URISyntaxException, JSONException {
 
     @Test
     public void userRefresh() throws URISyntaxException, JSONException {
-        Token t = SyncTestUtils.createTestUser().getAccessToken();
+        Token t = SyncTestUtils.createTestUser().getRefreshToken();
         AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default"));
 
         JSONObject obj = new JSONObject(request.toJson());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index c011fa563a..54172550a3 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -274,6 +274,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                         RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
                         assertNotNull(backupRealmConfiguration);
                         assertFalse(backupRealmConfiguration.isSyncConfiguration());
+                        assertTrue(backupRealmConfiguration.isRecoveryConfiguration());
 
                         Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
                         assertFalse(backupRealm.isEmpty());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index c91a7e2def..43339cab79 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -16,12 +16,10 @@
 
 package io.realm;
 
-import android.content.Context;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
@@ -61,13 +59,6 @@
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
-    private Context context;
-
-    @Before
-    public void setUp() {
-        context = InstrumentationRegistry.getContext();
-    }
-
     @After
     public void tearDown() throws Exception {
         SyncManager.reset();
@@ -104,7 +95,7 @@ public void serverUrl_setsFolderAndFileName() {
 
             SyncConfiguration config = new SyncConfiguration.Builder(user, serverUrl).build();
 
-            assertEquals(new File(context.getFilesDir(), expectedFolder), config.getRealmDirectory());
+            assertEquals(new File(InstrumentationRegistry.getContext().getFilesDir(), expectedFolder), config.getRealmDirectory());
             assertEquals(expectedFileName, config.getRealmFileName());
         }
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 2d306e413e..839c935b31 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -166,6 +166,5 @@ public void session() throws IOException {
         assertEquals(user, session.getUser()); // see also SessionTests
 
         realm.close();
-        SyncManager.reset();
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 1c90667d09..5d67f68af5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -50,8 +50,8 @@
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
-import io.realm.objectserver.utils.UserFactory;
 import io.realm.objectserver.utils.StringOnlyModule;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
@@ -382,7 +382,7 @@ public void changePasswordAsync_nonLooperThreadThrows() {
         SyncUser user = createTestUser();
 
         thrown.expect(IllegalStateException.class);
-        user.changePasswordAsync("password", new SyncUser.Callback() {
+        user.changePasswordAsync("password", new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 fail();
@@ -400,7 +400,7 @@ public void changePassword_admin_Async_nonLooperThreadThrows() {
         SyncUser user = createTestUser();
 
         thrown.expect(IllegalStateException.class);
-        user.changePasswordAsync("user-id", "new", new SyncUser.Callback() {
+        user.changePasswordAsync("user-id", "new", new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 fail();
@@ -543,11 +543,11 @@ public void fromJson_WorkWithRemovedObjectServerUser() {
         //       since the user is not persisted in the UserStore
         //       isValid() requires SyncManager.getUserStore().isActive(identity)
         //       to return true as well.
-        Token accessToken = syncUser.getAccessToken();
-        assertNotNull(accessToken);
+        Token refreshToken = syncUser.getRefreshToken();
+        assertNotNull(refreshToken);
         // refresh token should expire in 10 years (July 23, 2027)
         Calendar calendar = Calendar.getInstance();
-        calendar.setTimeInMillis(accessToken.expiresMs());
+        calendar.setTimeInMillis(refreshToken.expiresMs());
         int day = calendar.get(Calendar.DAY_OF_MONTH);
         int month = calendar.get(Calendar.MONTH);
         int year = calendar.get(Calendar.YEAR);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index f866cd1c9b..60b25da8fe 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -19,20 +19,21 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 
 import io.realm.entities.IndexedFields;
-import io.realm.entities.PrimaryKeyAsInteger;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
-import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.OsObjectStore;
+import io.realm.exceptions.IncompatibleSyncedFileException;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
@@ -51,6 +52,14 @@
     @Rule
     public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
+    @BeforeClass
+    public static void beforeClass () {
+        // another Test class may have the BaseRealm.applicationContext set but
+        // the SyncManager reset. This will make assertion to fail, we need to re-initialise
+        // the sync_manager.cpp#m_file_manager (configFactory rule do this)
+        BaseRealm.applicationContext = null;
+    }
+
     @Test
     public void migrateRealm_syncConfigurationThrows() {
         SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth").build();
@@ -296,18 +305,54 @@ public void moreFieldsThanExpectedIsAllowed() {
         realm.close();
     }
 
-    // The stable_id_migration.realm is created with sync v1.8.5 with one object created for each object schema.
     @Test
-    @Ignore("Not supported by sync right now.")
-    public void stableIDMigrationCauseClientReset() throws IOException {
+    public void offlineClientReset() throws IOException {
         SyncConfiguration config = configFactory
                 .createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
-                .schema(StringOnly.class, PrimaryKeyAsString.class, PrimaryKeyAsInteger.class)
-                .name("stable_id_migration.realm")
+                .modules(new StringOnlyModule())
                 .build();
-        configFactory.copyRealmFromAssets(InstrumentationRegistry.getContext(), "stable_id_migration.realm", config);
+
+        String path = config.getPath();
+        File realmFile = new File (path);
+        assertFalse(realmFile.exists());
+        // copy the 1.x Realm
+        configFactory.copyRealmFromAssets(InstrumentationRegistry.getContext(), "sync-1.x.realm", config);
+        assertTrue(realmFile.exists());
+
+        // open the file using the new ROS 2.x server
+        try {
+            Realm.getInstance(config);
+            fail("should throw IncompatibleSyncedFileException");
+        } catch (IncompatibleSyncedFileException expected) {
+            String recoveryPath = expected.getRecoveryPath();
+            assertTrue(new File(recoveryPath).exists());
+            // can open the backup Realm
+            RealmConfiguration backupRealmConfiguration = expected.getBackupRealmConfiguration(null, new StringOnlyModule());
+            Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+            assertFalse(backupRealm.isEmpty());
+            RealmResults<StringOnly> all = backupRealm.where(StringOnly.class).findAll();
+            assertEquals(1, all.size());
+            assertEquals("Hello from ROS 1.X", all.get(0).getChars());
+
+            // make sure it's read only
+            try {
+                backupRealm.beginTransaction();
+                fail("Backup Realm should be read-only, we should throw");
+            } catch (IllegalStateException ignored) {
+            }
+            backupRealm.close();
+
+            // we can open in dynamic mode
+            DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+            dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+            RealmResults<DynamicRealmObject> allDynamic = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+            assertEquals(1, allDynamic.size());
+            assertEquals("Hello from ROS 1.X", allDynamic.first().getString(StringOnly.FIELD_CHARS));
+            dynamicRealm.close();
+        }
+
         Realm realm = Realm.getInstance(config);
-        // TODO: Should the local realm be cleaned? It contains one object for each object schema in the realm.
+        assertTrue(realm.isEmpty());
         realm.close();
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index 167bb3b3a1..97caaa18bd 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -37,10 +37,13 @@
     public static final String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
 
     private final static Method SYNC_MANAGER_GET_USER_STORE_METHOD;
+    private final static Method SYNC_USER_GET_ACCESS_TOKEN_METHOD;
     static {
         try {
             SYNC_MANAGER_GET_USER_STORE_METHOD = SyncManager.class.getDeclaredMethod("getUserStore");
+            SYNC_USER_GET_ACCESS_TOKEN_METHOD = SyncUser.class.getDeclaredMethod("getRefreshToken");
             SYNC_MANAGER_GET_USER_STORE_METHOD.setAccessible(true);
+            SYNC_USER_GET_ACCESS_TOKEN_METHOD.setAccessible(true);
         } catch (NoSuchMethodException e) {
             throw new AssertionError(e);
         }
@@ -106,13 +109,19 @@ public static AuthenticateResponse createErrorResponse(ErrorCode code) {
         return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
     }
 
+    public static Token getRefreshToken(SyncUser user) {
+        try {
+            return (Token) SYNC_USER_GET_ACCESS_TOKEN_METHOD.invoke(user);
+        } catch (IllegalAccessException | InvocationTargetException e) {
+            throw new AssertionError(e);
+        }
+    }
+
     private static void addToUserStore(SyncUser user) {
         try {
             UserStore userStore = (UserStore) SYNC_MANAGER_GET_USER_STORE_METHOD.invoke(null);
             userStore.put(user);
-        } catch (InvocationTargetException e) {
-            throw new AssertionError(e);
-        } catch (IllegalAccessException e) {
+        } catch (InvocationTargetException | IllegalAccessException e) {
             throw new AssertionError(e);
         }
     }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 7cf19d9600..474a4c54cd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -158,20 +158,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsInTransact
     return static_cast<jboolean>(shared_realm->is_in_transaction());
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv* env, jclass,
-                                                                           jlong shared_realm_ptr)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        return reinterpret_cast<jlong>(&shared_realm->read_group());
-    }
-    CATCH_STD()
-
-    return static_cast<jlong>(NULL);
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv* env, jclass,
                                                                             jlong shared_realm_ptr)
 {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index a0f0e96fe4..c078d9d33d 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -20,6 +20,7 @@
 #include "io_realm_internal_Table.h"
 #include "tablebase_tpl.hpp"
 
+#include "shared_realm.hpp"
 #include "util/format.hpp"
 
 #include "java_accessor.hpp"
@@ -37,6 +38,7 @@ static_assert(io_realm_internal_Table_MAX_BINARY_SIZE == Table::max_binary_size,
 
 static const char* c_null_values_cannot_set_required_msg = "The primary key field '%1' has 'null' values stored.  It "
                                                            "cannot be converted to a '@Required' primary key field.";
+static const char* const PK_TABLE_NAME = "pk"; // ObjectStore::c_primaryKeyTableName
 static const size_t CLASS_COLUMN_INDEX = 0; // ObjectStore::c_primaryKeyObjectClassColumnIndex
 static const size_t FIELD_COLUMN_INDEX = 1; // ObjectStore::c_primaryKeyPropertyNameColumnIndex
 
@@ -1096,6 +1098,28 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(JNIEnv*, j
     return to_jbool(TBL(nativeTablePtr)->is_attached()); // noexcept
 }
 
+static bool pk_table_needs_migration(ConstTableRef pk_table)
+{
+    // Fix wrong types (string, int) -> (string, string)
+    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
+        return true;
+    }
+
+    // If needed remove "class_" prefix from class names
+    size_t number_of_rows = pk_table->size();
+    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
+        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
+        if (table_name.begins_with(TABLE_PREFIX)) {
+            return true;
+        }
+    }
+    // From realm-java 2.0.0, pk table's class column requires a search index.
+    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
+        return true;
+    }
+    return false;
+}
+
 // 1) Fixes interop issue with Cocoa Realm where the Primary Key table had different types.
 // This affects:
 // - All Realms created by Cocoa and used by Realm-android up to 0.80.1
@@ -1115,12 +1139,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(JNIEnv*, j
 
 // This methods converts the old (wrong) table format (string, integer) to the right (string,string) format and strips
 // any class names in the col[0] of their "class_" prefix
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded(
-    JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
+static bool migrate_pk_table(const Group& group, TableRef pk_table)
 {
-    auto group = reinterpret_cast<Group*>(groupNativePtr);
-    Table* pk_table = TBL(privateKeyTableNativePtr);
-    jboolean changed = JNI_FALSE;
+    bool changed = false;
 
     // Fix wrong types (string, int) -> (string, string)
     if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
@@ -1132,7 +1153,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
         for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
             StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
             size_t col_ndx = static_cast<size_t>(pk_table->get_int(FIELD_COLUMN_INDEX, row_ndx));
-            StringData col_name = group->get_table(table_name)->get_column_name(col_ndx);
+            StringData col_name = group.get_table(table_name)->get_column_name(col_ndx);
             // Make a copy of the string
             pk_table->set_string(tmp_col_ndx, row_ndx, col_name);
         }
@@ -1141,7 +1162,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
         // The column index for the renamed column will then be the same as the deleted old column
         pk_table->remove_column(FIELD_COLUMN_INDEX);
         pk_table->rename_column(pk_table->get_column_index(tmp_col_name), StringData("pk_property"));
-        changed = JNI_TRUE;
+        changed = true;
     }
 
     // If needed remove "class_" prefix from class names
@@ -1153,41 +1174,42 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
             std::string str(table_name.substr(TABLE_PREFIX.length()));
             StringData sd(str);
             pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, sd);
-            changed = JNI_TRUE;
+            changed = true;
         }
     }
 
     // From realm-java 2.0.0, pk table's class column requires a search index.
     if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
         pk_table->add_search_index(CLASS_COLUMN_INDEX);
-        changed = JNI_TRUE;
+        changed = true;
     }
     return changed;
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv*, jclass, jlong primaryKeyTableNativePtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded(JNIEnv* env, jclass,
+                                                                                         jlong shared_realm_ptr)
 {
-    Table* pk_table = TBL(primaryKeyTableNativePtr);
+    TR_ENTER_PTR(shared_realm_ptr)
+    auto& shared_realm = *reinterpret_cast<SharedRealm*>(shared_realm_ptr);
+    try {
+        if (!shared_realm->read_group().has_table(PK_TABLE_NAME)) {
+            return;
+        }
 
-    // Fix wrong types (string, int) -> (string, string)
-    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
-        return JNI_TRUE;
-    }
+        auto pk_table = shared_realm->read_group().get_table(PK_TABLE_NAME);
+        if (!pk_table_needs_migration(pk_table)) {
+            return;
+        }
 
-    // If needed remove "class_" prefix from class names
-    size_t number_of_rows = pk_table->size();
-    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
-        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
-        if (table_name.begins_with(TABLE_PREFIX)) {
-            return JNI_TRUE;
+        shared_realm->begin_transaction();
+        if (migrate_pk_table(shared_realm->read_group(), pk_table)) {
+            shared_realm->commit_transaction();
+        }
+        else {
+            shared_realm->cancel_transaction();
         }
     }
-    // From realm-java 2.0.0, pk table's class column requires a search index.
-    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
-        return JNI_TRUE;
-    }
-    return JNI_FALSE;
+    CATCH_STD()
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema(JNIEnv*, jobject, jlong thisTablePtr,
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index cdd0d8c82b..317dc9b3d9 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit cdd0d8c82ba6dfb60ebc2c339b26b7b3ca4d4047
+Subproject commit 317dc9b3d9ef1b5de5ace72e05ac6d58e443bef5
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 25c02994e0..72fd8b3ea5 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -20,6 +20,7 @@
 #include <realm/util/assert.hpp>
 #include <realm/util/file.hpp>
 #include <realm/unicode.hpp>
+#include <jni_util/java_method.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
@@ -38,7 +39,7 @@ using namespace realm::util;
 using namespace realm::jni_util;
 using namespace realm::_impl;
 
-void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind, const std::string& path = "");
 
 void ConvertException(JNIEnv* env, const char* file, int line)
 {
@@ -67,7 +68,7 @@ void ConvertException(JNIEnv* env, const char* file, int line)
     }
     catch (RealmFileException& e) {
         ss << e.what() << " (" << e.underlying() << ") (" << e.path() << ") in " << file << " line " << line;
-        ThrowRealmFileException(env, ss.str(), e.kind());
+        ThrowRealmFileException(env, ss.str(), e.kind(), e.path());
     }
     catch (File::AccessError& e) {
         ss << e.what() << " (" << e.get_path() << ") in " << file << " line " << line;
@@ -195,11 +196,11 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
     env->DeleteLocalRef(jExceptionClass);
 }
 
-void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind)
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind, const std::string& path)
 {
-    jclass cls = env->FindClass("io/realm/exceptions/RealmFileException");
+    static JavaClass  jrealm_file_exception_cls(env, "io/realm/exceptions/RealmFileException");
+    static JavaMethod constructor(env, jrealm_file_exception_cls, "<init>", "(BLjava/lang/String;)V");
 
-    jmethodID constructor = env->GetMethodID(cls, "<init>", "(BLjava/lang/String;)V");
     // Initial value to suppress gcc warning.
     jbyte kind_code = -1; // To suppress compile warning.
     switch (kind) {
@@ -225,13 +226,24 @@ void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::Rea
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED;
             break;
         case realm::RealmFileException::Kind::IncompatibleSyncedRealm:
-            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE;
-            break;
-    }
-    jstring jstr = env->NewStringUTF(message.c_str());
-    jobject exception = env->NewObject(cls, constructor, kind_code, jstr);
+#if REALM_ENABLE_SYNC
+            static JavaClass jincompatible_synced_file_cls(env,
+                                                           "io/realm/exceptions/IncompatibleSyncedFileException");
+            static JavaMethod jicompatible_synced_ctor(env, jincompatible_synced_file_cls, "<init>",
+                                                       "(Ljava/lang/String;Ljava/lang/String;)V");
+            jobject jexception = env->NewObject(jincompatible_synced_file_cls, jicompatible_synced_ctor,
+                                                to_jstring(env, message), to_jstring(env, path));
+            env->Throw(reinterpret_cast<jthrowable>(jexception));
+            env->DeleteLocalRef(jexception);
+            return;
+#else
+            REALM_ASSERT_RELEASE_EX(false, "'IncompatibleSyncedRealm' should not be thrown for non-sync realm.");
+#endif
+    }
+    jstring jmessage = to_jstring(env, message);
+    jstring jpath = to_jstring(env, path);
+    jobject exception = env->NewObject(jrealm_file_exception_cls, constructor, kind_code, jmessage, jpath);
     env->Throw(reinterpret_cast<jthrowable>(exception));
-    env->DeleteLocalRef(cls);
     env->DeleteLocalRef(exception);
 }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 1044874e21..7adc914661 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -315,15 +315,7 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
                     if (fileExists) {
                         // Primary key problem only exists before we release sync.
                         sharedRealm = SharedRealm.getInstance(configuration);
-
-                        if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
-                            sharedRealm.beginTransaction();
-                            if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
-                                sharedRealm.commitTransaction();
-                            } else {
-                                sharedRealm.cancelTransaction();
-                            }
-                        }
+                        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
                     }
                 }
             } finally {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index b6546f405a..6678fe935d 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -101,6 +101,11 @@
     private final Realm.Transaction initialDataTransaction;
     private final boolean readOnly;
     private final CompactOnLaunchCallback compactOnLaunch;
+    /**
+     * Whether this RealmConfiguration is intended to open a
+     * recovery Realm produced after an offline/online client reset.
+     */
+    private final boolean isRecoveryConfiguration;
 
     // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
     // subsets of them.
@@ -117,7 +122,8 @@ protected RealmConfiguration(@Nullable File realmDirectory,
             @Nullable RxObservableFactory rxObservableFactory,
             @Nullable Realm.Transaction initialDataTransaction,
             boolean readOnly,
-            @Nullable CompactOnLaunchCallback compactOnLaunch) {
+            @Nullable CompactOnLaunchCallback compactOnLaunch,
+            boolean isRecoveryConfiguration) {
         this.realmDirectory = realmDirectory;
         this.realmFileName = realmFileName;
         this.canonicalPath = canonicalPath;
@@ -132,6 +138,7 @@ protected RealmConfiguration(@Nullable File realmDirectory,
         this.initialDataTransaction = initialDataTransaction;
         this.readOnly = readOnly;
         this.compactOnLaunch = compactOnLaunch;
+        this.isRecoveryConfiguration = isRecoveryConfiguration;
     }
 
     public File getRealmDirectory() {
@@ -266,6 +273,14 @@ public boolean isReadOnly() {
         return readOnly;
     }
 
+    /**
+     * @return {@code true} if this configuration is intended to open a backup Realm (as a result of a client reset).
+     * @see <a href="https://realm.io/docs/java/latest/api/io/realm/ClientResetRequiredError.html">ClientResetRequiredError</a>
+     */
+    public boolean isRecoveryConfiguration() {
+        return isRecoveryConfiguration;
+    }
+
     @Override
     public boolean equals(Object obj) {
         if (this == obj) { return true; }
@@ -276,6 +291,7 @@ public boolean equals(Object obj) {
         if (schemaVersion != that.schemaVersion) { return false; }
         if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) { return false; }
         if (readOnly != that.readOnly) { return false; }
+        if (isRecoveryConfiguration != that.isRecoveryConfiguration) { return false; }
         if (realmDirectory != null ? !realmDirectory.equals(that.realmDirectory) : that.realmDirectory != null) {
             return false;
         }
@@ -317,6 +333,7 @@ public int hashCode() {
         result = 31 * result + (initialDataTransaction != null ? initialDataTransaction.hashCode() : 0);
         result = 31 * result + (readOnly ? 1 : 0);
         result = 31 * result + (compactOnLaunch != null ? compactOnLaunch.hashCode() : 0);
+        result = 31 * result + (isRecoveryConfiguration ? 1 : 0);
         return result;
     }
 
@@ -802,7 +819,8 @@ public RealmConfiguration build() {
                     rxFactory,
                     initialDataTransaction,
                     readOnly,
-                    compactOnLaunch
+                    compactOnLaunch,
+                    false
             );
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index 24eb5faa8d..f83f4f765c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -187,8 +187,10 @@ private OsRealmConfig(final RealmConfiguration config,
 
         // Set schema related params.
         SchemaMode schemaMode = SchemaMode.SCHEMA_MODE_MANUAL;
-        if (config.isReadOnly()) {
+        if (config.isRecoveryConfiguration()) {
             schemaMode = SchemaMode.SCHEMA_MODE_IMMUTABLE;
+        } else if (config.isReadOnly()) {
+            schemaMode = SchemaMode.SCHEMA_MODE_READONLY;
         } else if (syncRealmUrl != null) {
             schemaMode = SchemaMode.SCHEMA_MODE_ADDITIVE;
         } else if (config.shouldDeleteRealmIfMigrationNeeded()) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 6165ce00d0..13ac86c7d8 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -243,11 +243,6 @@ public boolean isInTransaction() {
         return nativeIsInTransaction(nativePtr);
     }
 
-    // FIXME: This should be removed, migratePrimaryKeyTableIfNeeded is using it which should be in Object Store instead?
-    long getGroupNative() {
-        return nativeReadGroup(nativePtr);
-    }
-
     public boolean hasTable(String name) {
         return nativeHasTable(nativePtr, name);
     }
@@ -497,8 +492,6 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
 
     private static native boolean nativeIsInTransaction(long nativeSharedRealmPtr);
 
-    private static native long nativeReadGroup(long nativeSharedRealmPtr);
-
     private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
 
     private static native void nativeRefresh(long nativeSharedRealmPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index cb2f9b551f..31c004a77d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -39,8 +39,6 @@
     public static final boolean NOT_NULLABLE = false;
     public static final int NO_MATCH = -1;
 
-    static final String PRIMARY_KEY_TABLE_NAME = "pk";
-
     public static final int MAX_BINARY_SIZE = 0xFFFFF8 - 8/*array header size*/;
     public static final int MAX_STRING_SIZE = 0xFFFFF8 - 8/*array header size*/ - 1;
 
@@ -500,24 +498,12 @@ public void removeSearchIndex(long columnIndex) {
      * 2) Migration required to fix: https://github.com/realm/realm-java/issues/1703
      * This will remove the prefix "class_" from all table names in the pk_column
      * Any database created on Realm-Java 0.84.1 and below will have this error.
+     *
+     * The native method will begin a transaction and make the migration if needed.
+     * This function should not be called in a transaction.
      */
-    public static boolean migratePrimaryKeyTableIfNeeded(SharedRealm sharedRealm) {
-        if (sharedRealm == null || !sharedRealm.isInTransaction()) {
-            throwImmutable();
-        }
-        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
-            return false;
-        }
-        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
-        return nativeMigratePrimaryKeyTableIfNeeded(sharedRealm.getGroupNative(), pkTable.nativePtr);
-    }
-
-    public static boolean primaryKeyTableNeedsMigration(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
-            return false;
-        }
-        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
-        return nativePrimaryKeyTableNeedsMigration(pkTable.nativePtr);
+    public static void migratePrimaryKeyTableIfNeeded(SharedRealm sharedRealm) {
+        nativeMigratePrimaryKeyTableIfNeeded(sharedRealm.getNativePtr());
     }
 
     public boolean hasSearchIndex(long columnIndex) {
@@ -772,9 +758,7 @@ public static String getTableNameForClass(String name) {
 
     public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
 
-    private static native boolean nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
-
-    private static native boolean nativePrimaryKeyTableNeedsMigration(long primaryKeyTableNativePtr);
+    private static native void nativeMigratePrimaryKeyTableIfNeeded(long sharedRealmPtr);
 
     private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 3659767dc9..2b69a760a0 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -131,7 +131,8 @@ private SyncConfiguration(File directory,
                 rxFactory,
                 initialDataTransaction,
                 readOnly,
-                null
+                null,
+                false
         );
 
         this.user = user;
@@ -188,7 +189,7 @@ public static RealmConfiguration forRecovery(String canonicalPath) {
     }
 
     static RealmConfiguration forRecovery(String canonicalPath, @Nullable byte[] encryptionKey, RealmProxyMediator schemaMediator) {
-        return new RealmConfiguration(null,null, canonicalPath,null, encryptionKey, 0,null, false, OsRealmConfig.Durability.FULL, schemaMediator, null, null, true, null);
+        return new RealmConfiguration(null,null, canonicalPath,null, encryptionKey, 0,null, false, OsRealmConfig.Durability.FULL, schemaMediator, null, null, true, null, true);
     }
 
     static URI resolveServerUrl(URI serverUrl, String userIdentifier) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 4387d8e26a..102eaba041 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -504,7 +504,7 @@ String getAccessToken(final AuthenticationServer authServer, String refreshToken
                 try {
                     JSONObject refreshTokenJSON = new JSONObject(refreshToken);
                     Token newRefreshToken = Token.from(refreshTokenJSON.getJSONObject("userToken"));
-                    if (newRefreshToken.hashCode() != getUser().getAccessToken().hashCode()) {
+                    if (newRefreshToken.hashCode() != getUser().getRefreshToken().hashCode()) {
                         RealmLog.debug("Session[%s]: Access token updated", configuration.getPath());
                         getUser().setRefreshToken(newRefreshToken);
                     }
@@ -551,7 +551,7 @@ private void authenticateRealm(final AuthenticationServer authServer) {
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
                     return authServer.loginToRealm(
-                            getUser().getAccessToken(), //refresh token in fact
+                            getUser().getRefreshToken(), //refresh token in fact
                             configuration.getServerUrl(),
                             getUser().getAuthenticationUrl()
                     );
@@ -629,7 +629,7 @@ private void refreshAccessToken(final AuthenticationServer authServer) {
             @Override
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                    return authServer.refreshUser(getUser().getAccessToken(), configuration.getServerUrl(), getUser().getAuthenticationUrl());
+                    return authServer.refreshUser(getUser().getRefreshToken(), configuration.getServerUrl(), getUser().getAuthenticationUrl());
                 }
                 return null;
             }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 2b24ec28d4..0a69915366 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -47,7 +47,6 @@
 import io.realm.internal.network.LookupUserIdResponse;
 import io.realm.internal.objectserver.Token;
 import io.realm.internal.permissions.ManagementModule;
-import io.realm.internal.permissions.PermissionModule;
 import io.realm.log.RealmLog;
 
 /**
@@ -221,9 +220,9 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
      * @return representation of the async task that can be used to cancel it if needed.
      * @throws IllegalArgumentException if not on a Looper thread.
      */
-    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback callback) {
+    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback<SyncUser> callback) {
         checkLooperThread("Asynchronous login is only possible from looper threads.");
-        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
             @Override
             public SyncUser run() throws ObjectServerError {
                 return login(credentials, authenticationUrl);
@@ -375,13 +374,13 @@ public void changePassword(final String userId, final String newPassword) throws
      * @return representation of the async task that can be used to cancel it if needed.
      * @throws IllegalArgumentException if not on a Looper thread.
      */
-    public RealmAsyncTask changePasswordAsync(final String newPassword, final Callback callback) {
+    public RealmAsyncTask changePasswordAsync(final String newPassword, final Callback<SyncUser> callback) {
         checkLooperThread("Asynchronous changing password is only possible from looper threads.");
         //noinspection ConstantConditions
         if (callback == null) {
             throw new IllegalArgumentException("Non-null 'callback' required.");
         }
-        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
             @Override
             public SyncUser run() {
                 changePassword(newPassword);
@@ -405,14 +404,14 @@ public SyncUser run() {
      * @return representation of the async task that can be used to cancel it if needed.
      * @throws IllegalArgumentException if not on a Looper thread.
      */
-    public RealmAsyncTask changePasswordAsync(final String userId, final String newPassword, final Callback callback) {
+    public RealmAsyncTask changePasswordAsync(final String userId, final String newPassword, final Callback<SyncUser> callback) {
         checkLooperThread("Asynchronous changing password is only possible from looper threads.");
         //noinspection ConstantConditions
         if (callback == null) {
             throw new IllegalArgumentException("Non-null 'callback' required.");
         }
 
-        return new Request(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
             @Override
             public SyncUser run() {
                 changePassword(userId, newPassword);
@@ -470,7 +469,7 @@ public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final
      * as this method is called on.
      * @return representation of the async task that can be used to cancel it if needed.
      */
-    public RealmAsyncTask retrieveInfoForUserAsync(final String providerUserIdentity, final String provider, final RequestCallback<SyncUserInfo> callback) {
+    public RealmAsyncTask retrieveInfoForUserAsync(final String providerUserIdentity, final String provider, final Callback<SyncUserInfo> callback) {
         checkLooperThread("Asynchronously retrieving user is only possible from looper threads.");
         //noinspection ConstantConditions
         if (callback == null) {
@@ -478,12 +477,8 @@ public RealmAsyncTask retrieveInfoForUserAsync(final String providerUserIdentity
         }
 
         return new Request<SyncUserInfo>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
-            // TODO remove this override on next major release when we remove the deprecated Callback
             @Override
-            public SyncUser run() {return null;}
-
-            @Override
-            public SyncUserInfo execute() throws ObjectServerError {
+            public SyncUserInfo run() throws ObjectServerError {
                 return retrieveInfoForUser(providerUserIdentity, provider);
             }
         }.start();
@@ -553,12 +548,12 @@ public String getIdentity() {
     }
 
     /**
-     * Returns this user's access token. This is the users credential for accessing the Realm Object Server and should
+     * Returns this user's refresh token. This is the users credential for accessing the Realm Object Server and should
      * be treated as sensitive data.
      *
-     * @return the user's access token. If this user has logged out or the login has expired {@code null} is returned.
+     * @return the user's refresh token. If this user has logged out or the login has expired {@code null} is returned.
      */
-    public Token getAccessToken() {
+    Token getRefreshToken() {
         return refreshToken;
     }
 
@@ -685,32 +680,19 @@ public String toString() {
     // Class wrapping requests made against the auth server. Is also responsible for calling with success/error on the
     // correct thread.
     private static abstract class Request<T> {
-
         @Nullable
-        private final Callback callback;
-        @Nullable
-        private final RequestCallback<T> genericCallback;
+        private final Callback<T> callback;
         private final RealmNotifier handler;
         private final ThreadPoolExecutor networkPoolExecutor;
 
-        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable Callback callback) {
+        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable Callback<T> callback) {
             this.callback = callback;
-            this.genericCallback = null;
-            this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());
-            this.networkPoolExecutor = networkPoolExecutor;
-        }
-
-        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable RequestCallback<T> callback) {
-            this.callback = null;
-            this.genericCallback = callback;
             this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());
             this.networkPoolExecutor = networkPoolExecutor;
         }
 
         // Implements the request. Return the current sync user if the request succeeded. Otherwise throw an error.
-        public abstract SyncUser run() throws ObjectServerError;
-        //TODO next major release, remove run, rename execute to run and make it abstract
-        public T execute() throws ObjectServerError {return null;}
+        public abstract T run() throws ObjectServerError;
 
         // Start the request
         public RealmAsyncTask start() {
@@ -718,13 +700,7 @@ public RealmAsyncTask start() {
                 @Override
                 public void run() {
                     try {
-                        // co-exist the old and new callback
-                        if (genericCallback != null) {
-                            postSuccess(Request.this.execute());
-                        } else {
-                            postSuccess(Request.this.run());
-                        }
-
+                        postSuccess(Request.this.run());
                     } catch (ObjectServerError e) {
                         postError(e);
                     } catch (Throwable e) {
@@ -752,45 +728,19 @@ public void run() {
             }
         }
 
-        private void postSuccess(final SyncUser user) {
-            if (callback != null) {
-                handler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        callback.onSuccess(user);
-                    }
-                });
-            }
-        }
-
         private void postSuccess(final T result) {
-            if (genericCallback != null) {
+            if (callback != null) {
                 handler.post(new Runnable() {
                     @Override
                     public void run() {
-                        genericCallback.onSuccess(result);
+                        callback.onSuccess(result);
                     }
                 });
             }
         }
     }
 
-    // TODO remove and replace uses by RequestCallback on next major release
-    public interface Callback {
-        /**
-         * @deprecated as per 3.6.0 release, replaced by {@link RequestCallback#onSuccess(Object)}
-         */
-        @Deprecated
-        void onSuccess(SyncUser user);
-
-        /**
-         * @deprecated as per 3.6.0 release, replaced by {@link RequestCallback#onError(ObjectServerError)}
-         */
-        @Deprecated
-        void onError(ObjectServerError error);
-    }
-
-    public interface RequestCallback<T> {
+    public interface Callback<T> {
         void onSuccess(T result);
 
         void onError(ObjectServerError error);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/exceptions/IncompatibleSyncedFileException.java b/realm/realm-library/src/objectServer/java/io/realm/exceptions/IncompatibleSyncedFileException.java
new file mode 100644
index 0000000000..2742b11ac7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/exceptions/IncompatibleSyncedFileException.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmModel;
+import io.realm.SyncConfiguration;
+import io.realm.internal.Keep;
+
+/**
+ * An exception thrown when attempting to open an incompatible Synchronized Realm file. This usually happens
+ * when the Realm file was created with an older version of the SDK and automatic migration to the current version
+ * is not possible. When such an exception occurs, the original file is moved to a backup location and a new file is
+ * created instead. If you wish to migrate any data from the backup location, you can use {@link #getBackupRealmConfiguration()}
+ * to obtain a {@link RealmConfiguration} that can then be used to open the backup Realm. After that, retry
+ * opening the original Realm file (which now should be recreated as an empty file) and copy all data from the backup file to the new one.
+ * <pre>
+ * {@code
+ *  SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, serverUri).build();
+ *  try {
+ *      Realm realm = Realm.getInstance(syncConfig);
+ *  } catch (IncompatibleSyncedFileException exception) {
+ *      RealmConfiguration backupConfig = exception.getBackupRealmConfiguration();
+ *      Realm backupRealm = Realm.getInstance(backupConfig);
+ *      realm = Realm.GetInstance(syncConfig);
+ *  }
+ * }
+ * </pre>
+ */
+@Keep
+public class IncompatibleSyncedFileException extends RealmFileException {
+    private final String path;
+
+    public IncompatibleSyncedFileException(String message, String recoveryPath) {
+        super(Kind.INCOMPATIBLE_SYNC_FILE, message);
+        this.path = recoveryPath;
+    }
+
+    /**
+     * Gets a {@link RealmConfiguration} instance that can be used to open the backup Realm file.
+     *
+     * Note: This will use the default Realm module (composed of all {@link RealmModel}), and
+     * assume no encryption should be used as well.
+     *
+     * @return A configuration object for the backup Realm.
+     */
+    public RealmConfiguration getBackupRealmConfiguration() {
+        return SyncConfiguration.forRecovery(path, null);
+    }
+
+    /**
+     * Gets a {@link RealmConfiguration} instance that can be used to open the backup Realm file.
+     *
+     * Note: This will use the default Realm module (composed of all {@link RealmModel}).
+     *
+     * @param encryptionKey Optional encryption key that was used to encrypt the original Realm file.
+     * @return A configuration object for the backup Realm.
+     */
+    public RealmConfiguration getBackupRealmConfiguration(@Nullable byte[] encryptionKey) {
+        return SyncConfiguration.forRecovery(path, encryptionKey);
+    }
+
+    /**
+     * Gets a {@link RealmConfiguration} instance that can be used to open the backup Realm file.
+     *
+     * @param encryptionKey Optional encryption key that was used to encrypt the original Realm file.
+     * @param modules restricts Realm schema to the provided module.
+     * @return A configuration object for the backup Realm.
+     */
+    public RealmConfiguration getBackupRealmConfiguration(@Nullable byte[] encryptionKey, Object... modules) {
+        return SyncConfiguration.forRecovery(path, encryptionKey, modules);
+    }
+
+    /**
+     * @return Absolute path to the backup Realm file.
+     */
+    public String getRecoveryPath() {
+        return path;
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/stable_id_migration.realm b/realm/realm-library/src/syncIntegrationTest/assets/sync-1.x.realm
similarity index 64%
rename from realm/realm-library/src/androidTestObjectServer/assets/stable_id_migration.realm
rename to realm/realm-library/src/syncIntegrationTest/assets/sync-1.x.realm
index cda2d88456..3f7404b42e 100644
Binary files a/realm/realm-library/src/androidTestObjectServer/assets/stable_id_migration.realm and b/realm/realm-library/src/syncIntegrationTest/assets/sync-1.x.realm differ
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 256df2f2aa..fddc2c5ea5 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -40,6 +40,7 @@
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
@@ -74,7 +75,7 @@ public void login_userNotExist() {
     @RunTestInLooperThread
     public void loginAsync_userNotExist() {
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 fail();
@@ -93,7 +94,7 @@ public void onError(ObjectServerError error) {
     public void login_newUser() {
         String userId = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(userId, "password", true);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertFalse(user.isAdmin());
@@ -116,8 +117,8 @@ public void onError(ObjectServerError error) {
     @RunTestInLooperThread
     public void login_withAccessToken() {
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncCredentials credentials = SyncCredentials.accessToken(adminUser.getAccessToken().value(), "custom-admin-user", adminUser.isAdmin());
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+        SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(adminUser).value(), "custom-admin-user", adminUser.isAdmin());
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertTrue(user.isAdmin());
@@ -159,7 +160,7 @@ public void run() {
                         @Override
                         public void run() {
                             SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-                            SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+                            SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
                                 @Override
                                 public void onSuccess(SyncUser user) {
                                     fail();
@@ -248,7 +249,7 @@ public void changePassword_using_admin_async() {
 
         // Change password using admin user
         final String newPassword = "new-password";
-        adminUser.changePasswordAsync(userOld.getIdentity(), newPassword, new SyncUser.Callback() {
+        adminUser.changePasswordAsync(userOld.getIdentity(), newPassword, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser administratorUser) {
                 assertEquals(adminUser, administratorUser);
@@ -497,7 +498,7 @@ public void revokedRefreshTokenIsNotSameAfterLogin() throws InterruptedException
 
         final SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
         SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        final Token revokedRefreshToken = user.getAccessToken();
+        final Token revokedRefreshToken = SyncTestUtils.getRefreshToken(user);
 
         SyncManager.addAuthenticationListener(new AuthenticationListener() {
             @Override
@@ -511,11 +512,12 @@ public void loggedOut(SyncUser user) {
                 SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
                 SyncUser loggedInUser = SyncUser.login(credentials, Constants.AUTH_URL);
 
+                Token token = SyncTestUtils.getRefreshToken(loggedInUser);
                 // still comparing the same user
-                assertEquals(revokedRefreshToken.identity(), loggedInUser.getAccessToken().identity());
+                assertEquals(revokedRefreshToken.identity(), token.identity());
 
                 // different tokens
-                assertNotEquals(revokedRefreshToken.value(), loggedInUser.getAccessToken().value());
+                assertNotEquals(revokedRefreshToken.value(), token.value());
                 SyncManager.removeAuthenticationListener(this);
                 userLoggedInAgain.countDown();
             }
@@ -591,7 +593,7 @@ public void execute(Realm realm) {
         assertNotEquals(accessToken, newAccessToken);
 
         // refresh_token identity is the same
-        assertEquals(user.getAccessToken().identity(), newAccessToken.identity());
+        assertEquals(SyncTestUtils.getRefreshToken(user).identity(), newAccessToken.identity());
         assertEquals(accessToken.identity(), newAccessToken.identity());
 
         realm.close();
@@ -728,7 +730,7 @@ public void retrieve_async() {
         assertTrue(adminUser.isAdmin());
 
         final String identity = user.getIdentity();
-        adminUser.retrieveInfoForUserAsync(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD, new SyncUser.RequestCallback<SyncUserInfo>() {
+        adminUser.retrieveInfoForUserAsync(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD, new SyncUser.Callback<SyncUserInfo>() {
             @Override
             public void onSuccess(SyncUserInfo userInfo) {
                 assertNotNull(userInfo);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 7806b4158b..d51f3520f0 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -24,6 +24,7 @@
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
+import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -187,7 +188,7 @@ public void onError(SyncSession session, ObjectServerError error) {
 
         // STEP 3: prepare a synced Realm for client B (admin user)
         SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+        SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
         SyncUser adminUser = SyncUser.login(credentials, Constants.AUTH_URL);
 
         final byte[] adminRandomKey = TestHelper.getRandomKey();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
index a51e9b97d1..b260e71ccb 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
@@ -12,16 +12,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.CountDownLatch;
 import java.util.Arrays;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 
-import io.realm.BaseIntegrationTest;
 import io.realm.Realm;
-import io.realm.StandardIntegrationTest;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
@@ -34,11 +32,12 @@
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestSyncConfigurationFactory;
+import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
@@ -222,9 +221,11 @@ public void logout_sameSyncUserMultipleSessions() {
         credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
         SyncUser.login(credentials, Constants.AUTH_URL);
 
-        // reviving the sessions
-        assertEquals(SyncSession.State.WAITING_FOR_ACCESS_TOKEN, session1.getState());
-        assertEquals(SyncSession.State.WAITING_FOR_ACCESS_TOKEN, session2.getState());
+        // reviving the sessions. The state could be changed concurrently.
+        assertTrue(session1.getState() == SyncSession.State.WAITING_FOR_ACCESS_TOKEN ||
+                session1.getState() == SyncSession.State.ACTIVE);
+        assertTrue(session2.getState() == SyncSession.State.WAITING_FOR_ACCESS_TOKEN ||
+                session2.getState() == SyncSession.State.ACTIVE);
 
         realm1.close();
         realm2.close();
@@ -275,7 +276,7 @@ public void run() {
                 // access the Realm from an different path on the device (using admin user), then monitor
                 // when the offline commits get synchronized
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
                 SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
 
                 SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
@@ -349,7 +350,7 @@ public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
             public void run() {
                 // using an admin user to open the Realm on different path on the device to monitor when all the uploads are done
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
                 SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
 
                 SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
@@ -420,7 +421,7 @@ public void downloadChangesWhenRealmOutOfScope() throws InterruptedException {
             public void run() {
                 // using an admin user to open the Realm on different path on the device then some commits
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
                 SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
 
                 SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
