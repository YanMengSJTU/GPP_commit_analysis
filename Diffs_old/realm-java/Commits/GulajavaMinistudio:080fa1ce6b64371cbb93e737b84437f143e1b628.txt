diff --git a/CHANGELOG.md b/CHANGELOG.md
index cd67e02160..f0f357215f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,10 +1,16 @@
 ## 3.6.0 (YYYY-MM-DD)
 
+### Deprecated
+
+* [ObjectServer] `SyncUser#retrieveUser` and `SyncUser#retrieveUserAsync` replaced by `SyncUser#retrieveInfoForUser`
+and `SyncUser#retrieveInfoForUserAsync` which returns a `SyncUserInfo` with mode information (#5008).
+* [ObjectServer] `SyncUser#Callback` replaced by the generic version `SyncUser#RequestCallback<T>`.
+
 ### Enhancements
 
 * [ObjectServer] Added `SyncSession.uploadAllLocalChanges()`.
 * [ObjectServer] APIs of `UserStore` have been changed to support same user identity but different authentication server scenario.
-* [ObjectServer] Added `SyncUser.allSessions` to retrive the all valid sessions belonging to the user (#4783).
+* [ObjectServer] Added `SyncUser.allSessions` to retrieve the all valid sessions belonging to the user (#4783).
 * Added `Nullable` annotation to methods that may return `null` in order to improve Kotlin usability. This also introduced a dependency to `com.google.code.findbugs:jsr305`.
 * Added support for new data type `MutableRealmIntegers`. The new type behaves almost exactly as a reference to a Long (mutable nullable, etc) but supports `increment` and `decrement` methods, which implement a Conflict Free Replicated Data Type, whose value will converge even when changed across distributed devices with poor connections (#4266).
 
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index d512f1f1be..878e159108 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.3-2'
+    ext.kotlin_version = '1.1.4-2'
     repositories {
         jcenter()
         mavenCentral()
diff --git a/realm/build.gradle b/realm/build.gradle
index 16505e4245..6dc878c41b 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.3-2'
+    ext.kotlin_version = '1.1.4-2'
     repositories {
         mavenLocal()
         google()
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index e4ddc6a961..7f8e82aa4f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -444,7 +444,9 @@ public SyncUser run() {
      * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
      * of an {@code invalid} provider or {@code providerId}.
      * @throws ObjectServerError in case of an error.
+     * @deprecated as of release 3.6.0, replaced by {@link #retrieveInfoForUser(String, String)}}
      */
+    @Deprecated
     public SyncUser retrieveUser(final String provider, final String providerId) throws ObjectServerError {
         if (Util.isEmptyString(provider)) {
             throw new IllegalArgumentException("Not-null 'provider' required.");
@@ -495,7 +497,9 @@ public SyncUser retrieveUser(final String provider, final String providerId) thr
      * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
      * as this method is called on.
      * @return representation of the async task that can be used to cancel it if needed.
+     * @deprecated as of release 3.6.0, replaced by {@link #retrieveInfoForUserAsync(String, String, RequestCallback)}}
      */
+    @Deprecated
     public RealmAsyncTask retrieveUserAsync(final String provider, final String providerId, final Callback callback) {
         checkLooperThread("Asynchronously retrieving user id is only possible from looper threads.");
         //noinspection ConstantConditions
@@ -511,6 +515,80 @@ public SyncUser run() {
         }.start();
     }
 
+    /**
+     * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), look up and return user information for that user.
+     *
+     * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
+     *                             In most cases this is different from the Realm Object Server-issued identity.
+     * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
+     *
+     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
+     * of an {@code invalid} provider or {@code providerId}.
+     * @throws ObjectServerError in case of an error.
+     */
+    public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final String provider) throws ObjectServerError {
+        if (Util.isEmptyString(providerUserIdentity)) {
+            throw new IllegalArgumentException("'providerUserIdentity' cannot be empty.");
+        }
+
+        if (Util.isEmptyString(provider)) {
+            throw new IllegalArgumentException("'provider' cannot be empty.");
+        }
+
+        if (!isAdmin()) {
+            throw new IllegalArgumentException("SyncUser needs to be admin in order to lookup other users ID.");
+        }
+
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        LookupUserIdResponse response = authServer.retrieveUser(getSyncUser().getUserToken(), provider, providerUserIdentity, getAuthenticationUrl());
+        if (!response.isValid()) {
+            // the endpoint returns a 404 if it can't honor the query, either because
+            // - provider is not valid
+            // - provider_id is not valid
+            // - token used is not an admin one
+            // in this case we should return null instead of throwing
+            if (response.getError().getErrorCode() == ErrorCode.NOT_FOUND) {
+                return null;
+            } else {
+                throw response.getError();
+            }
+        } else {
+            return SyncUserInfo.fromLookupUserIdResponse(response);
+        }
+    }
+
+    /**
+     * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), asynchronously look up and return user information for that user.
+     *
+     * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
+     *                             In most cases this is different from the Realm Object Server-issued identity.
+     * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
+     *
+     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
+     * of an {@code invalid} provider or {@code providerId}.
+     * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     */
+    public RealmAsyncTask retrieveInfoForUserAsync(final String providerUserIdentity, final String provider, final RequestCallback<SyncUserInfo> callback) {
+        checkLooperThread("Asynchronously retrieving user is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<SyncUserInfo>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            // TODO remove this override on next major release when we remove the deprecated Callback
+            @Override
+            public SyncUser run() {return null;}
+
+            @Override
+            public SyncUserInfo execute() throws ObjectServerError {
+                return retrieveInfoForUser(providerUserIdentity, provider);
+            }
+        }.start();
+    }
+
     private static void checkLooperThread(String errorMessage) {
         AndroidCapabilities capabilities = new AndroidCapabilities();
         capabilities.checkCanDeliverNotification(errorMessage);
@@ -657,21 +735,33 @@ ObjectServerUser getSyncUser() {
 
     // Class wrapping requests made against the auth server. Is also responsible for calling with success/error on the
     // correct thread.
-    private static abstract class Request {
+    private static abstract class Request<T> {
 
         @Nullable
         private final Callback callback;
+        @Nullable
+        private final RequestCallback<T> genericCallback;
         private final RealmNotifier handler;
         private final ThreadPoolExecutor networkPoolExecutor;
 
-        public Request(ThreadPoolExecutor networkPoolExecutor, @Nullable Callback callback) {
+        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable Callback callback) {
             this.callback = callback;
+            this.genericCallback = null;
+            this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());
+            this.networkPoolExecutor = networkPoolExecutor;
+        }
+
+        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable RequestCallback<T> callback) {
+            this.callback = null;
+            this.genericCallback = callback;
             this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());
             this.networkPoolExecutor = networkPoolExecutor;
         }
 
         // Implements the request. Return the current sync user if the request succeeded. Otherwise throw an error.
         public abstract SyncUser run() throws ObjectServerError;
+        //TODO next major release, remove run, rename execute to run and make it abstract
+        public T execute() throws ObjectServerError {return null;}
 
         // Start the request
         public RealmAsyncTask start() {
@@ -679,7 +769,13 @@ public RealmAsyncTask start() {
                 @Override
                 public void run() {
                     try {
-                        postSuccess(Request.this.run());
+                        // co-exist the old and new callback
+                        if (genericCallback != null) {
+                            postSuccess(Request.this.execute());
+                        } else {
+                            postSuccess(Request.this.run());
+                        }
+
                     } catch (ObjectServerError e) {
                         postError(e);
                     } catch (Throwable e) {
@@ -717,11 +813,37 @@ public void run() {
                 });
             }
         }
+
+        private void postSuccess(final T result) {
+            if (genericCallback != null) {
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        genericCallback.onSuccess(result);
+                    }
+                });
+            }
+        }
     }
 
+    // TODO remove and replace uses by RequestCallback on next major release
     public interface Callback {
+        /**
+         * @deprecated as per 3.6.0 release, replaced by {@link RequestCallback#onSuccess(Object)}
+         */
+        @Deprecated
         void onSuccess(SyncUser user);
 
+        /**
+         * @deprecated as per 3.6.0 release, replaced by {@link RequestCallback#onError(ObjectServerError)}
+         */
+        @Deprecated
+        void onError(ObjectServerError error);
+    }
+
+    public interface RequestCallback<T> {
+        void onSuccess(T result);
+
         void onError(ObjectServerError error);
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUserInfo.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUserInfo.java
new file mode 100644
index 0000000000..f9acdc942e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUserInfo.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.internal.network.LookupUserIdResponse;
+
+/**
+ * POJO representing information about a user that was retrieved from a user lookup call.
+ * @see SyncUser#retrieveInfoForUser(String, String)
+ */
+
+public class SyncUserInfo {
+    private final String provider;
+    private final String providerUserIdentity;
+    private final String identity;
+    private final boolean isAdmin;
+
+    private SyncUserInfo(String provider, String providerUserIdentity, String identity, boolean isAdmin) {
+        this.provider = provider;
+        this.providerUserIdentity = providerUserIdentity;
+        this.identity = identity;
+        this.isAdmin = isAdmin;
+    }
+
+    static SyncUserInfo fromLookupUserIdResponse(LookupUserIdResponse response) {
+        return new SyncUserInfo(response.getProvider(), response.getProviderId(), response.getUserId(), response.isAdmin());
+    }
+
+    /**
+     * @return identity providers {@link io.realm.SyncCredentials.IdentityProvider} which manages the user represented by this user info instance.
+     */
+    public String getProvider() {
+        return provider;
+    }
+
+    /**
+     * @return The username or identity issued to this user by the authentication provider.
+     */
+    public String getProviderUserIdentity() {
+        return providerUserIdentity;
+    }
+
+    /**
+     * @return The identity issued to this user by the Realm Object Server.
+     */
+    public String getIdentity() {
+        return identity;
+    }
+
+    /**
+     * @return Whether the user is flagged on the Realm Object Server as an administrator.
+     */
+    public boolean isAdmin() {
+        return isAdmin;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        SyncUserInfo that = (SyncUserInfo) o;
+
+        if (isAdmin != that.isAdmin) return false;
+        if (!provider.equals(that.provider)) return false;
+        if (!providerUserIdentity.equals(that.providerUserIdentity)) return false;
+        return identity.equals(that.identity);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = provider.hashCode();
+        result = 31 * result + providerUserIdentity.hashCode();
+        result = 31 * result + identity.hashCode();
+        result = 31 * result + (isAdmin ? 1 : 0);
+        return result;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
index 03f162131e..86c20952f4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
@@ -31,10 +31,14 @@
  */
 public class LookupUserIdResponse extends AuthServerResponse {
 
+    private static final String JSON_FIELD_PROVIDER = "provider";
+    private static final String JSON_FIELD_PROVIDER_ID = "provider_id";
     private static final String JSON_FIELD_USER = "user";
     private static final String JSON_FIELD_USER_ID = "id";
     private static final String JSON_FIELD_USER_IS_ADMIN = "isAdmin";
 
+    private final String providerId;
+    private final String provider;
     private final String userId;
     private final Boolean isAdmin;
 
@@ -78,17 +82,23 @@ private LookupUserIdResponse(ObjectServerError error) {
         RealmLog.debug("LookupUserIdResponse - Error: " + error);
         setError(error);
         this.error = error;
+        this.providerId = null;
+        this.provider = null;
         this.userId = null;
         this.isAdmin = null;
     }
 
     private LookupUserIdResponse(String serverResponse) {
         ObjectServerError error;
+        String provider;
+        String providerId;
         String userId;
         Boolean isAdmin;
         String message;
         try {
             JSONObject obj = new JSONObject(serverResponse);
+            provider = obj.getString(JSON_FIELD_PROVIDER);
+            providerId = obj.getString(JSON_FIELD_PROVIDER_ID);
             JSONObject jsonUser = obj.getJSONObject(JSON_FIELD_USER);
             if (jsonUser != null) {
                 userId = jsonUser.optString(JSON_FIELD_USER_ID, null);
@@ -107,6 +117,8 @@ private LookupUserIdResponse(String serverResponse) {
             }
 
         } catch (JSONException e) {
+            provider = null;
+            providerId = null;
             userId = null;
             isAdmin = null;
             error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
@@ -115,10 +127,20 @@ private LookupUserIdResponse(String serverResponse) {
 
         RealmLog.debug("LookupUserIdResponse. " + message);
         setError(error);
+        this.providerId = providerId;
+        this.provider = provider;
         this.userId = userId;
         this.isAdmin = isAdmin;
     }
 
+    public String getProviderId() {
+        return providerId;
+    }
+
+    public String getProvider() {
+        return provider;
+    }
+
     public String getUserId() {
         return userId;
     }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 3bab0bd93d..49c83e60d6 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -15,6 +15,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.realm.AuthenticationListener;
 import io.realm.BaseIntegrationTest;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
@@ -25,6 +26,7 @@
 import io.realm.SyncManager;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
+import io.realm.SyncUserInfo;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
@@ -473,14 +475,20 @@ public void retrieve() {
         assertTrue(user.isValid());
 
         String identity = user.getIdentity();
-        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username);
-        assertNotNull(syncUser);
-        assertEquals(identity, syncUser.getIdentity());
-        assertFalse(syncUser.isAdmin());
-        assertTrue(syncUser.isValid());
+
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD);
+
+        assertNotNull(userInfo);
+        assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, userInfo.getProvider());
+        assertEquals(username, userInfo.getProviderUserIdentity());
+        assertEquals(identity, userInfo.getIdentity());
+        assertFalse(userInfo.isAdmin());
     }
 
+
+    // retrieving a logged out user
     @Test
+    @RunTestInLooperThread
     public void retrieve_logout() {
         final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
 
@@ -489,31 +497,59 @@ public void retrieve_logout() {
         final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
         final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
         final String identity = user.getIdentity();
-        user.logout();
-        assertFalse(user.isValid());
 
-        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username);
-        assertNotNull(syncUser);
-        assertEquals(identity, syncUser.getIdentity());
-        assertFalse(syncUser.isAdmin());
-        assertFalse(syncUser.isValid());
+        // unless the refresh_token is revoked (via logout) the admin user can still retrieve the user
+        // we make sure the token is revoked before trying to retrieve the user
+        SyncManager.addAuthenticationListener(new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        fail("loggedIn should not be invoked");
+                    }
+                });
+            }
+
+            @Override
+            public void loggedOut(final SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertFalse(user.isValid());
+                        SyncUserInfo userInfo = adminUser.retrieveInfoForUser(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD);
+
+                        assertNotNull(userInfo);
+                        assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, userInfo.getProvider());
+                        assertEquals(username, userInfo.getProviderUserIdentity());
+                        assertEquals(identity, userInfo.getIdentity());
+                        assertFalse(userInfo.isAdmin());
+
+                        looperThread.testComplete();
+                    }
+                });
+
+            }
+        });
+        user.logout();
     }
 
     @Test
     public void retrieve_AdminUser() {
         final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.DEBUG, "admin");// TODO use enum for auth provider
-        assertNotNull(syncUser);
-        assertEquals(adminUser.getIdentity(), syncUser.getIdentity());
-        assertTrue(syncUser.isAdmin());
-        assertTrue(syncUser.isValid());
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser("admin", SyncCredentials.IdentityProvider.DEBUG);// TODO use enum for auth provider
+        assertNotNull(userInfo);
+        assertEquals(adminUser.getIdentity(), userInfo.getIdentity());
+        assertTrue(userInfo.isAdmin());
     }
 
     @Test
     public void retrieve_unknownProviderId() {
         final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncUser syncUser = adminUser.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, "doesNotExist");
-        assertNull(syncUser);
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser("doesNotExist", SyncCredentials.IdentityProvider.USERNAME_PASSWORD);
+        assertNull(userInfo);
     }
 
     @Test
@@ -525,8 +561,8 @@ public void retrieve_invalidProvider() {
         final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
         assertTrue(user.isValid());
 
-        SyncUser syncUser = adminUser.retrieveUser("invalid", "username");
-        assertNull(syncUser);
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser("username", "invalid");
+        assertNull(userInfo);
     }
 
     @Test
@@ -545,7 +581,7 @@ public void retrieve_notAdmin() {
 
         // trying to lookup user2 using user1 should not work (requires admin token)
         try {
-            user1.retrieveUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username2);
+            user1.retrieveInfoForUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username2);
             fail("It should not be possible to lookup a user using non admin token");
         } catch (IllegalArgumentException expected) {
         }
@@ -566,14 +602,15 @@ public void retrieve_async() {
         assertTrue(adminUser.isAdmin());
 
         final String identity = user.getIdentity();
-        adminUser.retrieveUserAsync("password", username, new SyncUser.Callback() {
+        adminUser.retrieveInfoForUserAsync(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD, new SyncUser.RequestCallback<SyncUserInfo>() {
             @Override
-            public void onSuccess(SyncUser syncUser) {
+            public void onSuccess(SyncUserInfo userInfo) {
+                assertNotNull(userInfo);
+                assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, userInfo.getProvider());
+                assertEquals(username, userInfo.getProviderUserIdentity());
+                assertEquals(identity, userInfo.getIdentity());
+                assertFalse(userInfo.isAdmin());
 
-                assertNotNull(syncUser);
-                assertEquals(identity, syncUser.getIdentity());
-                assertFalse(syncUser.isAdmin());
-                assertTrue(syncUser.isValid());
                 looperThread.testComplete();
             }
 
