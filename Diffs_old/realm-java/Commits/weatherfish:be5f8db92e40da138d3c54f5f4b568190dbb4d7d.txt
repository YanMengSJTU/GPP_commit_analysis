diff --git a/CHANGELOG.md b/CHANGELOG.md
index deecc12ea7..b756b905ad 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,22 @@
 ### Object Server API Changes (In Beta)
 
 * Add a default `UserStore` based on the Realm Object Store (`ObjectStoreUserStore`).
+* Change the order of arguments to SyncCredentials.custom to match iOS: token, provider, userInfo
+
+## 2.2.3
+
+### Bug fixes
+
+* Fixed native memory leak setting the value of a primary key (#3993).
+* Activated Realm's annotation processor on connectedTest when the project is using kapt (#4008).
+
+### Object Server API Changes (In Beta)
+
+* Exceptions thrown in error handlers are ignored but logged (#3559).
+
+### Internal
+
+* Updated Realm Sync to 1.0.0-BETA-7.1.
 
 ## 2.2.2
 
@@ -13,15 +29,23 @@
 ### Bug fixes
 
 * "operation not permitted" issue when creating Realm file on some devices' external storage (#3629).
+* Crash on API 10 devices (#3726).
+* `UnsatisfiedLinkError` caused by `pipe2` (#3945).
+* Unrecoverable error with message "Try again" when the notification fifo is full (#3964).
+* Realm migration wasn't triggered when the primary key definition was altered (#3966).
+* Use phantom reference to solve the finalize time out issue (#2496).
 
 ### Enhancements
 
 * All major public classes are now non-final. This is mostly a compromise to support Mockito. All protected fields/methods are still not considered part of the public API and can change without notice (#3869).
+* All Realm instances share a single notification daemon thread.
+* Fixed Java lint warnings with generated proxy classes (#2929).
+* Add 'like' predicate for String fields (#3752)
 
 ### Internal
 
-* Upgraded Realm Core to 2.1.0.
-* Upgraded Realm Sync to 1.0.0-BETA-5.0.
+* Upgraded Realm Core to 2.3.0.
+* Upgraded Realm Sync to 1.0.0-BETA-6.5.
 
 ## 2.2.1
 
diff --git a/README.md b/README.md
index 10e737e150..7e985ef5c4 100644
--- a/README.md
+++ b/README.md
@@ -42,9 +42,11 @@ buildscript {
     }
 }
 
-repositories {
-    maven {
-        url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
+allprojects {
+    repositories {
+        maven {
+            url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
+        }
     }
 }
 ```
@@ -68,38 +70,41 @@ In case you don't want to use the precompiled version, you can build Realm yours
     brew install android-ndk-r10e
     ```
 
- * Add two environment variables to your profile:
+ * Add two environment variables to your profile (presuming you used brew to install the NDK):
 
     ```
     export ANDROID_HOME=~/Library/Android/sdk
     export ANDROID_NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
     ```
 
- * If you want to build with Android Studio, `ndk.dir` has to be defined in the `realm/local.properties` as well.
+ * If you want to build with Android Studio, `ndk.dir` has to be defined in the `realm/local.properties` as well.  Note that there is a `local.properites` in the root directory that is *not* the one that needs to be edited.  Again, presuming you used brew to install the NDK:
 
     ```
     ndk.dir=/usr/local/Cellar/android-ndk-r10e/r10e
     ```
 
- * If you are using OS X, you'd be better to add following lines to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see those environment variables.
+ * If you will be launching Android Studio from the OS X Finder, you should also run the following two commands:
 
     ```
     launchctl setenv ANDROID_HOME "$ANDROID_HOME"
     launchctl setenv ANDROID_NDK_HOME "$ANDROID_NDK_HOME"
     ```
 
- * And if you'd like to specify the location to store the archives of Realm's core, set `REALM_CORE_DOWNLOAD_DIR` environment variable. It enables you to keep core's archive when executing `git clean -xfd`.
+ * If you'd like to specify the location in which to store the archives of Realm Core, define the `REALM_CORE_DOWNLOAD_DIR` environment variable. It enables you to keep Core's archive when executing `git clean -xfd`.
 
    ```
    export REALM_CORE_DOWNLOAD_DIR=~/.realmCore
    ```
 
-   OS X users should also add following line to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see this environment variable..
+   OS X users must also run the following command in order for Android Studio to see this environment variable..
 
    ```
    launchctl setenv REALM_CORE_DOWNLOAD_DIR "$REALM_CORE_DOWNLOAD_DIR"
    ```
 
+It would be a good idea to add all of the symbol definitions (and their accompanying `launchctl` commands, if you are using OS X) to your `~/.profile` (or `~/.zprofile` if the login shell is `zsh`)
+
+
 ### Download sources
 
 You can download the source code of Realm Java by using git. Since realm-java has git submodules, use `--recursive` when cloning the repository.
@@ -129,16 +134,18 @@ That command will generate:
  * a jar file for the annotations
  * a jar file for the annotations processor
 
+The full build may take an hour or more, to complete.
+
 ### Other Commands
 
  * `./gradlew tasks` will show all the available tasks
  * `./gradlew javadoc` will generate the Javadocs
  * `./gradlew monkeyExamples` will run the monkey tests on all the examples
  * `./gradlew installRealmJava` will install the Realm library and plugin to mavenLocal()
- * `./gradlew clean -PdontCleanJniFiles` will remove all generated files except for JNI related files. This saves recompilation time a lot.
- * `./gradlew connectedUnitTests -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.
+ * `./gradlew clean -PdontCleanJniFiles` will remove all generated files except for JNI related files. This reduces recompilation time a lot.
+ * `./gradlew connectedUnitTests -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.  These tests require a running Object Server (see below)
 
-Generating the Javadoc using the command above will report a large number of warnings. The Javadoc is generated, and we will fix the issue in the near future.
+Generating the Javadoc using the command above may generate warnings. The Javadoc is generated despite the warnings.
 
 ### Gotchas
 
@@ -149,11 +156,15 @@ The repository is organized in six Gradle projects:
  * `realm-transformer`: it contains the bytecode transformer.
  * `gradle-plugin`: it contains the Gradle plugin.
  * `examples`: it contains the example projects. This project directly depends on `gradle-plugin` which adds a dependency to the artifacts produced by `realm`.
- * The root folder is another Gradle project and all it does is orchestrating the other jobs
+ * The root folder is another Gradle project.  All it does is orchestrate the other jobs
 
 This means that `./gradlew clean` and `./gradlew cleanExamples` will fail if `assembleExamples` has not been executed first.
 Note that IntelliJ [does not support multiple projects in the same window](https://youtrack.jetbrains.com/issue/IDEABKL-6118#)
-so each sub-project must be opened in its own window.
+so each of the six Gradle projects must be imported as a separate IntelliJ project.
+
+Since the repository contains several completely independent Gradle projects, several independent builds are run to assemble it.
+Seeing a line like: `:realm:realm-library:compileBaseDebugAndroidTestSources UP-TO-DATE` in the build log does *not* imply
+that you can run `./gradlew :realm:realm-library:compileBaseDebugAndroidTestSources`.
 
 ## Examples
 
@@ -161,6 +172,26 @@ The `./examples` folder contain a number of example projects showing how Realm c
 
 Standalone examples can be [downloaded from website](https://realm.io/docs/java/latest/#getting-started).
 
+## Running Tests on a Device
+
+To run these tests you must have a device connected to the build computer and the `adb` command must be in your `PATH`
+
+1. Connect an Android device and verify that that the command `adb devices` shows a connected device:
+
+        ```sh
+        adb devices
+        List of devices attached
+        004c03eb5615429f	device
+        ```
+2. Run instrumentation tests:
+
+	```sh
+	cd realm
+	./gradlew connectedBaseDebugAndroidTest
+	```
+
+These tests may take as much as half an hour to complete.
+
 ## Running Tests Using The Realm Object Server
 
 Tests in `realm/realm-library/src/syncIntegrationTest` require a running testing server to work.
@@ -169,21 +200,27 @@ A docker image can be built from `tools/sync_test_server/Dockerfile` to run the
 
 To run a testing server locally:
 
-1. Install docker.
+1. Install [docker](https://www.docker.com/products/overview).
 
 2. Run `tools/sync_test_server/start_server.sh`:
 
-```sh
-cd tools/sync_test_server
-./start_server.sh
-```
+    ```sh
+    cd tools/sync_test_server
+    ./start_server.sh
+    ```
 
-3. Run instrumentation tests:
+    This command will not complete until the server has stopped.
 
-```sh
-cd realm
-./gradlew connectedObjectServerDebugAndroidTest
-```
+3. Run instrumentation tests
+
+	In a new terminal window, run:
+
+	```sh
+	cd realm
+	./gradlew connectedObjectServerDebugAndroidTest
+	```
+
+These tests may take as much as half an hour to complete.
 
 ## Contributing
 
@@ -193,6 +230,11 @@ This project adheres to the [Contributor Covenant Code of Conduct](https://realm
 By participating, you are expected to uphold this code. Please report
 unacceptable behavior to [info@realm.io](mailto:info@realm.io).
 
+The directory `realm/config/studio` contains lint and style files recommended for project code.
+Import them from Android Studio with Android Studio > Preferences... > Code Style > Manage... > Import,
+or Android Studio > Preferences... > Inspections > Manage... > Import.  Once imported select the
+style/lint in the drop-down to the left of the Manage... button.
+
 ## License
 
 Realm Java is published under the Apache 2.0 license.
diff --git a/build.gradle b/build.gradle
index cd7c5facad..870ada9c85 100644
--- a/build.gradle
+++ b/build.gradle
@@ -266,13 +266,21 @@ task clean {
     dependsOn cleanLocalMavenRepos
 }
 
-task uploadDistributionPackage(type: Exec) {
+task uploadDistributionPackage {
     group = 'Release'
     description = 'Upload the distribution package to S3'
     dependsOn distributionPackage
     dependsOn distributionJniUnstrippedPackage
-    commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
-    commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-jni-libs-unstripped-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+    doLast {
+        exec {
+            workingDir "${buildDir}/outputs/distribution/"
+            commandLine 's3cmd', 'put', "realm-java-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+        }
+        exec {
+            workingDir "${buildDir}/outputs/distribution/"
+            commandLine 's3cmd', 'put', "realm-java-jni-libs-unstripped-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+        }
+    }
 }
 
 task createEmptyFile(type: Exec) {
diff --git a/dependencies.list b/dependencies.list
index e1ea9c6811..769de14b97 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.0.0-BETA-5.0
-REALM_SYNC_SHA256=7bbaa9cdef722d85489feb1b70da11d5640869540d9a0fc40621de7352dd9ffd
+REALM_SYNC_VERSION=1.0.0-BETA-7.1
+REALM_SYNC_SHA256=5412b42d96dd525af3ec6a0b7943330c43beae2c663b32376b77278ea54e34a5
 
 # Object Server Release used by Integration tests
 # https://packagecloud.io/realm/realm?filter=debs
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 0b28d9a15c..38829e6538 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -66,6 +66,8 @@ class Realm implements Plugin<Project> {
         } else if (isKotlinProject && !preferAptOnKotlinProject) {
             project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("kapt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+            project.dependencies.add("kaptAndroidTest", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("kaptAndroidTest", "io.realm:realm-annotations-processor:${Version.VERSION}")
         } else {
             assert hasAnnotationProcessorConfiguration
             project.dependencies.add("annotationProcessor", "io.realm:realm-annotations:${Version.VERSION}")
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index 10553d8870..e28c4a627c 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -1,112 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <FindBugsFilter>
-    <Match>
-        <!-- ignore all issues in resource generation -->
-        <Class name="~.*\.R\$.*"/>
-    </Match>
-    <Match>
-        <Class name="~.*\.Manifest\$.*"/>
-    </Match>
-    <Match>
-        <Class name="io.realm.Realm" />
-        <Method name="checkHasPrimaryKey" />
-        <Bug pattern="UPM_UNCALLED_PRIVATE_METHOD" />
-    </Match>
-    <Match>
-        <Class name="io.realm.RealmBaseAdapter" />
-        <Field name="context" />
-        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
-    </Match>
-    <Match>
-        <Class name="io.realm.RealmBaseAdapter" />
-        <Field name="inflater" />
-        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
-    </Match>
-    <Match>
-        <Class name="io.realm.internal.RealmObjectProxy$CacheData" />
-        <Field name="minDepth" />
-        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
-    </Match>
-    <Match>
-        <Class name="io.realm.SyncManager" />
-        <Field name="APP_ID" />
-        <Bug pattern="MS_SHOULD_BE_FINAL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.SyncManager" />
-        <Field name="APP_ID" />
-        <Bug pattern="MS_CANNOT_BE_FINAL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.SyncUser" />
-        <Field name="managementRealmConfig" />
-        <Bug pattern="IS2_INCONSISTENT_SYNC" />
-    </Match>
-
+    <!--
+    In code, please prefer annotations as a way of ignoring Findbugs issues
+    -->
 
+    <!-- Unit tests
+        As of Jan 6, 2017, there are ~1000 Findbugs issues in the unit tests.
+        This shall not pass.
+        Clean the build directory and build only the product code:
+            ./gradlew clean findbugs
+    -->
 
-    <!-- Unit tests -->
-    <Match>
-        <Class name="io.realm.RealmTests" />
-        <Method name="getInstance_writeProtectedDir" />
-        <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
-    </Match>
-    <Match>
-        <Class name="io.realm.RealmTests" />
-        <Class name="~.*Tests?$"/>
-        <Bug pattern="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS"/>
-    </Match>
-    <Match>
-        <Class name="~.*Tests?$"/>
-        <Bug pattern="DM_GC"/>
-    </Match>
-    <Match>
-        <Class name="io.realm.HandlerController" />
-        <Method name="completedAsyncRealmObject" />
-        <Bug pattern="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN" />
-    </Match>
-    <Match>
-        <Class name="io.realm.permissions.PermissionChange" />
-        <Method name="mayManage" />
-        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.permissions.PermissionChange" />
-        <Method name="mayRead" />
-        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.permissions.PermissionChange" />
-        <Method name="mayWrite" />
-        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.PermissionChangeRealmProxy" />
-        <Method name="realmGet$mayManage" />
-        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.PermissionChangeRealmProxy" />
-        <Method name="realmGet$mayRead" />
-        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.PermissionChangeRealmProxy" />
-        <Method name="realmGet$mayWrite" />
-        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
-    </Match>
-    <Match>
-        <Class name="io.realm.permissions.PermissionChange" />
-        <Method name="getCreatedAt" />
-        <Bug pattern="EI_EXPOSE_REP" />
-    </Match>
-    <Match>
-        <Class name="io.realm.permissions.PermissionChange" />
-        <Method name="getUpdatedAt" />
-        <Bug pattern="EI_EXPOSE_REP" />
-    </Match>
+    <!-- Generated code -->
     <Match>
-        <Class name="io.realm.PermissionChangeRealmProxy" />
-        <Bug pattern="BC_IMPOSSIBLE_CAST" />
+        <Class name="io.realm.PermissionChangeRealmProxy"/>
     </Match>
 </FindBugsFilter>
diff --git a/realm/config/studio/Realm-style.xml b/realm/config/studio/Realm-style.xml
new file mode 100644
index 0000000000..6f11f49147
--- /dev/null
+++ b/realm/config/studio/Realm-style.xml
@@ -0,0 +1,238 @@
+<code_scheme name="Realm-style">
+  <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+  <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+  <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+    <value />
+  </option>
+  <option name="IMPORT_LAYOUT_TABLE">
+    <value>
+      <package name="android" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="com" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="junit" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="net" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="org" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="java" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="javax" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="" withSubpackages="true" static="false" />
+      <emptyLine />
+      <package name="" withSubpackages="true" static="true" />
+      <emptyLine />
+    </value>
+  </option>
+  <option name="RIGHT_MARGIN" value="120" />
+  <option name="JD_ALIGN_PARAM_COMMENTS" value="false" />
+  <option name="JD_ALIGN_EXCEPTION_COMMENTS" value="false" />
+  <AndroidXmlCodeStyleSettings>
+    <option name="USE_CUSTOM_SETTINGS" value="true" />
+  </AndroidXmlCodeStyleSettings>
+  <Objective-C-extensions>
+    <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
+    <option name="RELEASE_STYLE" value="IVAR" />
+    <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
+    <file>
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
+    </file>
+    <class>
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
+      <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
+    </class>
+    <extensions>
+      <pair source="cpp" header="h" />
+      <pair source="c" header="h" />
+    </extensions>
+  </Objective-C-extensions>
+  <XML>
+    <option name="XML_KEEP_LINE_BREAKS" value="false" />
+    <option name="XML_ALIGN_ATTRIBUTES" value="false" />
+    <option name="XML_SPACE_INSIDE_EMPTY_TAG" value="true" />
+  </XML>
+  <codeStyleSettings language="JAVA">
+    <option name="BLANK_LINES_AFTER_IMPORTS" value="2" />
+    <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />
+    <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
+    <option name="KEEP_SIMPLE_BLOCKS_IN_ONE_LINE" value="true" />
+    <option name="KEEP_SIMPLE_METHODS_IN_ONE_LINE" value="true" />
+    <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />
+    <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />
+    <option name="IF_BRACE_FORCE" value="3" />
+    <option name="DOWHILE_BRACE_FORCE" value="3" />
+    <option name="WHILE_BRACE_FORCE" value="3" />
+    <option name="FOR_BRACE_FORCE" value="3" />
+  </codeStyleSettings>
+  <codeStyleSettings language="XML">
+    <option name="FORCE_REARRANGE_MODE" value="1" />
+    <indentOptions>
+      <option name="CONTINUATION_INDENT_SIZE" value="4" />
+    </indentOptions>
+    <arrangement>
+      <rules>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>xmlns:android</NAME>
+                <XML_NAMESPACE>^$</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>xmlns:.*</NAME>
+                <XML_NAMESPACE>^$</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:id</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:name</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>name</NAME>
+                <XML_NAMESPACE>^$</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>style</NAME>
+                <XML_NAMESPACE>^$</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*</NAME>
+                <XML_NAMESPACE>^$</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:layout_width</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:layout_height</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:layout_.*</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:width</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*:height</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*</NAME>
+                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+        <section>
+          <rule>
+            <match>
+              <AND>
+                <NAME>.*</NAME>
+                <XML_NAMESPACE>.*</XML_NAMESPACE>
+              </AND>
+            </match>
+            <order>BY_NAME</order>
+          </rule>
+        </section>
+      </rules>
+    </arrangement>
+  </codeStyleSettings>
+</code_scheme>
diff --git a/realm/config/studio/Realm_lint.xml b/realm/config/studio/Realm_lint.xml
new file mode 100644
index 0000000000..2498bef0ce
--- /dev/null
+++ b/realm/config/studio/Realm_lint.xml
@@ -0,0 +1,136 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<inspections version="1.0">
+  <option name="myName" value="Realm-lint" />
+  <inspection_tool class="AccessToNonThreadSafeStaticFieldFromInstance" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="nonThreadSafeClasses">
+      <value />
+    </option>
+    <option name="nonThreadSafeTypes" value="" />
+  </inspection_tool>
+  <inspection_tool class="Anonymous2MethodRef" enabled="false" level="WARNING" enabled_by_default="false" />
+  <inspection_tool class="AnonymousClassComplexity" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_limit" value="3" />
+  </inspection_tool>
+  <inspection_tool class="AnonymousClassMethodCount" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_limit" value="5" />
+  </inspection_tool>
+  <inspection_tool class="ArrayEquality" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ArrayLengthInLoopCondition" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="AssignmentToSuperclassField" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="BadExceptionCaught" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="exceptionsString" value="" />
+    <option name="exceptions">
+      <value />
+    </option>
+  </inspection_tool>
+  <inspection_tool class="CStyleArrayDeclaration" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ClassComplexity" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_limit" value="80" />
+  </inspection_tool>
+  <inspection_tool class="ClassCoupling" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_includeJavaClasses" value="false" />
+    <option name="m_includeLibraryClasses" value="false" />
+    <option name="m_limit" value="15" />
+  </inspection_tool>
+  <inspection_tool class="ClassInitializer" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ClassNestingDepth" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_limit" value="2" />
+  </inspection_tool>
+  <inspection_tool class="ClassWithOnlyPrivateConstructors" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ComparableImplementedButEqualsNotOverridden" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="CompareToUsesNonFinalVariable" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="Convert2Lambda" enabled="false" level="WARNING" enabled_by_default="false" />
+  <inspection_tool class="CovariantCompareTo" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="CovariantEquals" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="DanglingJavadoc" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="DoubleCheckedLocking" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="ignoreOnVolatileVariables" value="false" />
+  </inspection_tool>
+  <inspection_tool class="EmptyInitializer" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="EmptySynchronizedStatement" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="EnumerationCanBeIteration" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="EqualsAndHashcode" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="EqualsCalledOnEnumConstant" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="EqualsUsesNonFinalVariable" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="FieldAccessedSynchronizedAndUnsynchronized" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="countGettersAndSetters" value="false" />
+  </inspection_tool>
+  <inspection_tool class="FieldMayBeFinal" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="FinalMethodInFinalClass" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="HashCodeUsesNonFinalVariable" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="InnerClassMayBeStatic" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="InstanceGuardedByStatic" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="InstanceofCatchParameter" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="InstanceofIncompatibleInterface" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="IteratorHasNextCallsIteratorNext" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="IteratorNextDoesNotThrowNoSuchElementException" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ListIndexOfReplaceableByContains" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="LiteralAsArgToStringEquals" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="LoggerInitializedWithForeignClass" enabled="false" level="WARNING" enabled_by_default="false">
+    <option name="loggerClassName" value="org.apache.log4j.Logger,org.slf4j.LoggerFactory,org.apache.commons.logging.LogFactory,java.util.logging.Logger" />
+    <option name="loggerFactoryMethodName" value="getLogger,getLogger,getLog,getLogger" />
+  </inspection_tool>
+  <inspection_tool class="MethodCallInLoopCondition" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="MethodCount" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_limit" value="20" />
+    <option name="ignoreGettersAndSetters" value="true" />
+    <option name="ignoreOverridingMethods" value="true" />
+  </inspection_tool>
+  <inspection_tool class="MethodMayBeSynchronized" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="MissingDeprecatedAnnotation" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="MissingOverrideAnnotation" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="ignoreObjectMethods" value="true" />
+    <option name="ignoreAnonymousClassMethods" value="false" />
+  </inspection_tool>
+  <inspection_tool class="MisspelledCompareTo" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="MisspelledEquals" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="NonAtomicOperationOnVolatileField" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="NonFinalFieldInEnum" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="NonProtectedConstructorInAbstractClass" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_ignoreNonPublicClasses" value="false" />
+  </inspection_tool>
+  <inspection_tool class="NonShortCircuitBoolean" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="NonSynchronizedMethodOverridesSynchronizedMethod" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="NullThrown" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ObjectEquality" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="m_ignoreEnums" value="true" />
+    <option name="m_ignoreClassObjects" value="false" />
+    <option name="m_ignorePrivateConstructors" value="false" />
+  </inspection_tool>
+  <inspection_tool class="ObjectNotify" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ObsoleteCollection" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="ignoreRequiredObsoleteCollectionTypes" value="false" />
+  </inspection_tool>
+  <inspection_tool class="OnDemandImport" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ParameterTypePreventsOverriding" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="PrivateMemberAccessBetweenOuterAndInnerClass" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ProblematicVarargsMethodOverride" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ProtectedMemberInFinalClass" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="RedundantThrowsDeclaration" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ResultOfObjectAllocationIgnored" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ReturnOfInnerClass" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="SafeLock" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="SamePackageImport" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="SimplifiableIfStatement" enabled="false" level="WARNING" enabled_by_default="false" />
+  <inspection_tool class="SizeReplaceableByIsEmpty" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="SleepWhileHoldingLock" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="StaticCallOnSubclass" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="StaticFieldReferenceOnSubclass" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="StaticGuardedByInstance" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="StringBufferField" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="SystemOutErr" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ThreadDumpStack" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="ThrowablePrintStackTrace" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="TooBroadCatch" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="TooBroadThrows" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="UnclearBinaryExpression" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="UnnecessaryInheritDoc" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="UnnecessaryJavaDocLink" enabled="true" level="WARNING" enabled_by_default="true">
+    <option name="ignoreInlineLinkToSuper" value="false" />
+  </inspection_tool>
+  <inspection_tool class="VolatileArrayField" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="VolatileLongOrDoubleField" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="WaitNotInLoop" enabled="true" level="WARNING" enabled_by_default="true" />
+  <inspection_tool class="WaitWhileHoldingTwoLocks" enabled="true" level="WARNING" enabled_by_default="true" />
+</inspections>
+
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index f87f679bb8..eb99fbeb6e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -205,7 +205,7 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
 
     private void emitClassFields(JavaWriter writer) throws IOException {
         writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE));
-        writer.emitField("ProxyState", "proxyState", EnumSet.of(Modifier.PRIVATE));
+        writer.emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
@@ -502,7 +502,7 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()");
         writer.emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName());
-        writer.emitStatement("this.proxyState = new ProxyState(%1$s.class, this)", qualifiedClassName);
+        writer.emitStatement("this.proxyState = new ProxyState<%1$s>(%1$s.class, this)", qualifiedClassName);
         writer.emitStatement("proxyState.setRealm$realm(context.getRealm())");
         writer.emitStatement("proxyState.setRow$realm(context.getRow())");
         writer.emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())");
@@ -668,6 +668,25 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName());
         writer.emitEmptyLine();
 
+        // verify primary key definition was not altered
+        if (metadata.hasPrimaryKey()) {
+            // the current model defines a PK, make sure it's defined in the Realm schema
+            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
+            writer.beginControlFlow("if (!table.hasPrimaryKey())")
+                    .emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")", metadata.getPrimaryKey().getSimpleName().toString())
+                    .nextControlFlow("else")
+                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName)
+                    .emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")" ,metadata.getPrimaryKey().getSimpleName().toString())
+                    .endControlFlow()
+                    .endControlFlow();
+        } else {
+            // the current model doesn't define a PK, make sure it's not defined in the Realm schema
+            writer.beginControlFlow("if (table.hasPrimaryKey())")
+                    .emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")")
+                    .endControlFlow();
+        }
+        writer.emitEmptyLine();
+
         // For each field verify there is a corresponding
         long fieldIndex = 0;
         for (VariableElement field : metadata.getFields()) {
@@ -738,13 +757,6 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     }
                 }
 
-                // Validate @PrimaryKey
-                if (metadata.isPrimaryKey(field)) {
-                    writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary key not defined for field '%s' in existing Realm file. Add @PrimaryKey.\")", fieldName);
-                    writer.endControlFlow();
-                }
-
                 // Validate @Index
                 if (metadata.getIndexedFields().contains(field)) {
                     writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
@@ -1490,7 +1502,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 .endControlFlow()
             .nextControlFlow("else")
                 .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
-                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject))")
+                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
             .endControlFlow();
 
         for (VariableElement field : metadata.getFields()) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index d67ccc944c..7bf9205056 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -92,7 +92,7 @@ public final AllTypesColumnInfo clone() {
 
     }
     private AllTypesColumnInfo columnInfo;
-    private ProxyState proxyState;
+    private ProxyState<some.test.AllTypes> proxyState;
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
     private static final List<String> FIELD_NAMES;
     static {
@@ -119,7 +119,7 @@ public final AllTypesColumnInfo clone() {
     private void injectObjectContext() {
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState(some.test.AllTypes.class, this);
+        this.proxyState = new ProxyState<some.test.AllTypes>(some.test.AllTypes.class, this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -533,6 +533,14 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
 
             final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
 
+            if (!table.hasPrimaryKey()) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
+            } else {
+                if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
+                }
+            }
+
             if (!columnTypes.containsKey("columnString")) {
                 throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
@@ -542,9 +550,6 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
             if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
                 throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
             }
-            if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
-            }
             if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
                 throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
             }
@@ -1210,7 +1215,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             }
         } else {
             unmanagedObject = new some.test.AllTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
         }
         ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
         ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 7200c4e70e..da1971a009 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -72,7 +72,7 @@ public final BooleansColumnInfo clone() {
 
     }
     private BooleansColumnInfo columnInfo;
-    private ProxyState proxyState;
+    private ProxyState<some.test.Booleans> proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -93,7 +93,7 @@ public final BooleansColumnInfo clone() {
     private void injectObjectContext() {
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (BooleansColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState(some.test.Booleans.class, this);
+        this.proxyState = new ProxyState<some.test.Booleans>(some.test.Booleans.class, this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -266,6 +266,10 @@ public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean
 
             final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
 
+            if (table.hasPrimaryKey()) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+            }
+
             if (!columnTypes.containsKey("done")) {
                 throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
@@ -521,7 +525,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             }
         } else {
             unmanagedObject = new some.test.Booleans();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
         }
         ((BooleansRealmProxyInterface) unmanagedObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
         ((BooleansRealmProxyInterface) unmanagedObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 608868bb72..88e3de0cca 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -140,7 +140,7 @@ public final NullTypesColumnInfo clone() {
 
     }
     private NullTypesColumnInfo columnInfo;
-    private ProxyState proxyState;
+    private ProxyState<some.test.NullTypes> proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -178,7 +178,7 @@ public final NullTypesColumnInfo clone() {
     private void injectObjectContext() {
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (NullTypesColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState(some.test.NullTypes.class, this);
+        this.proxyState = new ProxyState<some.test.NullTypes>(some.test.NullTypes.class, this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -1094,6 +1094,10 @@ public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
 
             final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
 
+            if (table.hasPrimaryKey()) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+            }
+
             if (!columnTypes.containsKey("fieldStringNotNull")) {
                 throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
@@ -2221,7 +2225,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             }
         } else {
             unmanagedObject = new some.test.NullTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
         }
         ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
         ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 3dc59b6feb..bd50bf8120 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -64,7 +64,7 @@ public final SimpleColumnInfo clone() {
 
     }
     private SimpleColumnInfo columnInfo;
-    private ProxyState proxyState;
+    private ProxyState<some.test.Simple> proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -83,7 +83,7 @@ public final SimpleColumnInfo clone() {
     private void injectObjectContext() {
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (SimpleColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState(some.test.Simple.class, this);
+        this.proxyState = new ProxyState<some.test.Simple>(some.test.Simple.class, this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -200,6 +200,10 @@ public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean al
 
             final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
 
+            if (table.hasPrimaryKey()) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+            }
+
             if (!columnTypes.containsKey("name")) {
                 throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
@@ -415,7 +419,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             }
         } else {
             unmanagedObject = new some.test.Simple();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
         }
         ((SimpleRealmProxyInterface) unmanagedObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
         ((SimpleRealmProxyInterface) unmanagedObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index a0810cb77c..5e1e6be367 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -126,6 +126,7 @@ repositories {
 dependencies {
     objectServerAnnotationProcessor project(':realm-annotations-processor')
     provided 'io.reactivex:rxjava:1.1.0'
+    provided 'com.google.code.findbugs:findbugs-annotations:3.0.1'
     compile "io.realm:realm-annotations:${version}"
     compile 'com.getkeepsafe.relinker:relinker:1.2.2'
     objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index c1a572e9c6..b273290f41 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -16,33 +16,46 @@
 
 package io.realm;
 
-import android.os.StrictMode;
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
 
 import junit.framework.AssertionFailedError;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
 import java.io.File;
-import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
 import io.realm.entities.Dog;
 import io.realm.exceptions.RealmFileException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmInMemoryTest {
 
-public class RealmInMemoryTest extends AndroidTestCase {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
     private final static String IDENTIFIER = "InMemRealmTest";
 
     private Realm testRealm;
     private RealmConfiguration inMemConf;
 
-    @Override
-    protected void setUp() throws Exception {
-        RealmConfiguration onDiskConf = new RealmConfiguration.Builder(getContext())
+    @Before
+    public void setUp() {
+        RealmConfiguration onDiskConf = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER)
                 .build();
-        inMemConf = new RealmConfiguration.Builder(getContext())
+        inMemConf = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER)
                 .inMemory()
                 .build();
@@ -52,8 +65,8 @@ protected void setUp() throws Exception {
         testRealm = Realm.getInstance(inMemConf);
     }
 
-    @Override
-    protected void tearDown() throws Exception {
+    @After
+    public void tearDown() {
         if (testRealm != null) {
             testRealm.close();
         }
@@ -61,14 +74,8 @@ protected void tearDown() throws Exception {
 
     // Testing the in-memory Realm by Creating one instance, adding a record, then close the instance.
     // By the next time in-memory Realm instance with the same name created, it should be empty.
-    // Use StrictMode to check no disk IO would happen in VM to this thread.
-    public void testInMemoryRealm() {
-        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
-                .detectDiskReads()
-                .detectDiskWrites()
-                .penaltyDeath()
-                .build());
-
+    @Test
+    public void inMemoryRealm() {
         testRealm.beginTransaction();
         Dog dog = testRealm.createObject(Dog.class);
         dog.setName("DinoDog");
@@ -82,19 +89,18 @@ public void testInMemoryRealm() {
         // in-mem-realm with same identifier should create a fresh new instance.
         testRealm = Realm.getInstance(inMemConf);
         assertEquals(testRealm.where(Dog.class).count(), 0);
-
-        StrictMode.enableDefaults();
     }
 
     // Two in-memory Realms with different names should not affect each other.
-    public void testInMemoryRealmWithDifferentNames() {
+    @Test
+    public void inMemoryRealmWithDifferentNames() {
         testRealm.beginTransaction();
         Dog dog = testRealm.createObject(Dog.class);
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
         // Create the 2nd in-memory Realm with a different name. To make sure they are not affecting each other.
-        RealmConfiguration inMemConf2 = new RealmConfiguration.Builder(getContext())
+        RealmConfiguration inMemConf2 = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER + "2")
                 .inMemory()
                 .build();
@@ -105,15 +111,18 @@ public void testInMemoryRealmWithDifferentNames() {
         testRealm2.commitTransaction();
 
         assertEquals(testRealm.where(Dog.class).count(), 1);
+        //noinspection ConstantConditions
         assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
         assertEquals(testRealm2.where(Dog.class).count(), 1);
+        //noinspection ConstantConditions
         assertEquals(testRealm2.where(Dog.class).findFirst().getName(), "UFODog");
 
         testRealm2.close();
     }
 
     // Test deleteRealm called on a in-memory Realm instance
-    public void testDelete() {
+    @Test
+    public void delete() {
         RealmConfiguration configuration = testRealm.getConfiguration();
         try {
             Realm.deleteRealm(configuration);
@@ -128,14 +137,15 @@ public void testDelete() {
     }
 
     // Test if an in-memory Realm can be written to disk with/without encryption
-    public void testWriteCopyTo() {
+    @Test
+    public void writeCopyTo() {
         byte[] key = TestHelper.getRandomKey();
         String fileName = IDENTIFIER + ".realm";
         String encFileName = IDENTIFIER + ".enc.realm";
-        RealmConfiguration conf = new RealmConfiguration.Builder(getContext())
+        RealmConfiguration conf = configFactory.createConfigurationBuilder()
                 .name(fileName)
                 .build();
-        RealmConfiguration encConf = new RealmConfiguration.Builder(getContext())
+        RealmConfiguration encConf = configFactory.createConfigurationBuilder()
                 .name(encFileName)
                 .encryptionKey(key)
                 .build();
@@ -149,19 +159,19 @@ public void testWriteCopyTo() {
         testRealm.commitTransaction();
 
         // Test a normal Realm file
-        testRealm.writeCopyTo(new File(getContext().getFilesDir(), fileName));
+        testRealm.writeCopyTo(new File(configFactory.getRoot(), fileName));
         Realm onDiskRealm = Realm.getInstance(conf);
         assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
 
         // Test a encrypted Realm file
-        testRealm.writeEncryptedCopyTo(new File(getContext().getFilesDir(), encFileName), key);
+        testRealm.writeEncryptedCopyTo(new File(configFactory.getRoot(), encFileName), key);
         onDiskRealm = Realm.getInstance(encConf);
         assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
         // Test with a wrong key to see if it fails as expected.
         try {
-            RealmConfiguration wrongKeyConf = new RealmConfiguration.Builder(getContext())
+            RealmConfiguration wrongKeyConf = configFactory.createConfigurationBuilder()
                     .name(encFileName)
                     .encryptionKey(TestHelper.getRandomKey(42))
                     .build();
@@ -179,7 +189,8 @@ public void testWriteCopyTo() {
     //    another instance is still held by the other thread.
     // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
     //    specific name exists.
-    public void testMultiThread() throws InterruptedException, ExecutionException {
+    @Test
+    public void multiThread() throws InterruptedException, ExecutionException {
         final CountDownLatch workerCommittedLatch = new CountDownLatch(1);
         final CountDownLatch workerClosedLatch = new CountDownLatch(1);
         final CountDownLatch realmInMainClosedLatch = new CountDownLatch(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index cbba8cc04c..cb26f70fb5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -47,6 +47,7 @@
 import io.realm.entities.PrimaryKeyAsShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.entities.Thread;
 import io.realm.entities.migration.MigrationClassRenamed;
 import io.realm.entities.migration.MigrationFieldRenamed;
 import io.realm.entities.migration.MigrationFieldTypeToInt;
@@ -196,11 +197,11 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     }
 
     @Test
-    public void notSettingPrimaryKeyThrows() {
+    public void addingPrimaryKeyThrows() {
 
         // Create v0 of the Realm
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
-                .schema(AllTypes.class)
+                .schema(Thread.class)
                 .build();
         Realm.getInstance(originalConfig).close();
 
@@ -218,14 +219,91 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         // Create v1 of the Realm
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
-                .schema(AllTypes.class, AnnotationTypes.class)
+                .schema(Thread.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+        try {
+            realm = Realm.getInstance(realmConfig);
+            fail();
+        } catch (RealmMigrationNeededException e) {
+            if (!e.getMessage().equals("Primary key not defined for field 'id' in existing Realm file. @PrimaryKey was added.")) {
+                fail(e.toString());
+            }
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void removingPrimaryKeyThrows() {
+
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(Thread.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("StringOnly")
+                        .addField("chars", String.class, FieldAttribute.PRIMARY_KEY);
+            }
+        };
+
+        // Create v1 of the Realm
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(Thread.class, StringOnly.class)
+                .migration(migration)
+                .build();
+        try {
+            realm = Realm.getInstance(realmConfig);
+            fail();
+        } catch (RealmMigrationNeededException e) {
+            if (!e.getMessage().equals("Primary Key defined for field chars was removed.")) {
+                fail(e.toString());
+            }
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void changingPrimaryKeyThrows() {
+
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(Thread.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("PrimaryKeyAsString")
+                        .addField("id", long.class, FieldAttribute.PRIMARY_KEY) // initial @PrimaryKey is on the int
+                        .addField("name", String.class);
+            }
+        };
+
+        // Create v1 of the Realm
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(Thread.class, PrimaryKeyAsString.class)
                 .migration(migration)
                 .build();
         try {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary key not defined for field 'id' in existing Realm file. Add @PrimaryKey.")) {
+            if (!e.getMessage().equals("Primary Key annotation definition was changed, from field id to field name")) {
                 fail(e.toString());
             }
         } finally {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index d23e6796c1..6ef934579b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -880,6 +880,90 @@ public void contains_caseSensitiveWithNonLatinCharacters() {
         assertEquals(0, resultList.size());
     }
 
+    @Test
+    public void like_caseSensitive() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).like("columnString", "*DaTa*").findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*DaTa*", Case.INSENSITIVE).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*DaTa 2?").findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*DaTa 2?", Case.INSENSITIVE).findAll();
+        assertEquals(10, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "TEST*0").findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "TEST*0", Case.INSENSITIVE).findAll();
+        assertEquals(20, resultList.size());
+    }
+
+    @Test
+    public void like_caseSensitiveWithNonLatinCharacters() {
+        populateTestRealm();
+
+        String flagEmoji = new StringBuilder().append(Character.toChars(0x1F1E9)).toString();
+        String emojis = "ABC" + flagEmoji + "DEF";
+
+        realm.beginTransaction();
+        realm.delete(AllTypes.class);
+        AllTypes at1 = realm.createObject(AllTypes.class);
+        at1.setColumnString("Αλφα");
+        AllTypes at2 = realm.createObject(AllTypes.class);
+        at2.setColumnString("βήτα");
+        AllTypes at3 = realm.createObject(AllTypes.class);
+        at3.setColumnString("δέλτα");
+        AllTypes at4 = realm.createObject(AllTypes.class);
+        at4.setColumnString(emojis);
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).like("columnString", "*Α*").findAll();
+         assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*λ*").findAll();
+        assertEquals(2, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*Δ*").findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*Α*", Case.INSENSITIVE).findAll();
+        //without ASCII-only limitation A matches α
+        //assertEquals(3, resultList.size());
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*λ*", Case.INSENSITIVE).findAll();
+        assertEquals(2, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*Δ*", Case.INSENSITIVE).findAll();
+        //without ASCII-only limitation Δ matches δ
+        //assertEquals(1, resultList.size());
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "?λ*").findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "??λ*").findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "?λ*").findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "??λ*").findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "ABC?DEF*").findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).like("columnString", "*" + flagEmoji + "*").findAll();
+        assertEquals(1, resultList.size());
+    }
+
     @Test
     public void equalTo_withNonExistingField() {
         try {
@@ -1258,6 +1342,17 @@ public void endsWith_nullStringPrimaryKey() {
         assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).endsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, (String) null).findAll().first().getId());
     }
 
+    @Test
+    public void like_nullStringPrimaryKey() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
+
+        assertEquals(
+                SECONDARY_FIELD_NUMBER,
+                realm.where(PrimaryKeyAsString.class).like(PrimaryKeyAsString.FIELD_PRIMARY_KEY, (String) null)
+                        .findAll().first().getId());
+    }
+
     @Test
     public void between_nullPrimaryKeysIsNotZero() {
         // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
@@ -1504,7 +1599,7 @@ public void beginWith_nullForNullableStrings() {
                 (String) null).findFirst().getFieldStringNotNull());
     }
 
-    // Querying nullable field with endsWith - all strings contain with null
+    // Querying nullable field with contains - all strings contain null
     @Test
     public void contains_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
@@ -1520,6 +1615,18 @@ public void endsWith_nullForNullableStrings() {
                 (String) null).findFirst().getFieldStringNotNull());
     }
 
+    // Querying nullable field with like - nulls do not match either '?' or '*'
+    @Test
+    public void like_nullForNullableStrings() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).like(NullTypes.FIELD_STRING_NULL, "*")
+                .findAll();
+        assertEquals(2, resultList.size());
+
+        resultList = realm.where(NullTypes.class).like(NullTypes.FIELD_STRING_NULL, "?").findAll();
+        assertEquals(0, resultList.size());
+    }
+
     // Querying with between and table has null values in row.
     @Test
     public void between_nullValuesInRow() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 5e65a027c3..5c8491f488 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -41,6 +41,7 @@
 import org.junit.runner.RunWith;
 
 import java.io.File;
+import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -3786,7 +3787,16 @@ public void namedPipeDirForExternalStorage() {
 
         Assume.assumeTrue("SELinux is not enforced on this device.", TestHelper.isSelinuxEnforcing());
 
-        assertEquals(2, namedPipeDir.list().length);
+        // Only check the fifo file created by call, since all Realm instances share the same fifo created by
+        // external_commit_helper which might not be created in the newly created dir if there are Realm instances
+        // are not deleted when TestHelper.deleteRecursively(namedPipeDir) called.
+        File[] files = namedPipeDir.listFiles(new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String name) {
+                return name.matches("realm_.*cv");
+            }
+        });
+        assertEquals(1, files.length);
 
         // test if it works when the namedPipeDir and the named pipe files already exist.
         realmOnExternalStorage = Realm.getInstance(config);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 321c5d927c..9c13abf838 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -778,12 +778,16 @@ public static void populateForDistinctFieldsOrder(Realm realm, long numberOfBloc
     }
 
     public static void awaitOrFail(CountDownLatch latch) {
-        awaitOrFail(latch, 7);
+        awaitOrFail(latch, 10);
     }
 
     public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
         try {
-            if (!latch.await(numberOfSeconds, TimeUnit.SECONDS)) {
+            if (android.os.Debug.isDebuggerConnected()) {
+                // If we are debugging the tests, just wait without a timeout. In case we are stopping at a break point
+                // and timeout happens.
+                latch.await();
+            } else if (!latch.await(numberOfSeconds, TimeUnit.SECONDS)) {
                 fail("Test took longer than " + numberOfSeconds + " seconds");
             }
         } catch (InterruptedException e) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 71f504509d..861d3e660c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -375,6 +375,8 @@ public void testNullInputQuery() {
         try { t.where().beginsWith(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
         try { t.where().endsWith(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
         try { t.where().endsWith(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().like(new long[]{1}, nullString);                            fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().like(new long[]{1}, nullString, Case.INSENSITIVE);          fail("String is null"); } catch (IllegalArgumentException e) { }
     }
 
 
@@ -448,9 +450,10 @@ public void testQueryWithWrongDataType() {
         for (int i = 0; i <= 6; i++) {
             try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
             try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            try { query.beginsWith(new long[]{i}, "string");            assert(false); } catch(IllegalArgumentException e) {}
-            try { query.endsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            try { query.contains(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.beginsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.endsWith(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
+            try { query.like(new long[]{i}, "string");                    assert(false); } catch(IllegalArgumentException e) {}
+            try { query.contains(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
         }
 
         // Compare integer in non integer columns
@@ -575,9 +578,10 @@ public void testColumnIndexOutOfBounds() {
         // Out of bounds for string
         try { query.equalTo(new long[]{7}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
         try { query.notEqualTo(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.beginsWith(new long[]{7}, "string");            assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.endsWith(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.beginsWith(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.endsWith(new long[]{7}, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.like(new long[]{7}, "string");                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{7}, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for integer
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index 9dab44e638..b0b339e230 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -169,7 +169,7 @@ public void onSchemaVersionChanged(long currentVersion) {
                 listenerCalled.set(true);
                 schemaVersionFromListener.set(currentVersion);
             }
-        });
+        }, true);
 
         final long before = sharedRealm.getSchemaVersion();
 
@@ -208,7 +208,7 @@ public void onSchemaVersionChanged(long currentVersion) {
                 listenerCalled.set(true);
                 schemaVersionFromListener.set(currentVersion);
             }
-        });
+        }, true);
 
         final long before = sharedRealm.getSchemaVersion();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
index f53221b9ef..79d55aedb8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
@@ -22,13 +22,13 @@
  * there does not exist.
  */
 public interface MigrationPrimaryKey {
-    public static String CLASS_NAME    = "MigrationPrimaryKey";
+    String CLASS_NAME    = "MigrationPrimaryKey";
 
-    public static String FIELD_FIRST   = "fieldFirst";
-    public static String FIELD_SECOND  = "fieldSecond";
+    String FIELD_FIRST   = "fieldFirst";
+    String FIELD_SECOND  = "fieldSecond";
 
     // this is original primary key field name.
-    public static String FIELD_PRIMARY = "fieldPrimary";
-    public static String FIELD_FOURTH  = "fieldFourth";
-    public static String FIELD_FIFTH   = "fieldFifth";
+    String FIELD_PRIMARY = "fieldPrimary";
+    String FIELD_FOURTH  = "fieldFourth";
+    String FIELD_FIFTH   = "fieldFifth";
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
index eaac178bb9..8143418f05 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
@@ -35,7 +35,7 @@
 
     @Test
     public void getUserInfo_isUnmodifiable() {
-        SyncCredentials creds = SyncCredentials.custom("foo", "bar", null);
+        SyncCredentials creds = SyncCredentials.custom("foo", "customProvider", null);
         Map<java.lang.String, Object> userInfo = creds.getUserInfo();
         try {
             userInfo.put("boom", null);
@@ -53,6 +53,18 @@ public void facebook() {
         assertTrue(creds.getUserInfo().isEmpty());
     }
 
+    @Test
+    public void facebook_invalidInput() {
+        String[] invalidInput = {null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.facebook(input);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
     @Test
     public void google() {
         SyncCredentials creds = SyncCredentials.google("foo");
@@ -63,11 +75,11 @@ public void google() {
     }
 
     @Test
-    public void facebook_invalidInput() {
-        String[] invalidInput = { null, ""};
+    public void google_invalidInput() {
+        String[] invalidInput = {null, ""};
         for (String input : invalidInput) {
             try {
-                SyncCredentials.facebook(input);
+                SyncCredentials.google(input);
                 fail(input + " should have failed");
             } catch (IllegalArgumentException ignored) {
             }
@@ -75,20 +87,27 @@ public void facebook_invalidInput() {
     }
 
     @Test
-    public void usernamePassword() {
+    public void usernamePassword_register() {
         SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar", true);
-        assertEquals("foo", creds.getUserIdentifier());
-        Map<String, Object> userInfo = creds.getUserInfo();
+        assertUsernamePassword(creds, "foo", "bar", true);
+    }
 
-        assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, creds.getIdentityProvider());
-        assertEquals("bar", userInfo.get("password"));
-        assertTrue((Boolean) userInfo.get("register"));
+    @Test
+    public void usernamePassword_noRegister() {
+        SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar", false);
+        assertUsernamePassword(creds, "foo", "bar", false);
+    }
+
+    @Test
+    public void usernamePassword_defaultRegister() {
+        SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar");
+        assertUsernamePassword(creds, "foo", "bar", false);
     }
 
     // Only validate username. All passwords are allowed
     @Test
     public void usernamePassword_invalidUserName() {
-        String[] invalidInput = { null, ""};
+        String[] invalidInput = {null, ""};
         for (String input : invalidInput) {
             try {
                 SyncCredentials.usernamePassword(input, "bar", true);
@@ -98,24 +117,18 @@ public void usernamePassword_invalidUserName() {
         }
     }
 
+    // Null passwords are allowed
     @Test
-    public void custom_invalidUserName() {
-        Map<String, Object> userInfo = new HashMap<>();
-        userInfo.put("custom", "property");
-        for (String username : new String[]{null, ""}) {
-            try {
-                SyncCredentials.custom("facebook", username, userInfo);
-                fail();
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
+    public void usernamePassword_nullPassword() {
+        SyncCredentials creds = SyncCredentials.usernamePassword("foo", null, true);
+        assertUsernamePassword(creds, "foo", null, true);
     }
 
     @Test
     public void custom() {
         Map<java.lang.String, Object> userInfo = new HashMap<String, Object>();
         userInfo.put("custom", "property");
-        SyncCredentials creds = SyncCredentials.custom("customProvider", "foo", userInfo);
+        SyncCredentials creds = SyncCredentials.custom("foo", "customProvider", userInfo);
 
         assertEquals("foo", creds.getUserIdentifier());
         assertEquals("customProvider", creds.getIdentityProvider());
@@ -124,16 +137,42 @@ public void custom() {
     }
 
     @Test
-    public void custom_invalidProvider() {
+    public void custom_invalidUserName() {
         Map<String, Object> userInfo = new HashMap<>();
-        userInfo.put("custom", "property");
 
-        for (String provider : new String[]{null, ""}) {
+        String[] invalidInput = {null, ""};
+        for (String username : invalidInput) {
             try {
-                SyncCredentials.custom(null, "foo", userInfo);
+                SyncCredentials.custom(username, SyncCredentials.IdentityProvider.FACEBOOK, userInfo);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
         }
     }
+
+    @Test
+    public void custom_invalidProvider() {
+        Map<String, Object> userInfo = new HashMap<>();
+
+        try {
+            SyncCredentials.custom("foo", null, userInfo);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    private void assertUsernamePassword(SyncCredentials creds, String username, String password, boolean register) {
+        assertEquals(username, creds.getUserIdentifier());
+
+        Map<String, Object> userInfo = creds.getUserInfo();
+        assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, creds.getIdentityProvider());
+
+        assertEquals(password, userInfo.get("password"));
+
+        Boolean registerActual = (Boolean) userInfo.get("register");
+        if (registerActual == null) {
+            registerActual = Boolean.FALSE;
+        }
+        assertEquals(register, registerActual);
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 48b1a8ef6b..18a8eb9aea 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -24,11 +24,18 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.net.URL;
 import java.util.Collection;
+import java.util.UUID;
 
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
 import io.realm.rule.RunInLooperThread;
 import io.realm.util.SyncTestUtils;
 
@@ -37,6 +44,9 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
 
 @RunWith(AndroidJUnit4.class)
 public class SyncUserTests {
@@ -74,6 +84,40 @@ public void currentUser_returnsNullIfUserExpired() {
         assertNull(SyncUser.currentUser());
     }
 
+    @Test
+    public void currentUser_throwsIfMultipleUsersLoggedIn() {
+        AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        SyncManager.setAuthServerImpl(authServer);
+        try {
+            // 1. Login two random users
+            when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenAnswer(new Answer<AuthenticateResponse>() {
+                @Override
+                public AuthenticateResponse answer(InvocationOnMock invocationOnMock) throws Throwable {
+                    return getNewRandomUser();
+                }
+            });
+            SyncUser.login(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
+            SyncUser.login(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
+
+            // 2. Verify currentUser() now throws
+            try {
+                SyncUser.currentUser();
+                fail();
+            } catch (IllegalStateException ignore) {
+            }
+        } finally {
+            SyncManager.setAuthServerImpl(originalAuthServer);
+        }
+
+    }
+
+    private AuthenticateResponse getNewRandomUser() {
+        String identity = UUID.randomUUID().toString();
+        String userTokenValue = UUID.randomUUID().toString();
+        return SyncTestUtils.createLoginResponse(userTokenValue, identity, Long.MAX_VALUE);
+    }
+
     // Test that current user is cleared if it is logged out
     @Test
     public void currentUser_clearedOnLogout() {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index bd067ab30b..ef3ead5f2f 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -35,21 +35,25 @@
     public static String REALM_TOKEN = UUID.randomUUID().toString();
     public static String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
 
+    public static SyncUser createRandomTestUser() {
+        return createTestUser(UUID.randomUUID().toString(), UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE);
+    }
+
     public static SyncUser createTestUser() {
-        return createTestUser(DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_AUTH_URL, Long.MAX_VALUE);
     }
 
     public static SyncUser createTestUser(long expires) {
-        return createTestUser(DEFAULT_AUTH_URL, expires);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_AUTH_URL, expires);
     }
 
     public static SyncUser createTestUser(String authUrl) {
-        return createTestUser(authUrl, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, REALM_TOKEN, authUrl, Long.MAX_VALUE);
     }
 
-    public static SyncUser createTestUser(String authUrl, long expires) {
-        Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
-        Token accessToken = new Token(REALM_TOKEN, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
+    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String authUrl, long expires) {
+        Token userToken = new Token(userTokenValue, "JohnDoe", null, expires, null);
+        Token accessToken = new Token(realmTokenValue, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
         ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
 
         JSONObject obj = new JSONObject();
@@ -70,8 +74,12 @@ public static SyncUser createTestUser(String authUrl, long expires) {
     }
 
     public static AuthenticateResponse createLoginResponse(long expires) {
+        return createLoginResponse(USER_TOKEN, "JohnDoe", expires);
+    }
+
+    public static AuthenticateResponse createLoginResponse(String userTokenValue, String userIdentity, long expires) {
         try {
-            Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
+            Token userToken = new Token(userTokenValue, userIdentity, null, expires, null);
             JSONObject response = new JSONObject();
             response.put("refresh_token", userToken.toJson());
             return AuthenticateResponse.from(response.toString());
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 19883ffcd3..cb52a9454c 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -116,9 +116,11 @@ endif()
 #      d.init(ValueBase::m_from_link_list, ValueBase::m_values, D{});
 #FIXME maybe-uninitialized is reported by table_view.cpp:272:15:
 #     'best.m_nanoseconds' was declared here
-set(WARNING_CXX_FLAGS "-Wall -Wextra -pedantic -Wno-long-long -Wno-variadic-macros \
--Wno-missing-field-initializers -Wmissing-declarations -Wno-error=uninitialized -Wno-error=maybe-uninitialized")
-set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DREALM_HAVE_EPOLL -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
+#     -Wno-missing-field-initializers disable in object store as well.
+set(WARNING_CXX_FLAGS "-Werror -Wall -Wextra -pedantic -Wmissing-declarations \
+    -Wempty-body -Wparentheses -Wunknown-pragmas -Wunreachable-code \
+    -Wno-missing-field-initializers  -Wno-maybe-uninitialized -Wno-uninitialized")
+set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
 if (build_SYNC)
     set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_ENABLE_SYNC=1")
 endif()
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index 87600fa09d..a3f98fc0ca 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -31,7 +31,6 @@ Java_io_realm_RealmFileUserStore_nativeGetCurrentUser (JNIEnv *env, jclass)
 {
     TR_ENTER()
     try {
-
         const std::shared_ptr<SyncUser> &user = SyncManager::shared().get_current_user();
         if (user) {
             return to_jstring(env, user->refresh_token().data());
@@ -92,7 +91,7 @@ Java_io_realm_RealmFileUserStore_nativeGetAllUsers (JNIEnv *env, jclass)
             ThrowException(env, OutOfMemory, ERR_COULD_NOT_ALLOCATE_MEMORY);
             return nullptr;
         }
-        for (int i = 0; i < len; ++i) {
+        for (size_t i = 0; i < len; ++i) {
             env->SetObjectArrayElement(users_token, i, to_jstring(env, all_users[i]->refresh_token().data()));
         }
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index e7da1e400c..17406c075b 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -30,6 +30,7 @@
 #include "io_realm_SyncManager.h"
 
 #include "jni_util/log.hpp"
+#include "jni_util/jni_utils.hpp"
 
 using namespace realm;
 using namespace realm::sync;
@@ -37,22 +38,8 @@ using namespace realm::jni_util;
 
 std::unique_ptr<Client> sync_client;
 
-static jclass sync_manager = nullptr;
-static jmethodID sync_manager_notify_error_handler = nullptr;
-
-static void error_handler(int error_code, std::string message)
-{
-    JNIEnv* env;
-    if (g_vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
-        throw std::runtime_error("JVM is not attached to this thread. Called in error_handler.");
-    }
-
-    env->CallStaticVoidMethod(sync_manager,
-                              sync_manager_notify_error_handler, error_code, env->NewStringUTF(message.c_str()));
-}
-
 JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncClient
-    (JNIEnv *env, jclass sync_manager_class)
+    (JNIEnv *env, jclass)
 {
     TR_ENTER()
     if (sync_client) return;
@@ -61,12 +48,6 @@ JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncClient
         sync::Client::Config config;
         config.logger = &CoreLoggerBridge::shared();
         sync_client = std::make_unique<Client>(std::move(config)); // Throws
-
-        // This function should only be called once, so below is safe.
-        sync_manager = reinterpret_cast<jclass>(env->NewGlobalRef(sync_manager_class));
-        sync_manager_notify_error_handler = env->GetStaticMethodID(sync_manager,
-                                                                   "notifyErrorHandler", "(ILjava/lang/String;)V");
-        sync_client->set_error_handler(error_handler);
     } CATCH_STD()
 }
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 6c78f94da9..37614dde25 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -4,6 +4,8 @@
 #include "object-store/src/sync/sync_config.hpp"
 #endif
 
+#include <realm/util/features.h>
+
 #include "object_store.hpp"
 #include "shared_realm.hpp"
 
@@ -41,7 +43,7 @@ Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv *env, jclass, jstring tempo
 JNIEXPORT jlong JNICALL
 Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstring realm_path, jbyteArray key,
         jbyte schema_mode, jboolean in_memory, jboolean cache, jboolean disable_format_upgrade,
-        jboolean auto_change_notification, jstring sync_server_url, jstring sync_user_token)
+        jboolean auto_change_notification, REALM_UNUSED jstring sync_server_url, jstring /*sync_user_token*/)
 {
     TR_ENTER()
 
@@ -56,11 +58,9 @@ Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstri
         config->cache = cache;
         config->disable_format_upgrade = disable_format_upgrade;
         config->automatic_change_notifications = auto_change_notification;
-#if REALM_ENABLE_SYNC
         if (sync_server_url) {
             config->force_sync_history = true;
         }
-#endif
         return reinterpret_cast<jlong>(config);
     } CATCH_STD()
 
@@ -166,6 +166,8 @@ Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv *env, jclass, jlong s
     try {
         return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
     } CATCH_STD()
+
+    return static_cast<jlong>(ObjectStore::NotVersioned);
 }
 
 JNIEXPORT void JNICALL
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 9c697bdca5..c42b2b23ad 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -1505,8 +1505,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
             else {
                 // Primary key already exists
                 // We only wish to check for duplicate values if a column isn't already a primary key
-                Row* row = new Row((*pk_table)[row_index]);
-                StringData current_primary_key = row->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX);
+                StringData current_primary_key = pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index);
                 if (new_primary_key_column_name != current_primary_key) {
                     if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
                         pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index 690bb7b3d2..7a9bd522c8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -19,9 +19,11 @@
 #include <shared_realm.hpp>
 #include <object_store.hpp>
 #include "util.hpp"
+#include "jni_util/java_local_ref.hpp"
 #include "io_realm_internal_TableQuery.h"
 
 using namespace realm;
+using namespace realm::jni_util;
 
 #if 1
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
@@ -829,7 +831,8 @@ enum StringPredicate {
     StringNotEqual,
     StringContains,
     StringBeginsWith,
-    StringEndsWith
+    StringEndsWith,
+    StringLike
 };
 
 
@@ -864,6 +867,9 @@ static void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongA
             case StringEndsWith:
                 Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, is_case_sensitive);
                 break;
+            case StringLike:
+                Q(nativeQueryPtr)->like(S(arr[0]), value2, is_case_sensitive);
+                break;
             }
         }
         else {
@@ -884,6 +890,9 @@ static void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongA
             case StringEndsWith:
                 Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).ends_with(StringData(value2), is_case_sensitive));
                 break;
+            case StringLike:
+                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).like(StringData(value2), is_case_sensitive));
+                break;
             }
         }
     } CATCH_STD()
@@ -913,6 +922,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEndsWith);
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLike(
+        JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+{
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringLike);
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
 {
@@ -1210,7 +1225,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
         // Step3: Run & export the queries against the latest shared group
         for (size_t i = 0; i < number_of_queries; ++i) {
             // Delete the local ref since we might have a long loop
-            JniLocalRef<jlongArray> local_ref(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
+            JavaLocalRef<jlongArray> local_ref(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
             JniLongArray query_param_array(env, local_ref);
 
             switch (query_param_array[0]) { // 0, index of the type of query, the next indicies are parameters
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 03bb3284a0..03241982e0 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -22,7 +22,10 @@
 #include "mem_usage.hpp"
 #include "util.hpp"
 
+#include "jni_util/jni_utils.hpp"
+
 using std::string;
+using namespace realm::jni_util;
 
 //#define USE_VLD
 #if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
@@ -39,7 +42,7 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         return JNI_ERR;
     }
     else {
-        g_vm = vm;
+        JniUtils::initialize(vm, JNI_VERSION_1_6);
         // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
         java_lang_long        = GetClass(env, "java/lang/Long");
         java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
index ea0ebecc4a..0caa7acccc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
@@ -70,11 +70,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_n
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeUnbind
-  (JNIEnv *env, jobject, jlong sessionPointer)
+  (JNIEnv *, jobject, jlong sessionPointer)
 {
     TR_ENTER()
     JniSession* session = SS(sessionPointer);
-    session->close(env);
     delete session; // TODO Can we avoid killing the session here?
 }
 
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
index b8954caeb6..f876847b86 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.cpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -15,46 +15,20 @@
  */
 
 #include "java_binding_context.hpp"
-
-#include "util/format.hpp"
+#include "jni_util/java_method.hpp"
 
 using namespace realm;
 using namespace realm::_impl;
-
-JavaBindingContext::JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
-    : m_local_jni_env(concrete_context.jni_env)
-{
-    jint ret = m_local_jni_env->GetJavaVM(&m_jvm);
-    if (ret != 0) {
-        throw std::runtime_error(util::format("Failed to get Java vm. Error: %d", ret));
-    }
-    if (concrete_context.java_notifier) {
-        m_java_notifier = m_local_jni_env->NewWeakGlobalRef(concrete_context.java_notifier);
-        jclass cls = m_local_jni_env->GetObjectClass(m_java_notifier);
-        m_notify_by_other_method = m_local_jni_env->GetMethodID(cls, "notifyCommitByOtherThread", "()V");
-    } else {
-        m_java_notifier = nullptr;
-    }
-}
-
-JavaBindingContext::~JavaBindingContext()
-{
-    if (m_java_notifier) {
-        // Always try to attach here since this may be called in the finalizer/phantom thread where m_local_jni_env
-        // should not be used on. No need to call DetachCurrentThread since this thread should always be created by
-        // JVM.
-        JNIEnv *env;
-        m_jvm->AttachCurrentThread(&env, nullptr);
-        env->DeleteWeakGlobalRef(m_java_notifier);
-    }
-}
+using namespace realm::jni_util;
 
 void JavaBindingContext::changes_available()
 {
-    jobject notifier = m_local_jni_env->NewLocalRef(m_java_notifier);
-    if (notifier) {
-        m_local_jni_env->CallVoidMethod(m_java_notifier, m_notify_by_other_method);
-        m_local_jni_env->DeleteLocalRef(notifier);
+    if (m_java_notifier) {
+        m_java_notifier.call_with_local_ref([&] (JNIEnv* env, jobject notifier_obj) {
+            // Method IDs from RealmNotifier implementation. Cache them as member vars.
+            static JavaMethod notify_by_other_method(env, notifier_obj, "notifyCommitByOtherThread", "()V");
+            env->CallVoidMethod(notifier_obj, notify_by_other_method);
+        });
     }
 }
 
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index a058691b3e..cba34dedba 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -22,6 +22,8 @@
 
 #include "binding_context.hpp"
 
+#include "jni_util/java_global_weak_ref.hpp"
+
 namespace realm {
 
 namespace _impl {
@@ -36,22 +38,16 @@ class JavaBindingContext final : public BindingContext {
             :jni_env(env), java_notifier(notifier) { }
     };
 
-    // The JNIEnv for the thread which creates the Realm. This should only be used on the current thread.
-    JNIEnv* m_local_jni_env;
-    // All methods should be called from the thread which creates the realm except the destructor which might be
-    // called from finalizer/phantom daemon. So we need a jvm pointer to create JNIEnv there if needed.
-    JavaVM* m_jvm;
     // A weak global ref to the implementation of RealmNotifier
     // Java should hold a strong ref to it as long as the SharedRealm lives
-    jobject m_java_notifier;
-    // Method IDs from RealmNotifier implementation. Cache them as member vars.
-    jmethodID m_notify_by_other_method;
+    jni_util::JavaGlobalWeakRef m_java_notifier;
 
 public:
-    virtual ~JavaBindingContext();
+    virtual ~JavaBindingContext() {};
     virtual void changes_available();
 
-    explicit JavaBindingContext(const ConcreteJavaBindContext&);
+    explicit JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
+            : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier) {}
     JavaBindingContext(const JavaBindingContext&) = delete;
     JavaBindingContext& operator=(const JavaBindingContext&) = delete;
     JavaBindingContext(JavaBindingContext&&) = delete;
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
new file mode 100644
index 0000000000..ceac7d8466
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_global_weak_ref.hpp"
+#include "java_local_ref.hpp"
+
+using namespace realm::jni_util;
+
+bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback> callback)
+{
+    if (!m_weak) {
+        return false;
+    }
+
+    JavaLocalRef<jobject> obj(env, m_weak, need_to_create_local_ref);
+
+    if (!obj) {
+        return false;
+    }
+    callback(env, obj);
+    return true;
+}
+
+bool JavaGlobalWeakRef::call_with_local_ref(std::function<Callback> callback)
+{
+    return call_with_local_ref(JniUtils::get_env(), callback);
+}
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
new file mode 100644
index 0000000000..676f92b37f
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JAVA_GLOBAL_WEAK_REF_HPP
+#define REALM_JNI_UTIL_JAVA_GLOBAL_WEAK_REF_HPP
+
+#include <jni.h>
+#include <functional>
+
+#include "jni_utils.hpp"
+
+namespace realm {
+namespace jni_util {
+
+// RAII wrapper for weak global ref.
+class JavaGlobalWeakRef {
+public:
+    JavaGlobalWeakRef() : m_weak(nullptr) {}
+    JavaGlobalWeakRef(JNIEnv* env, jobject obj) : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr) { }
+    ~JavaGlobalWeakRef()
+    {
+        if (m_weak) {
+            JniUtils::get_env()->DeleteWeakGlobalRef(m_weak);
+        }
+    }
+
+    // Implement those when needed.
+    JavaGlobalWeakRef(const JavaGlobalWeakRef&) = delete;
+    JavaGlobalWeakRef& operator=(const JavaGlobalWeakRef&) = delete;
+    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs) = delete;
+    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs) = delete;
+
+    inline operator bool() const noexcept
+    {
+        return m_weak != nullptr;
+    }
+
+    using Callback = void(JNIEnv* env, jobject obj);
+
+    // Acquire a local ref and run the callback with it if the weak ref is valid. The local ref will be deleted after
+    // callback finished. Return false if the weak ref is not valid anymore.
+    bool call_with_local_ref(JNIEnv* env, std::function<Callback> callback);
+    // Try to get an JNIEnv for current thread then run the callback.
+    bool call_with_local_ref(std::function<Callback> callback);
+
+private:
+    jweak m_weak;
+};
+
+} // namespace jni_util
+} // namespace realm
+
+#endif // REALM_JNI_UTIL_JAVA_GLOBAL_WEAK_REF_HPP
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
new file mode 100644
index 0000000000..7b38bb69a8
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JAVA_LOCAL_REF_HPP
+#define REALM_JNI_UTIL_JAVA_LOCAL_REF_HPP
+
+#include <jni.h>
+
+namespace realm {
+namespace jni_util {
+
+struct NeedToCreateLocalRef {};
+static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
+
+// Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
+// DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
+// program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap it
+// because the size of local reference table is relative small (512 bytes on Android).
+template <typename T>
+class JavaLocalRef {
+public:
+    // need_to_create is useful when acquire a local ref from a global weak ref.
+    inline JavaLocalRef(JNIEnv* env, T obj) noexcept : m_jobject(obj), m_env(env) {};
+    inline JavaLocalRef(JNIEnv* env, T obj, NeedToCreateLocalRef) noexcept
+            : m_jobject(env->NewLocalRef(obj)), m_env(env) {};
+    inline ~JavaLocalRef() { m_env->DeleteLocalRef(m_jobject); }
+
+    JavaLocalRef(const JavaLocalRef&) = delete;
+    JavaLocalRef& operator=(const JavaLocalRef&) = delete;
+    JavaLocalRef(JavaLocalRef&& rhs) = delete;
+    JavaLocalRef& operator=(JavaLocalRef&& rhs) = delete;
+
+    inline operator bool() const noexcept { return m_jobject != nullptr; };
+    inline operator T() const noexcept { return m_jobject; }
+
+private:
+    T m_jobject;
+    JNIEnv* m_env;
+};
+
+} // namespace realm
+} // namespace jni_util
+#endif // REALM_JNI_UTIL_JAVA_LOCAL_REF_HPP
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
new file mode 100644
index 0000000000..61f37748cd
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_method.hpp"
+
+#include <realm/util/assert.hpp>
+
+using namespace realm::jni_util;
+
+JavaMethod::JavaMethod(JNIEnv *env, jclass cls, const char* method_name, const char* signature)
+{
+    m_method_id = env->GetMethodID(cls, method_name, signature);
+    REALM_ASSERT_DEBUG(m_method_id != nullptr);
+}
+
+JavaMethod::JavaMethod(JNIEnv *env, jobject obj, const char* method_name, const char* signature)
+{
+    jclass cls = env->GetObjectClass(obj);
+    m_method_id = env->GetMethodID(cls, method_name, signature);
+    REALM_ASSERT_DEBUG(m_method_id != nullptr);
+    env->DeleteLocalRef(cls);
+}
+
+JavaMethod::JavaMethod(JNIEnv *env, const char* class_name, const char* method_name, const char* signature)
+{
+    jclass cls = env->FindClass(class_name);
+    REALM_ASSERT_DEBUG(cls != nullptr);
+    m_method_id = env->GetMethodID(cls, method_name, signature);
+}
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
new file mode 100644
index 0000000000..81c3fd64a4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JAVA_METHOD_HPP
+#define REALM_JNI_UTIL_JAVA_METHOD_HPP
+
+#include <jni.h>
+
+namespace realm {
+namespace jni_util {
+
+// RAII wrapper for java method ID. Since normally method ID stays unchanged for the whole JVM life cycle, it would be
+// safe to have a static JavaMethod object to avoid calling GetMethodID multiple times.
+class JavaMethod {
+public:
+    JavaMethod() : m_method_id(nullptr) {}
+    JavaMethod(JNIEnv *env, jclass cls, const char* method_name, const char* signature);
+    JavaMethod(JNIEnv *env, jobject obj, const char* method_name, const char* signature);
+    JavaMethod(JNIEnv *env, const char* class_name, const char* method_name, const char* signature);
+
+    JavaMethod(const JavaMethod&) = default;
+    JavaMethod& operator=(const JavaMethod&) = default;
+    JavaMethod(JavaMethod&& rhs) = delete;
+    JavaMethod& operator=(JavaMethod&& rhs) = delete;
+
+    ~JavaMethod() { }
+
+    inline operator bool() const noexcept { return m_method_id != nullptr; }
+    inline operator const jmethodID&() const noexcept { return m_method_id; }
+
+private:
+    jmethodID m_method_id;
+};
+
+} // namespace realm
+} // namespace jni_util
+
+#endif //REALM_JNI_UTIL_JAVA_METHOD_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
new file mode 100644
index 0000000000..7db8ce14d9
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jni_utils.hpp"
+
+#include <realm/util/assert.hpp>
+
+#include <memory>
+
+using namespace realm::jni_util;
+
+static std::unique_ptr<JniUtils> s_instance;
+
+void JniUtils::initialize(JavaVM *vm, jint vm_version) noexcept {
+    REALM_ASSERT_DEBUG(!s_instance);
+
+    s_instance = std::unique_ptr<JniUtils>(new JniUtils(vm, vm_version));
+}
+
+JNIEnv* JniUtils::get_env(bool attach_if_needed) {
+    REALM_ASSERT_DEBUG(s_instance);
+
+    JNIEnv* env;
+    if (s_instance->m_vm->GetEnv(reinterpret_cast<void**>(&env), s_instance->m_vm_version) != JNI_OK) {
+        if (attach_if_needed) {
+            jint ret = s_instance->m_vm->AttachCurrentThread(&env, nullptr);
+            REALM_ASSERT_RELEASE(ret == JNI_OK);
+        } else {
+            REALM_ASSERT_RELEASE(false);
+        }
+    }
+
+    return env;
+}
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
new file mode 100644
index 0000000000..61d8fbddfb
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JNI_UTILS_HPP
+#define REALM_JNI_UTIL_JNI_UTILS_HPP
+
+#include <jni.h>
+
+namespace realm {
+namespace jni_util {
+
+// Util functions for JNI.
+class JniUtils {
+public:
+    ~JniUtils() {}
+
+    // Call this only once in JNI_OnLoad.
+    static void initialize(JavaVM* vm, jint vm_version) noexcept;
+    // When attach_if_needed is false, returns the JNIEnv if there is one attached to this thread. Assert if there is
+    // none. When attach_if_needed is true, try to attach and return a JNIEnv if necessary.
+    static JNIEnv* get_env(bool attach_if_needed = false);
+
+private:
+    JniUtils(JavaVM* vm, jint vm_version) noexcept : m_vm(vm), m_vm_version(vm_version) {}
+
+    JavaVM* m_vm;
+    jint m_vm_version;
+};
+
+} // namespace realm
+} // namespace jni_util
+
+#endif //REALM_JNI_UTIL_JNI_UTILS_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
index 2e9ed01ae0..d4dfbefbc6 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -168,7 +168,7 @@ void Log::log(Level level, const char* tag, jthrowable throwable, const char* me
 void CoreLoggerBridge::do_log(realm::util::Logger::Level level, std::string msg)
 {
     // Ignore the level threshold from the root logger.
-    Log::Level jni_level;
+    Log::Level jni_level = Log::all; // Initial value to suppress the false positive compile warning.
     switch (level) {
         case Level::trace: jni_level = Log::trace; break;
         case Level::debug: // Fall through. Map to same level debug.
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 300a2d6f28..ac2f607264 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 300a2d6f284391540dcfd346893de49fa15e1771
+Subproject commit ac2f60726434654cace0bb5e57a92df7555c8f1f
diff --git a/realm/realm-library/src/main/cpp/objectserver_shared.hpp b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
index bd78254ba4..bf079cb824 100644
--- a/realm/realm-library/src/main/cpp/objectserver_shared.hpp
+++ b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
@@ -19,15 +19,20 @@
 #include <jni.h>
 #include <string>
 #include <thread>
+#include <memory>
 
 #include <realm/sync/history.hpp>
 #include <realm/sync/client.hpp>
+#include <realm/sync/protocol.hpp>
 #include <realm/util/logger.hpp>
 
 #include <impl/realm_coordinator.hpp>
 #include <sync/sync_manager.hpp>
 
 #include "util.hpp"
+#include "jni_util/jni_utils.hpp"
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
 
 
 // Wrapper class for realm::Session. This allows us to manage the C++ session and callback lifecycle correctly.
@@ -41,12 +46,14 @@ class JniSession {
     JniSession& operator=(JniSession&&) = delete;
 
     JniSession(JNIEnv* env, std::string local_realm_path, jobject java_session_obj)
+    : m_java_session_ref(std::make_shared<realm::jni_util::JavaGlobalWeakRef>(env, java_session_obj))
     {
         extern std::unique_ptr<realm::sync::Client> sync_client;
         // Get the coordinator for the given path, or null if there is none
         m_sync_session = new realm::sync::Session(*sync_client, local_realm_path);
-        m_java_session_ref = env->NewGlobalRef(java_session_obj);
-        jobject global_obj_ref_tmp(m_java_session_ref);
+        // error_handler could be called after JniSession destructed. So we need to pass a weak ref to lambda to avoid
+        // the corrupted pointer.
+        std::weak_ptr<realm::jni_util::JavaGlobalWeakRef> weak_session_ref(m_java_session_ref);
         auto sync_transact_callback = [local_realm_path](realm::VersionID, realm::VersionID) {
             auto coordinator = realm::_impl::RealmCoordinator::get_existing_coordinator(
                     realm::StringData(local_realm_path));
@@ -54,14 +61,28 @@ class JniSession {
                 coordinator->wake_up_notifier_worker();
             }
         };
-        auto error_handler = [&, global_obj_ref_tmp](int error_code, std::string message) {
-            JNIEnv *local_env;
-            g_vm->AttachCurrentThread(&local_env, nullptr);
-            jclass java_session_class = local_env->GetObjectClass(global_obj_ref_tmp);
-            jmethodID notify_error_handler = local_env->GetMethodID(java_session_class,
-                                                                       "notifySessionError", "(ILjava/lang/String;)V");
-            local_env->CallVoidMethod(global_obj_ref_tmp,
-                                      notify_error_handler, error_code, env->NewStringUTF(message.c_str()));
+        auto error_handler = [weak_session_ref](std::error_code error_code, bool is_fatal, const std::string message) {
+            if (error_code.category() != realm::sync::protocol_error_category() ||
+                    error_code.category() != realm::sync::client_error_category()) {
+                // FIXME: Consider below when moving to the OS sync manager.
+                // Ignore this error since it may cause exceptions in java ErrorCode.fromInt(). Throwing exception there
+                // will trigger "called with pending exception" later since the thread is created by java, and the
+                // endless loop is in native code. The java exception will never be thrown because of the endless loop
+                // will never quit to java land.
+                realm::jni_util::Log::e("Unhandled sync client error code %1, %2. is_fatal: %3.",
+                                        error_code.value(), error_code.message(), is_fatal);
+                return;
+            }
+
+            auto session_ref = weak_session_ref.lock();
+            if (session_ref) {
+                session_ref.get()->call_with_local_ref([&](JNIEnv* local_env, jobject obj) {
+                    static realm::jni_util::JavaMethod notify_error_handler(
+                            local_env, obj, "notifySessionError", "(ILjava/lang/String;)V");
+                    local_env->CallVoidMethod(
+                            obj, notify_error_handler, error_code.value(), local_env->NewStringUTF(message.c_str()));
+                });
+            }
         };
         m_sync_session->set_sync_transact_callback(sync_transact_callback);
         m_sync_session->set_error_handler(std::move(error_handler));
@@ -72,12 +93,6 @@ class JniSession {
         return m_sync_session;
     }
 
-    // Call this just before destroying the object to release JNI resources.
-    inline void close(JNIEnv* env)
-    {
-        env->DeleteGlobalRef(m_java_session_ref);
-    }
-
     ~JniSession()
     {
         delete m_sync_session;
@@ -85,7 +100,7 @@ class JniSession {
 
 private:
     realm::sync::Session* m_sync_session;
-    jobject m_java_session_ref;
+    std::shared_ptr<realm::jni_util::JavaGlobalWeakRef> m_java_session_ref;
 };
 
 #endif // REALM_OBJECTSERVER_SHARED_HPP
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 570bfa9185..840e0463cf 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -32,7 +32,6 @@ using namespace realm::util;
 using namespace realm::jni_util;
 
 // Caching classes and constructors for boxed types.
-JavaVM* g_vm;
 jclass java_lang_long;
 jmethodID java_lang_long_init;
 jclass java_lang_float;
@@ -68,7 +67,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (RealmFileException& e) {
-        ss << e.what() << " in " << file << " line " << line;
+        ss << e.what() << " (" <<  e.underlying() <<  ") in " << file << " line " << line;
         ThrowRealmFileException(env, ss.str(), e.kind());
     }
     catch (InvalidTransactionException& e) {
@@ -79,6 +78,9 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
+    catch (std::logic_error e) {
+        ThrowException(env, IllegalState, e.what());
+    }
     catch (exception& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, FatalError, ss.str());
@@ -166,11 +168,14 @@ void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::Rea
 
     jmethodID constructor = env->GetMethodID(cls, "<init>", "(BLjava/lang/String;)V");
     // Initial value to suppress gcc warning.
-    jbyte kind_code;
+    jbyte kind_code = -1; // To suppress compile warning.
     switch (kind) {
         case realm::RealmFileException::Kind::AccessError:
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_ACCESS_ERROR;
             break;
+        case realm::RealmFileException::Kind::BadHistoryError:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_BAD_HISTORY;
+            break;
         case realm::RealmFileException::Kind::PermissionDenied:
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_PERMISSION_DENIED;
             break;
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 98cce1fd3a..021752f6c3 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -636,30 +636,6 @@ class JniBooleanArray {
     jint                m_releaseMode;
 };
 
-// Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
-// DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
-// program returns to Java from native. But if the LocaRef is created in a loop, consider to use this class to wrap it
-// because the size of local reference table is relative small (512 on Android).
-template <typename T>
-class JniLocalRef {
-public:
-    JniLocalRef(JNIEnv* env, T obj) : m_jobject(obj), m_env(env) {};
-    ~JniLocalRef()
-    {
-        m_env->DeleteLocalRef(m_jobject);
-    }
-
-    inline operator T() const noexcept
-    {
-            return m_jobject;
-    }
-
-private:
-    T m_jobject;
-    JNIEnv* m_env;
-};
-
-extern JavaVM* g_vm;
 extern jclass java_lang_long;
 extern jmethodID java_lang_long_init;
 extern jclass java_lang_float;
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index c61b2cefae..0c02c401b3 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -86,7 +86,7 @@ protected BaseRealm(RealmConfiguration configuration) {
                     public void onSchemaVersionChanged(long currentVersion) {
                         RealmCache.updateSchemaCache((Realm) BaseRealm.this);
                     }
-                });
+                }, true);
         this.schema = new RealmSchema(this);
 
         if (handlerController.isAutoRefreshAvailable()) {
@@ -579,7 +579,6 @@ public void onResult(int count) {
      * Compacts the Realm file defined by the given configuration.
      *
      * @param configuration configuration for the Realm to compact.
-     * @throws IllegalArgumentException if Realm is encrypted.
      * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 071dcc6b77..5f76391b8a 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -33,6 +33,7 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.IdentitySet;
 import io.realm.internal.RealmObjectProxy;
@@ -602,6 +603,7 @@ private void notifyAsyncTransactionCallbacks() {
         }
     }
 
+    @SuppressFBWarnings("RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN")
     private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
         Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
         if (updatedRowKey.size() > 0) {
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 81c4bdebf1..fffb1f57eb 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -1539,6 +1539,7 @@ public void migrationComplete() {
      *
      * @param configuration a {@link RealmConfiguration}.
      * @return {@code false} if a file could not be deleted. The failing file will be logged.
+     * @throws IllegalStateException if not all realm instances are closed.
      */
     public static boolean deleteRealm(RealmConfiguration configuration) {
         return BaseRealm.deleteRealm(configuration);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index b9f6cc31c5..f42c9734df 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -45,7 +45,7 @@
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
  * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}.
  * <p>
- * The input to many of the query functions take a field name as String. Note that this is not type safe. If a 
+ * The input to many of the query functions take a field name as String. Note that this is not type safe. If a
  * RealmObject class is refactored care has to be taken to not break any queries.
  * <p>
  * A {@link io.realm.Realm} is unordered, which means that there is no guarantee that querying a Realm will return the
@@ -1238,9 +1238,9 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
+     * @param casing how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or field type.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
@@ -1248,6 +1248,44 @@ public boolean isValid() {
         return this;
     }
 
+    // Like
+
+    /**
+     * Condition that the value of field matches with the specified substring, with wildcards:
+     * <ul>
+     *   <li>'*' matches [0, n] unicode chars</li>
+     *   <li>'?' matches a single unicode char.</li>
+     * </ul>
+     *
+     * @param fieldName the field to compare.
+     * @param value the wildcard string.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> like(String fieldName, String value) {
+        return like(fieldName, value, Case.SENSITIVE);
+    }
+
+    /**
+     * Condition that the value of field matches with the specified substring, with wildcards:
+     * <ul>
+     *   <li>'*' matches [0, n] unicode chars</li>
+     *   <li>'?' matches a single unicode char.</li>
+     * </ul>
+     *
+     * @param fieldName the field to compare.
+     * @param value the wildcard string.
+     * @param casing how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> like(String fieldName, String value, Case casing) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.like(columnIndices, value, casing);
+        return this;
+    }
+
+
     // Grouping
 
     /**
@@ -1890,7 +1928,7 @@ public Long call() throws Exception {
      *
      * @param fieldNames an array of field names to sort by.
      * @param sortOrders how to sort the field names.
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero 
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
      *         objects is returned.
      * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
index 07b63b39c8..e4bca48d1b 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -32,6 +32,10 @@
          * Thrown for any I/O related exception scenarios when a Realm is opened.
          */
         ACCESS_ERROR,
+        /**
+         *  Thrown if the history type of the on-disk Realm is unexpected or incompatible.
+         */
+        BAD_HISTORY,
         /**
          * Thrown if the user does not have permission to open or create the specified file in the specified access
          * mode when the Realm is opened.
@@ -70,6 +74,8 @@ static Kind getKind(byte value) {
                     return INCOMPATIBLE_LOCK_FILE;
                 case SharedRealm.FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED:
                     return FORMAT_UPGRADE_REQUIRED;
+                case SharedRealm.FILE_EXCEPTION_KIND_BAD_HISTORY:
+                    return BAD_HISTORY;
                 default:
                     throw new RuntimeException("Unknown value for RealmFileException kind.");
             }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index e7ad6c0417..cc3f52827e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -27,11 +27,12 @@
 
     // Const value for RealmFileException conversion
     public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
-    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 1;
-    public static final byte FILE_EXCEPTION_KIND_EXISTS = 2;
-    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 3;
-    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 4;
-    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 5;
+    public static final byte FILE_EXCEPTION_KIND_BAD_HISTORY = 1;
+    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 2;
+    public static final byte FILE_EXCEPTION_KIND_EXISTS = 3;
+    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 4;
+    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 5;
+    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 6;
 
     public static void initialize(File tempDirectory) {
         if (SharedRealm.temporaryDirectory != null) {
@@ -178,18 +179,20 @@ private SharedRealm(long nativePtr, RealmConfiguration configuration, RealmNotif
         objectServerFacade = null;
     }
 
+    // This will create a SharedRealm where autoChangeNotifications is false,
+    // If autoChangeNotifications is true, an additional SharedGroup might be created in the OS's external commit helper.
+    // That is not needed for some cases: eg.: An extra opened SharedGroup will cause a compact failure.
     public static SharedRealm getInstance(RealmConfiguration config) {
-        return getInstance(config, null, null);
+        return getInstance(config, null, null, false);
     }
 
     public static SharedRealm getInstance(RealmConfiguration config, RealmNotifier realmNotifier,
-                                          SchemaVersionListener schemaVersionListener) {
+                                          SchemaVersionListener schemaVersionListener, boolean autoChangeNotifications) {
         String[] userAndServer = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
         String rosServerUrl = userAndServer[0];
         String rosUserToken = userAndServer[1];
         boolean enable_caching = false; // Handled in Java currently
         boolean disableFormatUpgrade = false; // TODO Double negatives :/
-        boolean autoChangeNotifications = true;
         long nativeConfigPtr = nativeCreateConfig(
                 config.getPath(),
                 config.getEncryptionKey(),
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index d8c6433681..05cdae38d5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -386,6 +386,18 @@ public TableQuery endsWith(long columnIndices[], String value) {
         return this;
     }
 
+    public TableQuery like(long columnIndices[], String value, Case caseSensitive) {
+        nativeLike(nativePtr, columnIndices, value, caseSensitive.getValue());
+        queryValidated = false;
+        return this;
+    }
+
+    public TableQuery like(long columnIndices[], String value) {
+        nativeLike(nativePtr, columnIndices, value, true);
+        queryValidated = false;
+        return this;
+    }
+
     public TableQuery contains(long columnIndices[], String value, Case caseSensitive) {
         nativeContains(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
@@ -752,6 +764,7 @@ private void throwImmutable() {
     private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
     private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
     private native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeLike(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
     private native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
     private native void nativeIsEmpty(long nativePtr, long[] columnIndices);
     private native long nativeFind(long nativeQueryPtr, long fromTableRow);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 7f251618a2..7d943b06a1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -16,6 +16,8 @@
 
 package io.realm.internal.async;
 
+import java.io.File;
+import java.io.FileFilter;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
@@ -23,8 +25,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.regex.Pattern;
 
-import io.realm.Realm;
+import edu.umd.cs.findbugs.annotations.SuppressWarnings;
 
 /**
  * Custom thread pool settings, instances of this executor can be paused, and resumed, this will also set
@@ -32,9 +35,10 @@
  * <a href="https://developer.android.com/training/multiple-threads/define-runnable.html"> Androids recommendation</a>.
  */
 public class RealmThreadPoolExecutor extends ThreadPoolExecutor {
-    // reduce context switch by using a number of thread proportionate to the number of cores
-    // from AOSP https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/os/AsyncTask.java#182
-    private static final int CORE_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2 + 1;
+    private static final String SYS_CPU_DIR = "/sys/devices/system/cpu/";
+
+    // reduce context switching by using a number of thread proportionate to the number of cores
+    private static final int CORE_POOL_SIZE = calculateCorePoolSize();
     private static final int QUEUE_SIZE = 100;
 
     private boolean isPaused;
@@ -55,6 +59,42 @@ public static RealmThreadPoolExecutor newSingleThreadExecutor() {
         return new RealmThreadPoolExecutor(1, 1);
     }
 
+    /**
+     * Try using the number of files named 'cpuNN' in sysfs to figure out the number of
+     * processors on this device. `Runtime.getRuntime().availableProcessors()` may return
+     * a smaller number when the device is sleeping.
+     *
+     * @return the number of threads to be allocated for the executor pool
+     */
+    @SuppressWarnings("DMI_HARDCODED_ABSOLUTE_FILENAME")
+    private static int calculateCorePoolSize() {
+        int cpus = countFilesInDir(SYS_CPU_DIR, "cpu[0-9]+");
+        if (cpus <= 0) {
+            cpus = Runtime.getRuntime().availableProcessors();
+        }
+        return (cpus <= 0) ? 1 : (cpus * 2) + 1;
+    }
+
+    /**
+     * @param dirPath A directory path
+     * @param pattern A regex
+     * @return the number of files, in the `dirPath` directory, whose names match `pattern`
+     */
+    private static int countFilesInDir(String dirPath, String pattern) {
+        final Pattern filePattern = Pattern.compile(pattern);
+        try {
+            File[] files = new File(dirPath).listFiles(new FileFilter() {
+                @Override
+                public boolean accept(File file) {
+                    return filePattern.matcher(file.getName()).matches();
+                }
+            });
+            return (files == null) ? 0 : files.length;
+        } catch (SecurityException ignore) {
+        }
+        return 0;
+    }
+
     private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
         super(corePoolSize, maxPoolSize,
                 0L, TimeUnit.MILLISECONDS, //terminated idle thread
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 827f1265cf..02e925643c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -66,12 +66,38 @@
 @Beta
 public class SyncCredentials {
 
-    private String identityProvider;
-    private String userIdentifier;
-    private Map<String, Object> userInfo;
+    private final String userIdentifier;
+    private final String identityProvider;
+    private final Map<String, Object> userInfo;
 
     // Factory constructors
 
+    /**
+     * Creates credentials based on a Facebook login.
+     *
+     * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials facebook(String facebookToken) {
+        assertStringNotEmpty(facebookToken, "facebookToken");
+        return new SyncCredentials(facebookToken, IdentityProvider.FACEBOOK, null);
+    }
+
+    /**
+     * Creates credentials based on a Google login.
+     *
+     * @param googleToken a google userIdentifier acquired by logging into Google.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials google(String googleToken) {
+        assertStringNotEmpty(googleToken, "googleToken");
+        return new SyncCredentials(googleToken, IdentityProvider.GOOGLE, null);
+    }
+
     /**
      * Creates credentials based on a login with username and password. These credentials will only be verified
      * by the Object Server.
@@ -86,51 +112,33 @@
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password, boolean createUser) {
-        if (username == null || username.equals("")) {
-            throw new IllegalArgumentException("Non-null 'username' required.");
-        }
+        assertStringNotEmpty(username, "username");
         Map<String, Object> userInfo = new HashMap<String, Object>();
         userInfo.put("register", createUser);
         userInfo.put("password", password);
-        return new SyncCredentials(IdentityProvider.USERNAME_PASSWORD, username, userInfo);
+        return new SyncCredentials(username, IdentityProvider.USERNAME_PASSWORD, userInfo);
     }
 
     /**
-     * Creates credentials based on a Facebook login.
-     *
-     * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
-     * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
-     * @throws IllegalArgumentException if user name is either {@code null} or empty.
-     */
-    public static SyncCredentials facebook(String facebookToken) {
-        if (facebookToken == null || facebookToken.equals("")) {
-            throw new IllegalArgumentException("Non-null 'facebookToken' required.");
-        }
-        return new SyncCredentials(IdentityProvider.FACEBOOK, facebookToken, null);
-    }
-
-    /**
-     * Creates credentials based on a Google login.
+     * Creates credentials based on a login with username and password. These credentials will only be verified
+     * by the Object Server.  The user is not created if she does not exist.
      *
-     * @param googleToken a google userIdentifier acquired by logging into Google.
+     * @param username username of the user.
+     * @param password the users password.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
-    public static SyncCredentials google(String googleToken) {
-        if (googleToken == null || googleToken.equals("")) {
-            throw new IllegalArgumentException("Non-null 'googleToken' required.");
-        }
-        return new SyncCredentials(IdentityProvider.GOOGLE, googleToken, null);
+    public static SyncCredentials usernamePassword(String username, String password) {
+        return usernamePassword(username, password, false);
     }
 
     /**
      * Creates a custom set of credentials. The behaviour will depend on the type of {@code identityProvider} and
      * {@code userInfo} used.
      *
-     * @param identityProvider provider used to verify the credentials.
      * @param userIdentifier String identifying the user. Usually a username of userIdentifier.
+     * @param identityProvider provider used to verify the credentials.
      * @param userInfo data describing the user further or {@code null} if the user does not have any extra data. The
      *              data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
      *              classes will be converted using {@code toString()}.
@@ -138,20 +146,22 @@ public static SyncCredentials google(String googleToken) {
      *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if any parameter is either {@code null} or empty.
      */
-    public static SyncCredentials custom(String identityProvider, String userIdentifier, Map<String, Object> userInfo) {
-        if (identityProvider == null || identityProvider.equals("")) {
-            throw new IllegalArgumentException("Non-null 'identityProvider' required.");
-        }
-        if (userIdentifier == null || userIdentifier.equals("")) {
-            throw new IllegalArgumentException("Non-null 'userIdentifier' required.");
-        }
+    public static SyncCredentials custom(String userIdentifier, String identityProvider, Map<String, Object> userInfo) {
+        assertStringNotEmpty(userIdentifier, "userIdentifier");
+        assertStringNotEmpty(identityProvider, "identityProvider");
         if (userInfo == null) {
             userInfo = new HashMap<String, Object>();
         }
-        return new SyncCredentials(identityProvider, userIdentifier, userInfo);
+        return new SyncCredentials(userIdentifier, identityProvider, userInfo);
+    }
+
+    private static void assertStringNotEmpty(String string, String message) {
+        if (string == null || "".equals(string)) {
+            throw new IllegalArgumentException("Non-null '" + message + "' required.");
+        }
     }
 
-    private SyncCredentials(String identityProvider, String token, Map<String, Object> userInfo) {
+    private SyncCredentials(String token, String identityProvider, Map<String, Object> userInfo) {
         this.identityProvider = identityProvider;
         this.userIdentifier = token;
         this.userInfo = (userInfo == null) ? new HashMap<String, Object>() : userInfo;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 0fd80867e4..3406054f72 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -21,6 +21,7 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.annotations.Beta;
 import io.realm.internal.Keep;
 import io.realm.internal.network.AuthenticationServer;
@@ -43,6 +44,7 @@
  */
 @Keep
 @Beta
+@SuppressFBWarnings("MS_CANNOT_BE_FINAL")
 public class SyncManager {
 
     /**
@@ -205,17 +207,6 @@ static UserStore getUserStore() {
         return userStore;
     }
 
-    // This is called from SyncManager.cpp from the worker thread the Sync Client is running on
-    // Right now Core doesn't send these errors to the proper session, so instead we need to notify all sessions
-    // from here. This can be removed once better error propagation is implemented in Sync Core.
-    @SuppressWarnings("unused")
-    private static void notifyErrorHandler(int errorCode, String errorMessage) {
-        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
-        for (ObjectServerSession session : SessionStore.getAllSessions()) {
-            session.onError(error);
-        }
-    }
-
     // Notify listeners that a user logged in
     static void notifyUserLoggedIn(SyncUser user) {
         for (AuthenticationListener authListener : authListeners) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 0aabe1e5d9..046295c876 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -107,7 +107,10 @@ protected void finalize() throws Throwable {
      */
     public interface ErrorHandler {
         /**
-         * Callback for errors on a session object.
+         * Callback for errors on a session object. It is not allowed to throw an exception inside an error handler.
+         * If the operations in an error handler can throw, it is safer to catch any exception in the error handler.
+         * When an exception is thrown in the error handler, the occurrence will be logged and the exception
+         * will be ignored.
          *
          * @param session {@link SyncSession} this error happened on.
          * @param error type of error.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index a892c980bb..c1097e8118 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -44,7 +44,6 @@
 import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
-import io.realm.permissions.PermissionChange;
 import io.realm.permissions.PermissionModule;
 
 /**
@@ -62,7 +61,25 @@
 @Beta
 public class SyncUser {
 
-    private SyncConfiguration managementRealmConfig;
+    private static class ManagementConfig {
+        private SyncConfiguration managementRealmConfig;
+
+        synchronized SyncConfiguration initAndGetManagementRealmConfig(
+                ObjectServerUser syncUser, SyncUser user) {
+            if (managementRealmConfig == null) {
+                managementRealmConfig = new SyncConfiguration.Builder(
+                        user, getManagementRealmUrl(syncUser.getAuthenticationUrl()))
+                        .modules(new PermissionModule())
+                        .build();
+            }
+
+            return managementRealmConfig;
+        }
+    }
+
+
+    private final ManagementConfig managementConfig = new ManagementConfig();
+
     private final ObjectServerUser syncUser;
 
     private SyncUser(ObjectServerUser user) {
@@ -70,11 +87,12 @@ private SyncUser(ObjectServerUser user) {
     }
 
     /**
-     * Returns the last user that has logged in and who is still valid.
-     * A user is invalidated when he/she logs out or the user's access token expire.
+     * Returns the current user that is logged in and still valid.
+     * A user is invalidated when he/she logs out or the user's access token expires.
      *
-     * @return last {@link SyncUser} that has logged in and who is still valid. {@code null} if no current user or user has
-     *         been invalidated.
+     * @return current {@link SyncUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has
+     *         expired.
+     * @throws IllegalStateException if multiple users are logged in.
      */
     public static SyncUser currentUser() {
         SyncUser user = SyncManager.getUserStore().get();
@@ -203,7 +221,12 @@ private void postError(final ObjectServerError error) {
                     handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            callback.onError(error);
+                            try {
+                                callback.onError(error);
+                            } catch (Exception e) {
+                                RealmLog.info("onError has thrown an exception but is ignoring it: %s",
+                                        Util.getStackTrace(e));
+                            }
                         }
                     });
                 }
@@ -364,16 +387,7 @@ public String getAccessToken() {
      * @see <a href="https://realm.io/docs/realm-object-server/#permissions">How to control permissions</a>
      */
     public Realm getManagementRealm() {
-        synchronized (this) {
-            if (managementRealmConfig == null) {
-                String managementUrl = getManagementRealmUrl(syncUser.getAuthenticationUrl());
-                managementRealmConfig = new SyncConfiguration.Builder(this, managementUrl)
-                        .modules(new PermissionModule())
-                        .build();
-            }
-        }
-
-        return Realm.getInstance(managementRealmConfig);
+        return Realm.getInstance(managementConfig.initAndGetManagementRealmConfig(syncUser, this));
     }
 
     // Creates the URL to the permission Realm based on the authentication URL.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
index e8d402d259..19f88c840f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
@@ -18,6 +18,7 @@
 import java.util.Date;
 import java.util.UUID;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.Required;
@@ -78,10 +79,12 @@ public String getId() {
         return id;
     }
 
+    @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
     }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index ccf997a3b8..bf6a0fc4df 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -9,10 +9,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.SyncCredentials;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
+import io.realm.SyncCredentials;
 import io.realm.SyncUser;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.HttpUtils;
@@ -66,4 +66,32 @@ public void onError(ObjectServerError error) {
             }
         });
     }
+
+    // The error handler throws an exception but it is ignored (but logged). That means, this test should not
+    // pass and not be stopped by an IllegalArgumentException.
+    @Test
+    @RunTestInLooperThread
+    public void loginAsync_errorHandlerThrows() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
+                throw new IllegalArgumentException("BOOM");
+            }
+        });
+
+        try {
+            Thread.sleep(2000);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+            fail();
+        }
+        looperThread.testComplete();
+    }
 }
