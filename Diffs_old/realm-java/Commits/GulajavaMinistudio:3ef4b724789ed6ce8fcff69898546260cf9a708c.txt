diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3cb8140005..f03336384a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -7,6 +7,7 @@
 ### Enhancements
 
 * [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
+* [ObjectServer] Added `SyncSession.getState()` (#4784).
 * Added support for querying inverse relationships (#2904).
 * Moved inverse relationships out of beta stage.
 * Added `Realm.getDefaultConfiguration()` (#4725).
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 37bf4c087a..8a132d05ea 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -26,13 +26,28 @@
 #include "jni_util/java_global_ref.hpp"
 #include "jni_util/java_method.hpp"
 #include "jni_util/java_class.hpp"
-#include "jni_util/java_local_ref.hpp"
 #include "jni_util/jni_utils.hpp"
 
 using namespace realm;
 using namespace jni_util;
 using namespace sync;
 
+static_assert(SyncSession::PublicState::WaitingForAccessToken ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_WAITING_FOR_ACCESS_TOKEN),
+              "");
+static_assert(SyncSession::PublicState::Active ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_ACTIVE),
+              "");
+static_assert(SyncSession::PublicState::Dying ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_DYING),
+              "");
+static_assert(SyncSession::PublicState::Inactive ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_INACTIVE),
+              "");
+static_assert(SyncSession::PublicState::Error ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_ERROR),
+              "");
+
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
                                                                               jstring j_local_realm_path,
                                                                               jstring j_access_token,
@@ -156,3 +171,30 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadComple
     CATCH_STD()
     return JNI_FALSE;
 }
+
+JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetState(JNIEnv* env, jclass,
+                                                                 jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            switch (session->state()) {
+                case SyncSession::PublicState::WaitingForAccessToken:
+                    return io_realm_SyncSession_STATE_VALUE_WAITING_FOR_ACCESS_TOKEN;
+                case SyncSession::PublicState::Active:
+                    return io_realm_SyncSession_STATE_VALUE_ACTIVE;
+                case SyncSession::PublicState::Dying:
+                    return io_realm_SyncSession_STATE_VALUE_DYING;
+                case SyncSession::PublicState::Inactive:
+                    return io_realm_SyncSession_STATE_VALUE_INACTIVE;
+                case SyncSession::PublicState::Error:
+                    return io_realm_SyncSession_STATE_VALUE_ERROR;
+            }
+        }
+    }
+    CATCH_STD()
+    return -1;
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 821d489b3d..98e79f0026 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -78,20 +78,13 @@ public static File getTemporaryDirectory() {
         }
     }
 
-    // Public for static checking in JNI
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_READONLY = 1;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_RESET_FILE = 2;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_ADDITIVE = 3;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_MANUAL = 4;
-
-    @SuppressWarnings("WeakerAccess")
-    public enum SchemaMode {
+    private static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
+    private static final byte SCHEMA_MODE_VALUE_READONLY = 1;
+    private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 2;
+    private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 3;
+    private static final byte SCHEMA_MODE_VALUE_MANUAL = 4;
+
+    private enum SchemaMode {
         SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
         SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
         SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 601692f367..846f79f290 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -86,6 +86,38 @@
     // we register the listener.
     private final AtomicLong progressListenerId = new AtomicLong(-1);
 
+    // represent different states as defined in SyncSession::PublicState 'sync_session.hpp'
+    private static final byte STATE_VALUE_WAITING_FOR_ACCESS_TOKEN = 0;
+    private static final byte STATE_VALUE_ACTIVE = 1;
+    private static final byte STATE_VALUE_DYING = 2;
+    private static final byte STATE_VALUE_INACTIVE = 3;
+    private static final byte STATE_VALUE_ERROR = 4;
+
+    public enum State {
+        WAITING_FOR_ACCESS_TOKEN(STATE_VALUE_WAITING_FOR_ACCESS_TOKEN),
+        ACTIVE(STATE_VALUE_ACTIVE),
+        DYING(STATE_VALUE_DYING),
+        INACTIVE(STATE_VALUE_INACTIVE),
+        ERROR(STATE_VALUE_ERROR);
+
+        final byte value;
+
+        State(byte value) {
+            this.value = value;
+        }
+
+        static State fromByte(byte value) {
+            State[] stateCodes = values();
+            for (State state : stateCodes) {
+                if (state.value == value) {
+                    return state;
+                }
+            }
+
+            throw new IllegalArgumentException("Unknown state code: " + value);
+        }
+    }
+
     SyncSession(SyncConfiguration configuration) {
         this.configuration = configuration;
         this.errorHandler = configuration.getErrorHandler();
@@ -136,6 +168,27 @@ void notifySessionError(int errorCode, String errorMessage) {
         }
     }
 
+    /**
+     * Get the current session's state, as defined in {@link SyncSession.State}.
+     *
+     * Note that the state may change after this method returns, example: the authentication
+     * token will expire, causing the session to move to {@link State#WAITING_FOR_ACCESS_TOKEN}
+     * after it was in {@link State#ACTIVE}.
+     *
+     * @return the state of the session.
+     * @see SyncSession.State
+     */
+    @KeepMember
+    @SuppressWarnings("unused")
+    public State getState() {
+        byte state = nativeGetState(configuration.getPath());
+        if (state == -1) {
+            // session was not found, probably the Realm was closed
+            throw new IllegalStateException("Could not find session, Realm was probably closed");
+        }
+        return State.fromByte(state);
+    }
+
     synchronized void notifyProgressListener(long listenerId, long transferredBytes, long transferableBytes) {
         Pair<ProgressListener, Progress> listener = listenerIdToProgressListenerMap.get(listenerId);
         if (listener != null) {
@@ -589,6 +642,7 @@ public void throwExceptionIfNeeded() {
 
     private static native long nativeAddProgressListener(String localRealmPath, long listenerId, int direction, boolean isStreaming);
     private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
-    private static native boolean nativeRefreshAccessToken(String path, String accessToken, String realmUrl);
-    private native boolean nativeWaitForDownloadCompletion(String path);
+    private static native boolean nativeRefreshAccessToken(String localRealmPath, String accessToken, String realmUrl);
+    private native boolean nativeWaitForDownloadCompletion(String localRealmPath);
+    private static native byte nativeGetState(String localRealmPath);
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
new file mode 100644
index 0000000000..695fd03989
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
@@ -0,0 +1,82 @@
+package io.realm.objectserver;
+
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.TimeUnit;
+
+import io.realm.BaseIntegrationTest;
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.TestSyncConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncSessionTests extends BaseIntegrationTest {
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Test
+    public void getState_active() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .waitForInitialRemoteData()
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+
+        // make sure the `access_token` is acquired. otherwise we can still be
+        // in WAITING_FOR_ACCESS_TOKEN state
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));
+
+        assertEquals(SyncSession.State.ACTIVE, session.getState());
+        realm.close();
+    }
+
+    @Test
+    public void getState_inactive() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .waitForInitialRemoteData()
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        user.logout();
+        assertEquals(SyncSession.State.INACTIVE, session.getState());
+
+        realm.close();
+    }
+
+    @Test
+    public void getState_closedRealm() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .waitForInitialRemoteData()
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        realm.close();
+        try {
+            session.getState();
+            fail("Realm was closed, getState should not return");
+        } catch (IllegalStateException expected) {
+        }
+    }
+}
