diff --git a/CHANGELOG.md b/CHANGELOG.md
index e2fdb3786b..cd67e02160 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -21,6 +21,7 @@
 * `Realm.copyToRealmOrUpdate()` might cause a `RealmList` field to contain duplicated elements (#4957).
 * `RealmSchema.create(String)` and `RealmObjectSchema.setClassName(String)` did not accept class name whose length was 51 to 57.
 * Workaround for an Android JVM crash when using `compactOnLaunch()` (#4964).
+* Class name in exception message from link query is wrong (#5096).
 
 ### Internal
 
diff --git a/README.md b/README.md
index dcc6c95e01..9fa3aa0cd3 100644
--- a/README.md
+++ b/README.md
@@ -24,7 +24,7 @@ The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/j
 - **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) â€” or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We activtely monitor & answer questions on SO!
 - **Have a bug to report?** [Open an issue](https://github.com/realm/realm-java/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
 - **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new). Tell us what the feature should do, and why you want the feature.
-- Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
+- Sign up for our [**Community Newsletter**](https://go.pardot.com/l/210132/2017-04-26/3j74l) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
 
 ## Using Snapshots
 
@@ -256,7 +256,9 @@ style/lint in the drop-down to the left of the Manage... button.
 ## License
 
 Realm Java is published under the Apache 2.0 license.
-The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](https://realm.io/docs/java/#faq).
+
+Realm Core is also published under the Apache 2.0 license and is available
+[here](https://github.com/realm/realm-core).
 
 **This product is not being made available to any person located in Cuba, Iran,
 North Korea, Sudan, Syria or the Crimea region, or to any other person that is
@@ -264,7 +266,7 @@ not eligible to receive the product under U.S. law.**
 
 ## Feedback
 
-**_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](http://twitter.com/realm), or email [help@realm.io](mailto:help@realm.io) to let us know about it!_**
+**_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](http://twitter.com/realm) to share your thoughts!_**
 
 **_And if you don't like it, please let us know what you would like improved, so we can fix it!_**
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 2998dae327..353d58886e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -24,6 +24,7 @@
 
 import java.lang.reflect.Field;
 import java.util.Date;
+import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
@@ -2774,6 +2775,26 @@ public void isEmpty_invalidFieldNameThrows() {
         }
     }
 
+    @Test
+    public void isEmpty_acrossLink_wrongTypeThrows() {
+        for (RealmFieldType type : RealmFieldType.values()) {
+            if (SUPPORTED_IS_EMPTY_TYPES.contains(type)) {
+                continue;
+            }
+
+            RealmQuery<Owner> query = realm.where(Owner.class);
+            try {
+                query.isEmpty(Owner.FIELD_CAT + "." + Cat.FIELD_AGE);
+                fail();
+            } catch (IllegalArgumentException expected) {
+                assertEquals(String.format(Locale.US,
+                        "Invalid query: field '%s' in class '%s' is of invalid type '%s'.",
+                        Cat.FIELD_AGE, Cat.CLASS_NAME, RealmFieldType.INTEGER.name()),
+                        expected.getMessage());
+            }
+        }
+    }
+
     @Test
     public void isNotEmpty() {
         createIsNotEmptyDataSet(realm);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index 55bac40c4e..02ee939e37 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -231,7 +231,7 @@ public void getInstanceForSort_shouldThrowOnLinkListField() {
         table.addColumnLink(listType, listType.name(), table);
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Invalid query: field 'LIST' in table 'test_table' is of invalid type 'LIST'.");
+        thrown.expectMessage("Invalid query: field 'LIST' in class 'test_table' is of invalid type 'LIST'.");
         SortDescriptor.getInstanceForSort(null, table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 62142d6283..fe4337afed 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -488,13 +488,8 @@ public long getColumnIndex(String columnName) {
         }
 
         @Override
-        public RealmFieldType getColumnType(String columnName) {
-            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
-        }
-
-        @Override
-        public String getLinkedTable(String columnName) {
-            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
+        public ColumnDetails getColumnDetails(String columnName) {
+            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnDetails'");
         }
 
         @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index e59db86fd0..0081185c55 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -127,24 +127,6 @@ public ColumnInfo getColumnInfo(String className) {
         return classesByName.get(className);
     }
 
-    /**
-     * Convenience method to return the column index for a given field on a class
-     * or {@code -1} if no such field exists.
-     *
-     * @param clazz the class to search.
-     * @param fieldName the name of the field whose index is needed.
-     * @return the index in clazz of the field fieldName.
-     * @deprecated Use {@code getColumnInfo().getColumnIndex()} instead.
-     */
-    @Deprecated
-    public long getColumnIndex(Class<? extends RealmModel> clazz, String fieldName) {
-        final ColumnInfo columnInfo = getColumnInfo(clazz);
-        if (columnInfo == null) {
-            return -1;
-        }
-        return columnInfo.getColumnIndex(fieldName);
-    }
-
     /**
      * Make this instance contain a (non-strict) subset of the data in the passed ColumnIndices.
      * The schemaVersion and every ColumnInfo object held by this instance will be updated to be
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index e7797866bf..9b33e12029 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -35,9 +35,9 @@
  * <p>
  * While the use of the fields in {@code ColumnDetails} is consistent, there are three subtly different cases:
  * <ul>
- * <li>If the column type is a simple type, the link table field is empty (0L / NULLPTR)</li>
- * <li>If the column type is OBJECT or LINK, the link table field is the class name of the OBJECT/LINK type</li>
- * <li>If the column type is LINKING_OBJECT, the link table field is the class name of the backlink source table
+ * <li>If the column type is a simple type, the {@code linkedClassName} field is {@code null}</li>
+ * <li>If the column type is OBJECT or LINK, the {@code linkedClassName} field is the class name of the OBJECT/LINK type</li>
+ * <li>If the column type is LINKING_OBJECT, the {@code linkedClassName} field is the class name of the backlink source table
  * and the column index field is the index of the backlink source field, in the source table</li>
  * </ul>
  *
@@ -62,15 +62,16 @@
 public abstract class ColumnInfo {
 
     // Immutable column information
-    private static final class ColumnDetails {
+    public static final class ColumnDetails {
         public final long columnIndex;
         public final RealmFieldType columnType;
-        public final String linkTable;
+        public final String linkedClassName;
 
-        ColumnDetails(long columnIndex, RealmFieldType columnType, String srcTable) {
+        ColumnDetails(long columnIndex, RealmFieldType columnType, @Nullable String linkedClassName) {
+            // invariant: (columnType == OBJECT || columnType == LIST || columnType == LINKING_OBJECTS) == (linkedClassName != null)
             this.columnIndex = columnIndex;
             this.columnType = columnType;
-            this.linkTable = srcTable;
+            this.linkedClassName = linkedClassName;
         }
 
         @Override
@@ -78,7 +79,7 @@ public String toString() {
             StringBuilder buf = new StringBuilder("ColumnDetails[");
             buf.append(columnIndex);
             buf.append(", ").append(columnType);
-            buf.append(", ").append(linkTable);
+            buf.append(", ").append(linkedClassName);
             return buf.append("]").toString();
         }
     }
@@ -135,24 +136,13 @@ public long getColumnIndex(String columnName) {
     }
 
     /**
-     * Returns the Realm Type, in the described table, of the named column.
+     * Returns the {@link ColumnDetails}, in the described table, of the named column.
      *
-     * @return column Realm Type.
-     */
-    public RealmFieldType getColumnType(String columnName) {
-        ColumnDetails details = indicesMap.get(columnName);
-        return (details == null) ? RealmFieldType.UNSUPPORTED_TABLE : details.columnType;
-    }
-
-    /**
-     * Returns the table linked in the described table, to the named column.
-     *
-     * @return the class name of the linked table, or {@code null} if the column is a primitive type.
+     * @return {@link ColumnDetails} or {@code null} if not found.
      */
     @Nullable
-    public String getLinkedTable(String columnName) {
-        ColumnDetails details = indicesMap.get(columnName);
-        return (details == null) ? null : details.linkTable;
+    public ColumnDetails getColumnDetails(String columnName) {
+        return indicesMap.get(columnName);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
index 014f9d03ed..0849a2e30b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
@@ -71,24 +71,24 @@ protected void compileFieldDescription(List<String> fields) {
                         String.format(Locale.US, "Invalid query: class '%s' not found in this schema.", currentClassName));
             }
 
-            final long columnIndex = columnInfo.getColumnIndex(currentColumnName);
-            if (columnIndex < 0) {
+            final ColumnInfo.ColumnDetails details = columnInfo.getColumnDetails(currentColumnName);
+            if (details == null) {
                 throw new IllegalArgumentException(
-                        String.format(Locale.US, "Invalid query: field '%s' not found in table '%s'.", currentColumnName, currentClassName));
+                        String.format(Locale.US, "Invalid query: field '%s' not found in class '%s'.", currentColumnName, currentClassName));
             }
 
-            currentColumnType = columnInfo.getColumnType(currentColumnName);
+            currentColumnType = details.columnType;
             // we don't check the type of the last field in the chain since it is done in the C++ code
             if (i < nFields - 1) {
                 verifyInternalColumnType(currentClassName, currentColumnName, currentColumnType);
+                currentClassName = details.linkedClassName;
             }
-            currentClassName = columnInfo.getLinkedTable(currentColumnName);
-            columnIndices[i] = columnIndex;
+            columnIndices[i] = details.columnIndex;
             tableNativePointers[i] = (currentColumnType != RealmFieldType.LINKING_OBJECTS)
                     ? NativeObject.NULLPTR
-                    : schema.getNativeTablePtr(currentClassName);
+                    : schema.getNativeTablePtr(details.linkedClassName);
         }
 
-        setCompilationResults(className, currentColumnName, currentColumnType, columnIndices, tableNativePointers);
+        setCompilationResults(currentClassName, currentColumnName, currentColumnType, columnIndices, tableNativePointers);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
index 4ed1bcac46..41f0e51aa1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
@@ -272,11 +272,11 @@ protected final void setCompilationResults(
         return Arrays.asList(fieldDescription.split("\\."));
     }
 
-    private void verifyColumnType(String tableName, String columnName, RealmFieldType columnType, Set<RealmFieldType> validTypes) {
+    private void verifyColumnType(String className, String columnName, RealmFieldType columnType, Set<RealmFieldType> validTypes) {
         if (!validTypes.contains(columnType)) {
             throw new IllegalArgumentException(String.format(Locale.US,
-                    "Invalid query: field '%s' in table '%s' is of invalid type '%s'.",
-                    columnName, tableName, columnType.toString()));
+                    "Invalid query: field '%s' in class '%s' is of invalid type '%s'.",
+                    columnName, className, columnType.toString()));
         }
     }
 
