diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
index ef9e5ba860..e2cb83eb1b 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
@@ -16,12 +16,18 @@
 
 package io.realm.examples.appmodules.model;
 
+import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.examples.librarymodules.model.Dog;
 
 public class Pig extends RealmObject {
 
     private String name;
 
+    // It is possible for model classes to to reference library model classes as long
+    // as they all are included in the schema when opening the Realm.
+    private RealmList<Dog> afraidOf = new RealmList<>();
+
     public String getName() {
         return name;
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index aa4ef4ad8c..d9488d92e6 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -102,19 +102,19 @@ public boolean preProcess(Set<? extends Element> moduleClasses) {
             }
 
             // Check that allClasses and classes are not set at the same time
-            RealmModule moduleAnnoation = classElement.getAnnotation(RealmModule.class);
+            RealmModule moduleAnnotation = classElement.getAnnotation(RealmModule.class);
             Utils.note("Processing module " + classSimpleName);
-            if (moduleAnnoation.allClasses() && hasCustomClassList(classElement)) {
+            if (moduleAnnotation.allClasses() && hasCustomClassList(classElement)) {
                 Utils.error("Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in " + classSimpleName);
                 return false;
             }
 
             // Validate that naming policies are correctly configured.
-            if (!validateNamingPolicies(globalModuleInfo, classSpecificModuleInfo, (TypeElement) classElement, moduleAnnoation)) {
+            if (!validateNamingPolicies(globalModuleInfo, classSpecificModuleInfo, (TypeElement) classElement, moduleAnnotation)) {
                 return false;
             }
 
-            moduleAnnotations.put(((TypeElement) classElement).getQualifiedName().toString(), moduleAnnoation);
+            moduleAnnotations.put(((TypeElement) classElement).getQualifiedName().toString(), moduleAnnotation);
         }
 
         return true;
@@ -236,7 +236,22 @@ public boolean postProcess(ClassCollection modelClasses) {
 
         // Check that app and library modules are not mixed
         if (modules.size() > 0 && libraryModules.size() > 0) {
-            Utils.error("Normal modules and library modules cannot be mixed in the same project");
+            StringBuilder sb = new StringBuilder();
+            sb.append("Normal modules and library modules cannot be mixed in the same project.");
+            sb.append('\n');
+            sb.append("Normal module(s):\n");
+            for (String module : modules.keySet()) {
+                sb.append("  ");
+                sb.append(module);
+                sb.append('\n');
+            }
+            sb.append("Library module(s):\n");
+            for (String module : libraryModules.keySet()) {
+                sb.append("  ");
+                sb.append(module);
+                sb.append('\n');
+            }
+            Utils.error(sb.toString());
             return false;
         }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index c557e866a3..9edeea9902 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -209,7 +209,7 @@ private boolean preProcessModules(RoundEnvironment roundEnv) {
         return moduleMetaData.preProcess(roundEnv.getElementsAnnotatedWith(RealmModule.class));
     }
 
-    // Returns true of modules where succesfully validated, false otherwise
+    // Returns true of modules where successfully validated, false otherwise
     private boolean postProcessModules() {
         return moduleMetaData.postProcess(classCollection);
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 7f154623c4..ef1e771df3 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -745,15 +745,15 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
                 }
                 case OBJECT: {
                     String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
-                    String internalClassName = classCollection.getClassFromQualifiedName(fieldTypeQualifiedName).getInternalClassName();
-                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
+                    String internalClassName = Utils.getReferencedTypeInternalClassNameStatement(fieldTypeQualifiedName, classCollection);
+                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, %s)",
                             fieldName, internalClassName);
                     break;
                 }
                 case LIST: {
                     String genericTypeQualifiedName = Utils.getGenericTypeQualifiedName(field);
-                    String internalClassName = classCollection.getClassFromQualifiedName(genericTypeQualifiedName).getInternalClassName(); // FIXME support for raw data
-                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
+                    String internalClassName = Utils.getReferencedTypeInternalClassNameStatement(genericTypeQualifiedName, classCollection);
+                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, %s)",
                             fieldName, internalClassName);
                     break;
                 }
@@ -795,6 +795,8 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
             }
         }
         for (Backlink backlink: metadata.getBacklinkFields()) {
+            // Backlinks can only be created between classes in the current round of annotation processing
+            // as the forward link cannot be created unless you know the type already.
             ClassMetaData sourceClass = classCollection.getClassFromQualifiedName(backlink.getSourceClass());
             String targetField = backlink.getTargetField(); // Only in the model, so no internal name exists
             String internalSourceField = sourceClass.getInternalFieldName(backlink.getSourceField());
@@ -838,6 +840,17 @@ private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException
                 .emitStatement("return \"%s\"", internalClassName)
                 .endMethod()
                 .emitEmptyLine();
+
+        // Helper class for the annotation processor so it can access the internal class name
+        // without needing to load the parent class (which we cannot do as it transitively loads
+        // native code, which cannot be loaded on the JVM).
+        writer.beginType(
+                "ClassNameHelper",                       // full qualified name of the item to generate
+                "class",                                                  // the type of the item
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)); // modifiers to apply
+        writer.emitField("String", "INTERNAL_CLASS_NAME", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL), "\""+ internalClassName+"\"");
+        writer.endType();
+        writer.emitEmptyLine();
     }
     //@formatter:on
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 9b0e4309e0..85b92a64ac 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -1,5 +1,8 @@
 package io.realm.processor;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.List;
 
 import javax.annotation.processing.Messager;
@@ -19,12 +22,11 @@
 
 import io.realm.annotations.RealmNamingPolicy;
 import io.realm.processor.nameconverter.CamelCaseConverter;
+import io.realm.processor.nameconverter.IdentityConverter;
 import io.realm.processor.nameconverter.LowerCaseWithSeparatorConverter;
 import io.realm.processor.nameconverter.NameConverter;
-import io.realm.processor.nameconverter.IdentityConverter;
 import io.realm.processor.nameconverter.PascalCaseConverter;
 
-
 /**
  * Utility methods working with the Realm processor.
  */
@@ -355,4 +357,49 @@ public static NameConverter getNameFormatter(RealmNamingPolicy policy) {
         }
     }
 
+    /**
+     * Tries to find the internal class name for a referenced type. In model classes this can
+     * happen with either direct object references or using `RealmList` or `RealmResults`.
+     * <p>
+     * This name is required by schema builders that operate on internal names and not the public ones.
+     * <p>
+     * Finding the internal name is easy if the referenced type is included in the current round
+     * of annotation processing. In that case the internal name was also calculated in the same round
+     * <p>
+     * If the referenced type was already compiled, e.g being included from library, then we need
+     * to get the name from the proxy class. Fortunately ProGuard should not have obfuscated any
+     * class files at this point, meaning we can look it up dynamically.
+     * <p>
+     * If a name is looked up using the class loader, it also means that developers need to
+     * combine a library and app module of model classes at runtime in the RealmConfiguration, but
+     * this should be a valid use case.
+     *
+     * @param qualifiedClassName type to lookup the internal name for.
+     * @param classCollection collection of classes found in the current round of annotation processing.
+     * @throws IllegalArgumentException If the internal name could not be looked up
+     * @return the statement that evalutes to the internal class name. This will either be a string
+     * constant or a reference to a static field in another class. In both cases, the return result
+     * should not be put in quotes.
+     */
+    public static String getReferencedTypeInternalClassNameStatement(String qualifiedClassName, ClassCollection classCollection) {
+
+        // Attempt to lookup internal name in current round
+        if (classCollection.containsQualifiedClass(qualifiedClassName)) {
+            ClassMetaData metadata = classCollection.getClassFromQualifiedName(qualifiedClassName);
+            return "\"" + metadata.getInternalClassName() + "\"";
+        }
+
+        // If we cannot find the name in the current processor round, we have to defer resolving the
+        // name to runtime. The reason being that proxy classes in libraries on the classpath
+        // might already have been obfuscated, which means we have no easy way of finding them.
+        // 
+        // Doing it this way unfortunately means that if the class is not on the apps classpath
+        // a rather obscure class-not-found exception will be thrown, but since this is probably
+        // a very niche use case that is acceptable for now.
+        //
+        // TODO: We could probably create an internal annotation like `@InternalName("__Permission")`
+        // which should make it possible for the annotation processor to read the value from the
+        // proxy class, even for files in other jar files.
+        return "io.realm." + Utils.getProxyClassName(qualifiedClassName) + ".ClassNameHelper.INTERNAL_CLASS_NAME";
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java
index 5dcdcd1f45..ee1fccac5a 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java
@@ -868,6 +868,10 @@ public static String getSimpleClassName() {
         return "AllTypes";
     }
 
+    public static final class ClassNameHelper {
+        public static final String INTERNAL_CLASS_NAME = "AllTypes";
+    }
+
     @SuppressWarnings("cast")
     public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java
index d2c9f22cff..ac32ff2b20 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java
@@ -202,6 +202,10 @@ public static String getSimpleClassName() {
         return "Booleans";
     }
 
+    public static final class ClassNameHelper {
+        public static final String INTERNAL_CLASS_NAME = "Booleans";
+    }
+
     @SuppressWarnings("cast")
     public static some.test.Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java
index eb71397828..b33b615633 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java
@@ -166,6 +166,10 @@ public static String getSimpleClassName() {
         return "customName";
     }
 
+    public static final class ClassNameHelper {
+        public static final String INTERNAL_CLASS_NAME = "customName";
+    }
+
     @SuppressWarnings("cast")
     public static some.test.NamePolicyMixedClassSettings createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java
index 221ca41710..29a6d97b08 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java
@@ -166,6 +166,10 @@ public static String getSimpleClassName() {
         return "NamePolicyModuleDefaults";
     }
 
+    public static final class ClassNameHelper {
+        public static final String INTERNAL_CLASS_NAME = "NamePolicyModuleDefaults";
+    }
+
     @SuppressWarnings("cast")
     public static some.test.NamePolicyModuleDefaults createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java
index c4c3669172..1e5c65b4a4 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java
@@ -1707,6 +1707,10 @@ public static String getSimpleClassName() {
         return "NullTypes";
     }
 
+    public static final class ClassNameHelper {
+        public static final String INTERNAL_CLASS_NAME = "NullTypes";
+    }
+
     @SuppressWarnings("cast")
     public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java
index fd591f4bc5..c072b532cb 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java
@@ -158,6 +158,10 @@ public static String getSimpleClassName() {
         return "Simple";
     }
 
+    public static final class ClassNameHelper {
+        public static final String INTERNAL_CLASS_NAME = "Simple";
+    }
+
     @SuppressWarnings("cast")
     public static some.test.Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
