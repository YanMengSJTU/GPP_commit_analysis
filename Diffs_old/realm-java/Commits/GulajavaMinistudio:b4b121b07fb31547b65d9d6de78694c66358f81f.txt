diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4a1351d1a7..47022631a8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,4 @@
-## 4.2.0 (YYYY-MM-DD)
+## 4.2.0 (2017-11-17)
 
 ### Breaking Changes
 
@@ -6,27 +6,24 @@
 
 * Added support for using non-encrypted Realms in multiple processes. Some caveats apply. Read [doc](https://realm.io/docs/java/latest/#multiprocess) for more info (#1091).
 * Added support for importing primitive lists from JSON (#5362).
-
-### Bug Fixes
-
-### Interal
-
-### Credits
-
-
-## 4.1.2 (YYYY-MM-DD)
+* [ObjectServer] Support SSL validation using Android TrustManager (no need to specify `trustedRootCA` in `SynConfiguration` if the certificate is installed on the device), fixes (#4759).
+* Added the and() function to `RealmQuery` in order to improve readability.
 
 ### Bug Fixes
 
 * Leaked file handler in the Realm Transformer (#5521).
 * Potential fix for "RealmError: Incompatible lock file" crash (#2459).
 
-### Internal
+### Interal
 
 * Updated JavaAssist to 3.22.0-GA.
 * Upgraded to Realm Sync 2.1.4.
 * Upgraded to Realm Core 4.0.3.
 
+### Credits
+
+Thanks to @rakshithravi1997 for adding `RealmQuery.and()` (#5520).
+
 
 ## 4.1.1 (2017-10-27)
 
diff --git a/dependencies.list b/dependencies.list
index de1b76ac57..35394be8e1 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -5,5 +5,5 @@ REALM_SYNC_SHA256=6d32ef44acbf4a63b654ceeaadce036feeefd04a4ca649a95a22a0e7d56df8
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.6
+REALM_OBJECT_SERVER_DE_VERSION=2.0.18
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 35456d248c..ece9fabd6c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -199,6 +199,7 @@ private void populateNoPrimaryKeyNullTypesRows() {
         BEGIN_GROUP,
         END_GROUP,
         OR,
+        AND,
         NOT,
         IS_NULL,
         IS_NOT_NULL,
@@ -315,6 +316,7 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
             case BEGIN_GROUP: query.beginGroup(); break;
             case END_GROUP: query.endGroup(); break;
             case OR: query.or(); break;
+            case AND: query.and(); break;
             case NOT: query.not(); break;
             case IS_NULL: query.isNull(          AllJavaTypes.FIELD_DATE); break;
             case IS_NOT_NULL: query.isNotNull(   AllJavaTypes.FIELD_DATE); break;
@@ -583,6 +585,19 @@ public void and_implicit() {
         resultList = query.between(AllTypes.FIELD_LONG, 1, 100).findAll();
         assertEquals(1, resultList.size());
     }
+    
+    @Test
+    public void and_explicit() {
+        populateTestRealm(realm, 200);
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.2345f);
+        RealmResults<AllTypes> resultList = query.and().between(AllTypes.FIELD_LONG, 1, 10).findAll();
+        assertEquals(0, resultList.size());
+
+        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 81.2345f);
+        resultList = query.and().between(AllTypes.FIELD_LONG, 1, 100).findAll();
+        assertEquals(1, resultList.size());
+    }
 
     @Test
     public void lessThan() {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
new file mode 100644
index 0000000000..4ed36faccc
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
@@ -0,0 +1,255 @@
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class TrustManagerCertificateValidationTests {
+
+    @BeforeClass
+    public static void setUp() {
+        // mainly to setup logging otherwise
+        // java.lang.UnsatisfiedLinkError: No implementation found for void io.realm.log.RealmLog.nativeSetLogLevel(int) (tried Java_io_realm_log_RealmLog_nativeSetLogLevel and Java_io_realm_log_RealmLog_nativeSetLogLevel__I)
+        // will be thrown
+        Realm.init(InstrumentationRegistry.getTargetContext());
+    }
+
+    // IMPORTANT: Following test assume the root certificate is installed on the test device
+    //            certificate is located in <realm-java>/tools/sync_test_server/keys/android_test_certificate.crt
+    //            adb push <realm-java>/tools/sync_test_server/keys/android_test_certificate.crt /sdcard/
+    //            then import the certificate from the device (Settings/Security/Install from storage)
+    @Test
+    public void sslVerifyCallback_certificateChainWithRootCAInstalledShouldValidate() {
+        // simulating the following certificate chain
+        // ---
+        // Certificate chain
+        // 0 s:/DC=127.0.0.1/O=Realm/OU=Realm/CN=127.0.0.1
+        // i:/DC=io/DC=realm/O=Realm/OU=Realm Test Signing CA/CN=Realm Test Signing CA
+        // 1 s:/DC=io/DC=realm/O=Realm/OU=Realm Test Signing CA/CN=Realm Test Signing CA
+        // i:/DC=io/DC=realm/O=Realm/OU=Realm Test Root CA/CN=Realm Test Root CA
+        // ---
+
+        // s:/DC=127.0.0.1/O=Realm/OU=Realm/CN=127.0.0.1
+        String pem_depth0 = "-----BEGIN CERTIFICATE-----\n" +
+                "MIIE1DCCArygAwIBAgIBBzANBgkqhkiG9w0BAQUFADB7MRIwEAYKCZImiZPyLGQB\n" +
+                "GRYCaW8xFTATBgoJkiaJk/IsZAEZFgVyZWFsbTEOMAwGA1UECgwFUmVhbG0xHjAc\n" +
+                "BgNVBAsMFVJlYWxtIFRlc3QgU2lnbmluZyBDQTEeMBwGA1UEAwwVUmVhbG0gVGVz\n" +
+                "dCBTaWduaW5nIENBMB4XDTE3MDUxNzIzMjg0OFoXDTE5MDUxNzIzMjg0OFowTzEZ\n" +
+                "MBcGCgmSJomT8ixkARkWCTEyNy4wLjAuMTEOMAwGA1UECgwFUmVhbG0xDjAMBgNV\n" +
+                "BAsMBVJlYWxtMRIwEAYDVQQDDAkxMjcuMC4wLjEwggEiMA0GCSqGSIb3DQEBAQUA\n" +
+                "A4IBDwAwggEKAoIBAQC3jJl7a1spgJyZt/64HgZsTVi9OLbME2r//fYmoHHSipTq\n" +
+                "Br7huFsDXpaOYRkPgF+4UUOXADhnRw4JuKuA0ZyBuIHbC7TF3no89ZzLvysS/rGd\n" +
+                "TqBKq67EERlUxRftWMNy8OVG3CFBTGMdMYXzuvataT7Yhp3EVjtSR10k3UCv+foD\n" +
+                "TE4tW9I03PCkGRMU9mx8HEe9fXmiCWGtP41OWcWupys5AOk0aGxv2GCiqSQzHJ+A\n" +
+                "tMaOujeYcT3dgmbY4MKBzEvRXVgmz4UKrP0IpUBQ//lz6CcYe3B1cyojx9cVvsrO\n" +
+                "V8nuu2202P3HIkcomwBeS6+CY8PXanROYBeUavuDAgMBAAGjgY4wgYswDgYDVR0P\n" +
+                "AQH/BAQDAgWgMAkGA1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUF\n" +
+                "BwMCMB0GA1UdDgQWBBTGvfRJ9S52UkTx4s4ubPlZsVYUrTAfBgNVHSMEGDAWgBQn\n" +
+                "eeHa8RXQ6eWGMIfnH1/PJzpwtDAPBgNVHREECDAGhwR/AAABMA0GCSqGSIb3DQEB\n" +
+                "BQUAA4ICAQCbP3T0aXJrW3WItxBf4HOygr7ccRuj1qRurqZfUXhcgGQgISATFgjQ\n" +
+                "rhX2UiTZI1wk7WI7DuZfAEu/oZQ0KvsqRl9U5jt/voFb3+h4ph7O4oe5i+TYBB8Y\n" +
+                "xCmAeiGpVsUp7k4oM/qNkkaiMTHF+TEZ7R32x3WCZbYarbw0SvMYBaCj1JpQ8u+7\n" +
+                "xC+JEJVoF2qFds6IjBnP16pww9BZm5rA0KjQ08318I5eGauhrlTcB6xtbtjw7mVH\n" +
+                "3ikedhsdDmL13R32bq0nLo2+xKhBC7FEIj0ps1d0PjtBKBmNSO1lBVuOF6erRSTZ\n" +
+                "lQDkBOds2GtrKoleH/u08hwgVer1QJlYot7Dg+UBcPhT6Y2Vugsg0JnmtDEFVQCc\n" +
+                "9/OWfHRbfcdqruyQ+A/y8FjsgAx5BLDzac3lQfL1/ES62U8/Mv5p824fMpRieBd2\n" +
+                "3NUMGaaLl3DpGTmo+rEAphhvSy04Lx2WC4eYhsEsdUQ8DuHr9MROAsef98wwinIj\n" +
+                "v0R8fD/3fLGx16pL5B7dyv1ajS6q/0mvpWNviDEmfbOk401NRdZEexKobga7gcCA\n" +
+                "pF+VO9SlSgEdAA57XSApl9DWiHPxicEBVIWbnO9Bbfm2g8xlrDTKv4j8NE9/YjDi\n" +
+                "2QLrx1iGkG/kfl8gRfLEoH6tklqFjwiQPehlvlR54mI8XY5XNioXuw==\n" +
+                "-----END CERTIFICATE-----";
+
+        // s:/DC=io/DC=realm/O=Realm/OU=Realm Test Signing CA/CN=Realm Test Signing CA
+        String pem_depth1 = "-----BEGIN CERTIFICATE-----\n" +
+                "MIIF0TCCA7mgAwIBAgIBAjANBgkqhkiG9w0BAQUFADB1MRIwEAYKCZImiZPyLGQB\n" +
+                "GRYCaW8xFTATBgoJkiaJk/IsZAEZFgVyZWFsbTEOMAwGA1UECgwFUmVhbG0xGzAZ\n" +
+                "BgNVBAsMElJlYWxtIFRlc3QgUm9vdCBDQTEbMBkGA1UEAwwSUmVhbG0gVGVzdCBS\n" +
+                "b290IENBMB4XDTE2MDkwNzEwMTcyOFoXDTI2MDkwNzEwMTcyOFowezESMBAGCgmS\n" +
+                "JomT8ixkARkWAmlvMRUwEwYKCZImiZPyLGQBGRYFcmVhbG0xDjAMBgNVBAoMBVJl\n" +
+                "YWxtMR4wHAYDVQQLDBVSZWFsbSBUZXN0IFNpZ25pbmcgQ0ExHjAcBgNVBAMMFVJl\n" +
+                "YWxtIFRlc3QgU2lnbmluZyBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC\n" +
+                "ggIBAL9bWpLeU69zgOE/IlV1OH2eO2VJqtOnrAS+TaXCfQMwydhB0gAKzd+jaKUT\n" +
+                "kgpxIsUJ1HWXc6b6N2SnYVWEiMG+65LgphsABMQx/UrpFFbIrQtcc8hVHOZgsTrj\n" +
+                "wh1BGm1XEt/awv5A59GlcSlxyw0S1ca+6KtinBFwtd7xILa8Ba96P+TfdDPWu6Mz\n" +
+                "WfM6oK8t6ucWyI8l8fsnc4BG40RbuPVMuo5hbV8swI/o0r066A36Ft4yGYTIbK0R\n" +
+                "FFzORL5GvvB7gych8Un1uuW8WQewwvtPflZ268sU8VDWs4MQK7HTgGiYRWdwnhvv\n" +
+                "/yjQ7xo4KGQWhFrRnwV/FVBqzqwIJeQ/1t8J2VmyBdm345Su9sYEaS7VR3lUkvty\n" +
+                "8kwJK2Q6PtEwdgwzZQoIVTREgwXpHlHCWHBEMGzvCuCw4hAr4VUpJANoYbtEWOqt\n" +
+                "A7OpDxNE/+ok03u9JXhXeXvkS568MjNj1fclOffFMY2f8naja7tbpN3MlkS0RJ1Q\n" +
+                "7y5kKQKjx1L3NpLF+vt13SVnPkY3453c3vblagqVfumQPsmx+HQHuf/yJMmE8J88\n" +
+                "p87KZL53HnyTKW/Ijo1006gd4dubi8Mn2A0D/H4+JRlquKWX0HrDEzO8OozHJen5\n" +
+                "z0rFwyZjQu9Y10IGMIogyM1qQIv6iOBU7WAJaSYSQ7Xyk2xbAgMBAAGjZjBkMA4G\n" +
+                "A1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQneeHa\n" +
+                "8RXQ6eWGMIfnH1/PJzpwtDAfBgNVHSMEGDAWgBSEcHEsBDvQkoO1+3x/sGEMYhZx\n" +
+                "dDANBgkqhkiG9w0BAQUFAAOCAgEANgWEjIghCKfivUGoJ3+3wpqG1yH+7UxR0Snf\n" +
+                "NUoO6qC1bMwoL169n5dovqoq/1SRnu8EXQ3s55g1EHhQth8XlqlemmD7aOkGfVOM\n" +
+                "WLeaR+CfyNFDGnRBP6sDITWIjjQ6JbeYZySL1BSIVxyZ3wgMvVefU9s6R6TlTCk4\n" +
+                "4oI5RepiyhvYlcsK42UQl8cQ14st2/oWxsQMgSbmb/Ha+3nAEidYmiuVoL1ziK31\n" +
+                "rZvNST2tLAKE+Ii+PL/XoijoCR58DbBWrebjpxFWWGaD3YAxVqYVReHjUkny+Ew8\n" +
+                "YP3WG0Vh7FLB2bnasF1cO3/vNN1IJhlaZq21p4drc+jq013N0T+sd+RZjU2VOC/o\n" +
+                "F/+PZ8j4XY6Gt3hQJWI1uQcV9utlmICWC9IUy1QadQyr2cKZGyDa46R3aO91zER/\n" +
+                "ZvRHjHoDIbZsxwCyUBWEXIcq+wM61y3fUpaAtsA9oEtlZ17zvUH+9GI63g8wjUe/\n" +
+                "igv4Dth7hJNg5nOpYBHzWhYsKljA3HiPZsgQkNXaAzXppyKKBBTP4fvJRl/MKe/H\n" +
+                "Ir1lpIpH4NUQDRJMo3IR5l+eW4c460h03YYmq0VhY0VSIak1ZYQwSYVokLYjDPAQ\n" +
+                "ft7h6D2Ubf9EoC6GHEy77HKFO9BtSWlHqWEfxTnL1noG6UFS3wAAwAg/Ib1EUsR4\n" +
+                "pf7lM/4=\n" +
+                "-----END CERTIFICATE-----\n";
+
+        String serverAddress = "127.0.0.1";
+
+        assertTrue(SyncManager.sslVerifyCallback(serverAddress, pem_depth1, 1));
+        assertTrue(SyncManager.sslVerifyCallback(serverAddress, pem_depth0, 0));
+    }
+
+    @Test
+    public void sslVerifyCallback_shouldVerifyHostname() {
+        // simulating the following certificate chain
+        // ---
+        // Certificate chain
+        // 0 s:/CN=*.ie1.realmlab.net
+        // i:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
+        // 1 s:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
+        // i:/C=US/O=Amazon/CN=Amazon Root CA 1
+        // 2 s:/C=US/O=Amazon/CN=Amazon Root CA 1
+        // i:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
+        // 3 s:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
+        // i:/C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority
+        // ---
+
+        // ie1.realmlab.net
+        String pem_depth0 = "-----BEGIN CERTIFICATE-----\n" +
+                "MIIEWDCCA0CgAwIBAgIQBE6+74j1z/Z88OEsSc3VIzANBgkqhkiG9w0BAQsFADBG\n" +
+                "MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\n" +
+                "Q0EgMUIxDzANBgNVBAMTBkFtYXpvbjAeFw0xNzA0MDMwMDAwMDBaFw0xODA1MDMx\n" +
+                "MjAwMDBaMB0xGzAZBgNVBAMMEiouaWUxLnJlYWxtbGFiLm5ldDCCASIwDQYJKoZI\n" +
+                "hvcNAQEBBQADggEPADCCAQoCggEBAKfV/38WJ47qvr4Onopu+XKYlTyTsvouX2VQ\n" +
+                "jRopM0gdXehp9BfwnFme8KUVZLSYh0vdmY7Wm5A7oxcL4ZuUpDSs9+xuERNg1YMD\n" +
+                "gI46ehj08+KUSfuqsVuw3gpNM6VPtpKY2I4//fJFmJKTWXA/fl35By0Xbuv4I180\n" +
+                "FFWu7CV0N4b/QQsjT0+CVvAjHRMMTpw0qtcZGQ4lWNNiqcqUql+Eklm/90S+lyBD\n" +
+                "q8YQUwcxhMgxKt6M5zwJpWuIbjov9kygDzlw/YU8P5wqvgocfnnXaKw+rr7EdiTS\n" +
+                "U2ZT99JO0F0CPzPZnphNrRtjkJ4Chtp0FVRqAdthpGH4i1VIKP0CAwEAAaOCAWkw\n" +
+                "ggFlMB8GA1UdIwQYMBaAFFmkZgZSoHuVkjyjlAcnlnRb+T3QMB0GA1UdDgQWBBRP\n" +
+                "5MQbQpMCFJgjiFgEtZUIiKdNeDAdBgNVHREEFjAUghIqLmllMS5yZWFsbWxhYi5u\n" +
+                "ZXQwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcD\n" +
+                "AjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3JsLnNjYTFiLmFtYXpvbnRydXN0\n" +
+                "LmNvbS9zY2ExYi5jcmwwEwYDVR0gBAwwCjAIBgZngQwBAgEwdQYIKwYBBQUHAQEE\n" +
+                "aTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYi5hbWF6b250cnVzdC5j\n" +
+                "b20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWIuYW1hem9udHJ1c3QuY29t\n" +
+                "L3NjYTFiLmNydDAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4IBAQAObbVL\n" +
+                "zDqqFO4iDjR4VRTYQbb3gSDxySqFqMm4iBJBmqgNRDsNDb75EmlbB0udbZ6+LHDK\n" +
+                "pmPh81ocdJECHZctidDh1zCkVf3uOYyPJqxNpt0ZCurGMTi4i5kaIbAwR50lZU2V\n" +
+                "eSkR5rYFoBIVcUNbXzzOMLTcJrRqbVYz7z9zCN71l12dKNMXdu9tLcec+WCGi0R+\n" +
+                "MNBOQ/XVlAzymsmQM6nWb0DEQ86ya9AAAMVQBVgyeEPZNPidxc82kU8pML9mO0Yl\n" +
+                "MtbgZWXH1kTppsi+/WbOwy+kalpiMJ7TXIvHmQat81FWiJNTnKwfVEsz79Op8EAW\n" +
+                "p9RkpzfSQpZQ30/u\n" +
+                "-----END CERTIFICATE-----\n";
+
+        // OU=Server CA 1B/CN=Amazon
+        String pem_depth1 = "-----BEGIN CERTIFICATE-----\n" +
+                "MIIESTCCAzGgAwIBAgITBn+UV4WH6Kx33rJTMlu8mYtWDTANBgkqhkiG9w0BAQsF\n" +
+                "ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\n" +
+                "b24gUm9vdCBDQSAxMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\n" +
+                "MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\n" +
+                "IDFCMQ8wDQYDVQQDEwZBbWF6b24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\n" +
+                "AoIBAQDCThZn3c68asg3Wuw6MLAd5tES6BIoSMzoKcG5blPVo+sDORrMd4f2AbnZ\n" +
+                "cMzPa43j4wNxhplty6aUKk4T1qe9BOwKFjwK6zmxxLVYo7bHViXsPlJ6qOMpFge5\n" +
+                "blDP+18x+B26A0piiQOuPkfyDyeR4xQghfj66Yo19V+emU3nazfvpFA+ROz6WoVm\n" +
+                "B5x+F2pV8xeKNR7u6azDdU5YVX1TawprmxRC1+WsAYmz6qP+z8ArDITC2FMVy2fw\n" +
+                "0IjKOtEXc/VfmtTFch5+AfGYMGMqqvJ6LcXiAhqG5TI+Dr0RtM88k+8XUBCeQ8IG\n" +
+                "KuANaL7TiItKZYxK1MMuTJtV9IblAgMBAAGjggE7MIIBNzASBgNVHRMBAf8ECDAG\n" +
+                "AQH/AgEAMA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUWaRmBlKge5WSPKOUByeW\n" +
+                "dFv5PdAwHwYDVR0jBBgwFoAUhBjMhTTsvAyUlC4IWZzHshBOCggwewYIKwYBBQUH\n" +
+                "AQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5yb290Y2ExLmFtYXpvbnRy\n" +
+                "dXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5yb290Y2ExLmFtYXpvbnRy\n" +
+                "dXN0LmNvbS9yb290Y2ExLmNlcjA/BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vY3Js\n" +
+                "LnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTEuY3JsMBMGA1UdIAQMMAow\n" +
+                "CAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IBAQCFkr41u3nPo4FCHOTjY3NTOVI1\n" +
+                "59Gt/a6ZiqyJEi+752+a1U5y6iAwYfmXss2lJwJFqMp2PphKg5625kXg8kP2CN5t\n" +
+                "6G7bMQcT8C8xDZNtYTd7WPD8UZiRKAJPBXa30/AbwuZe0GaFEQ8ugcYQgSn+IGBI\n" +
+                "8/LwhBNTZTUVEWuCUUBVV18YtbAiPq3yXqMB48Oz+ctBWuZSkbvkNodPLamkB2g1\n" +
+                "upRyzQ7qDn1X8nn8N8V7YJ6y68AtkHcNSRAnpTitxBKjtKPISLMVCx7i4hncxHZS\n" +
+                "yLyKQXhw2W2Xs0qLeC1etA+jTGDK4UfLeC0SF7FSi8o5LL21L8IzApar2pR/\n" +
+                "-----END CERTIFICATE-----\n";
+        // Amazon Root CA 1
+        String pem_depth2 = "-----BEGIN CERTIFICATE-----\n" +
+                "MIIEkjCCA3qgAwIBAgITBn+USionzfP6wq4rAfkI7rnExjANBgkqhkiG9w0BAQsF\n" +
+                "ADCBmDELMAkGA1UEBhMCVVMxEDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNj\n" +
+                "b3R0c2RhbGUxJTAjBgNVBAoTHFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4x\n" +
+                "OzA5BgNVBAMTMlN0YXJmaWVsZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1\n" +
+                "dGhvcml0eSAtIEcyMB4XDTE1MDUyNTEyMDAwMFoXDTM3MTIzMTAxMDAwMFowOTEL\n" +
+                "MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\n" +
+                "b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\n" +
+                "ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n" +
+                "9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\n" +
+                "IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\n" +
+                "VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n" +
+                "93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\n" +
+                "jgSubJrIqg0CAwEAAaOCATEwggEtMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/\n" +
+                "BAQDAgGGMB0GA1UdDgQWBBSEGMyFNOy8DJSULghZnMeyEE4KCDAfBgNVHSMEGDAW\n" +
+                "gBScXwDfqgHXMCs4iKK4bUqc8hGRgzB4BggrBgEFBQcBAQRsMGowLgYIKwYBBQUH\n" +
+                "MAGGImh0dHA6Ly9vY3NwLnJvb3RnMi5hbWF6b250cnVzdC5jb20wOAYIKwYBBQUH\n" +
+                "MAKGLGh0dHA6Ly9jcnQucm9vdGcyLmFtYXpvbnRydXN0LmNvbS9yb290ZzIuY2Vy\n" +
+                "MD0GA1UdHwQ2MDQwMqAwoC6GLGh0dHA6Ly9jcmwucm9vdGcyLmFtYXpvbnRydXN0\n" +
+                "LmNvbS9yb290ZzIuY3JsMBEGA1UdIAQKMAgwBgYEVR0gADANBgkqhkiG9w0BAQsF\n" +
+                "AAOCAQEAYjdCXLwQtT6LLOkMm2xF4gcAevnFWAu5CIw+7bMlPLVvUOTNNWqnkzSW\n" +
+                "MiGpSESrnO09tKpzbeR/FoCJbM8oAxiDR3mjEH4wW6w7sGDgd9QIpuEdfF7Au/ma\n" +
+                "eyKdpwAJfqxGF4PcnCZXmTA5YpaP7dreqsXMGz7KQ2hsVxa81Q4gLv7/wmpdLqBK\n" +
+                "bRRYh5TmOTFffHPLkIhqhBGWJ6bt2YFGpn6jcgAKUj6DiAdjd4lpFw85hdKrCEVN\n" +
+                "0FE6/V1dN2RMfjCyVSRCnTawXZwXgWHxyvkQAiSr6w10kY17RSlQOYiypok1JR4U\n" +
+                "akcjMS9cmvqtmg5iUaQqqcT5NJ0hGA==\n" +
+                "-----END CERTIFICATE-----\n";
+
+        // O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
+        String pem_depth3 = "-----BEGIN CERTIFICATE-----\n" +
+                "MIIEdTCCA12gAwIBAgIJAKcOSkw0grd/MA0GCSqGSIb3DQEBCwUAMGgxCzAJBgNV\n" +
+                "BAYTAlVTMSUwIwYDVQQKExxTdGFyZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTIw\n" +
+                "MAYDVQQLEylTdGFyZmllbGQgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\n" +
+                "eTAeFw0wOTA5MDIwMDAwMDBaFw0zNDA2MjgxNzM5MTZaMIGYMQswCQYDVQQGEwJV\n" +
+                "UzEQMA4GA1UECBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTElMCMGA1UE\n" +
+                "ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjE7MDkGA1UEAxMyU3RhcmZp\n" +
+                "ZWxkIFNlcnZpY2VzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IC0gRzIwggEi\n" +
+                "MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDVDDrEKvlO4vW+GZdfjohTsR8/\n" +
+                "y8+fIBNtKTrID30892t2OGPZNmCom15cAICyL1l/9of5JUOG52kbUpqQ4XHj2C0N\n" +
+                "Tm/2yEnZtvMaVq4rtnQU68/7JuMauh2WLmo7WJSJR1b/JaCTcFOD2oR0FMNnngRo\n" +
+                "Ot+OQFodSk7PQ5E751bWAHDLUu57fa4657wx+UX2wmDPE1kCK4DMNEffud6QZW0C\n" +
+                "zyyRpqbn3oUYSXxmTqM6bam17jQuug0DuDPfR+uxa40l2ZvOgdFFRjKWcIfeAg5J\n" +
+                "Q4W2bHO7ZOphQazJ1FTfhy/HIrImzJ9ZVGif/L4qL8RVHHVAYBeFAlU5i38FAgMB\n" +
+                "AAGjgfAwge0wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0O\n" +
+                "BBYEFJxfAN+qAdcwKziIorhtSpzyEZGDMB8GA1UdIwQYMBaAFL9ft9HO3R+G9FtV\n" +
+                "rNzXEMIOqYjnME8GCCsGAQUFBwEBBEMwQTAcBggrBgEFBQcwAYYQaHR0cDovL28u\n" +
+                "c3MyLnVzLzAhBggrBgEFBQcwAoYVaHR0cDovL3guc3MyLnVzL3guY2VyMCYGA1Ud\n" +
+                "HwQfMB0wG6AZoBeGFWh0dHA6Ly9zLnNzMi51cy9yLmNybDARBgNVHSAECjAIMAYG\n" +
+                "BFUdIAAwDQYJKoZIhvcNAQELBQADggEBACMd44pXyn3pF3lM8R5V/cxTbj5HD9/G\n" +
+                "VfKyBDbtgB9TxF00KGu+x1X8Z+rLP3+QsjPNG1gQggL4+C/1E2DUBc7xgQjB3ad1\n" +
+                "l08YuW3e95ORCLp+QCztweq7dp4zBncdDQh/U90bZKuCJ/Fp1U1ervShw3WnWEQt\n" +
+                "8jxwmKy6abaVd38PMV4s/KCHOkdp8Hlf9BRUpJVeEXgSYCfOn8J3/yNTd126/+pZ\n" +
+                "59vPr5KW7ySaNRB6nJHGDn2Z9j8Z3/VyVOEVqQdZe4O/Ui5GjLIAZHYcSNPYeehu\n" +
+                "VsyuLAOQ1xk4meTKCRlb/weWsKh/NEnfVqn3sF/tM+2MR7cwA130A4w=\n" +
+                "-----END CERTIFICATE-----\n";
+
+        String serverAddress = "nabil-test.ie1.realmlab.net";
+
+        assertTrue(SyncManager.sslVerifyCallback(serverAddress, pem_depth3, 3));
+        assertTrue(SyncManager.sslVerifyCallback(serverAddress, pem_depth2, 2));
+        assertTrue(SyncManager.sslVerifyCallback(serverAddress, pem_depth1, 1));
+        assertTrue(SyncManager.sslVerifyCallback(serverAddress, pem_depth0, 0));
+
+        // reaching depth0 will validate (or not) the entire chain, then removing the PEMs from memory
+        // make sure the hostname verify works
+
+        String wrongServerAddress = "hax0r-test.realmlab.net";
+        assertTrue(SyncManager.sslVerifyCallback(wrongServerAddress, pem_depth3, 3));
+        assertTrue(SyncManager.sslVerifyCallback(wrongServerAddress, pem_depth2, 2));
+        assertTrue(SyncManager.sslVerifyCallback(wrongServerAddress, pem_depth1, 1));
+        // Note hax0r-test.ie1.realmlab.net is valid since the certificate allow *.ie1.realmlab.net
+        // but the method fails because of the hostname verification
+        assertFalse(SyncManager.sslVerifyCallback(wrongServerAddress, pem_depth0, 0));
+    }
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index fd7d3fdc9e..8a8eb0bcb3 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -21,6 +21,7 @@
 #include <sync/sync_config.hpp>
 #include <sync/sync_manager.hpp>
 #include <sync/sync_session.hpp>
+
 #endif
 
 #include "java_accessor.hpp"
@@ -360,6 +361,32 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSyncConfigS
             JStringAccessor cert_path(env, j_sync_ssl_trust_certificate_path);
             config.sync_config->ssl_trust_certificate_path = realm::util::Optional<std::string>(cert_path);
         }
+        else if (config.sync_config->client_validate_ssl) {
+            // set default callback to allow Android to check the certificate
+            static JavaClass sync_manager_class(env, "io/realm/SyncManager");
+            static JavaMethod java_ssl_verify_callback(env, sync_manager_class, "sslVerifyCallback",
+                                                       "(Ljava/lang/String;Ljava/lang/String;I)Z", true);
+
+            std::function<sync::Session::SSLVerifyCallback> ssl_verify_callback =
+                [](const std::string server_address, REALM_UNUSED realm::sync::Client::port_type server_port,
+                   const char* pem_data, size_t pem_size, REALM_UNUSED int preverify_ok, int depth) {
+
+                    Log::d("Callback to Java requesting certificate validation for host %1",
+                                            server_address.c_str());
+
+                    JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+
+                    jstring jserver_address = to_jstring(env, server_address.c_str());
+                    // deep copy the pem_data into a string so DeleteLocalRef delete the local reference not the original const char
+                    std::string pem(pem_data, pem_size);
+                    jstring jpem = to_jstring(env, pem.c_str());
+                    bool isValid = env->CallStaticBooleanMethod(sync_manager_class, java_ssl_verify_callback,
+                                                                jserver_address,
+                                                                jpem, depth) == JNI_TRUE;
+                    return isValid;
+                };
+            config.sync_config->ssl_verify_callback = std::move(ssl_verify_callback);
+        }
     }
     CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 1cb3a165dc..e446a4c73c 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 1cb3a165dc703a706cd107318b38c2f49fa3f31f
+Subproject commit e446a4c73c52c70ac3d4eb801e0e0a286e21acbc
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 89fafb6b95..353da2a112 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -1524,6 +1524,18 @@ public boolean isValid() {
         this.query.or();
         return this;
     }
+    
+    /**
+     * Logical-and two conditions
+     * Realm automatically applies logical-and between all query statements, so this is intended only as a mean to increase readability.
+     *
+     * @return the query object
+     */
+    public RealmQuery<E> and() {
+    	realm.checkIfValid();
+    	
+    	return this;
+    }
 
     /**
      * Negate condition.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 4ba4d0e5d9..43381058c4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,7 +16,17 @@
 
 package io.realm;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -27,13 +37,18 @@
 import java.util.concurrent.TimeUnit;
 
 import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.Keep;
+import io.realm.internal.Util;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.network.OkHttpAuthenticationServer;
 import io.realm.log.RealmLog;
+import okhttp3.internal.tls.OkHostnameVerifier;
 
 /**
  * The SyncManager is the central controller for interacting with the Realm Object Server.
@@ -293,13 +308,25 @@ static void notifyUserLoggedOut(SyncUser user) {
      */
     @SuppressWarnings("unused")
     private static synchronized void notifyErrorHandler(int errorCode, String errorMessage, @Nullable String path) {
-        for (SyncSession syncSession : sessions.values()) {
-            if (path == null || path.equals(syncSession.getConfiguration().getPath())) {
+        if (Util.isEmptyString(path)) {
+            // notify all sessions
+            for (SyncSession syncSession : sessions.values()) {
+                    try {
+                        syncSession.notifySessionError(errorCode, errorMessage);
+                    } catch (Exception exception) {
+                        RealmLog.error(exception);
+                    }
+                }
+        } else {
+            SyncSession syncSession = sessions.get(path);
+            if (syncSession != null) {
                 try {
                     syncSession.notifySessionError(errorCode, errorMessage);
                 } catch (Exception exception) {
                     RealmLog.error(exception);
                 }
+            } else {
+                RealmLog.warn("Cannot find the SyncSession corresponding to the path: " + path);
             }
         }
     }
@@ -356,6 +383,117 @@ private synchronized static String bindSessionWithConfig(String sessionPath, Str
         return null;
     }
 
+    // Holds the certificate chain (per hostname). We need to keep the order of each certificate
+    // according to it's depth in the chain. The depth of the last
+    // certificate is 0. The depth of the first certificate is chain
+    // length - 1.
+    private static HashMap<String, List<String>> ROS_CERTIFICATES_CHAIN;
+
+    // The default Android Trust Manager which uses the default KeyStore to
+    // validate the certificate chain.
+    private static X509TrustManager TRUST_MANAGER;
+
+    // Help transform a String PEM representation of the certificate, into
+    // X509Certificate format.
+    private static CertificateFactory CERTIFICATE_FACTORY;
+
+    // From Sync implementation:
+    //  A recommended way of using the callback function is to return true
+    //  if preverify_ok = 1 and depth > 0,
+    //  always check the host name if depth = 0,
+    //  and use an independent verification step if preverify_ok = 0.
+    //
+    //  Another possible way of using the callback is to collect all the
+    //  ROS_CERTIFICATES_CHAIN until depth = 0, and present the entire chain for
+    //  independent verification.
+    //
+    // In this implementation we use the second method, since it's more suitable for
+    // the underlying Java API we need to call to validate the certificate chain.
+    @SuppressWarnings("unused")
+    synchronized static boolean sslVerifyCallback(String serverAddress, String pemData, int depth) {
+        try {
+            if (ROS_CERTIFICATES_CHAIN == null) {
+                ROS_CERTIFICATES_CHAIN = new HashMap<>();
+                TRUST_MANAGER = systemDefaultTrustManager();
+                CERTIFICATE_FACTORY = CertificateFactory.getInstance("X.509");
+            }
+
+            if (!ROS_CERTIFICATES_CHAIN.containsKey(serverAddress)) {
+                ROS_CERTIFICATES_CHAIN.put(serverAddress, new ArrayList<String>());
+            }
+
+            ROS_CERTIFICATES_CHAIN.get(serverAddress).add(pemData);
+
+            if (depth == 0) {
+                // transform all PEM ROS_CERTIFICATES_CHAIN into Java X509
+                // with respecting the order/depth provided from Sync.
+                List<String> pemChain = ROS_CERTIFICATES_CHAIN.get(serverAddress);
+                int n = pemChain.size();
+                X509Certificate[] chain = new X509Certificate[n];
+                for (String pem : pemChain) {
+                    // The depth of the last certificate is 0.
+                    // The depth of the first certificate is chain length - 1.
+                    chain[--n] = buildCertificateFromPEM(pem);
+                }
+
+                // verify the entire chain
+                try {
+                    TRUST_MANAGER.checkServerTrusted(chain, "RSA");
+                    // verify the hostname
+                    boolean isValid = OkHostnameVerifier.INSTANCE.verify(serverAddress, chain[0]);
+                    if (isValid) {
+                        return true;
+                    } else {
+                        RealmLog.error("Can not verify the hostname for the host: " + serverAddress);
+                        return false;
+                    }
+                } catch (CertificateException e) {
+                    RealmLog.error(e, "Can not validate SSL chain certificate for the host: " + serverAddress);
+                    return false;
+                } finally {
+                    // don't keep the certificate chain in memory
+                    ROS_CERTIFICATES_CHAIN.remove(serverAddress);
+                }
+            } else {
+                // return true, since the verification will happen for the entire chain
+                // when receiving the depth == 0 (host certificate)
+                return true;
+            }
+        } catch (Exception e) {
+            RealmLog.error(e, "Error during certificate validation for host: " + serverAddress);
+            return false;
+        }
+    }
+
+    // Credit OkHttp https://github.com/square/okhttp/blob/e5c84e1aef9572adb493197c1b6c4e882aca085b/okhttp/src/main/java/okhttp3/OkHttpClient.java#L270
+    private static X509TrustManager systemDefaultTrustManager() {
+        try {
+            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+                    TrustManagerFactory.getDefaultAlgorithm());
+            trustManagerFactory.init((KeyStore) null);
+            TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+            if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+                throw new IllegalStateException("Unexpected default trust managers:"
+                        + Arrays.toString(trustManagers));
+            }
+            return (X509TrustManager) trustManagers[0];
+        } catch (GeneralSecurityException e) {
+            throw new AssertionError(); // The system has no TLS. Just give up.
+        }
+    }
+
+    private static X509Certificate buildCertificateFromPEM(String pem) throws IOException, CertificateException {
+        InputStream stream = null;
+        try {
+            stream = new ByteArrayInputStream(pem.getBytes("UTF-8"));
+            return (X509Certificate) CERTIFICATE_FACTORY.generateCertificate(stream);
+        } finally {
+            if (stream != null) {
+                stream.close();
+            }
+        }
+    }
+
     /**
      * Resets the SyncManger and clear all existing users.
      * This will also terminate all sessions.
diff --git a/realm/realm-library/src/syncIntegrationTest/assets/untrusted_ca.pem b/realm/realm-library/src/syncIntegrationTest/assets/untrusted_ca.pem
new file mode 100644
index 0000000000..8c4c741058
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/assets/untrusted_ca.pem
@@ -0,0 +1,28 @@
+-----BEGIN CERTIFICATE-----
+MIIEsTCCA5mgAwIBAgIQBOHnpNxc8vNtwCtCuF0VnzANBgkqhkiG9w0BAQsFADBs
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j
+ZSBFViBSb290IENBMB4XDTEzMTAyMjEyMDAwMFoXDTI4MTAyMjEyMDAwMFowcDEL
+MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3
+LmRpZ2ljZXJ0LmNvbTEvMC0GA1UEAxMmRGlnaUNlcnQgU0hBMiBIaWdoIEFzc3Vy
+YW5jZSBTZXJ2ZXIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC2
+4C/CJAbIbQRf1+8KZAayfSImZRauQkCbztyfn3YHPsMwVYcZuU+UDlqUH1VWtMIC
+Kq/QmO4LQNfE0DtyyBSe75CxEamu0si4QzrZCwvV1ZX1QK/IHe1NnF9Xt4ZQaJn1
+itrSxwUfqJfJ3KSxgoQtxq2lnMcZgqaFD15EWCo3j/018QsIJzJa9buLnqS9UdAn
+4t07QjOjBSjEuyjMmqwrIw14xnvmXnG3Sj4I+4G3FhahnSMSTeXXkgisdaScus0X
+sh5ENWV/UyU50RwKmmMbGZJ0aAo3wsJSSMs5WqK24V3B3aAguCGikyZvFEohQcft
+bZvySC/zA/WiaJJTL17jAgMBAAGjggFJMIIBRTASBgNVHRMBAf8ECDAGAQH/AgEA
+MA4GA1UdDwEB/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIw
+NAYIKwYBBQUHAQEEKDAmMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2Vy
+dC5jb20wSwYDVR0fBEQwQjBAoD6gPIY6aHR0cDovL2NybDQuZGlnaWNlcnQuY29t
+L0RpZ2lDZXJ0SGlnaEFzc3VyYW5jZUVWUm9vdENBLmNybDA9BgNVHSAENjA0MDIG
+BFUdIAAwKjAoBggrBgEFBQcCARYcaHR0cHM6Ly93d3cuZGlnaWNlcnQuY29tL0NQ
+UzAdBgNVHQ4EFgQUUWj/kK8CB3U8zNllZGKiErhZcjswHwYDVR0jBBgwFoAUsT7D
+aQP4v0cB1JgmGggC72NkK8MwDQYJKoZIhvcNAQELBQADggEBABiKlYkD5m3fXPwd
+aOpKj4PWUS+Na0QWnqxj9dJubISZi6qBcYRb7TROsLd5kinMLYBq8I4g4Xmk/gNH
+E+r1hspZcX30BJZr01lYPf7TMSVcGDiEo+afgv2MW5gxTs14nhr9hctJqvIni5ly
+/D6q1UEL2tU2ob8cbkdJf17ZSHwD2f2LSaCYJkJA69aSEaRkCldUxPUd1gJea6zu
+xICaEnL6VpPX/78whQYwvwt/Tv9XBZ0k7YXDK/umdaisLRbvfXknsuvCnQsH6qqF
+0wGjIChBWUMo0oHjqvbsezt3tkBigAVBRQHvFwY+3sAzm2fTYS5yh+Rp/BIAV0Ae
+cPUeybQ=
+-----END CERTIFICATE-----
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
index dce05265a9..84c2788de8 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
@@ -106,7 +106,6 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore
     public void getPermissions_updatedWithNewRealms() {
         final PermissionManager pm = user.getPermissionManager();
         looperThread.closeAfterTest(pm);
@@ -153,7 +152,6 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore
     public void getPermissions_updatedWithNewRealms_stressTest() {
         final int TEST_SIZE = 10;
         final PermissionManager pm = user.getPermissionManager();
@@ -289,7 +287,7 @@ public void onError(ObjectServerError error) {
         });
     }
 
-    @Ignore("See https://github.com/realm/realm-java/issues/5143")
+    @Ignore("The PermissionManager can only be opened from the main thread")
     @Test
     public void clientResetOnMultipleThreads() {
 
@@ -901,7 +899,7 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread(emulateMainThread = true)
-    @Ignore
+    @Ignore("The offer is randomly accepted mostly on docker-02 SHIELD K1")
     public void acceptOffer_expiredThrows() {
         // Trying to guess how long CI is to process this. The offer cannot be created if it
         // already expired.
@@ -1181,6 +1179,7 @@ public void run() {
     private String createRemoteRealm(SyncUser user, String realmName) {
         String url = Constants.AUTH_SERVER_URL + "~/" + realmName;
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .name(realmName)
                 .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .build();
 
@@ -1205,18 +1204,12 @@ public void onChange(Progress progress) {
      * states and fail if neither of these can be verified.
      */
     private void assertInitialPermissions(RealmResults<Permission> permissions) {
-        assertGreaterThan("Unexpected count() for __permission Realm: " + Arrays.toString(permissions.toArray()), 0, permissions.where().endsWith("path", "__permission").count());
-        assertGreaterThan("Unexpected count() for __management Realm: " + Arrays.toString(permissions.toArray()), 0, permissions.where().endsWith("path", "__management").count());
-        // FIXME: Enable these again when https://github.com/realm/ros/issues/549 is fixed
-        // assertEquals("Unexpected count() for __permission Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__permission").count());
-        // assertEquals("Unexpected count() for __management Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__management").count());
+         assertEquals("Unexpected count() for __permission Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__permission").count());
+         assertEquals("Unexpected count() for __management Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__management").count());
     }
 
     private void assertInitialDefaultPermissions(RealmResults<Permission> permissions) {
-        assertGreaterThan("Unexpected count() for __wildcardpermissions Realm: " + Arrays.toString(permissions.toArray()), 0, permissions.where().endsWith("path", "__wildcardpermissions").count());
-
-        // FIXME: Enable these again when https://github.com/realm/ros/issues/549 is fixed
-        // assertEquals("Unexpected count() for __wildcardpermissions Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__wildcardpermissions").count());
+         assertEquals("Unexpected count() for __wildcardpermissions Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__wildcardpermissions").count());
     }
 
     private void assertGreaterThan(String error, int base, long count) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index ab943c1e3c..68de33b306 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -19,7 +19,6 @@
 import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
@@ -42,7 +41,7 @@
 public class SSLConfigurationTests extends StandardIntegrationTest {
 
     @Rule
-    public Timeout globalTimeout = Timeout.seconds(10);
+    public Timeout globalTimeout = Timeout.seconds(120);
 
     @Test
     public void trustedRootCA() throws InterruptedException {
@@ -51,30 +50,32 @@ public void trustedRootCA() throws InterruptedException {
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server
-        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+        //noinspection unchecked
+        final SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .schema(StringOnly.class)
                 .build();
-        Realm realm = Realm.getInstance(configOld);
+        Realm realm = Realm.getInstance(syncConfig);
 
         realm.beginTransaction();
         realm.createObject(StringOnly.class).setChars("Foo");
         realm.commitTransaction();
 
         // make sure the changes gets to the server
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
         user.logout();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
-        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+        //noinspection unchecked
+        SyncConfiguration syncConfigSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
                 .schema(StringOnly.class)
                 .waitForInitialRemoteData()
                 .trustedRootCA("trusted_ca.pem")
                 .build();
-        realm = Realm.getInstance(config);
+        realm = Realm.getInstance(syncConfigSSL);
 
         RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
         try {
@@ -92,30 +93,32 @@ public void withoutSSLVerification() throws InterruptedException {
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server
-        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+        //noinspection unchecked
+        final SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .schema(StringOnly.class)
                 .build();
-        Realm realm = Realm.getInstance(configOld);
+        Realm realm = Realm.getInstance(syncConfig);
 
         realm.beginTransaction();
         realm.createObject(StringOnly.class).setChars("Foo");
         realm.commitTransaction();
 
         // make sure the changes gets to the server
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
         user.logout();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
-        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+        //noinspection unchecked
+        SyncConfiguration syncConfigSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
                 .schema(StringOnly.class)
                 .waitForInitialRemoteData()
                 .disableSSLVerification()
                 .build();
-        realm = Realm.getInstance(config);
+        realm = Realm.getInstance(syncConfigSSL);
 
         RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
         try {
@@ -133,28 +136,33 @@ public void trustedRootCA_syncShouldFailWithoutTrustedCA() throws InterruptedExc
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server
-        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+        //noinspection unchecked
+        final SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .schema(StringOnly.class)
                 .build();
-        Realm realm = Realm.getInstance(configOld);
+        Realm realm = Realm.getInstance(syncConfig);
 
         realm.beginTransaction();
         realm.createObject(StringOnly.class).setChars("Foo");
         realm.commitTransaction();
 
         // make sure the changes gets to the server
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
         user.logout();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
-        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+        //noinspection unchecked
+        SyncConfiguration syncConfigSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
                 .schema(StringOnly.class)
+                .trustedRootCA("untrusted_ca.pem")
                 .build();
-        realm = Realm.getInstance(config);
+        // waitForInitialRemoteData will throw an Internal error (125): Operation Canceled
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));
+        realm = Realm.getInstance(syncConfigSSL);
         try {
             assertTrue(realm.isEmpty());
         } finally {
@@ -173,7 +181,9 @@ public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
         RealmLog.add(testLogger);
         RealmLog.setLevel(LogLevel.WARN);
 
+        //noinspection unchecked
         configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
                 .schema(StringOnly.class)
                 .trustedRootCA("trusted_ca.pem")
                 .disableSSLVerification()
@@ -190,15 +200,106 @@ public void trustedRootCA_notExisting_certificate_willThrow() {
         String username = UUID.randomUUID().toString();
         String password = "password";
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
-        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+        //noinspection unchecked
+        SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .schema(StringOnly.class)
-                .trustedRootCA("not_existing_file.pem")
+                .trustedRootCA("none_existing_file.pem")
                 .build();
 
         try {
-            Realm.getInstance(config);
+            Realm.getInstance(syncConfig);
             fail();
         } catch (RealmFileException ignored) {
         }
     }
+
+    @Test
+    public void combiningTrustedRootCA_and_disableSSLVerification() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server using ssl_verify_path option
+        //noinspection unchecked
+        final SyncConfiguration syncConfigWithCertificate = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .schema(StringOnly.class)
+                .trustedRootCA("trusted_ca.pem")
+                .build();
+        Realm realm = Realm.getInstance(syncConfigWithCertificate);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        // make sure the changes gets to the server
+        SyncManager.getSession(syncConfigWithCertificate).uploadAllLocalChanges();
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes.
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        //noinspection unchecked
+        SyncConfiguration syncConfigDisableSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
+                .schema(StringOnly.class)
+                .waitForInitialRemoteData()
+                .disableSSLVerification()
+                .build();
+        realm = Realm.getInstance(syncConfigDisableSSL);
+
+        RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
+        try {
+            assertEquals(1, all.size());
+            assertEquals("Foo", all.get(0).getChars());
+        } finally {
+            realm.close();
+        }
+    }
+
+    // IMPORTANT: Following test assume the root certificate is installed on the test device
+    //            certificate is located in <realm-java>/tools/sync_test_server/keys/android_test_certificate.crt
+    //            adb push <realm-java>/tools/sync_test_server/keys/android_test_certificate.crt /sdcard/
+    //            then import the certificate from the device (Settings/Security/Install from storage)
+    @Test
+    public void sslVerifyCallback_isUsed() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server using ssl_verify_path option
+        //noinspection unchecked
+        final SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(syncConfig);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        // make sure the changes gets to the server
+        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes.
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        //noinspection unchecked
+        SyncConfiguration syncConfigSecure = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
+                .schema(StringOnly.class)
+                .waitForInitialRemoteData()
+                .build();
+        realm = Realm.getInstance(syncConfigSecure);
+
+        RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
+        try {
+            assertEquals(1, all.size());
+            assertEquals("Foo", all.get(0).getChars());
+        } finally {
+            realm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 7fce3b7a02..55aab7e5f5 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -116,7 +116,6 @@ public void uploadDownloadAllChanges() throws InterruptedException {
     }
 
     @Test
-    @Ignore()
     public void interruptWaits() throws InterruptedException {
         final SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
@@ -309,7 +308,6 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
     // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
     // this test validate the behaviour of SyncSessionStopPolicy::AfterChangesUploaded
     @Test
-    @Ignore()
     public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index 7e581f6a6f..7eaa41f60a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -124,7 +124,8 @@ public void execute(Realm realm) {
     // We cannot do much better since we cannot control the order of events internally in Realm which would be
     // needed to correctly test all error paths.
     @Test
-    @Ignore("See https://github.com/realm/realm-java/issues/5177")
+    @Ignore("Sync somehow keeps a Realm alive, causing the Realm.deleteRealm to throw " +
+            " https://github.com/realm/realm-java/issues/5416")
     public void waitForInitialData_resilientInCaseOfRetries() throws InterruptedException {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
         SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
@@ -166,6 +167,8 @@ public void waitForInitialData_resilientInCaseOfRetriesAsync() {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
         SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
         final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .directory(configurationFactory.getRoot())
                 .waitForInitialRemoteData()
                 .build();
         Random randomizer = new Random();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index e4847f19aa..b477f33609 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -20,7 +20,6 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -104,7 +103,6 @@ protected void run() {
     @Test
     @RunTestInLooperThread
     @RunTestWithRemoteService(remoteService = SimpleCommitRemoteService.class, onLooperThread = true)
-    @Ignore("See https://github.com/realm/realm-java/issues/5376")
     public void expectSimpleCommit() {
         looperThread.runAfterTest(remoteService.afterRunnable);
         remoteService.createHandler(Looper.myLooper());
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index cc3fcd95ee..dc0ae46830 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -17,18 +17,12 @@
 package io.realm.objectserver.utils;
 
 import android.os.SystemClock;
-import android.util.Log;
 
 import java.io.IOException;
-import java.net.SocketTimeoutException;
 import java.util.concurrent.TimeUnit;
 
-import io.realm.log.RealmLog;
-import okhttp3.Headers;
-import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.RequestBody;
 import okhttp3.Response;
 
 /**
@@ -40,8 +34,9 @@
 public class HttpUtils {
     // TODO If the timeouts are longer than the test timeout you risk getting
     // "Realm could not be deleted errors".
+    // FIXME re-adjust timeout after https://github.com/realm/realm-object-server-private/issues/697 is fixed
     private final static OkHttpClient client = new OkHttpClient.Builder()
-            .retryOnConnectionFailure(true)
+            .connectTimeout(2, TimeUnit.MINUTES)
             .build();
 
     // adb reverse tcp:8888 tcp:8888
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index c4f792b11c..8a9a766a41 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -1,5 +1,9 @@
 FROM node:6.11.4
 
+# set timezone to Copenhagen (by default it's using UTC) to match Android's device time.
+RUN cp /usr/share/zoneinfo/Europe/Copenhagen /etc/localtime
+RUN echo "Europe/Copenhagen" >  /etc/timezone
+
 ARG ROS_DE_VERSION
 
 # Install realm object server
diff --git a/tools/sync_test_server/keys/android_test_certificate.crt b/tools/sync_test_server/keys/android_test_certificate.crt
new file mode 100644
index 0000000000..53a5f087ef
Binary files /dev/null and b/tools/sync_test_server/keys/android_test_certificate.crt differ
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index 2f841d4f43..e183378084 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -43,7 +43,7 @@ function handleRequest(request, response) {
 var syncServerChildProcess = null;
 
 // Waits for ROS to be fully initialized.
-function waitForRosToInitialize(attempts, onSuccess, onError) {
+function waitForRosToInitialize(attempts, onSuccess, onError, startSequence) {
     if (attempts == 0) {
         onError("Could not get ROS to start. See Docker log.");
         return;
@@ -51,16 +51,16 @@ function waitForRosToInitialize(attempts, onSuccess, onError) {
     http.get("http://0.0.0.0:9080/health", function(res) {
         if (res.statusCode != 200) {
             winston.info("ROS /health/ returned: " + res.statusCode)
-            waitForRosToInitialize(attempts - 1, onSuccess, onError)
+            waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence)
         } else {
-            onSuccess();
+            onSuccess(startSequence);
         }
     }).on('error', function(err) {
         // ROS not accepting any connections yet.
         // Errors like ECONNREFUSED 0.0.0.0:9080 will be reported here.
         // Wait a little before trying again (common startup is ~1 second).
         setTimeout(function() {
-            waitForRosToInitialize(attempts - 1, onSuccess, onError);
+            waitForRosToInitialize(attempts - 1, onSuccess, onError, startSequence);
         }, 200);
     });
 }
@@ -112,7 +112,7 @@ function doStartRealmObjectServer(onSuccess, onError) {
                 winston.info(`${data}`);
             });
 
-            waitForRosToInitialize(20, onSuccess, onError);
+            waitForRosToInitialize(100, onSuccess, onError, Date.now());
         }
     });
 }
@@ -121,24 +121,28 @@ function stopRealmObjectServer(onSuccess, onError) {
     if(syncServerChildProcess == null || syncServerChildProcess.killed) {
         onSuccess("No ROS process found or the process has been killed before");
     }
+    if (syncServerChildProcess) {
+        syncServerChildProcess.on('exit', function(code) {
+            winston.info("ROS server stopped due to process being killed. Exit code: " + code);
+            syncServerChildProcess.removeAllListeners('exit');
+            syncServerChildProcess = null;
+            onSuccess();
+        });
 
-    syncServerChildProcess.on('exit', function(code) {
-        winston.info("ROS server stopped due to process being killed. Exit code: " + code);
-        syncServerChildProcess.removeAllListeners('exit');
-        syncServerChildProcess = null;
-        onSuccess();
-    });
-
-    syncServerChildProcess.kill('SIGKILL');
+        syncServerChildProcess.kill('SIGKILL');
+    }
 }
 
 // start sync server
 dispatcher.onGet("/start", function(req, res) {
     winston.info("Attempting to start ROS");
-    startRealmObjectServer(() => {
+    startRealmObjectServer((startSequence) => {
         res.writeHead(200, {'Content-Type': 'text/plain'});
-        res.end('ROS started');
+        let response = `ROS started after ${Date.now() - startSequence} ms`;
+        winston.info(response);
+        res.end(response);
     }, function (err) {
+        winston.error('Starting ROS failed: ' + err);
         res.writeHead(500, {'Content-Type': 'text/plain'});
         res.end('Starting ROS failed: ' + err);
     });
diff --git a/version.txt b/version.txt
index c3a2c7076f..d168f1d8bd 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.2.0-SNAPSHOT
\ No newline at end of file
+4.2.1-SNAPSHOT
\ No newline at end of file
