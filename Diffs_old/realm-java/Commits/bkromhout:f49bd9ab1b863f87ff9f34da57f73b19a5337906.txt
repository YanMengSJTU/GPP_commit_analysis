diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4f0c017fea..0e29df4f4d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,17 +1,42 @@
 ## 0.90.0
 
+### Breaking changes
+
+* All JSON methods on Realm now only wraps JSONException in RealmException. All other Exceptions are thrown as they are.
+* Marked all methods on `RealmObject` and all public classes final (#1594).
+* Removed `BaseRealm` from the public API.
+* Removed `HandlerController` from the public API.
+* Removed constructor of `RealmAsyncTask` from the public API8 (#1594).
+
 ### Deprecated
 
+* `Realm.allObjects*()`. Use `Realm.where(clazz).findAll*()` instead.
+* `Realm.distinct*()`. Use `Realm.where(clazz).distinct*()` instead.
+* `DynamicRealm.allObjects*()`. Use `DynamicRealm.where(className).findAll*()` instead.
+* `DynamicRealm.distinct*()`. Use `DynamicRealm.where(className).distinct*()` instead.
+* `Realm.allObjectsSorted(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSorted(field[], sort[])`` instead.
+* `RealmQuery.findAllSorted(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSorted(field[], sort[])`` instead.
+* `RealmQuery.findAllSortedAsync(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSortedAsync(field[], sort[])`` instead.
 * `RealmConfiguration.setModules()`. Use `RealmConfiguration.modules()` instead.
 
 ### Enhancements
 
-* `RealmObjectSchema.getPrimaryKey()` (#2636)
+* `RealmObjectSchema.getPrimaryKey()`. (#2636)
+* `Realm.createObject(Class, Object)` for creating objects with a primary key directly.
+* Unit tests in Android library projects now detect Realm model classes.
 
 ### Credits
 
 * Thanks to Brenden Kromhout (@bkromhout) for adding `RealmObjectSchema.getPrimaryKey()`.
 
+## 0.89.1
+
+### Bug fixes
+
+* @PrimaryKey + @Required on String type primary key no longer throws when using copyToRealm or copyToRealmOrUpdate (#2653).
+* Primary key is cleared/changed when calling RealmSchema.remove()/RealmSchema.rename() (#2555).
+* Objects implementing RealmModel can be used as a field of RealmModel/RealmObject (#2654).
+
 ## 0.89.0
 
 ### Breaking changes
@@ -19,6 +44,8 @@
 * @PrimaryKey field value can now be null for String, Byte, Short, Integer, and Long types. Older Realms should be migrated, using RealmObjectSchema.setNullable(), or by adding the @Required annotation. (#2515).
 * `RealmResults.clear()` now throws UnsupportedOperationException. Use `RealmResults.deleteAllFromRealm()` instead.
 * `RealmResults.remove(int)` now throws UnsupportedOperationException. Use `RealmResults.deleteFromRealm(int)` instead.
+* `RealmResults.sort()` and `RealmList.sort()` now return the sorted result instead of sorting in-place.
+* `RealmList.first()` and `RealmList.last()` now throw `ArrayIndexOutOfBoundsException` if `RealmList` is empty.
 * Removed deprecated method `Realm.getTable()` from public API.
 
 ### Deprecated
diff --git a/README.md b/README.md
index db14a975d1..1638d47c8e 100644
--- a/README.md
+++ b/README.md
@@ -6,18 +6,18 @@ This repository holds the source code for the Java version of Realm, which curre
 ## Features
 
 * **Mobile-first:** Realm is the first database built from the ground up to run directly inside phones, tablets and wearables.
-* **Simple:** Data is directly exposed as objects and queryable by code, removing the need for ORM's riddled with performance & maintenance issues. Plus, we've worked hard to [keep our API down to very few classes](http://realm.io/docs/java/): most of our users pick it up intuitively, getting simple apps up & running in minutes.
+* **Simple:** Data is directly exposed as objects and queryable by code, removing the need for ORM's riddled with performance & maintenance issues. Plus, we've worked hard to [keep our API down to very few classes](https://realm.io/docs/java/): most of our users pick it up intuitively, getting simple apps up & running in minutes.
 * **Modern:** Realm supports easy thread-safety, relationships & encryption.
 * **Fast:** Realm is faster than even raw SQLite on common operations, while maintaining an extremely rich feature set.
 
 ## Getting Started
 
-Please see the [detailed instructions in our docs](http://realm.io/docs/java/#installation) to add Realm to your project.
+Please see the [detailed instructions in our docs](https://realm.io/docs/java/#installation) to add Realm to your project.
 
 ## Documentation
 
-Documentation for Realm can be found at [realm.io/docs/java](http://realm.io/docs/java).
-The API reference is located at [realm.io/docs/java/api](http://realm.io/docs/java/api).
+Documentation for Realm can be found at [realm.io/docs/java](https://realm.io/docs/java).
+The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/java/api).
 
 ## Getting Help
 
@@ -140,7 +140,7 @@ See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 ## License
 
 Realm Java is published under the Apache 2.0 license.
-The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](http://realm.io/docs/java/#faq).
+The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](https://realm.io/docs/java/#faq).
 
 **This product is not being made available to any person located in Cuba, Iran,
 North Korea, Sudan, Syria or the Crimea region, or to any other person that is
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 15365c35c7..049cf16cbf 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -32,7 +32,7 @@ android {
         abi {
             enable true
             reset()
-            include 'arm', 'arm-v7a', 'arm64', 'mips', 'x86', 'x86_64'
+            include 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86', 'x86_64'
         }
     }
 }
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index b6e94ac171..33a5ed5655 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -27,6 +27,8 @@ android {
     buildTypes {
         release {
             minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt'),
+                    'proguard-rules.pro'
             signingConfig signingConfigs.release
         }
     }
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 58e5be1490..1abe5250b8 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -60,7 +60,7 @@
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
-@PrepareForTest({Realm.class, RealmConfiguration.class, RealmResults.class, RealmCore.class})
+@PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class})
 public class ExampleActivityTest {
 
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 0536847d77..2077c526da 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -57,6 +57,8 @@ class Realm implements Plugin<Project> {
         } else {
             project.dependencies.add("apt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("apt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+            project.dependencies.add("androidTestApt", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("androidTestApt", "io.realm:realm-annotations-processor:${Version.VERSION}")
         }
     }
 
diff --git a/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java b/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
new file mode 100644
index 0000000000..a151800a9d
--- /dev/null
+++ b/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Scanner;
+
+/**
+ * Generate a unique identifier for a computer. The method being used depends on the platform:
+ *  - OS X:  Mac address of en0
+ *  - Windows:  BIOS identifier
+ *  - Linux: Machine ID provided by the OS
+ */
+public class ComputerIdentifierGenerator {
+
+    private static final String UNKNOWN = "unknown";
+
+    private static String OS = System.getProperty("os.name").toLowerCase();
+
+    public static String get() {
+        try {
+            if (isWindows()) {
+                return getWindowsIdentifier();
+            } else if (isMac()) {
+                return getMacOsIdentifier();
+            } else if (isLinux()) {
+                return getLinuxMacAddress();
+            } else {
+                return UNKNOWN;
+            }
+        } catch (Exception e) {
+            return UNKNOWN;
+        }
+    }
+
+    private static boolean isWindows() {
+        return (OS.contains("win"));
+    }
+
+    private static boolean isMac() {
+        return (OS.contains("mac"));
+    }
+
+    private static boolean isLinux() {
+        return (OS.contains("inux"));
+    }
+
+    private static String getLinuxMacAddress() throws FileNotFoundException, NoSuchAlgorithmException {
+        File machineId = new File("/var/lib/dbus/machine-id");
+        if (!machineId.exists()) {
+            machineId = new File("/etc/machine-id");
+        }
+        if (!machineId.exists()) {
+            return UNKNOWN;
+        }
+
+        Scanner scanner = null;
+        try {
+            scanner = new Scanner(machineId);
+            String id = scanner.useDelimiter("\\A").next();
+            return Utils.hexStringify(Utils.sha256Hash(id.getBytes()));
+        } finally {
+            if (scanner != null) {
+                scanner.close();
+            }
+        }
+    }
+
+    private static String getMacOsIdentifier() throws SocketException, NoSuchAlgorithmException {
+        NetworkInterface networkInterface = NetworkInterface.getByName("en0");
+        byte[] hardwareAddress = networkInterface.getHardwareAddress();
+        return Utils.hexStringify(Utils.sha256Hash(hardwareAddress));
+    }
+
+    private static String getWindowsIdentifier() throws IOException, NoSuchAlgorithmException {
+        Runtime runtime = Runtime.getRuntime();
+        Process process = runtime.exec(new String[] { "wmic", "bios", "get", "serialnumber" });
+
+        String result = null;
+        InputStream is = process.getInputStream();
+        Scanner sc = new Scanner(process.getInputStream());
+        try {
+            while (sc.hasNext()) {
+                String next = sc.next();
+                if ("SerialNumber".equals(next)) {
+                    result = sc.next().trim();
+                    break;
+                }
+            }
+        } finally {
+            is.close();
+        }
+
+        return result==null?UNKNOWN:Utils.hexStringify(Utils.sha256Hash(result.getBytes()));
+    }
+}
diff --git a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
index a791be28e4..bd1709453b 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
@@ -133,7 +133,7 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
         return JSON_TEMPLATE
                 .replaceAll("%EVENT%", EVENT_NAME)
                 .replaceAll("%TOKEN%", TOKEN)
-                .replaceAll("%USER_ID%", getAnonymousUserId())
+                .replaceAll("%USER_ID%", ComputerIdentifierGenerator.get())
                 .replaceAll("%APP_ID%", getAnonymousAppId())
                 .replaceAll("%LANGUAGE%", usesKotlin?"kotlin":"java")
                 .replaceAll("%REALM_VERSION%", Version.VERSION)
@@ -141,25 +141,6 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
                 .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
     }
 
-    /**
-     * Computes an anonymous user id from the hashed MAC address of the first network interface
-     * @return the anonymous user id
-     * @throws NoSuchAlgorithmException
-     * @throws SocketException
-     */
-    public static String getAnonymousUserId() throws NoSuchAlgorithmException, SocketException {
-        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
-
-        if (!networkInterfaces.hasMoreElements()) {
-            throw new IllegalStateException("No network interfaces detected");
-        }
-
-        NetworkInterface networkInterface = networkInterfaces.nextElement();
-        byte[] hardwareAddress = networkInterface.getHardwareAddress(); // Normally this is the MAC address
-
-        return Utils.hexStringify(Utils.sha256Hash(hardwareAddress));
-    }
-
     /**
      * Computes an anonymous app/library id from the packages containing RealmObject classes
      * @return the anonymous app/library id
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index 4f2b60bc50..fe4dab1d3c 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -13,7 +13,7 @@ dependencies {
 
     testCompile files('../realm-library/build/intermediates/bundles/release/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
-    testCompile group:'junit', name:'junit', version:'4.11'
+    testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
     testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-21/android.jar"))
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index da7a37422b..94586963b4 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -225,7 +225,7 @@ private boolean categorizeClassElements() {
                     } else if (Utils.isRealmList(variableElement)) {
                         Utils.error("@Required is invalid for field " + element +
                                 " with the type " + element.asType());
-                    } else if (Utils.isRealmObject(variableElement)) {
+                    } else if (Utils.isRealmModel(variableElement)) {
                         Utils.error("@Required is invalid for field " + element +
                                 " with the type " + element.asType());
                     } else {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index d5ee764a81..420cdcef2c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -86,7 +86,7 @@ public void generate() throws IOException, UnsupportedOperationException {
 
         for (VariableElement field : metadata.getFields()) {
             String fieldTypeName = "";
-            if (Utils.isRealmObject(field)) { // Links
+            if (Utils.isRealmModel(field)) { // Links
                 fieldTypeName = field.asType().toString();
             } else if (Utils.isRealmList(field)) { // LinkLists
                 fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
@@ -259,7 +259,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                         "proxyState.getRow$realm().set%s(%s, value)",
                         realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
-            } else if (Utils.isRealmObject(field)) {
+            } else if (Utils.isRealmModel(field)) {
                 /**
                  * Links
                  */
@@ -282,7 +282,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                     writer.emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field));
                     writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!value.isValid())");
+                writer.beginControlFlow("if (!RealmObject.isValid(value))");
                     writer.emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")");
                 writer.endControlFlow();
                 writer.beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
@@ -372,7 +372,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("table.addColumn(%s, \"%s\", %s)",
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         fieldName, nullableFlag);
-            } else if (Utils.isRealmObject(field)) {
+            } else if (Utils.isRealmModel(field)) {
                 writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
                 writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
@@ -519,7 +519,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     writer.endControlFlow();
                 }
 
-            } else if (Utils.isRealmObject(field)) { // Links
+            } else if (Utils.isRealmModel(field)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
                         "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
@@ -639,8 +639,9 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                         .endControlFlow();
                 }
             } else {
-                writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, ((%s) object).%s())",
-                        interfaceName, primaryKeyGetter);
+                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                        pkType, interfaceName, primaryKeyGetter);
             }
 
             writer
@@ -690,7 +691,7 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
 
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 writer
                     .emitEmptyLine()
                     .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
@@ -770,7 +771,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
             String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
 
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
@@ -821,7 +822,7 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             String fieldName = field.getSimpleName().toString();
             String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 writer
                     .emitStatement("%s %sObj = ((%s) newObject).%s()",
                             Utils.getFieldTypeSimpleName(field), fieldName, interfaceName, getter)
@@ -891,7 +892,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
             String fieldName = field.getSimpleName().toString();
 
             writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                 writer.emitStatement(
                         "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
@@ -1025,7 +1026,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                         interfaceName,
                         metadata.getSetter(fieldName),
@@ -1086,7 +1087,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             } else {
                 writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
             }
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                         interfaceName,
                         metadata.getSetter(fieldName),
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index def7ba77d3..8f0dd71b41 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -23,14 +23,14 @@
     private static Messager messager;
     private static DeclaredType realmList;
     private static DeclaredType markerInterface;
-    private static TypeMirror realmObject;
+    private static TypeMirror realmModel;
 
     public static void initialize(ProcessingEnvironment env) {
         typeUtils = env.getTypeUtils();
         messager = env.getMessager();
         realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"),
                 typeUtils.getWildcardType(null, null));
-        realmObject = env.getElementUtils().getTypeElement("io.realm.RealmObject").asType();
+        realmModel = env.getElementUtils().getTypeElement("io.realm.RealmModel").asType();
         markerInterface = env.getTypeUtils().getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmModel"));
     }
 
@@ -149,10 +149,10 @@ public static boolean isRealmList(VariableElement field) {
     }
 
     /**
-     * @return {@code true} if a given field type is {@code RealmObject}, {@code false} otherwise.
+     * @return {@code true} if a given field type is {@code RealmModel}, {@code false} otherwise.
      */
-    public static boolean isRealmObject(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmObject);
+    public static boolean isRealmModel(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmModel);
     }
 
 
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 3a7104a663..7bea9166ea 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -54,6 +54,7 @@
     private JavaFileObject invalidRealmModelModel_3 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_3.java");
     private JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
     private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
+    private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
 
     @Test
     public void compileSimpleFile() {
@@ -434,4 +435,12 @@ public void canNotInheritRealmList() throws Exception {
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
+
+    @Test
+    public void compileWithRealmModelFieldInReamlModel() {
+        ASSERT.about(javaSource())
+                .that(SimpleRealmModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 66c67b5563..a2a7452537 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -198,7 +198,7 @@
             proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
             return;
         }
-        if (!value.isValid()) {
+        if (!RealmObject.isValid(value)) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
         if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -819,4 +819,4 @@ public boolean equals(Object o) {
         return true;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index ff4aa82288..f4aa0f5139 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -484,7 +484,7 @@
             proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
             return;
         }
-        if (!value.isValid()) {
+        if (!RealmObject.isValid(value)) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
         if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -1306,4 +1306,4 @@ public boolean equals(Object o) {
         return true;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/SimpleRealmModel.java b/realm/realm-annotations-processor/src/test/resources/some/test/SimpleRealmModel.java
new file mode 100644
index 0000000000..d447bf08fa
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/SimpleRealmModel.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+// Object implements RealmModel and annotated by @RealmClase can be used as a field and element of RealmList
+@RealmClass
+public class SimpleRealmModel implements RealmModel {
+    String name;
+    RealmList<SimpleRealmModel> realmList;
+    SimpleRealmModel simpleRealmModel;
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 7069da01b1..e641615090 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -26,13 +26,10 @@
 import org.junit.runner.RunWith;
 
 import java.util.Date;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
-import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
@@ -43,7 +40,6 @@
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.internal.log.RealmLog;
-import io.realm.proxy.HandlerProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -56,8 +52,6 @@
 @RunWith(AndroidJUnit4.class)
 public class DynamicRealmTests {
 
-    private final static int TEST_DATA_SIZE = 10;
-
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
@@ -108,10 +102,6 @@ private void populateTestRealm(DynamicRealm realm, int objects) {
         }
     }
 
-    private void populateTestRealm() {
-        populateTestRealm(realm, TEST_DATA_SIZE);
-    }
-
     // Test that the SharedGroupManager is not reused across Realm/DynamicRealm on the same thread.
     // This is done by starting a write transaction in one Realm and verifying that none of the data
     // written (but not committed) is available in the other Realm.
@@ -279,7 +269,7 @@ public void executeTransaction_null() {
 
     @Test
     public void executeTransaction() {
-        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
         realm.executeTransaction(new DynamicRealm.Transaction() {
             @Override
             public void execute(DynamicRealm realm) {
@@ -288,7 +278,7 @@ public void execute(DynamicRealm realm) {
             }
         });
 
-        RealmResults<DynamicRealmObject> allObjects = realm.allObjects(Owner.CLASS_NAME);
+        RealmResults<DynamicRealmObject> allObjects = realm.where(Owner.CLASS_NAME).findAll();
         assertEquals(1, allObjects.size());
         assertEquals("Owner", allObjects.get(0).getString("name"));
     }
@@ -297,7 +287,7 @@ public void execute(DynamicRealm realm) {
     public void executeTransaction_cancelled() {
         final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
 
-        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
         try {
             realm.executeTransaction(new DynamicRealm.Transaction() {
                 @Override
@@ -312,12 +302,12 @@ public void execute(DynamicRealm realm) {
             //noinspection ThrowableResultOfMethodCallIgnored
             assertTrue(e == thrownException.get());
         }
-        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
     }
 
     @Test
     public void executeTransaction_warningIfManuallyCancelled() {
-        assertEquals(0, realm.allObjects("Owner").size());
+        assertEquals(0, realm.where("Owner").count());
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         try {
             RealmLog.add(testLogger);
@@ -336,392 +326,7 @@ public void execute(DynamicRealm realm) {
         } finally {
             RealmLog.remove(testLogger);
         }
-        assertEquals(0, realm.allObjects("Owner").size());
-    }
-
-    @Test
-    public void allObjectsSorted() {
-        populateTestRealm();
-        RealmResults<DynamicRealmObject> sortedList = realm.allObjectsSorted(AllTypes.CLASS_NAME, AllTypes.FIELD_STRING, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("test data 0", sortedList.first().getString(AllTypes.FIELD_STRING));
-
-        RealmResults<DynamicRealmObject> reverseList = realm.allObjectsSorted(AllTypes.CLASS_NAME, AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals("test data 0", reverseList.last().getString(AllTypes.FIELD_STRING));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void allObjectsSorted_wrongFieldName() {
-        realm.allObjectsSorted(AllTypes.CLASS_NAME, "invalid", Sort.ASCENDING);
-    }
-
-    @Test
-    public void allObjectsSorted_sortTwoFields() {
-        TestHelper.populateForMultiSort(realm);
-
-        RealmResults<DynamicRealmObject> results1 = realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results1.size());
-
-        assertEquals("Adam", results1.get(0).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results1.get(0).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Adam", results1.get(1).getString(AllTypes.FIELD_STRING));
-        assertEquals(5, results1.get(1).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Brian", results1.get(2).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results1.get(2).getLong(AllTypes.FIELD_LONG));
-
-        RealmResults<DynamicRealmObject> results2 = realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                new String[]{AllTypes.FIELD_LONG, AllTypes.FIELD_STRING},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results2.size());
-
-        assertEquals("Adam", results2.get(0).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results2.get(0).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Brian", results2.get(1).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results2.get(1).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Adam", results2.get(2).getString(AllTypes.FIELD_STRING));
-        assertEquals(5, results2.get(2).getLong(AllTypes.FIELD_LONG));
-    }
-
-    @Test
-    public void allObjectsSorted_failures() {
-        // zero fields specified
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME, new String[]{}, new Sort[]{});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // number of fields and sorting orders don't match
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                    new String[]{AllTypes.FIELD_STRING},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // null is not allowed
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME, null, (Sort[]) null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME, new String[]{AllTypes.FIELD_STRING}, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // non-existing field name
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                    new String[]{AllTypes.FIELD_STRING, "dont-exist"},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void allObjectsSorted_singleField() {
-        populateTestRealm();
-        RealmResults<DynamicRealmObject> sortedList = realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                new String[]{AllTypes.FIELD_LONG},
-                new Sort[]{Sort.DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getLong(AllTypes.FIELD_LONG));
-        assertEquals(0, sortedList.last().getLong(AllTypes.FIELD_LONG));
-    }
-
-    private void populateForDistinct(DynamicRealm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
-        boolean autoRefreshEnabled = realm.isAutoRefresh();
-        if (autoRefreshEnabled) {
-            realm.setAutoRefresh(false);
-        }
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
-            for (int j = 0; j < numberOfBlocks; j++) {
-                DynamicRealmObject obj = realm.createObject("AnnotationIndexTypes");
-                obj.setBoolean("indexBoolean", j % 2 == 0);
-                obj.setLong("indexLong", j);
-                obj.setDate("indexDate", withNull ? null : new Date(1000 * ((long) j)));
-                obj.setString("indexString", withNull ? null : "Test " + j);
-                obj.setBoolean("notIndexBoolean", j % 2 == 0);
-                obj.setLong("notIndexLong", j);
-                obj.setDate("notIndexDate", withNull ? null : new Date(1000 * ((long) j)));
-                obj.setString("notIndexString", withNull ? null : "Test " + j);
-            }
-        }
-        realm.commitTransaction();
-        if (autoRefreshEnabled) {
-            realm.setAutoRefresh(true);
-        }
-    }
-
-    private void populateForDistinctInvalidTypesLinked(DynamicRealm realm) {
-        realm.beginTransaction();
-        DynamicRealmObject notEmpty = realm.createObject(AllJavaTypes.CLASS_NAME);
-        notEmpty.setBlob(AllJavaTypes.FIELD_BINARY, new byte[]{1, 2, 3});
-        notEmpty.setObject(AllJavaTypes.FIELD_OBJECT, notEmpty);
-        notEmpty.setList(AllJavaTypes.FIELD_LIST, new RealmList<DynamicRealmObject>(notEmpty));
-        realm.commitTransaction();
-    }
-
-    /*
-     * Fields order test for Chained or Multi-Arguments Distinct()
-     *
-     * The idea is to interweave different values in 2's multiplier and 3's multiplier in a way that
-     * the outcome is different if the order of distinct* operations alternates. More numbers of
-     * fields can be constructed with the combination of multipliers in prime numbers such as 2, 3,
-     * and 5.
-     *
-     * An example is illustrated below.
-     *
-     * Object      : O1| O2| O3| O4| O5| O6
-     * indexString : A | A | B | B | A | A
-     * indexLong   : 1 | 1 | 1 | 2 | 2 | 2
-     */
-    private void populateForDistinctFieldsOrder(DynamicRealm realm, long numberOfBlocks) {
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfBlocks; i++) {
-            for (int j = 0; j < 6; j++) {
-                DynamicRealmObject obj = realm.createObject(AnnotationIndexTypes.CLASS_NAME);
-                obj.setString("indexString", (((j / 2) % 2) == 0) ? "A" : "B");
-                obj.setLong("indexLong", (j < 3) ? 1 : 2);
-            }
-        }
-        realm.commitTransaction();
-    }
-
-    @Test
-    public void distinct_invalidClassNames() {
-        String[] classNames = new String[]{null, "", "foo", "foo.bar"};
-        for (String className : classNames) {
-            try {
-                realm.distinct(className, "foo");
-                fail();
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_invalidFieldNames() {
-        String[] fieldNames = new String[]{null, "", "foo", "foo.bar"};
-        for (String fieldName : fieldNames) {
-            try {
-                realm.distinct(AnnotationIndexTypes.CLASS_NAME, fieldName);
-                fail();
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    // Realm.distinct(): requires indexing, and type = boolean, integer, date, string
-    @Test
-    public void distinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<DynamicRealmObject> distinctBool = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        assertEquals(2, distinctBool.size());
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<DynamicRealmObject> distinct = realm.distinct(AnnotationIndexTypes.CLASS_NAME, field);
-            assertEquals(field, numberOfBlocks, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.distinct(AnnotationIndexTypes.CLASS_NAME, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_invalidTypes() {
-        populateTestRealm();
-
-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
-            try {
-                realm.distinct(AllTypes.CLASS_NAME, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<DynamicRealmObject> distinctMulti = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
-        assertEquals(numberOfBlocks, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_switchedFieldsOrder() {
-        final long numberOfBlocks = 25;
-        populateForDistinctFieldsOrder(realm, numberOfBlocks);
-
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
-        RealmResults<DynamicRealmObject> distinctStringLong = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<DynamicRealmObject> distinctLongString = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(4, distinctStringLong.size());
-        assertEquals(4, distinctLongString.size());
-        assertEquals(distinctStringLong.size(), distinctLongString.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_emptyFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        // an empty string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // an empty string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // (String)null makes varargs a null array.
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two (String)null for first and varargs fields
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, (String)null, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, "", (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, (String)null, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two empty fields tests
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, "", "");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<DynamicRealmObject> distinctMulti = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(1, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_doesNotExistField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesFields() {
-        populateTestRealm();
-
-        try {
-            realm.distinct(AllTypes.CLASS_NAME, AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        try {
-            realm.distinct(AllJavaTypes.CLASS_NAME, AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
+        assertEquals(0, realm.where("Owner").count());
     }
 
     @Test
@@ -906,64 +511,6 @@ public void onChange() {
         });
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync() {
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(dynamicRealm, numberOfBlocks, numberOfObjects, false);
-
-        final RealmResults<DynamicRealmObject> distinctBool = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        final RealmResults<DynamicRealmObject> distinctLong = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        final RealmResults<DynamicRealmObject> distinctDate = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_DATE);
-        final RealmResults<DynamicRealmObject> distinctString = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_STRING);
-
-        final Runnable callbackDoneTask = new Runnable() {
-            final CountDownLatch signalTestFinished = new CountDownLatch(4);
-            @Override
-            public void run() {
-                signalTestFinished.countDown();
-                if (signalTestFinished.getCount() == 0) {
-                    dynamicRealm.close();
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        distinctBool.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(2, distinctBool.size());
-                callbackDoneTask.run();
-            }
-        });
-
-        distinctLong.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(numberOfBlocks, distinctLong.size());
-                callbackDoneTask.run();
-            }
-        });
-
-        distinctDate.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(numberOfBlocks, distinctDate.size());
-                callbackDoneTask.run();
-            }
-        });
-
-        distinctString.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(numberOfBlocks, distinctString.size());
-                callbackDoneTask.run();
-            }
-        });
-    }
-
     @Test
     @RunTestInLooperThread
     public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
similarity index 97%
rename from realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java
rename to realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
index 95d5797a34..1ba7760203 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.proxy;
+package io.realm;
 
 import android.os.Handler;
 import android.os.Message;
@@ -24,7 +24,7 @@
 /**
  * Handler decorator, to help intercept some messages before they are sent and received.
  */
-public abstract class HandlerProxy extends Handler {
+abstract class HandlerProxy extends Handler {
 
     private final HandlerController controller;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 416a022a5c..c4740faeb6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -43,7 +43,6 @@
 import io.realm.instrumentation.MockActivityManager;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.internal.log.RealmLog;
-import io.realm.proxy.HandlerProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 1d44baa256..6aec097eea 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -1171,71 +1171,90 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(0));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 2 Bytes
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(1));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 3 Boolean
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(2));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 4 Byte
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(3));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 5 Short
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(4));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 6 Integer
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(5));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 7 Long
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(6));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 8 Float
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(7));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 9 Double
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(8));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 10 Date
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(9));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
 
         realm.cancelTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index bedfed68d7..bfc07906a3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -35,7 +35,9 @@
 import io.realm.entities.pojo.InvalidRealmModel;
 import io.realm.entities.pojo.RealmModelWithRealmListOfRealmModel;
 import io.realm.entities.pojo.PojoWithRealmListOfRealmObject;
+import io.realm.entities.pojo.RealmModelWithRealmModelField;
 import io.realm.entities.pojo.RealmObjectWithRealmListOfRealmModel;
+import io.realm.entities.pojo.RealmObjectWithRealmModelField;
 import io.realm.exceptions.RealmException;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -342,5 +344,39 @@ public void realmObjectWithRealmListOfRealmModel() {
         assertEquals(10, all.first().getColumnRealmList().size());
         assertEquals(1, all.first().getColumnRealmList().first().columnLong);
     }
+
+    // Test the behaviour of a RealmModel, containing a RealmModel field
+    @Test
+    public void realmModelWithRealmModelField() {
+        RealmModelWithRealmModelField realmModelWithRealmModelField = new RealmModelWithRealmModelField();
+        AllTypesRealmModel allTypePojo = new AllTypesRealmModel();
+        allTypePojo.columnLong = 42;
+        realmModelWithRealmModelField.setAllTypesRealmModel(allTypePojo);
+
+        realm.beginTransaction();
+        realm.copyToRealm(realmModelWithRealmModelField);
+        realm.commitTransaction();
+
+        RealmResults<RealmModelWithRealmModelField> all = realm.where(RealmModelWithRealmModelField.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(42, all.first().getAllTypesRealmModel().columnLong);
+    }
+
+    // Test the behaviour of a RealmObject, containing a RealmModel field
+    @Test
+    public void realmObjectWithRealmModelField() {
+        RealmObjectWithRealmModelField realmObjectWithRealmModelField = new RealmObjectWithRealmModelField();
+        AllTypesRealmModel allTypePojo = new AllTypesRealmModel();
+        allTypePojo.columnLong = 42;
+        realmObjectWithRealmModelField.setAllTypesRealmModel(allTypePojo);
+
+        realm.beginTransaction();
+        realm.copyToRealm(realmObjectWithRealmModelField);
+        realm.commitTransaction();
+
+        RealmResults<RealmObjectWithRealmModelField> all = realm.where(RealmObjectWithRealmModelField.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(42, all.first().getAllTypesRealmModel().columnLong);
+    }
 }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 1bcde0b70d..6963b7ff1a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -608,6 +608,20 @@ public void renameField_toIllegalNameThrows() {
         schema.renameField(oldFieldName, newFieldName);
     }
 
+    @Test
+    public void renameField_withPrimaryKey() {
+        String fieldName = "foo";
+        schema.addField(fieldName, String.class, FieldAttribute.PRIMARY_KEY);
+        assertTrue(schema.hasField(fieldName));
+        assertTrue(schema.hasPrimaryKey());
+        assertTrue(schema.isPrimaryKey(fieldName));
+
+        schema.renameField(fieldName, "bar");
+        assertTrue(schema.hasPrimaryKey());
+
+        assertEquals("bar", schema.getPrimaryKey());
+    }
+
     @Test
     public void setGetClassName() {
         assertEquals("Dog", DOG_SCHEMA.getClassName());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
new file mode 100644
index 0000000000..d642764f0d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyRequiredAsBoxedByte;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedInteger;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedLong;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
+import io.realm.entities.PrimaryKeyRequiredAsString;
+import io.realm.objectid.NullPrimaryKey;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class RealmPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    /**
+     * Base parameters for testing null/not-null primary key value. The parameters are aligned in an
+     * order of 1) a test target class, 2) a primary key field class, 3) a primary Key value, 4) a
+     * secondary field class, and 5) a secondary field value, accommodating {@interface NullPrimaryKey}
+     * to condense unit tests.
+     */
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+                // 1) Test target class                  2) PK Class    3) PK value            4) 2nd Class  5) 2nd field value
+                {PrimaryKeyRequiredAsString.class,       String.class,  "424123",              String.class, "SomeSecondaryValue"},
+                {PrimaryKeyRequiredAsBoxedByte.class,    Byte.class,    Byte.valueOf("67"),    String.class, "This-Is-Second-One"},
+                {PrimaryKeyRequiredAsBoxedShort.class,   Short.class,   Short.valueOf("1729"), String.class, "AnyValueIsAccepted"},
+                {PrimaryKeyRequiredAsBoxedInteger.class, Integer.class, Integer.valueOf("19"), String.class, "PlayWithSeondFied!"},
+                {PrimaryKeyRequiredAsBoxedLong.class,    Long.class,    Long.valueOf("62914"), String.class, "Let's name a value"}
+        });
+    }
+
+    final private Class<? extends RealmObject> testClazz;
+    final private Class primaryKeyFieldType;
+    final private Object primaryKeyFieldValue;
+    final private Class secondaryFieldType;
+    final private Object secondaryFieldValue;
+
+    public RealmPrimaryKeyTests(Class<? extends RealmObject> testClazz, Class primaryKeyFieldType, Object primaryKeyFieldValue, Class secondaryFieldType, Object secondaryFieldValue) {
+        this.testClazz = testClazz;
+        this.primaryKeyFieldType = primaryKeyFieldType;
+        this.primaryKeyFieldValue = primaryKeyFieldValue;
+        this.secondaryFieldType = secondaryFieldType;
+        this.secondaryFieldValue = secondaryFieldValue;
+    }
+
+    // @PrimaryKey + @Required annotation accept not-null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealmOrUpdate_requiredPrimaryKey() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(primaryKeyFieldValue, secondaryFieldValue);
+        realm.beginTransaction();
+        realm.copyToRealmOrUpdate(obj);
+        realm.commitTransaction();
+
+        RealmResults results = realm.where(testClazz).findAll();
+        assertEquals(1, results.size());
+        assertEquals(primaryKeyFieldValue, ((NullPrimaryKey)results.first()).getId());
+        assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
+    }
+
+    // @PrimaryKey + @Required annotation does accept null as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        try {
+            RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
+            realm.beginTransaction();
+            realm.copyToRealmOrUpdate(obj);
+            fail("@PrimaryKey + @Required field cannot be null");
+        } catch (RuntimeException expected) {
+            if (testClazz.equals(PrimaryKeyRequiredAsString.class)) {
+                assertTrue(expected instanceof IllegalArgumentException);
+            } else {
+                assertTrue(expected instanceof NullPointerException);
+            }
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index b2172a7367..bef98fac91 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -30,6 +30,8 @@
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -51,7 +53,7 @@
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-                .schema(AllJavaTypes.class, Owner.class)
+                .schema(AllJavaTypes.class, Owner.class, PrimaryKeyAsString.class)
                 .build();
         Realm.getInstance(realmConfig).close(); // create Schema
         realm = DynamicRealm.getInstance(realmConfig);
@@ -68,9 +70,10 @@ public void tearDown() {
     @Test
     public void getAll() {
         Set<RealmObjectSchema> objectSchemas = realmSchema.getAll();
-        assertEquals(5, objectSchemas.size());
+        assertEquals(6, objectSchemas.size());
 
-        List<String> expectedTables = Arrays.asList(AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey");
+        List<String> expectedTables = Arrays.asList(
+                AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey", "PrimaryKeyAsString");
         for (RealmObjectSchema objectSchema : objectSchemas) {
             if (!expectedTables.contains(objectSchema.getClassName())) {
                 fail(objectSchema.getClassName() + " was not found");
@@ -139,6 +142,32 @@ public void rename_invalidArgumentThrows() {
         }
     }
 
+    @Test
+    public void rename_shouldChangeInfoInPKTable() {
+        final String NEW_NAME = "NewPrimaryKeyAsString";
+        assertTrue(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+        realmSchema.rename(PrimaryKeyAsString.CLASS_NAME, NEW_NAME);
+        assertFalse(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+        assertTrue(realmSchema.contains(NEW_NAME));
+        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass(NEW_NAME);
+
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
+
+        // Create an object with the old name, and the PK should not exist after created.
+        RealmObjectSchema oldObjectSchema = realmSchema.create(PrimaryKeyAsString.CLASS_NAME);
+        oldObjectSchema.addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
+
+        try {
+            // It should not have primary key anymore at this point
+            oldObjectSchema.getPrimaryKey();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        oldObjectSchema.addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, oldObjectSchema.getPrimaryKey());
+    }
+
     @Test
     public void remove() {
         realmSchema.remove(AllJavaTypes.CLASS_NAME);
@@ -178,4 +207,24 @@ public void remove_classWithReferencesThrows() {
         realmSchema.remove("Cat");
         assertFalse(realmSchema.contains("Cat"));
     }
+
+    @Test
+    public void remove_shouldRemoveInfoFromPKTable() {
+        assertTrue(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+        realmSchema.remove(PrimaryKeyAsString.CLASS_NAME);
+        assertFalse(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+
+        RealmObjectSchema objectSchema = realmSchema.create(PrimaryKeyAsString.CLASS_NAME);
+        objectSchema.addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
+
+        try {
+            // It should not have primary key anymore at this point
+            objectSchema.getPrimaryKey();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        objectSchema.addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index c0ff52cf09..760d809ad1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -60,7 +60,6 @@
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
-import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.Cat;
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
@@ -78,6 +77,11 @@
 import io.realm.entities.PrimaryKeyAsLong;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.PrimaryKeyMix;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedByte;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedInteger;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedLong;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
+import io.realm.entities.PrimaryKeyRequiredAsString;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
@@ -506,117 +510,6 @@ public void where_equalTo_requiredFieldWithNullArgument() {
         }
     }
 
-    @Test
-    public void allObjects() {
-        populateTestRealm();
-        RealmResults<AllTypes> resultList = realm.allObjects(AllTypes.class);
-        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
-    }
-
-    @Test
-    public void allObjectsSorted() {
-        populateTestRealm();
-        RealmResults<AllTypes> sortedList = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_STRING, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("test data 0", sortedList.first().getColumnString());
-
-        RealmResults<AllTypes> reverseList = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals("test data 0", reverseList.last().getColumnString());
-
-        try {
-            realm.allObjectsSorted(AllTypes.class, "invalid", Sort.ASCENDING);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void allObjectsSorted_singleField() {
-        populateTestRealm();
-        RealmResults<AllTypes> sortedList = realm.allObjectsSorted(AllTypes.class,
-                new String[]{AllTypes.FIELD_LONG},
-                new Sort[]{Sort.DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
-        assertEquals(0, sortedList.last().getColumnLong());
-    }
-
-    @Test
-    public void allObjectsSorted_twoFields() {
-        TestHelper.populateForMultiSort(realm);
-
-        RealmResults<AllTypes> results1 = realm.allObjectsSorted(AllTypes.class,
-                new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results1.size());
-
-        assertEquals("Adam", results1.get(0).getColumnString());
-        assertEquals(4, results1.get(0).getColumnLong());
-
-        assertEquals("Adam", results1.get(1).getColumnString());
-        assertEquals(5, results1.get(1).getColumnLong());
-
-        assertEquals("Brian", results1.get(2).getColumnString());
-        assertEquals(4, results1.get(2).getColumnLong());
-
-        RealmResults<AllTypes> results2 = realm.allObjectsSorted(AllTypes.class,
-                new String[]{AllTypes.FIELD_LONG, AllTypes.FIELD_STRING},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results2.size());
-
-        assertEquals("Adam", results2.get(0).getColumnString());
-        assertEquals(4, results2.get(0).getColumnLong());
-
-        assertEquals("Brian", results2.get(1).getColumnString());
-        assertEquals(4, results2.get(1).getColumnLong());
-
-        assertEquals("Adam", results2.get(2).getColumnString());
-        assertEquals(5, results2.get(2).getColumnLong());
-    }
-
-    @Test
-    public void allObjectsSorted_failures() {
-        // zero fields specified
-        try {
-            realm.allObjectsSorted(AllTypes.class, new String[]{}, new Sort[]{});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // number of fields and sorting orders don't match
-        try {
-            realm.allObjectsSorted(AllTypes.class,
-                    new String[]{AllTypes.FIELD_STRING},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // null is not allowed
-        try {
-            realm.allObjectsSorted(AllTypes.class, null, (Sort[]) null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            realm.allObjectsSorted(AllTypes.class, new String[]{AllTypes.FIELD_STRING}, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // non-existing field name
-        try {
-            realm.allObjectsSorted(AllTypes.class,
-                    new String[]{AllTypes.FIELD_STRING, "dont-exist"},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
     @Test
     public void beginTransaction() throws IOException {
         populateTestRealm();
@@ -654,7 +547,6 @@ public void nestedTransaction() {
         METHOD_CANCEL,
         METHOD_DELETE_TYPE,
         METHOD_DELETE_ALL,
-        METHOD_DISTINCT,
         METHOD_CREATE_OBJECT,
         METHOD_COPY_TO_REALM,
         METHOD_COPY_TO_REALM_OR_UPDATE,
@@ -691,9 +583,6 @@ public Boolean call() throws Exception {
                         case METHOD_DELETE_ALL:
                             realm.deleteAll();
                             break;
-                        case METHOD_DISTINCT:
-                            realm.distinct(AllTypesPrimaryKey.class, "columnLong");
-                            break;
                         case METHOD_CREATE_OBJECT:
                             realm.createObject(AllTypes.class);
                             break;
@@ -774,7 +663,7 @@ public void cancelTransaction() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.cancelTransaction();
-        assertEquals(TEST_DATA_SIZE, realm.allObjects(AllTypes.class).size());
+        assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
 
         try {
             realm.cancelTransaction();
@@ -796,7 +685,7 @@ public void executeTransaction_null() {
 
     @Test
     public void executeTransaction_success() {
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -804,14 +693,14 @@ public void execute(Realm realm) {
                 owner.setName("Owner");
             }
         });
-        assertEquals(1, realm.allObjects(Owner.class).size());
+        assertEquals(1, realm.where(Owner.class).count());
     }
 
     @Test
     public void executeTransaction_canceled() {
         final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
 
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
         try {
             realm.executeTransaction(new Realm.Transaction() {
                 @Override
@@ -826,12 +715,12 @@ public void execute(Realm realm) {
             //noinspection ThrowableResultOfMethodCallIgnored
             assertTrue(e == thrownException.get());
         }
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
     }
 
     @Test
     public void executeTransaction_cancelInsideClosureThrowsException() {
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         try {
             RealmLog.add(testLogger);
@@ -850,7 +739,7 @@ public void execute(Realm realm) {
         } finally {
             RealmLog.remove(testLogger);
         }
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
     }
 
     @Test
@@ -899,7 +788,7 @@ private void createAndTestFilename(String language, String fileName) {
         assertTrue(language, file.exists());
 
         Realm realm2 = Realm.getInstance(realmConfig);
-        Dog dog2 = realm2.allObjects(Dog.class).first();
+        Dog dog2 = realm2.where(Dog.class).findFirst();
         assertEquals(language, "Rex", dog2.getName());
         realm2.close();
     }
@@ -999,7 +888,7 @@ public void unicodeStrings() {
             stringOnly.setChars(test_char);
             realm.commitTransaction();
 
-            realm.allObjects(StringOnly.class).get(0).getChars();
+            realm.where(StringOnly.class).findFirst().getChars();
 
             realm.beginTransaction();
             realm.delete(StringOnly.class);
@@ -1067,7 +956,7 @@ public void getInstance_referenceCounting_doubleClose() {
         realm = Realm.getInstance(configFactory.createConfiguration());
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
-        RealmResults<AllTypes> queryResult = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> queryResult = realm.where(AllTypes.class).findAll();
         assertEquals(allTypes, queryResult.get(0));
         realm.commitTransaction();
         realm.close(); // This might not close the Realm if the reference count is wrong
@@ -1108,7 +997,7 @@ public void writeCopyTo() throws IOException {
         try {
             // Contents is copied too
             realm2 = Realm.getInstance(configB);
-            RealmResults<AllTypes> results = realm2.allObjects(AllTypes.class);
+            RealmResults<AllTypes> results = realm2.where(AllTypes.class).findAll();
             assertEquals(1, results.size());
             assertEquals("Hello World", results.first().getColumnString());
         } finally {
@@ -1281,7 +1170,7 @@ public void copyToRealm_cyclicObjectReferences() {
 
         assertEquals("One", realmObject.getName());
         assertEquals("Two", realmObject.getObject().getName());
-        assertEquals(2, realm.allObjects(CyclicType.class).size());
+        assertEquals(2, realm.where(CyclicType.class).count());
     }
 
     @Test
@@ -1298,7 +1187,7 @@ public void copyToRealm_cyclicListReferences() {
         realm.commitTransaction();
 
         assertEquals("One", realmObject.getName());
-        assertEquals(2, realm.allObjects(CyclicType.class).size());
+        assertEquals(2, realm.where(CyclicType.class).count());
     }
 
     // Check that if a field has a null value it gets converted to the default value for that type
@@ -1591,7 +1480,7 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(2, realm.allObjects(PrimaryKeyAsLong.class).size());
+        assertEquals(2, realm.where(PrimaryKeyAsLong.class).count());
     }
 
     @Test
@@ -1627,8 +1516,8 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
 
         // Check that the the only element has all its properties updated
         assertEquals("Bar", obj.getColumnString());
@@ -1663,7 +1552,7 @@ public void copyToRealmOrUpdate_cyclicObject() {
         realm.copyToRealmOrUpdate(oneCyclicType);
         realm.commitTransaction();
 
-        assertEquals(2, realm.allObjects(CyclicTypePrimaryKey.class).size());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
         assertEquals("Three", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getName());
     }
 
@@ -1692,9 +1581,9 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
 
-        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertNull(obj.getColumnString());
         assertEquals(1, obj.getColumnLong());
         assertEquals(0.0F, obj.getColumnFloat(), 0);
@@ -1727,8 +1616,8 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals(4, realm.allObjects(DogPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        assertEquals(4, realm.where(DogPrimaryKey.class).count());
     }
 
     @Test
@@ -1782,8 +1671,8 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
-        assertEquals("Baz", realm.allObjects(PrimaryKeyAsLong.class).first().getName());
+        assertEquals(1, realm.where(PrimaryKeyAsLong.class).count());
+        assertEquals("Baz", realm.where(PrimaryKeyAsLong.class).findFirst().getName());
     }
 
     // Tests that a collection of objects with references all gets copied.
@@ -1803,8 +1692,8 @@ public void copyToRealmOrUpdate_iterableChildObjects() {
         realm.copyToRealmOrUpdate(Arrays.asList(allTypes1, allTypes2));
         realm.commitTransaction();
 
-        assertEquals(2, realm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals(1, realm.allObjects(DogPrimaryKey.class).size());
+        assertEquals(2, realm.where(AllTypesPrimaryKey.class).count());
+        assertEquals(1, realm.where(DogPrimaryKey.class).count());
     }
 
     @Test
@@ -2130,18 +2019,18 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
         try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
 
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (RealmException expected) {}
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (RealmException expected) {}
+        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (IllegalStateException expected) {}
+        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (IllegalStateException expected) {}
         try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);       fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
 
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (RealmException expected) {}
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (RealmException expected) {}
+        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (IllegalStateException expected) {}
+        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (IllegalStateException expected) {}
         try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);          fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (RealmException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (RealmException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (IllegalStateException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
     }
 
@@ -2216,6 +2105,172 @@ public void createObject_cannotCreateDynamicRealmObject() {
         }
     }
 
+    @Test
+    public void createObjectWithPrimaryKey() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 42);
+        assertEquals(1, realm.where(AllJavaTypes.class).count());
+        assertEquals(42, obj.getFieldLong());
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_noPrimaryKeyField() {
+        realm.beginTransaction();
+        try {
+            realm.createObject(AllTypes.class, 42);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_wrongValueType() {
+        realm.beginTransaction();
+        try {
+            realm.createObject(AllJavaTypes.class, "fortyTwo");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_valueAlreadyExists() {
+        realm.beginTransaction();
+        realm.createObject(AllJavaTypes.class, 42);
+        try {
+            realm.createObject(AllJavaTypes.class, 42);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_null() {
+        // Byte
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedByte primaryKeyAsBoxedByte= realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedByte.class).count());
+        assertNull(primaryKeyAsBoxedByte.getId());
+
+        // Short
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedShort primaryKeyAsBoxedShort = realm.createObject(PrimaryKeyAsBoxedShort.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedShort.class).count());
+        assertNull(primaryKeyAsBoxedShort.getId());
+
+        // Integer
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedInteger primaryKeyAsBoxedInteger = realm.createObject(PrimaryKeyAsBoxedInteger.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedInteger.class).count());
+        assertNull(primaryKeyAsBoxedInteger.getId());
+
+        // Long
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedLong primaryKeyAsBoxedLong = realm.createObject(PrimaryKeyAsBoxedLong.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedLong.class).count());
+        assertNull(primaryKeyAsBoxedLong.getId());
+
+        // String
+        realm.beginTransaction();
+        PrimaryKeyAsString primaryKeyAsString = realm.createObject(PrimaryKeyAsString.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsString.class).count());
+        assertNull(primaryKeyAsString.getName());
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_nullOnRequired() {
+        realm.beginTransaction();
+
+        // Byte
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedByte.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Short
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedShort.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Integer
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedInteger.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Long
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedLong.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // String
+        try {
+            realm.createObject(PrimaryKeyRequiredAsString.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        realm.cancelTransaction();
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_nullDuplicated() {
+        realm.beginTransaction();
+
+        // Byte
+        realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // Short
+        realm.createObject(PrimaryKeyAsBoxedShort.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedShort.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // Integer
+        realm.createObject(PrimaryKeyAsBoxedInteger.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedInteger.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // Long
+        realm.createObject(PrimaryKeyAsBoxedLong.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedLong.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // String
+        realm.createObject(PrimaryKeyAsString.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsString.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        realm.cancelTransaction();
+    }
+
     // Test close Realm in another thread different from where it is created.
     @Test
     public void close_differentThread() throws InterruptedException {
@@ -2405,253 +2460,6 @@ public void onChange() {
         assertTrue(typeListenerWasCalled.get());
     }
 
-    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
-            for (int j = 0; j < numberOfBlocks; j++) {
-                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
-                obj.setIndexBoolean(j % 2 == 0);
-                obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * (long) j));
-                obj.setIndexString(withNull ? null : "Test " + j);
-                obj.setNotIndexBoolean(j % 2 == 0);
-                obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * (long) j));
-                obj.setNotIndexString(withNull ? null : "Test " + j);
-            }
-        }
-        realm.commitTransaction();
-    }
-
-    private void populateForDistinctInvalidTypesLinked(Realm realm) {
-        realm.beginTransaction();
-        AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        notEmpty.setFieldObject(notEmpty);
-        notEmpty.setFieldList(new RealmList<AllJavaTypes>(notEmpty));
-        realm.copyToRealm(notEmpty);
-        realm.commitTransaction();
-    }
-
-    // Realm.distinct(): requires indexing, and type = boolean, integer, date, string
-    @Test
-    public void distinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        assertEquals(2, distinctBool.size());
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.distinct(AnnotationIndexTypes.class, field);
-            assertEquals(field, numberOfBlocks, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.distinct(AnnotationIndexTypes.class, field);
-            assertEquals(field, 1, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_notIndexedFieldsThrows() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.distinct(AnnotationIndexTypes.class, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_unknownFieldThrows() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-        thrown.expect(IllegalArgumentException.class);
-
-        realm.distinct(AnnotationIndexTypes.class, "doesNotExist");
-    }
-
-    @Test
-    public void distinct_invalidTypeThrows() {
-        populateTestRealm();
-
-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
-            try {
-                realm.distinct(AllTypes.class, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> distinctMulti = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
-        assertEquals(numberOfBlocks, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_switchedFieldsOrder() {
-        final long numberOfBlocks = 25;
-        TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
-
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
-        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<AnnotationIndexTypes> distinctLongString = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(4, distinctStringLong.size());
-        assertEquals(4, distinctLongString.size());
-        assertEquals(distinctStringLong.size(), distinctLongString.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_emptyFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        // an empty string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // an empty string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // (String)null makes varargs a null array.
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two (String)null for first and varargs fields
-        try {
-            realm.distinct(AnnotationIndexTypes.class, (String)null, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.class, "", (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.class, (String)null, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two empty fields tests
-        try {
-            realm.distinct(AnnotationIndexTypes.class, "", "");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<AnnotationIndexTypes> distinctMulti = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(1, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_doesNotExistField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesFields() {
-        populateTestRealm();
-
-        try {
-            realm.distinct(AllTypes.class, AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        try {
-            realm.distinct(AllJavaTypes.class, AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
     @Test
     public void isInTransaction() {
         assertFalse(realm.isInTransaction());
@@ -2964,7 +2772,7 @@ public void copyFromRealm_list_invalidListThrows() {
 
     @Test
     public void copyFromRealm_list_invalidDepthThrows() {
-        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         thrown.expect(IllegalArgumentException.class);
         realm.copyFromRealm(results, -1);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
new file mode 100644
index 0000000000..20979c2518
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedByte extends RealmObject implements NullPrimaryKey<Byte, String> {
+
+    @PrimaryKey
+    @Required
+    private Byte id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedByte() {}
+    public PrimaryKeyRequiredAsBoxedByte(Byte id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Byte getId() {
+        return id;
+    }
+
+    public void setId(Byte id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
new file mode 100644
index 0000000000..bb8ecfbf83
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedInteger extends RealmObject implements NullPrimaryKey<Integer, String> {
+
+    @PrimaryKey
+    @Required
+    private Integer id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedInteger() {}
+    public PrimaryKeyRequiredAsBoxedInteger(Integer id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Integer getId() {
+        return id;
+    }
+
+    public void setId(Integer id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
new file mode 100644
index 0000000000..fe526e125a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedLong extends RealmObject implements NullPrimaryKey<Long, String> {
+
+    @PrimaryKey
+    @Required
+    private Long id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedLong() {}
+    public PrimaryKeyRequiredAsBoxedLong(Long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
new file mode 100644
index 0000000000..3c14549a52
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedShort extends RealmObject implements NullPrimaryKey<Short, String> {
+
+    @PrimaryKey
+    @Required
+    private Short id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedShort() {}
+    public PrimaryKeyRequiredAsBoxedShort(Short id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Short getId() {
+        return id;
+    }
+
+    public void setId(Short id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
new file mode 100644
index 0000000000..4daa2d8fe6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsString extends RealmObject implements NullPrimaryKey<String, String> {
+
+    @PrimaryKey
+    @Required
+    private String id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsString(){}
+    public PrimaryKeyRequiredAsString(String id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmModelField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmModelField.java
new file mode 100644
index 0000000000..11c26b9cac
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmModelField.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class RealmModelWithRealmModelField implements RealmModel {
+    private AllTypesRealmModel allTypesRealmModel;
+
+    public AllTypesRealmModel getAllTypesRealmModel() {
+        return allTypesRealmModel;
+    }
+
+    public void setAllTypesRealmModel(AllTypesRealmModel allTypesRealmModel) {
+        this.allTypesRealmModel = allTypesRealmModel;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
new file mode 100644
index 0000000000..71be5a1a07
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmObject;
+
+public class RealmObjectWithRealmModelField extends RealmObject{
+    private AllTypesRealmModel allTypesRealmModel;
+
+    public AllTypesRealmModel getAllTypesRealmModel() {
+        return allTypesRealmModel;
+    }
+
+    public void setAllTypesRealmModel(AllTypesRealmModel allTypesRealmModel) {
+        this.allTypesRealmModel = allTypesRealmModel;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 2714cd7f90..739107ee15 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -47,7 +47,7 @@
  * @see io.realm.Realm
  * @see io.realm.DynamicRealm
  */
-public abstract class BaseRealm implements Closeable {
+abstract class BaseRealm implements Closeable {
     protected static final long UNVERSIONED = -1;
     private static final String INCORRECT_THREAD_CLOSE_MESSAGE = "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
     private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index dbaccbf0f0..5a37ee6a5b 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -88,8 +88,10 @@ public DynamicRealmObject createObject(String className) {
      *
      * @return the new object. All fields will have default values for their type, except for the
      * primary key field which will have the provided value.
-     * @throws IllegalArgumentException if the primary key value is of the wrong type.
-     * @throws IllegalStateException if the class doesn't have a primary key defined.
+     * @throws RealmException if object could not be created due to the primary key being invalid.
+     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     *                                  expectd value.
      */
     public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
         Table table = schema.getTable(className);
@@ -165,28 +167,17 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Gets all objects of a specific class name.
-     *
-     * @param className the Class to get objects of.
-     * @return a {@link RealmResults} list containing the objects. If no results where found, an empty list
-     * will be returned.
-     * @see io.realm.RealmResults
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll()} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> allObjects(String className) {
         return where(className).findAll();
     }
 
     /**
-     * Gets all objects of a specific class name sorted by a field. If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of objects
-     * instead.
-     *
-     * @param className the class to get all objects from.
-     * @param fieldName the field name to sort by.
-     * @param sortOrder how to sort the results.
-     * @return a sorted {@link RealmResults} containing the objects.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName, sortOrder)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName, Sort sortOrder) {
         checkIfValid();
         Table table = schema.getTable(className);
@@ -201,19 +192,9 @@ public void executeTransaction(Transaction transaction) {
 
 
     /**
-     * Gets all objects of a specific class name sorted by two specific field names.  If no objects exist,
-     * the returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number
-     * of objects instead.
-     *
-     * @param className the class to get all objects from.
-     * @param fieldName1 the first field name to sort by.
-     * @param sortOrder1 how to sort the first field.
-     * @param fieldName2 the second field name to sort by.
-     * @param sortOrder2 how to sort the second field.
-     * @return a sorted {@link RealmResults} containing the objects. If no results where found an empty list
-     * is returned.
-     * @throws java.lang.IllegalArgumentException if a field name used for sorting does not exist.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName1,
                                                                     Sort sortOrder1, String fieldName2,
                                                                     Sort sortOrder2) {
@@ -222,17 +203,9 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Gets all objects of a specific class name sorted by multiple fields.  If no objects exist, the
-     * returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of
-     * objects instead.
-     *
-     * @param className the class to get all objects from.
-     * @param sortOrders sort ascending if Sort.ASCENDING, sort descending if Sort.DESCENDING.
-     * @param fieldNames an array of field names to sort objects by.
-     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.
-     * @return A sorted {@link RealmResults} containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldNames[], sortOrders[])} instead.
      */
+    @Deprecated
     @SuppressWarnings("unchecked")
     public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldNames[], Sort sortOrders[]) {
         checkAllObjectsSortedParameters(fieldNames, sortOrders);
@@ -253,15 +226,9 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     *
-     * @param className the Class to get objects of.
-     * @param fieldName the field name.
-     * @return A non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(fieldName)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> distinct(String className, String fieldName) {
         checkIfValid();
         Table table = schema.getTable(className);
@@ -271,36 +238,18 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     * This method is only available from a Looper thread.
-     *
-     * @param className the Class to get objects of.
-     * @param fieldName the field name.
-     * @return immediately a {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     * query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).distinctAsync(fieldName)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> distinctAsync(String className, String fieldName) {
         checkIfValid();
         return where(className).distinctAsync(fieldName);
     }
 
     /**
-     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
-     * given, all unique combinations of values in the fields will be returned. In case of multiple
-     * matches, it is undefined which object is returned. Unless the result is sorted, then the
-     * first object will be returned.
-     *
-     * @param className the Class to get objects of.
-     * @param firstFieldName first field name to use when finding distinct objects.
-     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     * is an unsupported type, or points to a linked field.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(firstFieldName, remainingFieldNames)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> distinct(String className, String firstFieldName, String... remainingFieldNames) {
         checkIfValid();
         return where(className).distinct(firstFieldName, remainingFieldNames);
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 160d38dcaa..5b4185f188 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -43,7 +43,7 @@
 /**
  * Centralises all Handler callbacks, including updating async queries and refreshing the Realm.
  */
-public final class HandlerController implements Handler.Callback {
+final class HandlerController implements Handler.Callback {
 
     static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
     static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 2f63c38e95..f2e8fc070d 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -350,8 +350,8 @@ private static void initializeRealm(Realm realm) {
         for (int i = 0; i < json.length(); i++) {
             try {
                 configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
-            } catch (Exception e) {
-                throw new RealmException("Could not map Json", e);
+            } catch (JSONException e) {
+                throw new RealmException("Could not map JSON", e);
             }
         }
     }
@@ -378,8 +378,8 @@ private static void initializeRealm(Realm realm) {
         for (int i = 0; i < json.length(); i++) {
             try {
                 configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
-            } catch (Exception e) {
-                throw new RealmException("Could not map Json", e);
+            } catch (JSONException e) {
+                throw new RealmException("Could not map JSON", e);
             }
         }
     }
@@ -402,7 +402,7 @@ private static void initializeRealm(Realm realm) {
         JSONArray arr;
         try {
             arr = new JSONArray(json);
-        } catch (Exception e) {
+        } catch (JSONException e) {
             throw new RealmException("Could not create JSON array from string", e);
         }
 
@@ -526,8 +526,8 @@ private static void initializeRealm(Realm realm) {
 
         try {
             return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
-        } catch (Exception e) {
-            throw new RealmException("Could not map Json", e);
+        } catch (JSONException e) {
+            throw new RealmException("Could not map JSON", e);
         }
     }
 
@@ -555,7 +555,7 @@ private static void initializeRealm(Realm realm) {
             handlerController.addToRealmObjects(realmObject);
             return realmObject;
         } catch (JSONException e) {
-            throw new RealmException("Could not map Json", e);
+            throw new RealmException("Could not map JSON", e);
         }
     }
 
@@ -578,7 +578,7 @@ private static void initializeRealm(Realm realm) {
         JSONObject obj;
         try {
             obj = new JSONObject(json);
-        } catch (Exception e) {
+        } catch (JSONException e) {
             throw new RealmException("Could not create Json object from string", e);
         }
 
@@ -609,7 +609,7 @@ private static void initializeRealm(Realm realm) {
         JSONObject obj;
         try {
             obj = new JSONObject(json);
-        } catch (Exception e) {
+        } catch (JSONException e) {
             throw new RealmException("Could not create Json object from string", e);
         }
 
@@ -719,16 +719,20 @@ private Scanner getFullStringScanner(InputStream in) {
     }
 
     /**
-     * Creates a new object inside the Realm with the Primary key value initially set.
+     * Instantiates and adds a new object to the Realm with the primary key value already set.
+     *
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
      *
      * @param clazz the Class of the object to create.
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
-     * @throws RealmException if object could not be created.
+     * @throws RealmException if object could not be created due to the primary key being invalid.
+     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     *                                  expected value.
      */
-    <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
+    public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
         Table table = getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
         return get(clazz, rowIndex);
@@ -951,27 +955,17 @@ boolean contains(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * Gets all objects of a specific Class. If no objects exist, the returned RealmResults will not be {@code null}.
-     * The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @return a RealmResult list containing the objects.
-     * @see io.realm.RealmResults
+     * DEPRECATED: Use {@code realm.where(clazz).findAll()} instead.
      */
+    @Deprecated
     public <E extends RealmModel> RealmResults<E> allObjects(Class<E> clazz) {
         return where(clazz).findAll();
     }
 
     /**
-     * Get all objects of a specific Class sorted by a field. If no objects exist, the returned {@link RealmResults}
-     * will not be {@code null}. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name to sort by.
-     * @param sortOrder how to sort the results.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName, sortOrder)} instead.
      */
+    @Deprecated
     public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                                     Sort sortOrder) {
         checkIfValid();
@@ -987,17 +981,9 @@ boolean contains(Class<? extends RealmModel> clazz) {
 
 
     /**
-     * Gets all objects of a specific class sorted by two specific field names.  If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the class ti get objects of.
-     * @param fieldName1 first field name to sort by.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name to sort by.
-     * @param sortOrder2 sort order for second field.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
      */
+    @Deprecated
     public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                     Sort sortOrder1, String fieldName2,
                                                                     Sort sortOrder2) {
@@ -1006,19 +992,10 @@ boolean contains(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * Gets all objects of a specific class sorted by two specific field names.  If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the class ti get objects of.
-     * @param fieldName1 first field name to sort by.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name to sort by.
-     * @param sortOrder2 sort order for second field.
-     * @param fieldName3 third field name to sort by.
-     * @param sortOrder3 sort order for third field.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2, fieldName3, sortOrder3)}
+     * instead.
      */
+    @Deprecated
     public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                     Sort sortOrder1,
                                                                     String fieldName2, Sort sortOrder2,
@@ -1028,16 +1005,9 @@ boolean contains(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * Gets all objects of a specific Class sorted by multiple fields. If no objects exist, the returned
-     * {@link RealmResults} will not be null. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @param sortOrders sort ascending if Sort.ASCENDING, sort descending if Sort.DESCENDING.
-     * @param fieldNames an array of field names to sort objects by. The objects are first sorted by fieldNames[0], then
-     *                   by fieldNames[1] and so forth.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldNames[], sortOrders[])} instead.
      */
+    @Deprecated
     @SuppressWarnings("unchecked")
     public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                                     Sort sortOrders[]) {
@@ -1049,15 +1019,9 @@ boolean contains(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code realm.where(clazz).distinct(fieldName)} instead.
      */
+    @Deprecated
     public <E extends RealmModel> RealmResults<E> distinct(Class<E> clazz, String fieldName) {
         checkIfValid();
         Table table = schema.getTable(clazz);
@@ -1067,36 +1031,18 @@ boolean contains(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     * This method is only available from a Looper thread.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name.
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     *         {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     *         query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     *         is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code realm.where(clazz).distinctAsync(fieldName)} instead.
      */
+    @Deprecated
     public <E extends RealmModel> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
         checkIfValid();
         return where(clazz).distinctAsync(fieldName);
     }
 
     /**
-     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
-     * given, all unique combinations of values in the fields will be returned. In case of multiple
-     * matches, it is undefined which object is returned. Unless the result is sorted, then the
-     * first object will be returned.
-     *
-     * @param clazz the Class to get objects of.
-     * @param firstFieldName first field name to use when finding distinct objects.
-     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     *         is an unsupported type, or points to a linked field.
+     * DEPRECATED: Use {@code realm.where(clazz).distinct(firstFieldName, remainingFieldNames)} instead.
      */
+    @Deprecated
     public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String firstFieldName, String... remainingFieldNames) {
         checkIfValid();
         return where(clazz).distinct(firstFieldName, remainingFieldNames);
@@ -1527,7 +1473,7 @@ static String getCanonicalPath(File realmFile) {
         try {
             return realmFile.getCanonicalPath();
         } catch (IOException e) {
-            throw new RealmException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
+            throw new RealmIOException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index df1ec5987d..3f6492f453 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -25,11 +25,11 @@
  * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
  * caller's thread callback).
  */
-public class RealmAsyncTask {
+public final class RealmAsyncTask {
     private final Future<?> pendingQuery;
     private volatile boolean isCancelled = false;
 
-    public RealmAsyncTask(Future<?> pendingQuery) {
+    RealmAsyncTask(Future<?> pendingQuery) {
         this.pendingQuery = pendingQuery;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 991f596000..f21b268d2f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -30,7 +30,7 @@
  * One {@link RealmCache} is created for each {@link RealmConfiguration}, and it caches all the {@link Realm} and
  * {@link DynamicRealm} instances which are created from the same {@link RealmConfiguration}.
  */
-class RealmCache {
+final class RealmCache {
 
     interface Callback {
         void onResult(int count);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 8672d10f26..89d723eeb7 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -54,7 +54,7 @@
  * - It is saved in Context.getFilesDir()
  * - It has its schema version set to 0.
  */
-public class RealmConfiguration {
+public final class RealmConfiguration {
 
     public static final String DEFAULT_REALM_NAME = "default.realm";
     public static final int KEY_LENGTH = 64;
@@ -311,7 +311,7 @@ private static synchronized boolean isRxJavaAvailable() {
     /**
      * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
      */
-    public static class Builder {
+    public static final class Builder {
         private File folder;
         private String fileName;
         private byte[] key;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index f5f93f919b..c7d66424d0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -927,9 +927,9 @@ public void set(E e) {
 
         /**
          * Adding a new object to the RealmList. If the object is not already manage by Realm it will be transparently
-         * copied using {@link Realm#copyToRealmOrUpdate(RealmObject)}
+         * copied using {@link Realm#copyToRealmOrUpdate(RealmModel)}
          *
-         * @see #add(RealmObject)
+         * @see #add(RealmModel)
          */
         public void add(E e) {
             realm.checkIfValid();
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 3697674bcf..5366e338c6 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -89,7 +89,7 @@ public final void removeFromRealm() {
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      * @see #isValid()
      */
-    public void deleteFromRealm() {
+    public final void deleteFromRealm() {
         deleteFromRealm(this);
     }
     
@@ -327,7 +327,7 @@ public final void removeChangeListeners() {
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public <E extends RealmObject> Observable<E> asObservable() {
+    public final <E extends RealmObject> Observable<E> asObservable() {
         return (Observable<E>) RealmObject.asObservable(this);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 2fcdea4c90..7a3d006452 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -221,6 +221,9 @@ public RealmObjectSchema renameField(String currentFieldName, String newFieldNam
         checkFieldNameIsAvailable(newFieldName);
         long columnIndex = getColumnIndex(currentFieldName);
         table.renameColumn(columnIndex, newFieldName);
+
+        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
+
         return this;
     }
 
@@ -672,7 +675,7 @@ public FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
         }
     }
 
-    static class DynamicColumnMap implements Map<String, Long> {
+    static final class DynamicColumnMap implements Map<String, Long> {
         private final Table table;
 
         public DynamicColumnMap(Table table) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index bd23a7cce0..0e2596940b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -59,7 +59,7 @@
  * @see Realm#where(Class)
  * @see RealmResults#where()
  */
-public class RealmQuery<E extends RealmModel> {
+public final class RealmQuery<E extends RealmModel> {
 
     private BaseRealm realm;
     private Class<E> clazz;
@@ -1844,22 +1844,9 @@ public Long call() throws Exception {
     }
 
     /**
-     * Finds all objects that fulfill the query conditions and sorted by specific field names in
-     * ascending order.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName1 first field name
-     * @param sortOrder1 sort order for first field
-     * @param fieldName2 second field name
-     * @param sortOrder2 sort order for second field
-     * @param fieldName3 third field names
-     * @param sortOrder3 sort order for third field
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
-     * objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@link #findAllSorted(String[], Sort[])}  instead.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
                                    String fieldName2, Sort sortOrder2,
                                    String fieldName3, Sort sortOrder3) {
@@ -1868,14 +1855,9 @@ public Long call() throws Exception {
     }
 
     /**
-     * Similar to {@link #findAllSorted(String, Sort, String, Sort, String, Sort)} but
-     * runs asynchronously on a worker thread.
-     * This method is only available from a Looper thread.
-     *
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@link #findAllSortedAsync(String[], Sort[])}  instead.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
                                               String fieldName2, Sort sortOrder2,
                                               String fieldName3, Sort sortOrder3) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 7c3b1dc00c..aca535075f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -130,6 +130,10 @@ public void remove(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
         String internalTableName = TABLE_PREFIX + className;
         checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
+        Table table = getTable(className);
+        if (table.hasPrimaryKey()) {
+            table.setPrimaryKey(null);
+        }
         transaction.removeTable(internalTableName);
     }
 
@@ -149,8 +153,23 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
         if (transaction.hasTable(newInternalName)) {
             throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
         }
+
+        // Check if there is a primary key defined for the old class.
+        Table oldTable = getTable(oldClassName);
+        String pkField = null;
+        if (oldTable.hasPrimaryKey()) {
+            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
+            oldTable.setPrimaryKey(null);
+        }
+
         transaction.renameTable(oldInternalName, newInternalName);
         Table table = transaction.getTable(newInternalName);
+
+        // Set the primary key for the new class if necessary
+        if (pkField != null) {
+            table.setPrimaryKey(pkField);
+        }
+
         RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
         return new RealmObjectSchema(realm, table, columnIndices);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
index f726575adf..e75cbbad5c 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
@@ -23,7 +23,7 @@
  * RealmError should never be caught or ignored. By doing so, the Realm could possibly get corrupted.
  */
 @Keep
-public class RealmError extends Error {
+public final class RealmError extends Error {
     public RealmError(String detailMessage) {
         super(detailMessage);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
index 354e2ce5f0..5cd20f9bff 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
@@ -22,7 +22,7 @@
  * RealmException is Realm specific exceptions.
  */
 @Keep
-public class RealmException extends RuntimeException {
+public final class RealmException extends RuntimeException {
 
     public RealmException(String detailMessage) {
         super(detailMessage);
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
index 3d59ed049e..845093fbc7 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
@@ -22,7 +22,7 @@
  * Class for reporting problems with Realm files.
  */
 @Keep
-public class RealmIOException extends RuntimeException {
+public final class RealmIOException extends RuntimeException {
 
     public RealmIOException(Throwable cause) {
         super(cause);
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
index d1093d6313..cfb7e50fb0 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
@@ -21,7 +21,7 @@
 import io.realm.internal.Keep;
 
 @Keep
-public class RealmMigrationNeededException extends RuntimeException {
+public final class RealmMigrationNeededException extends RuntimeException {
 
     private final String canonicalRealmPath;
 
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
index e24a380ba2..151bf264be 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
@@ -24,7 +24,7 @@
  * @see io.realm.annotations.PrimaryKey
  */
 @Keep
-public class RealmPrimaryKeyConstraintException extends RuntimeException {
+public final class RealmPrimaryKeyConstraintException extends RuntimeException {
     public RealmPrimaryKeyConstraintException(String message) {
         super(message);
     }
