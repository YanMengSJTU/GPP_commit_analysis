diff --git a/CHANGELOG.md b/CHANGELOG.md
index cd6f6deb72..4eb2c28380 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -29,6 +29,7 @@
 ### Bug Fixes
 
 * Throw `IllegalArgumentException` instead of `IllegalStateException` when calling string/binary data setters if the data length exceeds the limit.
+* Exposing a `RealmConfiguration` that allows a user to open the backup Realm after the client reset (#4759).
 
 ### Internal
 
diff --git a/Jenkinsfile b/Jenkinsfile
index dc74785a4d..84261d4ceb 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -6,106 +6,118 @@ def buildSuccess = false
 def rosContainer
 try {
   node('android') {
-    timeout(time: 1, unit: 'HOURS') {
+    timeout(time: 90, unit: 'MINUTES') {
       // Allocate a custom workspace to avoid having % in the path (it breaks ld)
       ws('/tmp/realm-java') {
-	stage('SCM') {
-	  checkout([
-		     $class: 'GitSCM',
-		    branches: scm.branches,
-		    gitTool: 'native git',
-		    extensions: scm.extensions + [
-		      [$class: 'CleanCheckout'],
-		      [$class: 'SubmoduleOption', recursiveSubmodules: true]
-		    ],
-		    userRemoteConfigs: scm.userRemoteConfigs
-		   ])
-	}
-
-	def buildEnv
-	def rosEnv
-	stage('Docker build') {
-	  // Docker image for build
-	  buildEnv = docker.build 'realm-java:snapshot'
-	  // Docker image for testing Realm Object Server
-	  def dependProperties = readProperties file: 'dependencies.list'
-	  def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
-	  rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
-	}
-
-	rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
-
-	try {
-          buildEnv.inside("-e HOME=/tmp " +
-			  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
-			  "--privileged " +
-			  "-v /dev/bus/usb:/dev/bus/usb " +
-			  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
-			  "-v ${env.HOME}/.android:/tmp/.android " +
-			  "-v ${env.HOME}/ccache:/tmp/.ccache " +
-			  "--network container:${rosContainer.id}") {
-            stage('JVM tests') {
-              try {
-                withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
-                  sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG}"
+        stage('SCM') {
+          checkout([
+                 $class: 'GitSCM',
+                branches: scm.branches,
+                gitTool: 'native git',
+                extensions: scm.extensions + [
+                  [$class: 'CleanCheckout'],
+                  [$class: 'SubmoduleOption', recursiveSubmodules: true]
+                ],
+                userRemoteConfigs: scm.userRemoteConfigs
+               ])
+        }
+
+        // Toggles for PR vs. Master builds.
+        // For PR's, we just build for arm-v7a and run unit tests for the ObjectServer variant
+        // A full build is done on `master`.
+        // TODO Once Android emulators are available on all nodes, we can switch to x86 builds
+        // on PR's for even more throughput.
+        def ABIs = ""
+        def instrumentationTestTarget = "connectedAndroidTest"
+        if (!['master'].contains(env.BRANCH_NAME)) {
+            ABIs = "armeabi-v7a"
+            instrumentationTestTarget = "connectedObjectServerDebugAndroidTest" // Run in debug more for better error reporting
+        }
+
+        def buildEnv
+        def rosEnv
+        stage('Docker build') {
+          // Docker image for build
+          buildEnv = docker.build 'realm-java:snapshot'
+          // Docker image for testing Realm Object Server
+          def dependProperties = readProperties file: 'dependencies.list'
+          def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
+          rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
+        }
+
+	    rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
+
+        try {
+              buildEnv.inside("-e HOME=/tmp " +
+                  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
+                  "--privileged " +
+                  "-v /dev/bus/usb:/dev/bus/usb " +
+                  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
+                  "-v ${env.HOME}/.android:/tmp/.android " +
+                  "-v ${env.HOME}/ccache:/tmp/.ccache " +
+                  "--network container:${rosContainer.id}") {
+                stage('JVM tests') {
+                  try {
+                    withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
+                      sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG} -PbuildTargetABIs=${ABIs}"
+                    }
+                  } finally {
+                    storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
+                    storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+                    step([$class: 'LintPublisher'])
+                  }
                 }
-              } finally {
-                storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
-                storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
-                step([$class: 'LintPublisher'])
-              }
-            }
-
-            stage('Static code analysis') {
-              try {
-                gradle('realm', 'findbugs pmd checkstyle')
-              } finally {
-                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
-                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
-                step([$class: 'CheckStylePublisher',
-		      canComputeNew: false,
-		      defaultEncoding: '',
-		      healthy: '',
-		      pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
-		      unHealthy: ''
-		     ])
-              }
-            }
-
-            stage('Run instrumented tests') {
-              lock("${env.NODE_NAME}-android") {
-                boolean archiveLog = true
-                String backgroundPid
-                try {
-                  backgroundPid = startLogCatCollector()
-                  forwardAdbPorts()
-                  gradle('realm', 'connectedAndroidTest')
-                  archiveLog = false;
-                } finally {
-                  stopLogCatCollector(backgroundPid, archiveLog)
-                  storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+
+                stage('Static code analysis') {
+                  try {
+                    gradle('realm', 'findbugs pmd checkstyle')
+                  } finally {
+                    publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
+                    publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
+                    step([$class: 'CheckStylePublisher',
+                  canComputeNew: false,
+                  defaultEncoding: '',
+                  healthy: '',
+                  pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+                  unHealthy: ''
+                 ])
+                  }
                 }
-              }
-            }
 
-            // TODO: add support for running monkey on the example apps
+                stage('Run instrumented tests') {
+                  lock("${env.NODE_NAME}-android") {
+                    boolean archiveLog = true
+                    String backgroundPid
+                    try {
+                      backgroundPid = startLogCatCollector()
+                      forwardAdbPorts()
+                      gradle('realm', "${instrumentationTestTarget}")
+                      archiveLog = false;
+                    } finally {
+                      stopLogCatCollector(backgroundPid, archiveLog)
+                      storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+                    }
+                  }
+                }
 
-            if (env.BRANCH_NAME == 'master') {
-              stage('Collect metrics') {
-                collectAarMetrics()
-              }
+                // TODO: add support for running monkey on the example apps
+
+                if (env.BRANCH_NAME == 'master') {
+                  stage('Collect metrics') {
+                    collectAarMetrics()
+                  }
 
-              stage('Publish to OJO') {
-                withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
-                  sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+                  stage('Publish to OJO') {
+                    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
+                      sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+                    }
+                  }
                 }
               }
-            }
-          }
-	} finally {
-          sh "docker logs ${rosContainer.id}"
-          rosContainer.stop()
-	}
+        } finally {
+              sh "docker logs ${rosContainer.id}"
+              rosContainer.stop()
+        }
       }
     }
     currentBuild.rawBuild.setResult(Result.SUCCESS)
diff --git a/dependencies.list b/dependencies.list
index 1398418c5d..91cfac3223 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,8 +1,8 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=2.0.0-rc18
-REALM_SYNC_SHA256=73cb89c1a04cafa871444aa91d93eb9df16af088bcb7d3ede73bb815d53a06e5
+REALM_SYNC_VERSION=2.0.0-rc21
+REALM_SYNC_SHA256=5e09e54e68e78683e006898f5a703f80e0ee49492fb0f9dc2384fcbbb9f02f70
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.0-alpha.30
+REALM_OBJECT_SERVER_DE_VERSION=2.0.0-alpha.34
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 5dc2af0691..c011fa563a 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -28,6 +28,10 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestSyncConfigurationFactory;
@@ -35,6 +39,7 @@
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -123,7 +128,7 @@ public void onChange(Progress progress) {
     public void errorHandler_clientResetReported() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
@@ -138,6 +143,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                         assertEquals(filePathFromError, filePathFromConfig);
                         assertFalse(handler.getBackupFile().exists());
                         assertTrue(handler.getOriginalFile().exists());
+
                         looperThread.testComplete();
                     }
                 })
@@ -156,7 +162,7 @@ public void onError(SyncSession session, ObjectServerError error) {
     public void errorHandler_manualExecuteClientReset() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
@@ -241,13 +247,221 @@ public void run() {
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
 
+    // Check that we can use the backup SyncConfiguration to open the Realm.
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_useBackupSyncConfigurationForClientReset() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
+
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Validate that files have been moved
+                        assertFalse(handler.getOriginalFile().exists());
+                        assertTrue(handler.getBackupFile().exists());
+
+                        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
+                        assertNotNull(backupRealmConfiguration);
+                        assertFalse(backupRealmConfiguration.isSyncConfiguration());
+
+                        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertFalse(backupRealm.isEmpty());
+                        assertEquals(1, backupRealm.where(StringOnly.class).count());
+                        assertEquals("Foo", backupRealm.where(StringOnly.class).findAll().first().getChars());
+                        backupRealm.close();
+
+                        // opening a Dynamic Realm should also work
+                        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+                        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+                        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+                        assertEquals(1, all.size());
+                        assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
+                        dynamicRealm.close();
+                        looperThread.testComplete();
+                    }
+                })
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+    // Check that we can open the backup file without using the provided SyncConfiguration,
+    // this might be the case if the user decide to act upon the client reset later (providing s/he
+    // persisted the location of the file)
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_useBackupSyncConfigurationAfterClientReset() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
+
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Validate that files have been moved
+                        assertFalse(handler.getOriginalFile().exists());
+                        assertTrue(handler.getBackupFile().exists());
+
+                        String backupFile = handler.getBackupFile().getAbsolutePath();
+
+                        // this SyncConf doesn't specify any module, it will throw a migration required
+                        // exception since the backup Realm contain only StringOnly table
+                        RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);
+
+                        try {
+                            Realm.getInstance(backupRealmConfiguration);
+                            fail("Expected to throw a Migration required");
+                        } catch (RealmMigrationNeededException expected) {
+                        }
+
+                        // opening a DynamicRealm will work though
+                        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+
+                        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+                        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+                        assertEquals(1, all.size());
+                        assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
+
+                        // make sure we can't write to it (read-only Realm)
+                        try {
+                            dynamicRealm.beginTransaction();
+                            fail("Can't perform transactions on read-only Realms");
+                        } catch (IllegalStateException expected) {
+                        }
+                        dynamicRealm.close();
+
+                        try {
+                            SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);
+                            fail("Expected to throw java.lang.Class is not a RealmModule");
+                        } catch (IllegalArgumentException expected) {
+                        }
+
+                        // specifying the module will allow to open the typed Realm
+                        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());
+                        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertFalse(backupRealm.isEmpty());
+                        assertEquals(1, backupRealm.where(StringOnly.class).count());
+                        RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();
+                        assertEquals("Foo", allSorted.get(0).getChars());
+                        backupRealm.close();
+
+                        looperThread.testComplete();
+                    }
+                })
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_useClientResetEncrypted() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final byte[] randomKey = TestHelper.getRandomKey();
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .encryptionKey(randomKey)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
+
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
+
+                        // can open encrypted backup Realm
+                        Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
+                        RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
+                        assertEquals("Foo", allSorted.get(0).getChars());
+                        backupEncryptedRealm.close();
+
+                        String backupFile = handler.getBackupFile().getAbsolutePath();
+                        // build a conf to open a DynamicRealm
+                        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());
+                        backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
+                        allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
+                        assertEquals("Foo", allSorted.get(0).getChars());
+                        backupEncryptedRealm.close();
+
+                        // using wrong key throw
+                        try {
+                            Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));
+                            fail("Expected to throw when using wrong encryption key");
+                        } catch (RealmFileException expected) {
+                        }
+
+                        looperThread.testComplete();
+                    }
+                })
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
     @Test
     @UiThreadTest
     public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {
-        SyncUser user = createTestUser();
         Realm realm = Realm.getInstance(configuration);
         try {
             SyncManager.getSession(configuration).uploadAllLocalChanges();
+            fail("Should throw an IllegalStateException on Ui Thread");
         } catch (IllegalStateException ignored) {
         } finally {
             realm.close();
@@ -257,10 +471,10 @@ public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException
     @Test
     @UiThreadTest
     public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {
-        SyncUser user = createTestUser();
         Realm realm = Realm.getInstance(configuration);
         try {
             SyncManager.getSession(configuration).downloadAllServerChanges();
+            fail("Should throw an IllegalStateException on Ui Thread");
         } catch (IllegalStateException ignored) {
         } finally {
             realm.close();
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 6f7804a233..cdd0d8c82b 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 6f7804a2332732e0c2d2db6bf920a38c75e72fb2
+Subproject commit cdd0d8c82ba6dfb60ebc2c339b26b7b3ca4d4047
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index b7e157cdac..25c02994e0 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -224,6 +224,9 @@ void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::Rea
         case realm::RealmFileException::Kind::FormatUpgradeRequired:
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED;
             break;
+        case realm::RealmFileException::Kind::IncompatibleSyncedRealm:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE;
+            break;
     }
     jstring jstr = env->NewStringUTF(message.c_str());
     jobject exception = env->NewObject(cls, constructor, kind_code, jstr);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index ad52ddfa33..b6546f405a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -104,8 +104,8 @@
 
     // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
     // subsets of them.
-    protected RealmConfiguration(File realmDirectory,
-            String realmFileName,
+    protected RealmConfiguration(@Nullable File realmDirectory,
+            @Nullable String realmFileName,
             String canonicalPath,
             @Nullable String assetFilePath,
             @Nullable byte[] key,
@@ -275,42 +275,48 @@ public boolean equals(Object obj) {
 
         if (schemaVersion != that.schemaVersion) { return false; }
         if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) { return false; }
-        if (!realmDirectory.equals(that.realmDirectory)) { return false; }
-        if (!realmFileName.equals(that.realmFileName)) { return false; }
+        if (readOnly != that.readOnly) { return false; }
+        if (realmDirectory != null ? !realmDirectory.equals(that.realmDirectory) : that.realmDirectory != null) {
+            return false;
+        }
+        if (realmFileName != null ? !realmFileName.equals(that.realmFileName) : that.realmFileName != null) {
+            return false;
+        }
         if (!canonicalPath.equals(that.canonicalPath)) { return false; }
+        if (assetFilePath != null ? !assetFilePath.equals(that.assetFilePath) : that.assetFilePath != null) {
+            return false;
+        }
         if (!Arrays.equals(key, that.key)) { return false; }
-        if (!durability.equals(that.durability)) { return false; }
-        if (migration != null ? !migration.equals(that.migration) : that.migration != null) { return false; }
-        //noinspection SimplifiableIfStatement
+        if (migration != null ? !migration.equals(that.migration) : that.migration != null) {
+            return false;
+        }
+        if (durability != that.durability) { return false; }
+        if (!schemaMediator.equals(that.schemaMediator)) { return false; }
         if (rxObservableFactory != null ? !rxObservableFactory.equals(that.rxObservableFactory) : that.rxObservableFactory != null) {
             return false;
         }
         if (initialDataTransaction != null ? !initialDataTransaction.equals(that.initialDataTransaction) : that.initialDataTransaction != null) {
             return false;
         }
-        if (readOnly != that.readOnly) { return false; }
-        if (compactOnLaunch != null ? !compactOnLaunch.equals(that.compactOnLaunch) : that.compactOnLaunch != null) { return false; }
-
-        return schemaMediator.equals(that.schemaMediator);
+        return compactOnLaunch != null ? compactOnLaunch.equals(that.compactOnLaunch) : that.compactOnLaunch == null;
     }
 
-
     @Override
     public int hashCode() {
-        int result = realmDirectory.hashCode();
-        result = 31 * result + realmFileName.hashCode();
+        int result = realmDirectory != null ? realmDirectory.hashCode() : 0;
+        result = 31 * result + (realmFileName != null ? realmFileName.hashCode() : 0);
         result = 31 * result + canonicalPath.hashCode();
-        result = 31 * result + (key != null ? Arrays.hashCode(key) : 0);
-        result = 31 * result + (int) schemaVersion;
+        result = 31 * result + (assetFilePath != null ? assetFilePath.hashCode() : 0);
+        result = 31 * result + Arrays.hashCode(key);
+        result = 31 * result + (int) (schemaVersion ^ (schemaVersion >>> 32));
         result = 31 * result + (migration != null ? migration.hashCode() : 0);
         result = 31 * result + (deleteRealmIfMigrationNeeded ? 1 : 0);
-        result = 31 * result + schemaMediator.hashCode();
         result = 31 * result + durability.hashCode();
+        result = 31 * result + schemaMediator.hashCode();
         result = 31 * result + (rxObservableFactory != null ? rxObservableFactory.hashCode() : 0);
         result = 31 * result + (initialDataTransaction != null ? initialDataTransaction.hashCode() : 0);
         result = 31 * result + (readOnly ? 1 : 0);
         result = 31 * result + (compactOnLaunch != null ? compactOnLaunch.hashCode() : 0);
-
         return result;
     }
 
@@ -365,7 +371,7 @@ private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleC
     public String toString() {
         //noinspection StringBufferReplaceableByString
         StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.append("realmDirectory: ").append(realmDirectory.toString());
+        stringBuilder.append("realmDirectory: ").append(realmDirectory != null ? realmDirectory.toString() : "");
         stringBuilder.append("\n");
         stringBuilder.append("realmFileName : ").append(realmFileName);
         stringBuilder.append("\n");
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
index 07e6b86453..716c0266c6 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -60,7 +60,12 @@
         /**
          * Thrown if the file needs to be upgraded to a new format, but upgrades have been explicitly disabled.
          */
-        FORMAT_UPGRADE_REQUIRED;
+        FORMAT_UPGRADE_REQUIRED,
+        /**
+         * Thrown if an attempt was made to open an Realm file created with Realm Object Server 1.*, which is
+         * not compatible with Realm Object Server 2.*. This exception should automatically be handled by Realm.
+         */
+        INCOMPATIBLE_SYNC_FILE;
 
         // Created from byte values by JNI.
         static Kind getKind(byte value) {
@@ -79,6 +84,8 @@ static Kind getKind(byte value) {
                     return FORMAT_UPGRADE_REQUIRED;
                 case SharedRealm.FILE_EXCEPTION_KIND_BAD_HISTORY:
                     return BAD_HISTORY;
+                case SharedRealm.FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE:
+                    return INCOMPATIBLE_SYNC_FILE;
                 default:
                     throw new RuntimeException("Unknown value for RealmFileException kind.");
             }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index 096b62620d..24eb5faa8d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -188,7 +188,7 @@ private OsRealmConfig(final RealmConfiguration config,
         // Set schema related params.
         SchemaMode schemaMode = SchemaMode.SCHEMA_MODE_MANUAL;
         if (config.isReadOnly()) {
-            schemaMode = SchemaMode.SCHEMA_MODE_READONLY;
+            schemaMode = SchemaMode.SCHEMA_MODE_IMMUTABLE;
         } else if (syncRealmUrl != null) {
             schemaMode = SchemaMode.SCHEMA_MODE_ADDITIVE;
         } else if (config.shouldDeleteRealmIfMigrationNeeded()) {
@@ -210,7 +210,6 @@ private OsRealmConfig(final RealmConfiguration config,
         if (initializationCallback != null) {
             nativeSetInitializationCallback(nativePtr, initializationCallback);
         }
-
         // Set sync config
         if (syncRealmUrl != null) {
             nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index c2a81e4f34..6f4e971551 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -26,7 +26,6 @@
 import javax.annotation.Nullable;
 
 import io.realm.RealmConfiguration;
-import io.realm.RealmFieldType;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
@@ -41,6 +40,7 @@
     public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 4;
     public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 5;
     public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 6;
+    public static final byte FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE = 7;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
     public static void initialize(File tempDirectory) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java b/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
index f9a2fbe1e1..1ffc75acc7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
@@ -26,15 +26,17 @@
  */
 public class ClientResetRequiredError extends ObjectServerError {
 
-    private final RealmConfiguration configuration;
+    private final SyncConfiguration originalConfiguration;
+    private final RealmConfiguration backupConfiguration;
     private final File backupFile;
     private final File originalFile;
 
-    public ClientResetRequiredError(ErrorCode errorCode, String errorMessage, String backupFilePath, RealmConfiguration configuration) {
+    ClientResetRequiredError(ErrorCode errorCode, String errorMessage, SyncConfiguration originalConfiguration, RealmConfiguration backupConfiguration) {
         super(errorCode, errorMessage);
-        this.configuration = configuration;
-        this.backupFile = new File(backupFilePath);
-        this.originalFile = new File(configuration.getPath());
+        this.originalConfiguration = originalConfiguration;
+        this.backupConfiguration = backupConfiguration;
+        this.backupFile = new File(backupConfiguration.getPath());
+        this.originalFile = new File(originalConfiguration.getPath());
     }
 
     /**
@@ -50,11 +52,11 @@ public ClientResetRequiredError(ErrorCode errorCode, String errorMessage, String
      */
     public void executeClientReset()  {
         synchronized (Realm.class) {
-            if (Realm.getGlobalInstanceCount(configuration) > 0) {
+            if (Realm.getGlobalInstanceCount(originalConfiguration) > 0) {
                 throw new IllegalStateException("Realm has not been fully closed. Client Reset cannot run before all " +
                         "instances have been closed.");
             }
-            nativeExecuteClientReset(configuration.getPath());
+            nativeExecuteClientReset(originalConfiguration.getPath());
         }
     }
 
@@ -70,6 +72,12 @@ public File getBackupFile() {
         return backupFile;
     }
 
+    /**
+     * @return the configuration that can be used to open the backup Realm offline.
+     */
+    public RealmConfiguration getBackupRealmConfiguration() {
+        return backupConfiguration;
+    }
     /**
      * Returns the location of the original Realm file. After the Client Reset has completed, the file at this location
      * will be deleted.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 1c160cbdff..3659767dc9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -78,7 +78,7 @@
     static final int MAX_FULL_PATH_LENGTH = 256;
     static final int MAX_FILE_NAME_LENGTH = 255;
     private static final char[] INVALID_CHARS = {'<', '>', ':', '"', '/', '\\', '|', '?', '*'};
-private final URI serverUrl;
+    private final URI serverUrl;
     private final SyncUser user;
     private final SyncSession.ErrorHandler errorHandler;
     private final boolean deleteRealmOnLogout;
@@ -144,6 +144,53 @@ private SyncConfiguration(File directory,
         this.waitForInitialData = waitForInitialData;
     }
 
+    /**
+     * Returns a {@link RealmConfiguration} appropriate to open a read-only, non-synced Realm to recover any pending changes.
+     * This is useful when trying to open a backup/recovery Realm (after a client reset).
+     *
+     * @param canonicalPath the absolute path to the Realm file defined by this configuration.
+     * @param encryptionKey the key used to encrypt/decrypt the Realm file.
+     * @param modules if specified it will restricts Realm schema to the provided module.
+     * @return RealmConfiguration that can be used offline
+     */
+    public static RealmConfiguration forRecovery(String canonicalPath, @Nullable byte[] encryptionKey, @Nullable Object... modules) {
+        HashSet<Object> validatedModules = new HashSet<>();
+        if (modules != null && modules.length > 0) {
+            for (Object module : modules) {
+                if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
+                    throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
+                            "Add @RealmModule to the class definition.");
+                }
+                validatedModules.add(module);
+            }
+        } else {
+            if (Realm.getDefaultModule() != null) {
+                validatedModules.add(Realm.getDefaultModule());
+            }
+        }
+
+        RealmProxyMediator schemaMediator = createSchemaMediator(validatedModules, Collections.<Class<? extends RealmModel>>emptySet());
+        return forRecovery(canonicalPath, encryptionKey, schemaMediator);
+    }
+
+    /**
+     * Returns a {@link RealmConfiguration} appropriate to open a read-only, non-synced Realm to recover any pending changes.
+     * This is useful when trying to open a backup/recovery Realm (after a client reset).
+     *
+     * Note: This will use the default Realm module (composed of all {@link RealmModel}), and
+     * assume no encryption should be used as well.
+     *
+     * @param canonicalPath the absolute path to the Realm file defined by this configuration.
+     * @return RealmConfiguration that can be used offline
+     */
+    public static RealmConfiguration forRecovery(String canonicalPath) {
+        return forRecovery(canonicalPath, null);
+    }
+
+    static RealmConfiguration forRecovery(String canonicalPath, @Nullable byte[] encryptionKey, RealmProxyMediator schemaMediator) {
+        return new RealmConfiguration(null,null, canonicalPath,null, encryptionKey, 0,null, false, OsRealmConfig.Durability.FULL, schemaMediator, null, null, true, null);
+    }
+
     static URI resolveServerUrl(URI serverUrl, String userIdentifier) {
         try {
             return new URI(serverUrl.toString().replace("/~/", "/" + userIdentifier + "/"));
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 9a3eb54852..4387d8e26a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -167,9 +167,10 @@ void notifySessionError(int errorCode, String errorMessage) {
         ErrorCode errCode = ErrorCode.fromInt(errorCode);
         if (errCode == ErrorCode.CLIENT_RESET) {
             // errorMessage contains the path to the backed up file
+            RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(errorMessage, configuration.getEncryptionKey(), configuration.getSchemaMediator());
             errorHandler.onError(this, new ClientResetRequiredError(errCode, "A Client Reset is required. " +
                     "Read more here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup.",
-                    errorMessage, getConfiguration()));
+                    configuration, backupRealmConfiguration));
         } else {
             errorHandler.onError(this, new ObjectServerError(errCode, errorMessage));
         }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 429e2e61c8..23a60d532a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -274,7 +274,31 @@ public void logout() {
             // the similar SyncConfiguration using the same identity, but with different (new)
             // refresh-token.
             realms.clear();
-            SyncManager.notifyUserLoggedOut(SyncUser.this);
+
+            // Finally revoke server token. The local user is logged out in any case.
+            final AuthenticationServer server = SyncManager.getAuthServer();
+            // don't reference directly the refreshToken inside the revoke request
+            // as it may revoke the newly acquired refresh_token
+            final Token refreshTokenToBeRevoked = refreshToken;
+
+            ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
+            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
+
+                @Override
+                protected LogoutResponse execute() {
+                    return server.logout(refreshTokenToBeRevoked, getAuthenticationUrl());
+                }
+
+                @Override
+                protected void onSuccess(LogoutResponse response) {
+                    SyncManager.notifyUserLoggedOut(SyncUser.this);
+                }
+
+                @Override
+                protected void onError(LogoutResponse response) {
+                    RealmLog.error("Failed to log user out.\n" + response.getError().toString());
+                }
+            });
         }
     }
 
@@ -503,16 +527,10 @@ public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final
         AuthenticationServer authServer = SyncManager.getAuthServer();
         LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerUserIdentity, getAuthenticationUrl());
         if (!response.isValid()) {
-            // the endpoint returns a 404 if it can't honor the query, either because
-            // - provider is not valid
-            // - provider_id is not valid
-            // - token used is not an admin one
-            // in this case we should return null instead of throwing
-            if (response.getError().getErrorCode() == ErrorCode.NOT_FOUND) {
-                return null;
-            } else {
-                throw response.getError();
-            }
+            // Right now errors are very inconsistent. See https://github.com/realm/ros/issues/310
+            // Treat them all as "User not existing". This is too broad, and should be revisited
+            // once #310 is fixed.
+            return null;
         } else {
             return SyncUserInfo.fromLookupUserIdResponse(response);
         }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
index c6d2c47045..4285b565a6 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
@@ -63,7 +63,14 @@ public static ObjectServerError createError(String response, int httpErrorCode)
             JSONObject obj = new JSONObject(response);
             String title = obj.optString("title", null);
             String hint = obj.optString("hint", null);
-            ErrorCode errorCode = ErrorCode.fromInt(obj.optInt("code", -1));
+            ErrorCode errorCode;
+            if (obj.has("code")) {
+                errorCode = ErrorCode.fromInt(obj.getInt("code"));
+            } else if (obj.has("status")) {
+                errorCode = ErrorCode.fromInt(obj.getInt("status"));
+            } else {
+                errorCode = ErrorCode.UNKNOWN;
+            }
             return new ObjectServerError(errorCode, title, hint);
         } catch (JSONException e) {
             return new ObjectServerError(ErrorCode.JSON_EXCEPTION, "Server failed with " +
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
index 8e22c09704..6ca1f3aef1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
@@ -56,10 +56,9 @@ private ChangePasswordRequest(String token, String newPassword, String userID) {
     public String toJson() {
         try {
             JSONObject request = new JSONObject();
-            request.put("token", token);
-            request.put("password", newPassword);
+            request.put("newPassword", newPassword);
             if (userID != null) {
-                request.put("user_id", userID);
+                request.put("userId", userID);
             }
             return request.toString();
         } catch (JSONException e) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 997f59cea7..88a6fcfd20 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -22,6 +22,7 @@
 import java.util.concurrent.TimeUnit;
 
 import io.realm.SyncCredentials;
+import io.realm.internal.Util;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
 import okhttp3.Call;
@@ -36,8 +37,8 @@
 
     public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
     private static final String ACTION_LOGOUT = "revoke"; // Auth end point for logging out users
-    private static final String ACTION_CHANGE_PASSWORD = "users/:userId:/password"; // Auth end point for changing passwords
-    private static final String ACTION_LOOKUP_USER_ID = "users"; // Auth end point for looking up user id
+    private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
+    private static final String ACTION_LOOKUP_USER_ID = "/users/:provider:/:providerId:"; // Auth end point for looking up user id
 
     private final OkHttpClient client = new OkHttpClient.Builder()
             .connectTimeout(10, TimeUnit.SECONDS)
@@ -86,7 +87,7 @@ public AuthenticateResponse refreshUser(Token userToken, URI serverUrl, URL auth
     public LogoutResponse logout(Token userToken, URL authenticationUrl) {
         try {
             String requestBody = LogoutRequest.create(userToken).toJson();
-            return logout(buildActionUrl(authenticationUrl, ACTION_LOGOUT), requestBody);
+            return logout(buildActionUrl(authenticationUrl, ACTION_LOGOUT), userToken.value(), requestBody);
         } catch (Exception e) {
             return LogoutResponse.from(e);
         }
@@ -96,7 +97,7 @@ public LogoutResponse logout(Token userToken, URL authenticationUrl) {
     public ChangePasswordResponse changePassword(Token userToken, String newPassword, URL authenticationUrl) {
         try {
             String requestBody = ChangePasswordRequest.create(userToken, newPassword).toJson();
-            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), requestBody);
+            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), userToken.value(), requestBody);
         } catch (Exception e) {
             return ChangePasswordResponse.from(e);
         }
@@ -106,7 +107,7 @@ public ChangePasswordResponse changePassword(Token userToken, String newPassword
     public ChangePasswordResponse changePassword(Token adminToken, String userId, String newPassword, URL authenticationUrl) {
         try {
             String requestBody = ChangePasswordRequest.create(adminToken, userId, newPassword).toJson();
-            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD.replace(":userId:", userId)), requestBody);
+            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), adminToken.value(), requestBody);
         } catch (Exception e) {
             return ChangePasswordResponse.from(e);
         }
@@ -115,7 +116,10 @@ public ChangePasswordResponse changePassword(Token adminToken, String userId, St
     @Override
     public LookupUserIdResponse retrieveUser(Token adminToken, String provider, String providerId, URL authenticationUrl) {
         try {
-            return lookupUserId(buildLookupUserIdUrl(authenticationUrl, ACTION_LOOKUP_USER_ID, provider, providerId), adminToken.value());
+            String action = ACTION_LOOKUP_USER_ID
+                .replace(":provider:", provider)
+                .replace(":providerId:", providerId);
+            return lookupUserId(buildActionUrl(authenticationUrl, action), adminToken.value());
         } catch (Exception e) {
             return LookupUserIdResponse.from(e);
         }
@@ -132,53 +136,62 @@ private static URL buildActionUrl(URL authenticationUrl, String action) {
         }
     }
 
-    private static URL buildLookupUserIdUrl(URL authenticationUrl, String action, String provider, String providerId) {
-        String authURL = authenticationUrl.toExternalForm();
-        String separator = authURL.endsWith("/") ? "" : "/";
-        try {
-            return new URL(authURL + separator + action + "/" + providerId);
-        } catch (MalformedURLException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
     private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
         RealmLog.debug("Network request (authenticate): " + authenticationUrl);
-        Request request = newAuthRequest(authenticationUrl).post(RequestBody.create(JSON, requestBody)).build();
+        Request request = newAuthRequest(authenticationUrl)
+                .post(RequestBody.create(JSON, requestBody))
+                .build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return AuthenticateResponse.from(response);
     }
 
-    private LogoutResponse logout(URL logoutUrl, String requestBody) throws Exception {
+    private LogoutResponse logout(URL logoutUrl, String authToken, String requestBody) throws Exception {
         RealmLog.debug("Network request (logout): " + logoutUrl);
-        Request request = newAuthRequest(logoutUrl).post(RequestBody.create(JSON, requestBody)).build();
+        Request request = newAuthRequest(logoutUrl, authToken)
+                .post(RequestBody.create(JSON, requestBody))
+                .build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return LogoutResponse.from(response);
     }
 
-    private ChangePasswordResponse changePassword(URL changePasswordUrl, String requestBody) throws Exception {
+    private ChangePasswordResponse changePassword(URL changePasswordUrl, String authToken, String requestBody) throws Exception {
         RealmLog.debug("Network request (changePassword): " + changePasswordUrl);
-        Request request = newAuthRequest(changePasswordUrl).put(RequestBody.create(JSON, requestBody)).build();
+        Request request = newAuthRequest(changePasswordUrl, authToken)
+                .put(RequestBody.create(JSON, requestBody))
+                .build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return ChangePasswordResponse.from(response);
     }
 
-    private LookupUserIdResponse lookupUserId(URL lookupUserIdUrl, String token) throws Exception {
+    private LookupUserIdResponse lookupUserId(URL lookupUserIdUrl, String authToken) throws Exception {
         RealmLog.debug("Network request (lookupUserId): " + lookupUserIdUrl);
-        Request request = newAuthRequest(lookupUserIdUrl).get().header("Authorization", token).build();
+        Request request = newAuthRequest(lookupUserIdUrl, authToken)
+                .get()
+                .build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return LookupUserIdResponse.from(response);
     }
 
     private Request.Builder newAuthRequest(URL url) {
-        return new Request.Builder()
+        return newAuthRequest(url, null);
+    }
+
+    private Request.Builder newAuthRequest(URL url, String authToken) {
+        Request.Builder builder = new Request.Builder()
                 .url(url)
                 .addHeader("Content-Type", "application/json")
                 .addHeader("Accept", "application/json");
+
+        // Only add Authorization header for those API's that require it.
+        if (!Util.isEmptyString(authToken)) {
+            builder.addHeader("Authorization", authToken);
+        }
+
+        return builder;
     }
 
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index 660d9e6d56..bd53f9209c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -267,5 +267,4 @@ public void waitForInitialRemoteData_readOnlyFalse_upgradeSchema() {
             user.logout();
         }
     }
-
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 9bd027cd60..537bf257bd 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -32,6 +32,7 @@
 import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.SyncUserInfo;
+import io.realm.TestHelper;
 import io.realm.entities.StringOnly;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.objectserver.Token;
@@ -90,7 +91,8 @@ public void onError(ObjectServerError error) {
     @Test
     @RunTestInLooperThread
     public void login_newUser() {
-        SyncCredentials credentials = SyncCredentials.usernamePassword("myUser", "password", true);
+        String userId = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userId, "password", true);
         SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
             @Override
             public void onSuccess(SyncUser user) {
@@ -194,7 +196,6 @@ public void onError(ObjectServerError error) {
     }
 
     @Test
-    @Ignore("Resolve https://github.com/realm/ros/issues/273")
     public void changePassword() {
         String username = UUID.randomUUID().toString();
         String originalPassword = "password";
@@ -214,7 +215,6 @@ public void changePassword() {
     }
 
     @Test
-    @Ignore("Resolve https://github.com/realm/ros/issues/273")
     public void changePassword_using_admin() {
         String username = UUID.randomUUID().toString();
         String originalPassword = "password";
@@ -242,7 +242,6 @@ public void changePassword_using_admin() {
 
     @Test
     @RunTestInLooperThread
-    @Ignore("Resolve https://github.com/realm/ros/issues/273")
     public void changePassword_using_admin_async() {
         final String username = UUID.randomUUID().toString();
         final String originalPassword = "password";
@@ -282,6 +281,7 @@ public void onError(ObjectServerError error) {
 
     @Test
     @RunTestInLooperThread
+    @Ignore("Wait until https://github.com/realm/ros/issues/309 is resolved")
     public void changePassword_throwWhenUserIsLoggedOut() {
         String username = UUID.randomUUID().toString();
         String password = "password";
@@ -398,7 +398,6 @@ public void usingConfigurationWithInvalidUserShouldThrow() {
         RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
         user.logout();
         assertFalse(user.isValid());
-
         Realm instance = Realm.getInstance(configuration);
         instance.close();
     }
@@ -500,23 +499,38 @@ public void singleUserCanBeLoggedInAndOutRepeatedly() {
     }
 
     @Test
-    @Ignore("Resolve https://github.com/realm/ros/issues/261")
     public void revokedRefreshTokenIsNotSameAfterLogin() throws InterruptedException {
+        final CountDownLatch userLoggedInAgain = new CountDownLatch(1);
         final String uniqueName = UUID.randomUUID().toString();
 
-        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
         SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        Token revokedRefreshToken = user.getAccessToken();
+        final Token revokedRefreshToken = user.getAccessToken();
 
-        user.logout();
+        SyncManager.addAuthenticationListener(new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
 
-        credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
-        SyncUser loggedInUser = SyncUser.login(credentials, Constants.AUTH_URL);
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                SystemClock.sleep(1000); // Remove once https://github.com/realm/ros/issues/304 is fixed
+                SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+                SyncUser loggedInUser = SyncUser.login(credentials, Constants.AUTH_URL);
 
-        // still comparing the same user
-        Assert.assertEquals(revokedRefreshToken.identity(), loggedInUser.getAccessToken().identity());
-        // different tokens
-        assertNotEquals(revokedRefreshToken.value(), loggedInUser.getAccessToken().value());
+                // still comparing the same user
+                assertEquals(revokedRefreshToken.identity(), loggedInUser.getAccessToken().identity());
+
+                // different tokens
+                assertNotEquals(revokedRefreshToken.value(), loggedInUser.getAccessToken().value());
+                SyncManager.removeAuthenticationListener(this);
+                userLoggedInAgain.countDown();
+            }
+        });
+
+        user.logout();
+        TestHelper.awaitOrFail(userLoggedInAgain);
     }
 
     // The pre-emptive token refresh subsystem should function, and properly refresh the access token.
@@ -563,7 +577,6 @@ public void execute(Realm realm) {
 
         final Token accessToken = entry.getValue();
         Assert.assertNotNull(accessToken);
-
         // getting refresh token delay
         Field refreshTokenTaskField = SyncSession.class.getDeclaredField("refreshTokenTask");
         refreshTokenTaskField.setAccessible(true);
@@ -582,8 +595,7 @@ public void execute(Realm realm) {
         SystemClock.sleep(TimeUnit.SECONDS.toMillis(3));
 
         Token newAccessToken = accessTokens.get(syncConfiguration);
-
-        assertThat("new Token is not expired", newAccessToken.expiresMs(), greaterThan(System.currentTimeMillis()));
+        assertThat("new Token expires after the old one", newAccessToken.expiresMs(), greaterThan(accessToken.expiresMs()));
         assertNotEquals(accessToken, newAccessToken);
 
         // refresh_token identity is the same
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 50d7ed8b40..7806b4158b 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -1,18 +1,14 @@
 package io.realm.objectserver;
 
 import android.os.SystemClock;
-import android.text.style.TabStopSpan;
 
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 
 import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 
-import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmResults;
@@ -24,7 +20,6 @@
 import io.realm.SyncUser;
 import io.realm.TestHelper;
 import io.realm.entities.StringOnly;
-import io.realm.exceptions.RealmError;
 import io.realm.exceptions.RealmFileException;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
@@ -130,19 +125,6 @@ public void onError(SyncSession session, ObjectServerError error) {
         // STEP 2: make sure the changes gets to the server
         SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
 
-        final CountDownLatch backgroundException = new CountDownLatch(1);
-        final AtomicBoolean exceptionThrown = new AtomicBoolean(false);
-
-        Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-            @Override
-            public void uncaughtException(Thread t, Throwable e) {
-                if (e instanceof RealmError && e.getMessage().contains("An exception has been thrown on the sync client thread")) {
-                    exceptionThrown.set(true);
-                }
-                backgroundException.countDown();
-            }
-        });
         realm.close();
         user.logout();
 
@@ -163,12 +145,11 @@ public void onError(SyncSession session, ObjectServerError error) {
             realm = Realm.getInstance(configWithoutEncryption);
             fail("It should not be possible to open the Realm without the encryption key set previously.");
         } catch (RealmFileException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
         }
-
-        TestHelper.awaitOrFail(backgroundException);
-        // restore default handler
-        Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
-        assertTrue("Sync Client Thread should throw an exception", exceptionThrown.get());
     }
 
     // If client B encrypts its synced Realm, client A should be able to access that Realm with a different encryption key.
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
index af4d52fdcb..e1943ae61c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -18,7 +18,6 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -187,6 +186,11 @@ public void onChange(Progress progress) {
         TestHelper.awaitOrFail(allChangesDownloaded);
         adminRealm.close();
         userRealm.close();
+        userWithData.logout();
+        adminUser.logout();
+        // FIXME sometimes the worker thread doesn't terminate
+        // causing the test thread to wait  indefinitely until it times out
+        // https://github.com/realm/realm-java/issues/5245
         worker.join();
     }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
index 889d09897d..a51e9b97d1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
@@ -7,6 +7,7 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -381,6 +382,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
 
     // A Realm that was opened before a user logged out should be able to resume downloading if the user logs back in.
     @Test
+    @Ignore("until https://github.com/realm/realm-java/issues/5294 is fixed")
     public void downloadChangesWhenRealmOutOfScope() throws InterruptedException {
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index a1d325d687..beb5c0cb06 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -161,40 +161,12 @@ public static void logoutAllUsers() {
         handler.post(new Runnable() {
             @Override
             public void run() {
-                final AtomicInteger usersLoggedOut = new AtomicInteger(0);
-                final int activeUsers = SyncUser.all().size();
-                final AuthenticationListener listener = new AuthenticationListener() {
-                    @Override
-                    public void loggedIn(SyncUser user) {
-                        SyncManager.removeAuthenticationListener(this);
-                        fail("User logged in while exiting test: " + user);
-                    }
-
-                    @Override
-                    public void loggedOut(SyncUser user) {
-                        if (usersLoggedOut.incrementAndGet() == activeUsers) {
-                            SyncManager.removeAuthenticationListener(this);
-                            allUsersLoggedOut.countDown();
-                        }
-                    }
-                };
-                SyncManager.addAuthenticationListener(listener);
-
                 Map<String, SyncUser> users = SyncUser.all();
-                if (users.isEmpty()) {
-                    SyncManager.removeAuthenticationListener(listener);
-                    allUsersLoggedOut.countDown();
-                } else {
-                    for (SyncUser user : users.values()) {
-                        user.logout();
-                        if (!user.getAuthenticationUrl().toString().contains("127.0.0.1")) {
-                            // For dummy users, calling `logout()` will never result in the
-                            // authentication listener to trigger since the URL doesn't exist.
-                            // For these cases, we manually trigger the listener.
-                            listener.loggedOut(user);
-                        }
-                    }
+                for (SyncUser user : users.values()) {
+                    user.logout();
                 }
+                SystemClock.sleep(2000); // Remove when https://github.com/realm/ros/issues/304 is fixed
+                allUsersLoggedOut.countDown();
             }
         });
         TestHelper.awaitOrFail(allUsersLoggedOut);
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index 384c54984e..0e46a056d8 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -42,7 +42,7 @@ function waitForRosToInitialize(attempts, onSuccess, onError) {
     http.get("http://0.0.0.0:9080/health", function(res) {
         if (res.statusCode != 200) {
             winston.info("ROS /health/ returned: " + res.statusCode)
-            waitForRosToInitialize(attempts - 1,onSuccess)
+            waitForRosToInitialize(attempts - 1, onSuccess, onError)
         } else {
             onSuccess();
         }
@@ -51,7 +51,7 @@ function waitForRosToInitialize(attempts, onSuccess, onError) {
         // Errors like ECONNREFUSED 0.0.0.0:9080 will be reported here.
         // Wait a little before trying again (common startup is ~1 second).
         setTimeout(function() {
-            waitForRosToInitialize(attempts - 1, onSuccess);
+            waitForRosToInitialize(attempts - 1, onSuccess, onError);
         }, 200);
     });
 }
@@ -64,7 +64,10 @@ function startRealmObjectServer(onSuccess, onError) {
             winston.info(env.NODE_ENV);
             env.NODE_ENV = 'development';
             syncServerChildProcess = spawn('ros',
-                    ['start', '--data', path],
+                    ['start',
+                        '--data', path,
+                        '--access-token-ttl', '20' //WARNING : Changing this value may impact the timeout of the refresh token test (AuthTests#preemptiveTokenRefresh)
+                    ],
                     { env: env, cwd: path});
 
             // local config:
@@ -93,8 +96,6 @@ function stopRealmObjectServer(onSuccess, onError) {
         onSuccess();
     });
 
-    // Move back to `SIGTERM` once https://github.com/realm/ros/issues/234
-    // is resolved
     syncServerChildProcess.kill('SIGKILL');
 }
 
@@ -103,10 +104,10 @@ dispatcher.onGet("/start", function(req, res) {
     winston.info("Attempting to start ROS");
     startRealmObjectServer(() => {
         res.writeHead(200, {'Content-Type': 'text/plain'});
-        res.end('ROS server started');
+        res.end('ROS started');
     }, function (err) {
         res.writeHead(500, {'Content-Type': 'text/plain'});
-        res.end('Starting a ROS server failed: ' + err);
+        res.end('Starting ROS failed: ' + err);
     });
 });
 
@@ -114,8 +115,11 @@ dispatcher.onGet("/start", function(req, res) {
 dispatcher.onGet("/stop", function(req, res) {
   winston.info("Attempting to stop ROS")
   stopRealmObjectServer(function() {
-      res.writeHead(200, {'Content-Type': 'text/plain'});
-      res.end('ROS server stopped');
+        res.writeHead(200, {'Content-Type': 'text/plain'});
+        res.end('ROS stopped');
+  }, function(err) {
+        res.writeHead(500, {'Content-Type': 'text/plain'});
+        res.end('Stopping ROS failed: ' + err);
   });
 });
 
