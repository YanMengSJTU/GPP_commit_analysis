diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5f9c327261..8f4f95d32a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -13,7 +13,6 @@
   * Linking objects are not yet supported on dynamic objects
   * Migration for linking objects is not yet supported.
   * Backlink verification is incomplete.  Evil code can cause native crashes.
-* [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
 * [ObjectServer] In case of a Client Reset, information about the location of the backed up Realm file is now reported through the `ErrorHandler` interface (#4080).
 * [ObjectServer] Authentication URLs now automatically append `/auth` if no other path segment is set (#4370).
 * The listener on `RealmObject` will only be triggered if the object changes (#3894).
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index db813f22ad..8a42675c8a 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -61,9 +61,7 @@ realm {
 
 dependencies {
     compile 'com.android.support:support-v4:25.2.0'
-    compile 'com.android.support:appcompat-v7:25.2.0'
     compile 'com.android.support:design:25.2.0'
-    compile 'me.zhanghai.android.materialprogressbar:library:1.3.0'
     compile 'com.jakewharton:butterknife:8.3.0'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.3.0'
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index 536b24ef90..97c67d2443 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -17,67 +17,32 @@
 package io.realm.examples.objectserver;
 
 import android.content.Intent;
-import android.graphics.PorterDuff;
 import android.os.Bundle;
-import android.support.annotation.ColorRes;
 import android.support.v7.app.AppCompatActivity;
 import android.view.Menu;
 import android.view.MenuItem;
-import android.view.View;
 import android.widget.TextView;
 
 import java.util.Locale;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import butterknife.OnClick;
-import io.realm.Progress;
-import io.realm.ProgressListener;
-import io.realm.ProgressMode;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.SyncConfiguration;
-import io.realm.SyncManager;
-import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.examples.objectserver.model.CRDTCounter;
-import me.zhanghai.android.materialprogressbar.MaterialProgressBar;
 
 public class CounterActivity extends AppCompatActivity {
 
     private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
 
     private Realm realm;
-    private SyncSession session;
     private CRDTCounter counter;
     private SyncUser user;
-    private AtomicBoolean downloadingChanges = new AtomicBoolean(false);
-    private AtomicBoolean uploadingChanges = new AtomicBoolean(false);
-    private ProgressListener downloadListener = new ProgressListener() {
-        @Override
-        public void onChange(Progress progress) {
-            downloadingChanges.set(!progress.isTransferComplete());
-            runOnUiThread(updateProgressBar);
-        }
-    };
-    private ProgressListener uploadListener = new ProgressListener() {
-        @Override
-        public void onChange(Progress progress) {
-            uploadingChanges.set(!progress.isTransferComplete());
-            runOnUiThread(updateProgressBar);
-        }
-    };
-    private Runnable updateProgressBar = new Runnable() {
-        @Override
-        public void run() {
-            updateProgressBar(downloadingChanges.get(), uploadingChanges.get());
-        }
-    };
-
 
     @BindView(R.id.text_counter) TextView counterView;
-    @BindView(R.id.progressbar) MaterialProgressBar progressBar;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -121,21 +86,12 @@ public void onChange(CRDTCounter counter) {
                 }
             });
             counterView.setText("0");
-
-            // Setup progress listeners for indeterminate progress bars
-            session = SyncManager.getSession(config);
-            session.addDownloadProgressListener(ProgressMode.INDEFINITELY, downloadListener);
-            session.addUploadProgressListener(ProgressMode.INDEFINITELY, uploadListener);
         }
     }
 
     @Override
     protected void onStop() {
         super.onStop();
-        if (session != null) {
-            session.removeProgressListener(downloadListener);
-            session.removeProgressListener(uploadListener);
-        }
         closeRealm();
         user = null;
     }
@@ -176,22 +132,6 @@ public void decrementCounter() {
         adjustCounter(-1);
     }
 
-    private void updateProgressBar(boolean downloading, boolean uploading) {
-        @ColorRes int color = android.R.color.black;
-        int visibility = View.VISIBLE;
-        if (downloading && uploading) {
-            color = R.color.progress_both;
-        } else if (downloading) {
-            color = R.color.progress_download;
-        } else if (uploading) {
-            color = R.color.progress_upload;
-        } else {
-            visibility = View.GONE;
-        }
-        progressBar.getIndeterminateDrawable().setColorFilter(getResources().getColor(color), PorterDuff.Mode.SRC_IN);
-        progressBar.setVisibility(visibility);
-    }
-
     private void adjustCounter(final int adjustment) {
         // A synchronized Realm can get written to at any point in time, so doing synchronous writes on the UI
         // thread is HIGHLY discouraged as it might block longer than intended. Only use async transactions.
diff --git a/examples/objectServerExample/src/main/res/layout/activity_counter.xml b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
index df73031aa7..62127eca0d 100644
--- a/examples/objectServerExample/src/main/res/layout/activity_counter.xml
+++ b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
@@ -1,9 +1,7 @@
 <RelativeLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    xmlns:app="http://schemas.android.com/apk/res-auto">
-
+    android:layout_height="match_parent">
 
     <LinearLayout
         android:layout_width="match_parent"
@@ -36,15 +34,4 @@
         android:fontFamily="sans-serif-light"
         android:textSize="160sp"/>
 
-    <me.zhanghai.android.materialprogressbar.MaterialProgressBar
-        android:id="@+id/progressbar"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:layout_gravity="top"
-        android:indeterminate="true"
-        app:mpb_progressStyle="horizontal"
-        android:visibility="gone"
-        style="@style/Widget.MaterialProgressBar.ProgressBar.Horizontal.NoPadding"
-        />
-
 </RelativeLayout>
diff --git a/examples/objectServerExample/src/main/res/values/realm_colors.xml b/examples/objectServerExample/src/main/res/values/realm_colors.xml
index 8fec3b9456..aada8ea195 100644
--- a/examples/objectServerExample/src/main/res/values/realm_colors.xml
+++ b/examples/objectServerExample/src/main/res/values/realm_colors.xml
@@ -20,9 +20,4 @@
     <color name="flamingo_darker">#d64881</color>
     <color name="touch_area_pressed">#dadada</color>
 
-    // Progress bar colors
-    <color name="progress_upload">#EF5350</color>
-    <color name="progress_download">#9CCC65</color>
-    <color name="progress_both">#FFA726</color>
-
 </resources>
\ No newline at end of file
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index fa33ca5ad9..e9c7a2d0f1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -196,12 +196,12 @@ public void sort() {
 
     @Test
     public void clear() {
-        assertEquals(table.size(), 4);
+        assertEquals(4, table.size());
         Collection collection = new Collection(sharedRealm, table.where());
         sharedRealm.beginTransaction();
         collection.clear();
         sharedRealm.commitTransaction();
-        assertEquals(table.size(), 0);
+        assertEquals(0, table.size());
     }
 
     @Test
@@ -217,7 +217,7 @@ public void indexOf() {
 
         Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
         UncheckedRow row = table.getUncheckedRow(0);
-        assertEquals(collection.indexOf(row), 3);
+        assertEquals(3, collection.indexOf(row));
     }
 
     @Test
@@ -225,7 +225,7 @@ public void indexOf_long() {
         SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
 
         Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
-        assertEquals(collection.indexOf(0), 3);
+        assertEquals(3, collection.indexOf(0));
     }
 
     @Test
@@ -240,8 +240,8 @@ public void distinct() {
         assertEquals(3, collection.size());
         assertEquals(2, collection2.size());
 
-        assertEquals(collection2.getUncheckedRow(0).getLong(2), 3);
-        assertEquals(collection2.getUncheckedRow(1).getLong(2), 1);
+        assertEquals(3, collection2.getUncheckedRow(0).getLong(2));
+        assertEquals(1, collection2.getUncheckedRow(1).getLong(2));
     }
 
     // 1. Create a results and add listener.
@@ -257,8 +257,8 @@ public void addListener_shouldBeCalledToReturnTheQueryResults() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 4);
+                assertEquals(collection, collection1);
+                assertEquals(4, collection1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -277,8 +277,8 @@ public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 4);
+                assertEquals(collection, collection1);
+                assertEquals(4, collection1.size());
                 sharedRealm.close();
                 onChangeCalled.set(true);
             }
@@ -323,7 +323,7 @@ public void addListener_triggeredByRefresh() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection element) {
-                assertEquals(latch.getCount(), 1);
+                assertEquals(1, latch.getCount());
                 latch.countDown();
             }
         });
@@ -346,8 +346,8 @@ public void addListener_queryNotReturned() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 5);
+                assertEquals(collection, collection1);
+                assertEquals(5, collection1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -368,8 +368,8 @@ public void addListener_queryReturned() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 5);
+                assertEquals(collection, collection1);
+                assertEquals(5, collection1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -394,10 +394,10 @@ public void addListener_triggeredByLocalCommit() {
             public void onChange(Collection collection1) {
                 switch (listenerCounter.getAndIncrement()) {
                     case 0:
-                        assertEquals(collection1.size(), 4);
+                        assertEquals(4, collection1.size());
                         break;
                     case 1:
-                        assertEquals(collection1.size(), 5);
+                        assertEquals(5, collection1.size());
                         sharedRealm.close();
                         break;
                     default:
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
deleted file mode 100644
index 22c31bc2a5..0000000000
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.Locale;
-
-import static org.junit.Assert.assertEquals;
-
-@RunWith(AndroidJUnit4.class)
-public class ProgressTests {
-
-    @Test
-    public void getFractionTransferred() {
-        Object[][] testData = {
-            { 0L, 0L, 1.0D },
-            { 0L, 1L, 0.0D },
-            { 1L, 1L, 1.0D },
-            { 1L, 2L, 0.5D }
-        };
-
-        for (Object[] test : testData) {
-            long transferredBytes = (long) test[0];
-            long transferableBytes = (long) test[1];
-            double fraction = (double) test[2];
-            Progress progress = new Progress(transferredBytes, transferableBytes);
-            String errorMessage = String.format(Locale.US, "Failed with: (%d, %d)", transferredBytes, transferableBytes);
-            assertEquals(errorMessage, fraction, progress.getFractionTransferred(), 0.0D);
-        }
-    }
-
-    @Test
-    public void getTransferredBytes () {
-        long[] testData = { 0, Long.MAX_VALUE };
-
-        for (long transferredBytes : testData) {
-            String errorMessage = String.format(Locale.US, "Failed with: %d", transferredBytes);
-            Progress progress = new Progress(transferredBytes, Long.MAX_VALUE);
-            assertEquals(errorMessage, transferredBytes, progress.getTransferredBytes());
-        }
-    }
-
-    @Test
-    public void getTransferableBytes () {
-        long[] testData = { 0, Long.MAX_VALUE };
-
-        for (long transferableBytes : testData) {
-            String errorMessage = String.format(Locale.US, "Failed with: %d", transferableBytes);
-            Progress progress = new Progress(0, transferableBytes);
-            assertEquals(errorMessage, transferableBytes, progress.getTransferableBytes());
-        }
-    }
-
-}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 7ee77dfa61..a360d94fed 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -61,54 +61,6 @@ public void get_syncValues() {
         assertEquals(configuration, session.getConfiguration());
     }
 
-    @Test
-    public void addDownloadProgressListener_nullThrows() {
-        SyncSession session = SyncManager.getSession(configuration);
-        try {
-            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void addUploadProgressListener_nullThrows() {
-        SyncSession session = SyncManager.getSession(configuration);
-        try {
-            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void removeProgressListener() {
-        Realm realm = Realm.getInstance(configuration);
-        SyncSession session = SyncManager.getSession(configuration);
-        ProgressListener[] listeners = new ProgressListener[] {
-                null,
-                new ProgressListener() {
-                    @Override
-                    public void onChange(Progress progress) {
-                        // Listener 1, not present
-                    }
-                },
-                new ProgressListener() {
-                    @Override
-                    public void onChange(Progress progress) {
-                        // Listener 2, present
-                    }
-                }
-        };
-        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);
-
-        // Check that remove works unconditionally for all input
-        for (ProgressListener listener : listeners) {
-            session.removeProgressListener(listener);
-        }
-        realm.close();
-    }
-
     // Check that a Client Reset is correctly reported.
     @Test
     @RunTestInLooperThread
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 88e80e151f..e3a58bbad2 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -15,7 +15,6 @@
  */
 
 #include <jni.h>
-#include <string>
 
 #include "io_realm_SyncSession.h"
 
@@ -23,22 +22,22 @@
 #include "object-store/src/sync/sync_session.hpp"
 
 #include "util.hpp"
-#include "jni_util/jni_utils.hpp"
 
+using namespace std;
 using namespace realm;
 using namespace sync;
 
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
-                                                                              jstring j_local_realm_path,
-                                                                              jstring j_access_token,
+                                                                              jstring localRealmPath,
+                                                                              jstring accessToken,
                                                                               jstring sync_realm_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor local_realm_path(env, j_local_realm_path);
+        JStringAccessor local_realm_path(env, localRealmPath);
         auto session = SyncManager::shared().get_existing_session(local_realm_path);
         if (session) {
-            JStringAccessor access_token(env, j_access_token);
+            JStringAccessor access_token(env, accessToken);
             JStringAccessor realm_url(env, sync_realm_url);
             session->refresh_access_token(access_token, std::string(realm_url));
             return JNI_TRUE;
@@ -50,67 +49,3 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JN
     CATCH_STD()
     return JNI_FALSE;
 }
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddProgressListener(JNIEnv* env, jclass,
-                                                                            jstring j_local_realm_path,
-                                                                            jlong listener_id, jint direction,
-                                                                            jboolean is_streaming)
-{
-    try {
-        // JNIEnv is thread confined, so we need a deep copy in order to capture the string in the lambda
-        realm::StringData local_realm_path(JStringAccessor(env, j_local_realm_path));
-        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
-        if (!session) {
-            // FIXME: We should lift this restriction
-            ThrowException(env, IllegalState,
-                           "Cannot register a progress listener before a session is "
-                           "created. A session will be created after the first call to Realm.getInstance().");
-            return static_cast<jlong>(0);
-        }
-
-        SyncSession::NotifierType type =
-            (direction == 1) ? SyncSession::NotifierType::download : SyncSession::NotifierType::upload;
-
-        std::function<SyncProgressNotifierCallback> callback = [local_realm_path, listener_id](
-            uint64_t transferred, uint64_t transferrable) {
-            JNIEnv* local_env = jni_util::JniUtils::get_env(true);
-
-            auto path = to_jstring(local_env, local_realm_path);
-            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_progress_listener, path, listener_id,
-                                            static_cast<jlong>(transferred), static_cast<jlong>(transferrable));
-
-            // All exceptions will be caught on the Java side of handlers, but errors will still end
-            // up here, so we need to do something sensible with them.
-            // Throwing a C++ exception will terminate the sync thread and cause the pending Java
-            // exception to become visible. For some (unknown) reason Logcat will not see the C++
-            // exception, only the Java one.
-            if (local_env->ExceptionCheck()) {
-                local_env->ExceptionDescribe();
-                throw std::runtime_error("An unexpected Error was thrown from Java. See LogCat");
-            }
-
-            // Callback happens on a thread not controlled by the JVM. So manual cleanup is
-            // required.
-            local_env->DeleteLocalRef(path);
-        };
-        uint64_t token = session->register_progress_notifier(callback, type, to_bool(is_streaming));
-        return static_cast<jlong>(token);
-    }
-    CATCH_STD()
-    return static_cast<jlong>(0);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeRemoveProgressListener(JNIEnv* env, jclass,
-                                                                              jstring j_local_realm_path,
-                                                                              jlong listener_token)
-{
-    try {
-        JStringAccessor local_realm_path(env, j_local_realm_path);
-        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
-        if (session) {
-            session->unregister_progress_notifier(static_cast<uint64_t>(listener_token));
-        }
-    }
-    CATCH_STD()
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 7946856b1c..48e47cf726 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -53,10 +53,6 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
         java_util_date = GetClass(env, "java/util/Date");
         java_util_date_init = env->GetMethodID(java_util_date, "<init>", "(J)V");
-#if REALM_ENABLE_SYNC
-        java_syncmanager_class = GetClass(env, "io/realm/SyncManager");
-        java_notify_progress_listener = env->GetStaticMethodID(java_syncmanager_class, "notifyProgressListener", "(Ljava/lang/String;JJJ)V");
-#endif
     }
 
     return JNI_VERSION_1_6;
@@ -74,9 +70,6 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
         env->DeleteGlobalRef(java_lang_double);
         env->DeleteGlobalRef(java_util_date);
         env->DeleteGlobalRef(java_lang_string);
-        #if REALM_ENABLE_SYNC
-            env->DeleteGlobalRef(java_syncmanager_class);
-        #endif
         JniUtils::release();
     }
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index f29c5a3335..283c948fba 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -29,7 +29,8 @@ static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
 // Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
 // DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
 // program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap
-// it because the size of local reference table is relative small (512 bytes on Android).
+// it
+// because the size of local reference table is relative small (512 bytes on Android).
 template <typename T>
 class JavaLocalRef {
 public:
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 8908d1ae3e..e562c12564 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -43,10 +43,6 @@ jclass java_lang_string;
 jmethodID java_lang_double_init;
 jclass java_util_date;
 jmethodID java_util_date_init;
-#if REALM_ENABLE_SYNC
-jclass java_syncmanager_class;
-jmethodID java_notify_progress_listener;
-#endif
 
 void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 615887dfa7..c0ec632f62 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -703,10 +703,6 @@ extern jclass java_lang_string;
 extern jmethodID java_lang_double_init;
 extern jclass java_util_date;
 extern jmethodID java_util_date_init;
-#if REALM_ENABLE_SYNC
-extern jclass java_syncmanager_class;
-extern jmethodID java_notify_progress_listener;
-#endif
 
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
deleted file mode 100644
index cac85f8077..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.util;
-
-/**
- * Copy from the Android framework to avoid the dependency on Android classes + slight adjustment
- * to support older versions of Android.
- *
- * Container to ease passing around a tuple of two objects. This object provides a sensible
- * implementation of equals(), returning true if equals() is true on each of the contained
- * objects.
- */
-public class Pair<F, S> {
-    public F first;
-    public S second;
-
-    /**
-     * Constructor for a Pair.
-     *
-     * @param first the first object in the Pair.
-     * @param second the second object in the pair.
-     */
-    public Pair(F first, S second) {
-        this.first = first;
-        this.second = second;
-    }
-
-    /**
-     * Checks the two objects for equality by delegating to their respective
-     * {@link Object#equals(Object)} methods.
-     *
-     * @param o the {@link Pair} to which this one is to be checked for equality.
-     * @return true if the underlying objects of the Pair are both considered
-     *         equal.
-     */
-    @Override
-    public boolean equals(Object o) {
-        if (!(o instanceof Pair)) {
-            return false;
-        }
-        Pair<?, ?> p = (Pair<?, ?>) o;
-        return equals(p.first, first) && (equals(p.second, second));
-    }
-
-    private boolean equals(Object a, Object b) {
-        return (a == b) || (a != null && a.equals(b));
-    }
-
-    /**
-     * Compute a hash code using the hash codes of the underlying objects.
-     *
-     * @return a hashcode of the Pair.
-     */
-    @Override
-    public int hashCode() {
-        return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());
-    }
-
-    @Override
-    public String toString() {
-        return "Pair{" + String.valueOf(first) + " " + String.valueOf(second) + "}";
-    }
-
-    /**
-     * Convenience method for creating an appropriately typed pair.
-     *
-     * @param a the first object in the Pair.
-     * @param b the second object in the pair.
-     * @return a Pair that is templatized with the types of a and b.
-     */
-    public static <A, B> Pair <A, B> create(A a, B b) {
-        return new Pair<A, B>(a, b);
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/Progress.java b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
deleted file mode 100644
index db4e7cdc9a..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/Progress.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-/**
- * Class used to encapsulate progress notifications when either downloading or uploading Realm data.
- * Each instance of this class is an immutable snapshot of the current progress.
- * <p>
- * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, the progress reported by
- * {@link #getFractionTransferred()} can both increase and decrease since more changes might be added while
- * the progres listener is registered. This means it is possible for one notification to report
- * {@code true} for {@link #isTransferComplete()}, and then on the next event report {@code false}.
- * <p>
- * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, progress can only ever
- * increase, and once {@link #isTransferComplete()} returns {@code true}, no further events will be generated.
- *
- * @see SyncSession#addDownloadProgressListener(ProgressMode, ProgressListener)
- * @see SyncSession#addUploadProgressListener(ProgressMode, ProgressListener)
- */
-public class Progress {
-
-    private final long transferredBytes;
-    private final long transferableBytes;
-
-    /**
-     * Creates a snapshot of the current progress when downloading or uploading changes.
-     *
-     * @param transferredBytes number of bytes transferred.
-     * @param transferableBytes total number of bytes that needs to be transferred (including those already transferred).
-     */
-    Progress(long transferredBytes, long transferableBytes) {
-        this.transferredBytes = transferredBytes;
-        this.transferableBytes = transferableBytes;
-    }
-
-    /**
-     * Returns the total number of bytes that has been transferred since the {@link ProgressListener} was added.
-     *
-     * @return the total number of bytes transferred since the {@link ProgressListener} was added.
-     */
-    public long getTransferredBytes() {
-        return transferredBytes;
-    }
-
-    /**
-     * Returns the total number of transferable bytes (bytes that have been transferred + bytes pending transfer).
-     * <p>
-     * If the {@link ProgressListener} is tracking downloads, this number represents the size of the changesets
-     * generated by all other clients using the Realm.
-     * <p>
-     * If the {@link ProgressListener} is tracking uploads, this number represents the size of changesets created
-     * locally.
-     *
-     * @return the total number of bytes that has been transferred + number of bytes still pending transfer.
-     */
-    public long getTransferableBytes() {
-        return transferableBytes;
-    }
-
-    /**
-     * The fraction of bytes transferred out of all transferable bytes. Counting from since the {@link ProgressListener}
-     * was added.
-     *
-     * @return a number between {@code 0.0} and {@code 1.0}, where {@code 0.0} represents that no data has been
-     *         transferred yet, and {@code 1.0} that all data has been transferred.
-     */
-    public double getFractionTransferred() {
-        if (transferableBytes == 0) {
-            return 1.0D;
-        } else {
-            double percentage = (double) transferredBytes / (double) transferableBytes;
-            return percentage > 1.0D ? 1.0D : percentage;
-        }
-    }
-
-    /**
-     * Returns {@code true} when all pending bytes have been transferred.
-     * <p>
-     * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, this method can return
-     * {@code false} for subsequent events after returning {@code true}.
-     * <p>
-     * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, when this method
-     * returns {@code true}, no more progress events will be sent.
-     *
-     * @return {@code true} if all changes have been transferred, {@code false} otherwise.
-     */
-    public boolean isTransferComplete() {
-        return transferredBytes >= transferableBytes;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        Progress progress = (Progress) o;
-
-        if (transferredBytes != progress.transferredBytes) return false;
-        return transferableBytes == progress.transferableBytes;
-
-    }
-
-    @Override
-    public int hashCode() {
-        int result = (int) (transferredBytes ^ (transferredBytes >>> 32));
-        result = 31 * result + (int) (transferableBytes ^ (transferableBytes >>> 32));
-        return result;
-    }
-
-    @Override
-    public String toString() {
-        return "Progress{" +
-                "transferredBytes=" + transferredBytes +
-                ", transferableBytes=" + transferableBytes +
-                '}';
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
deleted file mode 100644
index 5b5798f2d4..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-/**
- * Interface used when interested in updates on data either being uploaded to or downloaded from
- * a Realm Object Server.
- */
-public interface ProgressListener {
-    /**
-     * This method will be called periodically from the underlying Object Server Client responsible
-     * for uploading and downloading changes from the remote Object Server.
-     * <p>
-     * This callback will <i>not</i> happen on the UI thread, but on the worker thread controlling
-     * the Object Server Client. Use {@code Activity.runOnUiThread(Runnable)} or similar to update
-     * any UI elements.
-     * <p>
-     * <pre>
-     * {@code
-     * // Adding an upload progress listener that completes when all known changes have been
-     * // uploaded.
-     * session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-     *   \@Override
-     *    public void onChange(Progress progress) {
-     *      activity.runOnUiThread(new Runnable() {
-     *        \@Override
-     *         public void run() {
-     *           updateProgressBar(progress);
-     *         }
-     *      });
-     *      if (progress.isTransferComplete() {
-     *        session.removeProgressListener(this);
-     *      }
-     *    }
-     * });
-     * }
-     * </pre>
-     *
-     * @param progress an immutable progress change event with information about current progress. This object is thread safe.
-     */
-    void onChange(Progress progress);
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
deleted file mode 100644
index f80f63150d..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-/**
- * Enum describing how to listen to progress changes.
- */
-public enum ProgressMode {
-    /**
-     * When registering the {@link ProgressListener}, it will record the current size of changes, and will only
-     * continue to report progress updates until those changes have been either downloaded or uploaded. After that
-     * the progress listener will not report any further changes.
-     * <p>
-     * This means that listeners registered in this mode should be done <i>before</i> changes are written to
-     * the Realm.
-     * <p>
-     * Progress reported in this mode will only ever increase.
-     * <p>
-     * This is useful when e.g. reporting progress when downloading a Realm for the first time.
-     */
-    CURRENT_CHANGES,
-
-    /**
-     * A {@link ProgressListener} registered in this mode, will continue to report progress changes, even
-     * if changes are being added after the listener was registered.
-     * <p>
-     * Progress reported in this mode can both increase and decrease, e.g. if large amounts of data is
-     * written after registering the listener.
-     * <p>
-     * This is useful when you want to track if all changes have been uploaded to the server from the device.
-     */
-    INDEFINITELY
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index abf5951752..0d37ce79eb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,9 +16,9 @@
 
 package io.realm;
 
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -90,7 +90,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         }
     };
     // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
-    private static Map<String, SyncSession> sessions = new ConcurrentHashMap<>();
+    private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
     private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
 
     // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
@@ -248,24 +248,6 @@ private static synchronized void notifyErrorHandler(int errorCode, String errorM
         }
     }
 
-    /**
-     * All progress listener events from native Sync are reported to this method.
-     * It costs 2 HashMap lookups for each listener triggered (one to find the session, one to
-     * find the progress listener), but it means we don't have to cache anything on the C++ side which
-     * can leak since we don't have control over the session lifecycle.
-     */
-    @SuppressWarnings("unused")
-    private static synchronized void notifyProgressListener(String localRealmPath, long listenerId, long transferedBytes, long transferableBytes) {
-        SyncSession session = sessions.get(localRealmPath);
-        if (session != null) {
-            try {
-                session.notifyProgressListener(listenerId, transferedBytes, transferableBytes);
-            } catch (Exception exception) {
-                RealmLog.error(exception);
-            }
-        }
-    }
-
     /**
      * This is called from the Object Store (through JNI) to request an {@code access_token} for
      * the session specified by sessionPath.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index e301800027..b456318617 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -17,16 +17,11 @@
 package io.realm;
 
 import java.net.URI;
-import java.util.HashMap;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.Map;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
 
 import io.realm.internal.Keep;
 import io.realm.internal.KeepMember;
@@ -38,7 +33,6 @@
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
-import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 
 /**
@@ -56,8 +50,6 @@
 public class SyncSession {
     private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
     private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
-    private final static int DIRECTION_DOWNLOAD = 1;
-    private final static int DIRECTION_UPLOAD = 2;
 
     private final SyncConfiguration configuration;
     private final ErrorHandler errorHandler;
@@ -68,19 +60,6 @@
     private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean(false);
     private volatile boolean isClosed = false;
 
-    // We need JavaId -> Listener so C++ can trigger callbacks without keeping a reference to the
-    // jobject, which would require a similar map on the C++ side.
-    // We need Listener -> Token map in order to remove the progress listener in C++ from Java.
-    private Map<Long, Pair<ProgressListener, Progress>> listenerIdToProgressListenerMap = new HashMap<>();
-    private Map<ProgressListener, Long> progressListenerToOsTokenMap = new IdentityHashMap<>();
-    // Counter used to assign all ProgressListeners on this session with a unique id.
-    // ListenerId is created by Java to enable C++ to reference the java listener without holding
-    // a reference to the actual object.
-    // ListenerToken is the same concept, but created by OS and represents the listener.
-    // We can unfortunately not just use the ListenerToken, since we need it to be available before
-    // we register the listener.
-    AtomicLong progressListenerId = new AtomicLong(-1);
-
     SyncSession(SyncConfiguration configuration) {
         this.configuration = configuration;
         this.errorHandler = configuration.getErrorHandler();
@@ -131,105 +110,6 @@ void notifySessionError(int errorCode, String errorMessage) {
         }
     }
 
-    // Called from native code
-    @SuppressWarnings("unused")
-    @KeepMember
-    synchronized void notifyProgressListener(long listenerId, long transferredBytes, long transferableBytes) {
-        Pair<ProgressListener, Progress> listener = listenerIdToProgressListenerMap.get(listenerId);
-        if (listener != null) {
-            Progress newProgressNotification = new Progress(transferredBytes, transferableBytes);
-            if (!newProgressNotification.equals(listener.second)) {
-                listener.first.onChange(newProgressNotification);
-                listener.second = newProgressNotification;
-            }
-        } else {
-            RealmLog.debug("Trying unknown listener failed: " + listenerId);
-        }
-    }
-    
-    /**
-     * Adds a progress listener tracking changes that need to be downloaded from the Realm Object
-     * Server.
-     * <p>
-     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
-     * afterwards.
-     *
-     * @param mode type of mode used. See {@link ProgressMode} for more information.
-     * @param listener the listener to register.
-     */
-    public synchronized void addDownloadProgressListener(ProgressMode mode, ProgressListener listener) {
-        addProgressListener(mode, DIRECTION_DOWNLOAD, listener);
-    }
-
-    /**
-     * Adds a progress listener tracking changes that need to be uploaded from the device to the
-     * Realm Object Server.
-     * <p>
-     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
-     * afterwards.
-     *
-     * @param mode type of mode used. See {@link ProgressMode} for more information.
-     * @param listener the listener to register.
-     */
-    public synchronized void addUploadProgressListener(ProgressMode mode, ProgressListener listener) {
-        addProgressListener(mode, DIRECTION_UPLOAD, listener);
-    }
-
-    /**
-     * Removes a progress listener. If the listener wasn't registered, this method will do nothing.
-     *
-     * @param listener listener to remove.
-     */
-    public synchronized void removeProgressListener(ProgressListener listener) {
-        if (listener == null) {
-            return;
-        }
-        // If an exception is thrown somewhere in here, we will most likely leave the various
-        // maps in an inconsistent manner. Not much we can do about it.
-        Long token = progressListenerToOsTokenMap.remove(listener);
-        if (token != null) {
-            Iterator<Map.Entry<Long, Pair<ProgressListener, Progress>>> it = listenerIdToProgressListenerMap.entrySet().iterator();
-            while (it.hasNext()) {
-                Map.Entry<Long, Pair<ProgressListener, Progress>> entry = it.next();
-                if (entry.getValue().first.equals(listener)) {
-                    it.remove();
-                    break;
-                }
-            }
-            nativeRemoveProgressListener(configuration.getPath(), token);
-        }
-    }
-
-    private void addProgressListener(ProgressMode mode, int direction, ProgressListener listener) {
-        checkProgressListenerArguments(mode, listener);
-        boolean isStreaming = (mode == ProgressMode.INDEFINITELY);
-        long listenerId = progressListenerId.incrementAndGet();
-
-        // A listener might be triggered immediately as part of `nativeAddProgressListener`, so
-        // we need to make sure it can be found by SyncManager.notifyProgressListener()
-        listenerIdToProgressListenerMap.put(listenerId, new Pair<ProgressListener, Progress>(listener, null));
-        long listenerToken = nativeAddProgressListener(configuration.getPath(), listenerId , direction, isStreaming);
-        if (listenerToken == 0) {
-            // ObjectStore did not register the listener. This can happen if a
-            // listener is registered with ProgressMode.CURRENT_CHANGES and no changes actually
-            // exists. In that case the listener was triggered immediately and we just need
-            // to clean it up, since it will never be called again.
-            listenerIdToProgressListenerMap.remove(listenerId);
-        } else {
-            // Listener was properly registered.
-            progressListenerToOsTokenMap.put(listener, listenerToken);
-        }
-    }
-
-    private void checkProgressListenerArguments(ProgressMode mode, ProgressListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException("Non-null 'listener' required.");
-        }
-        if (mode == null) {
-            throw new IllegalArgumentException("Non-null 'mode' required.");
-        }
-    }
-
     void close() {
         isClosed = true;
         if (networkRequest != null) {
@@ -472,7 +352,5 @@ private void clearScheduledAccessTokenRefresh() {
     }
 
     private static native boolean nativeRefreshAccessToken(String path, String accessToken, String authURL);
-    private static native long nativeAddProgressListener(String localRealmPath, long listenerId, int direction, boolean isStreaming);
-    private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
 }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 7bbf233fde..ae1cda7ac7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -6,7 +6,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.BaseIntegrationTest;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
similarity index 59%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
rename to realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
index 57e50f7616..764b511ee7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
@@ -14,31 +14,19 @@
  * limitations under the License.
  */
 
-package io.realm;
+package io.realm.objectserver;
 
 import android.support.test.InstrumentationRegistry;
 
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
-import java.util.UUID;
-
-import io.realm.ObjectServerError;
 import io.realm.Realm;
-import io.realm.SyncConfiguration;
-import io.realm.SyncCredentials;
 import io.realm.SyncManager;
-import io.realm.SyncSession;
-import io.realm.SyncUser;
 import io.realm.log.RealmLog;
-import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.HttpUtils;
-import io.realm.objectserver.utils.UserFactory;
-
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
 
-public class BaseIntegrationTest {
+class BaseIntegrationTest {
 
     @BeforeClass
     public static void setUp () throws Exception {
@@ -57,28 +45,8 @@ public static void setUp () throws Exception {
     public static void tearDown () throws Exception {
         try {
             HttpUtils.stopSyncServer();
-            SyncManager.reset();
         } catch (Exception e) {
             RealmLog.error("Failed to stop Sync Server", e);
         }
     }
-
-    /**
-     * Login the admin user synchronously.
-     */
-    public SyncUser loginAdminUser() {
-        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
-        return SyncUser.login(credentials, Constants.AUTH_URL);
-    }
-
-    /**
-     * Create new random user and log in.
-     */
-    public SyncUser loginUser() {
-        String id = UUID.randomUUID().toString();
-        SyncCredentials credentials = SyncCredentials.usernamePassword(id, "password", true);
-        return SyncUser.login(credentials, Constants.AUTH_URL);
-    }
-
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index bfe2e752f1..f78c34acfe 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -26,7 +26,6 @@
 import java.util.Date;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 56ba8589e5..dfd7b31859 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -32,7 +32,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import io.realm.BaseIntegrationTest;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
deleted file mode 100644
index 54473d4ec7..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver;
-
-import android.support.annotation.NonNull;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.net.URI;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import io.realm.BaseIntegrationTest;
-import io.realm.Progress;
-import io.realm.ProgressListener;
-import io.realm.ProgressMode;
-import io.realm.Realm;
-import io.realm.SyncConfiguration;
-import io.realm.SyncManager;
-import io.realm.SyncSession;
-import io.realm.SyncUser;
-import io.realm.TestHelper;
-import io.realm.entities.AllTypes;
-import io.realm.objectserver.utils.Constants;
-import io.realm.rule.TestSyncConfigurationFactory;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@RunWith(AndroidJUnit4.class)
-public class ProgressListenerTests extends BaseIntegrationTest {
-
-    private static final long TEST_SIZE = 10;
-    @Rule
-    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
-
-    @NonNull
-    private SyncConfiguration createSyncConfig() {
-        SyncUser user = loginAdminUser();
-        return configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL).build();
-    }
-
-    private void writeSampleData(Realm realm) {
-        realm.beginTransaction();
-        for (int i = 0; i < TEST_SIZE; i++) {
-            AllTypes obj = realm.createObject(AllTypes.class);
-            obj.setColumnString("Object " + i);
-        }
-        realm.commitTransaction();
-    }
-
-    private void assertTransferComplete(Progress progress, boolean nonZeroChange) {
-        assertTrue(progress.isTransferComplete());
-        assertEquals(1.0D, progress.getFractionTransferred(), 0.0D);
-        assertEquals(progress.getTransferableBytes(), progress.getTransferredBytes());
-        if (nonZeroChange) {
-            assertTrue(progress.getTransferredBytes() > 0);
-        }
-    }
-
-    // Create remote data for a given user.
-    private URI createRemoteData(SyncUser user) {
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_USER_REALM).build();
-        final Realm realm = Realm.getInstance(config);
-        writeSampleData(realm);
-        final CountDownLatch changesUploaded = new CountDownLatch(1);
-        final SyncSession session = SyncManager.getSession(config);
-        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    session.removeProgressListener(this);
-                    changesUploaded.countDown();
-                }
-            }
-        });
-        TestHelper.awaitOrFail(changesUploaded);
-        realm.close();
-        return config.getServerUrl();
-    }
-
-    @Test
-    public void downloadProgressListener_changesOnly() {
-        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
-        SyncUser userWithData = loginUser();
-        URI serverUrl = createRemoteData(userWithData);
-        SyncUser adminUser = loginAdminUser();
-
-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
-        Realm realm = Realm.getInstance(config);
-        SyncSession session = SyncManager.getSession(config);
-        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    assertTransferComplete(progress, true);
-                    Realm realm = Realm.getInstance(config);
-                    assertEquals(TEST_SIZE, realm.where(AllTypes.class).count());
-                    realm.close();
-                    allChangesDownloaded.countDown();
-                }
-            }
-        });
-        TestHelper.awaitOrFail(allChangesDownloaded);
-        realm.close();
-        userWithData.logout();
-        adminUser.logout();
-    }
-
-    @Test
-    public void downloadProgressListener_indefinitely() throws InterruptedException {
-        final AtomicInteger transferCompleted = new AtomicInteger(0);
-        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
-        final CountDownLatch startWorker = new CountDownLatch(1);
-        final SyncUser userWithData = loginUser();
-
-        URI serverUrl = createRemoteData(userWithData);
-
-        // Create worker thread that puts data into another Realm.
-        // This is to avoid blocking one progress listener while waiting for another to complete.
-        Thread worker = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                TestHelper.awaitOrFail(startWorker);
-                createRemoteData(userWithData);
-            }
-        });
-        worker.start();
-
-        SyncUser adminUser = loginAdminUser();
-        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
-        Realm adminRealm = Realm.getInstance(adminConfig);
-        Realm userRealm = Realm.getInstance(configFactory.createSyncConfigurationBuilder(userWithData, Constants.SYNC_USER_REALM).build()); // Keep session alive
-        SyncSession session = SyncManager.getSession(adminConfig);
-        session.addDownloadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    switch (transferCompleted.incrementAndGet()) {
-                        case 1:
-                            // Initial trigger when registering
-                            assertTransferComplete(progress, false);
-                            break;
-                        case 2: {
-                            assertTransferComplete(progress, true);
-                            Realm adminRealm = Realm.getInstance(adminConfig);
-                            assertEquals(TEST_SIZE, adminRealm.where(AllTypes.class).count());
-                            adminRealm.close();
-                            startWorker.countDown();
-                            break;
-                        }
-                        case 3: {
-                            assertTransferComplete(progress, true);
-                            Realm adminRealm = Realm.getInstance(adminConfig);
-                            assertEquals(TEST_SIZE * 2, adminRealm.where(AllTypes.class).count());
-                            adminRealm.close();
-                            allChangesDownloaded.countDown();
-                            break;
-                        }
-                        default:
-                            fail();
-                    }
-                }
-            }
-        });
-        TestHelper.awaitOrFail(allChangesDownloaded);
-        adminRealm.close();
-        userRealm.close();
-        userWithData.logout();
-        adminUser.logout();
-        worker.join();
-    }
-
-    @Test
-    public void uploadProgressListener_changesOnly() {
-        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
-        SyncConfiguration config = createSyncConfig();
-        Realm realm = Realm.getInstance(config);
-        writeSampleData(realm);
-
-        SyncSession session = SyncManager.getSession(config);
-        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    assertTransferComplete(progress, true);
-                    allChangeUploaded.countDown();
-                }
-            }
-        });
-
-        TestHelper.awaitOrFail(allChangeUploaded);
-        realm.close();
-    }
-
-    @Test
-    public void uploadProgressListener_indefinitely() {
-        final AtomicInteger transferCompleted = new AtomicInteger(0);
-        final CountDownLatch testDone = new CountDownLatch(1);
-        final SyncConfiguration config = createSyncConfig();
-        Realm realm = Realm.getInstance(config);
-
-        writeSampleData(realm); // Write first batch of sample data
-        SyncSession session = SyncManager.getSession(config);
-        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    switch(transferCompleted.incrementAndGet()) {
-                        case 1:
-                            Realm realm = Realm.getInstance(config);
-                            writeSampleData(realm);
-                            realm.close();
-                            break;
-                        case 2:
-                            assertTransferComplete(progress, true);
-                            testDone.countDown();
-                            break;
-                        default:
-                            fail("Unsupported number of transfers completed: " + transferCompleted.get());
-                    }
-                }
-            }
-        });
-
-        TestHelper.awaitOrFail(testDone);
-        realm.close();
-    }
-
-    @Test
-    public void addListenerInsideCallback() {
-        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
-        final SyncConfiguration config = createSyncConfig();
-        Realm realm = Realm.getInstance(config);
-        writeSampleData(realm);
-
-        final SyncSession session = SyncManager.getSession(config);
-        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    Realm realm = Realm.getInstance(config);
-                    writeSampleData(realm);
-                    realm.close();
-                    session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-                        @Override
-                        public void onChange(Progress progress) {
-                            if (progress.isTransferComplete()) {
-                                allChangeUploaded.countDown();
-                            }
-                        }
-                    });
-                }
-            }
-        });
-
-        TestHelper.awaitOrFail(allChangeUploaded);
-        realm.close();
-    }
-
-    @Test
-    public void addListenerInsideCallback_mixProgressModes() {
-        final CountDownLatch allChangeUploaded = new CountDownLatch(3);
-        final AtomicBoolean progressCompletedReported = new AtomicBoolean(false);
-        final SyncConfiguration config = createSyncConfig();
-        Realm realm = Realm.getInstance(config);
-        writeSampleData(realm);
-
-        final SyncSession session = SyncManager.getSession(config);
-        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                if (progress.isTransferComplete()) {
-                    allChangeUploaded.countDown();
-                    if (progressCompletedReported.compareAndSet(false, true)) {
-                        Realm realm = Realm.getInstance(config);
-                        writeSampleData(realm);
-                        realm.close();
-                        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
-                            @Override
-                            public void onChange(Progress progress) {
-                                if (progress.isTransferComplete()) {
-                                    allChangeUploaded.countDown();
-                                }
-                            }
-                        });
-                    }
-                }
-            }
-        });
-
-        TestHelper.awaitOrFail(allChangeUploaded);
-        realm.close();
-    }
-
-    @Test
-    public void addProgressListener_triggerImmediatelyWhenRegistered() {
-        final SyncConfiguration config = createSyncConfig();
-        Realm realm = Realm.getInstance(config);
-        SyncSession session = SyncManager.getSession(config);
-
-        checkListener(session, ProgressMode.INDEFINITELY);
-        checkListener(session, ProgressMode.CURRENT_CHANGES);
-
-        realm.close();
-    }
-
-    private void checkListener(SyncSession session, ProgressMode progressMode) {
-        final CountDownLatch listenerCalled = new CountDownLatch(1);
-        session.addDownloadProgressListener(progressMode, new ProgressListener() {
-            @Override
-            public void onChange(Progress progress) {
-                listenerCalled.countDown();
-            }
-        });
-        TestHelper.awaitOrFail(listenerCalled);
-    }
-
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index a4c11802dd..e5347effc8 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -18,9 +18,8 @@
 
 public class Constants {
 
-    public static String SYNC_USER_REALM = "realm://127.0.0.1:9080/~/tests";
-    public static String SYNC_SERVER_URL = "realm://127.0.0.1:9080/tests";
-    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1:9080/tests2";
+    public static String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
+    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
 
     public static String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
     public static String AUTH_URL = AUTH_SERVER_URL + "auth";
