diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 328426dc3a..c56aa0c8c4 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -121,6 +121,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitGetFieldNamesMethod(writer);
         emitCreateOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
+        emitGetManagedMethod(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
         emitInsertMethod(writer);
@@ -982,8 +983,115 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
     }
     //@formatter:on
 
+    //@formatter:off
+    private void emitGetManagedMethod(JavaWriter writer) throws IOException {
+        writer.emitSingleLineComment("TODO create copyOrGetManaged");
+        writer.beginMethod(
+                qualifiedClassName, // Return type
+                "getManaged", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
+        );
+
+        writer
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
+                .emitSingleLineComment("TODO create managed for current thread")
+                .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
+                        " threads cannot be copied into this Realm instance.\")")
+                .endControlFlow();
+
+        // If object is already in the Realm there is nothing to update
+        writer
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
+                .emitStatement("return object")
+                .endControlFlow();
+
+        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
+
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)");
+        writer.beginControlFlow("if (cachedRealmObject != null)")
+                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+                .nextControlFlow("else");
+
+        if (!metadata.hasPrimaryKey()) {
+            writer.emitSingleLineComment("return copy(realm, object, update, cache)");
+            writer.emitStatement("return object");
+        } else {
+            writer
+                    .emitStatement("%s realmObject = null", qualifiedClassName)
+                    .emitStatement("boolean canUpdate = true")
+                    .emitSingleLineComment("boolean canUpdate = update")
+                    .beginControlFlow("if (canUpdate)")
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+
+            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
+            VariableElement primaryKeyElement = metadata.getPrimaryKey();
+            if (metadata.isNullable(primaryKeyElement)) {
+                if (Utils.isString(primaryKeyElement)) {
+                    writer
+                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
+                            .beginControlFlow("if (value == null)")
+                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .nextControlFlow("else")
+                            .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                            .endControlFlow();
+                } else {
+                    writer
+                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
+                            .beginControlFlow("if (value == null)")
+                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .nextControlFlow("else")
+                            .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                            .endControlFlow();
+                }
+            } else {
+                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                        pkType, interfaceName, primaryKeyGetter);
+            }
+
+            writer
+                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
+                    .beginControlFlow("try")
+                    .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                            " realm.schema.getColumnInfo(%s.class)," +
+                            " false, Collections.<String> emptyList())", qualifiedClassName)
+                    .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
+                    .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                    .nextControlFlow("finally")
+                    .emitStatement("objectContext.clear()")
+                    .endControlFlow()
+
+                    .nextControlFlow("else")
+                    .emitSingleLineComment("canUpdate = false")
+                    .emitStatement("return null")
+                    .endControlFlow();
+
+            writer.endControlFlow();
+
+            writer
+                    .emitEmptyLine()
+                    .beginControlFlow("if (canUpdate)")
+                    .emitSingleLineComment("return update(realm, realmObject, object, cache)")
+                    .emitStatement("return realmObject")
+                    .nextControlFlow("else")
+                    .emitSingleLineComment("return copy(realm, object, update, cache)")
+                    .emitStatement("return null")
+                    .endControlFlow();
+        }
+
+        writer.endControlFlow();
+        writer.endMethod()
+                .emitEmptyLine();
+    }
+    //@formatter:on
+
     //@formatter:off
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Deprecated");
         writer.beginMethod(
                 qualifiedClassName, // Return type
                 "copyOrUpdate", // Method name
@@ -991,6 +1099,18 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
+        writer.emitStatement("return copyOrUpdate(realm, object, update, cache, null)");
+
+        writer.endMethod()
+                .emitEmptyLine();
+
+        writer.beginMethod(
+                qualifiedClassName, // Return type
+                "copyOrUpdate", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache", "List<String>", "fields" // Argument type & argument name
+        );
+
         writer
             .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
                 .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
@@ -1069,7 +1189,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 writer
                     .emitEmptyLine()
                     .beginControlFlow("if (canUpdate)")
-                        .emitStatement("return update(realm, realmObject, object, cache)")
+                        .emitStatement("return update(realm, realmObject, object, cache, fields)")
                     .nextControlFlow("else")
                         .emitStatement("return copy(realm, object, update, cache)")
                     .endControlFlow();
@@ -1719,11 +1839,21 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             return;
         }
 
+        writer.emitAnnotation("Deprecated");
         writer.beginMethod(
                 qualifiedClassName, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
                 "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
+        writer.emitStatement("return update(realm, realmObject, newObject, cache, null)");
+        writer.endMethod();
+        writer.emitEmptyLine();
+
+        writer.beginMethod(
+                qualifiedClassName, // Return type
+                "update", // Method name
+                EnumSet.of(Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache", "List<String>", "fields"); // Argument type & argument name
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -1731,6 +1861,9 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             String getter = metadata.getInternalGetter(fieldName);
             //@formatter:off
             if (Utils.isRealmModel(field)) {
+
+                writer.beginControlFlow("if (fields == null || fields.contains(\"%s\"))", fieldName);
+
                 writer
                     .emitStatement("%s %sObj = ((%s) newObject).%s()",
                             Utils.getFieldTypeQualifiedName(field), fieldName, interfaceName, getter)
@@ -1750,7 +1883,13 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
                     .endControlFlow();
+
+                writer.endControlFlow();
+
             } else if (Utils.isRealmList(field)) {
+
+                writer.beginControlFlow("if (fields == null || fields.contains(\"%s\"))", fieldName);
+
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                     .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
@@ -1770,12 +1909,19 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                     .endControlFlow();
 
+                writer.endControlFlow();
+
             } else {
                 if (field == metadata.getPrimaryKey()) {
                     continue;
                 }
+
+                writer.beginControlFlow("if (fields == null || fields.contains(\"%s\"))", fieldName);
+
                 writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
                         interfaceName, setter, interfaceName, getter);
+
+                writer.endControlFlow();
             }
             //@formatter:on
         }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index f02aefc106..c7660f938c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -103,6 +103,7 @@ public void generate() throws IOException {
         emitGetTableNameMethod(writer);
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
+        emitGetManagedMethod(writer);
         emitCopyToRealmMethod(writer);
         emitInsertObjectToRealmMethod(writer);
         emitInsertListToRealmMethod(writer);
@@ -257,14 +258,50 @@ private void emitGetClassModelList(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    public void emitGetManagedMethod(JavaWriter writer) throws IOException {
+        writer.emitSingleLineComment("TODO : create copyOrGetManaged");
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmModel> E",
+                "getManaged",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "E", "obj", "Map<RealmModel, RealmObjectProxy>", "cache"
+        );
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return clazz.cast(%s.getManaged(realm, (%s) obj, cache))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
+        writer.emitAnnotation("Deprecated");
         writer.beginMethod(
                 "<E extends RealmModel> E",
                 "copyOrUpdate",
                 EnumSet.of(Modifier.PUBLIC),
                 "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmModel, RealmObjectProxy>", "cache"
         );
+
+        writer.emitStatement("return copyOrUpdate(realm, obj, update, cache, null)");
+        writer.endMethod();
+        writer.emitEmptyLine();
+
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmModel> E",
+                "copyOrUpdate",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmModel, RealmObjectProxy>", "cache", "List<String>", "fields"
+        );
         writer.emitSingleLineComment("This cast is correct because obj is either");
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
         writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 65f8477350..fe4c349d7f 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -37,7 +37,6 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
@@ -964,7 +963,28 @@ private Scanner getFullStringScanner(InputStream in) {
     public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object.getClass());
-        return copyOrUpdate(object, true, new HashMap<RealmModel, RealmObjectProxy>());
+        return copyOrUpdate(object, true, new HashMap<RealmModel, RealmObjectProxy>(), null);
+    }
+
+    /**
+     * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or creates
+     * a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects will be
+     * either copied or updated.
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the object and child objects will be
+     * set to their default value if not provided.
+     *
+     * @param object {@link io.realm.RealmObject} to copy or update.
+     * @param fields fields to update.
+     * @return the new or updated RealmObject with all its properties backed by the Realm.
+     * @throws java.lang.IllegalArgumentException if the object is {@code null} or doesn't have a Primary key defined
+     * or it belongs to a Realm instance in a different thread.
+     * @see #copyToRealm(RealmModel)
+     */
+    public <E extends RealmModel> E copyToRealmOrUpdate(E object, List<String> fields) {
+        checkNotNullObject(object);
+        checkHasPrimaryKey(object.getClass());
+        return copyOrUpdate(object, true, new HashMap<RealmModel, RealmObjectProxy>(), fields);
     }
 
     /**
@@ -1154,7 +1174,35 @@ public void insertOrUpdate(RealmModel object) {
         ArrayList<E> realmObjects = new ArrayList<E>();
         for (E object : objects) {
             checkNotNullObject(object);
-            realmObjects.add(copyOrUpdate(object, true, cache));
+            realmObjects.add(copyOrUpdate(object, true, cache, null));
+        }
+
+        return realmObjects;
+    }
+
+    /**
+     * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
+     * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced
+     * objects will be either copied or updated.
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
+     * set to their default value if not provided.
+     *
+     * @param objects a list of objects to update or copy into Realm.
+     * @return a list of all the new or updated RealmObjects.
+     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
+     * @see #copyToRealm(Iterable)
+     */
+    public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects, List<String> fields) {
+        if (objects == null) {
+            return new ArrayList<E>(0);
+        }
+
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
+        ArrayList<E> realmObjects = new ArrayList<E>();
+        for (E object : objects) {
+            checkNotNullObject(object);
+            realmObjects.add(copyOrUpdate(object, true, cache, fields));
         }
 
         return realmObjects;
@@ -1532,7 +1580,13 @@ public void delete(Class<? extends RealmModel> clazz) {
     @SuppressWarnings("unchecked")
     private <E extends RealmModel> E copyOrUpdate(E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         checkIfValid();
-        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache);
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache, null);
+    }
+
+    @SuppressWarnings("unchecked")
+    private <E extends RealmModel> E copyOrUpdate(E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, List<String> fields) {
+        checkIfValid();
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache, fields);
     }
 
     private <E extends RealmModel> E createDetachedCopy(E object, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index d2c7319f5c..a15920b655 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -118,6 +118,18 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
      */
     public abstract Set<Class<? extends RealmModel>> getModelClasses();
 
+    /**
+     * Copies an unmanaged {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
+     * any changes to the original object will not be persisted.
+     *
+     * @param realm the reference to the {@link Realm} where the object will be copied.
+     * @param object the object to get managed version from.
+     * {@code false} otherwise.
+     * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
+     * @return the managed Realm object or null if Real has no managed version
+     */
+    public abstract <E extends RealmModel> E getManaged(Realm realm, E object, Map<RealmModel, RealmObjectProxy> cache);
+
     /**
      * Copies an unmanaged {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
      * any changes to the original object will not be persisted.
@@ -129,8 +141,23 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
      * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
      * @return the managed Realm object.
      */
+    @Deprecated
     public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
 
+    /**
+     * Copies an unmanaged {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
+     * any changes to the original object will not be persisted.
+     *
+     * @param realm the reference to the {@link Realm} where the object will be copied.
+     * @param object the object to copy properties from.
+     * @param update {@code true} if object has a primary key and should try to update already existing data,
+     * {@code false} otherwise.
+     * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
+     * @param fields a list of fields to update if the object is already managed. if null, every fields will be updated
+     * @return the managed Realm object.
+     */
+    public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, List<String> fields);
+
     /**
      * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
      * since it doesn't return the inserted elements, and performs minimum allocations and checks.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index dc410380d8..f616ce55e4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -109,9 +109,22 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     }
 
     @Override
+    public <E extends RealmModel> E getManaged(Realm realm, E object, Map<RealmModel, RealmObjectProxy> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        return mediator.getManaged(realm, object, cache);
+    }
+
+    @Override
+    @Deprecated
     public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
-        return mediator.copyOrUpdate(realm, object, update, cache);
+        return mediator.copyOrUpdate(realm, object, update, cache, null);
+    }
+
+    @Override
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, List<String> fields) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        return mediator.copyOrUpdate(realm, object, update, cache, fields);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index f0cdbf22b8..a1bc7a707a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -124,9 +124,22 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     }
 
     @Override
+    public <E extends RealmModel> E getManaged(Realm realm, E object, Map<RealmModel, RealmObjectProxy> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        return originalMediator.getManaged(realm, object, cache);
+    }
+
+    @Override
+    @Deprecated
     public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
-        return originalMediator.copyOrUpdate(realm, object, update, cache);
+        return originalMediator.copyOrUpdate(realm, object, update, cache, null);
+    }
+
+    @Override
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, List<String> fields) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        return originalMediator.copyOrUpdate(realm, object, update, cache, fields);
     }
 
     @Override
