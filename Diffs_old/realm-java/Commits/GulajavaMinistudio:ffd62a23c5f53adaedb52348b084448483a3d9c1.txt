diff --git a/CHANGELOG.md b/CHANGELOG.md
index b4917e5d97..70fa4587ef 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,7 +10,8 @@
 
 ### Bug Fixes
 
-* [ObjectServer] Fixed a crash when an authentication error happend (#4726).
+* [ObjectServer] Fixed a crash when an authentication error happens (#4726).
+* [ObjectServer] Enabled encryption with Sync (#4561).
 
 ### Internal
 
diff --git a/LICENSE b/LICENSE
index 273b4d5f7b..57a0e0b24a 100644
--- a/LICENSE
+++ b/LICENSE
@@ -181,8 +181,6 @@ TABLE OF CONTENTS
       incurred by, or claims asserted against, such Contributor by reason
       of your accepting any such warranty or additional liability.
 
-   END OF TERMS AND CONDITIONS
-
 2. -------------------------------------------------------------------------------
 
 REALM COMPONENTS
@@ -195,7 +193,7 @@ For the Realm Platform Extensions component
 
   Realm Platform Extensions License
 
-  Copyright (c) 2011-2016 Realm Inc All rights reserved
+  Copyright (c) 2011-2017 Realm Inc All rights reserved
 
   Redistribution and use in binary form, with or without modification, is
   permitted provided that the following conditions are met:
@@ -232,16 +230,19 @@ EXPORT COMPLIANCE
 
 You understand that the Software may contain cryptographic functions that may be
 subject to export restrictions, and you represent and warrant that you are not
-located in a country that is subject to United States export restriction or embargo,
-including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
-are not on the Department of Commerce list of Denied Persons, Unverified Parties,
-or affiliated with a Restricted Entity.
+(i) located in a jurisdiction that is subject to United States economic
+sanctions (“Prohibited Jurisdiction”), including Cuba, Iran, North Korea,
+Sudan, Syria or the Crimea region, (ii) a person listed on any U.S. government
+blacklist (to include the List of Specially Designated Nationals and Blocked
+Persons or the Consolidated Sanctions List administered by the U.S. Department
+of the Treasury’s Office of Foreign Assets Control, or the Denied Persons List
+or Entity List administered by the U.S. Department of Commerce)
+(“Sanctioned Person”), or (iii) controlled or 50% or more owned by a Sanctioned
+Person.
 
 You agree to comply with all export, re-export and import restrictions and
-regulations of the Department of Commerce or other agency or authority of the
-United States or other applicable countries. You also agree not to transfer, or
-authorize the transfer of, directly or indirectly, the Software to any prohibited
-country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
-or to any person or organization on or affiliated with the Department of
-Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
-otherwise in violation of any such restrictions or regulations.
+regulations of the U.S. Department of Commerce or other agency or authority of
+the United States or other applicable countries. You also agree not to transfer,
+or authorize the transfer of, directly or indirectly, of the Software to any
+Prohibited Jurisdiction, or otherwise in violation of any such restrictions or
+regulations.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java b/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
new file mode 100644
index 0000000000..cc70851ced
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+
+/**
+ * Meta test. Checking the lifecycle of @RunTestInLooperThreadTest does the right thing.
+ *
+ * Current order is:
+ * - @RunTestInLooperThread(before = <classRef>)
+ * - @Before()
+ * - @RunTestInLooperThread/@Test
+ * - @After : This is called when exiting the test method. Warning: Looper test is still running.
+ * - looperThread.runAfterTest(Runnable) : This is called when the LooperTest either succeed or fails.
+ */
+
+@RunWith(AndroidJUnit4.class)
+public class RunTestInLooperThreadLifeCycleTest {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private static AtomicBoolean beforeCalled = new AtomicBoolean(false);
+    private static AtomicBoolean afterCalled = new AtomicBoolean(false);
+    private static AtomicBoolean testExited = new AtomicBoolean(false);
+    private static AtomicBoolean beforeRunnableCalled = new AtomicBoolean(false);
+    private static AtomicBoolean afterRunnableCalled = new AtomicBoolean(false);
+    private static AtomicBoolean closableClosed = new AtomicBoolean(false);
+
+    @Before
+    public void before() {
+        assertTrue(beforeCalled.compareAndSet(false, true));
+        assertTrue(beforeRunnableCalled.get());
+
+        looperThread.closeAfterTest(new Closeable() {
+            @Override
+            public void close() throws IOException {
+                assertTrue(testExited.get());
+                assertFalse(afterRunnableCalled.get());
+                assertTrue(closableClosed.compareAndSet(false, true));
+            }
+        });
+        looperThread.runAfterTest(new Runnable() {
+            @Override
+            public void run() {
+                assertTrue(testExited.get());
+                assertTrue(afterRunnableCalled.compareAndSet(false, true));
+                assertTrue(looperThread.isTestComplete());
+            }
+        });
+;    }
+
+    @After
+    public void after() {
+        assertTrue(afterCalled.compareAndSet(false, true));
+        assertTrue(testExited.get());
+        assertFalse(looperThread.isTestComplete()); // Beware of this. Use `runAfterTest` for destroying resources used.
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PrepareLooperTest.class)
+    public void looperTest() {
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                assertTrue(afterCalled.get());
+                assertFalse(looperThread.isTestComplete());
+                looperThread.testComplete();
+            }
+        });
+        assertTrue(testExited.compareAndSet(false, true));
+    }
+
+    public static class PrepareLooperTest implements RunInLooperThread.RunnableBefore {
+        @Override
+        public void run(RealmConfiguration realmConfig) {
+            assertTrue(beforeRunnableCalled.compareAndSet(false, true));
+            assertFalse(beforeCalled.get());
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 33e699995e..f44a42e56a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -23,6 +23,8 @@
 import org.junit.runners.model.MultipleFailureException;
 import org.junit.runners.model.Statement;
 
+import java.io.Closeable;
+import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -81,6 +83,14 @@
     // Access guarded by 'lock'
     private List<Realm> testRealms;
 
+    // List of closable resources that will be automatically closed when the test finishes.
+    // Access guarded by 'lock'
+    private List<Closeable> closableResources;
+
+    // Runnable guaranteed to trigger after the test either succeeded or failed.
+    // Access guarded by 'lock'
+    private Runnable runAfterTestIsComplete;
+
     /**
      * Get the configuration for the test realm.
      * <p>
@@ -129,6 +139,33 @@ public void keepStrongReference(Object obj) {
         }
     }
 
+    /**
+     * Add a closable resource which this test will guarantee to call {@link Closeable#close()} on
+     * when the tests is done.
+     *
+     * @param closeable {@link Closeable} to close.
+     */
+    public void closeAfterTest(Closeable closeable) {
+        synchronized (lock) {
+            closableResources.add(closeable);
+        }
+    }
+
+    /**
+     * Run this task after the unit test either failed or succeeded.
+     * This is a work-around for the the current @After being triggered right after the unit test method exits,
+     * but before the @RunTestInLooperThread has determined the test is done
+     *
+     * TODO: Consider replacing this pattern with `@AfterLooperTest` annotation.
+     *
+     * @param task task to run. Only one task can be provided
+     */
+    public void runAfterTest(Runnable task) {
+        synchronized (lock) {
+            runAfterTestIsComplete = task;
+        }
+    }
+
     /**
      * Add a Realm to be closed when test is complete.
      * <p>
@@ -227,6 +264,7 @@ protected void before() throws Throwable {
         RealmConfiguration config = createConfiguration(UUID.randomUUID().toString());
         LinkedList<Object> refs = new LinkedList<>();
         List<Realm> realms = new LinkedList<>();
+        LinkedList<Closeable> closeables = new LinkedList<>();
 
         synchronized (lock) {
             realmConfiguration = config;
@@ -234,6 +272,7 @@ protected void before() throws Throwable {
             backgroundHandler = null;
             keepStrongReference = refs;
             testRealms = realms;
+            closableResources = closeables;
         }
     }
 
@@ -290,6 +329,24 @@ private void closeRealms() {
         }
     }
 
+    private void closeResources() throws IOException {
+        synchronized (lock) {
+            for (Closeable cr : closableResources) {
+                cr.close();
+            }
+        }
+    }
+
+    /**
+     * Checks if the current test is considered completed or not.
+     * It is completed if either {@link #testComplete()} was called or an uncaught exception was thrown.
+     */
+    public boolean isTestComplete() {
+        synchronized (lock) {
+            return signalTestCompleted.getCount() == 0;
+        }
+    }
+
     /**
      * If an implementation of this is supplied with the annotation, the {@link RunnableBefore#run(RealmConfiguration)}
      * will be executed before the looper thread starts. It is normally for populating the Realm before the test.
@@ -427,6 +484,10 @@ public void run() {
             } finally {
                 try {
                     looperTearDown();
+                    closeResources();
+                    if (runAfterTestIsComplete != null) {
+                        runAfterTestIsComplete.run();
+                    }
                 } catch (Throwable t) {
                     setAssertionError(t);
                     setUnitTestFailed();
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index 20228694a1..8d0a12d01f 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -20,10 +20,13 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.UUID;
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
+import io.realm.SyncManager;
 import io.realm.SyncUser;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.objectserver.ObjectServerUser;
@@ -36,6 +39,16 @@
     public static final String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
     public static final String DEFAULT_USER_IDENTIFIER = "JohnDoe";
 
+    private final static Method SYNC_MANAGER_RESET_METHOD;
+    static {
+        try {
+            SYNC_MANAGER_RESET_METHOD = SyncManager.class.getDeclaredMethod("reset");
+            SYNC_MANAGER_RESET_METHOD.setAccessible(true);
+        } catch (NoSuchMethodException e) {
+            throw new AssertionError(e);
+        }
+    }
+
     public static SyncUser createRandomTestUser() {
         return createTestUser(UUID.randomUUID().toString(),
                 UUID.randomUUID().toString(),
@@ -116,4 +129,14 @@ public static AuthenticateResponse createRefreshResponse() {
     public static AuthenticateResponse createErrorResponse(ErrorCode code) {
         return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
     }
+
+    public static void resetSyncMetadata() {
+        try {
+            SYNC_MANAGER_RESET_METHOD.invoke(null);
+        } catch (InvocationTargetException e) {
+            throw new AssertionError(e);
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 4738a264d2..5eb72588d5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -141,11 +141,16 @@ class JniConfigWrapper {
             ssl_trust_certificate_path =
                 realm::util::Optional<std::string>(JStringAccessor(env, sync_ssl_trust_certificate_path));
         }
-        m_config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
-            user, realm_url, SyncSessionStopPolicy::Immediately, std::move(bind_handler), std::move(error_handler),
-            nullptr, util::none, sync_client_validate_ssl, ssl_trust_certificate_path});
 
+        util::Optional<std::array<char, 64>> sync_encryption_key(util::none);
+        if (!m_config.encryption_key.empty()) {
+            sync_encryption_key = std::array<char, 64>();
+            std::copy_n(m_config.encryption_key.begin(), 64, sync_encryption_key->begin());
+        }
 
+        m_config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
+            user, realm_url, SyncSessionStopPolicy::Immediately, std::move(bind_handler), std::move(error_handler),
+            nullptr, sync_encryption_key, sync_client_validate_ssl, ssl_trust_certificate_path});
 #else
         REALM_UNREACHABLE();
 #endif
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index e24211efca..80bde88777 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -269,6 +269,10 @@ public static void fatal(Throwable throwable, String message, Object... args) {
 
     // Formats the message, parses the stacktrace of given throwable and passes them to nativeLog.
     private static void log(int level, Throwable throwable, String message, Object... args) {
+        if (level < getLevel()) {
+            return;
+        }
+
         StringBuilder stringBuilder = new StringBuilder();
         if (args != null && args.length > 0) {
             message = String.format(message, args);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
new file mode 100644
index 0000000000..63bcb72115
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -0,0 +1,253 @@
+package io.realm.objectserver;
+
+import android.os.SystemClock;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.TestSyncConfigurationFactory;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class EncryptedSynchronizedRealmTests extends BaseIntegrationTest {
+    @Rule
+    public Timeout globalTimeout = Timeout.seconds(10);
+
+    @Rule
+    public final TestSyncConfigurationFactory configurationFactory = new TestSyncConfigurationFactory();
+
+    @Before
+    public void before() {
+        // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
+        // causing the SyncUser to remain in memory.
+        // They're actually not persisted into disk.
+        // move this call to 'tearDown' to clean in-memory & on-disk users
+        // once https://github.com/realm/realm-object-store/issues/207 is resolved
+        SyncTestUtils.resetSyncMetadata();
+    }
+
+    // Make sure the encryption is local, i.e after deleting a synced Realm
+    // re-open it again with no (or different) key, should be possible.
+    @Test
+    public void setEncryptionKey_canReOpenRealmWithoutKey() {
+
+        // STEP 1: open a synced Realm using a local encryption key
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        final byte[] randomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(randomKey)
+                .build();
+
+        Realm realm = Realm.getInstance(configWithEncryption);
+        assertTrue(realm.isEmpty());
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Hi Alice");
+        realm.commitTransaction();
+
+        // STEP 2:  make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+        Realm.deleteRealm(configWithEncryption);
+
+        // STEP 3: try to open again the Realm without the encryption key should not fail
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .build();
+
+        realm = Realm.getInstance(configWithoutEncryption);
+        RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("Hi Alice", all.get(0).getChars());
+
+        realm.close();
+        user.logout();
+    }
+
+    // If an encrypted synced Realm is re-opened with the wrong key, throw an exception.
+    // TODO: enable again once https://github.com/realm/realm-java/pull/4707 is merged
+    @Ignore("This test crash the Sync client thread")
+    @Test
+    public void setEncryptionKey_shouldCrashIfKeyNotProvided() {
+        // STEP 1: open a synced Realm using a local encryption key
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        final byte[] randomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(randomKey)
+                .build();
+
+        Realm realm = Realm.getInstance(configWithEncryption);
+        assertTrue(realm.isEmpty());
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Hi Alice");
+        realm.commitTransaction();
+
+        // STEP 2: make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close(); // Realm is not deleted, just closed
+        user.logout();
+
+        // STEP 3: try to open again the Realm without the encryption key should fail
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .build();
+
+        try {
+            realm = Realm.getInstance(configWithoutEncryption);
+            fail("It should not be possible to open the Realm without the encryption key set previously.");
+        } catch (RealmFileException ignored) {
+        }
+    }
+
+    // If client B encrypts its synced Realm, client A should be able to access that Realm with a different encryption key.
+    @Test
+    public void setEncryptionKey_differentClientsWithDifferentKeys() throws InterruptedException {
+        // STEP 1: prepare a synced Realm for client A
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        final byte[] randomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(randomKey)
+                .build();
+
+        Realm realm = Realm.getInstance(configWithEncryption);
+        assertTrue(realm.isEmpty());
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Hi Alice");
+        realm.commitTransaction();
+
+        // STEP 2: make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+
+        // STEP 3: prepare a synced Realm for client B (admin user)
+        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+        SyncUser adminUser = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final byte[] adminRandomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration adminConfigWithEncryption = configurationFactory.createSyncConfigurationBuilder(adminUser, configWithEncryption.getServerUrl().toString())
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(adminRandomKey)
+                .build();
+
+        Realm adminRealm = Realm.getInstance(adminConfigWithEncryption);
+        RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("Hi Alice", all.get(0).getChars());
+
+        adminRealm.beginTransaction();
+        adminRealm.createObject(StringOnly.class).setChars("Hi Bob");
+        adminRealm.commitTransaction();
+
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));
+        adminRealm.close();
+
+        // STEP 4: client A can see changes from client B (although they're using different encryption keys)
+        realm = Realm.getInstance(configWithEncryption);
+        SyncManager.getSession(configWithEncryption).downloadAllServerChanges();// force download latest commits from ROS
+        realm.refresh();//FIXME not calling refresh will still point to the previous version of the Realm without the latest admin commit  "Hi Bob"
+        assertEquals(2, realm.where(StringOnly.class).count());
+
+        adminRealm = Realm.getInstance(adminConfigWithEncryption);
+
+        RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+        RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+        assertEquals("Hi Alice", allSorted.get(0).getChars());
+        assertEquals("Hi Bob", allSorted.get(1).getChars());
+
+        assertEquals("Hi Alice", allSortedAdmin.get(0).getChars());
+        assertEquals("Hi Bob", allSortedAdmin.get(1).getChars());
+
+        adminUser.logout();
+        user.logout();
+
+        realm.close();
+        adminRealm.close();
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/StringOnlyModule.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/StringOnlyModule.java
new file mode 100644
index 0000000000..e935a0b1b9
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/StringOnlyModule.java
@@ -0,0 +1,8 @@
+package io.realm.objectserver.utils;
+
+import io.realm.annotations.RealmModule;
+import io.realm.entities.StringOnly;
+
+@RealmModule(classes = { StringOnly.class})
+public class StringOnlyModule {
+}
