diff --git a/CHANGELOG.md b/CHANGELOG.md
index 922c13a348..733550ade9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,31 +1,90 @@
+## 0.90.0
+
+* Updated Realm Core to 0.100.0.
+
+### Breaking changes
+
+* RealmChangeListener provides the changed object/Realm/collection as well (#1594).
+* All JSON methods on Realm now only wraps JSONException in RealmException. All other Exceptions are thrown as they are.
+* Marked all methods on `RealmObject` and all public classes final (#1594).
+* Removed `BaseRealm` from the public API.
+* Removed `HandlerController` from the public API.
+* Removed constructor of `RealmAsyncTask` from the public API (#1594).
+* `RealmBaseAdapter` has been moved to its own GitHub repository: https://github.com/realm/realm-android-adapters
+  See https://github.com/realm/realm-android-adapters/README.md for further info on how to include it.
+* File format of Realm files is changed. Files will be automatically upgraded but opening a Realm file with older
+  versions of Realm is not possible.
+
+### Deprecated
+
+* `Realm.allObjects*()`. Use `Realm.where(clazz).findAll*()` instead.
+* `Realm.distinct*()`. Use `Realm.where(clazz).distinct*()` instead.
+* `DynamicRealm.allObjects*()`. Use `DynamicRealm.where(className).findAll*()` instead.
+* `DynamicRealm.distinct*()`. Use `DynamicRealm.where(className).distinct*()` instead.
+* `Realm.allObjectsSorted(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSorted(field[], sort[])`` instead.
+* `RealmQuery.findAllSorted(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSorted(field[], sort[])`` instead.
+* `RealmQuery.findAllSortedAsync(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSortedAsync(field[], sort[])`` instead.
+* `RealmConfiguration.setModules()`. Use `RealmConfiguration.modules()` instead.
+* `Realm.refresh()` and `DynamicRealm.refresh()`. Use `Realm.waitForChange()`/`stopWaitForChange()` or `DynamicRealm.waitForChange()`/`stopWaitForChange()` instead.
+
+### Enhancements
+
+* `RealmObjectSchema.getPrimaryKey()` (#2636).
+* `Realm.createObject(Class, Object)` for creating objects with a primary key directly.
+* Unit tests in Android library projects now detect Realm model classes.
+* Better error message if `equals()` and `hashCode()` are not properly overridden in custom Migration classes.
+* Expanding the precision of `Date` fields to cover full range (#833).
+* `Realm.waitForChange()`/`stopWaitForChange()` and `DynamicRealm.waitForChange()`/`stopWaitForChange()` (#2386).
+
+### Bug fixes
+
+* `RealmChangeListener` on `RealmObject` is not triggered when adding listener on returned `RealmObject` of `copyToRealmOrUpdate()` (#2569).
+
+### Credits
+
+* Thanks to Brenden Kromhout (@bkromhout) for adding `RealmObjectSchema.getPrimaryKey()`.
+
+## 0.89.1
+
+### Bug fixes
+
+* @PrimaryKey + @Required on String type primary key no longer throws when using copyToRealm or copyToRealmOrUpdate (#2653).
+* Primary key is cleared/changed when calling RealmSchema.remove()/RealmSchema.rename() (#2555).
+* Objects implementing RealmModel can be used as a field of RealmModel/RealmObject (#2654).
+
 ## 0.89.0
 
 ### Breaking changes
 
-* RealmResults.clear() now throws UnsupportedOperationException. Use RealmResults.deleteAllFromRealm() instead.
-* RealmResults.remove(int) now throws UnsupportedOperationException. Use RealmResults.deleteFromRealm() instead.
-* Removed deprecated methods Realm.getTable() from public API.
+* @PrimaryKey field value can now be null for String, Byte, Short, Integer, and Long types. Older Realms should be migrated, using RealmObjectSchema.setNullable(), or by adding the @Required annotation. (#2515).
+* `RealmResults.clear()` now throws UnsupportedOperationException. Use `RealmResults.deleteAllFromRealm()` instead.
+* `RealmResults.remove(int)` now throws UnsupportedOperationException. Use `RealmResults.deleteFromRealm(int)` instead.
+* `RealmResults.sort()` and `RealmList.sort()` now return the sorted result instead of sorting in-place.
+* `RealmList.first()` and `RealmList.last()` now throw `ArrayIndexOutOfBoundsException` if `RealmList` is empty.
+* Removed deprecated method `Realm.getTable()` from public API.
+* `Realm.refresh()` and `DynamicRealm.refresh()` on a Looper no longer have any effect. `RealmObject` and `RealmResults` are always updated on the next event loop.
 
 ### Deprecated
 
-* RealmObject.removeFromRealm() in place of RealmObject.deleteFromRealm()
-* Realm.clear(Class) in favour of Realm.delete(Class).
-* DynamicRealm.clear(Class) in place of DynamicRealm.delete(Class).
+* `RealmObject.removeFromRealm()` in place of `RealmObject.deleteFromRealm()`
+* `Realm.clear(Class)` in favour of `Realm.delete(Class)`.
+* `DynamicRealm.clear(Class)` in place of `DynamicRealm.delete(Class)`.
 
 ### Enhancements
 
-* RealmCollection and OrderedRealmCollection have been added. RealmList and RealmResults both implement these interfaces.
-* RealmBaseAdapter now accept an OrderedRealmCollection instead of only RealmResults.
-* RealmObjectSchema.isPrimaryKey(String) (#2440)
-* RealmConfiguration.initialData() can now be used to populate a Realm file before it is used for the first time.
+* Added a `RealmModel` interface that can be used instead of extending `RealmObject`.
+* `RealmCollection` and `OrderedRealmCollection` interfaces have been added. `RealmList` and `RealmResults` both implement these.
+* `RealmBaseAdapter` now accept an `OrderedRealmCollection` instead of only `RealmResults`.
+* `RealmObjectSchema.isPrimaryKey(String)` (#2440)
+* `RealmConfiguration.initialData(Realm.Transaction)` can now be used to populate a Realm file before it is used for the first time.
 
 ### Bug fixes
 
-* RealmObjectSchema.isRequired() and RealmObjectSchema.isNullable() don't throw when the given field name doesn't exist.
+* `RealmObjectSchema.isRequired(String)` and `RealmObjectSchema.isNullable(String)` don't throw when the given field name doesn't exist.
 
 ### Credits
 
-* Thanks to @thesurix for adding RealmConfiguration.initialData().
+* Thanks to @thesurix for adding `RealmConfiguration.initialData()`.
 
 ## 0.88.3
 
@@ -104,6 +163,7 @@
 
 ### Bug fixes
 
+* Error occurring during test and (#2025).
 * Error occurring during test and connectedCheck of unit test example (#1934).
 * Bug in jsonExample (#2092).
 * Multiple calls of RealmResults.distinct() causes to return wrong results (#2198).
diff --git a/README.md b/README.md
index db14a975d1..1638d47c8e 100644
--- a/README.md
+++ b/README.md
@@ -6,18 +6,18 @@ This repository holds the source code for the Java version of Realm, which curre
 ## Features
 
 * **Mobile-first:** Realm is the first database built from the ground up to run directly inside phones, tablets and wearables.
-* **Simple:** Data is directly exposed as objects and queryable by code, removing the need for ORM's riddled with performance & maintenance issues. Plus, we've worked hard to [keep our API down to very few classes](http://realm.io/docs/java/): most of our users pick it up intuitively, getting simple apps up & running in minutes.
+* **Simple:** Data is directly exposed as objects and queryable by code, removing the need for ORM's riddled with performance & maintenance issues. Plus, we've worked hard to [keep our API down to very few classes](https://realm.io/docs/java/): most of our users pick it up intuitively, getting simple apps up & running in minutes.
 * **Modern:** Realm supports easy thread-safety, relationships & encryption.
 * **Fast:** Realm is faster than even raw SQLite on common operations, while maintaining an extremely rich feature set.
 
 ## Getting Started
 
-Please see the [detailed instructions in our docs](http://realm.io/docs/java/#installation) to add Realm to your project.
+Please see the [detailed instructions in our docs](https://realm.io/docs/java/#installation) to add Realm to your project.
 
 ## Documentation
 
-Documentation for Realm can be found at [realm.io/docs/java](http://realm.io/docs/java).
-The API reference is located at [realm.io/docs/java/api](http://realm.io/docs/java/api).
+Documentation for Realm can be found at [realm.io/docs/java](https://realm.io/docs/java).
+The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/java/api).
 
 ## Getting Help
 
@@ -140,7 +140,7 @@ See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 ## License
 
 Realm Java is published under the Apache 2.0 license.
-The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](http://realm.io/docs/java/#faq).
+The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](https://realm.io/docs/java/#faq).
 
 **This product is not being made available to any person located in Cuba, Iran,
 North Korea, Sudan, Syria or the Crimea region, or to any other person that is
diff --git a/examples/adapterExample/build.gradle b/examples/adapterExample/build.gradle
deleted file mode 100644
index 707733ce88..0000000000
--- a/examples/adapterExample/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-apply plugin: 'realm-android'
-
-android {
-    //noinspection GroovyAssignabilityCheck
-    compileSdkVersion rootProject.sdkVersion
-    //noinspection GroovyAssignabilityCheck
-    buildToolsVersion rootProject.buildTools
-
-    defaultConfig {
-        applicationId "io.realm.examples.realmadapters"
-        //noinspection GroovyAssignabilityCheck
-        targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-        }
-    }
-
-    command {
-        events 2000
-    }
-}
diff --git a/examples/adapterExample/lint.xml b/examples/adapterExample/lint.xml
deleted file mode 100644
index 829e13eda8..0000000000
--- a/examples/adapterExample/lint.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<lint>
-    <issue id="AllowBackup" severity="ignore" />
-    <issue id="GoogleAppIndexingWarning" severity="ignore" />
-    <issue id="IconMissingDensityFolder" severity="ignore" />
-    <issue id="IconLauncherShape" severity="ignore" />
-</lint>
diff --git a/examples/adapterExample/src/main/AndroidManifest.xml b/examples/adapterExample/src/main/AndroidManifest.xml
deleted file mode 100644
index 5958789fd6..0000000000
--- a/examples/adapterExample/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest package="io.realm.examples.realmadapters"
-          xmlns:android="http://schemas.android.com/apk/res/android">
-
-    <application
-        android:icon="@drawable/ic_launcher"
-        android:label="@string/app_name"
-        android:theme="@style/AppTheme">
-
-        <activity
-            android:name=".AdapterExampleActivity"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:label="@string/app_name">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <category android:name="android.intent.category.LAUNCHER"/>
-            </intent-filter>
-        </activity>
-
-    </application>
-
-</manifest>
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
deleted file mode 100644
index df09a02d9d..0000000000
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.realmadapters;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.os.Message;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.ListView;
-
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmResults;
-import io.realm.examples.realmadapters.models.TimeStamp;
-
-
-public class AdapterExampleActivity extends Activity {
-
-    private Realm realm;
-    private WorkerThread workerThread;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_my);
-
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(this).build();
-        Realm.deleteRealm(realmConfig);
-        // Set the default Realm configuration at the beginning.
-        Realm.setDefaultConfiguration(realmConfig);
-        realm = Realm.getDefaultInstance();
-
-        RealmResults<TimeStamp> timeStamps = realm.where(TimeStamp.class).findAll();
-        final MyAdapter adapter = new MyAdapter(this, timeStamps);
-        ListView listView = (ListView) findViewById(R.id.listView);
-        listView.setAdapter(adapter);
-        listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
-            @Override
-            public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
-                TimeStamp timeStamp = adapter.getAdapterData().get(i);
-                Message message = buildMessage(WorkerHandler.REMOVE_TIMESTAMP, timeStamp.getTimeStamp());
-
-                workerThread.workerHandler.sendMessage(message);
-                return true;
-            }
-        });
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        workerThread.quit();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        workerThread = new WorkerThread();
-        workerThread.start();
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        realm.close(); // Remember to close Realm when done.
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        getMenuInflater().inflate(R.menu.my, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int id = item.getItemId();
-        if (id == R.id.action_add) {
-            Message message = buildMessage(WorkerHandler.ADD_TIMESTAMP, Long.toString(System.currentTimeMillis()));
-            workerThread.workerHandler.sendMessage(message);
-        }
-        return true;
-    }
-
-    private static Message buildMessage(int action, String timeStamp) {
-        Bundle bundle = new Bundle(2);
-        bundle.putInt(WorkerHandler.ACTION, action);
-        bundle.putString(WorkerHandler.TIMESTAMP, timeStamp);
-        Message message = new Message();
-        message.setData(bundle);
-        return message;
-    }
-}
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
deleted file mode 100644
index 48ab829baf..0000000000
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.realmadapters;
-
-import android.content.Context;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ListAdapter;
-import android.widget.TextView;
-
-import io.realm.OrderedRealmCollection;
-import io.realm.RealmBaseAdapter;
-import io.realm.examples.realmadapters.models.TimeStamp;
-
-class MyAdapter extends RealmBaseAdapter<TimeStamp> implements ListAdapter {
-
-    private static class ViewHolder {
-        TextView timestamp;
-    }
-
-    public MyAdapter(Context context, OrderedRealmCollection<TimeStamp> realmResults) {
-        super(context, realmResults, true);
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        ViewHolder viewHolder;
-        if (convertView == null) {
-            convertView = inflater.inflate(android.R.layout.simple_list_item_1, parent, false);
-            viewHolder = new ViewHolder();
-            viewHolder.timestamp = (TextView) convertView.findViewById(android.R.id.text1);
-            convertView.setTag(viewHolder);
-        } else {
-            viewHolder = (ViewHolder) convertView.getTag();
-        }
-
-        TimeStamp item = adapterData.get(position);
-        viewHolder.timestamp.setText(item.getTimeStamp());
-        return convertView;
-    }
-
-    public OrderedRealmCollection<TimeStamp> getAdapterData() {
-        return adapterData;
-    }
-}
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java
deleted file mode 100644
index 062da433f3..0000000000
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.examples.realmadapters;
-
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-
-import io.realm.Realm;
-import io.realm.examples.realmadapters.models.TimeStamp;
-
-class WorkerHandler extends Handler {
-
-    public static final int ADD_TIMESTAMP = 1;
-    public static final int REMOVE_TIMESTAMP = 2;
-
-    public static final String ACTION = "action";
-    public static final String TIMESTAMP = "timestamp";
-
-    private final Realm realm;
-
-    public WorkerHandler(Realm realm) {
-        this.realm = realm;
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
-        final Bundle bundle = msg.getData();
-
-        final int action = bundle.getInt(ACTION);
-        final String timestamp = bundle.getString(TIMESTAMP);
-
-        switch (action) {
-            case ADD_TIMESTAMP:
-                realm.beginTransaction();
-                realm.createObject(TimeStamp.class).setTimeStamp(timestamp);
-                realm.commitTransaction();
-                break;
-            case REMOVE_TIMESTAMP:
-                realm.beginTransaction();
-                realm.where(TimeStamp.class).equalTo("timeStamp", timestamp).findAll().deleteAllFromRealm();
-                realm.commitTransaction();
-                break;
-        }
-    }
-}
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
deleted file mode 100644
index 00f7551eea..0000000000
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.examples.realmadapters;
-
-import android.os.Handler;
-import android.os.Looper;
-
-import java.util.concurrent.CountDownLatch;
-
-import io.realm.Realm;
-
-class WorkerThread extends Thread {
-
-    public Handler workerHandler;
-    private CountDownLatch realmOpen;
-
-    @Override
-    public void run() {
-        Realm realm = null;
-        try {
-            Looper.prepare();
-            realm = Realm.getDefaultInstance();
-            realmOpen = new CountDownLatch(1);
-            workerHandler = new WorkerHandler(realm);
-            Looper.loop();
-        } finally {
-            if (realm != null) {
-                realm.close();
-                realmOpen.countDown();
-            }
-        }
-    }
-
-    public void quit() {
-        workerHandler.getLooper().quit();
-        try {
-            realmOpen.await();
-        } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-        }
-    }
-}
diff --git a/examples/adapterExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/adapterExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/adapterExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/adapterExample/src/main/res/layout/activity_my.xml b/examples/adapterExample/src/main/res/layout/activity_my.xml
deleted file mode 100644
index 375a00e263..0000000000
--- a/examples/adapterExample/src/main/res/layout/activity_my.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    tools:context=".AdapterExampleActivity">
-
-
-    <ListView
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:id="@+id/listView"
-        android:layout_alignParentTop="true"
-        android:layout_alignParentLeft="true"
-        android:layout_alignParentStart="true"
-        tools:listitem="@android:layout/simple_list_item_1" />
-</RelativeLayout>
diff --git a/examples/adapterExample/src/main/res/menu/my.xml b/examples/adapterExample/src/main/res/menu/my.xml
deleted file mode 100644
index bd4fcccd3e..0000000000
--- a/examples/adapterExample/src/main/res/menu/my.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    tools:context=".MyActivity" >
-    <item android:id="@+id/action_add"
-        android:icon="@android:drawable/ic_menu_add"
-        android:title="@string/add"
-        android:showAsAction="always"/>
-</menu>
diff --git a/examples/adapterExample/src/main/res/values-w820dp/dimens.xml b/examples/adapterExample/src/main/res/values-w820dp/dimens.xml
deleted file mode 100644
index 63fc816444..0000000000
--- a/examples/adapterExample/src/main/res/values-w820dp/dimens.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
-         (such as screen margins) for screens with more than 820dp of available width. This
-         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
-    <dimen name="activity_horizontal_margin">64dp</dimen>
-</resources>
diff --git a/examples/adapterExample/src/main/res/values/dimens.xml b/examples/adapterExample/src/main/res/values/dimens.xml
deleted file mode 100644
index 47c8224673..0000000000
--- a/examples/adapterExample/src/main/res/values/dimens.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
-</resources>
diff --git a/examples/adapterExample/src/main/res/values/strings.xml b/examples/adapterExample/src/main/res/values/strings.xml
deleted file mode 100644
index 11de42b091..0000000000
--- a/examples/adapterExample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="app_name">Adapter example</string>
-    <string name="add">Add</string>
-
-</resources>
diff --git a/examples/adapterExample/src/main/res/values/styles.xml b/examples/adapterExample/src/main/res/values/styles.xml
deleted file mode 100644
index ff6c9d2c0f..0000000000
--- a/examples/adapterExample/src/main/res/values/styles.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<resources>
-
-    <!-- Base application theme. -->
-    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
-        <!-- Customize your theme here. -->
-    </style>
-
-</resources>
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 15365c35c7..049cf16cbf 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -32,7 +32,7 @@ android {
         abi {
             enable true
             reset()
-            include 'arm', 'arm-v7a', 'arm64', 'mips', 'x86', 'x86_64'
+            include 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86', 'x86_64'
         }
     }
 }
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index edc41c4e0d..c308278d72 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -100,23 +100,7 @@ protected void onDestroy() {
             return null;
         }
 
-        // GSON can parse the data.
-        // Note there is a bug in GSON 2.5 that can cause it to StackOverflow when working with RealmObjects.
-        // To work around this, use the ExclusionStrategy below or downgrade to 1.7.1
-        // See more here: https://code.google.com/p/google-gson/issues/detail?id=440
-        Gson gson = new GsonBuilder()
-                .setExclusionStrategies(new ExclusionStrategy() {
-                    @Override
-                    public boolean shouldSkipField(FieldAttributes f) {
-                        return f.getDeclaringClass().equals(RealmObject.class);
-                    }
-
-                    @Override
-                    public boolean shouldSkipClass(Class<?> clazz) {
-                        return false;
-                    }
-                })
-                .create();
+        Gson gson = new GsonBuilder().create();
 
         JsonElement json = new JsonParser().parse(new InputStreamReader(stream));
         List<City> cities = gson.fromJson(json, new TypeToken<List<City>>() {}.getType());
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index b6e94ac171..33a5ed5655 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -27,6 +27,8 @@ android {
     buildTypes {
         release {
             minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt'),
+                    'proguard-rules.pro'
             signingConfig signingConfigs.release
         }
     }
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index b472e6d0cf..1d36960fda 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -65,14 +65,14 @@ protected void onCreate(Bundle savedInstanceState) {
         // Spider, Cat, Dog }
         RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder(this)
                 .name("farm.realm")
-                .setModules(Realm.getDefaultModule(), new DomesticAnimalsModule())
+                .modules(Realm.getDefaultModule(), new DomesticAnimalsModule())
                 .build();
 
         // Or you can completely replace the default schema.
         // This Realm contains the following classes: { Elephant, Lion, Zebra, Snake, Spider }
         RealmConfiguration exoticAnimalsConfig = new RealmConfiguration.Builder(this)
                 .name("exotic.realm")
-                .setModules(new ZooAnimalsModule(), new CreepyAnimalsModule())
+                .modules(new ZooAnimalsModule(), new CreepyAnimalsModule())
                 .build();
 
         // Multiple Realms can be open at the same time
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
index bddcffaaa3..9e19a30e2a 100644
--- a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
@@ -35,7 +35,7 @@
     public Zoo(Context context) {
         realmConfig = new RealmConfiguration.Builder(context) // Beware this is the app context
                 .name("library.zoo.realm")                    // So always use a unique name
-                .setModules(new AllAnimalsModule())           // Always use explicit modules in library projects
+                .modules(new AllAnimalsModule())           // Always use explicit modules in library projects
                 .build();
 
         // Reset Realm
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 529a4f486c..9b18f1e779 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -1,4 +1,3 @@
-include 'adapterExample'
 include 'encryptionExample'
 include 'gridViewExample'
 include 'introExample'
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
index 48a821225b..6d730bce93 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -40,7 +40,7 @@
 /**
  * This fragment demonstrates how you can perform asynchronous queries with Realm.
  */
-public class AsyncQueryFragment extends Fragment implements View.OnClickListener, RealmChangeListener {
+public class AsyncQueryFragment extends Fragment implements View.OnClickListener, RealmChangeListener<RealmResults<Dot>> {
     private Realm realm;
     private DotAdapter dotAdapter;
     private RealmResults<Dot> allSortedDots;
@@ -135,7 +135,7 @@ private void cancelAsyncTransaction() {
     }
 
     @Override
-    public void onChange() {
+    public void onChange(RealmResults<Dot> result) {
         dotAdapter.notifyDataSetChanged();
     }
 
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index 7d0c1ba477..bc6396386a 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -44,9 +44,9 @@
     private DotsView dotsView;
 
     // Realm change listener that refreshes the UI when there is changes to Realm.
-    private RealmChangeListener realmListener = new RealmChangeListener() {
+    private RealmChangeListener<Realm> realmListener = new RealmChangeListener<Realm>() {
         @Override
-        public void onChange() {
+        public void onChange(Realm realm) {
             dotsView.invalidate();
         }
     };
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 58e5be1490..1abe5250b8 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -60,7 +60,7 @@
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
-@PrepareForTest({Realm.class, RealmConfiguration.class, RealmResults.class, RealmCore.class})
+@PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class})
 public class ExampleActivityTest {
 
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 0536847d77..2077c526da 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -57,6 +57,8 @@ class Realm implements Plugin<Project> {
         } else {
             project.dependencies.add("apt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("apt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+            project.dependencies.add("androidTestApt", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("androidTestApt", "io.realm:realm-annotations-processor:${Version.VERSION}")
         }
     }
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
index a0cf1174e8..ddef303a14 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
@@ -22,14 +22,16 @@
 import java.lang.annotation.Target;
 
 /**
- * The @PrimaryKey annotation will mark a field as a primary key inside Realm. The field
- * should uniquely identify the object. Trying to insert an object with an existing primary key
- * will result in an {@link io.realm.exceptions.RealmException}.
+ * The @PrimaryKey annotation will mark a field as a primary key inside Realm. Only one field in a
+ * RealmObject class can have this annotation, and the field should uniquely identify the object.
+ * Trying to insert an object with an existing primary key will result in an
+ * {@link io.realm.exceptions.RealmPrimaryKeyConstraintException}.
  *
- * Primary keys also count as having the {@link Index} and {@link Required} annotations.
+ * Primary keys also count as having the {@link Index} annotation.
  *
- * Only one field pr. RealmObject class can have this annotation and it is only allowed on the following
- * types: String, short, int, long, byte
+ * It is allowed to apply this annotation on the following primitive types: byte, short, int, and long.
+ * String, Byte, Short, Integer, and Long are also allowed, and further permitted to have {@code null}
+ * as a primary key value.
  */
 @Retention(RetentionPolicy.CLASS)
 @Target(ElementType.FIELD)
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
index 5f3cf9b738..940a462ac9 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -47,7 +47,7 @@
  * Library authors are responsible for avoiding this conflict by using explicit modules where {@code library = true} is
  * set. This disables the generation of the DefaultRealmModule for the library project and allows the library to be
  * included in the app project that also uses Realm. This means that library projects that uses Realm internally are
- * required to specify a specific module using {@code RealmConfiguration.setModules()}.
+ * required to specify a specific module using {@code RealmConfiguration.modules()}.
  * <p>
  * App developers are not required to specify any modules, as they implicitly use the {@code DefaultRealmModule}, but
  * they now has the option of adding the library project classes to their schema using
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index 1e9ec46830..96a163bac1 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -23,6 +23,7 @@ import com.google.common.collect.Sets
 import com.google.common.io.Files
 import groovy.io.FileType
 import io.realm.annotations.Ignore
+import io.realm.annotations.RealmClass
 import javassist.ClassPool
 import javassist.CtClass
 import javassist.LoaderClassPath
@@ -99,11 +100,10 @@ class RealmTransformer extends Transform {
         }
 
         // Find the model classes
-        def realmObject = classPool.get('io.realm.RealmObject')
         def allModelClasses = allClassNames
                 .findAll { it.endsWith('RealmProxy') }
                 .collect { classPool.getCtClass(it).superclass }
-                .findAll { it.superclass?.equals(realmObject) }
+                .findAll { it.hasAnnotation(RealmClass.class) || it.superclass.hasAnnotation(RealmClass.class) }
         def inputModelClasses = allModelClasses.findAll {
             inputClassNames.contains(it.name)
         }
diff --git a/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java b/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
new file mode 100644
index 0000000000..aa32099d22
--- /dev/null
+++ b/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Scanner;
+
+/**
+ * Generate a unique identifier for a computer. The method being used depends on the platform:
+ *  - OS X:  Mac address of en0
+ *  - Windows:  BIOS identifier
+ *  - Linux: Machine ID provided by the OS
+ */
+public class ComputerIdentifierGenerator {
+
+    private static final String UNKNOWN = "unknown";
+
+    private static String OS = System.getProperty("os.name").toLowerCase();
+
+    public static String get() {
+        try {
+            if (isWindows()) {
+                return getWindowsIdentifier();
+            } else if (isMac()) {
+                return getMacOsIdentifier();
+            } else if (isLinux()) {
+                return getLinuxMacAddress();
+            } else {
+                return UNKNOWN;
+            }
+        } catch (Exception e) {
+            return UNKNOWN;
+        }
+    }
+
+    private static boolean isWindows() {
+        return (OS.contains("win"));
+    }
+
+    private static boolean isMac() {
+        return (OS.contains("mac"));
+    }
+
+    private static boolean isLinux() {
+        return (OS.contains("inux"));
+    }
+
+    private static String getLinuxMacAddress() throws FileNotFoundException, NoSuchAlgorithmException {
+        File machineId = new File("/var/lib/dbus/machine-id");
+        if (!machineId.exists()) {
+            machineId = new File("/etc/machine-id");
+        }
+        if (!machineId.exists()) {
+            return UNKNOWN;
+        }
+
+        Scanner scanner = null;
+        try {
+            scanner = new Scanner(machineId);
+            String id = scanner.useDelimiter("\\A").next();
+            return Utils.hexStringify(Utils.sha256Hash(id.getBytes()));
+        } finally {
+            if (scanner != null) {
+                scanner.close();
+            }
+        }
+    }
+
+    private static String getMacOsIdentifier() throws SocketException, NoSuchAlgorithmException {
+        NetworkInterface networkInterface = NetworkInterface.getByName("en0");
+        byte[] hardwareAddress = networkInterface.getHardwareAddress();
+        return Utils.hexStringify(Utils.sha256Hash(hardwareAddress));
+    }
+
+    private static String getWindowsIdentifier() throws IOException, NoSuchAlgorithmException {
+        Runtime runtime = Runtime.getRuntime();
+        Process process = runtime.exec(new String[] { "wmic", "csproduct", "get", "UUID" });
+
+        String result = null;
+        InputStream is = process.getInputStream();
+        Scanner sc = new Scanner(process.getInputStream());
+        try {
+            while (sc.hasNext()) {
+                String next = sc.next();
+                if (next.contains("UUID")) {
+                    result = sc.next().trim();
+                    break;
+                }
+            }
+        } finally {
+            is.close();
+        }
+
+        return result==null?UNKNOWN:Utils.hexStringify(Utils.sha256Hash(result.getBytes()));
+    }
+}
diff --git a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
index a791be28e4..bd1709453b 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
@@ -133,7 +133,7 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
         return JSON_TEMPLATE
                 .replaceAll("%EVENT%", EVENT_NAME)
                 .replaceAll("%TOKEN%", TOKEN)
-                .replaceAll("%USER_ID%", getAnonymousUserId())
+                .replaceAll("%USER_ID%", ComputerIdentifierGenerator.get())
                 .replaceAll("%APP_ID%", getAnonymousAppId())
                 .replaceAll("%LANGUAGE%", usesKotlin?"kotlin":"java")
                 .replaceAll("%REALM_VERSION%", Version.VERSION)
@@ -141,25 +141,6 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
                 .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
     }
 
-    /**
-     * Computes an anonymous user id from the hashed MAC address of the first network interface
-     * @return the anonymous user id
-     * @throws NoSuchAlgorithmException
-     * @throws SocketException
-     */
-    public static String getAnonymousUserId() throws NoSuchAlgorithmException, SocketException {
-        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
-
-        if (!networkInterfaces.hasMoreElements()) {
-            throw new IllegalStateException("No network interfaces detected");
-        }
-
-        NetworkInterface networkInterface = networkInterfaces.nextElement();
-        byte[] hardwareAddress = networkInterface.getHardwareAddress(); // Normally this is the MAC address
-
-        return Utils.hexStringify(Utils.sha256Hash(hardwareAddress));
-    }
-
     /**
      * Computes an anonymous app/library id from the packages containing RealmObject classes
      * @return the anonymous app/library id
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index 4f2b60bc50..fe4dab1d3c 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -13,7 +13,7 @@ dependencies {
 
     testCompile files('../realm-library/build/intermediates/bundles/release/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
-    testCompile group:'junit', name:'junit', version:'4.11'
+    testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
     testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-21/android.jar"))
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 98f20d4777..94586963b4 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -94,7 +94,6 @@ public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
      * @return True if meta data was correctly created and processing can continue, false otherwise.
      */
     public boolean generate() {
-
         // Get the package of the class
         Element enclosingElement = classType.getEnclosingElement();
         if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
@@ -103,9 +102,9 @@ public boolean generate() {
         }
 
         TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
-        if (!parentElement.toString().endsWith(".RealmObject")) {
-            Utils.error("A RealmClass annotated object must be derived from RealmObject", classType);
-            return false;
+        if (!parentElement.toString().equals("java.lang.Object") && !parentElement.toString().equals("io.realm.RealmObject")) {
+                Utils.error("Realm model classes must either extend RealmObject or implement RealmModel to be considered a valid model class", classType);
+                return false;
         }
 
         PackageElement packageElement = (PackageElement) enclosingElement;
@@ -226,7 +225,7 @@ private boolean categorizeClassElements() {
                     } else if (Utils.isRealmList(variableElement)) {
                         Utils.error("@Required is invalid for field " + element +
                                 " with the type " + element.asType());
-                    } else if (Utils.isRealmObject(variableElement)) {
+                    } else if (Utils.isRealmModel(variableElement)) {
                         Utils.error("@Required is invalid for field " + element +
                                 " with the type " + element.asType());
                     } else {
@@ -329,13 +328,12 @@ public String getPrimaryKeyGetter() {
         return getGetter(primaryKey.getSimpleName().toString());
     }
 
+    /**
+     * Checks if a VariableElement is nullable.
+     *
+     * @return {@code true} if a VariableElement is nullable type, {@code false} otherwise.
+     */
     public boolean isNullable(VariableElement variableElement) {
-        // primary keys cannot be nullable
-        if (hasPrimaryKey()) {
-            if (variableElement.equals(getPrimaryKey())) {
-                return false;
-            }
-        }
         return nullableFields.contains(variableElement);
     }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index ffacfe4c23..c7bdee7c34 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -23,6 +23,7 @@
 import java.util.TreeSet;
 
 import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.lang.model.SourceVersion;
@@ -53,7 +54,7 @@
  * <ol>
  *  <li>Create proxy classes for all classes marked with @RealmClass. They are named &lt;className&gt;RealmProxy.java</li>
  *  <li>Create a DefaultRealmModule containing all RealmObject classes (if needed).</li>
- *  <li>Create a RealmProxyMediator class for all classes marked with @RealmModule. They are named <moduleName>Mediator.java</li>
+ *  <li>Create a RealmProxyMediator class for all classes marked with {@code @RealmModule}. They are named {@code <moduleName>Mediator.java}</li>
  * </ol>
  *
  * <h1>WHY</h1>
@@ -67,7 +68,7 @@
  * annotated with @RealmModule(library = true). It is not allowed to have both a class with library = true and
  * library = false in the same IntelliJ module and it will cause the annotation processor to throw an exception. If no
  * library modules are defined, we will create a DefaultRealmModule containing all known RealmObjects and with the
- * @RealmModule annotation. Realm automatically knows about this module, but it is still possible for users to create
+ * {@code @RealmModule} annotation. Realm automatically knows about this module, but it is still possible for users to create
  * their own modules with a subset of model classes.</li>
  *
  * <li>For each class annotated with @RealmModule a matching Mediator class is created (including the default one). This
@@ -113,7 +114,6 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         if (hasProcessedModules) {
             return true;
         }
-
         RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
         updateChecker.executeRealmVersionUpdate();
 
@@ -124,10 +124,17 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         // Create all proxy classes
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
+            // The class must either extend RealmObject or implement RealmModel
+            if (!Utils.isImplementingMarkerInterface(classElement)) {
+                Utils.error("A RealmClass annotated object must implement RealmModel or derive from RealmObject", classElement);
+            }
+
             // Check the annotation was applied to a Class
             if (!classElement.getKind().equals(ElementKind.CLASS)) {
                 Utils.error("The RealmClass annotation can only be applied to classes", classElement);
+                return true; // Abort processing by claiming all annotations
             }
+
             ClassMetaData metadata = new ClassMetaData(processingEnv, (TypeElement) classElement);
             if (!metadata.isModelClass()) {
                 continue;
@@ -135,7 +142,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             Utils.note("Processing class " + metadata.getSimpleClassName());
             boolean success = metadata.generate();
             if (!success) {
-                return true; // Abort processing by claiming all annotations
+                return true;
             }
             classesToValidate.add(metadata);
             packages.add(metadata.getPackageName());
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 46d853401c..92354116c2 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -69,6 +69,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.internal.ImplicitTransaction");
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
+        imports.add("io.realm.internal.Row");
         imports.add("java.io.IOException");
         imports.add("java.util.ArrayList");
         imports.add("java.util.Collections");
@@ -79,11 +80,13 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("org.json.JSONObject");
         imports.add("org.json.JSONException");
         imports.add("org.json.JSONArray");
+        imports.add("java.util.concurrent.Future");
+
         imports.add(metadata.getFullyQualifiedClassName());
 
         for (VariableElement field : metadata.getFields()) {
             String fieldTypeName = "";
-            if (Utils.isRealmObject(field)) { // Links
+            if (Utils.isRealmModel(field)) { // Links
                 fieldTypeName = field.asType().toString();
             } else if (Utils.isRealmList(field)) { // LinkLists
                 fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
@@ -122,6 +125,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitCreateDetachedCopyMethod(writer);
         emitUpdateMethod(writer);
         emitToStringMethod(writer);
+        emitRealmObjectProxyImplementation(writer);
         emitHashcodeMethod(writer);
         emitEqualsMethod(writer);
 
@@ -168,6 +172,8 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
 
     private void emitClassFields(JavaWriter writer) throws IOException {
         writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
+        writer.emitField("ProxyState", "proxyState", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
+
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
                 String genericType = Utils.getGenericType(variableElement);
@@ -190,6 +196,7 @@ private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
         writer.beginConstructor(EnumSet.noneOf(Modifier.class), "ColumnInfo", "columnInfo");
         writer.emitStatement("this.columnInfo = (%s) columnInfo", columnInfoClassName());
+        writer.emitStatement("this.proxyState = new ProxyState(%s.class, this)", className);
         writer.endConstructor();
         writer.emitEmptyLine();
     }
@@ -208,11 +215,11 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 // Getter
                 writer.emitAnnotation("SuppressWarnings", "\"cast\"");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
                 // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
                 if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
-                    writer.beginControlFlow("if (((RealmObject) this).row.isNull(%s))", fieldIndexVariableReference(field));
+                    writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field));
                     writer.emitStatement("return null");
                     writer.endControlFlow();
                 }
@@ -226,19 +233,19 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                     castingBackType = fieldTypeCanonicalName;
                 }
                 writer.emitStatement(
-                        "return (%s) ((RealmObject) this).row.get%s(%s)",
+                        "return (%s) proxyState.getRow$realm().get%s(%s)",
                         castingBackType, realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
                 // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
                 if (metadata.isNullable(field)) {
                     writer.beginControlFlow("if (value == null)")
-                        .emitStatement("((RealmObject) this).row.setNull(%s)", fieldIndexVariableReference(field))
+                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
                         .emitStatement("return")
                     .endControlFlow();
                 } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
@@ -249,39 +256,39 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                         .endControlFlow();
                 }
                 writer.emitStatement(
-                        "((RealmObject) this).row.set%s(%s, value)",
+                        "proxyState.getRow$realm().set%s(%s, value)",
                         realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
-            } else if (Utils.isRealmObject(field)) {
+            } else if (Utils.isRealmModel(field)) {
                 /**
                  * Links
                  */
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
-                writer.beginControlFlow("if (((RealmObject) this).row.isNullLink(%s))", fieldIndexVariableReference(field));
+                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+                writer.beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field));
                         writer.emitStatement("return null");
                         writer.endControlFlow();
-                writer.emitStatement("return ((RealmObject) this).realm.get(%s.class, ((RealmObject) this).row.getLink(%s))",
+                writer.emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s))",
                         fieldTypeCanonicalName, fieldIndexVariableReference(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (value == null)");
-                    writer.emitStatement("((RealmObject) this).row.nullifyLink(%s)", fieldIndexVariableReference(field));
+                    writer.emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field));
                     writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!value.isValid())");
+                writer.beginControlFlow("if (!RealmObject.isValid(value))");
                     writer.emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")");
                 writer.endControlFlow();
-                writer.beginControlFlow("if (value.realm != this.realm)");
+                writer.beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
                     writer.emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")");
                 writer.endControlFlow();
-                writer.emitStatement("((RealmObject) this).row.setLink(%s, ((RealmObject) value).row.getIndex())", fieldIndexVariableReference(field));
+                writer.emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field));
                 writer.endMethod();
             } else if (Utils.isRealmList(field)) {
                 /**
@@ -291,13 +298,13 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.emitSingleLineComment("use the cached value if available");
                 writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
                         writer.emitStatement("return " + fieldName + "RealmList");
                 writer.nextControlFlow("else");
-                    writer.emitStatement("LinkView linkView = ((RealmObject) this).row.getLinkList(%s)", fieldIndexVariableReference(field));
-                    writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, realm)",
+                    writer.emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
+                    writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
                         genericType, genericType);
                     writer.emitStatement("return " + fieldName + "RealmList");
                 writer.endControlFlow();
@@ -307,20 +314,20 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
-                writer.emitStatement("LinkView links = ((RealmObject) this).row.getLinkList(%s)", fieldIndexVariableReference(field));
+                writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+                writer.emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
                 writer.emitStatement("links.clear()");
                 writer.beginControlFlow("if (value == null)");
                     writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
-                    writer.beginControlFlow("if (!linkedObject.isValid())");
+                writer.beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)");
+                    writer.beginControlFlow("if (!RealmObject.isValid(linkedObject))");
                         writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")");
                     writer.endControlFlow();
-                    writer.beginControlFlow("if (linkedObject.realm != this.realm)");
+                    writer.beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
                         writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")");
                     writer.endControlFlow();
-                    writer.emitStatement("links.add(((RealmObject) linkedObject).row.getIndex())");
+                    writer.emitStatement("links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex())");
                 writer.endControlFlow();
                 writer.endMethod();
             } else {
@@ -331,6 +338,14 @@ private void emitAccessors(JavaWriter writer) throws IOException {
         }
     }
 
+    private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod("ProxyState", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC));
+        writer.emitStatement("return proxyState");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitInitTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 "Table", // Return type
@@ -357,7 +372,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("table.addColumn(%s, \"%s\", %s)",
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         fieldName, nullableFlag);
-            } else if (Utils.isRealmObject(field)) {
+            } else if (Utils.isRealmModel(field)) {
                 writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
                 writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
@@ -442,35 +457,51 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 // make sure that nullability matches
                 if (metadata.isNullable(field)) {
                     writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                    if (Utils.isBoxedType(fieldTypeCanonicalName)) {
+                    // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
+                    if (field.equals(metadata.getPrimaryKey())) {
+                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
+                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
+                                fieldName);
+                    // nullability check for boxed types
+                    } else if (Utils.isBoxedType(fieldTypeCanonicalName)) {
                         writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
                                 "\"Field '%s' does not support null values in the existing Realm file. " +
                                 "Either set @Required, use the primitive type for field '%s' " +
-                                "or migrate using io.realm.internal.Table.convertColumnToNullable()." +
-                                "\")",
+                                "or migrate using RealmObjectSchema.setNullable().\")",
                                 fieldName, fieldName);
                     } else {
                         writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
                                 " \"Field '%s' is required. Either set @Required to field '%s' " +
-                                "or migrate using io.realm.internal.Table.convertColumnToNullable()." +
-                                "\")",
+                                "or migrate using RealmObjectSchema.setNullable().\")",
                                 fieldName, fieldName);
                     }
                     writer.endControlFlow();
                 } else {
-                    writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                    if (Utils.isPrimitiveType(fieldTypeCanonicalName)) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
-                                " \"Field '%s' does support null values in the existing Realm file. " +
-                                "Use corresponding boxed type for field '%s' or migrate using io.realm.internal.Table.convertColumnToNotNullable().\")",
-                                fieldName, fieldName);
+                    // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
+                    if (field.equals(metadata.getPrimaryKey())) {
+                        writer
+                            .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != TableOrView.NO_MATCH)",
+                                    fieldIndexVariableReference(field), fieldIndexVariableReference(field))
+                            .emitStatement("throw new IllegalStateException(\"Cannot migrate an object with null value in field '%s'." +
+                                    " Either maintain the same type for primary key field '%s', or remove the object with null value before migration.\")",
+                                    fieldName, fieldName)
+                            .endControlFlow();
                     } else {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
-                                " \"Field '%s' does support null values in the existing Realm file. " +
-                                "Remove @Required or @PrimaryKey from field '%s' or migrate using io.realm.internal.Table.convertColumnToNotNullable().\")",
-                                fieldName, fieldName);
+                        writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
+                        if (Utils.isPrimitiveType(fieldTypeCanonicalName)) {
+                            writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                    " \"Field '%s' does support null values in the existing Realm file. " +
+                                    "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
+                                    fieldName, fieldName);
+                        } else {
+                            writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                    " \"Field '%s' does support null values in the existing Realm file. " +
+                                    "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
+                                    fieldName, fieldName);
+                        }
+                        writer.endControlFlow();
                     }
-                    writer.endControlFlow();
                 }
 
                 // Validate @PrimaryKey
@@ -488,7 +519,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     writer.endControlFlow();
                 }
 
-            } else if (Utils.isRealmObject(field)) { // Links
+            } else if (Utils.isRealmModel(field)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
                         "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
@@ -560,18 +591,18 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 className, // Return type
                 "copyOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "object", "boolean", "update", "Map<RealmObject,RealmObjectProxy>", "cache" // Argument type & argument name
+                "Realm", "realm", className, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
         writer
-            .beginControlFlow("if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId)")
+            .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
                 .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
                         " threads cannot be copied into this Realm instance.\")")
             .endControlFlow();
 
         // If object is already in the Realm there is nothing to update
         writer
-            .beginControlFlow("if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath()))")
+            .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                 .emitStatement("return object")
             .endControlFlow();
 
@@ -586,16 +617,31 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
 
             String primaryKeyGetter = metadata.getPrimaryKeyGetter();
-            if (Utils.isString(metadata.getPrimaryKey())) {
-                writer
-                    .beginControlFlow("if (((%s) object).%s() == null)", interfaceName, primaryKeyGetter)
-                        .emitStatement("throw new IllegalArgumentException(\"Primary key value must not be null.\")")
-                    .endControlFlow()
-                    .emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, ((%s) object).%s())",
-                            interfaceName, primaryKeyGetter);
+            VariableElement primaryKeyElement = metadata.getPrimaryKey();
+            if (metadata.isNullable(primaryKeyElement)) {
+                if (Utils.isString(primaryKeyElement)) {
+                    writer
+                        .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                        .beginControlFlow("if (value == null)")
+                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                        .nextControlFlow("else")
+                            .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                        .endControlFlow();
+                } else {
+                    writer
+                        .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                        .beginControlFlow("if (value == null)")
+                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                        .nextControlFlow("else")
+                            .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                        .endControlFlow();
+                }
             } else {
-                writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, ((%s) object).%s())",
-                        interfaceName, primaryKeyGetter);
+                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                        pkType, interfaceName, primaryKeyGetter);
             }
 
             writer
@@ -603,8 +649,8 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     .emitStatement("realmObject = new %s(realm.schema.getColumnInfo(%s.class))",
                             Utils.getProxyClassName(className),
                             className)
-                    .emitStatement("((RealmObject) realmObject).realm = realm")
-                    .emitStatement("((RealmObject) realmObject).row = table.getUncheckedRow(rowIndex)")
+                    .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm)")
+                    .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
                     .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                 .nextControlFlow("else")
                     .emitStatement("canUpdate = false")
@@ -630,7 +676,7 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 className, // Return type
                 "copy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmObject,RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
 
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("%s realmObject = realm.createObject(%s.class, ((%s) newObject).%s())",
@@ -645,7 +691,7 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
 
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 writer
                     .emitEmptyLine()
                     .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
@@ -700,12 +746,12 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 className, // Return type
                 "createDetachedCopy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                className, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmObject, CacheData<RealmObject>>", "cache");
+                className, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
         writer
             .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                 .emitStatement("return null")
             .endControlFlow()
-            .emitStatement("CacheData<RealmObject> cachedObject = cache.get(realmObject)")
+            .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
             .emitStatement("%s standaloneObject", className)
             .beginControlFlow("if (cachedObject != null)")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
@@ -717,7 +763,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 .endControlFlow()
             .nextControlFlow("else")
                 .emitStatement("standaloneObject = new %s()", className)
-                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject))")
+                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject))")
             .endControlFlow();
 
         for (VariableElement field : metadata.getFields()) {
@@ -725,7 +771,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
             String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
 
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
@@ -770,13 +816,13 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                 className, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmObject, RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 writer
                     .emitStatement("%s %sObj = ((%s) newObject).%s()",
                             Utils.getFieldTypeSimpleName(field), fieldName, interfaceName, getter)
@@ -836,7 +882,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
         }
         writer.emitAnnotation("Override");
         writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
-        writer.beginControlFlow("if (!isValid())");
+        writer.beginControlFlow("if (!RealmObject.isValid(this))");
         writer.emitStatement("return \"Invalid object\"");
         writer.endControlFlow();
         writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
@@ -846,7 +892,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
             String fieldName = field.getSimpleName().toString();
 
             writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                 writer.emitStatement(
                         "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
@@ -881,15 +927,20 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    /**
+     * Currently, the hash value emitted from this could suddenly change as an object's index might
+     * alternate due to Realm Java using {@code Table#moveLastOver()}. Hash codes should therefore not
+     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
+     */
     private void emitHashcodeMethod(JavaWriter writer) throws IOException {
         if (metadata.containsHashCode()) {
             return;
         }
         writer.emitAnnotation("Override");
         writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
-        writer.emitStatement("String realmName = ((RealmObject) this).realm.getPath()");
-        writer.emitStatement("String tableName = ((RealmObject) this).row.getTable().getName()");
-        writer.emitStatement("long rowIndex = ((RealmObject) this).row.getIndex()");
+        writer.emitStatement("String realmName = proxyState.getRealm$realm().getPath()");
+        writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
+        writer.emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()");
         writer.emitEmptyLine();
         writer.emitStatement("int result = 17");
         writer.emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)");
@@ -911,15 +962,15 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
         writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
         writer.emitEmptyLine();
-        writer.emitStatement("String path = ((RealmObject) this).realm.getPath()");
-        writer.emitStatement("String otherPath = ((RealmObject) a%s).realm.getPath()", className);
+        writer.emitStatement("String path = proxyState.getRealm$realm().getPath()");
+        writer.emitStatement("String otherPath = a%s.proxyState.getRealm$realm().getPath()", className);
         writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false;");
         writer.emitEmptyLine();
-        writer.emitStatement("String tableName = ((RealmObject) this).row.getTable().getName()");
-        writer.emitStatement("String otherTableName = ((RealmObject) a%s).row.getTable().getName()", className);
+        writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
+        writer.emitStatement("String otherTableName = a%s.proxyState.getRow$realm().getTable().getName()", className);
         writer.emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false");
         writer.emitEmptyLine();
-        writer.emitStatement("if (((RealmObject) this).row.getIndex() != ((RealmObject) a%s).row.getIndex()) return false", className);
+        writer.emitStatement("if (proxyState.getRow$realm().getIndex() != a%s.proxyState.getRow$realm().getIndex()) return false", className);
         writer.emitEmptyLine();
         writer.emitStatement("return true");
         writer.endMethod();
@@ -945,16 +996,28 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                 .beginControlFlow("if (update)")
                     .emitStatement("Table table = realm.getTable(%s.class)", className)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
+                    .emitStatement("long rowIndex = TableOrView.NO_MATCH");
+            if (metadata.isNullable(metadata.getPrimaryKey())) {
+                writer
+                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                        .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                    .nextControlFlow("else")
+                        .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                    .endControlFlow();
+            } else {
+                writer
                     .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                    .emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                    .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                             pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                    .endControlFlow();
+            }
+            writer
                     .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                            .emitStatement("obj = new %s(realm.schema.getColumnInfo(%s.class))",
-                                    Utils.getProxyClassName(className),
-                                    className)
-                            .emitStatement("((RealmObject) obj).realm = realm")
-                            .emitStatement("((RealmObject) obj).row = table.getUncheckedRow(rowIndex)")
-                        .endControlFlow()
+                        .emitStatement("obj = new %s(realm.schema.getColumnInfo(%s.class))",
+                                Utils.getProxyClassName(className), className)
+                        .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm)")
+                        .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
                     .endControlFlow()
                 .endControlFlow();
 
@@ -968,7 +1031,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                         interfaceName,
                         metadata.getSetter(fieldName),
@@ -1029,7 +1092,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             } else {
                 writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
             }
-            if (Utils.isRealmObject(field)) {
+            if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                         interfaceName,
                         metadata.getSetter(fieldName),
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 28510955bd..7a963457c5 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -109,9 +109,9 @@ public void generate() throws IOException {
     }
 
     private void emitFields(JavaWriter writer) throws IOException {
-        writer.emitField("Set<Class<? extends RealmObject>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
-        writer.emitStatement("Set<Class<? extends RealmObject>> modelClasses = new HashSet<Class<? extends RealmObject>>()");
+        writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>()");
         for (String clazz : simpleModelClasses) {
             writer.emitStatement("modelClasses.add(%s.class)", clazz);
         }
@@ -126,7 +126,7 @@ private void emitCreateTableMethod(JavaWriter writer) throws IOException {
                 "Table",
                 "createTable",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmObject>", "clazz", "ImplicitTransaction", "transaction"
+                "Class<? extends RealmModel>", "clazz", "ImplicitTransaction", "transaction"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
@@ -144,7 +144,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 "ColumnInfo",
                 "validateTable",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmObject>", "clazz", "ImplicitTransaction", "transaction"
+                "Class<? extends RealmModel>", "clazz", "ImplicitTransaction", "transaction"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
@@ -162,7 +162,7 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
                 "List<String>",
                 "getFieldNames",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmObject>", "clazz"
+                "Class<? extends RealmModel>", "clazz"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
@@ -180,7 +180,7 @@ private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
                 "String",
                 "getTableName",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmObject>", "clazz"
+                "Class<? extends RealmModel>", "clazz"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
@@ -195,7 +195,7 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> E",
+                "<E extends RealmModel> E",
                 "newInstance",
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<E>", "clazz", "ColumnInfo", "columnInfo"
@@ -212,7 +212,7 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
 
     private void emitGetClassModelList(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
-        writer.beginMethod("Set<Class<? extends RealmObject>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC));
+        writer.beginMethod("Set<Class<? extends RealmModel>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC));
         writer.emitStatement("return MODEL_CLASSES");
         writer.endMethod();
         writer.emitEmptyLine();
@@ -221,10 +221,10 @@ private void emitGetClassModelList(JavaWriter writer) throws IOException {
     private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> E",
+                "<E extends RealmModel> E",
                 "copyOrUpdate",
                 EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmObject, RealmObjectProxy>",  "cache"
+                "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmModel, RealmObjectProxy>",  "cache"
         );
         writer.emitSingleLineComment("This cast is correct because obj is either");
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
@@ -243,7 +243,7 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> E",
+                "<E extends RealmModel> E",
                 "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC),
                 Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
@@ -262,7 +262,7 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> E",
+                "<E extends RealmModel> E",
                 "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC),
                 Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
@@ -281,10 +281,10 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "<E extends RealmObject> E",
+                "<E extends RealmModel> E",
                 "createDetachedCopy",
                 EnumSet.of(Modifier.PUBLIC),
-                "E", "realmObject", "int", "maxDepth", "Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>>", "cache"
+                "E", "realmObject", "int", "maxDepth", "Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>>", "cache"
         );
         writer.emitSingleLineComment("This cast is correct because obj is either");
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 8eccdafb94..8f0dd71b41 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -1,8 +1,5 @@
 package io.realm.processor;
 
-import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
 import javax.annotation.processing.Messager;
@@ -16,7 +13,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
-import javax.xml.bind.DatatypeConverter;
 
 /**
  * Utility methods working with the Realm processor.
@@ -26,14 +22,16 @@
     public static Types typeUtils;
     private static Messager messager;
     private static DeclaredType realmList;
-    private static TypeMirror realmObject;
+    private static DeclaredType markerInterface;
+    private static TypeMirror realmModel;
 
     public static void initialize(ProcessingEnvironment env) {
         typeUtils = env.getTypeUtils();
         messager = env.getMessager();
         realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"),
                 typeUtils.getWildcardType(null, null));
-        realmObject = env.getElementUtils().getTypeElement("io.realm.RealmObject").asType();
+        realmModel = env.getElementUtils().getTypeElement("io.realm.RealmModel").asType();
+        markerInterface = env.getTypeUtils().getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmModel"));
     }
 
     /**
@@ -137,19 +135,27 @@ public static boolean isString(String fieldType) {
     }
 
     /**
-     * @return {@code true} if a given field type is "RealmList", {@code false} otherwise.
+     * @return {@code true} if a given type implement {@code RealmModel}, {@code false} otherwise.
+     */
+    public static boolean isImplementingMarkerInterface(Element classElement) {
+        return typeUtils.isAssignable(classElement.asType(), markerInterface);
+    }
+
+    /**
+     * @return {@code true} if a given field type is {@code RealmList}, {@code false} otherwise.
      */
     public static boolean isRealmList(VariableElement field) {
         return typeUtils.isAssignable(field.asType(), realmList);
     }
 
     /**
-     * @return {@code true} if a given field type is "RealmObject", {@code false} otherwise.
+     * @return {@code true} if a given field type is {@code RealmModel}, {@code false} otherwise.
      */
-    public static boolean isRealmObject(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmObject);
+    public static boolean isRealmModel(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmModel);
     }
 
+
     /**
      * @return the simple type name for a field.
      */
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index b7b8f064b0..7bea9166ea 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -49,6 +49,12 @@
     private JavaFileObject nullTypesProxy = JavaFileObjects.forResource("io/realm/NullTypesRealmProxy.java");
     private JavaFileObject missingGenericTypeModel = JavaFileObjects.forResource("some/test/MissingGenericType.java");
     private JavaFileObject conflictingFieldNameModel = JavaFileObjects.forResource("some/test/ConflictingFieldName.java");
+    private JavaFileObject invalidRealmModelModel_1 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_1.java");
+    private JavaFileObject invalidRealmModelModel_2 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_2.java");
+    private JavaFileObject invalidRealmModelModel_3 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_3.java");
+    private JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
+    private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
+    private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
 
     @Test
     public void compileSimpleFile() {
@@ -386,4 +392,55 @@ public void failOnVolatileFields() throws Exception {
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
+
+    // annotation without implementing RealmModel interface
+    @Test
+    public void failOnInvalidRealmModel_1() throws Exception {
+        ASSERT.about(javaSource())
+                .that(invalidRealmModelModel_1)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    // it's not allowed to extend from another RealmObject
+    @Test
+    public void failOnInvalidRealmModel_2() throws Exception {
+        ASSERT.about(javaSource())
+                .that(invalidRealmModelModel_2)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    // it's not allowed to extend from another RealmObject
+    @Test
+    public void failOnInvalidRealmModel_3() throws Exception {
+        ASSERT.about(javaSource())
+                .that(invalidRealmModelModel_3)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void validRealmModelUsingInheritance() throws Exception {
+        ASSERT.about(javaSource())
+                .that(ValidModelPojo_ExtendingRealmObject)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void canNotInheritRealmList() throws Exception {
+        ASSERT.about(javaSource())
+                .that(UseExtendRealmList)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileWithRealmModelFieldInReamlModel() {
+        ASSERT.about(javaSource())
+                .that(SimpleRealmModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 2bc6e1a3bc..5d28d96813 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -19,13 +20,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import some.test.AllTypes;
 
 public class AllTypesRealmProxy extends AllTypes
-    implements RealmObjectProxy, AllTypesRealmProxyInterface {
+        implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
     static final class AllTypesColumnInfo extends ColumnInfo {
 
@@ -73,6 +75,7 @@
     }
 
     private final AllTypesColumnInfo columnInfo;
+    private final ProxyState proxyState;
     private RealmList<AllTypes> columnRealmListRealmList;
     private static final List<String> FIELD_NAMES;
     static {
@@ -91,151 +94,153 @@
 
     AllTypesRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (AllTypesColumnInfo) columnInfo;
+        this.proxyState = new ProxyState(AllTypes.class, this);
     }
 
     @SuppressWarnings("cast")
     public String realmGet$columnString() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.columnStringIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
     }
 
     public void realmSet$columnString(String value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field columnString to null.");
+            proxyState.getRow$realm().setNull(columnInfo.columnStringIndex);
+            return;
         }
-        ((RealmObject) this).row.setString(columnInfo.columnStringIndex, value);
+        proxyState.getRow$realm().setString(columnInfo.columnStringIndex, value);
     }
 
     @SuppressWarnings("cast")
     public long realmGet$columnLong() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (long) ((RealmObject) this).row.getLong(columnInfo.columnLongIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
     }
 
     public void realmSet$columnLong(long value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setLong(columnInfo.columnLongIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
     }
 
     @SuppressWarnings("cast")
     public float realmGet$columnFloat() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (float) ((RealmObject) this).row.getFloat(columnInfo.columnFloatIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
     }
 
     public void realmSet$columnFloat(float value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setFloat(columnInfo.columnFloatIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
     }
 
     @SuppressWarnings("cast")
     public double realmGet$columnDouble() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (double) ((RealmObject) this).row.getDouble(columnInfo.columnDoubleIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
     }
 
     public void realmSet$columnDouble(double value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setDouble(columnInfo.columnDoubleIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$columnBoolean() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.columnBooleanIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
     }
 
     public void realmSet$columnBoolean(boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setBoolean(columnInfo.columnBooleanIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Date realmGet$columnDate() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (java.util.Date) ((RealmObject) this).row.getDate(columnInfo.columnDateIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
     }
 
     public void realmSet$columnDate(Date value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field columnDate to null.");
         }
-        ((RealmObject) this).row.setDate(columnInfo.columnDateIndex, value);
+        proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
     }
 
     @SuppressWarnings("cast")
     public byte[] realmGet$columnBinary() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (byte[]) ((RealmObject) this).row.getBinaryByteArray(columnInfo.columnBinaryIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
     }
 
     public void realmSet$columnBinary(byte[] value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field columnBinary to null.");
         }
-        ((RealmObject) this).row.setBinaryByteArray(columnInfo.columnBinaryIndex, value);
+        proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
     }
 
     public AllTypes realmGet$columnObject() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNullLink(columnInfo.columnObjectIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
             return null;
         }
-        return ((RealmObject) this).realm.get(some.test.AllTypes.class, ((RealmObject) this).row.getLink(columnInfo.columnObjectIndex));
+        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex));
     }
 
     public void realmSet$columnObject(AllTypes value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.nullifyLink(columnInfo.columnObjectIndex);
+            proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
             return;
         }
-        if (!value.isValid()) {
+        if (!RealmObject.isValid(value)) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
-        if (value.realm != this.realm) {
+        if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
             throw new IllegalArgumentException("'value' belongs to a different Realm.");
         }
-        ((RealmObject) this).row.setLink(columnInfo.columnObjectIndex, ((RealmObject) value).row.getIndex());
+        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
     public RealmList<AllTypes> realmGet$columnRealmList() {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         // use the cached value if available
         if (columnRealmListRealmList != null) {
             return columnRealmListRealmList;
         } else {
-            LinkView linkView = ((RealmObject) this).row.getLinkList(columnInfo.columnRealmListIndex);
-            columnRealmListRealmList = new RealmList<AllTypes>(AllTypes.class, linkView, realm);
+            LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
+            columnRealmListRealmList = new RealmList<AllTypes>(AllTypes.class, linkView, proxyState.getRealm$realm());
             return columnRealmListRealmList;
         }
     }
 
     public void realmSet$columnRealmList(RealmList<AllTypes> value) {
-        ((RealmObject) this).realm.checkIfValid();
-        LinkView links = ((RealmObject) this).row.getLinkList(columnInfo.columnRealmListIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
         links.clear();
         if (value == null) {
             return;
         }
-        for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value) {
-            if (!linkedObject.isValid()) {
+        for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
+            if (!RealmObject.isValid(linkedObject)) {
                 throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
             }
-            if (linkedObject.realm != this.realm) {
+            if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                 throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
             }
-            links.add(((RealmObject) linkedObject).row.getIndex());
+            links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex());
         }
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
         if (!transaction.hasTable("class_AllTypes")) {
             Table table = transaction.getTable("class_AllTypes");
-            table.addColumn(RealmFieldType.STRING, "columnString", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.STRING, "columnString", Table.NULLABLE);
             table.addColumn(RealmFieldType.INTEGER, "columnLong", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.FLOAT, "columnFloat", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.DOUBLE, "columnDouble", Table.NOT_NULLABLE);
@@ -276,8 +281,8 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
             if (columnTypes.get("columnString") != RealmFieldType.STRING) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
             }
-            if (table.isColumnNullable(columnInfo.columnStringIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnString' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnString' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
             }
             if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
@@ -292,7 +297,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnLongIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnFloat")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -301,7 +306,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnDouble")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -310,7 +315,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnBoolean")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -319,7 +324,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnDate")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -328,7 +333,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnDateIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnBinary")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -337,7 +342,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnObject")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -386,13 +391,16 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
         if (update) {
             Table table = realm.getTable(AllTypes.class);
             long pkColumnIndex = table.getPrimaryKey();
-            if (!json.isNull("columnString")) {
-                long rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
-                if (rowIndex != TableOrView.NO_MATCH) {
-                    obj = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
-                    ((RealmObject) obj).realm = realm;
-                    ((RealmObject) obj).row = table.getUncheckedRow(rowIndex);
-                }
+            long rowIndex = TableOrView.NO_MATCH;
+            if (json.isNull("columnString")) {
+                rowIndex = table.findFirstNull(pkColumnIndex);
+            } else {
+                rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
+            }
+            if (rowIndex != TableOrView.NO_MATCH) {
+                obj = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
+                ((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm);
+                ((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
             }
         }
         if (obj == null) {
@@ -572,12 +580,11 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
-            throw new IllegalArgumentException(
-                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
+            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
         AllTypes realmObject = null;
@@ -585,14 +592,17 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
         if (canUpdate) {
             Table table = realm.getTable(AllTypes.class);
             long pkColumnIndex = table.getPrimaryKey();
-            if (((AllTypesRealmProxyInterface) object).realmGet$columnString() == null) {
-                throw new IllegalArgumentException("Primary key value must not be null.");
+            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+            long rowIndex = TableOrView.NO_MATCH;
+            if (value == null) {
+                rowIndex = table.findFirstNull(pkColumnIndex);
+            } else {
+                rowIndex = table.findFirstString(pkColumnIndex, value);
             }
-            long rowIndex = table.findFirstString(pkColumnIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnString());
             if (rowIndex != TableOrView.NO_MATCH) {
                 realmObject = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
-                ((RealmObject) realmObject).realm = realm;
-                ((RealmObject) realmObject).row = table.getUncheckedRow(rowIndex);
+                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
+                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
                 cache.put(object, (RealmObjectProxy) realmObject);
             } else {
                 canUpdate = false;
@@ -606,7 +616,7 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
         }
     }
 
-    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         AllTypes realmObject = realm.createObject(AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
         cache.put(newObject, (RealmObjectProxy) realmObject);
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
@@ -646,11 +656,11 @@ public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map
         return realmObject;
     }
 
-    public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+    public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
-        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        CacheData<RealmModel> cachedObject = cache.get(realmObject);
         AllTypes standaloneObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
@@ -662,7 +672,7 @@ public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth
             }
         } else {
             standaloneObject = new AllTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
         }
         ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
         ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
@@ -692,7 +702,7 @@ public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth
         return standaloneObject;
     }
 
-    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmObject, RealmObjectProxy> cache) {
+    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
@@ -729,12 +739,12 @@ static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Ma
 
     @Override
     public String toString() {
-        if (!isValid()) {
+        if (!RealmObject.isValid(this)) {
             return "Invalid object";
         }
         StringBuilder stringBuilder = new StringBuilder("AllTypes = [");
         stringBuilder.append("{columnString:");
-        stringBuilder.append(realmGet$columnString());
+        stringBuilder.append(realmGet$columnString() != null ? realmGet$columnString() : "null");
         stringBuilder.append("}");
         stringBuilder.append(",");
         stringBuilder.append("{columnLong:");
@@ -772,11 +782,16 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+    @Override
+    public ProxyState realmGet$proxyState() {
+        return proxyState;
+    }
+
     @Override
     public int hashCode() {
-        String realmName = ((RealmObject) this).realm.getPath();
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        long rowIndex = ((RealmObject) this).row.getIndex();
+        String realmName = proxyState.getRealm$realm().getPath();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        long rowIndex = proxyState.getRow$realm().getIndex();
 
         int result = 17;
         result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
@@ -791,15 +806,15 @@ public boolean equals(Object o) {
         if (o == null || getClass() != o.getClass()) return false;
         AllTypesRealmProxy aAllTypes = (AllTypesRealmProxy)o;
 
-        String path = ((RealmObject) this).realm.getPath();
-        String otherPath = ((RealmObject) aAllTypes).realm.getPath();
+        String path = proxyState.getRealm$realm().getPath();
+        String otherPath = aAllTypes.proxyState.getRealm$realm().getPath();
         if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
 
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        String otherTableName = ((RealmObject) aAllTypes).row.getTable().getName();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        String otherTableName = aAllTypes.proxyState.getRow$realm().getTable().getName();
         if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
 
-        if (((RealmObject) this).row.getIndex() != ((RealmObject) aAllTypes).row.getIndex()) return false;
+        if (proxyState.getRow$realm().getIndex() != aAllTypes.proxyState.getRow$realm().getIndex()) return false;
 
         return true;
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index d9ed8c1fb3..468e4c1f51 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -19,13 +20,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import some.test.Booleans;
 
 public class BooleansRealmProxy extends Booleans
-    implements RealmObjectProxy, BooleansRealmProxyInterface {
+        implements RealmObjectProxy, BooleansRealmProxyInterface {
 
     static final class BooleansColumnInfo extends ColumnInfo {
 
@@ -53,6 +55,7 @@
     }
 
     private final BooleansColumnInfo columnInfo;
+    private final ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -65,50 +68,51 @@
 
     BooleansRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (BooleansColumnInfo) columnInfo;
+        this.proxyState = new ProxyState(Booleans.class, this);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$done() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.doneIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.doneIndex);
     }
 
     public void realmSet$done(boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setBoolean(columnInfo.doneIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setBoolean(columnInfo.doneIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$isReady() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.isReadyIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.isReadyIndex);
     }
 
     public void realmSet$isReady(boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setBoolean(columnInfo.isReadyIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setBoolean(columnInfo.isReadyIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$mCompleted() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.mCompletedIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.mCompletedIndex);
     }
 
     public void realmSet$mCompleted(boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setBoolean(columnInfo.mCompletedIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setBoolean(columnInfo.mCompletedIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$anotherBoolean() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.anotherBooleanIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.anotherBooleanIndex);
     }
 
     public void realmSet$anotherBoolean(boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setBoolean(columnInfo.anotherBooleanIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setBoolean(columnInfo.anotherBooleanIndex, value);
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -144,7 +148,7 @@ public static BooleansColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.doneIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("isReady")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -153,7 +157,7 @@ public static BooleansColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.isReadyIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("mCompleted")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -162,7 +166,7 @@ public static BooleansColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("anotherBoolean")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -171,7 +175,7 @@ public static BooleansColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
             }
             return columnInfo;
         } else {
@@ -265,18 +269,17 @@ public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
-            throw new IllegalArgumentException(
-                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
+            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
         return copy(realm, object, update, cache);
     }
 
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         Booleans realmObject = realm.createObject(Booleans.class);
         cache.put(newObject, (RealmObjectProxy) realmObject);
         ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
@@ -286,11 +289,11 @@ public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map
         return realmObject;
     }
 
-    public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+    public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
-        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        CacheData<RealmModel> cachedObject = cache.get(realmObject);
         Booleans standaloneObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
@@ -302,7 +305,7 @@ public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth
             }
         } else {
             standaloneObject = new Booleans();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
         }
         ((BooleansRealmProxyInterface) standaloneObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
         ((BooleansRealmProxyInterface) standaloneObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
@@ -313,7 +316,7 @@ public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth
 
     @Override
     public String toString() {
-        if (!isValid()) {
+        if (!RealmObject.isValid(this)) {
             return "Invalid object";
         }
         StringBuilder stringBuilder = new StringBuilder("Booleans = [");
@@ -336,11 +339,16 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+    @Override
+    public ProxyState realmGet$proxyState() {
+        return proxyState;
+    }
+
     @Override
     public int hashCode() {
-        String realmName = ((RealmObject) this).realm.getPath();
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        long rowIndex = ((RealmObject) this).row.getIndex();
+        String realmName = proxyState.getRealm$realm().getPath();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        long rowIndex = proxyState.getRow$realm().getIndex();
 
         int result = 17;
         result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
@@ -355,17 +363,17 @@ public boolean equals(Object o) {
         if (o == null || getClass() != o.getClass()) return false;
         BooleansRealmProxy aBooleans = (BooleansRealmProxy)o;
 
-        String path = ((RealmObject) this).realm.getPath();
-        String otherPath = ((RealmObject) aBooleans).realm.getPath();
+        String path = proxyState.getRealm$realm().getPath();
+        String otherPath = aBooleans.proxyState.getRealm$realm().getPath();
         if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
 
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        String otherTableName = ((RealmObject) aBooleans).row.getTable().getName();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        String otherTableName = aBooleans.proxyState.getRow$realm().getTable().getName();
         if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
 
-        if (((RealmObject) this).row.getIndex() != ((RealmObject) aBooleans).row.getIndex()) return false;
+        if (proxyState.getRow$realm().getIndex() != aBooleans.proxyState.getRow$realm().getIndex()) return false;
 
         return true;
     }
 
-}
+}
\ No newline at end of file
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index f33f78d817..2001284f7f 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -19,13 +20,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import some.test.NullTypes;
 
 public class NullTypesRealmProxy extends NullTypes
-    implements RealmObjectProxy, NullTypesRealmProxyInterface {
+        implements RealmObjectProxy, NullTypesRealmProxyInterface {
 
     static final class NullTypesColumnInfo extends ColumnInfo {
 
@@ -121,6 +123,7 @@
     }
 
     private final NullTypesColumnInfo columnInfo;
+    private final ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -150,343 +153,344 @@
 
     NullTypesRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (NullTypesColumnInfo) columnInfo;
+        this.proxyState = new ProxyState(NullTypes.class, this);
     }
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.fieldStringNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNotNullIndex);
     }
 
     public void realmSet$fieldStringNotNull(String value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldStringNotNull to null.");
         }
-        ((RealmObject) this).row.setString(columnInfo.fieldStringNotNullIndex, value);
+        proxyState.getRow$realm().setString(columnInfo.fieldStringNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.fieldStringNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNullIndex);
     }
 
     public void realmSet$fieldStringNull(String value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldStringNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldStringNullIndex);
             return;
         }
-        ((RealmObject) this).row.setString(columnInfo.fieldStringNullIndex, value);
+        proxyState.getRow$realm().setString(columnInfo.fieldStringNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.fieldBooleanNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNotNullIndex);
     }
 
     public void realmSet$fieldBooleanNotNull(Boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldBooleanNotNull to null.");
         }
-        ((RealmObject) this).row.setBoolean(columnInfo.fieldBooleanNotNullIndex, value);
+        proxyState.getRow$realm().setBoolean(columnInfo.fieldBooleanNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldBooleanNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldBooleanNullIndex)) {
             return null;
         }
-        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.fieldBooleanNullIndex);
+        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNullIndex);
     }
 
     public void realmSet$fieldBooleanNull(Boolean value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldBooleanNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldBooleanNullIndex);
             return;
         }
-        ((RealmObject) this).row.setBoolean(columnInfo.fieldBooleanNullIndex, value);
+        proxyState.getRow$realm().setBoolean(columnInfo.fieldBooleanNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (byte[]) ((RealmObject) this).row.getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
     }
 
     public void realmSet$fieldBytesNotNull(byte[] value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldBytesNotNull to null.");
         }
-        ((RealmObject) this).row.setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, value);
+        proxyState.getRow$realm().setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (byte[]) ((RealmObject) this).row.getBinaryByteArray(columnInfo.fieldBytesNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNullIndex);
     }
 
     public void realmSet$fieldBytesNull(byte[] value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldBytesNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldBytesNullIndex);
             return;
         }
-        ((RealmObject) this).row.setBinaryByteArray(columnInfo.fieldBytesNullIndex, value);
+        proxyState.getRow$realm().setBinaryByteArray(columnInfo.fieldBytesNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (byte) ((RealmObject) this).row.getLong(columnInfo.fieldByteNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNotNullIndex);
     }
 
     public void realmSet$fieldByteNotNull(Byte value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldByteNotNull to null.");
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldByteNotNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldByteNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldByteNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldByteNullIndex)) {
             return null;
         }
-        return (byte) ((RealmObject) this).row.getLong(columnInfo.fieldByteNullIndex);
+        return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNullIndex);
     }
 
     public void realmSet$fieldByteNull(Byte value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldByteNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldByteNullIndex);
             return;
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldByteNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldByteNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (short) ((RealmObject) this).row.getLong(columnInfo.fieldShortNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNotNullIndex);
     }
 
     public void realmSet$fieldShortNotNull(Short value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldShortNotNull to null.");
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldShortNotNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldShortNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldShortNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldShortNullIndex)) {
             return null;
         }
-        return (short) ((RealmObject) this).row.getLong(columnInfo.fieldShortNullIndex);
+        return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNullIndex);
     }
 
     public void realmSet$fieldShortNull(Short value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldShortNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldShortNullIndex);
             return;
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldShortNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldShortNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (int) ((RealmObject) this).row.getLong(columnInfo.fieldIntegerNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNotNullIndex);
     }
 
     public void realmSet$fieldIntegerNotNull(Integer value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldIntegerNotNull to null.");
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldIntegerNotNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldIntegerNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldIntegerNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldIntegerNullIndex)) {
             return null;
         }
-        return (int) ((RealmObject) this).row.getLong(columnInfo.fieldIntegerNullIndex);
+        return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNullIndex);
     }
 
     public void realmSet$fieldIntegerNull(Integer value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldIntegerNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldIntegerNullIndex);
             return;
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldIntegerNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldIntegerNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (long) ((RealmObject) this).row.getLong(columnInfo.fieldLongNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNotNullIndex);
     }
 
     public void realmSet$fieldLongNotNull(Long value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldLongNotNull to null.");
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldLongNotNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldLongNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldLongNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldLongNullIndex)) {
             return null;
         }
-        return (long) ((RealmObject) this).row.getLong(columnInfo.fieldLongNullIndex);
+        return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNullIndex);
     }
 
     public void realmSet$fieldLongNull(Long value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldLongNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldLongNullIndex);
             return;
         }
-        ((RealmObject) this).row.setLong(columnInfo.fieldLongNullIndex, value);
+        proxyState.getRow$realm().setLong(columnInfo.fieldLongNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (float) ((RealmObject) this).row.getFloat(columnInfo.fieldFloatNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNotNullIndex);
     }
 
     public void realmSet$fieldFloatNotNull(Float value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldFloatNotNull to null.");
         }
-        ((RealmObject) this).row.setFloat(columnInfo.fieldFloatNotNullIndex, value);
+        proxyState.getRow$realm().setFloat(columnInfo.fieldFloatNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldFloatNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldFloatNullIndex)) {
             return null;
         }
-        return (float) ((RealmObject) this).row.getFloat(columnInfo.fieldFloatNullIndex);
+        return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNullIndex);
     }
 
     public void realmSet$fieldFloatNull(Float value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldFloatNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldFloatNullIndex);
             return;
         }
-        ((RealmObject) this).row.setFloat(columnInfo.fieldFloatNullIndex, value);
+        proxyState.getRow$realm().setFloat(columnInfo.fieldFloatNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (double) ((RealmObject) this).row.getDouble(columnInfo.fieldDoubleNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNotNullIndex);
     }
 
     public void realmSet$fieldDoubleNotNull(Double value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldDoubleNotNull to null.");
         }
-        ((RealmObject) this).row.setDouble(columnInfo.fieldDoubleNotNullIndex, value);
+        proxyState.getRow$realm().setDouble(columnInfo.fieldDoubleNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldDoubleNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldDoubleNullIndex)) {
             return null;
         }
-        return (double) ((RealmObject) this).row.getDouble(columnInfo.fieldDoubleNullIndex);
+        return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNullIndex);
     }
 
     public void realmSet$fieldDoubleNull(Double value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldDoubleNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldDoubleNullIndex);
             return;
         }
-        ((RealmObject) this).row.setDouble(columnInfo.fieldDoubleNullIndex, value);
+        proxyState.getRow$realm().setDouble(columnInfo.fieldDoubleNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNotNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (java.util.Date) ((RealmObject) this).row.getDate(columnInfo.fieldDateNotNullIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNotNullIndex);
     }
 
     public void realmSet$fieldDateNotNull(Date value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field fieldDateNotNull to null.");
         }
-        ((RealmObject) this).row.setDate(columnInfo.fieldDateNotNullIndex, value);
+        proxyState.getRow$realm().setDate(columnInfo.fieldDateNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNull(columnInfo.fieldDateNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNull(columnInfo.fieldDateNullIndex)) {
             return null;
         }
-        return (java.util.Date) ((RealmObject) this).row.getDate(columnInfo.fieldDateNullIndex);
+        return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNullIndex);
     }
 
     public void realmSet$fieldDateNull(Date value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.fieldDateNullIndex);
+            proxyState.getRow$realm().setNull(columnInfo.fieldDateNullIndex);
             return;
         }
-        ((RealmObject) this).row.setDate(columnInfo.fieldDateNullIndex, value);
+        proxyState.getRow$realm().setDate(columnInfo.fieldDateNullIndex, value);
     }
 
     public NullTypes realmGet$fieldObjectNull() {
-        ((RealmObject) this).realm.checkIfValid();
-        if (((RealmObject) this).row.isNullLink(columnInfo.fieldObjectNullIndex)) {
+        proxyState.getRealm$realm().checkIfValid();
+        if (proxyState.getRow$realm().isNullLink(columnInfo.fieldObjectNullIndex)) {
             return null;
         }
-        return ((RealmObject) this).realm.get(some.test.NullTypes.class, ((RealmObject) this).row.getLink(columnInfo.fieldObjectNullIndex));
+        return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex));
     }
 
     public void realmSet$fieldObjectNull(NullTypes value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.nullifyLink(columnInfo.fieldObjectNullIndex);
+            proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
             return;
         }
-        if (!value.isValid()) {
+        if (!RealmObject.isValid(value)) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
-        if (value.realm != this.realm) {
+        if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
             throw new IllegalArgumentException("'value' belongs to a different Realm.");
         }
-        ((RealmObject) this).row.setLink(columnInfo.fieldObjectNullIndex, ((RealmObject) value).row.getIndex());
+        proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -542,7 +546,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldStringNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -551,7 +555,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBooleanNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -560,7 +564,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBooleanNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -569,7 +573,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBytesNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -578,7 +582,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBytesNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -587,7 +591,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldByteNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -596,7 +600,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldByteNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -605,7 +609,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldShortNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -614,7 +618,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldShortNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -623,7 +627,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldIntegerNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -632,7 +636,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldIntegerNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -641,7 +645,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldLongNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -650,7 +654,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldLongNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -659,7 +663,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldFloatNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -668,7 +672,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldFloatNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -677,7 +681,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDoubleNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -686,7 +690,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDoubleNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -695,7 +699,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDateNotNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -704,7 +708,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDateNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -713,7 +717,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldObjectNull")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -1080,18 +1084,17 @@ public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
-            throw new IllegalArgumentException(
-                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+    public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
+            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
         return copy(realm, object, update, cache);
     }
 
-    public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+    public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         NullTypes realmObject = realm.createObject(NullTypes.class);
         cache.put(newObject, (RealmObjectProxy) realmObject);
         ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
@@ -1129,11 +1132,11 @@ public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, M
         return realmObject;
     }
 
-    public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+    public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
-        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        CacheData<RealmModel> cachedObject = cache.get(realmObject);
         NullTypes standaloneObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
@@ -1145,7 +1148,7 @@ public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDep
             }
         } else {
             standaloneObject = new NullTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
         }
         ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
         ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
@@ -1175,7 +1178,7 @@ public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDep
 
     @Override
     public String toString() {
-        if (!isValid()) {
+        if (!RealmObject.isValid(this)) {
             return "Invalid object";
         }
         StringBuilder stringBuilder = new StringBuilder("NullTypes = [");
@@ -1266,11 +1269,16 @@ public String toString() {
         return stringBuilder.toString();
     }
 
+    @Override
+    public ProxyState realmGet$proxyState() {
+        return proxyState;
+    }
+
     @Override
     public int hashCode() {
-        String realmName = ((RealmObject) this).realm.getPath();
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        long rowIndex = ((RealmObject) this).row.getIndex();
+        String realmName = proxyState.getRealm$realm().getPath();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        long rowIndex = proxyState.getRow$realm().getIndex();
 
         int result = 17;
         result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
@@ -1285,15 +1293,15 @@ public boolean equals(Object o) {
         if (o == null || getClass() != o.getClass()) return false;
         NullTypesRealmProxy aNullTypes = (NullTypesRealmProxy)o;
 
-        String path = ((RealmObject) this).realm.getPath();
-        String otherPath = ((RealmObject) aNullTypes).realm.getPath();
+        String path = proxyState.getRealm$realm().getPath();
+        String otherPath = aNullTypes.proxyState.getRealm$realm().getPath();
         if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
 
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        String otherTableName = ((RealmObject) aNullTypes).row.getTable().getName();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        String otherTableName = aNullTypes.proxyState.getRow$realm().getTable().getName();
         if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
 
-        if (((RealmObject) this).row.getIndex() != ((RealmObject) aNullTypes).row.getIndex()) return false;
+        if (proxyState.getRow$realm().getIndex() != aNullTypes.proxyState.getRow$realm().getIndex()) return false;
 
         return true;
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 3b43065494..861016434b 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -21,15 +21,15 @@
 @io.realm.annotations.RealmModule
 class DefaultRealmModuleMediator extends RealmProxyMediator {
 
-    private static final Set<Class<? extends RealmObject>> MODEL_CLASSES;
+    private static final Set<Class<? extends RealmModel>> MODEL_CLASSES;
     static {
-        Set<Class<? extends RealmObject>> modelClasses = new HashSet<Class<? extends RealmObject>>();
+        Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>();
         modelClasses.add(AllTypes.class);
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
     @Override
-    public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
@@ -40,7 +40,7 @@ public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
@@ -51,7 +51,7 @@ public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTran
     }
 
     @Override
-    public List<String> getFieldNames(Class<? extends RealmObject> clazz) {
+    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
@@ -62,7 +62,7 @@ public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTran
     }
 
     @Override
-    public String getTableName(Class<? extends RealmObject> clazz) {
+    public String getTableName(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
@@ -73,7 +73,7 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
@@ -84,12 +84,12 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public Set<Class<? extends RealmObject>> getModelClasses() {
+    public Set<Class<? extends RealmModel>> getModelClasses() {
         return MODEL_CLASSES;
     }
 
     @Override
-    public <E extends RealmObject> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         // This cast is correct because obj is either
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
@@ -102,7 +102,7 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
+    public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
             throws JSONException {
         checkClass(clazz);
 
@@ -114,7 +114,7 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader)
+    public <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader)
             throws IOException {
         checkClass(clazz);
 
@@ -126,7 +126,7 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+    public <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
         // This cast is correct because obj is either
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 216af4e164..6cb7a3edc2 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -19,13 +20,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import some.test.Simple;
 
 public class SimpleRealmProxy extends Simple
-    implements RealmObjectProxy, SimpleRealmProxyInterface {
+        implements RealmObjectProxy, SimpleRealmProxyInterface {
 
     static final class SimpleColumnInfo extends ColumnInfo {
 
@@ -45,6 +47,7 @@
     }
 
     private final SimpleColumnInfo columnInfo;
+    private final ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -55,32 +58,33 @@
 
     SimpleRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (SimpleColumnInfo) columnInfo;
+        this.proxyState = new ProxyState(Simple.class, this);
     }
 
     @SuppressWarnings("cast")
     public String realmGet$name() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.nameIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.nameIndex);
     }
 
     public void realmSet$name(String value) {
-        ((RealmObject) this).realm.checkIfValid();
+        proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            ((RealmObject) this).row.setNull(columnInfo.nameIndex);
+            proxyState.getRow$realm().setNull(columnInfo.nameIndex);
             return;
         }
-        ((RealmObject) this).row.setString(columnInfo.nameIndex, value);
+        proxyState.getRow$realm().setString(columnInfo.nameIndex, value);
     }
 
     @SuppressWarnings("cast")
     public int realmGet$age() {
-        ((RealmObject) this).realm.checkIfValid();
-        return (int) ((RealmObject) this).row.getLong(columnInfo.ageIndex);
+        proxyState.getRealm$realm().checkIfValid();
+        return (int) proxyState.getRow$realm().getLong(columnInfo.ageIndex);
     }
 
     public void realmSet$age(int value) {
-        ((RealmObject) this).realm.checkIfValid();
-        ((RealmObject) this).row.setLong(columnInfo.ageIndex, value);
+        proxyState.getRealm$realm().checkIfValid();
+        proxyState.getRow$realm().setLong(columnInfo.ageIndex, value);
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -114,7 +118,7 @@ public static SimpleColumnInfo validateTable(ImplicitTransaction transaction) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.nameIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("age")) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
@@ -123,7 +127,7 @@ public static SimpleColumnInfo validateTable(ImplicitTransaction transaction) {
                 throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.ageIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
             }
             return columnInfo;
         } else {
@@ -189,18 +193,17 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
-            throw new IllegalArgumentException(
-                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
+            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
-        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
         return copy(realm, object, update, cache);
     }
 
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         Simple realmObject = realm.createObject(Simple.class);
         cache.put(newObject, (RealmObjectProxy) realmObject);
         ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
@@ -208,11 +211,11 @@ public static Simple copy(Realm realm, Simple newObject, boolean update, Map<Rea
         return realmObject;
     }
 
-    public static Simple createDetachedCopy(Simple realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+    public static Simple createDetachedCopy(Simple realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
-        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        CacheData<RealmModel> cachedObject = cache.get(realmObject);
         Simple standaloneObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
@@ -224,10 +227,16 @@ public static Simple createDetachedCopy(Simple realmObject, int currentDepth, in
             }
         } else {
             standaloneObject = new Simple();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
         }
         ((SimpleRealmProxyInterface) standaloneObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
         ((SimpleRealmProxyInterface) standaloneObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
         return standaloneObject;
     }
-}
+
+    @Override
+    public ProxyState realmGet$proxyState() {
+        return proxyState;
+    }
+
+}
\ No newline at end of file
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/models/TimeStamp.java b/realm/realm-annotations-processor/src/test/resources/some/test/ExtendRealmList.java
similarity index 65%
rename from examples/adapterExample/src/main/java/io/realm/examples/realmadapters/models/TimeStamp.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/ExtendRealmList.java
index 8945954fa2..ddd8962580 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/models/TimeStamp.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ExtendRealmList.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,18 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.examples.realmadapters.models;
 
-import io.realm.RealmObject;
-
-public class TimeStamp extends RealmObject {
-    private String timeStamp;
+package some.test;
 
-    public String getTimeStamp() {
-        return timeStamp;
-    }
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+import io.realm.RealmList;
 
-    public void setTimeStamp(String timeStamp) {
-        this.timeStamp = timeStamp;
-    }
+public class ExtendRealmList<E extends RealmModel> extends RealmList<E> {
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_1.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_1.java
new file mode 100644
index 0000000000..3bd10b47f8
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_1.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+// Invalid POJO, this uses the annotation but doesn't implements the RealmModel interface
+@RealmClass
+public class InvalidModelRealmModel_1 {
+    public String id;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_2.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_2.java
new file mode 100644
index 0000000000..9753159929
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_2.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+// it's not allowed to extend from another RealmObject
+public class InvalidModelRealmModel_2 extends Booleans {
+    public String id;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java
new file mode 100644
index 0000000000..d4adc862a8
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidModelRealmModel_3.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+import io.realm.annotations.RealmClass;
+
+// Invalid POJO, you can't extends from another class besides RealmObject
+@RealmClass
+public class ValidModelPojo_3 extends Booleans implements RealmModel {
+    public String id;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/SimpleRealmModel.java b/realm/realm-annotations-processor/src/test/resources/some/test/SimpleRealmModel.java
new file mode 100644
index 0000000000..d447bf08fa
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/SimpleRealmModel.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+// Object implements RealmModel and annotated by @RealmClase can be used as a field and element of RealmList
+@RealmClass
+public class SimpleRealmModel implements RealmModel {
+    String name;
+    RealmList<SimpleRealmModel> realmList;
+    SimpleRealmModel simpleRealmModel;
+}
\ No newline at end of file
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/UseExtendRealmList.java b/realm/realm-annotations-processor/src/test/resources/some/test/UseExtendRealmList.java
new file mode 100644
index 0000000000..f296b9a188
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/UseExtendRealmList.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+import io.realm.RealmList;
+
+public class UseExtendRealmList extends RealmObject {
+    private ExtendRealmList<UseExtendRealmList> extendRealmList;
+
+    public ExtendRealmList<UseExtendRealmList> extendRealmList() {
+        return extendRealmList;
+    }
+
+    public void realmSet$extendRealmList(ExtendRealmList<UseExtendRealmList> extendRealmList) {
+        this.extendRealmList = extendRealmList;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/ValidModelRealmModel_ExtendingRealmObject.java b/realm/realm-annotations-processor/src/test/resources/some/test/ValidModelRealmModel_ExtendingRealmObject.java
new file mode 100644
index 0000000000..e4c16e677c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ValidModelRealmModel_ExtendingRealmObject.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+import io.realm.annotations.RealmClass;
+
+// This is valid, although weird, you should either use composition or inheritance
+@RealmClass
+public class ValidModelRealmModel_ExtendingRealmObject extends RealmObject implements RealmModel {
+    public String id;
+}
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
index 3f0c28f814..2389891e27 100644
--- a/realm/realm-jni/build.gradle
+++ b/realm/realm-jni/build.gradle
@@ -1,8 +1,8 @@
 import java.security.MessageDigest
 
-ext.coreVersion = '0.97.3'
+ext.coreVersion = '0.100.0'
 // empty or comment out this to disable hash checking
-ext.coreSha256Hash = '2835ae5c51ec83c38fb3f968af6cacd5fce6393b3602ddad4a8f48aaa9e62781'
+ext.coreSha256Hash = 'f3bb8564a8bab7eca8dc85f1c508a35e125b93a104f964105558739bd1032d98'
 ext.forceDownloadCore =
         project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
 // gcc is default for the NDK. It also produces smaller binaries
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp b/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
index 031afa39f0..79ceb7a496 100644
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
@@ -103,13 +103,13 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
     return Java_io_realm_internal_UncheckedRow_nativeGetDouble(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp))
         return 0;
 
-    return Java_io_realm_internal_UncheckedRow_nativeGetDateTime(env, obj, nativeRowPtr, columnIndex);
+    return Java_io_realm_internal_UncheckedRow_nativeGetTimestamp(env, obj, nativeRowPtr, columnIndex);
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
@@ -211,13 +211,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
     Java_io_realm_internal_UncheckedRow_nativeSetDouble(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp))
         return;
 
-    Java_io_realm_internal_UncheckedRow_nativeSetDate(env, obj, nativeRowPtr, columnIndex, value);
+    Java_io_realm_internal_UncheckedRow_nativeSetTimestamp(env, obj, nativeRowPtr, columnIndex, value);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.h b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
index 230aa03d0a..2ef21447c4 100644
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.h
+++ b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
@@ -73,10 +73,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetDateTime
+ * Method:    nativeGetTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -169,10 +169,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetDate
+ * Method:    nativeSetTimestamp
  * Signature: (JJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
diff --git a/realm/realm-jni/src/io_realm_internal_Group.cpp b/realm/realm-jni/src/io_realm_internal_Group.cpp
index d2e289e020..ad2237df66 100644
--- a/realm/realm-jni/src/io_realm_internal_Group.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Group.cpp
@@ -315,13 +315,12 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
     JNIEnv*, jobject, jlong nativeGroupPtr)
 {
     Group* grp = G(nativeGroupPtr);
-    const string table_prefix(TABLE_PREFIX);
-    const size_t table_prefix_length = table_prefix.length();
+    const size_t table_prefix_length = TABLE_PREFIX.length();
 
     for (size_t i = 0; i < grp->size(); ++i) {
         ConstTableRef table = grp->get_table(i);
         const string table_name = table->get_name();
-        if (table_name.compare(0, table_prefix_length, table_prefix) == 0 && !table->is_empty()) {
+        if (table_name.compare(0, table_prefix_length, TABLE_PREFIX) == 0 && !table->is_empty()) {
             return false;
         }
     }
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.cpp b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
index b10a6c8523..0eef715113 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -23,7 +23,7 @@ using namespace realm;
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
   (JNIEnv*, jclass, jlong nativeLinkViewPtr)
 {
-    LangBindHelper::unbind_linklist_ptr( LV( nativeLinkViewPtr ) );
+    LangBindHelper::unbind_linklist_ptr(*LV(nativeLinkViewPtr));
 }
 
 
@@ -31,12 +31,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
     }
     try {
-        Row* row = new Row( (*lv)[ S(pos) ] );
+        LinkViewRef lvr = *lv;
+        Row* row = new Row( (*lvr)[ S(pos) ] );
         return reinterpret_cast<jlong>(row);
     } CATCH_STD()
     return 0;
@@ -47,12 +48,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
     }
     try {
-        return lv->get( S(pos) ).get_index();
+        LinkViewRef lvr = *lv;
+        return lvr->get( S(pos) ).get_index();
     } CATCH_STD()
     return 0;
 }
@@ -62,8 +64,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
-        LV(nativeLinkViewPtr)->add( S(rowIndex) );
+        LinkViewRef lvr = *lv;
+        lvr->add( S(rowIndex) );
     } CATCH_STD()
 }
 
@@ -72,8 +76,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
-        LV(nativeLinkViewPtr)->insert( S(pos), S(rowIndex) );
+        LinkViewRef lvr = *lv;
+        lvr->insert( S(pos), S(rowIndex) );
     } CATCH_STD()
 }
 
@@ -82,12 +88,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
-        lv->set( S(pos), S(rowIndex) );
+        LinkViewRef lvr = *lv;
+        lvr->set( S(pos), S(rowIndex) );
     } CATCH_STD()
 }
 
@@ -97,14 +104,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        size_t size = LV(nativeLinkViewPtr)->size();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        size_t size = lvr->size();
         if (old_pos < 0 || new_pos < 0 || size_t(old_pos) >= size || size_t(new_pos) >= size) {
             ThrowException(env, IndexOutOfBounds,
                 "Indices must be within range [0, " + num_to_string(size) + "[. " +
                 "Yours were (" + num_to_string(old_pos) + "," + num_to_string(new_pos) + ")");
             return;
         }
-        LV(nativeLinkViewPtr)->move( S(old_pos), S(new_pos) );
+        lvr->move( S(old_pos), S(new_pos) );
     } CATCH_STD()
 }
 
@@ -113,12 +122,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
-        return lv->remove( S(pos) );
+        LinkViewRef lvr = *lv;
+        return lvr->remove( S(pos) );
     } CATCH_STD()
 }
 
@@ -128,7 +138,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->clear();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->clear();
     } CATCH_STD()
 }
 
@@ -136,9 +148,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
+    
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->size();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->size();
     } CATCH_STD()
     return 0;
 }
@@ -149,7 +164,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->is_empty();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->is_empty();
     } CATCH_STD()
     return 0;
 }
@@ -159,8 +176,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr);
-        Query query = lv->get_target_table().where(LinkViewRef(lv));
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        Query query = lvr->get_target_table().where(LinkViewRef(lvr));
         TableQuery* queryPtr = new TableQuery(query);
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
@@ -172,7 +190,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->is_attached();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->is_attached();
     } CATCH_STD()
     return 0;
 }
@@ -182,11 +202,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr);
-        if (!ROW_INDEX_VALID(env, &lv->get_target_table(), targetRowIndex)) {
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        if (!ROW_INDEX_VALID(env, &lvr->get_target_table(), targetRowIndex)) {
             return -1;
         }
-        size_t ndx = lv->find(targetRowIndex);
+        size_t ndx = lvr->find(targetRowIndex);
         return to_jlong_or_not_found(ndx);
     } CATCH_STD()
     return -1;
@@ -197,8 +218,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr);
-        lv->remove_all_target_rows();
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        lvr->remove_all_target_rows();
     } CATCH_STD()
 }
 
@@ -207,8 +229,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
 
-    LinkView* lv = LV(nativeLinkViewPtr);
-    Table* pTable = &(lv->get_target_table());
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
+    LinkViewRef lvr = *lv;
+    Table* pTable = &(lvr->get_target_table());
     LangBindHelper::bind_table_ptr(pTable);
 
     return reinterpret_cast<jlong>(pTable);
@@ -218,11 +241,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
-        return lv->remove_target_row( S(pos) );
+        LinkViewRef lvr = *lv;
+        return lvr->remove_target_row( S(pos) );
     } CATCH_STD()
 }
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
index a85bc7105f..c7474319c5 100644
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -323,4 +323,23 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersion
     env->SetLongArrayRegion(version_data, 0, 2, version_array);
 
     return version_data;
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
+  (JNIEnv *env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        return static_cast<jboolean>(SG(native_ptr)->wait_for_change());
+    } CATCH_STD()
+    return false;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
+  (JNIEnv *env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        SG(native_ptr)->wait_for_change_release();
+    } CATCH_STD()
 }
\ No newline at end of file
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.h b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
index d41e817899..526ec73e58 100644
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.h
+++ b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
@@ -176,6 +176,22 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
 JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
         (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeWaitForChange
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeStopWaitForChange
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
+  (JNIEnv *, jobject, jlong);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
index 5064e191e4..943c435968 100644
--- a/realm/realm-jni/src/io_realm_internal_Table.h
+++ b/realm/realm-jni/src/io_realm_internal_Table.h
@@ -255,10 +255,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeGetDateTime
+ * Method:    nativeGetTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -383,10 +383,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeSetDate
+ * Method:    nativeSetTimestamp
  * Signature: (JJJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
 /*
@@ -405,6 +405,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray
   (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeSetNull
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeSetMixed
@@ -575,18 +583,18 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeMaximumDate
+ * Method:    nativeMaximumTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeMinimumDate
+ * Method:    nativeMinimumTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -663,10 +671,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstDate
+ * Method:    nativeFindFirstTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -677,6 +685,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString
   (JNIEnv *, jobject, jlong, jlong, jstring);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeFindFirstNull
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeFindAllInt
@@ -711,10 +727,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeFindAllDate
+ * Method:    nativeFindAllTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
index debe1ce72c..8f1f779bda 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -55,7 +55,9 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
 (JNIEnv *env, jobject, jlong nativeQueryPtr)
 {
     try {
-        return to_jstring(env, Q(nativeQueryPtr)->validate());
+        const std::string str = Q(nativeQueryPtr)->validate();
+        StringData sd(str);
+        return to_jstring(env, sd);
     } CATCH_STD();
     return NULL;
 }
@@ -111,7 +113,7 @@ static jlong getDistinctViewWithHandover
         switch (table->get_column_type(S(columnIndex))) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
+            case type_Timestamp:
             case type_String: {
                 TableView tableView(table->get_distinct_view(S(columnIndex)) );
 
@@ -148,10 +150,10 @@ static jlong findAllSortedWithHandover
         switch (colType) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
             case type_Float:
             case type_Double:
             case type_String:
+            case type_Timestamp:
                 tableView.sort( S(columnIndex), ascending != 0);
                 break;
             default:
@@ -206,10 +208,10 @@ static jlong findAllMultiSortedWithHandover
             switch (colType) {
                 case type_Bool:
                 case type_Int:
-                case type_DateTime:
                 case type_Float:
                 case type_Double:
                 case type_String:
+                case type_Timestamp:
                     indices.push_back( S(long_arr[i]) );
                     ascendings.push_back( B(bool_arr[i]) );
                     break;
@@ -662,135 +664,133 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(
 }
 
 
-// DateTime
+// Timestamp
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(
-                    numeric_link_equal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualDateTime(
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->not_equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(
-                    numeric_link_notequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->greater(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->less(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->less_equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->between_datetime(S(arr[0]), DateTime(value1), DateTime(value2));
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value1)).less_equal(S(arr[0]), from_milliseconds(value2));
         }
         else {
             ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
@@ -1523,42 +1523,42 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble(
 
 
 // date aggregates
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate(
+// FIXME: This is a rough workaround while waiting for https://github.com/realm/realm-core/issues/1745 to be solved
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr,
     jlong columnIndex, jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
     if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
         !ROW_INDEXES_VALID(env, pTable, start, end, limit))
         return NULL;
     try {
         size_t return_ndx;
-        DateTime result = pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+        Timestamp result = pQuery->find_all().maximum_timestamp(S(columnIndex), &return_ndx);
+        if (return_ndx != npos && !result.is_null()) {
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr,
     jlong columnIndex, jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
     if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
         !ROW_INDEXES_VALID(env, pTable, start, end, limit))
         return NULL;
     try {
         size_t return_ndx;
-        DateTime result = pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+        Timestamp result = pQuery->find_all().minimum_timestamp(S(columnIndex), &return_ndx);
+        if (return_ndx != npos && !result.is_null()) {
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
@@ -1629,7 +1629,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                     Q(nativeQueryPtr)->equal(S(column_idx), realm::null());
                     break;
                 default:
@@ -1664,8 +1664,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
                 case type_Double:
                     pQuery->and_query(src_table_ref->column<Double>(S(column_idx)) == realm::null());
                     break;
-                case type_DateTime:
-                    pQuery->and_query(src_table_ref->column<DateTime>(S(column_idx)) == realm::null());
+                case type_Timestamp:
+                    pQuery->and_query(src_table_ref->column<Timestamp>(S(column_idx)) == realm::null());
                     break;
                 default:
                     // this point is unreachable
@@ -1770,7 +1770,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                     pQuery->not_equal(S(column_idx), realm::null());
                     break;
                 default:
@@ -1806,8 +1806,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
                 case type_Double:
                     pQuery->and_query(src_table_ref->column<Double>(S(column_idx)) != realm::null());
                     break;
-                case type_DateTime:
-                    pQuery->and_query(src_table_ref->column<DateTime>(S(column_idx)) != realm::null());
+                case type_Timestamp:
+                    pQuery->and_query(src_table_ref->column<Timestamp>(S(column_idx)) != realm::null());
                     break;
                 default:
                     // this point is unreachable
@@ -1847,7 +1847,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                 default:
                     ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList.");
                     return;
@@ -1870,7 +1870,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                 default:
                     ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList across links.");
                     return;
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.h b/realm/realm-jni/src/io_realm_internal_TableQuery.h
index 943f9a2227..e149942bbd 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.h
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.h
@@ -257,58 +257,58 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqualDateTime
+ * Method:    nativeEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqualDateTime
+ * Method:    nativeNotEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterDateTime
+ * Method:    nativeGreaterTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqualDateTime
+ * Method:    nativeGreaterEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessDateTime
+ * Method:    nativeLessTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqualDateTime
+ * Method:    nativeLessEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetweenDateTime
+ * Method:    nativeBetweenTimestamp
  * Signature: (J[JJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong, jlong);
 
 /*
@@ -529,18 +529,18 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumDate
+ * Method:    nativeMaximumTimestamp
  * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumDate
+ * Method:    nativeMinimumTimestamp
  * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
index 63c986e52a..85c54e1420 100644
--- a/realm/realm-jni/src/io_realm_internal_TableView.h
+++ b/realm/realm-jni/src/io_realm_internal_TableView.h
@@ -97,10 +97,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeGetDateTimeValue
+ * Method:    nativeGetTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetDateTimeValue
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -201,10 +201,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeSetDateTimeValue
+ * Method:    nativeSetTimestampValue
  * Signature: (JJJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDateTimeValue
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
 /*
@@ -465,18 +465,18 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumDate
+ * Method:    nativeMaximumTimestamp
  * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumDate
+ * Method:    nativeMinimumTimestamp
  * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -561,10 +561,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeSync
+ * Method:    nativeSyncIfNeeded
  * Signature: (J)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded
   (JNIEnv *, jobject, jlong);
 
 /*
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp b/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
index 2c126a5db0..b78ed27aa6 100644
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
@@ -115,14 +115,14 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
     return ROW(nativeRowPtr)->get_double( S(columnIndex) );
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
-    return ROW(nativeRowPtr)->get_datetime( S(columnIndex) ).get_datetime();
+    return to_milliseconds(ROW(nativeRowPtr)->get_timestamp( S(columnIndex) ));
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
@@ -217,7 +217,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
-    LinkView* link_view_ptr = LangBindHelper::get_linklist_ptr( *ROW( nativeRowPtr ), S( columnIndex) );
+    LinkViewRef* link_view_ptr = const_cast<LinkViewRef*>(&(LangBindHelper::get_linklist_ptr(*ROW(nativeRowPtr), S(columnIndex))));
     return reinterpret_cast<jlong>(link_view_ptr);
 }
 
@@ -269,7 +269,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -277,7 +277,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
         return;
 
     try {
-        ROW(nativeRowPtr)->set_datetime( S(columnIndex), value);
+        ROW(nativeRowPtr)->set_timestamp( S(columnIndex), from_milliseconds(value));
     } CATCH_STD()
 }
 
@@ -395,7 +395,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
-  (JNIEnv *, jobject, jlong nativeRowPtr, jlong columnIndex) {
+  (JNIEnv *env, jobject, jlong nativeRowPtr, jlong columnIndex) {
     TR_ENTER_PTR(nativeRowPtr)
-    ROW(nativeRowPtr)->set_null(columnIndex);
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+        return;
+    if (!TBL_AND_COL_NULLABLE(env, ROW(nativeRowPtr)->get_table(), columnIndex))
+        return;
+    try {
+        ROW(nativeRowPtr)->set_null(columnIndex);
+    } CATCH_STD()
 }
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
index b714145ce3..effbcd34c6 100644
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
+++ b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
@@ -81,10 +81,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetDateTime
+ * Method:    nativeGetTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -177,10 +177,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetDate
+ * Method:    nativeSetTimestamp
  * Signature: (JJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
diff --git a/realm/realm-jni/src/io_realm_internal_Util.cpp b/realm/realm-jni/src/io_realm_internal_Util.cpp
index 03d298af02..c4cfaf9e4d 100644
--- a/realm/realm-jni/src/io_realm_internal_Util.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Util.cpp
@@ -16,6 +16,8 @@
 
 #include <jni.h>
 
+#include <realm/string_data.hpp>
+
 #include "util.hpp"
 #include "mem_usage.hpp"
 #include "io_realm_internal_Util.h"
@@ -31,7 +33,8 @@ using std::string;
 int trace_level = 0;
 const char* log_tag = "REALM";
 
-const char* const TABLE_PREFIX = "class_";
+const string TABLE_PREFIX("class_");
+
 
 JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 {
@@ -78,7 +81,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, j
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
     JNIEnv* env, jclass)
 {
-    return to_jstring(env, string(TABLE_PREFIX));
+    realm::StringData sd(TABLE_PREFIX);
+    return to_jstring(env, sd);
 }
 
 // -------------------------- Testcases for exception handling
diff --git a/realm/realm-jni/src/io_realm_internal_Version.cpp b/realm/realm-jni/src/io_realm_internal_Version.cpp
index bcbdf120b0..4fc4bc5cf8 100644
--- a/realm/realm-jni/src/io_realm_internal_Version.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Version.cpp
@@ -20,6 +20,7 @@
 #include "util.hpp"
 #include "io_realm_internal_Version.h"
 #include <realm/version.hpp>
+#include <realm/string_data.hpp>
 
 static int realm_jni_version = 23;
 
@@ -34,7 +35,9 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Version_nativeGetAPIVersion(JNIEnv
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Version_nativeGetVersion(JNIEnv *env, jclass)
 {
     try {
-        return to_jstring(env, Version::get_version());
+        std::string str(Version::get_version());
+        StringData sd(str);
+        return to_jstring(env, sd);
     }
     CATCH_STD();
     return NULL;
diff --git a/realm/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-jni/src/io_realm_internal_table.cpp
index 5ce8ba3869..b5680bb491 100644
--- a/realm/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-jni/src/io_realm_internal_table.cpp
@@ -33,7 +33,8 @@ inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type) {
     if (!(column_type == type_String ||
                 column_type == type_Int ||
                 column_type == type_Bool ||
-                column_type == type_DateTime)) {
+                column_type == type_Timestamp ||
+                column_type == type_OldDateTime)) {
         ThrowException(env, IllegalArgument,
                 "This field cannot be indexed - "
                 "Only String/byte/short/int/long/boolean/Date fields are supported.");
@@ -166,7 +167,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
 }
 
 
-// General comments about the implementation of 
+// General comments about the implementation of
 // Java_io_realm_internal_Table_nativeConvertColumnToNullable and Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
 //
 // 1. converting a (not-)nullable column is idempotent (and is implemented as a no-op)
@@ -212,8 +213,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
         while (true) {
             std::ostringstream ss;
             ss << std::string("__TMP__") << j;
-            if (table->get_column_index(ss.str()) == realm::not_found) {
-                table->insert_column(column_index, column_type, ss.str(), true);
+            std::string str = ss.str();
+            StringData sd(str);
+            if (table->get_column_index(sd) == realm::not_found) {
+                table->insert_column(column_index, column_type, sd, true);
                 tmp_column_name = ss.str();
                 break;
             }
@@ -222,10 +225,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
 
         for (size_t i = 0; i < table->size(); ++i) {
             switch (column_type) {
-                case type_String:
+               case type_String: {
                     // Payload copy is needed
-                    table->set_string(column_index, i, std::string(table->get_string(column_index + 1, i)));
+                    StringData sd(table->get_string(column_index + 1, i));
+                    table->set_string(column_index, i, sd);
                     break;
+                }
                 case type_Binary: {
                     // Payload copy is needed
                     BinaryData bd = table->get_binary(column_index + 1, i);
@@ -239,8 +244,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
                 case type_Bool:
                     table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
                     break;
-                case type_DateTime:
-                    table->set_datetime(column_index, i, table->get_datetime(column_index + 1, i));
+                case type_Timestamp:
+                    table->set_timestamp(column_index, i, table->get_timestamp(column_index + 1, i));
                     break;
                 case type_Float:
                     table->set_float(column_index, i, table->get_float(column_index + 1, i));
@@ -254,6 +259,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
                 case type_Table:
                     // checked previously
                     break;
+                case type_OldDateTime:
+                    ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
+                    return;
             }
         }
         if (table->has_search_index(column_index + 1)) {
@@ -279,7 +287,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
         size_t column_index = S(columnIndex);
         if (!table->is_nullable(column_index)) {
             return; // column is already not nullable
-        } 
+        }
 
         std::string column_name = table->get_column_name(column_index);
         DataType column_type = table->get_column_type(column_index);
@@ -295,8 +303,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
         while (true) {
             std::ostringstream ss;
             ss << std::string("__TMP__") << j;
-            if (table->get_column_index(ss.str()) == realm::not_found) {
-                table->insert_column(column_index, column_type, ss.str(), false);
+            std::string str = ss.str();
+            StringData sd(str);
+            if (table->get_column_index(sd) == realm::not_found) {
+                table->insert_column(column_index, column_type, sd, false);
                 tmp_column_name = ss.str();
                 break;
             }
@@ -312,7 +322,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                     }
                     else {
                         // Payload copy is needed
-                        table->set_string(column_index, i, std::string(sd));
+                        table->set_string(column_index, i, sd);
                     }
                     break;
                 }
@@ -344,12 +354,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                         table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
                     }
                     break;
-                case type_DateTime:
+                case type_Timestamp:
                     if (table->is_null(column_index + 1, i)) {
-                        table->set_datetime(column_index, i, static_cast<time_t>(0));
+                        table->set_timestamp(column_index, i, Timestamp(0, 0));
                     }
                     else {
-                        table->set_datetime(column_index, i, table->get_datetime(column_index + 1, i));
+                        table->set_timestamp(column_index, i, table->get_timestamp(column_index + 1, i));
                     }
                     break;
                 case type_Float:
@@ -374,6 +384,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                 case type_Table:
                     // checked previously
                     break;
+                case type_OldDateTime:
+                    // not used
+                    ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
+                    return;
             }
         }
         if (table->has_search_index(column_index + 1)) {
@@ -592,12 +606,15 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble(
     return TBL(nativeTablePtr)->get_double( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDateTime(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_DateTime))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return 0;
-    return TBL(nativeTablePtr)->get_datetime( S(columnIndex), S(rowIndex)).get_datetime();  // noexcept
+    try {
+        return to_milliseconds(TBL(nativeTablePtr)->get_timestamp( S(columnIndex), S(rowIndex)));
+    } CATCH_STD()
+    return 0;
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString(
@@ -783,13 +800,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDate(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong dateTimeValue)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(
+    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_DateTime))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return;
     try {
-        TBL(nativeTablePtr)->set_datetime( S(columnIndex), S(rowIndex), dateTimeValue);
+        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
     } CATCH_STD()
 }
 
@@ -823,6 +840,21 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
     } CATCH_STD()
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
+    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+{
+    Table* pTable = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+        return;
+    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex))
+        return;
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
+        return;
+    try {
+        pTable->set_null(S(columnIndex), S(rowIndex));
+    } CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClearSubtable(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
@@ -1050,26 +1082,24 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble(
 
 //--------------------- Aggregate methods for date
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumDate(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        // This exploits the fact that dates are stored as int in core
-        return TBL(nativeTablePtr)->maximum_int( S(columnIndex));
+        return to_milliseconds(TBL(nativeTablePtr)->maximum_timestamp( S(columnIndex)));
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumDate(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        // This exploits the fact that dates are stored as int in core
-        return TBL(nativeTablePtr)->minimum_int( S(columnIndex));
+        return to_milliseconds(TBL(nativeTablePtr)->minimum_timestamp( S(columnIndex)));
     } CATCH_STD()
     return 0;
 }
@@ -1182,14 +1212,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble(
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        size_t res = TBL(nativeTablePtr)->find_first_datetime( S(columnIndex), DateTime(dateTimeValue));
-        return to_jlong_or_not_found( res );
+        size_t res = TBL(nativeTablePtr)->find_first_timestamp( S(columnIndex), from_milliseconds(dateTimeValue));
+        return to_jlong_or_not_found(res);
     } CATCH_STD()
     return 0;
 }
@@ -1207,6 +1237,20 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(
     return 0;
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(
+    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+{
+    Table* pTable = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+        return jlong(-1);
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
+        return jlong(-1);
+    try {
+        return to_jlong_or_not_found( pTable->find_first_null( S(columnIndex) ) );
+    } CATCH_STD()
+    return jlong(-1);
+}
+
 // FindAll
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllInt(
@@ -1256,18 +1300,20 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllBool(
     return reinterpret_cast<jlong>(pTableView);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDate(
+// FIXME: reenable when find_first_timestamp() is implemented
+/*
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_datetime( S(columnIndex),
-                                            DateTime(dateTimeValue)) );
+        TableView* pTableView = new TableView(TBL(nativeTablePtr)->find_all_timestamp(S(columnIndex), from_milliseconds(dateTimeValue)));
         return reinterpret_cast<jlong>(pTableView);
     } CATCH_STD()
     return 0;
 }
+*/
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllString(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring value)
@@ -1329,15 +1375,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
     switch (pTable->get_column_type(S(columnIndex))) {
         case type_Bool:
         case type_Int:
-        case type_DateTime:
         case type_String:
+        case type_Timestamp:
             try {
                 TableView* pTableView = new TableView( pTable->get_distinct_view(S(columnIndex)) );
                 return reinterpret_cast<jlong>(pTableView);
             } CATCH_STD()
             break;
         default:
-            ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, short, int, long and their boxed variants are supported.");
+            ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
             return 0;
         break;
     }
@@ -1355,16 +1401,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView(
     switch (colType) {
         case type_Int:
         case type_Bool:
-        case type_DateTime:
         case type_String:
         case type_Double:
         case type_Float:
+        case type_Timestamp:
             try {
                 TableView* pTableView = new TableView( pTable->get_sorted_view(S(columnIndex), ascending != 0 ? true : false) );
                 return reinterpret_cast<jlong>(pTableView);
             } CATCH_STD()
         default:
-            ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, boolean, double, float, String, and Date columns.");
+            ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
             return 0;
     }
     return 0;
@@ -1404,15 +1450,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
         switch (colType) {
             case type_Int:
             case type_Bool:
-            case type_DateTime:
             case type_String:
             case type_Double:
             case type_Float:
+            case type_Timestamp:
                 indices[i] = S(long_arr[i]);
                 ascendings[i] = S(bool_arr[i]);
                 break;
             default:
-                ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, boolean, double, float, String, and Date columns.");
+                ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
                 return 0;
         }
     }
@@ -1594,7 +1640,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
     try {
         Table* table = TBL(nativeTablePtr);
         Table* pk_table = TBL(nativePrivateKeyTablePtr);
-        const std::string table_name(table->get_name().substr(strlen(TABLE_PREFIX))); // Remove "class_" prefix
+        const std::string table_name(table->get_name().substr(TABLE_PREFIX.length())); // Remove "class_" prefix
         size_t row_index = pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
 
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
@@ -1668,7 +1714,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
             size_t col_ndx = static_cast<size_t>(pk_table->get_int(FIELD_COLUMN_INDEX, row_ndx));
             StringData col_name = group->get_table(table_name)->get_column_name(col_ndx);
             // Make a copy of the string
-            pk_table->set_string(tmp_col_ndx, row_ndx, std::string(col_name));
+            pk_table->set_string(tmp_col_ndx, row_ndx, col_name);
         }
 
         // Delete old int column, and rename tmp column to same name
@@ -1683,7 +1729,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
         StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
         if (table_name.begins_with(TABLE_PREFIX)) {
             // New string copy is needed, since the original memory will be changed.
-            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, std::string(table_name.substr(strlen(TABLE_PREFIX))));
+            std::string str(table_name.substr(TABLE_PREFIX.length()));
+            StringData sd(str);
+            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, sd);
         }
     }
 }
diff --git a/realm/realm-jni/src/io_realm_internal_tableview.cpp b/realm/realm-jni/src/io_realm_internal_tableview.cpp
index 93d2fd07dd..7d5d6451af 100644
--- a/realm/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm/realm-jni/src/io_realm_internal_tableview.cpp
@@ -34,7 +34,13 @@ inline bool view_valid_and_in_sync(JNIEnv* env, jlong nativeViewPtr) {
             ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
             return false;
         }
-        TV(nativeViewPtr)->sync_if_needed();
+        // depends_on_deleted_linklist() will return true if and only if the current TableView was created from a
+        // query on a RealmList and that RealmList was then deleted (as a result of the object being deleted).
+        if (!TV(nativeViewPtr)->is_in_sync() && TV(nativeViewPtr)->depends_on_deleted_object()) {
+            // This table view is no longer valid. By calling sync_if_needed we ensure it behaves
+            // properly as a 0-size TableView.
+            TV(nativeViewPtr)->sync_if_needed();
+        }
     }
     return valid;
 }
@@ -64,8 +70,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct(
         switch (TV(nativeViewPtr)->get_column_type(S(columnIndex))) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
             case type_String:
+            case type_Timestamp:
                 TV(nativeViewPtr)->distinct(S(columnIndex));
                 break;
             default:
@@ -95,8 +101,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti(
             switch (TV(nativeViewPtr)->get_column_type(S(indexes[i]))) {
                 case type_Bool:
                 case type_Int:
-                case type_DateTime:
                 case type_String:
+                case type_Timestamp:
                     columns.push_back(S(indexes[i]));
                     break;
                 default:
@@ -165,9 +171,11 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSourceRowIndex
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return npos;
+            return to_jlong_or_not_found(-1);
         if (!ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return npos;
+            return to_jlong_or_not_found(-1);
+        if (!TV(nativeViewPtr)->is_row_attached(rowIndex))
+            return to_jlong_or_not_found(-1);
     } CATCH_STD()
     return TV(nativeViewPtr)->get_source_ndx(S(rowIndex));   // noexcept
 }
@@ -195,11 +203,11 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetColumnName
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnIndex
    (JNIEnv *env, jobject, jlong nativeViewPtr, jstring columnName)
+
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-        return 0;
-
+            return 0;
         JStringAccessor columnName2(env, columnName); // throws
         return to_jlong_or_not_found( TV(nativeViewPtr)->get_column_index(columnName2) ); // noexcept
     } CATCH_STD()
@@ -260,15 +268,15 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble(
     return TV(nativeViewPtr)->get_double( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetDateTimeValue(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_DateTime))
+            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Timestamp))
             return 0;
     } CATCH_STD()
-    return TV(nativeViewPtr)->get_datetime( S(columnIndex), S(rowIndex)).get_datetime();  // noexcept
+    return to_milliseconds(TV(nativeViewPtr)->get_timestamp( S(columnIndex), S(rowIndex)));
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString(
@@ -427,14 +435,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDateTimeValue(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong dateTimeValue)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestamp(
+    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_DateTime))
+            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Timestamp))
             return;
-        TV(nativeViewPtr)->set_datetime( S(columnIndex), S(rowIndex), dateTimeValue);
+        TV(nativeViewPtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
     } CATCH_STD()
 }
 
@@ -595,6 +603,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDouble(
     return 0;
 }
 
+// FIXME: find_first_timestamp() isn't implemented
+/*
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong dateTimeValue)
 {
@@ -606,6 +616,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate(
     } CATCH_STD()
     return 0;
 }
+*/
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstString(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jstring value)
@@ -676,6 +687,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDouble(
     return 0;
 }
 
+// FIXME: find_all_timestamp() isn't implemented
+/*
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong dateTimeValue)
 {
@@ -689,6 +702,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate(
     } CATCH_STD()
     return 0;
 }
+*/
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jstring value)
@@ -883,35 +897,35 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble(
 
 // date aggregates
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
+            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Timestamp))
             return NULL;
 
         size_t return_ndx;
-        DateTime result = TV(nativeViewPtr)->maximum_datetime( S(columnIndex), &return_ndx);
+        Timestamp result = TV(nativeViewPtr)->maximum_timestamp( S(columnIndex), &return_ndx);
         if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
+            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Timestamp))
             return NULL;
 
         size_t return_ndx;
-        DateTime result = TV(nativeViewPtr)->minimum_datetime( S(columnIndex), &return_ndx);
+        Timestamp result = TV(nativeViewPtr)->minimum_timestamp( S(columnIndex), &return_ndx);
         if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
@@ -931,10 +945,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
         switch (colType) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
             case type_Float:
             case type_Double:
             case type_String:
+            case type_Timestamp:
                 TV(nativeViewPtr)->sort( S(columnIndex), ascending != 0 ? true : false);
                 break;
             default:
@@ -980,10 +994,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
             switch (colType) {
                 case type_Bool:
                 case type_Int:
-                case type_DateTime:
                 case type_Float:
                 case type_Double:
                 case type_String:
+                case type_Timestamp:
                     indices.push_back( S(long_arr[i]) );
                     ascendings.push_back( B(bool_arr[i]) );
                     break;
@@ -1059,7 +1073,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded(
     JNIEnv* env, jobject, jlong nativeViewPtr)
 {
     bool valid = (TV(nativeViewPtr) != NULL);
diff --git a/realm/realm-jni/src/mixedutil.cpp b/realm/realm-jni/src/mixedutil.cpp
index ce80c43cb7..3317ea5a03 100644
--- a/realm/realm-jni/src/mixedutil.cpp
+++ b/realm/realm-jni/src/mixedutil.cpp
@@ -90,9 +90,9 @@ jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
         if (consId)
             return env->NewObject(jMixedClass, consId, mixed.get_bool());
     }
-    case type_DateTime:
+    case type_Timestamp:
         {
-            int_fast64_t timeValue = mixed.get_datetime().get_datetime();
+            Timestamp timeValue = mixed.get_timestamp();
             jclass jDateClass = env->FindClass("java/util/Date");
             if (jDateClass == NULL) {
                 ThrowException(env, ClassNotFound, "Date");
@@ -103,7 +103,7 @@ jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
                 ThrowException(env, NoSuchMethod, "Date", "<init>");
                 return NULL;
             }
-            jobject jDate = env->NewObject(jDateClass, jDateConsId, static_cast<jlong>(timeValue));
+            jobject jDate = env->NewObject(jDateClass, jDateConsId, to_milliseconds(timeValue));
             jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/util/Date;)V");
             if (consId)
                 return env->NewObject(jMixedClass, consId, jDate);
@@ -133,6 +133,9 @@ jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
         break;
     case type_LinkList:
         break;
+    case type_OldDateTime:
+        // not used anymore
+        break;
     }
 
     return NULL;
diff --git a/realm/realm-jni/src/tablebase_tpl.hpp b/realm/realm-jni/src/tablebase_tpl.hpp
index afd1089d48..67c05beebd 100644
--- a/realm/realm-jni/src/tablebase_tpl.hpp
+++ b/realm/realm-jni/src/tablebase_tpl.hpp
@@ -101,11 +101,11 @@ void tbl_nativeDoMixed(M doMixed, T* pTable, JNIEnv* env, jlong columnIndex, jlo
             (pTable->*doMixed)( S(columnIndex), S(rowIndex), StringData(string));
             return;
         }
-    case type_DateTime:
+    case type_Timestamp:
         {
             jlong dateTimeValue = GetMixedDateTimeValue(env, jMixedValue);
-            DateTime date(dateTimeValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(date));
+            Timestamp ts = from_milliseconds(dateTimeValue);
+            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(ts));
             return;
         }
     case type_Binary:
@@ -145,6 +145,9 @@ void tbl_nativeDoMixed(M doMixed, T* pTable, JNIEnv* env, jlong columnIndex, jlo
         break;
     case type_LinkList:
         break;
+    case type_OldDateTime:
+        // not used
+        break;
     }
     TR_ERR("ERROR: nativeSetMixed() failed.")
     ThrowException(env, IllegalArgument, "nativeSetMixed()");
@@ -186,11 +189,11 @@ void row_nativeSetMixed(R* pRow, JNIEnv* env, jlong columnIndex, jobject jMixedV
             pRow->set_mixed( S(columnIndex), StringData(string));
             return;
         }
-    case type_DateTime:
+    case type_Timestamp:
         {
             jlong dateTimeValue = GetMixedDateTimeValue(env, jMixedValue);
-            DateTime date(dateTimeValue);
-            pRow->set_mixed( S(columnIndex), Mixed(date));
+            Timestamp ts = from_milliseconds(dateTimeValue);
+            pRow->set_mixed( S(columnIndex), Mixed(ts));
             return;
         }
     case type_Binary:
@@ -230,6 +233,9 @@ void row_nativeSetMixed(R* pRow, JNIEnv* env, jlong columnIndex, jobject jMixedV
         break;
     case type_LinkList:
         break;
+    case type_OldDateTime:
+        // not used
+        break;
     }
     TR_ERR("ERROR: nativeSetMixed() failed.")
     ThrowException(env, IllegalArgument, "nativeSetMixed()");
diff --git a/realm/realm-jni/src/util.hpp b/realm/realm-jni/src/util.hpp
index c96fd26a48..8a7af2ad55 100644
--- a/realm/realm-jni/src/util.hpp
+++ b/realm/realm-jni/src/util.hpp
@@ -31,6 +31,7 @@
 #include <realm/util/meta.hpp>
 #include <realm/util/safe_int_ops.hpp>
 #include <realm/lang_bind_helper.hpp>
+#include <realm/timestamp.hpp>
 
 #include "io_realm_internal_Util.h"
 
@@ -96,7 +97,7 @@ std::string num_to_string(T pNumber)
 #define S64(x)  static_cast<int64_t>(x)
 #define TBL(x)  reinterpret_cast<realm::Table*>(x)
 #define TV(x)   reinterpret_cast<realm::TableView*>(x)
-#define LV(x)   reinterpret_cast<realm::LinkView*>(x)
+#define LV(x)   reinterpret_cast<realm::LinkViewRef*>(x)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
 #define G(x)    reinterpret_cast<realm::Group*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
@@ -292,7 +293,7 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
 }
 
 template <class T>
-inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
+inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset=false)
 {
     if (rowIndex < 0) {
         ThrowException(env, IndexOutOfBounds, "rowIndex is less than 0.");
@@ -669,6 +670,24 @@ inline jobject NewFloat(JNIEnv* env, float value)
     return env->NewObject(java_lang_float, java_lang_float_init, value);
 }
 
-extern const char* const TABLE_PREFIX;
+inline jlong to_milliseconds(const realm::Timestamp& ts)
+{
+    // From core's reference implementation aka unit test
+    // FIXME: check for overflow/underflow
+    const int64_t seconds = ts.get_seconds();
+    const int32_t nanoseconds = ts.get_nanoseconds();
+    const int64_t milliseconds = seconds * 1000 + nanoseconds / 1000000; // This may overflow
+    return milliseconds;
+}
+
+inline realm::Timestamp from_milliseconds(jlong milliseconds)
+{
+    // From core's reference implementation aka unit test
+    int64_t seconds = milliseconds / 1000;
+    int32_t nanoseconds = (milliseconds % 1000) * 1000000;
+    return realm::Timestamp(seconds, nanoseconds);
+}
+
+extern const std::string TABLE_PREFIX;
 
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/proguard-rules.pro b/realm/realm-library/proguard-rules.pro
index 980b5b3ce2..0b2181d2ed 100644
--- a/realm/realm-library/proguard-rules.pro
+++ b/realm/realm-library/proguard-rules.pro
@@ -4,3 +4,5 @@
 -keep @io.realm.internal.Keep class * { *; }
 -dontwarn javax.**
 -dontwarn io.realm.**
+-keep class io.realm.RealmCollection
+-keep class io.realm.OrderedRealmCollection
diff --git a/realm/realm-library/src/androidTest/assets/default-notnullable-primarykey.realm b/realm/realm-library/src/androidTest/assets/default-notnullable-primarykey.realm
new file mode 100644
index 0000000000..40ca6a937c
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/default-notnullable-primarykey.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/default-nullable-primarykey.realm b/realm/realm-library/src/androidTest/assets/default-nullable-primarykey.realm
new file mode 100644
index 0000000000..0611f90efd
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/default-nullable-primarykey.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 10df299323..9898a360d7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -84,20 +84,22 @@ protected void populateRealm(Realm realm, int objects) {
         realm.beginTransaction();
         realm.delete(AllJavaTypes.class);
         realm.delete(NonLatinFieldNames.class);
-        for (int i = 0; i < objects; i++) {
-            AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
-            fillObject(i, objects, obj);
-            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
-            nonLatinFieldNames.set델타(i);
-            nonLatinFieldNames.setΔέλτα(i);
-        }
-
-        // Add all items to the RealmList on the first object
-        AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst();
-        RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
-        RealmList<AllJavaTypes> list = firstObj.getFieldList();
-        for (int i = 0; i < listData.size(); i++) {
-            list.add(listData.get(i));
+        if (objects > 0) {
+            for (int i = 0; i < objects; i++) {
+                AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
+                fillObject(i, objects, obj);
+                NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
+                nonLatinFieldNames.set델타(i);
+                nonLatinFieldNames.setΔέλτα(i);
+            }
+
+            // Add all items to the RealmList on the first object
+            AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst();
+            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+            RealmList<AllJavaTypes> list = firstObj.getFieldList();
+            for (int i = 0; i < listData.size(); i++) {
+                list.add(listData.get(i));
+            }
         }
         realm.commitTransaction();
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 395aae9c24..c26e039d4b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -16,7 +16,6 @@
 
 package io.realm;
 
-
 import android.os.Handler;
 import android.support.test.runner.AndroidJUnit4;
 
@@ -27,19 +26,20 @@
 import org.junit.runner.RunWith;
 
 import java.util.Date;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
-import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.internal.log.RealmLog;
-import io.realm.proxy.HandlerProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -52,8 +52,6 @@
 @RunWith(AndroidJUnit4.class)
 public class DynamicRealmTests {
 
-    private final static int TEST_DATA_SIZE = 10;
-
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
@@ -104,10 +102,6 @@ private void populateTestRealm(DynamicRealm realm, int objects) {
         }
     }
 
-    private void populateTestRealm() {
-        populateTestRealm(realm, TEST_DATA_SIZE);
-    }
-
     // Test that the SharedGroupManager is not reused across Realm/DynamicRealm on the same thread.
     // This is done by starting a write transaction in one Realm and verifying that none of the data
     // written (but not committed) is available in the other Realm.
@@ -183,6 +177,51 @@ public void createObject_withPrimaryKey() {
         realm.cancelTransaction();
     }
 
+    @Test
+    public void createObject_withNullStringPrimaryKey() {
+        realm.beginTransaction();
+        realm.createObject(PrimaryKeyAsString.CLASS_NAME, (String) null);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(PrimaryKeyAsString.CLASS_NAME).equalTo(PrimaryKeyAsString.FIELD_PRIMARY_KEY, (String) null).count());
+    }
+
+    @Test
+    public void createObject_withNullBytePrimaryKey() {
+        realm.beginTransaction();
+        realm.createObject(PrimaryKeyAsBoxedByte.CLASS_NAME, (Byte) null);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedByte.CLASS_NAME).equalTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY, (Byte) null).count());
+    }
+
+    @Test
+    public void createObject_withNullShortPrimaryKey() {
+        realm.beginTransaction();
+        realm.createObject(PrimaryKeyAsBoxedShort.CLASS_NAME, (Short) null);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedShort.CLASS_NAME).equalTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY, (Short) null).count());
+    }
+
+    @Test
+    public void createObject_withNullIntegerPrimaryKey() {
+        realm.beginTransaction();
+        realm.createObject(PrimaryKeyAsBoxedInteger.CLASS_NAME, (Integer) null);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedInteger.CLASS_NAME).equalTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, (Integer) null).count());
+    }
+
+    @Test
+    public void createObject_withNullLongPrimaryKey() {
+        realm.beginTransaction();
+        realm.createObject(PrimaryKeyAsBoxedLong.CLASS_NAME, (Long) null);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedLong.CLASS_NAME).equalTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY, (Long) null).count());
+    }
+
     @Test(expected = IllegalArgumentException.class)
     public void createObject_illegalPrimaryKeyValue() {
         realm.beginTransaction();
@@ -230,7 +269,7 @@ public void executeTransaction_null() {
 
     @Test
     public void executeTransaction() {
-        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
         realm.executeTransaction(new DynamicRealm.Transaction() {
             @Override
             public void execute(DynamicRealm realm) {
@@ -239,7 +278,7 @@ public void execute(DynamicRealm realm) {
             }
         });
 
-        RealmResults<DynamicRealmObject> allObjects = realm.allObjects(Owner.CLASS_NAME);
+        RealmResults<DynamicRealmObject> allObjects = realm.where(Owner.CLASS_NAME).findAll();
         assertEquals(1, allObjects.size());
         assertEquals("Owner", allObjects.get(0).getString("name"));
     }
@@ -248,7 +287,7 @@ public void execute(DynamicRealm realm) {
     public void executeTransaction_cancelled() {
         final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
 
-        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
         try {
             realm.executeTransaction(new DynamicRealm.Transaction() {
                 @Override
@@ -263,12 +302,12 @@ public void execute(DynamicRealm realm) {
             //noinspection ThrowableResultOfMethodCallIgnored
             assertTrue(e == thrownException.get());
         }
-        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
     }
 
     @Test
     public void executeTransaction_warningIfManuallyCancelled() {
-        assertEquals(0, realm.allObjects("Owner").size());
+        assertEquals(0, realm.where("Owner").count());
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         try {
             RealmLog.add(testLogger);
@@ -287,392 +326,7 @@ public void execute(DynamicRealm realm) {
         } finally {
             RealmLog.remove(testLogger);
         }
-        assertEquals(0, realm.allObjects("Owner").size());
-    }
-
-    @Test
-    public void allObjectsSorted() {
-        populateTestRealm();
-        RealmResults<DynamicRealmObject> sortedList = realm.allObjectsSorted(AllTypes.CLASS_NAME, AllTypes.FIELD_STRING, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("test data 0", sortedList.first().getString(AllTypes.FIELD_STRING));
-
-        RealmResults<DynamicRealmObject> reverseList = realm.allObjectsSorted(AllTypes.CLASS_NAME, AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals("test data 0", reverseList.last().getString(AllTypes.FIELD_STRING));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void allObjectsSorted_wrongFieldName() {
-        realm.allObjectsSorted(AllTypes.CLASS_NAME, "invalid", Sort.ASCENDING);
-    }
-
-    @Test
-    public void allObjectsSorted_sortTwoFields() {
-        TestHelper.populateForMultiSort(realm);
-
-        RealmResults<DynamicRealmObject> results1 = realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results1.size());
-
-        assertEquals("Adam", results1.get(0).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results1.get(0).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Adam", results1.get(1).getString(AllTypes.FIELD_STRING));
-        assertEquals(5, results1.get(1).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Brian", results1.get(2).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results1.get(2).getLong(AllTypes.FIELD_LONG));
-
-        RealmResults<DynamicRealmObject> results2 = realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                new String[]{AllTypes.FIELD_LONG, AllTypes.FIELD_STRING},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results2.size());
-
-        assertEquals("Adam", results2.get(0).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results2.get(0).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Brian", results2.get(1).getString(AllTypes.FIELD_STRING));
-        assertEquals(4, results2.get(1).getLong(AllTypes.FIELD_LONG));
-
-        assertEquals("Adam", results2.get(2).getString(AllTypes.FIELD_STRING));
-        assertEquals(5, results2.get(2).getLong(AllTypes.FIELD_LONG));
-    }
-
-    @Test
-    public void allObjectsSorted_failures() {
-        // zero fields specified
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME, new String[]{}, new Sort[]{});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // number of fields and sorting orders don't match
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                    new String[]{AllTypes.FIELD_STRING},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // null is not allowed
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME, null, (Sort[]) null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME, new String[]{AllTypes.FIELD_STRING}, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // non-existing field name
-        try {
-            realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                    new String[]{AllTypes.FIELD_STRING, "dont-exist"},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void allObjectsSorted_singleField() {
-        populateTestRealm();
-        RealmResults<DynamicRealmObject> sortedList = realm.allObjectsSorted(AllTypes.CLASS_NAME,
-                new String[]{AllTypes.FIELD_LONG},
-                new Sort[]{Sort.DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getLong(AllTypes.FIELD_LONG));
-        assertEquals(0, sortedList.last().getLong(AllTypes.FIELD_LONG));
-    }
-
-    private void populateForDistinct(DynamicRealm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
-        boolean autoRefreshEnabled = realm.isAutoRefresh();
-        if (autoRefreshEnabled) {
-            realm.setAutoRefresh(false);
-        }
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
-            for (int j = 0; j < numberOfBlocks; j++) {
-                DynamicRealmObject obj = realm.createObject("AnnotationIndexTypes");
-                obj.setBoolean("indexBoolean", j % 2 == 0);
-                obj.setLong("indexLong", j);
-                obj.setDate("indexDate", withNull ? null : new Date(1000 * ((long) j)));
-                obj.setString("indexString", withNull ? null : "Test " + j);
-                obj.setBoolean("notIndexBoolean", j % 2 == 0);
-                obj.setLong("notIndexLong", j);
-                obj.setDate("notIndexDate", withNull ? null : new Date(1000 * ((long) j)));
-                obj.setString("notIndexString", withNull ? null : "Test " + j);
-            }
-        }
-        realm.commitTransaction();
-        if (autoRefreshEnabled) {
-            realm.setAutoRefresh(true);
-        }
-    }
-
-    private void populateForDistinctInvalidTypesLinked(DynamicRealm realm) {
-        realm.beginTransaction();
-        DynamicRealmObject notEmpty = realm.createObject(AllJavaTypes.CLASS_NAME);
-        notEmpty.setBlob(AllJavaTypes.FIELD_BINARY, new byte[]{1, 2, 3});
-        notEmpty.setObject(AllJavaTypes.FIELD_OBJECT, notEmpty);
-        notEmpty.setList(AllJavaTypes.FIELD_LIST, new RealmList<DynamicRealmObject>(notEmpty));
-        realm.commitTransaction();
-    }
-
-    /*
-     * Fields order test for Chained or Multi-Arguments Distinct()
-     *
-     * The idea is to interweave different values in 2's multiplier and 3's multiplier in a way that
-     * the outcome is different if the order of distinct* operations alternates. More numbers of
-     * fields can be constructed with the combination of multipliers in prime numbers such as 2, 3,
-     * and 5.
-     *
-     * An example is illustrated below.
-     *
-     * Object      : O1| O2| O3| O4| O5| O6
-     * indexString : A | A | B | B | A | A
-     * indexLong   : 1 | 1 | 1 | 2 | 2 | 2
-     */
-    private void populateForDistinctFieldsOrder(DynamicRealm realm, long numberOfBlocks) {
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfBlocks; i++) {
-            for (int j = 0; j < 6; j++) {
-                DynamicRealmObject obj = realm.createObject(AnnotationIndexTypes.CLASS_NAME);
-                obj.setString("indexString", (((j / 2) % 2) == 0) ? "A" : "B");
-                obj.setLong("indexLong", (j < 3) ? 1 : 2);
-            }
-        }
-        realm.commitTransaction();
-    }
-
-    @Test
-    public void distinct_invalidClassNames() {
-        String[] classNames = new String[]{null, "", "foo", "foo.bar"};
-        for (String className : classNames) {
-            try {
-                realm.distinct(className, "foo");
-                fail();
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_invalidFieldNames() {
-        String[] fieldNames = new String[]{null, "", "foo", "foo.bar"};
-        for (String fieldName : fieldNames) {
-            try {
-                realm.distinct(AnnotationIndexTypes.CLASS_NAME, fieldName);
-                fail();
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    // Realm.distinct(): requires indexing, and type = boolean, integer, date, string
-    @Test
-    public void distinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<DynamicRealmObject> distinctBool = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        assertEquals(2, distinctBool.size());
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<DynamicRealmObject> distinct = realm.distinct(AnnotationIndexTypes.CLASS_NAME, field);
-            assertEquals(field, numberOfBlocks, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.distinct(AnnotationIndexTypes.CLASS_NAME, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_invalidTypes() {
-        populateTestRealm();
-
-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
-            try {
-                realm.distinct(AllTypes.CLASS_NAME, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<DynamicRealmObject> distinctMulti = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
-        assertEquals(numberOfBlocks, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_switchedFieldsOrder() {
-        final long numberOfBlocks = 25;
-        populateForDistinctFieldsOrder(realm, numberOfBlocks);
-
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
-        RealmResults<DynamicRealmObject> distinctStringLong = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<DynamicRealmObject> distinctLongString = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(4, distinctStringLong.size());
-        assertEquals(4, distinctLongString.size());
-        assertEquals(distinctStringLong.size(), distinctLongString.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_emptyFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        // an empty string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // an empty string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // (String)null makes varargs a null array.
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two (String)null for first and varargs fields
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, (String)null, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, "", (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, (String)null, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two empty fields tests
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, "", "");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<DynamicRealmObject> distinctMulti = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(1, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_doesNotExistField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesFields() {
-        populateTestRealm();
-
-        try {
-            realm.distinct(AllTypes.CLASS_NAME, AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        try {
-            realm.distinct(AllJavaTypes.CLASS_NAME, AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
+        assertEquals(0, realm.where("Owner").count());
     }
 
     @Test
@@ -683,10 +337,9 @@ public void findFirstAsync() {
                 .between(AllTypes.FIELD_LONG, 4, 9)
                 .findFirstAsync();
         assertFalse(allTypes.isLoaded());
-
-        allTypes.addChangeListener(new RealmChangeListener() {
+        allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
-            public void onChange() {
+            public void onChange(DynamicRealmObject object) {
                 assertEquals("test data 4", allTypes.getString(AllTypes.FIELD_STRING));
                 dynamicRealm.close();
                 looperThread.testComplete();
@@ -705,9 +358,9 @@ public void findAllAsync() {
         assertFalse(allTypes.isLoaded());
         assertEquals(0, allTypes.size());
 
-        allTypes.addChangeListener(new RealmChangeListener() {
+        allTypes.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals(6, allTypes.size());
                 for (int i = 0; i < allTypes.size(); i++) {
                     assertEquals("test data " + (4 + i), allTypes.get(i).getString(AllTypes.FIELD_STRING));
@@ -728,9 +381,9 @@ public void findAllSortedAsync() {
         assertFalse(allTypes.isLoaded());
         assertEquals(0, allTypes.size());
 
-        allTypes.addChangeListener(new RealmChangeListener() {
+        allTypes.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals(5, allTypes.size());
                 for (int i = 0; i < 5; i++) {
                     int iteration = (4 - i);
@@ -796,9 +449,9 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals("data 0", realmResults1.get(0).get(AllTypes.FIELD_STRING));
                 assertEquals(3L, realmResults1.get(0).get(AllTypes.FIELD_LONG));
                 assertEquals("data 0", realmResults1.get(1).get(AllTypes.FIELD_STRING));
@@ -826,9 +479,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals("data 2", realmResults2.get(0).get(AllTypes.FIELD_STRING));
                 assertEquals(1L, realmResults2.get(0).get(AllTypes.FIELD_LONG));
                 assertEquals("data 2", realmResults2.get(1).get(AllTypes.FIELD_STRING));
@@ -857,64 +510,6 @@ public void onChange() {
         });
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync() {
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(dynamicRealm, numberOfBlocks, numberOfObjects, false);
-
-        final RealmResults<DynamicRealmObject> distinctBool = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        final RealmResults<DynamicRealmObject> distinctLong = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        final RealmResults<DynamicRealmObject> distinctDate = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_DATE);
-        final RealmResults<DynamicRealmObject> distinctString = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_STRING);
-
-        final Runnable callbackDoneTask = new Runnable() {
-            final CountDownLatch signalTestFinished = new CountDownLatch(4);
-            @Override
-            public void run() {
-                signalTestFinished.countDown();
-                if (signalTestFinished.getCount() == 0) {
-                    dynamicRealm.close();
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        distinctBool.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(2, distinctBool.size());
-                callbackDoneTask.run();
-            }
-        });
-
-        distinctLong.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(numberOfBlocks, distinctLong.size());
-                callbackDoneTask.run();
-            }
-        });
-
-        distinctDate.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(numberOfBlocks, distinctDate.size());
-                callbackDoneTask.run();
-            }
-        });
-
-        distinctString.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals(numberOfBlocks, distinctString.size());
-                callbackDoneTask.run();
-            }
-        });
-    }
-
     @Test
     @RunTestInLooperThread
     public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
similarity index 97%
rename from realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java
rename to realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
index 95d5797a34..1ba7760203 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.proxy;
+package io.realm;
 
 import android.os.Handler;
 import android.os.Message;
@@ -24,7 +24,7 @@
 /**
  * Handler decorator, to help intercept some messages before they are sent and received.
  */
-public abstract class HandlerProxy extends Handler {
+abstract class HandlerProxy extends Handler {
 
     private final HandlerController controller;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 97c81a5ced..2b008949ac 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -145,6 +145,11 @@ public void setup() {
         collection = createCollection(collectionClass);
     }
 
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
     OrderedRealmCollection<AllJavaTypes> createCollection(ManagedCollection collectionClass) {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
@@ -176,12 +181,7 @@ public void setup() {
         throw new AssertionError("Unknown collection: " + collectionClass);
     }
 
-    @After
-    public void tearDown() {
-        realm.close();
-    }
-
-    @Test
+   @Test
     public void sort_twoFields() {
         OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
         AllJavaTypes obj = sortedList.first();
@@ -240,7 +240,7 @@ public void sort_double() {
         sortedList = sortedList.sort(AllJavaTypes.FIELD_DOUBLE, Sort.DESCENDING);
         assertEquals(resultList.size(), sortedList.size());
         assertEquals(TEST_SIZE, sortedList.size());
-            assertEquals(resultList.first().getFieldDouble(), sortedList.last().getFieldDouble(), 0D);
+        assertEquals(resultList.first().getFieldDouble(), sortedList.last().getFieldDouble(), 0D);
 
         RealmResults<AllJavaTypes> reverseList = sortedList.sort(AllJavaTypes.FIELD_DOUBLE, Sort.ASCENDING);
         assertEquals(TEST_SIZE, reverseList.size());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index fa18344d51..cd1420bc98 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -128,7 +128,7 @@ public void tearDown() {
                         .getFieldList();
 
             case REALMRESULTS:
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -490,12 +490,14 @@ public void avg_partialNullRows() {
 
     @Test
     public void maxDate() {
-        assertEquals(new Date(YEAR_MILLIS * 20 * 4), collection.maxDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(TEST_SIZE, collection.size());
+        assertEquals(new Date(YEAR_MILLIS * 20 * (TEST_SIZE/2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
     }
 
     @Test
     public void minDate() {
-        assertEquals(new Date(YEAR_MILLIS * 20 * -5), collection.minDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(TEST_SIZE, collection.size());
+        assertEquals(new Date(- YEAR_MILLIS * 20 * TEST_SIZE/2), collection.minDate(AllJavaTypes.FIELD_DATE));
     }
 
     @Test
@@ -783,3 +785,4 @@ public Boolean call() throws Exception {
     }
 
 }
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java b/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java
index 5bc28cad5b..377f19eddd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java
@@ -74,7 +74,7 @@ public void testCompositeMediatorModelClassesCount() {
 
     public void testFilterableMediatorModelClassesCount() {
         //noinspection unchecked
-        final FilterableMediator mediator = new FilterableMediator(new AnimalModuleMediator(), Arrays.asList(Cat.class, CatOwner.class));
+        final FilterableMediator mediator = new FilterableMediator(new AnimalModuleMediator(), Arrays.<Class<? extends RealmModel>>asList(Cat.class, CatOwner.class));
 
         assertTrue(mediator.getModelClasses().contains(Cat.class));
         // CatOwner is not a member of AnimalModuleMediator
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 422b8b85e4..8ce41fc2fe 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -136,9 +136,9 @@ public Boolean call() throws Exception {
     @UiThreadTest
     public void removeChangeListener() throws InterruptedException, ExecutionException {
         final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
@@ -158,9 +158,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void addChangeListener_duplicatedListener() {
         final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
@@ -168,9 +168,9 @@ public void onChange() {
         Realm realm = looperThread.realm;
         realm.addChangeListener(listener);
         realm.addChangeListener(listener);
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals(1, counter.get());
                 looperThread.testComplete();
             }
@@ -187,9 +187,9 @@ public void notificationsNumber() throws InterruptedException, ExecutionExceptio
         final AtomicBoolean isReady = new AtomicBoolean(false);
         final Looper[] looper = new Looper[1];
         final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
@@ -246,15 +246,16 @@ public Boolean call() throws Exception {
         RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
     }
 
-    @Test
-    public void autoUpdateRealmResults() throws InterruptedException, ExecutionException {
+    // @Test
+    // FIXME: This test is being replaced by https://github.com/realm/realm-java/pull/2319/files
+    public void realmResultsStableDuringLooperEvent() throws InterruptedException, ExecutionException {
         final int TEST_SIZE = 10;
         final AtomicInteger counter = new AtomicInteger(0);
         final AtomicBoolean isReady = new AtomicBoolean(false);
         final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
         final Map<Integer, Integer> results = new ConcurrentHashMap<Integer, Integer>();
         final Looper[] looper = new Looper[1];
-        final RealmChangeListener listener[] = new RealmChangeListener[1];
+        final RealmChangeListener<Realm> listener[] = new RealmChangeListener[1];
 
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -268,9 +269,9 @@ public Boolean call() throws Exception {
                     realm = Realm.getInstance(realmConfig);
                     final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
                     assertEquals(0, dogs.size());
-                    listener[0] = new RealmChangeListener() {
+                    listener[0] = new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             int c = counter.incrementAndGet();
                             results.put(c, dogs.size());
                         }
@@ -417,9 +418,9 @@ public void handlerNotRemovedToSoon() {
     public void commitTransaction_delayChangeListenerOnSameThread() {
         final AtomicInteger success = new AtomicInteger(0);
         Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals(1, success.get());
                 looperThread.testComplete();
             }
@@ -433,9 +434,9 @@ public void onChange() {
     @Test
     @RunTestInLooperThread
     public void emptyCommitTriggerChangeListener() {
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 looperThread.testComplete();
             }
         };
@@ -457,9 +458,9 @@ public void addRemoveListenerConcurrency() {
         // the iterator.next get called
 
         // This one will be added when listener2's onChange called
-        final RealmChangeListener listener1 = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener1 = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Step 7: Last listener called. Should only be called once
                 counter1.incrementAndGet();
 
@@ -474,9 +475,9 @@ public void onChange() {
         };
 
         // This one will be existing in the list all the time
-        final RealmChangeListener listener2 = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener2 = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Step 3: Listener2 called
                 // Listener state [listener2, listener3, listener1]
                 // Listener 1 will not be called this time around
@@ -486,9 +487,9 @@ public void onChange() {
         };
 
         // This one will be removed after first transaction
-        RealmChangeListener listener3 = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener3 = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Step 4: Listener3 called
                 // Listener state [listener2, listener1]
                 counter3.incrementAndGet();
@@ -527,9 +528,9 @@ public void weakReferenceListener() throws InterruptedException {
         final Realm realm = looperThread.realm;
 
         // Setup weak listener
-        RealmChangeListener weakListener = new RealmChangeListener() {
+        RealmChangeListener<Realm> weakListener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 weakCounter.incrementAndGet();
             }
         };
@@ -538,9 +539,9 @@ public void onChange() {
 
         // This is not a weak listener so will be called. When this is triggered the weak references have not been
         // removed yet. So make another change to ensure that they really are removed before validating.
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int count = strongCounter.incrementAndGet();
                 if (count == 1) {
                     realm.beginTransaction();
@@ -555,7 +556,7 @@ public void onChange() {
         });
 
         // Hack: There is no guaranteed way to release the WeakReference, just clear it.
-        for (WeakReference<RealmChangeListener> weakRef : realm.handlerController.weakChangeListeners) {
+        for (WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef : realm.handlerController.weakChangeListeners) {
             weakRef.clear();
         }
 
@@ -574,15 +575,15 @@ public void onChange() {
     public void removingWeakReferenceListener() throws InterruptedException {
         final AtomicInteger counter = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmChangeListener listenerA = new RealmChangeListener() {
+        RealmChangeListener<Realm> listenerA = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
-        RealmChangeListener listenerB = new RealmChangeListener() {
+        RealmChangeListener<Realm> listenerB = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals(0, counter.get());
                 assertEquals(1, realm.handlerController.weakChangeListeners.size());
                 looperThread.testComplete();
@@ -592,7 +593,7 @@ public void onChange() {
 
         // There is no guaranteed way to release the WeakReference,
         // just clear it.
-        for (WeakReference<RealmChangeListener> weakRef : realm.handlerController.weakChangeListeners) {
+        for (WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef : realm.handlerController.weakChangeListeners) {
             weakRef.clear();
         }
 
@@ -612,10 +613,10 @@ public void realmNotificationOrder() {
         final AtomicInteger listenerBCalled = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
 
-        final RealmChangeListener listenerA = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listenerA = new RealmChangeListener<Realm>() {
 
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int called = listenerACalled.incrementAndGet();
                 if (called == 2) {
                     assertEquals(2, listenerBCalled.get());
@@ -623,9 +624,9 @@ public void onChange() {
                 }
             }
         };
-        final RealmChangeListener listenerB = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listenerB = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 listenerBCalled.incrementAndGet();
                 if (listenerACalled.get() == 1) {
                     // 2. Reverse order
@@ -662,9 +663,9 @@ public void doNotUseClosedHandler() throws InterruptedException {
             public void run() {
                 Looper.prepare();
                 final Realm realm = Realm.getInstance(realmConfig);
-                RealmChangeListener listener = new RealmChangeListener() {
+                RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         realm.close();
                         handlerNotified.countDown();
                     }
@@ -680,9 +681,9 @@ public void onChange() {
             public void run() {
                 Looper.prepare();
                 Realm realm = Realm.getInstance(realmConfig);
-                RealmChangeListener listener = new RealmChangeListener() {
+                RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         try {
                             fail("This handler should not be notified");
                         } catch (AssertionFailedError e) {
@@ -779,9 +780,9 @@ public void run() {
                     assertionFailedErrors[0] = e;
                 }
                 final Realm backgroundRealm = Realm.getInstance(realmConfig);
-                backgroundRealm.addChangeListener(new RealmChangeListener() {
+                backgroundRealm.addChangeListener(new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         backgroundRealm.close();
                         numberOfInvocation.countDown();
                     }
@@ -831,9 +832,9 @@ public void run() {
             @Override
             public void run() {
                 final Realm mainRealm = Realm.getInstance(realmConfig);
-                mainRealm.addChangeListener(new RealmChangeListener() {
+                mainRealm.addChangeListener(new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         mainRealm.close();
                         numberOfInvocation.countDown();
                     }
@@ -868,18 +869,18 @@ public void run() {
 
                 try {
                     realm[0] = Realm.getInstance(realmConfig);
-                    realm[0].addChangeListener(new RealmChangeListener() {
+                    realm[0].addChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             RealmResults<Dog> dogs; // to keep it as a strong reference
                             switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
                                 case 1: {
                                     // first commit
                                     dogs = realm[0].where(Dog.class).findAllAsync();
                                     assertTrue(dogs.load());
-                                    dogs.addChangeListener(new RealmChangeListener() {
+                                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                                         @Override
-                                        public void onChange() {
+                                        public void onChange(RealmResults<Dog> object) {
                                             numberOfAsyncRealmResultsCallbackInvocation.incrementAndGet();
                                         }
                                     });
@@ -944,17 +945,17 @@ public void run() {
     public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification() {
         final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-        looperThread.realm.addChangeListener(new RealmChangeListener() {
+        looperThread.realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
                     case 1: {
                         // first commit
                         Dog dog = looperThread.realm.where(Dog.class).findFirstAsync();
                         assertTrue(dog.load());
-                        dog.addChangeListener(new RealmChangeListener() {
+                        dog.addChangeListener(new RealmChangeListener<Dog>() {
                             @Override
-                            public void onChange() {
+                            public void onChange(Dog dog) {
                             }
                         });
                         looperThread.keepStrongReference.add(dog);
@@ -999,9 +1000,9 @@ public void realmListenerAddedAfterCommit() {
         realm.beginTransaction();
         realm.commitTransaction();
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 looperThread.testComplete();
             }
         });
@@ -1016,9 +1017,9 @@ public void realmResultsListenerAddedAfterCommit() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        results.addChangeListener(new RealmChangeListener() {
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
@@ -1036,9 +1037,9 @@ public void realmObjectListenerAddedAfterCommit() {
         obj.setColumnLong(42);
         realm.commitTransaction();
 
-        obj.addChangeListener(new RealmChangeListener() {
+        obj.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 looperThread.testComplete();
             }
         });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
new file mode 100644
index 0000000000..0539661a07
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -0,0 +1,1128 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class OrderedRealmCollectionIteratorTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private final CollectionClass collectionClass;
+    private Realm realm;
+    private OrderedRealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<CollectionClass> data() {
+        return Arrays.asList(CollectionClass.values());
+    }
+
+    public OrderedRealmCollectionIteratorTests(CollectionClass collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        collection = createCollection(realm, collectionClass, TEST_SIZE);
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    private OrderedRealmCollection<AllJavaTypes> createCollection(Realm realm, CollectionClass collectionClass, int sampleSize) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                boolean isEmpty = (sampleSize == 0);
+                int newSampleSize = (isEmpty) ? 2 : sampleSize;
+                populateRealm(realm, newSampleSize);
+                return realm.where(AllJavaTypes.class)
+                    .equalTo(AllJavaTypes.FIELD_LONG, isEmpty ? 1 : 0)
+                    .findFirst()
+                    .getFieldList();
+
+            case UNMANAGED_REALMLIST:
+                populateRealm(realm, sampleSize);
+                RealmResults<AllJavaTypes> objects = realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                RealmList<AllJavaTypes> inMemoryList = new RealmList<AllJavaTypes>();
+                inMemoryList.addAll(objects);
+                return inMemoryList;
+
+            case REALMRESULTS:
+                populateRealm(realm, sampleSize);
+                return realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    private void appendElementToCollection(Realm realm, CollectionClass collection) {
+        realm.beginTransaction();
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst().getFieldList().add(new AllJavaTypes(TEST_SIZE + 1));
+                break;
+
+            case UNMANAGED_REALMLIST:
+            case REALMRESULTS:
+                realm.createObject(AllJavaTypes.class, TEST_SIZE + 1);
+                break;
+            default:
+                fail("Unknown class: " + collection);
+        }
+        realm.commitTransaction();
+    }
+
+    private void createNewObject() {
+        Number currentMax = realm.where(AllJavaTypes.class).max(AllJavaTypes.FIELD_LONG);
+        long nextId = 0;
+        if (currentMax != null) {
+            nextId = currentMax.longValue() + 1;
+        }
+
+        realm.beginTransaction();
+        realm.createObject(AllJavaTypes.class, nextId);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Helper method for checking if the unit test isn't supported for the current collectionClass.
+     *
+     * @param unsupportedTypes list of unsupported test types
+     * @return {@code true} if the unit test should be aborted, {@code false} if it should continue.
+     */
+    private boolean skipTest(CollectionClass... unsupportedTypes) {
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < unsupportedTypes.length; i++) {
+            if (unsupportedTypes[i].equals(collectionClass)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Test
+    public void iterator() {
+        Iterator<AllJavaTypes> it = collection.iterator();
+        int i = 0;
+        while (it.hasNext()) {
+            AllJavaTypes item = it.next();
+            assertEquals("Failed at index: " + i, i, item.getFieldLong());
+            i++;
+        }
+        assertEquals(TEST_SIZE, collection.size());
+        assertEquals(TEST_SIZE, i);
+    }
+
+    @Test
+    public void iterator_empty() {
+        collection = createCollection(realm, collectionClass, 0);
+        Iterator<AllJavaTypes> it = collection.iterator();
+        assertFalse(it.hasNext());
+        assertEquals(0, collection.size());
+    }
+
+    @Test
+    public void iterator_oneElement() {
+        collection = createCollection(realm, collectionClass, 1);
+        Iterator<AllJavaTypes> it = collection.iterator();
+        //noinspection WhileLoopReplaceableByForEach
+        int i = 0;
+        while (it.hasNext()) {
+            AllJavaTypes item = it.next();
+            assertEquals(0, item.getFieldLong());
+            i++;
+        }
+        assertEquals(1, collection.size());
+        assertEquals(1, i);
+    }
+
+    @Test
+    public void iterator_unrelatedTransactionBeforeNextItem() {
+        Iterator<AllJavaTypes> it = collection.iterator();
+        int i = 0;
+        while (it.hasNext()) {
+            AllJavaTypes item = it.next();
+            assertEquals("Failed at index: " + i, i, item.getFieldLong());
+            i++;
+
+            // Committing unrelated transactions while iterating should not effect the current iterator.
+            createNewObject();
+        }
+    }
+
+    @Test
+    public void iterator_closedRealm_methodsThrows() {
+        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        Iterator<AllJavaTypes> it = collection.iterator();
+        realm.close();
+        try {
+            it.hasNext();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            it.next();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            it.remove();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(CollectionClass.MANAGED_REALMLIST, collectionClass);
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+    }
+
+    @Test
+    public void iterator_remove_beforeNext() {
+        Iterator<AllJavaTypes> it = collection.iterator();
+        realm.beginTransaction();
+
+        try {
+            it.remove();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        } catch (IllegalStateException ignored) {
+            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+    }
+
+    @Test
+    public void iterator_remove() {
+        Iterator<AllJavaTypes> it = collection.iterator();
+        AllJavaTypes obj = it.next();
+        assertEquals("test data 0", obj.getFieldString());
+        realm.beginTransaction();
+
+        try {
+            it.remove();
+        } catch (UnsupportedOperationException e) {
+            // RealmResults doesn't support remove
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            return;
+        }
+
+        // un-managed objects are always invalid, but cannot be GC'ed while we have a reference.
+        // managed objects should not be deleted (= invalid).
+        assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        assertTrue(obj.isValid());
+        assertEquals("test data 1", collection.iterator().next().getFieldString());
+        assertEquals(TEST_SIZE - 1, collection.size());
+    }
+
+    @Test
+    public void iterator_deleteManagedObjectIndirectly() {
+        realm.beginTransaction();
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next(); // First item is a cyclic reference to the entire graph, avoid deleting that.
+        it.next().deleteFromRealm();
+        realm.commitTransaction();
+
+        switch (collectionClass) {
+            // Managed RealmLists are directly associated with their table. Thus any indirect deletion will
+            // also remove it from the LinkView.
+            case MANAGED_REALMLIST:
+                assertEquals(TEST_SIZE - 1, collection.size());
+                break;
+
+            // Un-managed collections are not affected by changes to Realm and RealmResult should maintain a stable
+            // view until next time sync_if_needed is called.
+            case UNMANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(TEST_SIZE, collection.size());
+                break;
+
+            default:
+                fail();
+        }
+    }
+
+    @Test
+    public void iterator_removeCalledTwice() {
+        if (skipTest(CollectionClass.REALMRESULTS)) {
+            return; // remove() not supported by RealmResults
+        }
+
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next();
+        realm.beginTransaction();
+        it.remove();
+
+        thrown.expect(IllegalStateException.class);
+        it.remove();
+    }
+
+    // TODO Remove once waitForChange is introduced
+    @Test
+    public void iterator_refreshWhileIterating_nonLooper() {
+        final CountDownLatch bgDone = new CountDownLatch(1);
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
+                appendElementToCollection(realm, collectionClass);
+                realm.close();
+                bgDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDone);
+
+        realm.refresh();
+        switch (collectionClass) {
+            case UNMANAGED_REALMLIST:
+                assertEquals(TEST_SIZE, collection.size());
+                break;
+
+            case MANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(TEST_SIZE + 1, collection.size());
+                break;
+
+            default:
+                fail("Unknown class: " + collectionClass);
+        }
+    }
+
+    // TODO Remove once waitForChange is introduced
+    @Test
+    @UiThreadTest
+    public void iterator_refreshWhileIterating_looper() {
+        final CountDownLatch bgDone = new CountDownLatch(1);
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
+                appendElementToCollection(realm, collectionClass);
+                realm.close();
+                bgDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDone);
+
+        realm.refresh();
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+            case UNMANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(TEST_SIZE, collection.size());
+                break;
+
+            default:
+                fail("Unknown class: " + collectionClass);
+        }
+    }
+
+
+    // TODO Remove once waitForChange is introduced
+    @Test
+    public void iterator_refreshClearsDeletedObjects() {
+        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        assertEquals(0, collection.iterator().next().getFieldLong());
+        realm.beginTransaction();
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next(); // First item is a cyclic reference, avoid deleting that
+        AllJavaTypes obj = it.next();
+        assertEquals(1, obj.getFieldLong());
+        obj.deleteFromRealm();
+        realm.commitTransaction();
+        realm.refresh(); // Force a refresh of all Collections
+
+        assertEquals(TEST_SIZE - 1, collection.size());
+
+        it = collection.iterator();
+        it.next();
+        obj = it.next(); // Iterator can no longer access the deleted object
+        assertTrue(obj.isValid());
+        assertEquals(2, obj.getFieldLong());
+    }
+
+    @Test
+    public void listIterator_empty() {
+        collection = createCollection(realm, collectionClass, 0);
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+
+        assertFalse(it.hasPrevious());
+        assertFalse(it.hasNext());
+        assertEquals(0, it.nextIndex());
+        assertEquals(-1, it.previousIndex());
+
+        try {
+            it.next();
+            fail();
+        } catch (NoSuchElementException ignored) {
+        }
+
+        try {
+            it.previous();
+            fail();
+        } catch (NoSuchElementException ignored) {
+        }
+    }
+
+    @Test
+    public void listIterator_oneElement() {
+        collection = createCollection(realm, collectionClass, 1);
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+
+        // Test beginning of the list
+        assertFalse(it.hasPrevious());
+        assertTrue(it.hasNext());
+        assertEquals(-1, it.previousIndex());
+        assertEquals(0, it.nextIndex());
+
+        // Test end of the list
+        AllJavaTypes firstObject = it.next();
+        assertEquals(0, firstObject.getFieldLong());
+        assertTrue(it.hasPrevious());
+        assertFalse(it.hasNext());
+        assertEquals(0, it.previousIndex());
+        assertEquals(1, it.nextIndex());
+    }
+
+    @Test
+    public void listIterator_manyElements() {
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+
+        // Test beginning of the list
+        assertFalse(it.hasPrevious());
+        assertTrue(it.hasNext());
+        assertEquals(-1, it.previousIndex());
+        assertEquals(0, it.nextIndex());
+
+        // Test 1st element in the list
+        AllJavaTypes firstObject = it.next();
+        assertEquals(0, firstObject.getFieldLong());
+        assertTrue(it.hasPrevious());
+        assertEquals(0, it.previousIndex());
+
+        // Move to second last element
+        for (int i = 1; i < TEST_SIZE - 1; i++) {
+            it.next();
+        }
+        assertTrue(it.hasPrevious());
+        assertTrue(it.hasNext());
+        assertEquals(TEST_SIZE - 1, it.nextIndex());
+
+        // Test end of the list
+        AllJavaTypes lastObject = it.next();
+        assertEquals(TEST_SIZE - 1, lastObject.getFieldLong());
+        assertTrue(it.hasPrevious());
+        assertFalse(it.hasNext());
+        assertEquals(TEST_SIZE, it.nextIndex());
+    }
+
+    @Test
+    public void listIterator_defaultStartIndex() {
+        ListIterator<AllJavaTypes> it1 = collection.listIterator(0);
+        ListIterator<AllJavaTypes> it2 = collection.listIterator();
+
+        assertEquals(it1.previousIndex(), it2.previousIndex());
+        assertEquals(it1.nextIndex(), it2.nextIndex());
+    }
+
+    @Test
+    public void listIterator_startIndex() {
+        int i = TEST_SIZE/2;
+        ListIterator<AllJavaTypes> it = collection.listIterator(i);
+
+        assertTrue(it.hasPrevious());
+        assertTrue(it.hasNext());
+        assertEquals(i - 1, it.previousIndex());
+        assertEquals(i, it.nextIndex());
+        AllJavaTypes nextObject = it.next();
+        assertEquals(i, nextObject.getFieldLong());
+    }
+
+    @Test
+    public void listIterator_remove_beforeNext() {
+        Iterator<AllJavaTypes> it = collection.listIterator();
+        realm.beginTransaction();
+
+        try {
+            it.remove();
+        } catch (IllegalStateException e) {
+            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+    }
+
+    @Test
+    public void listIterator_remove_calledTwice() {
+        Iterator<AllJavaTypes> it = collection.listIterator();
+        it.next();
+        realm.beginTransaction();
+
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+            case UNMANAGED_REALMLIST:
+                it.remove();
+                thrown.expect(IllegalStateException.class);
+                it.remove();
+                break;
+            case REALMRESULTS:
+                try {
+                    it.remove(); // Method not supported
+                    fail();
+                } catch (UnsupportedOperationException ignored) {
+                }
+                break;
+            default:
+                fail("Unknown collection class: " + collectionClass);
+        }
+    }
+
+    @Test
+    public void listIterator_transactionBeforeNextItem() {
+        Iterator<AllJavaTypes> it = collection.listIterator();
+        int i = 0;
+        while (it.hasNext()) {
+            AllJavaTypes item = it.next();
+            assertEquals("Failed at index: " + i, i, item.getFieldLong());
+            i++;
+
+            // Committing transactions while iterating should not effect the current iterator if on a looper thread
+            createNewObject();
+        }
+    }
+
+    @Test
+    public void listIterator_refreshClearsDeletedObjects() {
+        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        assertEquals(0, collection.iterator().next().getFieldLong());
+        realm.beginTransaction();
+        Iterator<AllJavaTypes> it = collection.listIterator();
+        it.next(); // First item is a cyclic reference, avoid deleting that
+        AllJavaTypes obj = it.next();
+        assertEquals(1, obj.getFieldLong());
+        obj.deleteFromRealm();
+        realm.commitTransaction();
+        realm.refresh(); // Refresh forces a refresh of all Collections
+
+        assertEquals(TEST_SIZE - 1, collection.size());
+
+        it = collection.iterator();
+        it.next();
+        obj = it.next(); // Iterator can no longer access the deleted object
+        assertTrue(obj.isValid());
+        assertEquals(2, obj.getFieldLong());
+    }
+
+    @Test
+    public void listIterator_closedRealm_methods() {
+        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        int location = TEST_SIZE / 2;
+        ListIterator<AllJavaTypes> it = collection.listIterator(location);
+        realm.close();
+
+        try {
+            assertEquals(location - 1, it.previousIndex());
+        } catch (IllegalStateException e) {
+            fail();
+        }
+
+        try {
+            assertEquals(location, it.nextIndex());
+        } catch (IllegalStateException e) {
+            fail();
+        }
+
+        try {
+            assertTrue(it.hasNext());
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            it.next();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            it.previous();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            it.remove();
+            fail();
+        } catch (IllegalStateException e) {
+            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        } catch (UnsupportedOperationException ignored) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+    }
+
+    // TODO Remove once waitForChange is introduced
+    @Test
+    public void listIterator_refreshWhileIterating_nonLooper() {
+        final CountDownLatch bgDone = new CountDownLatch(1);
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
+                appendElementToCollection(realm, collectionClass);
+                realm.close();
+                bgDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDone);
+
+        realm.refresh();
+        switch (collectionClass) {
+            case UNMANAGED_REALMLIST:
+                assertEquals(TEST_SIZE, collection.size());
+                break;
+
+            case MANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(TEST_SIZE + 1, collection.size());
+                break;
+
+            default:
+                fail("Unknown class: " + collectionClass);
+        }
+    }
+
+    // TODO Remove once waitForChange is introduced
+    @Test
+    @UiThreadTest
+    public void listIterator_refreshWhileIterating_looper() {
+        final CountDownLatch bgDone = new CountDownLatch(1);
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
+                appendElementToCollection(realm, collectionClass);
+                realm.close();
+                bgDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDone);
+
+        realm.refresh();
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+            case UNMANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(TEST_SIZE, collection.size());
+                break;
+
+            default:
+                fail("Unknown class: " + collectionClass);
+        }
+    }
+
+    @Test
+    public void listIterator_deleteManagedObjectIndirectly() {
+        realm.beginTransaction();
+        Iterator<AllJavaTypes> it = collection.iterator();
+        it.next();
+        it.next().deleteFromRealm();
+        realm.commitTransaction();
+
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                assertEquals(TEST_SIZE - 1, collection.size());
+                break;
+            case UNMANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(TEST_SIZE, collection.size());
+                break;
+        }
+        it = collection.listIterator();
+        it.next();
+        AllJavaTypes types = it.next(); // Iterator can still access the deleted object
+
+        //noinspection SimplifiableConditionalExpression
+        assertTrue(collectionClass == CollectionClass.MANAGED_REALMLIST ? types.isValid() : !types.isValid());
+    }
+
+    @Test
+    public void listIterator_remove_doesNotDeleteObject() {
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+        AllJavaTypes obj = it.next();
+        assertEquals("test data 0", obj.getFieldString());
+        realm.beginTransaction();
+        try {
+            it.remove();
+            if (collectionClass == CollectionClass.REALMRESULTS) {
+                fail();
+            }
+            assertTrue(obj.isValid());
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+    }
+
+    @Test
+    public void listIterator_set() {
+        if (skipTest(CollectionClass.REALMRESULTS)) {
+            return;
+        }
+
+        realm.beginTransaction();
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+
+        // Calling set() before next() should throw
+        try {
+            it.set(new AllJavaTypes());
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        AllJavaTypes obj = it.next();
+        assertEquals(0, obj.getFieldLong());
+        it.set(new AllJavaTypes(42));
+
+        it.next();
+        it.previous(); // A big ListIterator WTF!, but it is by design.
+        obj = it.previous();
+        assertEquals(42, obj.getFieldLong());
+    }
+
+    public void listIterator_add() {
+        if (skipTest(CollectionClass.REALMRESULTS)) {
+            return;
+        }
+
+        realm.beginTransaction();
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+
+        // Calling set() before next() should throw
+        try {
+            it.add(new AllJavaTypes());
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        AllJavaTypes obj = it.next();
+        assertEquals(0, obj.getFieldLong());
+        it.add(new AllJavaTypes(42));
+        obj = it.previous();
+        assertEquals(42, obj.getFieldLong());
+    }
+
+    @Test
+    public void listIterator_unsupportedMethods() {
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+        try {
+            it.remove();
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        } catch (IllegalStateException e) {
+            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+
+        try {
+            it.add(null);
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        } catch (IllegalArgumentException e) {
+            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+
+        try {
+            it.set(new AllJavaTypes());
+            fail();
+        } catch (UnsupportedOperationException e) {
+            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        } catch (IllegalStateException e) {
+            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+        }
+    }
+
+    @Test
+    public void iterator_outsideChangeToSizeThrowsConcurrentModification() {
+        if (skipTest(CollectionClass.REALMRESULTS)) {
+            return;
+        }
+
+        // Test all standard collection methods
+        for (CollectionMethod method : CollectionMethod.values()) {
+            collection = createCollection(realm, collectionClass, TEST_SIZE);
+            realm.beginTransaction();
+            Iterator<AllJavaTypes> it = collection.iterator();
+            switch (method) {
+                case ADD_OBJECT: collection.add(new AllJavaTypes(TEST_SIZE)); break;
+                case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes(TEST_SIZE))); break;
+                case CLEAR: collection.clear(); break;
+                case REMOVE_OBJECT: collection.remove(collection.get(0)); break;
+                case REMOVE_ALL: collection.removeAll(Collections.singletonList(collection.get(0))); break;
+                case RETAIN_ALL: collection.retainAll(Collections.singletonList(collection.get(0))); break;
+
+                // Does not impact size, so does not trigger ConcurrentModificationException
+                case CONTAINS:
+                case CONTAINS_ALL:
+                case EQUALS:
+                case HASHCODE:
+                case IS_EMPTY:
+                case ITERATOR:
+                case SIZE:
+                case TO_ARRAY:
+                case TO_ARRAY_INPUT:
+                    realm.cancelTransaction();
+                    continue;
+                default:
+                    fail("Unknown method: " + method);
+            }
+            checkIteratorThrowsConcurrentModification(realm, method.toString(), it);
+        }
+
+        for (ListMethod method : ListMethod.values()) {
+            collection = createCollection(realm, collectionClass, TEST_SIZE);
+            realm.beginTransaction();
+            Iterator<AllJavaTypes> it = collection.iterator();
+            switch (method) {
+                case ADD_INDEX: collection.add(0, new AllJavaTypes(TEST_SIZE)); break;
+                case ADD_ALL_INDEX: collection.addAll(0, Collections.singleton(new AllJavaTypes(TEST_SIZE))); break;
+                case REMOVE_INDEX: collection.remove(0); break;
+
+                // Does not impact size, so does not trigger ConcurrentModificationException
+                case FIRST:
+                case LAST:
+                case GET_INDEX:
+                case INDEX_OF:
+                case LAST_INDEX_OF:
+                case LIST_ITERATOR:
+                case LIST_ITERATOR_INDEX:
+                case SET:
+                case SUBLIST:
+                    realm.cancelTransaction();
+                    continue;
+
+                default:
+                    fail("Unknown method: " + method);
+            }
+            checkIteratorThrowsConcurrentModification(realm, method.toString(), it);
+        }
+    }
+
+    @Test
+    public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedCollection() {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        // Test all RealmCollection methods
+        for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
+            collection = createCollection(realm, collectionClass, TEST_SIZE);
+            realm.beginTransaction();
+            collection.remove(0); // Remove object creating circular dependency which will crash deleteAll.
+            Iterator<AllJavaTypes> it = collection.iterator();
+            switch (method) {
+                case DELETE_ALL_FROM_REALM:
+                    collection.deleteAllFromRealm(); break;
+
+                // Does not impact size, so does not trigger ConcurrentModificationException
+                case WHERE:
+                case MIN:
+                case MAX:
+                case SUM:
+                case AVERAGE:
+                case MIN_DATE:
+                case MAX_DATE:
+                case IS_VALID:
+                    realm.cancelTransaction();
+                    continue;
+                default:
+                    fail("Unknown method: " + method);
+            }
+            checkIteratorThrowsConcurrentModification(realm, method.toString(), it);
+        }
+
+        // Test all OrderedRealmCollection methods
+        for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
+            collection = createCollection(realm, collectionClass, TEST_SIZE);
+            realm.beginTransaction();
+            Iterator<AllJavaTypes> it = collection.iterator();
+            switch (method) {
+                case DELETE_INDEX: collection.deleteFromRealm(0); break;
+                case DELETE_FIRST: collection.deleteFirstFromRealm(); break;
+                case DELETE_LAST: collection.deleteLastFromRealm(); break;
+
+                // Does not impact size, so does not trigger ConcurrentModificationException
+                case SORT:
+                case SORT_FIELD:
+                case SORT_2FIELDS:
+                case SORT_MULTI:
+                    realm.cancelTransaction();
+                    continue;
+                default:
+                    fail("Unknown method: " + method);
+
+            }
+            checkIteratorThrowsConcurrentModification(realm, method.toString(), it);
+        }
+    }
+
+
+    private void checkIteratorThrowsConcurrentModification(Realm realm, String method, Iterator<AllJavaTypes> it) {
+        try {
+            it.next();
+            fail("Method should have thrown: " + method);
+        } catch (ConcurrentModificationException ignored) {
+        } catch (Exception e) {
+            throw new RuntimeException("Method failed: " + method, e);
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void iterator_realmResultsThrowConcurrentModification() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        // Verify that ConcurrentModification is correctly detected on non-looper threads
+        Iterator<AllJavaTypes> it = collection.iterator();
+        realm.beginTransaction();
+        realm.createObject(AllJavaTypes.class, TEST_SIZE);
+        realm.commitTransaction();
+        realm.refresh();
+
+        try {
+            it.next();
+            fail();
+        } catch (ConcurrentModificationException ignored) {
+        }
+    }
+
+    @Test
+    public void useCase_simpleIterator_modifyQueryResult_innerTransaction() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        for (int i = 0; i < collection.size(); i++) {
+            realm.beginTransaction();
+            AllJavaTypes obj = collection.get(i);
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+            realm.commitTransaction();
+        }
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    public void useCase_simpleIterator_modifyQueryResult_outerTransaction() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        realm.beginTransaction();
+        for (int i = 0; i < collection.size(); i++) {
+            AllJavaTypes obj = collection.get(i);
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+        }
+        realm.commitTransaction();
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    public void useCase_forEachIterator_modifyQueryResult_innerTransaction() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        for (AllJavaTypes obj : collection) {
+            realm.beginTransaction();
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+            realm.commitTransaction();
+        }
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    public void useCase_forEachIterator_modifyQueryResult_outerTransaction() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        realm.beginTransaction();
+        for (AllJavaTypes obj : collection) {
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+        }
+        realm.commitTransaction();
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    @UiThreadTest
+    public void useCase_simpleIterator_modifyQueryResult_innerTransaction_looperThread() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        for (int i = 0; i < collection.size(); i++) {
+            realm.beginTransaction();
+            AllJavaTypes obj = collection.get(i);
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+            realm.commitTransaction();
+        }
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    @UiThreadTest
+    public void useCase_simpleIterator_modifyQueryResult_outerTransaction_looperThread() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        realm.beginTransaction();
+        for (int i = 0; i < collection.size(); i++) {
+            AllJavaTypes obj = collection.get(i);
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+        }
+        realm.commitTransaction();
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    @UiThreadTest
+    public void useCase_forEachIterator_modifyQueryResult_innerTransaction_looperThread() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        for (AllJavaTypes obj : collection) {
+            realm.beginTransaction();
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+            realm.commitTransaction();
+        }
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+
+    @Test
+    @UiThreadTest
+    public void useCase_forEachIterator_modifyQueryResult_outerTransaction_looperThread() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+            return;
+        }
+
+        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(TEST_SIZE, collection.size());
+        realm.beginTransaction();
+        for (AllJavaTypes obj : collection) {
+            obj.setFieldLong(obj.getFieldLong() + TEST_SIZE);
+        }
+        realm.commitTransaction();
+
+        // Verify that all elements were modified
+        assertEquals(0, realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).count());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index 778d6b76c2..e7c7235988 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -132,6 +132,11 @@ public void setup() {
         collection = createCollection(realm, collectionClass);
     }
 
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
     private OrderedRealmCollection<AllJavaTypes> createCollection(Realm realm, CollectionClass collectionClass) {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
@@ -200,11 +205,6 @@ public void setup() {
         }
     }
 
-    @After
-    public void tearDown() {
-        realm.close();
-    }
-
     @Test
     public void first() {
         assertEquals(collection.get(0), collection.first());
@@ -365,4 +365,5 @@ public void methods_indexOutOfBounds() {
             }
         }
     }
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
deleted file mode 100644
index f42ca7a48f..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.annotation.UiThreadTest;
-import android.support.test.rule.UiThreadTestRule;
-import android.support.test.runner.AndroidJUnit4;
-import android.view.View;
-import android.widget.TextView;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.RealmAdapter;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-
-@RunWith(AndroidJUnit4.class)
-public class RealmAdapterTest {
-    @Rule
-    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
-    private Context context;
-
-    private final static String FIELD_STRING = "columnString";
-    private final static int TEST_DATA_SIZE = 47;
-
-    private boolean automaticUpdate = true;
-    private Realm testRealm;
-
-    @Before
-    public void setUp() throws Exception {
-        // Injecting the Instrumentation instance is required
-        // for your test to run with AndroidJUnitRunner.
-        context = InstrumentationRegistry.getInstrumentation().getContext();
-
-        RealmConfiguration realmConfig = TestHelper.createConfiguration(context);
-        Realm.deleteRealm(realmConfig);
-        testRealm = Realm.getInstance(realmConfig);
-
-        testRealm.beginTransaction();
-        for (int i = 0; i < TEST_DATA_SIZE; ++i) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnString("test data " + i);
-        }
-        testRealm.commitTransaction();
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-    @Test
-    public void testAdapterParameterExceptions() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        try {
-            RealmAdapter realmAdapter = new RealmAdapter(null, resultList, automaticUpdate);
-            fail("Should throw exception if context is null");
-        } catch (IllegalArgumentException ignore) {
-        }
-    }
-
-    @Test
-    public void testUpdateRealmResultInAdapter() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        resultList.sort(FIELD_STRING);
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, false);
-        assertEquals(resultList.first().getColumnString(), realmAdapter.getRealmResults().first().getColumnString());
-        assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
-
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        allTypes.setColumnString("test data " + TEST_DATA_SIZE);
-        testRealm.commitTransaction();
-        assertEquals(resultList.last().getColumnString(), realmAdapter.getRealmResults().last().getColumnString());
-        assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
-
-        RealmResults<AllTypes> emptyResultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "Not there").findAll();
-        realmAdapter.updateRealmResults(emptyResultList);
-        assertEquals(emptyResultList.size(), realmAdapter.getRealmResults().size());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testClearFromAdapter() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-
-        testRealm.beginTransaction();
-        realmAdapter.getRealmResults().deleteAllFromRealm();
-        testRealm.commitTransaction();
-
-        assertEquals(0, realmAdapter.getCount());
-        assertEquals(0, resultList.size());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testRemoveFromAdapter() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-
-        testRealm.beginTransaction();
-        realmAdapter.getRealmResults().deleteFromRealm(0);
-        testRealm.commitTransaction();
-        assertEquals(TEST_DATA_SIZE - 1, realmAdapter.getCount());
-
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "test data 0").findAll();
-        assertEquals(0, resultList.size());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testSortWithAdapter() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        resultList.sort(FIELD_STRING, Sort.DESCENDING);
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-        assertEquals(resultList.first().getColumnString(), realmAdapter.getRealmResults().first().getColumnString());
-        assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
-
-        resultList.sort(FIELD_STRING);
-
-        assertEquals(resultList.last().getColumnString(), realmAdapter.getRealmResults().last().getColumnString());
-        assertEquals(resultList.get(TEST_DATA_SIZE / 2).getColumnString(), realmAdapter.getRealmResults().get(TEST_DATA_SIZE / 2).getColumnString());
-        assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testEmptyRealmResult() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "Not there").findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-        assertEquals(0, realmAdapter.getRealmResults().size());
-        assertEquals(0, realmAdapter.getCount());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testGetItem() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-
-        assertEquals(resultList.get(0).getColumnString(), realmAdapter.getItem(0).getColumnString());
-        assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
-        assertEquals(resultList.last().getColumnString(), realmAdapter.getRealmResults().last().getColumnString());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testGetItemId() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-        for (int i = 0; i < resultList.size(); i++) {
-            assertEquals(i, realmAdapter.getItemId(i));
-        }
-    }
-
-    @Test
-    @UiThreadTest
-    public void testGetCount() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-        assertEquals(TEST_DATA_SIZE, realmAdapter.getCount());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testGetView() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-        View view = realmAdapter.getView(0, null, null);
-
-        TextView name = (TextView) view.findViewById(android.R.id.text1);
-
-        assertNotNull(view);
-        assertNotNull(name);
-        assertEquals(resultList.get(0).getColumnString(), name.getText());
-    }
-
-    @Test
-    public void testNullResults() {
-        RealmAdapter realmAdapter = new RealmAdapter(context, null, automaticUpdate);
-
-        assertEquals(0, realmAdapter.getCount());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testNonNullToNullResults() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
-        realmAdapter.updateRealmResults(null);
-
-        assertEquals(0, realmAdapter.getCount());
-    }
-
-    @Test
-    @UiThreadTest
-    public void testNullToNonNullResults() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(context, null, automaticUpdate);
-        realmAdapter.updateRealmResults(resultList);
-
-        assertEquals(TEST_DATA_SIZE, realmAdapter.getCount());
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 9d4a2b3726..5f8f7a13b5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -43,7 +43,6 @@
 import io.realm.instrumentation.MockActivityManager;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.internal.log.RealmLog;
-import io.realm.proxy.HandlerProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -156,9 +155,9 @@ public void execute(Realm realm) {
                 owner.setName("Owner");
             }
         });
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
                 looperThread.testComplete();
             }
@@ -297,9 +296,9 @@ public void findAllAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
-        results.addChangeListener(new RealmChangeListener() {
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(results.isLoaded());
                 assertEquals(5, results.size());
                 assertTrue(results.get(0).isValid());
@@ -381,9 +380,9 @@ public void findAllAsync_withNotification() throws Throwable {
                 .between("columnLong", 0, 4)
                 .findAllAsync();
 
-        results.addChangeListener(new RealmChangeListener() {
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(results.isLoaded());
                 assertEquals(5, results.size());
                 assertTrue(results.get(4).isValid());
@@ -407,9 +406,9 @@ public void findAllAsync_forceLoad() throws Throwable {
                 .findAllAsync();
 
         // notification should be called as well
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(realmResults.isLoaded());
                 assertEquals(5, realmResults.size());
                 looperThread.testComplete();
@@ -481,9 +480,9 @@ public boolean onInterceptInMessage(int what) {
         assertEquals(0, realmResults.size());
 
         // 6. Callback triggered after retry has completed
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(3, numberOfIntercept.get());
                 assertEquals(1, numberOfInvocation.incrementAndGet());
                 assertTrue(realmResults.isLoaded());
@@ -563,9 +562,9 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults1.isLoaded());
@@ -584,9 +583,9 @@ public void onChange() {
         });
 
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults2.isLoaded());
@@ -645,9 +644,9 @@ public boolean onInterceptInMessage(int what) {
         assertEquals(0, realmResults.size());
 
         // Add change listener that should only be called once
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(3, numberOfIntercept.get());
                 assertTrue(realmResults.isLoaded());
                 assertEquals(6, realmResults.size());
@@ -702,7 +701,7 @@ public boolean onInterceptInMessage(int what) {
             }
         };
         realm.setHandler(handler);
-        Realm.asyncQueryExecutor.pause();
+        Realm.asyncTaskExecutor.pause();
 
         // Create async queries and check they haven't completed
         final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
@@ -726,7 +725,7 @@ public void doInBackground(Realm realm) {
                 realm.commitTransaction();
             }
         }.awaitOrFail();
-        Realm.asyncQueryExecutor.resume();
+        Realm.asyncTaskExecutor.resume();
 
         // Setup change listeners
         final Runnable signalCallbackDone = new Runnable() {
@@ -741,9 +740,9 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(maxNumberOfNotificationsQuery1.getAndDecrement() > 0);
                 assertTrue(realmResults1.isLoaded());
                 assertEquals(12, realmResults1.size());
@@ -752,9 +751,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(maxNumberOfNotificationsQuery2.getAndDecrement() > 0);
                 assertTrue(realmResults2.isLoaded());
                 assertEquals(7, realmResults2.size());// the 2 add rows has columnLong == 0
@@ -779,9 +778,9 @@ public void findFirstAsync() {
         assertFalse(asyncObj.isValid());
         assertFalse(asyncObj.isLoaded());
 
-        asyncObj.addChangeListener(new RealmChangeListener() {
+        asyncObj.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertTrue(asyncObj.isLoaded());
                 assertTrue(asyncObj.isValid());
                 looperThread.testComplete();
@@ -794,9 +793,9 @@ public void onChange() {
     public void findFirstAsync_initalEmptyRow() throws Throwable {
         Realm realm = looperThread.realm;
         final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();
-        firstAsync.addChangeListener(new RealmChangeListener() {
+        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertTrue(firstAsync.load());
                 assertTrue(firstAsync.isLoaded());
                 assertTrue(firstAsync.isValid());
@@ -828,9 +827,9 @@ public void findFirstAsync_updatedIfsyncRealmObjectIsUpdated() throws Throwable
         assertEquals(0, firstAsync.getColumnLong());
         assertEquals("test data 0", firstAsync.getColumnString());
 
-        firstAsync.addChangeListener(new RealmChangeListener() {
+        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertEquals("Galacticon", firstAsync.getColumnString());
                 looperThread.testComplete();
             }
@@ -852,9 +851,9 @@ public void findFirstAsync_withNotification() throws Throwable {
                 .between("columnLong", 4, 9)
                 .findFirstAsync();
 
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertTrue(realmResults.isLoaded());
                 assertTrue(realmResults.isValid());
                 assertEquals("test data 4", realmResults.getColumnString());
@@ -945,9 +944,9 @@ public boolean onInterceptInMessage(int what) {
         }
 
         // Add change listener that should only be called once after the retry completed.
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertEquals(3, numberOfIntercept.get());
                 assertTrue(realmResults.isLoaded());
                 assertEquals(5, realmResults.getColumnLong());
@@ -975,9 +974,9 @@ public void findAllSortedAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
-        results.addChangeListener(new RealmChangeListener() {
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(results.isLoaded());
                 assertEquals(5, results.size());
                 for (int i = 0; i < 5; i++) {
@@ -1026,7 +1025,7 @@ public boolean onInterceptInMessage(int what) {
         };
         realm.setHandler(handler);
 
-        // 3. This will add a task to the paused asyncQueryExecutor
+        // 3. This will add a task to the paused asyncTaskExecutor
         final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 8)
                 .findAllSortedAsync("columnString", Sort.ASCENDING);
@@ -1037,9 +1036,9 @@ public boolean onInterceptInMessage(int what) {
         // 4. Intercepting the query completed event the first time will
         // cause a commit that should cause the findAllSortedAsync to be re-run.
         // This change listener should only be called with the final result.
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(3, numberOfIntercept.get());
                 looperThread.testComplete();
             }
@@ -1130,9 +1129,9 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
                     case 1: { // first callback invocation
                         assertTrue(realmResults1.isLoaded());
@@ -1151,9 +1150,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
                     case 1: { // first callback invocation
                         assertTrue(realmResults2.isLoaded());
@@ -1271,9 +1270,9 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults1.isLoaded());
@@ -1320,9 +1319,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults2.isLoaded());
@@ -1411,21 +1410,21 @@ public void listenerShouldNotLeak() {
     public void combiningAsyncAndSync() {
         populateTestRealm(looperThread.realm, 10);
 
-        Realm.asyncQueryExecutor.pause();
+        Realm.asyncTaskExecutor.pause();
         final RealmResults<AllTypes> allTypesAsync = looperThread.realm.where(AllTypes.class).greaterThan("columnLong", 5).findAllAsync();
         final RealmResults<AllTypes> allTypesSync = allTypesAsync.where().greaterThan("columnLong", 3).findAll();
 
         assertEquals(0, allTypesAsync.size());
         assertEquals(6, allTypesSync.size());
-        allTypesAsync.addChangeListener(new RealmChangeListener() {
+        allTypesAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(4, allTypesAsync.size());
                 assertEquals(6, allTypesSync.size());
                 looperThread.testComplete();
             }
         });
-        Realm.asyncQueryExecutor.resume();
+        Realm.asyncTaskExecutor.resume();
         looperThread.keepStrongReference.add(allTypesAsync);
     }
 
@@ -1438,6 +1437,7 @@ public void stressTestBackgroundCommits() throws Throwable {
         final CountDownLatch bgRealmClosed = new CountDownLatch(1);
         final long[] latestLongValue = new long[1];
         final float[] latestFloatValue = new float[1];
+
         // start a background thread that pushes a commit every 16ms
         final Thread backgroundThread = new Thread() {
             @Override
@@ -1462,9 +1462,9 @@ public void run() {
         };
 
         final RealmResults<AllTypes> allAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
-        allAsync.addChangeListener(new RealmChangeListener() {
+        allAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(allAsync.isLoaded());
                 if (allAsync.size() == NUMBER_OF_COMMITS) {
                     AllTypes lastInserted = looperThread.realm.where(AllTypes.class)
@@ -1526,33 +1526,33 @@ public void run() {
             }
         };
 
-        distinctBool.addChangeListener(new RealmChangeListener() {
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(2, distinctBool.size());
                 changeListenerDone.run();
             }
         });
 
-        distinctLong.addChangeListener(new RealmChangeListener() {
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctLong.size());
                 changeListenerDone.run();
             }
         });
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctDate.size());
                 changeListenerDone.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctString.size());
                 changeListenerDone.run();
             }
@@ -1630,9 +1630,9 @@ public void batchUpdateDifferentTypeOfQueries() {
         final AtomicInteger findAllSortedMultiInvocation = new AtomicInteger(0);
         final AtomicInteger findDistinctInvocation = new AtomicInteger(0);
 
-        findAllAsync.addChangeListener(new RealmChangeListener() {
+        findAllAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (findAllAsyncInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1648,9 +1648,9 @@ public void onChange() {
             }
         });
 
-        findAllSorted.addChangeListener(new RealmChangeListener() {
+        findAllSorted.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (findAllSortedInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1666,9 +1666,9 @@ public void onChange() {
             }
         });
 
-        findAllSortedMulti.addChangeListener(new RealmChangeListener() {
+        findAllSortedMulti.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (findAllSortedMultiInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1684,9 +1684,9 @@ public void onChange() {
             }
         });
 
-        findDistinct.addChangeListener(new RealmChangeListener() {
+        findDistinct.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 switch (findDistinctInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1733,9 +1733,9 @@ public void queryingLinkHandover() throws Throwable {
         final Realm realm = looperThread.realm;
 
         final RealmResults<Dog> allAsync = realm.where(Dog.class).equalTo("owner.name", "kiba").findAllAsync();
-        allAsync.addChangeListener(new RealmChangeListener() {
+        allAsync.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 switch (numberOfInvocations.incrementAndGet()) {
                     case 1:
                         assertEquals(0, allAsync.size());
@@ -1789,12 +1789,12 @@ public void testFindFirstUsesCallerThreadVersion() throws Throwable {
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
 
         populateTestRealm(looperThread.realm, 10);
-        Realm.asyncQueryExecutor.pause();
+        Realm.asyncTaskExecutor.pause();
 
         final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
-        firstAsync.addChangeListener(new RealmChangeListener() {
+        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertNotNull(firstAsync);
                 assertEquals("test data 0", firstAsync.getColumnString());
                 looperThread.testComplete(signalClosedRealm);
@@ -1809,7 +1809,7 @@ public void run() {
                 // Advancing the Realm without generating notifications
                 bgRealm.sharedGroupManager.promoteToWrite();
                 bgRealm.sharedGroupManager.commitAndContinueAsRead();
-                Realm.asyncQueryExecutor.resume();
+                Realm.asyncTaskExecutor.resume();
                 bgRealm.close();
                 signalClosedRealm.countDown();
             }
@@ -1925,9 +1925,9 @@ public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAcc
 
         // 1. Make sure that async query is not started
         final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
-        result.addChangeListener(new RealmChangeListener() {
+        result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 // 4. The commit in #2, should result in a refresh being triggered, which means this callback will
                 // be notified once the updated async queries has run.
                 // with the correct
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
new file mode 100644
index 0000000000..4778fbe2e9
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.rule.UiThreadTestRule;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.pojo.AllTypesRealmModel;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmChangeListenerTests {
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+    private RealmConfiguration realmConfig;
+
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmIsNotNull() {
+        Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm realm) {
+                assertNotNull(realm);
+                assertFalse(realm.isClosed());
+                looperThread.testComplete();
+            }
+        });
+        realm.beginTransaction();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedDynamicRealmIsNotNull() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        dynamicRealm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
+            @Override
+            public void onChange(DynamicRealm dynRealm) {
+                assertNotNull(dynRealm);
+                assertFalse(dynRealm.isClosed());
+                dynRealm.close();
+                looperThread.testComplete();
+            }
+        });
+        dynamicRealm.beginTransaction();
+        dynamicRealm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmResultsIsNotNull() {
+        Realm realm = looperThread.realm;
+        RealmResults<Cat> cats = realm.where(Cat.class).findAll();
+        cats.addChangeListener(new RealmChangeListener<RealmResults<Cat>>() {
+            @Override
+            public void onChange(RealmResults<Cat> result) {
+                assertEquals("cat1", result.first().getName());
+                looperThread.testComplete();
+            }
+        });
+        realm.beginTransaction();
+        Cat cat = realm.createObject(Cat.class);
+        cat.setName("cat1");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmResultsOfModelIsNotNull() {
+        Realm realm = looperThread.realm;
+        RealmResults<AllTypesRealmModel> alltypes = realm.where(AllTypesRealmModel.class).findAll();
+        alltypes.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
+            @Override
+            public void onChange(RealmResults<AllTypesRealmModel> result) {
+                assertEquals("data 1", result.first().columnString);
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        model.columnString = "data 1";
+        realm.commitTransaction();
+    }
+
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmObjectIsNotNull() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        Cat cat = looperThread.realm.createObject(Cat.class);
+        realm.commitTransaction();
+
+        cat.addChangeListener(new RealmChangeListener<Cat>() {
+            @Override
+            public void onChange(Cat object) {
+                assertEquals("cat1", object.getName());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        cat.setName("cat1");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmModelIsNotNull() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        realm.commitTransaction();
+
+        RealmObject.addChangeListener(model, new RealmChangeListener<AllTypesRealmModel>() {
+            @Override
+            public void onChange(AllTypesRealmModel object) {
+                assertEquals("model1", object.columnString);
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        model.columnString = "model1";
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedDynamicRealmObjectIsNotNull() {
+        Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+        realm.close();
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+
+        allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
+            @Override
+            public void onChange(DynamicRealmObject object) {
+                assertEquals("test data 1", object.getString(AllTypes.FIELD_STRING));
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+        dynamicRealm.beginTransaction();
+        allTypes.setString(AllTypes.FIELD_STRING, "test data 1");
+        dynamicRealm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedDynamicRealmResultsIsNotNull() {
+        Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+        realm.close();
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        RealmResults<DynamicRealmObject> all = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        all.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
+            @Override
+            public void onChange(RealmResults<DynamicRealmObject> result) {
+                assertEquals("test data 1", result.first().getString(AllTypes.FIELD_STRING));
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        allTypes.setString(AllTypes.FIELD_STRING, "test data 1");
+        dynamicRealm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index 7669919f01..b240f6caab 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm;
 
 import org.junit.After;
@@ -91,6 +107,11 @@ public void setup() {
         collection = createCollection(collectionClass);
     }
 
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+    
     private RealmCollection<AllJavaTypes> createCollection(CollectionClass collectionClass) {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
@@ -130,12 +151,6 @@ public void setup() {
         throw new AssertionError("Unknown collection: " + collectionClass);
     }
 
-
-    @After
-    public void tearDown() {
-        realm.close();
-    }
-
     @Test
     public void contains() {
         AllJavaTypes obj = collection.iterator().next();
@@ -229,4 +244,5 @@ public void toArray_inputArray() {
         assertEquals(TEST_SIZE, array.length);
         assertEquals(collection.iterator().next(), array[0]);
     }
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 87e4106c42..a9a8a11f40 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -258,23 +258,23 @@ public void migration_nullThrows() {
     public void setModules_nonRealmModulesThrows() {
         // Test first argument
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).setModules(new Object());
+            new RealmConfiguration.Builder(configFactory.getRoot()).modules(new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Test second argument
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).setModules(Realm.getDefaultModule(), new Object());
+            new RealmConfiguration.Builder(configFactory.getRoot()).modules(Realm.getDefaultModule(), new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
-    public void setModules() {
+    public void modules() {
         RealmConfiguration realmConfig = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(Realm.getDefaultModule(), (Object) null).build();
+                .modules(Realm.getDefaultModule(), (Object) null).build();
         realm = Realm.getInstance(realmConfig);
         assertNotNull(realm.getTable(AllTypes.class));
     }
@@ -381,11 +381,11 @@ public void hashCode_Test() {
     @Test
     public void equals_withCustomModules() {
         RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(new HumanModule(), new AnimalModule())
+                .modules(new HumanModule(), new AnimalModule())
                 .build();
 
         RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(new AnimalModule(), new HumanModule())
+                .modules(new AnimalModule(), new HumanModule())
                 .build();
 
         assertTrue(config1.equals(config2));
@@ -394,10 +394,10 @@ public void equals_withCustomModules() {
     @Test
     public void hashCode_withCustomModules() {
         RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(new HumanModule(), new AnimalModule())
+                .modules(new HumanModule(), new AnimalModule())
                 .build();
         RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(new AnimalModule(), new HumanModule())
+                .modules(new AnimalModule(), new HumanModule())
                 .build();
 
         assertEquals(config1.hashCode(), config2.hashCode());
@@ -543,7 +543,7 @@ public void encryptionKey_keyStorage() throws Exception {
     public void modelClassesForDefaultMediator() throws Exception {
         assertTrue(defaultConfig.getSchemaMediator() instanceof DefaultRealmModuleMediator);
 
-        final Set<Class<? extends RealmObject>> realmClasses = defaultConfig.getRealmObjectClasses();
+        final Set<Class<? extends RealmModel>> realmClasses = defaultConfig.getRealmObjectClasses();
 
         assertTrue(realmClasses.contains(AllTypes.class));
 
@@ -558,10 +558,10 @@ public void modelClassesForDefaultMediator() throws Exception {
     @Test
     public void modelClasses_forGeneratedMediator() throws Exception {
         final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(new HumanModule()).build();
+                .modules(new HumanModule()).build();
         assertTrue(config.getSchemaMediator() instanceof HumanModuleMediator);
 
-        final Set<Class<? extends RealmObject>> realmClasses = config.getRealmObjectClasses();
+        final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
 
         assertFalse(realmClasses.contains(AllTypes.class));
         assertTrue(realmClasses.contains(CatOwner.class));
@@ -578,10 +578,10 @@ public void modelClasses_forGeneratedMediator() throws Exception {
     @Test
     public void modelClasses_forCompositeMediator() throws Exception {
         final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .setModules(new HumanModule(), new AnimalModule()).build();
+                .modules(new HumanModule(), new AnimalModule()).build();
         assertTrue(config.getSchemaMediator() instanceof CompositeMediator);
 
-        final Set<Class<? extends RealmObject>> realmClasses = config.getRealmObjectClasses();
+        final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
 
         assertFalse(realmClasses.contains(AllTypes.class));
         assertTrue(realmClasses.contains(CatOwner.class));
@@ -602,7 +602,7 @@ public void modelClasses_forFilterableMediator() throws Exception {
                 .schema(AllTypes.class, CatOwner.class).build();
         assertTrue(config.getSchemaMediator() instanceof FilterableMediator);
 
-        final Set<Class<? extends RealmObject>> realmClasses = config.getRealmObjectClasses();
+        final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
 
         assertTrue(realmClasses.contains(AllTypes.class));
         assertTrue(realmClasses.contains(CatOwner.class));
@@ -630,7 +630,7 @@ public void rxFactory() {
             }
 
             @Override
-            public <E extends RealmObject> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
+            public <E extends RealmModel> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
                 return null;
             }
 
@@ -640,7 +640,7 @@ public void rxFactory() {
             }
 
             @Override
-            public <E extends RealmObject> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+            public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
                 return null;
             }
 
@@ -650,7 +650,7 @@ public void rxFactory() {
             }
 
             @Override
-            public <E extends RealmObject> Observable<E> from(Realm realm, E object) {
+            public <E extends RealmModel> Observable<E> from(Realm realm, E object) {
                 return null;
             }
 
@@ -660,7 +660,7 @@ public void rxFactory() {
             }
 
             @Override
-            public <E extends RealmObject> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+            public <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
                 return null;
             }
 
@@ -779,4 +779,27 @@ public void initialDataTransactionAssetFile() throws IOException {
         realm.close();
         verify(transaction, never()).execute(realm);
     }
+
+    private static class MigrationWithNoEquals implements RealmMigration {
+        @Override
+        public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+            // Do nothing
+        }
+    }
+
+    @Test
+    public void detectMissingEqualsInCustomMigration() {
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().migration(new MigrationWithNoEquals()).build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().migration(new MigrationWithNoEquals()).build();
+
+        Realm realm = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("The most likely cause is that equals() and hashCode() are not overridden"));
+        } finally {
+            realm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
new file mode 100644
index 0000000000..81846cd202
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.objectid.NullPrimaryKey;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(Parameterized.class)
+public class RealmJsonNullPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    // parameters for testing null primary key value. PrimaryKey field is explicitly null or absent.
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+             {"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedByte.class}
+            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj",  PrimaryKeyAsBoxedShort.class}
+            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedInteger.class}
+            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedLong.class}
+            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedByte.class}
+            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj",  PrimaryKeyAsBoxedShort.class}
+            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedInteger.class}
+            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedLong.class}
+            ,{"{ \"name\":null, \"id\":4299214 }", "4299214", PrimaryKeyAsString.class}
+            ,{"{ \"id\":4299214 }", "4299214", PrimaryKeyAsString.class}
+        });
+    }
+
+    final private String jsonString;
+    final private String secondaryFieldValue;
+    final private Class<? extends RealmObject> clazz;
+
+    public RealmJsonNullPrimaryKeyTests(String jsonString, String secondFieldValue, Class<? extends RealmObject> clazz) {
+        this.jsonString = jsonString;
+        this.secondaryFieldValue = secondFieldValue;
+        this.clazz = clazz;
+    }
+
+    // Testing null or absent primary key value for createObjectFromJson()
+    @Test
+    public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        realm.createObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+
+        // PrimaryKeyAsString
+        if (clazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            assertEquals(1, results.size());
+            assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
+            assertEquals(null, results.first().getName());
+
+        // PrimaryKeyAsNumber
+        } else {
+            RealmResults results = realm.allObjects(clazz);
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey)results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
+        }
+    }
+
+    // Testing null or absent primary key value for createOrUpdateObjectFromJson()
+    @Test
+    public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+
+        // PrimaryKeyAsString
+        if (clazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            assertEquals(1, results.size());
+            assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
+            assertEquals(null, results.first().getName());
+
+        // PrimaryKeyAsNumber
+        } else {
+            RealmResults results = realm.allObjects(clazz);
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey)results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
+        }
+    }
+
+    // Testing null or absent primary key value for createObject() -> createOrUpdateObjectFromJson()
+    @Test
+    public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        realm.createObject(clazz); // name = null, id = 0
+        realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+
+        // PrimaryKeyAsString
+        if (clazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            assertEquals(1, results.size());
+            assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
+            assertEquals(null, results.first().getName());
+
+        // PrimaryKeyAsNumber
+        } else {
+            RealmResults results = realm.allObjects(clazz);
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey)results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 1d44baa256..7183dcba20 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -246,10 +246,10 @@ public void createObjectFromJson_dateAsStringTimeZone() throws JSONException {
         Calendar cal = GregorianCalendar.getInstance();
         cal.setTimeZone(TimeZone.getTimeZone("Australia/West"));
         cal.set(2015, Calendar.OCTOBER, 03, 14, 45, 33);
-        cal.set(Calendar.MILLISECOND, 0);
+        cal.set(Calendar.MILLISECOND, 376);
         Date convDate = obj.getColumnDate();
 
-        assertEquals(convDate.getTime(), cal.getTime().getTime());
+        assertEquals(convDate.getTime(), cal.getTimeInMillis());
     }
 
     @Test
@@ -532,12 +532,10 @@ public void createObjectFromJson_streamDateAsISO8601String() throws IOException
         cal.setTimeZone(TimeZone.getTimeZone("GMT"));
         cal.set(Calendar.MILLISECOND, 789);
         Date date = cal.getTime();
-        cal.set(Calendar.MILLISECOND, 0);
-        Date dateZeroMillis = cal.getTime();
 
         // Check that all primitive types are imported correctly
         AllTypes obj = realm.allObjects(AllTypes.class).first();
-        assertEquals(dateZeroMillis, obj.getColumnDate());
+        assertEquals(date, obj.getColumnDate());
     }
 
     @Test
@@ -1171,71 +1169,90 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(0));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 2 Bytes
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(1));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 3 Boolean
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(2));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 4 Byte
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(3));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 5 Short
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(4));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 6 Integer
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(5));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 7 Long
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(6));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 8 Float
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(7));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 9 Double
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(8));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
+
         // 10 Date
         try {
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(9));
             fail();
-        } catch (RealmException expected) {
-            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        } catch (IllegalArgumentException ignored) {
+        } catch (Exception e) {
+            fail("Unexpected exception: " + e);
         }
 
         realm.cancelTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 355468db5c..d049d3dc8a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -36,6 +36,7 @@
 import io.realm.entities.CyclicTypePrimaryKey;
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -656,10 +657,10 @@ public void toString_AfterContainerObjectRemoved() {
     public void toString_managedMode() {
         StringBuilder sb = new StringBuilder("Dog@[");
         for (int i = 0; i < collection.size() - 1; i++) {
-            sb.append(collection.get(i).row.getIndex());
+            sb.append(((RealmObjectProxy) (collection.get(i))).realmGet$proxyState().getRow$realm().getIndex());
             sb.append(",");
         }
-        sb.append(collection.get(TEST_SIZE - 1).row.getIndex());
+        sb.append(((RealmObjectProxy)collection.get(TEST_SIZE - 1)).realmGet$proxyState().getRow$realm().getIndex());
         sb.append("]");
 
         assertEquals(sb.toString(), collection.toString());
@@ -970,4 +971,5 @@ public void add_set_dynamicObjectCreatedFromTypedRealm() {
         dynamicRealm.cancelTransaction();
         dynamicRealm.close();
     }
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 5294936414..b90e014ccd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -31,12 +31,20 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.Date;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationTypes;
 import io.realm.entities.FieldOrder;
 import io.realm.entities.NullTypes;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsByte;
+import io.realm.entities.PrimaryKeyAsInteger;
 import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -221,22 +229,19 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     // adding search index is idempotent
     @Test
     public void addingSearchIndexTwice() throws IOException {
-        Class[] classes = {PrimaryKeyAsLong.class, PrimaryKeyAsString.class};
+        final Class[] classes = {PrimaryKeyAsLong.class, PrimaryKeyAsString.class};
 
-        for (final Class clazz : classes){
-            final boolean[] didMigrate = {false};
+        for (final Class clazz : classes) {
+            final AtomicBoolean didMigrate = new AtomicBoolean(false);
 
             RealmMigration migration = new RealmMigration() {
                 @Override
                 public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                    Table table = realm.schema.getTable(clazz);
-                    long columnIndex = table.getColumnIndex("id");
-                    table.addSearchIndex(columnIndex);
-                    if (clazz == PrimaryKeyAsLong.class) {
-                        columnIndex = table.getColumnIndex("name");
-                        table.convertColumnToNullable(columnIndex);
-                    }
-                    didMigrate[0] = true;
+                    RealmObjectSchema schema = realm.getSchema().getSchemaForClass(clazz.getSimpleName());
+                    schema.addIndex("id");
+                    // @PrimaryKey fields in PrimaryKeyAsLong and PrimaryKeyAsString.class should be set 'nullable'.
+                    schema.setNullable("name", true);
+                    didMigrate.set(true);
                 }
             };
             RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
@@ -245,12 +250,11 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                     .migration(migration)
                     .build();
             Realm.deleteRealm(realmConfig);
-            configFactory.copyRealmFromAssets(context,
-                    "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+            configFactory.copyRealmFromAssets(context, "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
             Realm.migrateRealm(realmConfig);
             realm = Realm.getInstance(realmConfig);
             assertEquals(42, realm.getVersion());
-            assertTrue(didMigrate[0]);
+            assertTrue(didMigrate.get());
             Table table = realm.getTable(clazz);
             assertEquals(true, table.hasSearchIndex(table.getColumnIndex("id")));
             realm.close();
@@ -340,7 +344,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm.close();
             fail();
         } catch (RealmMigrationNeededException e) {
-            assertEquals("Field 'chars' is required. Either set @Required to field 'chars' or migrate using io.realm.internal.Table.convertColumnToNullable().",
+            assertEquals("Field 'chars' is required. Either set @Required to field 'chars' or migrate using RealmObjectSchema.setNullable().",
                     e.getMessage());
         }
     }
@@ -461,7 +465,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             } catch (RealmMigrationNeededException e) {
                 assertEquals("Field '" + field + "' does support null values in the existing Realm file." +
                         " Remove @Required or @PrimaryKey from field '" + field + "' " +
-                        "or migrate using io.realm.internal.Table.convertColumnToNotNullable().",
+                        "or migrate using RealmObjectSchema.setNullable().",
                         e.getMessage());
             }
         }
@@ -531,16 +535,115 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                         field.equals(NullTypes.FIELD_DATE_NULL)) {
                     assertEquals("Field '" + field + "' is required. Either set @Required to field '" +
                             field + "' " +
-                            "or migrate using io.realm.internal.Table.convertColumnToNullable().", e.getMessage());
+                            "or migrate using RealmObjectSchema.setNullable().", e.getMessage());
                 } else {
                     assertEquals("Field '" + field + "' does not support null values in the existing Realm file."
                                     + " Either set @Required, use the primitive type for field '"
-                                    + field + "' or migrate using io.realm.internal.Table.convertColumnToNullable().",  e.getMessage());
+                                    + field + "' or migrate using RealmObjectSchema.setNullable().",  e.getMessage());
+                }
+            }
+        }
+    }
+
+    // Testing older Realms for setting Boxed type primary keys fields nullable in migration process to support Realm Version 0.89+
+    @Test
+    public void settingNullableToPrimaryKey() throws IOException {
+        final long SCHEMA_VERSION = 67;
+        final Class[] classes = {PrimaryKeyAsBoxedByte.class, PrimaryKeyAsBoxedShort.class, PrimaryKeyAsBoxedInteger.class, PrimaryKeyAsBoxedLong.class, PrimaryKeyAsString.class};
+        for (final Class clazz : classes) {
+            final AtomicBoolean didMigrate = new AtomicBoolean(false);
+            RealmMigration migration = new RealmMigration() {
+                @Override
+                public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    RealmObjectSchema schema = realm.getSchema().getSchemaForClass(clazz.getSimpleName());
+                    if (clazz == PrimaryKeyAsString.class) {
+                        schema.setNullable("name", true);
+                    } else {
+                        schema.setNullable("id", true);
+                    }
+                    didMigrate.set(true);
+                }
+            };
+            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                    .schemaVersion(SCHEMA_VERSION)
+                    .schema(clazz)
+                    .migration(migration)
+                    .build();
+            Realm.deleteRealm(realmConfig);
+            configFactory.copyRealmFromAssets(context, "default-notnullable-primarykey.realm", Realm.DEFAULT_REALM_NAME);
+            Realm.migrateRealm(realmConfig);
+            realm = Realm.getInstance(realmConfig);
+            RealmObjectSchema schema = realm.getSchema().getSchemaForClass(clazz);
+            assertEquals(SCHEMA_VERSION, realm.getVersion());
+            assertTrue(didMigrate.get());
+            if (clazz == PrimaryKeyAsString.class) {
+                assertEquals(true, schema.isNullable(PrimaryKeyAsString.FIELD_PRIMARY_KEY));
+            } else {
+                assertEquals(true, schema.isNullable("id"));
+            }
+            realm.close();
+        }
+    }
+
+    // Not-setting older boxed type PrimaryKey field nullable to see if migration fails in order to support Realm version 0.89+
+    @Test
+    public void notSettingNullableToPrimaryKeyThrows() throws IOException {
+        configFactory.copyRealmFromAssets(context, "default-notnullable-primarykey.realm", Realm.DEFAULT_REALM_NAME);
+        final Class[] classes = {PrimaryKeyAsString.class, PrimaryKeyAsBoxedByte.class, PrimaryKeyAsBoxedShort.class, PrimaryKeyAsBoxedInteger.class, PrimaryKeyAsBoxedLong.class};
+        for (final Class clazz : classes) {
+            try {
+                RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                        .schemaVersion(0)
+                        .schema(clazz)
+                        .migration(new RealmMigration() {
+                            @Override
+                            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                                // intentionally left empty to preserve not-nullablility of PrimaryKey on old schema.
+                            }
+                        })
+                        .build();
+                Realm realm = Realm.getInstance(realmConfig);
+                realm.close();
+                fail();
+            } catch (RealmMigrationNeededException expected) {
+                if (clazz == PrimaryKeyAsString.class) {
+                    assertEquals("@PrimaryKey field 'name' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.",
+                            expected.getMessage());
+                } else {
+                    assertEquals("@PrimaryKey field 'id' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.",
+                            expected.getMessage());
                 }
             }
         }
     }
 
+    // Migrate a nullable field containing null value to non-nullable PrimaryKey field throws Realm version 0.89+
+    @Test
+    public void migrating_nullableField_toward_notNullable_PrimaryKeyThrows() throws IOException {
+        configFactory.copyRealmFromAssets(context, "default-nullable-primarykey.realm", Realm.DEFAULT_REALM_NAME);
+        final Class[] classes = {PrimaryKeyAsByte.class, PrimaryKeyAsShort.class, PrimaryKeyAsInteger.class, PrimaryKeyAsLong.class};
+        for (final Class clazz : classes) {
+            try {
+                RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                        .schemaVersion(0)
+                        .schema(clazz)
+                        .migration(new RealmMigration() {
+                            @Override
+                            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                                // intentionally left empty to demonstrate incompatibilities between nullable/not-nullable PrimaryKeys.
+                            }
+                        })
+                        .build();
+                Realm realm = Realm.getInstance(realmConfig);
+                realm.close();
+                fail();
+            } catch (IllegalStateException expected) {
+                assertEquals("Cannot migrate an object with null value in field 'id'. Either maintain the same type for primary key field 'id', or remove the object with null value before migration.",
+                        expected.getMessage());
+            }
+        }
+    }
+
     @Test
     public void realmOpenBeforeMigrationThrows() throws FileNotFoundException {
         RealmConfiguration config = configFactory.createConfiguration();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
new file mode 100644
index 0000000000..a3ce3221ab
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -0,0 +1,382 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.util.Date;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.pojo.AllTypesRealmModel;
+import io.realm.entities.pojo.InvalidRealmModel;
+import io.realm.entities.pojo.RealmModelWithRealmListOfRealmModel;
+import io.realm.entities.pojo.PojoWithRealmListOfRealmObject;
+import io.realm.entities.pojo.RealmModelWithRealmModelField;
+import io.realm.entities.pojo.RealmObjectWithRealmListOfRealmModel;
+import io.realm.entities.pojo.RealmObjectWithRealmModelField;
+import io.realm.exceptions.RealmException;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+// tests API methods when using a model class implementing RealmModel instead
+// of extending RealmObject.
+@RunWith(AndroidJUnit4.class)
+public class RealmModelTests {
+    private final static int TEST_DATA_SIZE = 10;
+
+    private Context context;
+    private Realm realm;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Before
+    public void setUp() {
+        // Injecting the Instrumentation instance is required
+        // for your test to run with AndroidJUnitRunner.
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private void populateTestRealm(Realm realm, int objects) {
+        realm.beginTransaction();
+        realm.delete(AllTypesRealmModel.class);
+        for (int i = 0; i < objects; ++i) {
+            AllTypesRealmModel allTypes = new AllTypesRealmModel();
+            allTypes.columnLong = i;
+            allTypes.columnBoolean = (i % 3) == 0;
+            allTypes.columnBinary = new byte[]{1, 2, 3};
+            allTypes.columnDate = new Date();
+            allTypes.columnDouble = 3.1415 + i;
+            allTypes.columnFloat = 1.234567f;
+            allTypes.columnString = "test data ";
+            allTypes.columnByte = 0b0010_1010;
+            realm.copyToRealm(allTypes);
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void createObject() {
+        for (int i = 1; i < 43; i++) { // using i = 0 as PK will crash subsequent createObject
+                                       // since createObject uses default values
+            realm.beginTransaction();
+            AllTypesRealmModel allTypesRealmModel = realm.createObject(AllTypesRealmModel.class);
+            allTypesRealmModel.columnLong = i;
+            realm.commitTransaction();
+        }
+
+        RealmResults<AllTypesRealmModel> resultList = realm.allObjects(AllTypesRealmModel.class);
+        assertEquals("Realm.get is returning wrong result set", 42, resultList.size());
+    }
+
+    @Test
+    public void copyToRealm() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        RealmResults<AllTypesRealmModel> resultList = realm.allObjects(AllTypesRealmModel.class);
+        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
+    }
+
+
+    @Test
+    public void copyFromRealm() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+
+        AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class).findAllSorted(AllTypesRealmModel.FIELD_LONG).first();
+        AllTypesRealmModel standaloneObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.columnBinary, standaloneObject.columnBinary);
+        assertEquals(realmObject.columnString, standaloneObject.columnString);
+        assertEquals(realmObject.columnLong, standaloneObject.columnLong);
+        assertEquals(realmObject.columnFloat, standaloneObject.columnFloat, 0.00000000001);
+        assertEquals(realmObject.columnDouble, standaloneObject.columnDouble, 0.00000000001);
+        assertEquals(realmObject.columnBoolean, standaloneObject.columnBoolean);
+        assertEquals(realmObject.columnDate, standaloneObject.columnDate);
+        assertEquals(realmObject.hashCode(), standaloneObject.hashCode());
+
+    }
+
+    @Test
+    public void copyToRealmOrUpdate() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypesRealmModel obj = new AllTypesRealmModel();
+                obj.columnLong = 1;
+                realm.copyToRealm(obj);
+
+                AllTypesRealmModel obj2 = new AllTypesRealmModel();
+                obj2.columnLong = 1;
+                obj2.columnString = "Foo";
+                realm.copyToRealmOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(1, realm.allObjects(AllTypesRealmModel.class).size());
+
+        AllTypesRealmModel obj = realm.allObjects(AllTypesRealmModel.class).first();
+        assertEquals("Foo", obj.columnString);
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson() throws IOException {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesRealmModel.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(AllTypesRealmModel.class).size());
+        AllTypesRealmModel obj = realm.allObjects(AllTypesRealmModel.class).first();
+        assertEquals("Bar", obj.columnString);
+        assertEquals(2.23F, obj.columnFloat, 0.000000001);
+        assertEquals(2.234D, obj.columnDouble, 0.000000001);
+        assertEquals(true, obj.columnBoolean);
+        assertArrayEquals(new byte[]{1, 2, 3}, obj.columnBinary);
+        assertEquals(new Date(2000), obj.columnDate);
+        assertEquals("Dog4", obj.columnRealmObject.getName());
+        assertEquals(2, obj.columnRealmList.size());
+        assertEquals("Dog5", obj.columnRealmList.get(0).getName());
+    }
+
+    // where with filed selection
+    @Test
+    public void query() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+
+        assertEquals(5, realm.where(AllTypesRealmModel.class).greaterThanOrEqualTo(AllTypesRealmModel.FIELD_DOUBLE, 8.1415).count());
+    }
+
+    // async where with filed selection
+    @Test
+    @RunTestInLooperThread
+    public void async_query() {
+        populateTestRealm(looperThread.realm, TEST_DATA_SIZE);
+
+        final RealmResults<AllTypesRealmModel> allTypesRealmModels = looperThread.realm.distinctAsync(AllTypesRealmModel.class, AllTypesRealmModel.FIELD_STRING);
+        allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
+            @Override
+            public void onChange(RealmResults<AllTypesRealmModel> object) {
+                assertEquals(1, allTypesRealmModels.size());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    public void dynamicObject() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+
+        AllTypesRealmModel typedObj = realm.allObjects(AllTypesRealmModel.class).first();
+        DynamicRealmObject dObj = new DynamicRealmObject(typedObj);
+
+        realm.beginTransaction();
+        dObj.setLong(AllTypesRealmModel.FIELD_LONG, 42L);
+        assertEquals(42, dObj.getLong(AllTypesRealmModel.FIELD_LONG));
+        assertEquals(42, typedObj.columnLong);
+
+        dObj.setBlob(AllTypesRealmModel.FIELD_BINARY, new byte[]{1, 2, 3});
+        Assert.assertArrayEquals(new byte[]{1, 2, 3}, dObj.getBlob(AllTypesRealmModel.FIELD_BINARY));
+        Assert.assertArrayEquals(new byte[]{1, 2, 3}, typedObj.columnBinary);
+        realm.cancelTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealm() {
+        populateTestRealm(looperThread.realm, TEST_DATA_SIZE);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject dog = dynamicRealm.createObject(AllTypesRealmModel.CLASS_NAME, 42);
+        assertEquals(42, dog.getLong(AllTypesRealmModel.FIELD_LONG));
+        dynamicRealm.commitTransaction();
+
+        RealmResults<DynamicRealmObject> allAsync = dynamicRealm.where(AllTypesRealmModel.CLASS_NAME).equalTo(AllTypesRealmModel.FIELD_LONG, 42).findAll();
+        allAsync.load();
+        assertTrue(allAsync.isLoaded());
+        assertEquals(1, allAsync.size());
+
+        dynamicRealm.beginTransaction();
+        allAsync.deleteAllFromRealm();
+        dynamicRealm.commitTransaction();
+
+        RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypesRealmModel.CLASS_NAME).findAll();
+        assertEquals(TEST_DATA_SIZE, results.size());
+        for (int i = 0; i < TEST_DATA_SIZE; i++) {
+            assertEquals(3.1415 + i, results.get(i).getDouble(AllTypesRealmModel.FIELD_DOUBLE), 0.0000001);
+            assertEquals((i % 3) == 0, results.get(i).getBoolean(AllTypesRealmModel.FIELD_BOOLEAN));
+        }
+        dynamicRealm.close();
+        looperThread.testComplete();
+    }
+
+    // exception expected when using in schema model not annotated
+    // a valid model need to implement the interface RealmModel and annotate the class with @RealmClass
+    // we expect in this test a runtime exception 'InvalidRealmModel is not part of the schema for this Realm.'
+    @Test(expected = RealmException.class)
+    public void invalidModelDefinition() {
+        realm.beginTransaction();
+        realm.createObject(InvalidRealmModel.class);
+        realm.commitTransaction();
+    }
+
+    // Test the behaviour of a RealmModel, containing a RealmList
+    // of other RealmModel, in managed and un-managed mode
+    @Test
+    public void realmModelWithRealmListOfRealmModel() {
+        RealmList<AllTypesRealmModel> allTypesRealmModels = new RealmList<AllTypesRealmModel>();
+        AllTypesRealmModel allTypePojo;
+        for (int i = 0; i < 10; i++) {
+            allTypePojo = new AllTypesRealmModel();
+            allTypePojo.columnLong = i;
+            allTypesRealmModels.add(allTypePojo);
+        }
+        AllTypesRealmModel pojo1 = allTypesRealmModels.get(1);
+        assertEquals(1, pojo1.columnLong);
+        allTypesRealmModels.move(1, 0);
+        assertEquals(0, allTypesRealmModels.indexOf(pojo1));
+
+        RealmModelWithRealmListOfRealmModel model = new RealmModelWithRealmListOfRealmModel();
+        model.setColumnRealmList(allTypesRealmModels);
+
+        realm.beginTransaction();
+        realm.copyToRealm(model);
+        realm.commitTransaction();
+
+        RealmResults<RealmModelWithRealmListOfRealmModel> all = realm.where(RealmModelWithRealmListOfRealmModel.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(10, all.first().getColumnRealmList().size());
+        assertEquals(1, all.first().getColumnRealmList().first().columnLong);
+    }
+
+    // Test the behaviour of a RealmModel, containing a RealmList
+    // of RealmObject, in managed and un-managed mode
+    @Test
+    public void realmModelWithRealmListOfRealmObject() {
+        RealmList<AllTypes> allTypes = new RealmList<AllTypes>();
+        AllTypes allType;
+        for (int i = 0; i < 10; i++) {
+            allType = new AllTypes();
+            allType.setColumnLong(i);
+            allTypes.add(allType);
+        }
+        AllTypes pojo1 = allTypes.get(1);
+        assertEquals(1, pojo1.getColumnLong());
+        allTypes.move(1, 0);
+        assertEquals(0, allTypes.indexOf(pojo1));
+
+        PojoWithRealmListOfRealmObject model = new PojoWithRealmListOfRealmObject();
+        model.setColumnRealmList(allTypes);
+
+        realm.beginTransaction();
+        realm.copyToRealm(model);
+        realm.commitTransaction();
+
+        RealmResults<PojoWithRealmListOfRealmObject> all = realm.where(PojoWithRealmListOfRealmObject.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(10, all.first().getColumnRealmList().size());
+        assertEquals(1, all.first().getColumnRealmList().first().getColumnLong());
+    }
+
+    // Test the behaviour of a RealmObject, containing a RealmList
+    // of RealmModel, in managed and un-managed mode
+    @Test
+    public void realmObjectWithRealmListOfRealmModel() {
+        RealmList<AllTypesRealmModel> allTypesRealmModel = new RealmList<AllTypesRealmModel>();
+        AllTypesRealmModel allTypePojo;
+        for (int i = 0; i < 10; i++) {
+            allTypePojo = new AllTypesRealmModel();
+            allTypePojo.columnLong = i;
+            allTypesRealmModel.add(allTypePojo);
+        }
+        AllTypesRealmModel pojo1 = allTypesRealmModel.get(1);
+        assertEquals(1, pojo1.columnLong);
+        allTypesRealmModel.move(1, 0);
+        assertEquals(0, allTypesRealmModel.indexOf(pojo1));
+
+        RealmObjectWithRealmListOfRealmModel model = new RealmObjectWithRealmListOfRealmModel();
+        model.setColumnRealmList(allTypesRealmModel);
+
+        realm.beginTransaction();
+        realm.copyToRealm(model);
+        realm.commitTransaction();
+
+        RealmResults<RealmObjectWithRealmListOfRealmModel> all = realm.where(RealmObjectWithRealmListOfRealmModel.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(10, all.first().getColumnRealmList().size());
+        assertEquals(1, all.first().getColumnRealmList().first().columnLong);
+    }
+
+    // Test the behaviour of a RealmModel, containing a RealmModel field
+    @Test
+    public void realmModelWithRealmModelField() {
+        RealmModelWithRealmModelField realmModelWithRealmModelField = new RealmModelWithRealmModelField();
+        AllTypesRealmModel allTypePojo = new AllTypesRealmModel();
+        allTypePojo.columnLong = 42;
+        realmModelWithRealmModelField.setAllTypesRealmModel(allTypePojo);
+
+        realm.beginTransaction();
+        realm.copyToRealm(realmModelWithRealmModelField);
+        realm.commitTransaction();
+
+        RealmResults<RealmModelWithRealmModelField> all = realm.where(RealmModelWithRealmModelField.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(42, all.first().getAllTypesRealmModel().columnLong);
+    }
+
+    // Test the behaviour of a RealmObject, containing a RealmModel field
+    @Test
+    public void realmObjectWithRealmModelField() {
+        RealmObjectWithRealmModelField realmObjectWithRealmModelField = new RealmObjectWithRealmModelField();
+        AllTypesRealmModel allTypePojo = new AllTypesRealmModel();
+        allTypePojo.columnLong = 42;
+        realmObjectWithRealmModelField.setAllTypesRealmModel(allTypePojo);
+
+        realm.beginTransaction();
+        realm.copyToRealm(realmObjectWithRealmModelField);
+        realm.commitTransaction();
+
+        RealmResults<RealmObjectWithRealmModelField> all = realm.where(RealmObjectWithRealmModelField.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals(42, all.first().getAllTypesRealmModel().columnLong);
+    }
+}
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 500b7261fb..6963b7ff1a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -17,7 +17,8 @@
 package io.realm;
 
 import android.support.test.runner.AndroidJUnit4;
-
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -28,9 +29,6 @@
 import java.util.Date;
 import java.util.Set;
 
-import io.realm.entities.AllJavaTypes;
-import io.realm.rule.TestRealmConfigurationFactory;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -318,7 +316,18 @@ public void primaryKeyFieldAttribute() {
             schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
             assertTrue(schema.hasPrimaryKey());
             assertTrue(schema.isPrimaryKey(fieldName));
-            assertFalse(schema.isNullable(fieldName));
+            assertEquals(fieldName, schema.getPrimaryKey());
+            switch (fieldType) {
+                case BYTE:
+                case SHORT:
+                case INT:
+                case LONG:
+                case STRING:
+                    assertTrue(schema.isNullable(fieldName));
+                    break;
+                default:
+                    assertFalse(schema.isNullable(fieldName));
+            }
             schema.removeField(fieldName);
         }
     }
@@ -599,6 +608,20 @@ public void renameField_toIllegalNameThrows() {
         schema.renameField(oldFieldName, newFieldName);
     }
 
+    @Test
+    public void renameField_withPrimaryKey() {
+        String fieldName = "foo";
+        schema.addField(fieldName, String.class, FieldAttribute.PRIMARY_KEY);
+        assertTrue(schema.hasField(fieldName));
+        assertTrue(schema.hasPrimaryKey());
+        assertTrue(schema.isPrimaryKey(fieldName));
+
+        schema.renameField(fieldName, "bar");
+        assertTrue(schema.hasPrimaryKey());
+
+        assertEquals("bar", schema.getPrimaryKey());
+    }
+
     @Test
     public void setGetClassName() {
         assertEquals("Dog", DOG_SCHEMA.getClassName());
@@ -698,6 +721,11 @@ public void isPrimaryKey_nonExistFieldThrows() {
         schema.isPrimaryKey("I don't exist");
     }
 
+    @Test(expected = IllegalStateException.class)
+    public void getPrimaryKey_nonExistFieldThrows() {
+        schema.getPrimaryKey();
+    }
+
     private interface FieldRunnable {
         void run(String fieldName);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 5ee084bc5d..76f4c16fc8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -26,10 +28,10 @@
 import org.junit.runner.RunWith;
 
 import java.io.FileNotFoundException;
+import java.lang.ref.WeakReference;
 import java.util.Calendar;
 import java.util.Date;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -39,6 +41,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.ConflictingFieldName;
 import io.realm.entities.CustomMethods;
 import io.realm.entities.CyclicType;
@@ -46,6 +49,7 @@
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
 import io.realm.entities.Thread;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
@@ -74,6 +78,8 @@
     public final ExpectedException thrown = ExpectedException.none();
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
 
     private Realm realm;
     private RealmConfiguration realmConfig;
@@ -102,8 +108,8 @@ public void tearDown() {
     @Test
     public void row_isValid() {
         realm.beginTransaction();
-        RealmObject realmObject = realm.createObject(AllTypes.class);
-        Row row = realmObject.row;
+        RealmObjectProxy realmObject = (RealmObjectProxy) realm.createObject(AllTypes.class);
+        Row row = realmObject.realmGet$proxyState().getRow$realm();
         realm.commitTransaction();
 
         assertNotNull("RealmObject.realmGetRow returns zero ", row);
@@ -225,7 +231,7 @@ public void deleteFromRealm_throwOnUnmanagedObject() {
         try {
             dog.deleteFromRealm();
             fail("Failed on deleting a RealmObject from null Row.");
-        } catch (IllegalStateException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -262,49 +268,31 @@ public void deleteFromRealm_removedFromResults() {
         realm.close();
     }
 
-    private void removeOneByOne(boolean atFirst) {
-        Set<Long> ages = new HashSet<Long>();
+    private void removeOneByOne(boolean removeFromFront) {
+        // Create test data
         realm.beginTransaction();
         realm.delete(Dog.class);
         for (int i = 0; i < TEST_SIZE; i++) {
-            Dog dog = realm.createObject(Dog.class);
-            dog.setAge(i);
-            ages.add((long) i);
+            realm.createObject(Dog.class);
         }
         realm.commitTransaction();
 
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
-
+        // Check initial size
         RealmResults<Dog> dogs = realm.allObjects(Dog.class);
-        for (int i = 0; i < TEST_SIZE; i++) {
-            realm.beginTransaction();
-            Dog dogToRemove;
-            if (atFirst) {
-                dogToRemove = dogs.first();
-            } else {
-                dogToRemove = dogs.last();
-            }
-            ages.remove(dogToRemove.getAge());
-            dogToRemove.deleteFromRealm();
-
-            // object is no longer valid
-            try {
-                dogToRemove.getAge();
-                fail();
-            }
-            catch (IllegalStateException ignored) {}
+        assertEquals(TEST_SIZE, dogs.size());
 
-            realm.commitTransaction();
-
-            // and removed from realm and remaining objects are place correctly
-            RealmResults<Dog> remainingDogs = realm.allObjects(Dog.class);
-            assertEquals(TEST_SIZE - i - 1, remainingDogs.size());
-            for (Dog dog : remainingDogs) {
-                assertTrue(ages.contains(dog.getAge()));
-            }
+        // Check that calling deleteFromRealm doesn't remove the object from the RealmResult
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            dogs.get(removeFromFront ? i : TEST_SIZE - 1 - i).deleteFromRealm();
         }
+        realm.commitTransaction();
+
+        assertEquals(TEST_SIZE, dogs.size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
+    // Tests calling deleteFromRealm on a RealmResults instead of RealmResults.remove()
     @Test
     public void deleteFromRealm_atPosition() {
         removeOneByOne(REMOVE_FIRST);
@@ -342,8 +330,7 @@ public Boolean call() throws Exception {
             }
         });
 
-        Boolean result = future.get();
-        return result;
+        return future.get();
     }
 
     @Test
@@ -580,10 +567,8 @@ private CyclicType createCyclicData() {
 
     @Test
     public void dateType() {
-        long testDatesValid[] = {-1000, 0, 1000};
-        long testDatesLoosePrecision[] = {Long.MIN_VALUE, 1, 1001, Long.MAX_VALUE};
+        long testDatesValid[] = {Long.MIN_VALUE, -1001, -1000, -1, 0, 1, 1000, 1001, Long.MAX_VALUE};
 
-        // test valid dates
         realm.beginTransaction();
         for (long value : testDatesValid) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -596,22 +581,6 @@ public void dateType() {
             assertEquals("Item " + i, new Date(testDatesValid[i]), allTypes.getColumnDate());
             i++;
         }
-
-        // test valid dates but with precision lost
-        realm.beginTransaction();
-        realm.delete(AllTypes.class);
-        for (long value : testDatesLoosePrecision) {
-            AllTypes allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnDate(new Date(value));
-        }
-        realm.commitTransaction();
-
-        i = 0;
-        for (AllTypes allTypes : realm.allObjects(AllTypes.class)) {
-            assertFalse("Item " + i, new Date(testDatesLoosePrecision[i]) == allTypes.getColumnDate());
-            assertEquals("Item " + i, new Date(1000*(testDatesLoosePrecision[i]/1000)), allTypes.getColumnDate());
-            i++;
-        }
     }
 
     private Date newDate(int year, int month, int dayOfMonth) {
@@ -981,7 +950,7 @@ public void isValid_closedRealm() {
     }
 
     @Test
-    public void IsValid_deletedObject() {
+    public void isValid_deletedObject() {
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
         assertTrue(allTypes.isValid());
@@ -1607,9 +1576,9 @@ public void addChangeListener_throwOnUnmanagedObject() {
         Dog dog = new Dog();
 
         try {
-            dog.addChangeListener(new RealmChangeListener() {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
-                public void onChange() {
+                public void onChange(Dog object) {
                 }
             });
             fail("Failed on adding listener on null realm.");
@@ -1643,9 +1612,9 @@ public void removeChangeListeners() {
         Dog dog = realm.createObject(Dog.class);
         dog.setAge(13);
         realm.commitTransaction();
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 assertTrue(false);
             }
         });
@@ -1662,9 +1631,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void removeChangeListener_throwOnUnmanagedObject() {
         Dog dog = new Dog();
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener listener = new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
             }
         };
 
@@ -1688,4 +1657,114 @@ public void removeChangeListeners_throwOnUnmanagedObject() {
             looperThread.testComplete();
         }
     }
+
+    // Bug https://github.com/realm/realm-java/issues/2569
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_returnedObjectOfCopyToRealmOrUpdate() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        realm.createObject(AllTypesPrimaryKey.class, 1);
+
+        AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
+        allTypesPrimaryKey.setColumnLong(1);
+        allTypesPrimaryKey.setColumnFloat(42f);
+        allTypesPrimaryKey = realm.copyToRealmOrUpdate(allTypesPrimaryKey);
+        realm.commitTransaction();
+
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+                assertEquals(42.0f, element.getColumnFloat(), 0f);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // The object should be added to HandlerController.realmObjects only when the first time addListener called.
+    @Test
+    @UiThreadTest
+    public void addChangeListener_shouldAddTheObjectToHandlerRealmObjects() {
+        realm.beginTransaction();
+        AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
+        realm.commitTransaction();
+        final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+                realm.handlerController.realmObjects;
+
+        assertTrue(realmObjects.isEmpty());
+
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+            }
+        });
+
+        assertEquals(1, realmObjects.size());
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            assertTrue(ref.get() == allTypesPrimaryKey);
+        }
+    }
+
+    // The object should be added to HandlerController.realmObjects only once.
+    @Test
+    @UiThreadTest
+    public void addChangeListener_shouldNotAddDupEntriesToHandlerRealmObjects() {
+        realm.beginTransaction();
+        AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
+        realm.commitTransaction();
+        final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+                realm.handlerController.realmObjects;
+
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            assertFalse(ref.get() == allTypesPrimaryKey);
+        }
+
+        // Add different listeners twice
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+            }
+        });
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+            }
+        });
+
+        assertEquals(1, realmObjects.size());
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            assertTrue(ref.get() == allTypesPrimaryKey);
+        }
+    }
+
+    // The object should not be added to HandlerController again after the async query loaded.
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_checkHandlerRealmObjectsWhenCallingOnAsyncObject() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        realm.createObject(AllTypesPrimaryKey.class, 1);
+        realm.commitTransaction();
+        final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+                realm.handlerController.realmObjects;
+
+        final AllTypesPrimaryKey allTypesPrimaryKey = realm.where(AllTypesPrimaryKey.class).findFirstAsync();
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+                allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+                    @Override
+                    public void onChange(AllTypesPrimaryKey element) {
+
+                    }
+                });
+                assertEquals(1, realmObjects.size());
+                looperThread.testComplete();
+            }
+        });
+        assertEquals(1, realmObjects.size());
+        for (RealmQuery<? extends RealmModel> query : realmObjects.values()) {
+            assertNotNull(query);
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
new file mode 100644
index 0000000000..d642764f0d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyRequiredAsBoxedByte;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedInteger;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedLong;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
+import io.realm.entities.PrimaryKeyRequiredAsString;
+import io.realm.objectid.NullPrimaryKey;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class RealmPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    /**
+     * Base parameters for testing null/not-null primary key value. The parameters are aligned in an
+     * order of 1) a test target class, 2) a primary key field class, 3) a primary Key value, 4) a
+     * secondary field class, and 5) a secondary field value, accommodating {@interface NullPrimaryKey}
+     * to condense unit tests.
+     */
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+                // 1) Test target class                  2) PK Class    3) PK value            4) 2nd Class  5) 2nd field value
+                {PrimaryKeyRequiredAsString.class,       String.class,  "424123",              String.class, "SomeSecondaryValue"},
+                {PrimaryKeyRequiredAsBoxedByte.class,    Byte.class,    Byte.valueOf("67"),    String.class, "This-Is-Second-One"},
+                {PrimaryKeyRequiredAsBoxedShort.class,   Short.class,   Short.valueOf("1729"), String.class, "AnyValueIsAccepted"},
+                {PrimaryKeyRequiredAsBoxedInteger.class, Integer.class, Integer.valueOf("19"), String.class, "PlayWithSeondFied!"},
+                {PrimaryKeyRequiredAsBoxedLong.class,    Long.class,    Long.valueOf("62914"), String.class, "Let's name a value"}
+        });
+    }
+
+    final private Class<? extends RealmObject> testClazz;
+    final private Class primaryKeyFieldType;
+    final private Object primaryKeyFieldValue;
+    final private Class secondaryFieldType;
+    final private Object secondaryFieldValue;
+
+    public RealmPrimaryKeyTests(Class<? extends RealmObject> testClazz, Class primaryKeyFieldType, Object primaryKeyFieldValue, Class secondaryFieldType, Object secondaryFieldValue) {
+        this.testClazz = testClazz;
+        this.primaryKeyFieldType = primaryKeyFieldType;
+        this.primaryKeyFieldValue = primaryKeyFieldValue;
+        this.secondaryFieldType = secondaryFieldType;
+        this.secondaryFieldValue = secondaryFieldValue;
+    }
+
+    // @PrimaryKey + @Required annotation accept not-null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealmOrUpdate_requiredPrimaryKey() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(primaryKeyFieldValue, secondaryFieldValue);
+        realm.beginTransaction();
+        realm.copyToRealmOrUpdate(obj);
+        realm.commitTransaction();
+
+        RealmResults results = realm.where(testClazz).findAll();
+        assertEquals(1, results.size());
+        assertEquals(primaryKeyFieldValue, ((NullPrimaryKey)results.first()).getId());
+        assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
+    }
+
+    // @PrimaryKey + @Required annotation does accept null as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        try {
+            RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
+            realm.beginTransaction();
+            realm.copyToRealmOrUpdate(obj);
+            fail("@PrimaryKey + @Required field cannot be null");
+        } catch (RuntimeException expected) {
+            if (testClazz.equals(PrimaryKeyRequiredAsString.class)) {
+                assertTrue(expected instanceof IllegalArgumentException);
+            } else {
+                assertTrue(expected instanceof NullPointerException);
+            }
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 771e8a1cdf..52552402c5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -45,6 +45,11 @@
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -769,6 +774,190 @@ public void isNull_notNullableFields() {
         }
     }
 
+    // Querying nullable PrimaryKey
+    @Test
+    public void equalTo_nullPrimaryKeys() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        final String SECONDARY_FIELD_STRING = "Realm is a mobile database hundreds of millions of people rely on.";
+        // fill up a Realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    SECONDARY_FIELD_STRING, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   SECONDARY_FIELD_STRING, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, SECONDARY_FIELD_STRING, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    SECONDARY_FIELD_STRING, 10, -5);
+
+        // String
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).equalTo(PrimaryKeyAsString.FIELD_PRIMARY_KEY,             (String) null).findAll().first().getId());
+        // Boxed Byte
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).equalTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       (Byte) null).findAll().first().getName());
+        // Boxed Short
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).equalTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     (Short) null).findAll().first().getName());
+        // Boxed Integer
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedInteger.class).equalTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, (Integer) null).findAll().first().getName());
+        // Boxed Long
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).equalTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       (Long) null).findAll().first().getName());
+    }
+
+    @Test
+    public void isNull_nullPrimaryKeys() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        final String SECONDARY_FIELD_STRING = "Realm is a mobile database hundreds of millions of people rely on.";
+        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    SECONDARY_FIELD_STRING, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   SECONDARY_FIELD_STRING, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, SECONDARY_FIELD_STRING, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    SECONDARY_FIELD_STRING, 10, -5);
+
+        // String
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).isNull(PrimaryKeyAsString.FIELD_PRIMARY_KEY).findAll().first().getId());
+        // Boxed Byte
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).isNull(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY).findAll().first().getName());
+        // Boxed Short
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).isNull(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY).findAll().first().getName());
+        // Boxed Integer
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedInteger.class).isNull(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY).findAll().first().getName());
+        // Boxed Long
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).isNull(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY).findAll().first().getName());
+    }
+
+    @Test
+    public void notEqualTo_nullPrimaryKeys() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        final String SECONDARY_FIELD_STRING = "Realm is a mobile database hundreds of millions of people rely on.";
+        // fill up a realm with one user PrimaryKey value and one numeric values, starting from -1
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 2, -1);
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    SECONDARY_FIELD_STRING, 2, -1);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   SECONDARY_FIELD_STRING, 2, -1);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, SECONDARY_FIELD_STRING, 2, -1);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    SECONDARY_FIELD_STRING, 2, -1);
+
+        // String
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).notEqualTo(PrimaryKeyAsString.FIELD_PRIMARY_KEY,             "-1").findAll().first().getId());
+        // Boxed Byte
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).notEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       Byte.valueOf((byte)-1)).findAll().first().getName());
+        // Boxed Short
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).notEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     Short.valueOf((short)-1)).findAll().first().getName());
+        // Boxed Integer
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedInteger.class).notEqualTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, Integer.valueOf(-1)).findAll().first().getName());
+        // Boxed Long
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).notEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       Long.valueOf((long)-1)).findAll().first().getName());
+    }
+
+    @Test
+    public void beginWith_nullStringPrimaryKey() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).beginsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
+    }
+
+    @Test
+    public void contains_nullStringPrimaryKey() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).contains(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
+    }
+
+    @Test
+    public void endsWith_nullStringPrimaryKey() {
+        final long SECONDARY_FIELD_NUMBER = 49992417L;
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).endsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
+    }
+
+    @Test
+    public void between_nullPrimaryKeysIsNotZero() {
+        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    (String) null, 10, -5);
+
+        // Boxed Byte
+        assertEquals(3, realm.where(PrimaryKeyAsBoxedByte.class).between(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       -1, 1).count());
+        // Boxed Short
+        assertEquals(3, realm.where(PrimaryKeyAsBoxedShort.class).between(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     -1, 1).count());
+        // Boxed Integer
+        assertEquals(3, realm.where(PrimaryKeyAsBoxedInteger.class).between(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, -1, 1).count());
+        // Boxed Long
+        assertEquals(3, realm.where(PrimaryKeyAsBoxedLong.class).between(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       -1, 1).count());
+    }
+
+    @Test
+    public void greaterThan_nullPrimaryKeysIsNotZero() {
+        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    (String) null, 10, -5);
+
+        // Boxed Byte
+        assertEquals(4, realm.where(PrimaryKeyAsBoxedByte.class).greaterThan(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       -1).count());
+        // Boxed Short
+        assertEquals(4, realm.where(PrimaryKeyAsBoxedShort.class).greaterThan(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     -1).count());
+        // Boxed Integer
+        assertEquals(4, realm.where(PrimaryKeyAsBoxedInteger.class).greaterThan(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, -1).count());
+        // Boxed Long
+        assertEquals(4, realm.where(PrimaryKeyAsBoxedLong.class).greaterThan(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       -1).count());
+    }
+
+    @Test
+    public void greaterThanOrEqualTo_nullPrimaryKeysIsNotZero() {
+        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    (String) null, 10, -5);
+
+        // Boxed Byte
+        assertEquals(5, realm.where(PrimaryKeyAsBoxedByte.class).greaterThanOrEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       -1).count());
+        // Boxed Short
+        assertEquals(5, realm.where(PrimaryKeyAsBoxedShort.class).greaterThanOrEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     -1).count());
+        // Boxed Integer
+        assertEquals(5, realm.where(PrimaryKeyAsBoxedInteger.class).greaterThanOrEqualTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, -1).count());
+        // Boxed Long
+        assertEquals(5, realm.where(PrimaryKeyAsBoxedLong.class).greaterThanOrEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       -1).count());
+    }
+
+    @Test
+    public void lessThan_nullPrimaryKeysIsNotZero() {
+        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    (String) null, 10, -5);
+
+        // Boxed Byte
+        assertEquals(6, realm.where(PrimaryKeyAsBoxedByte.class).lessThan(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       1).count());
+        // Boxed Short
+        assertEquals(6, realm.where(PrimaryKeyAsBoxedShort.class).lessThan(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     1).count());
+        // Boxed Integer
+        assertEquals(6, realm.where(PrimaryKeyAsBoxedInteger.class).lessThan(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, 1).count());
+        // Boxed Long
+        assertEquals(6, realm.where(PrimaryKeyAsBoxedLong.class).lessThan(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       1).count());
+    }
+
+    @Test
+    public void lessThanOrEqualTo_nullPrimaryKeysIsNotZero() {
+        // fill up a realm with one user PrimaryKey value and 9 numeric values, starting from -5
+        TestHelper.populateTestRealmWithBytePrimaryKey(realm,    (Byte) null,    (String) null, 10, -5);
+        TestHelper.populateTestRealmWithShortPrimaryKey(realm,   (Short) null,   (String) null, 10, -5);
+        TestHelper.populateTestRealmWithIntegerPrimaryKey(realm, (Integer) null, (String) null, 10, -5);
+        TestHelper.populateTestRealmWithLongPrimaryKey(realm,    (Long) null,    (String) null, 10, -5);
+
+        // Boxed Byte
+        assertEquals(7, realm.where(PrimaryKeyAsBoxedByte.class).lessThanOrEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       1).count());
+        // Boxed Short
+        assertEquals(7, realm.where(PrimaryKeyAsBoxedShort.class).lessThanOrEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     1).count());
+        // Boxed Integer
+        assertEquals(7, realm.where(PrimaryKeyAsBoxedInteger.class).lessThanOrEqualTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, 1).count());
+        // Boxed Long
+        assertEquals(7, realm.where(PrimaryKeyAsBoxedLong.class).lessThanOrEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       1).count());
+    }
+
     // Querying nullable fields, querying with equalTo null
     @Test
     public void equalTo_nullableFields() {
@@ -1119,7 +1308,7 @@ public void max_allNonNullRows() {
         assertEquals(4, query.max(NullTypes.FIELD_INTEGER_NULL).intValue());
         assertEquals(5f, query.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
         assertEquals(6d, query.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-        assertEquals(12000, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
+        assertEquals(12345, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
     // Test max on columns with partial null rows
@@ -1131,7 +1320,7 @@ public void max_partialNullRows() {
         assertEquals(4, query.max(NullTypes.FIELD_INTEGER_NULL).intValue());
         assertEquals(5f, query.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
         assertEquals(6d, query.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-        assertEquals(12000, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
+        assertEquals(12345, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
     // Test average on empty columns
@@ -1638,6 +1827,7 @@ public void isValid_removedParent() {
         list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
         list.remove(RealmFieldType.UNSUPPORTED_MIXED);
         list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        list.remove(RealmFieldType.UNSUPPORTED_DATE);
         NOT_SUPPORTED_IS_EMPTY_TYPES = list;
     }
 
@@ -1760,6 +1950,7 @@ public void isEmpty_invalidFieldNameThrows() {
         list.removeAll(SUPPORTED_IS_NOT_EMPTY_TYPES);
         list.remove(RealmFieldType.UNSUPPORTED_MIXED);
         list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        list.remove(RealmFieldType.UNSUPPORTED_DATE);
         NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = list;
     }
 
@@ -2120,33 +2311,33 @@ public void run() {
             }
         };
 
-        distinctBool.addChangeListener(new RealmChangeListener() {
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(2, distinctBool.size());
                 endTest.run();
             }
         });
 
-        distinctLong.addChangeListener(new RealmChangeListener() {
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctLong.size());
                 endTest.run();
             }
         });
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctDate.size());
                 endTest.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctString.size());
                 endTest.run();
             }
@@ -2168,7 +2359,7 @@ public void run() {
 
                 Realm asyncRealm = null;
                 try {
-                    Realm.asyncQueryExecutor.pause();
+                    Realm.asyncTaskExecutor.pause();
                     asyncRealm = openRealmInstance("testDistinctAsyncQueryWithNull");
                     final long numberOfBlocks = 25;
                     final long numberOfObjects = 10; // must be greater than 1
@@ -2185,19 +2376,19 @@ public void run() {
                     assertTrue(distinctString.isValid());
                     assertTrue(distinctString.isEmpty());
 
-                    Realm.asyncQueryExecutor.resume();
+                    Realm.asyncTaskExecutor.resume();
 
-                    distinctDate.addChangeListener(new RealmChangeListener() {
+                    distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<AnnotationIndexTypes> object) {
                             assertEquals(1, distinctDate.size());
                             signalCallbackFinished.countDown();
                         }
                     });
 
-                    distinctString.addChangeListener(new RealmChangeListener() {
+                    distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<AnnotationIndexTypes> object) {
                             assertEquals(1, distinctString.size());
                             signalCallbackFinished.countDown();
                         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
deleted file mode 100644
index b67a23b06c..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
-* Copyright 2014 Realm Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import java.util.ConcurrentModificationException;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.ListIterator;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import io.realm.entities.AllTypes;
-import io.realm.exceptions.RealmException;
-
-public class RealmResultsIteratorTests extends AndroidTestCase {
-
-    protected final static int TEST_DATA_SIZE = 10;
-    protected Realm testRealm;
-
-    @Override
-    protected void setUp() throws InterruptedException {
-        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
-        Realm.deleteRealm(realmConfig);
-        testRealm = Realm.getInstance(realmConfig);
-        testRealm.beginTransaction();
-        for (int i = 0; i < TEST_DATA_SIZE; ++i) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnBoolean((i % 2) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date((long) i));
-            allTypes.setColumnDouble(3.1415 + i);
-            allTypes.setColumnFloat(1.234567f + i);
-            allTypes.setColumnString("test data " + i);
-            allTypes.setColumnLong(i);
-        }
-        testRealm.commitTransaction();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-    public void testListIteratorAtBeginning() {
-        ListIterator<AllTypes> it = testRealm.allObjects(AllTypes.class).listIterator();
-        assertFalse(it.hasPrevious());
-        assertEquals(-1, it.previousIndex());
-        assertTrue(it.hasNext());
-        assertEquals(0, it.nextIndex());
-    }
-
-    public void testListIteratorAtEnd() {
-        ListIterator<AllTypes> it = testRealm.allObjects(AllTypes.class).listIterator(TEST_DATA_SIZE);
-        assertTrue(it.hasPrevious());
-        assertEquals(TEST_DATA_SIZE - 1, it.previousIndex());
-        assertFalse(it.hasNext());
-        assertEquals(TEST_DATA_SIZE, it.nextIndex());
-    }
-    // TODO: Should we reenable this test?
-    public void DISABLEDtestListIteratorRemove() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        ListIterator<AllTypes> it = result.listIterator();
-        while (it.hasNext()) {
-            testRealm.beginTransaction();
-            it.next();
-            it.remove();
-            assertFalse(it.hasPrevious());
-            testRealm.commitTransaction();
-        }
-
-        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-    }
-    // TODO: Should we reenable this test?
-    public void DISABLEDtestListIteratorFailOnDeleteBeforeNext() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        ListIterator<AllTypes> it = result.listIterator();
-        testRealm.beginTransaction();
-        try {
-            it.remove();
-        } catch (IllegalStateException ignored) {
-            return;
-        } finally {
-            testRealm.cancelTransaction();
-        }
-
-        fail("You must call next() before calling remove() pr. the JavaDoc");
-    }
-    // TODO: Should we reenable this test?
-    public void DISABLEDtestListIteratorFailOnDoubleRemove() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        ListIterator<AllTypes> it = result.listIterator();
-        testRealm.beginTransaction();
-        it.next();
-        it.remove();
-
-        try {
-            it.remove();
-        } catch (IllegalStateException ignored) {
-            return;
-        } finally {
-            testRealm.cancelTransaction();
-        }
-
-        fail("You can only make one call to remove() after calling next() pr. the JavaDoc");
-    }
-
-    private enum ListIteratorMethods { ADD, SET; }
-    public void testListIteratorUnsupportedMethods() {
-        for (ListIteratorMethods method : ListIteratorMethods.values()) {
-            ListIterator<AllTypes> it = testRealm.allObjects(AllTypes.class).listIterator();
-            try {
-                switch (method) {
-                    case ADD: it.add(new AllTypes()); break;
-                    case SET: it.set(new AllTypes()); break;
-                }
-
-                fail(method + " should not be supported");
-
-            } catch(RealmException ignored) {
-            }
-        }
-    }
-
-    public void testRemovingObjectsInsideLoop() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        testRealm.beginTransaction();
-        try {
-            for (AllTypes obj : result) {
-                obj.deleteFromRealm();
-            }
-        } catch (ConcurrentModificationException ignored) {
-            return;
-        } finally {
-            testRealm.cancelTransaction();
-        }
-
-        fail("Modifying Realm while iterating is not allowed");
-    }
-
-    // TODO: Should we reenable this test?
-    // Query iterator should still be valid if we modify Realm after query but before iterator is
-    // fetched.
-    public void DISABLEDtestIteratorValidAfterAutoUpdate() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        testRealm.beginTransaction();
-        result.removeLast();
-        testRealm.commitTransaction();
-
-        // For..each uses RealmResults.iterator() in the byte code.
-        long realmSum = 0;
-        for (AllTypes obj : result) {
-            realmSum += obj.getColumnLong();
-        }
-
-        assertEquals(sum(0, TEST_DATA_SIZE - 2), realmSum);
-    }
-
-
-    public void testIteratorStandardBehavior() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        // For..each uses RealmResults.iterator() in the byte code.
-        long realmSum = 0;
-        for (AllTypes obj : result) {
-            realmSum += obj.getColumnLong();
-        }
-
-        assertEquals(sum(0, TEST_DATA_SIZE - 1), realmSum);
-    }
-    // TODO: Should we reenable this test?
-    public void DISABLEDtestIteratorRemove() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        Iterator<AllTypes> it = result.iterator();
-        while (it.hasNext()) {
-            testRealm.beginTransaction();
-            it.next();
-            it.remove();
-            testRealm.commitTransaction();
-        }
-
-        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-    }
-
-    // TODO: Should we reenable this test?
-    public void DISABLEDtestIteratorFailOnDeleteBeforeNext() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        Iterator<AllTypes> it = result.iterator();
-        testRealm.beginTransaction();
-        try {
-            it.remove();
-        } catch (IllegalStateException ignored) {
-            return;
-        } finally {
-            testRealm.cancelTransaction();
-        }
-
-        fail("You must call next() before calling remove() pr. the JavaDoc");
-    }
-    // TODO: Should we reenable this test?
-    public void DISABLEDtestIteratorFailOnDoubleRemove() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-
-        Iterator<AllTypes> it = result.iterator();
-        testRealm.beginTransaction();
-        it.next();
-        it.remove();
-
-        try {
-            it.remove();
-
-        } catch (IllegalStateException ignored) {
-            return;
-        } finally {
-            testRealm.cancelTransaction();
-        }
-
-        fail("You can only make one call to remove() after calling next() pr. the JavaDoc");
-    }
-
-
-    // TODO: Should we reenable this test?
-    // Using size() as heuristic for concurrent modifications is dangerous as we might skip
-    // elements.
-    // TODO Possible bug: Why does this interfere with reference counting check. They are separate Realm files.
-    // TODO Possible bug: Why is realm.refresh() needed?
-    public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws InterruptedException, ExecutionException {
-
-        // Prefill
-        final RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "test");
-        Realm realm = Realm.getInstance(realmConfig);
-        realm.beginTransaction();
-        realm.delete(AllTypes.class);
-        AllTypes o1 = realm.createObject(AllTypes.class);
-        o1.setColumnLong(1);
-        AllTypes o2 = realm.createObject(AllTypes.class);
-        o2.setColumnLong(2);
-        realm.commitTransaction();
-
-        // Iterate past 1st item
-        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-        Iterator<AllTypes> it = result.iterator();
-        it.next();
-
-        // Delete first item and insert new. Meaning Item 2 gets Item 1s place, and is skipped
-        // in iterator when calling next().
-        Callable<Boolean> backgroundWorker = new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                Realm backgroundRealm = Realm.getInstance(realmConfig);
-                backgroundRealm.beginTransaction();
-                RealmResults<AllTypes> backgroundResult = backgroundRealm.allObjects(AllTypes.class);
-                if (backgroundResult.size() != 2) {
-                    backgroundRealm.close();
-                    return false;
-                }
-                backgroundResult.sort("columnLong", Sort.ASCENDING);
-                backgroundResult.remove(0);
-                AllTypes o3 = backgroundRealm.createObject(AllTypes.class);
-                o3.setColumnLong(3);
-                backgroundRealm.commitTransaction();
-                int size = backgroundResult.size();
-                backgroundRealm.close();
-                if (size != 2) {
-                    return false;
-                } else {
-                    return true;
-                }
-            }
-        };
-
-        // Wait for background thread to finish
-        ExecutorService executorService = Executors.newFixedThreadPool(1);
-        Future<Boolean> backgroundResult = executorService.submit(backgroundWorker);
-        assertTrue(backgroundResult.get());
-        realm.refresh(); // This shouldn't be needed, but is currently.
-
-        // Next item would now be o3.
-        try {
-            AllTypes o3 = it.next();
-            assertEquals(3, o3.getColumnLong());
-            fail("Failed to detect the list was modified, but retained it's size while iterating");
-        } catch (ConcurrentModificationException ignored) {
-            return;
-        } finally {
-            realm.close();
-        }
-    }
-
-    private long sum(int start, int end) {
-        long sum = 0;
-        for (int i = start; i <= end; i++) {
-            sum += i;
-        }
-        return sum;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index f2a5322446..3e7c1e8085 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -73,7 +73,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         populateTestRealm();
-        collection = realm.allObjects(AllTypes.class);
+        collection = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_LONG, Sort.ASCENDING);
     }
 
     @After
@@ -83,30 +83,6 @@ public void tearDown() {
         }
     }
 
-    private void populateTestRealm(int objects) {
-        realm.beginTransaction();
-        realm.deleteAll();
-
-        for (int i = 0; i < objects; ++i) {
-            AllTypes allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnBoolean((i % 2) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - objects / 2)));
-            allTypes.setColumnDouble(3.1415 + i);
-            allTypes.setColumnFloat(1.234567f + i);
-            allTypes.setColumnString("test data " + i);
-            allTypes.setColumnLong(i);
-            Dog d = realm.createObject(Dog.class);
-            d.setName("Foo " + i);
-            allTypes.setColumnRealmObject(d);
-            allTypes.getColumnRealmList().add(d);
-            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
-            nonLatinFieldNames.set델타(i);
-            nonLatinFieldNames.setΔέλτα(i);
-        }
-        realm.commitTransaction();
-    }
-
     private void populateTestRealm() {
         populateTestRealm(TEST_DATA_SIZE);
     }
@@ -362,11 +338,61 @@ public void distinct_invalidTypesLinkedFields() {
         }
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_syncIfNeeded_updatedFromOtherThread() {
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration("Foo"));
+        populateTestRealm(realm, 10);
+
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 10).findAll();
+        assertEquals(10, results.size());
+
+        // 1. Delete first object from another thread.
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+               realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 0).findFirst().removeFromRealm();
+            }
+        }, new Realm.Transaction.Callback() {
+            @Override
+            public void onSuccess() {
+                // 2. RealmResults are refreshed before onSuccess is called
+                assertEquals(9, results.size());
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+    }
+
     // distinctAsync
+    private void populateTestRealm(int objects) {
+        realm.beginTransaction();
+        realm.deleteAll();
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 2) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - objects / 2)));
+            allTypes.setColumnDouble(3.1415 + i);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            Dog d = realm.createObject(Dog.class);
+            d.setName("Foo " + i);
+            allTypes.setColumnRealmObject(d);
+            allTypes.getColumnRealmList().add(d);
+            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+        }
+        realm.commitTransaction();
+    }
+
+
     private void populateTestRealm(Realm testRealm, int objects) {
         testRealm.beginTransaction();
         testRealm.deleteAll();
-        for (int i = 0; i < objects; ++i) {
+        for (int i = 0; i < objects; i++) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
@@ -423,33 +449,33 @@ public void run() {
             }
         };
 
-        distinctBool.addChangeListener(new RealmChangeListener() {
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(2, distinctBool.size());
                 endTest.run();
             }
         });
 
-        distinctLong.addChangeListener(new RealmChangeListener() {
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctLong.size());
                 endTest.run();
             }
         });
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctDate.size());
                 endTest.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctString.size());
                 endTest.run();
             }
@@ -485,17 +511,17 @@ public void run() {
             }
         };
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals("distinctDate", 1, distinctDate.size());
                 endTest.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals("distinctString", 1, distinctString.size());
                 endTest.run();
             }
@@ -750,7 +776,7 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
         return dogs;
     }
 
-    // It will still be treated as valid table view in core, just alays be empty.
+    // It will still be treated as valid table view in core, just always be empty.
     @Test
     public void isValid_resultsBuiltOnDeletedLinkView() {
         assertEquals(true, populateRealmResultsOnDeletedLinkView().isValid());
@@ -829,9 +855,9 @@ public void addChangeListener() {
         Realm realm = looperThread.realm;
         RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
 
-        collection.addChangeListener(new RealmChangeListener() {
+        collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
@@ -848,16 +874,16 @@ public void addChangeListener_twice() {
         final Realm realm = looperThread.realm;
         RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
 
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 listenersTriggered.incrementAndGet();
                 looperThread.postRunnable(new Runnable() {
                     @Override
@@ -899,9 +925,9 @@ public void removeChangeListener() {
         final Realm realm = looperThread.realm;
         RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
 
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
@@ -943,15 +969,15 @@ public void removeAllChangeListeners() {
         final Realm realm = looperThread.realm;
         RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
 
-        RealmChangeListener listenerA = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listenerA = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
-        RealmChangeListener listenerB = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listenerB = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index b2172a7367..bef98fac91 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -30,6 +30,8 @@
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -51,7 +53,7 @@
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-                .schema(AllJavaTypes.class, Owner.class)
+                .schema(AllJavaTypes.class, Owner.class, PrimaryKeyAsString.class)
                 .build();
         Realm.getInstance(realmConfig).close(); // create Schema
         realm = DynamicRealm.getInstance(realmConfig);
@@ -68,9 +70,10 @@ public void tearDown() {
     @Test
     public void getAll() {
         Set<RealmObjectSchema> objectSchemas = realmSchema.getAll();
-        assertEquals(5, objectSchemas.size());
+        assertEquals(6, objectSchemas.size());
 
-        List<String> expectedTables = Arrays.asList(AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey");
+        List<String> expectedTables = Arrays.asList(
+                AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey", "PrimaryKeyAsString");
         for (RealmObjectSchema objectSchema : objectSchemas) {
             if (!expectedTables.contains(objectSchema.getClassName())) {
                 fail(objectSchema.getClassName() + " was not found");
@@ -139,6 +142,32 @@ public void rename_invalidArgumentThrows() {
         }
     }
 
+    @Test
+    public void rename_shouldChangeInfoInPKTable() {
+        final String NEW_NAME = "NewPrimaryKeyAsString";
+        assertTrue(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+        realmSchema.rename(PrimaryKeyAsString.CLASS_NAME, NEW_NAME);
+        assertFalse(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+        assertTrue(realmSchema.contains(NEW_NAME));
+        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass(NEW_NAME);
+
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
+
+        // Create an object with the old name, and the PK should not exist after created.
+        RealmObjectSchema oldObjectSchema = realmSchema.create(PrimaryKeyAsString.CLASS_NAME);
+        oldObjectSchema.addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
+
+        try {
+            // It should not have primary key anymore at this point
+            oldObjectSchema.getPrimaryKey();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        oldObjectSchema.addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, oldObjectSchema.getPrimaryKey());
+    }
+
     @Test
     public void remove() {
         realmSchema.remove(AllJavaTypes.CLASS_NAME);
@@ -178,4 +207,24 @@ public void remove_classWithReferencesThrows() {
         realmSchema.remove("Cat");
         assertFalse(realmSchema.contains("Cat"));
     }
+
+    @Test
+    public void remove_shouldRemoveInfoFromPKTable() {
+        assertTrue(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+        realmSchema.remove(PrimaryKeyAsString.CLASS_NAME);
+        assertFalse(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
+
+        RealmObjectSchema objectSchema = realmSchema.create(PrimaryKeyAsString.CLASS_NAME);
+        objectSchema.addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
+
+        try {
+            // It should not have primary key anymore at this point
+            objectSchema.getPrimaryKey();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        objectSchema.addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index e9969b0fb2..c7322e0edc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -55,12 +55,12 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
-import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.Cat;
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
@@ -71,16 +71,29 @@
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
 import io.realm.entities.OwnerPrimaryKey;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsLong;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.PrimaryKeyMix;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedByte;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedInteger;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedLong;
+import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
+import io.realm.entities.PrimaryKeyRequiredAsString;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 import io.realm.internal.log.RealmLog;
+import io.realm.objectid.NullPrimaryKey;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.util.ExceptionHolder;
+import io.realm.util.RealmThread;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -500,117 +513,6 @@ public void where_equalTo_requiredFieldWithNullArgument() {
         }
     }
 
-    @Test
-    public void allObjects() {
-        populateTestRealm();
-        RealmResults<AllTypes> resultList = realm.allObjects(AllTypes.class);
-        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
-    }
-
-    @Test
-    public void allObjectsSorted() {
-        populateTestRealm();
-        RealmResults<AllTypes> sortedList = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_STRING, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("test data 0", sortedList.first().getColumnString());
-
-        RealmResults<AllTypes> reverseList = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals("test data 0", reverseList.last().getColumnString());
-
-        try {
-            realm.allObjectsSorted(AllTypes.class, "invalid", Sort.ASCENDING);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void allObjectsSorted_singleField() {
-        populateTestRealm();
-        RealmResults<AllTypes> sortedList = realm.allObjectsSorted(AllTypes.class,
-                new String[]{AllTypes.FIELD_LONG},
-                new Sort[]{Sort.DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
-        assertEquals(0, sortedList.last().getColumnLong());
-    }
-
-    @Test
-    public void allObjectsSorted_twoFields() {
-        TestHelper.populateForMultiSort(realm);
-
-        RealmResults<AllTypes> results1 = realm.allObjectsSorted(AllTypes.class,
-                new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results1.size());
-
-        assertEquals("Adam", results1.get(0).getColumnString());
-        assertEquals(4, results1.get(0).getColumnLong());
-
-        assertEquals("Adam", results1.get(1).getColumnString());
-        assertEquals(5, results1.get(1).getColumnLong());
-
-        assertEquals("Brian", results1.get(2).getColumnString());
-        assertEquals(4, results1.get(2).getColumnLong());
-
-        RealmResults<AllTypes> results2 = realm.allObjectsSorted(AllTypes.class,
-                new String[]{AllTypes.FIELD_LONG, AllTypes.FIELD_STRING},
-                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-
-        assertEquals(3, results2.size());
-
-        assertEquals("Adam", results2.get(0).getColumnString());
-        assertEquals(4, results2.get(0).getColumnLong());
-
-        assertEquals("Brian", results2.get(1).getColumnString());
-        assertEquals(4, results2.get(1).getColumnLong());
-
-        assertEquals("Adam", results2.get(2).getColumnString());
-        assertEquals(5, results2.get(2).getColumnLong());
-    }
-
-    @Test
-    public void allObjectsSorted_failures() {
-        // zero fields specified
-        try {
-            realm.allObjectsSorted(AllTypes.class, new String[]{}, new Sort[]{});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // number of fields and sorting orders don't match
-        try {
-            realm.allObjectsSorted(AllTypes.class,
-                    new String[]{AllTypes.FIELD_STRING},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // null is not allowed
-        try {
-            realm.allObjectsSorted(AllTypes.class, null, (Sort[]) null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            realm.allObjectsSorted(AllTypes.class, new String[]{AllTypes.FIELD_STRING}, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // non-existing field name
-        try {
-            realm.allObjectsSorted(AllTypes.class,
-                    new String[]{AllTypes.FIELD_STRING, "dont-exist"},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
     @Test
     public void beginTransaction() throws IOException {
         populateTestRealm();
@@ -648,7 +550,6 @@ public void nestedTransaction() {
         METHOD_CANCEL,
         METHOD_DELETE_TYPE,
         METHOD_DELETE_ALL,
-        METHOD_DISTINCT,
         METHOD_CREATE_OBJECT,
         METHOD_COPY_TO_REALM,
         METHOD_COPY_TO_REALM_OR_UPDATE,
@@ -685,9 +586,6 @@ public Boolean call() throws Exception {
                         case METHOD_DELETE_ALL:
                             realm.deleteAll();
                             break;
-                        case METHOD_DISTINCT:
-                            realm.distinct(AllTypesPrimaryKey.class, "columnLong");
-                            break;
                         case METHOD_CREATE_OBJECT:
                             realm.createObject(AllTypes.class);
                             break;
@@ -768,7 +666,7 @@ public void cancelTransaction() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.cancelTransaction();
-        assertEquals(TEST_DATA_SIZE, realm.allObjects(AllTypes.class).size());
+        assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
 
         try {
             realm.cancelTransaction();
@@ -790,7 +688,7 @@ public void executeTransaction_null() {
 
     @Test
     public void executeTransaction_success() {
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -798,14 +696,14 @@ public void execute(Realm realm) {
                 owner.setName("Owner");
             }
         });
-        assertEquals(1, realm.allObjects(Owner.class).size());
+        assertEquals(1, realm.where(Owner.class).count());
     }
 
     @Test
     public void executeTransaction_canceled() {
         final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
 
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
         try {
             realm.executeTransaction(new Realm.Transaction() {
                 @Override
@@ -820,12 +718,12 @@ public void execute(Realm realm) {
             //noinspection ThrowableResultOfMethodCallIgnored
             assertTrue(e == thrownException.get());
         }
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
     }
 
     @Test
     public void executeTransaction_cancelInsideClosureThrowsException() {
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         try {
             RealmLog.add(testLogger);
@@ -844,7 +742,7 @@ public void execute(Realm realm) {
         } finally {
             RealmLog.remove(testLogger);
         }
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
     }
 
     @Test
@@ -893,7 +791,7 @@ private void createAndTestFilename(String language, String fileName) {
         assertTrue(language, file.exists());
 
         Realm realm2 = Realm.getInstance(realmConfig);
-        Dog dog2 = realm2.allObjects(Dog.class).first();
+        Dog dog2 = realm2.where(Dog.class).findFirst();
         assertEquals(language, "Rex", dog2.getName());
         realm2.close();
     }
@@ -993,7 +891,7 @@ public void unicodeStrings() {
             stringOnly.setChars(test_char);
             realm.commitTransaction();
 
-            realm.allObjects(StringOnly.class).get(0).getChars();
+            realm.where(StringOnly.class).findFirst().getChars();
 
             realm.beginTransaction();
             realm.delete(StringOnly.class);
@@ -1061,7 +959,7 @@ public void getInstance_referenceCounting_doubleClose() {
         realm = Realm.getInstance(configFactory.createConfiguration());
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
-        RealmResults<AllTypes> queryResult = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> queryResult = realm.where(AllTypes.class).findAll();
         assertEquals(allTypes, queryResult.get(0));
         realm.commitTransaction();
         realm.close(); // This might not close the Realm if the reference count is wrong
@@ -1102,7 +1000,7 @@ public void writeCopyTo() throws IOException {
         try {
             // Contents is copied too
             realm2 = Realm.getInstance(configB);
-            RealmResults<AllTypes> results = realm2.allObjects(AllTypes.class);
+            RealmResults<AllTypes> results = realm2.where(AllTypes.class).findAll();
             assertEquals(1, results.size());
             assertEquals("Hello World", results.first().getColumnString());
         } finally {
@@ -1275,7 +1173,7 @@ public void copyToRealm_cyclicObjectReferences() {
 
         assertEquals("One", realmObject.getName());
         assertEquals("Two", realmObject.getObject().getName());
-        assertEquals(2, realm.allObjects(CyclicType.class).size());
+        assertEquals(2, realm.where(CyclicType.class).count());
     }
 
     @Test
@@ -1292,7 +1190,7 @@ public void copyToRealm_cyclicListReferences() {
         realm.commitTransaction();
 
         assertEquals("One", realmObject.getName());
-        assertEquals(2, realm.allObjects(CyclicType.class).size());
+        assertEquals(2, realm.where(CyclicType.class).count());
     }
 
     // Check that if a field has a null value it gets converted to the default value for that type
@@ -1319,10 +1217,72 @@ public void copyToRealm_primaryKeyIsSetDirectly() {
     }
 
     @Test
-    public void copyToRealm_primaryKeyIsNull() {
-        realm.beginTransaction();
-        thrown.expect(IllegalArgumentException.class);
-        realm.copyToRealm(new PrimaryKeyAsString());
+    public void copyToRealm_stringPrimaryKeyIsNull() {
+        final long SECONDARY_FIELD_VALUE = 34992142L;
+        TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, SECONDARY_FIELD_VALUE);
+
+        RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+        assertEquals(1, results.size());
+        assertEquals(null, results.first().getName());
+        assertEquals(SECONDARY_FIELD_VALUE, results.first().getId());
+    }
+
+    @Test
+    public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
+        final String SECONDARY_FIELD_VALUE = "nullNumberPrimaryKeyObj";
+        final Class[] CLASSES = {PrimaryKeyAsBoxedByte.class, PrimaryKeyAsBoxedShort.class, PrimaryKeyAsBoxedInteger.class, PrimaryKeyAsBoxedLong.class};
+
+        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm,    (Byte) null,    SECONDARY_FIELD_VALUE);
+        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm,   (Short) null,   SECONDARY_FIELD_VALUE);
+        TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, SECONDARY_FIELD_VALUE);
+        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    SECONDARY_FIELD_VALUE);
+
+        for (Class clazz : CLASSES) {
+            RealmResults results = realm.allObjects(clazz);
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey)results.first()).getId());
+            assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey)results.first()).getName());
+        }
+    }
+
+    @Test
+    public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
+        final String[] PRIMARY_KEY_TYPES = {"String", "BoxedByte", "BoxedShort", "BoxedInteger", "BoxedLong"};
+
+        TestHelper.addStringPrimaryKeyObjectToTestRealm(realm,  (String) null,  0);
+        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm,    (Byte) null,    (String) null);
+        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm,   (Short) null,   (String) null);
+        TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, (String) null);
+        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    (String) null);
+
+        for (String className : PRIMARY_KEY_TYPES) {
+            try {
+                realm.beginTransaction();
+                switch (className) {
+                    case "String":
+                        realm.copyToRealm(new PrimaryKeyAsString());
+                        break;
+                    case "BoxedByte":
+                        realm.copyToRealm(new PrimaryKeyAsBoxedByte());
+                        break;
+                    case "BoxedShort":
+                        realm.copyToRealm(new PrimaryKeyAsBoxedShort());
+                        break;
+                    case "BoxedInteger":
+                        realm.copyToRealm(new PrimaryKeyAsBoxedInteger());
+                        break;
+                    case "BoxedLong":
+                        realm.copyToRealm(new PrimaryKeyAsBoxedLong());
+                        break;
+                    default:
+                }
+                fail("Null value as primary key already exists.");
+            } catch (RealmPrimaryKeyConstraintException expected) {
+                assertEquals("Value already exists: null", expected.getMessage());
+            } finally {
+                realm.cancelTransaction();
+            }
+        }
     }
 
     @Test
@@ -1400,10 +1360,103 @@ public void copyToRealmOrUpdate_null() {
     }
 
     @Test
-    public void copyToRealmOrUpdate_primaryKeyFieldIsNull() {
+    public void copyToRealmOrUpdate_stringPrimaryKeyFieldIsNull() {
+        final long SECONDARY_FIELD_VALUE = 2192841L;
+        final long SECONDARY_FIELD_UPDATED = 44887612L;
+        PrimaryKeyAsString nullPrimaryKeyObj = TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, SECONDARY_FIELD_VALUE);
+
+        RealmResults<PrimaryKeyAsString> result = realm.allObjects(PrimaryKeyAsString.class);
+        assertEquals(1, result.size());
+        assertEquals(null, result.first().getName());
+        assertEquals(SECONDARY_FIELD_VALUE, result.first().getId());
+
+        // update objects
         realm.beginTransaction();
-        thrown.expect(IllegalArgumentException.class);
-        realm.copyToRealmOrUpdate(new PrimaryKeyAsString());
+        nullPrimaryKeyObj.setId(SECONDARY_FIELD_UPDATED);
+        realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
+        realm.commitTransaction();
+
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsString.class).first().getId());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_boxedBytePrimaryKeyFieldIsNull() {
+        final String SECONDARY_FIELD_VALUE = "nullBytePrimaryKeyObj";
+        final String SECONDARY_FIELD_UPDATED = "nullBytePrimaryKeyObjUpdated";
+        PrimaryKeyAsBoxedByte nullPrimaryKeyObj = TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, SECONDARY_FIELD_VALUE);
+
+        RealmResults<PrimaryKeyAsBoxedByte> result = realm.allObjects(PrimaryKeyAsBoxedByte.class);
+        assertEquals(1, result.size());
+        assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
+        assertEquals(null, result.first().getId());
+
+        // update objects
+        realm.beginTransaction();
+        nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
+        realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
+        realm.commitTransaction();
+
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedByte.class).first().getName());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_boxedShortPrimaryKeyFieldIsNull() {
+        final String SECONDARY_FIELD_VALUE = "nullShortPrimaryKeyObj";
+        final String SECONDARY_FIELD_UPDATED = "nullShortPrimaryKeyObjUpdated";
+        PrimaryKeyAsBoxedShort nullPrimaryKeyObj = TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, SECONDARY_FIELD_VALUE);
+
+        RealmResults<PrimaryKeyAsBoxedShort> result = realm.allObjects(PrimaryKeyAsBoxedShort.class);
+        assertEquals(1, result.size());
+        assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
+        assertEquals(null, result.first().getId());
+
+        // update objects
+        realm.beginTransaction();
+        nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
+        realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
+        realm.commitTransaction();
+
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedShort.class).first().getName());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_boxedIntegerPrimaryKeyFieldIsNull() {
+        final String SECONDARY_FIELD_VALUE = "nullIntegerPrimaryKeyObj";
+        final String SECONDARY_FIELD_UPDATED = "nullIntegerPrimaryKeyObjUpdated";
+        PrimaryKeyAsBoxedInteger nullPrimaryKeyObj = TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, SECONDARY_FIELD_VALUE);
+
+        RealmResults<PrimaryKeyAsBoxedInteger> result = realm.allObjects(PrimaryKeyAsBoxedInteger.class);
+        assertEquals(1, result.size());
+        assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
+        assertEquals(null, result.first().getId());
+
+        // update objects
+        realm.beginTransaction();
+        nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
+        realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
+        realm.commitTransaction();
+
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedInteger.class).first().getName());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_boxedLongPrimaryKeyFieldIsNull() {
+        final String SECONDARY_FIELD_VALUE = "nullLongPrimaryKeyObj";
+        final String SECONDARY_FIELD_UPDATED = "nullLongPrimaryKeyObjUpdated";
+        PrimaryKeyAsBoxedLong nullPrimaryKeyObj = TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, SECONDARY_FIELD_VALUE);
+
+        RealmResults<PrimaryKeyAsBoxedLong> result = realm.allObjects(PrimaryKeyAsBoxedLong.class);
+        assertEquals(1, result.size());
+        assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
+        assertEquals(null, result.first().getId());
+
+        // update objects
+        realm.beginTransaction();
+        nullPrimaryKeyObj.setName(SECONDARY_FIELD_UPDATED);
+        realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
+        realm.commitTransaction();
+
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedLong.class).first().getName());
     }
 
     @Test
@@ -1430,7 +1483,7 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(2, realm.allObjects(PrimaryKeyAsLong.class).size());
+        assertEquals(2, realm.where(PrimaryKeyAsLong.class).count());
     }
 
     @Test
@@ -1466,8 +1519,8 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
 
         // Check that the the only element has all its properties updated
         assertEquals("Bar", obj.getColumnString());
@@ -1502,7 +1555,7 @@ public void copyToRealmOrUpdate_cyclicObject() {
         realm.copyToRealmOrUpdate(oneCyclicType);
         realm.commitTransaction();
 
-        assertEquals(2, realm.allObjects(CyclicTypePrimaryKey.class).size());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
         assertEquals("Three", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getName());
     }
 
@@ -1531,9 +1584,9 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
 
-        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertNull(obj.getColumnString());
         assertEquals(1, obj.getColumnLong());
         assertEquals(0.0F, obj.getColumnFloat(), 0);
@@ -1566,8 +1619,8 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals(4, realm.allObjects(DogPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        assertEquals(4, realm.where(DogPrimaryKey.class).count());
     }
 
     @Test
@@ -1621,8 +1674,8 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
-        assertEquals("Baz", realm.allObjects(PrimaryKeyAsLong.class).first().getName());
+        assertEquals(1, realm.where(PrimaryKeyAsLong.class).count());
+        assertEquals("Baz", realm.where(PrimaryKeyAsLong.class).findFirst().getName());
     }
 
     // Tests that a collection of objects with references all gets copied.
@@ -1642,8 +1695,8 @@ public void copyToRealmOrUpdate_iterableChildObjects() {
         realm.copyToRealmOrUpdate(Arrays.asList(allTypes1, allTypes2));
         realm.commitTransaction();
 
-        assertEquals(2, realm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals(1, realm.allObjects(DogPrimaryKey.class).size());
+        assertEquals(2, realm.where(AllTypesPrimaryKey.class).count());
+        assertEquals(1, realm.where(DogPrimaryKey.class).count());
     }
 
     @Test
@@ -1969,18 +2022,18 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
         try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
 
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (RealmException expected) {}
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (RealmException expected) {}
+        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (IllegalStateException expected) {}
+        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (IllegalStateException expected) {}
         try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);       fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
 
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (RealmException expected) {}
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (RealmException expected) {}
+        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (IllegalStateException expected) {}
+        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (IllegalStateException expected) {}
         try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);          fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (RealmException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (RealmException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (IllegalStateException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
     }
 
@@ -2055,6 +2108,172 @@ public void createObject_cannotCreateDynamicRealmObject() {
         }
     }
 
+    @Test
+    public void createObjectWithPrimaryKey() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 42);
+        assertEquals(1, realm.where(AllJavaTypes.class).count());
+        assertEquals(42, obj.getFieldLong());
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_noPrimaryKeyField() {
+        realm.beginTransaction();
+        try {
+            realm.createObject(AllTypes.class, 42);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_wrongValueType() {
+        realm.beginTransaction();
+        try {
+            realm.createObject(AllJavaTypes.class, "fortyTwo");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_valueAlreadyExists() {
+        realm.beginTransaction();
+        realm.createObject(AllJavaTypes.class, 42);
+        try {
+            realm.createObject(AllJavaTypes.class, 42);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_null() {
+        // Byte
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedByte primaryKeyAsBoxedByte= realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedByte.class).count());
+        assertNull(primaryKeyAsBoxedByte.getId());
+
+        // Short
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedShort primaryKeyAsBoxedShort = realm.createObject(PrimaryKeyAsBoxedShort.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedShort.class).count());
+        assertNull(primaryKeyAsBoxedShort.getId());
+
+        // Integer
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedInteger primaryKeyAsBoxedInteger = realm.createObject(PrimaryKeyAsBoxedInteger.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedInteger.class).count());
+        assertNull(primaryKeyAsBoxedInteger.getId());
+
+        // Long
+        realm.beginTransaction();
+        PrimaryKeyAsBoxedLong primaryKeyAsBoxedLong = realm.createObject(PrimaryKeyAsBoxedLong.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsBoxedLong.class).count());
+        assertNull(primaryKeyAsBoxedLong.getId());
+
+        // String
+        realm.beginTransaction();
+        PrimaryKeyAsString primaryKeyAsString = realm.createObject(PrimaryKeyAsString.class, null);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(PrimaryKeyAsString.class).count());
+        assertNull(primaryKeyAsString.getName());
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_nullOnRequired() {
+        realm.beginTransaction();
+
+        // Byte
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedByte.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Short
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedShort.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Integer
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedInteger.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Long
+        try {
+            realm.createObject(PrimaryKeyRequiredAsBoxedLong.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // String
+        try {
+            realm.createObject(PrimaryKeyRequiredAsString.class, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        realm.cancelTransaction();
+    }
+
+    @Test
+    public void createObjectWithPrimaryKey_nullDuplicated() {
+        realm.beginTransaction();
+
+        // Byte
+        realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // Short
+        realm.createObject(PrimaryKeyAsBoxedShort.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedShort.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // Integer
+        realm.createObject(PrimaryKeyAsBoxedInteger.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedInteger.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // Long
+        realm.createObject(PrimaryKeyAsBoxedLong.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsBoxedLong.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        // String
+        realm.createObject(PrimaryKeyAsString.class, null);
+        try {
+            realm.createObject(PrimaryKeyAsString.class, null);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        }
+
+        realm.cancelTransaction();
+    }
+
     // Test close Realm in another thread different from where it is created.
     @Test
     public void close_differentThread() throws InterruptedException {
@@ -2165,19 +2384,25 @@ public void run() {
         }
     }
 
-    // FIXME HandlerThread
+    // This test assures that calling refresh will not trigger local listeners until after the Looper receives a
+    // REALM_CHANGE message
     @Test
-    public void processLocalListenersAfterRefresh() throws InterruptedException {
+    public void processRefreshLocalListenersAfterLooperQueueStart() throws Throwable {
         // Used to validate the result
         final AtomicBoolean listenerWasCalled = new AtomicBoolean(false);
         final AtomicBoolean typeListenerWasCalled = new AtomicBoolean(false);
 
         // Used by the background thread to wait for the main thread to do the write operation
         final CountDownLatch bgThreadLatch = new CountDownLatch(1);
-        final CountDownLatch bgClosedLatch = new CountDownLatch(1);
+        final CountDownLatch bgClosedLatch = new CountDownLatch(2);
         final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
+        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
 
-        Thread backgroundThread = new Thread() {
+        final Looper[] looper = new Looper[1];
+        final Throwable[] throwable = new Throwable[1];
+
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
             @Override
             public void run() {
                 // this will allow to register a listener.
@@ -2185,42 +2410,43 @@ public void run() {
                 // the handler mechanism, the purpose of this test is to make sure refresh calls
                 // the listeners.
                 Looper.prepare();
+                looper[0] = Looper.myLooper();
 
                 Realm bgRealm = Realm.getInstance(realmConfig);
                 RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
                 try {
-                    bgRealm.addChangeListener(new RealmChangeListener() {
+                    bgRealm.addChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             listenerWasCalled.set(true);
+                            bgClosedLatch.countDown();
                         }
                     });
-                    dogs.addChangeListener(new RealmChangeListener() {
+                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<Dog> object) {
                             typeListenerWasCalled.set(true);
+                            bgClosedLatch.countDown();
                         }
                     });
 
                     bgThreadReadyLatch.countDown();
                     bgThreadLatch.await(); // Wait for the main thread to do a write operation
                     bgRealm.refresh(); // This should call the listener
-                    assertTrue(listenerWasCalled.get());
-                    assertTrue(typeListenerWasCalled.get());
-                    bgRealm.close();
-                    bgRealm = null;
-                    // DON'T count down in the final block! The test will fail silently!!!
-                    bgClosedLatch.countDown();
-                } catch (InterruptedException e) {
-                    fail(e.getMessage());
+                    assertFalse(listenerWasCalled.get());
+                    assertFalse(typeListenerWasCalled.get());
+
+                    Looper.loop();
+
+                } catch (Throwable e) {
+                    throwable[0] = e;
+
                 } finally {
-                    if (bgRealm != null) {
-                        bgRealm.close();
-                    }
+                    bgRealm.close();
+                    signalClosedRealm.countDown();
                 }
             }
-        };
-        backgroundThread.start();
+        });
 
         // Wait until bgThread finishes adding listener to the RealmResults. Otherwise same TableView version won't
         // trigger the listener.
@@ -2230,258 +2456,16 @@ public void onChange() {
         realm.commitTransaction();
         bgThreadLatch.countDown();
         bgClosedLatch.await();
+
+        TestHelper.exitOrThrow(executorService, bgClosedLatch, signalClosedRealm, looper, throwable);
+
+        assertTrue(listenerWasCalled.get());
+        assertTrue(typeListenerWasCalled.get());
     }
 
-    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
-            for (int j = 0; j < numberOfBlocks; j++) {
-                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
-                obj.setIndexBoolean(j % 2 == 0);
-                obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * (long) j));
-                obj.setIndexString(withNull ? null : "Test " + j);
-                obj.setNotIndexBoolean(j % 2 == 0);
-                obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * (long) j));
-                obj.setNotIndexString(withNull ? null : "Test " + j);
-            }
-        }
-        realm.commitTransaction();
-    }
-
-    private void populateForDistinctInvalidTypesLinked(Realm realm) {
-        realm.beginTransaction();
-        AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        notEmpty.setFieldObject(notEmpty);
-        notEmpty.setFieldList(new RealmList<AllJavaTypes>(notEmpty));
-        realm.copyToRealm(notEmpty);
-        realm.commitTransaction();
-    }
-
-    // Realm.distinct(): requires indexing, and type = boolean, integer, date, string
-    @Test
-    public void distinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        assertEquals(2, distinctBool.size());
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.distinct(AnnotationIndexTypes.class, field);
-            assertEquals(field, numberOfBlocks, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.distinct(AnnotationIndexTypes.class, field);
-            assertEquals(field, 1, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_notIndexedFieldsThrows() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.distinct(AnnotationIndexTypes.class, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_unknownFieldThrows() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-        thrown.expect(IllegalArgumentException.class);
-
-        realm.distinct(AnnotationIndexTypes.class, "doesNotExist");
-    }
-
-    @Test
-    public void distinct_invalidTypeThrows() {
-        populateTestRealm();
-
-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
-            try {
-                realm.distinct(AllTypes.class, field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> distinctMulti = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
-        assertEquals(numberOfBlocks, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_switchedFieldsOrder() {
-        final long numberOfBlocks = 25;
-        TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
-
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
-        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<AnnotationIndexTypes> distinctLongString = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(4, distinctStringLong.size());
-        assertEquals(4, distinctLongString.size());
-        assertEquals(distinctStringLong.size(), distinctLongString.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_emptyFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        // an empty string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // an empty string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field in the middle
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // a null string field at the end
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // (String)null makes varargs a null array.
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two (String)null for first and varargs fields
-        try {
-            realm.distinct(AnnotationIndexTypes.class, (String)null, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.class, "", (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination
-        try {
-            realm.distinct(AnnotationIndexTypes.class, (String)null, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two empty fields tests
-        try {
-            realm.distinct(AnnotationIndexTypes.class, "", "");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<AnnotationIndexTypes> distinctMulti = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(1, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_doesNotExistField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesFields() {
-        populateTestRealm();
-
-        try {
-            realm.distinct(AllTypes.class, AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        try {
-            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        try {
-            realm.distinct(AllJavaTypes.class, AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void isInTransaction() {
-        assertFalse(realm.isInTransaction());
+    @Test
+    public void isInTransaction() {
+        assertFalse(realm.isInTransaction());
         realm.beginTransaction();
         assertTrue(realm.isInTransaction());
         realm.commitTransaction();
@@ -2791,7 +2775,7 @@ public void copyFromRealm_list_invalidListThrows() {
 
     @Test
     public void copyFromRealm_list_invalidDepthThrows() {
-        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         thrown.expect(IllegalArgumentException.class);
         realm.copyFromRealm(results, -1);
     }
@@ -2861,9 +2845,9 @@ public void closeRealmInChangeListener() {
             @Override
             public void run() {
                 final Realm realm = Realm.getInstance(realmConfig);
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         if (realm.where(AllTypes.class).count() == 1) {
                             realm.removeChangeListener(this);
                             realm.close();
@@ -2890,16 +2874,16 @@ public void execute(Realm realm) {
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject() {
         final Realm realm = Realm.getInstance(looperThread.createConfiguration());
-        final RealmChangeListener dummyListener = new RealmChangeListener() {
+        final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
             }
         };
 
         // Change listener on Realm
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(AllTypes.class).count() == 1) {
                     realm.removeChangeListener(this);
                     realm.close();
@@ -2931,14 +2915,14 @@ public void execute(Realm realm) {
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnObject() {
         final Realm realm = Realm.getInstance(looperThread.createConfiguration());
-        final RealmChangeListener dummyListener = new RealmChangeListener() {
+        final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
             }
         };
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(AllTypes.class).count() == 2) {
                     realm.removeChangeListener(this);
                     realm.close();
@@ -2976,14 +2960,14 @@ public void execute(Realm realm) {
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnResults() {
         final Realm realm = Realm.getInstance(looperThread.createConfiguration());
-        final RealmChangeListener dummyListener = new RealmChangeListener() {
+        final RealmChangeListener<RealmResults<AllTypes>> dummyListener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
             }
         };
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(AllTypes.class).count() == 1) {
                     realm.removeChangeListener(this);
                     realm.close();
@@ -3019,9 +3003,9 @@ public void removeChangeListenerThrowExceptionOnNonLooperThread() {
             public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 try {
-                    realm.removeChangeListener(new RealmChangeListener() {
+                    realm.removeChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                         }
                     });
                     fail("Should not be able to invoke removeChangeListener");
@@ -3087,4 +3071,353 @@ public void deleteAll() {
         assertEquals(0, realm.where(Cat.class).count());
         assertTrue(realm.isEmpty());
     }
+
+    @Test
+    public void waitForChange_emptyDataChange() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
+
+        // wait in background
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        realm.beginTransaction();
+        realm.commitTransaction();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertTrue(bgRealmChangeResult.get());
+        assertEquals(0, bgRealmWaitForChangeResult.get());
+    }
+
+    @Test
+    public void waitForChange_withDataChange() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
+
+        // wait in background
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertTrue(bgRealmChangeResult.get());
+        assertEquals(TEST_DATA_SIZE, bgRealmWaitForChangeResult.get());
+    }
+
+    @Test
+    public void waitForChange_syncBackgroundRealmResults() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmResultSize = new AtomicLong(0);
+
+        // wait in background
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+                // first make sure the results is empty
+                bgRealmResultSize.set(results.size());
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmResultSize.set(results.size());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        // background result should be empty
+        assertEquals(0, bgRealmResultSize.get());
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertTrue(bgRealmChangeResult.get());
+        // Once RealmResults are synchronized after waitForChange, the result size should be what we expect
+        assertEquals(TEST_DATA_SIZE, bgRealmResultSize.get());
+    }
+
+    @Test
+    public void stopWaitForChange() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(true);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        Thread.sleep(200);
+        bgRealm.get().stopWaitForChange();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertFalse(bgRealmChangeResult.get());
+    }
+
+    // Test if waitForChange doesn't blocks once stopWaitForChange has been called before.
+    @Test
+    public void waitForChange_stopWaitForChangeDisablesWaiting() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmStopped = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmFirstWaitResult = new AtomicBoolean(true);
+        final AtomicBoolean bgRealmSecondWaitResult = new AtomicBoolean(false);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmOpened.countDown();
+                bgRealmFirstWaitResult.set(realm.waitForChange());
+                bgRealmStopped.countDown();
+                bgRealmSecondWaitResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        bgRealm.get().stopWaitForChange();
+        TestHelper.awaitOrFail(bgRealmStopped);
+        assertFalse(bgRealmFirstWaitResult.get());
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertFalse(bgRealmSecondWaitResult.get());
+    }
+
+    // Test if waitForChange still blocks if stopWaitForChange has been called for a realm in a different thread.
+    @Test
+    public void waitForChange_blockSpecificThreadOnly() throws InterruptedException {
+        final CountDownLatch bgRealmsOpened = new CountDownLatch(2);
+        final CountDownLatch bgRealmsClosed = new CountDownLatch(2);
+        final AtomicBoolean bgRealmFirstWaitResult = new AtomicBoolean(true);
+        final AtomicBoolean bgRealmSecondWaitResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        Thread thread1 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmsOpened.countDown();
+                bgRealmFirstWaitResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmsClosed.countDown();
+            }
+        });
+
+        Thread thread2 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealmsOpened.countDown();
+                bgRealmSecondWaitResult.set(realm.waitForChange());
+                bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmsClosed.countDown();
+            }
+        });
+        thread1.start();
+        thread2.start();
+
+        TestHelper.awaitOrFail(bgRealmsOpened);
+        bgRealm.get().stopWaitForChange();
+        // wait for Thread 2 to wait
+        Thread.sleep(500);
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmsClosed);
+        assertFalse(bgRealmFirstWaitResult.get());
+        assertTrue(bgRealmSecondWaitResult.get());
+        assertEquals(TEST_DATA_SIZE, bgRealmWaitForChangeResult.get());
+    }
+
+    // Check if waitForChange() does not respond to Thread.interrupt().
+    @Test
+    public void waitForChange_interruptingThread() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicReference<Boolean> bgRealmWaitResult = new AtomicReference<Boolean>();
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmOpened.countDown();
+                bgRealmWaitResult.set(new Boolean(realm.waitForChange()));
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        // make sure background thread goes to wait
+        Thread.sleep(500);
+        // interrupting a thread should neither cause any side effect nor terminate the Background Realm from waiting.
+        thread.interrupt();
+        assertTrue(thread.isInterrupted());
+        assertEquals(null, bgRealmWaitResult.get());
+
+        // now we'll stop realm from waiting
+        bgRealm.get().stopWaitForChange();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertFalse(bgRealmWaitResult.get().booleanValue());
+    }
+
+    @Test
+    public void waitForChange_onLooperThread() throws Throwable {
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final ExceptionHolder bgError = new ExceptionHolder();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(realmConfig);
+                try {
+                    realm.waitForChange();
+                    fail();
+                } catch (Throwable expected) {
+                    bgError.setException(expected);
+                } finally {
+                    realm.close();
+                    bgRealmClosed.countDown();
+                }
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmClosed);
+        if (bgError.getException() instanceof AssertionError) {
+            throw bgError.getException();
+        }
+        assertEquals(IllegalStateException.class, bgError.getException().getClass());
+    }
+
+    // Cannot wait inside of a transaction
+    @Test(expected= IllegalStateException.class)
+    public void waitForChange_illegalWaitInsideTransaction() {
+        realm.beginTransaction();
+        realm.waitForChange();
+    }
+
+    @Test
+    public void waitForChange_stopWaitingOnClosedRealmThrows() throws InterruptedException {
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmClosed);
+        try {
+            bgRealm.get().stopWaitForChange();
+            fail("Cannot stop a closed Realm from waiting");
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    // waitForChange & stopWaitForChange within a simple Thread wrapper.
+    @Test
+    public void waitForChange_runWithRealmThread() throws InterruptedException {
+        final CountDownLatch bgRealmStarted = new CountDownLatch(1);
+        final CountDownLatch bgRealmFished = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmResultSize = new AtomicLong(0);
+
+        RealmThread thread = new RealmThread(realmConfig, new RealmThread.RealmRunnable() {
+            @Override
+            public void run(Realm realm) {
+                bgRealmStarted.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmResultSize.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmFished.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmStarted);
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmFished);
+        assertTrue(bgRealmChangeResult.get());
+        assertEquals(TEST_DATA_SIZE, bgRealmResultSize.get());
+    }
+
+    @Test
+    public void waitForChange_endRealmThread() throws InterruptedException {
+        final CountDownLatch bgRealmStarted = new CountDownLatch(1);
+        final CountDownLatch bgRealmFished = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(true);
+
+        RealmThread thread = new RealmThread(realmConfig, new RealmThread.RealmRunnable() {
+            @Override
+            public void run(Realm realm) {
+                bgRealmStarted.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmFished.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmStarted);
+        thread.end();
+        TestHelper.awaitOrFail(bgRealmFished);
+        assertFalse(bgRealmChangeResult.get());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 5835953c0e..7c787c5f59 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -16,13 +16,39 @@
 
 package io.realm;
 
-import android.test.AndroidTestCase;
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
 import io.realm.internal.TableView;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SortTest {
+    private Realm realm;
 
-public class SortTest extends AndroidTestCase {
-    private Realm testRealm = null;
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private Context context;
+    private RealmConfiguration realmConfig;
 
     private final static String FIELD_STRING = "columnString";
     private final static String FIELD_LONG = "columnLong";
@@ -33,44 +59,54 @@
     private final static Sort[] ORDER_ASC_ASC = {Sort.ASCENDING, Sort.ASCENDING};
     private final static Sort[] ORDER_ASC_DES = {Sort.ASCENDING, Sort.DESCENDING};
 
-    @Override
-    public void setUp() {
-        // Creates a Realm with the following objects:
-        // 0: (5, "Adam")
-        // 1: (4, "Brian")
-        // 2: (4, "Adam")
-        // 3: (5, "Adam")
-        RealmConfiguration config = TestHelper.createConfiguration(getContext());
-        Realm.deleteRealm(config);
-        testRealm = Realm.getInstance(config);
-
-        testRealm.beginTransaction();
-        testRealm.delete(AllTypes.class);
-        AllTypes object1 = testRealm.createObject(AllTypes.class);
+    private void populateRealm(Realm realm) {
+        realm.beginTransaction();
+        realm.delete(AllTypes.class);
+        AllTypes object1 = realm.createObject(AllTypes.class);
         object1.setColumnLong(5);
         object1.setColumnString("Adam");
 
-        AllTypes object2 = testRealm.createObject(AllTypes.class);
+        AllTypes object2 = realm.createObject(AllTypes.class);
         object2.setColumnLong(4);
         object2.setColumnString("Brian");
 
-        AllTypes object3 = testRealm.createObject(AllTypes.class);
+        AllTypes object3 = realm.createObject(AllTypes.class);
         object3.setColumnLong(4);
         object3.setColumnString("Adam");
 
-        AllTypes object4 = testRealm.createObject(AllTypes.class);
+        AllTypes object4 = realm.createObject(AllTypes.class);
         object4.setColumnLong(5);
         object4.setColumnString("Adam");
-        testRealm.commitTransaction();
+        realm.commitTransaction();
+    }
+
+    @Before
+    public void setUp() {
+        // Creates a Realm with the following objects:
+        // 0: (5, "Adam")
+        // 1: (4, "Brian")
+        // 2: (4, "Adam")
+        // 3: (5, "Adam")
+
+        // Injecting the Instrumentation instance is required
+        // for your test to run with AndroidJUnitRunner.
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+        realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+
+        populateRealm(realm);
     }
 
-    @Override
-    public void tearDown() throws Exception {
-        testRealm.close();
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
     }
 
-    public void testSortMultiFailures() {
-        RealmResults<AllTypes> allTypes = testRealm.allObjects(AllTypes.class);
+    @Test
+    public void sortMultiFailures() {
+        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
 
         // zero fields specified
         try {
@@ -88,7 +124,7 @@ public void testSortMultiFailures() {
 
         // null is not allowed
         try {
-            allTypes.sort(null, (Sort[])null);
+            allTypes.sort(null, (Sort[]) null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -117,19 +153,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -143,19 +179,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -169,19 +205,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -195,108 +231,285 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
-    public void testSortRealmResultsTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.allObjects(AllTypes.class).sort(ORDER_STRING_INT, ORDER_ASC_ASC);
+    @Test
+    public void sortRealmResultsTwoFields() {
+        RealmResults<AllTypes> results1 = realm.where(AllTypes.class).findAll().sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.allObjects(AllTypes.class).sort(ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = realm.where(AllTypes.class).findAll().sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.allObjects(AllTypes.class).sort(ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = realm.where(AllTypes.class).findAll().sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.allObjects(AllTypes.class).sort(ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = realm.where(AllTypes.class).findAll().sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
-   }
-
+    }
 
-    public void testRealmQuerySortTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_STRING_INT, ORDER_ASC_ASC);
+    @Test
+    public void realmQuerySortTwoFields() {
+        RealmResults<AllTypes> results1 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
     }
 
-    public void testRealmSortTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_STRING_INT, ORDER_ASC_ASC);
+    @Test
+    public void realmSortTwoFields() {
+        RealmResults<AllTypes> results1 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
     }
 
-    public void testRealmSortMultiFailures() {
-        RealmResults<AllTypes> allTypes = testRealm.allObjects(AllTypes.class);
+    @Test
+    public void realmSortMultiFailures() {
+        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
 
         // zero fields specified
         try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{}, new Sort[]{});
+            realm.where(AllTypes.class).findAll().sort(new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // number of fields and sorting orders don't match
         try {
-            testRealm.allObjectsSorted(AllTypes.class,
-                    new String[]{FIELD_STRING}, ORDER_ASC_ASC);
+            realm.where(AllTypes.class).findAll().
+                    sort(new String[]{FIELD_STRING}, ORDER_ASC_ASC);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // null is not allowed
         try {
-            testRealm.allObjectsSorted(AllTypes.class, null, (Sort[])null);
+            realm.where(AllTypes.class).findAll().sort(null, (Sort[]) null);
             fail();
-        } catch (IllegalArgumentException ignored) {}
+        } catch (IllegalArgumentException ignored) {
+        }
         try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{FIELD_STRING}, null);
+            realm.where(AllTypes.class).findAll().sort(new String[]{FIELD_STRING}, null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // non-existing field name
         try {
-            testRealm.allObjectsSorted(AllTypes.class,
-                    new String[]{FIELD_STRING, "dont-exist"},
-                    ORDER_ASC_ASC);
+            realm.where(AllTypes.class).findAll().
+                    sort(new String[]{FIELD_STRING, "dont-exist"}, ORDER_ASC_ASC);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void resorting() throws InterruptedException {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
+
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        realm.setAutoRefresh(true);
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        // 0: (5, "Adam")
+        // 1: (4, "Brian")
+        // 2: (4, "Adam")
+        // 3: (5, "Adam")
+        populateRealm(realm);
+
+        // rr0: [0, 1, 2, 3]
+        final RealmResults<AllTypes> rr0 = realm.where(AllTypes.class).findAll();
+        rr0.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                // After commit: [0, 1, 2, 3, 4] - most likely as order isn't guaranteed
+                assertEquals(5, element.size());
+                endTest.run();
+            }
+        });
+
+        // rr1: [1, 2, 0, 3]
+        final RealmResults<AllTypes> rr1 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.ASCENDING);
+        rr1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                // After commit: [1, 2, 0, 3, 4]
+                assertEquals(4, element.first().getColumnLong());
+                assertEquals(6, element.last().getColumnLong());
+                assertEquals(5, element.size());
+                endTest.run();
+            }
+        });
+        assertEquals(4, rr1.first().getColumnLong());
+        assertEquals(5, rr1.last().getColumnLong());
+
+        // rr2: [0, 3, 1, 2]
+        final RealmResults<AllTypes> rr2 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.DESCENDING);
+        rr2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                // After commit: [4, 0, 3, 1, 2]
+                assertEquals(6, element.first().getColumnLong());
+                assertEquals(4, element.last().getColumnLong());
+                assertEquals(5, element.size());
+                endTest.run();
+            }
+        });
+        assertEquals(5, rr2.first().getColumnLong());
+        assertEquals(4, rr2.last().getColumnLong());
+
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                assertEquals(5, element.where(AllTypes.class).findAll().size());
+                endTest.run();
+            }
+        });
+
+        // After commit:
+        // 0: (5, "Adam")
+        // 1: (4, "Brian")
+        // 2: (4, "Adam")
+        // 3: (5, "Adam")
+        // 4: (6, "")
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnLong(6);
+        realm.commitTransaction();
+    }
+
+    private void populateDates(Realm realm, int n) {
+        realm.beginTransaction();
+        realm.delete(AllTypes.class);
+        for (int i = 0; i < n; i++) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnDate(new Date(i));
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void sortingDates() {
+        final int TEST_SIZE = 10;
+
+        populateDates(realm, TEST_SIZE);
+
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, objectsAscending.size());
+        int i = 0;
+        for (AllTypes allTypes : objectsAscending) {
+            assertEquals(new Date(i), allTypes.getColumnDate());
+            i++;
+        }
+
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, objectsDescending.size());
+        i = TEST_SIZE - 1;
+        for (AllTypes allTypes : objectsDescending) {
+            assertEquals(new Date(i), allTypes.getColumnDate());
+            i--;
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void resortingDates() {
+        final int TEST_SIZE = 10;
+        final AtomicInteger changeListenerCalled = new AtomicInteger(2);
+
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        realm.setAutoRefresh(true);
+        populateDates(realm, TEST_SIZE);
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, objectsAscending.size());
+        objectsAscending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                assertEquals(TEST_SIZE + 1, element.size());
+                int i = 0;
+                for (AllTypes allTypes : element) {
+                    assertEquals(new Date(i), allTypes.getColumnDate());
+                    i++;
+                }
+                endTest.run();
+            }
+        });
+
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, objectsDescending.size());
+        objectsDescending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                assertEquals(TEST_SIZE + 1, element.size());
+                int i = element.size() - 1;
+                for (AllTypes allTypes : element) {
+                    assertEquals(new Date(i), allTypes.getColumnDate());
+                    i--;
+                }
+                endTest.run();
+            }
+        });
+
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnDate(new Date(TEST_SIZE));
+        realm.commitTransaction();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 17b3d20362..ce5f00c14c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -46,6 +46,11 @@
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.NullTypes;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
@@ -385,6 +390,171 @@ public static RealmConfiguration createConfiguration(File dir, String name, byte
         return config.build();
     }
 
+    /**
+     * Adds a String type PrimaryKey object to a realm with values for name field (PrimaryKey) and id field
+     */
+    public static PrimaryKeyAsString addStringPrimaryKeyObjectToTestRealm(Realm testRealm, String primaryFieldValue, long secondaryFieldValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsString obj = new PrimaryKeyAsString();
+        obj.setName(primaryFieldValue);
+        obj.setId(secondaryFieldValue);
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    /**
+     * Populates a realm with String type Primarykey objects for a number of numberOfPopulation - 1,
+     * starting with iteratorBeginValue. One object is setup to have given values from parameters.
+     */
+    public static void populateTestRealmWithStringPrimaryKey(Realm testRealm, String primaryFieldValue, long secondaryFieldValue, int numberOfPopulation, int iteratorBeginValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsString userObj = new PrimaryKeyAsString();
+        userObj.setName(primaryFieldValue);
+        userObj.setId(secondaryFieldValue);
+        testRealm.copyToRealm(userObj);
+        int idValue = iteratorBeginValue;
+        for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
+            PrimaryKeyAsString obj = new PrimaryKeyAsString();
+            obj.setName(String.valueOf(idValue));
+            obj.setId(idValue);
+            testRealm.copyToRealm(obj);
+        }
+        testRealm.commitTransaction();
+    }
+
+    /**
+     * Adds a Byte type PrimaryKey object to a realm with values for id field (PrimaryKey) and name field
+     */
+    public static PrimaryKeyAsBoxedByte addBytePrimaryKeyObjectToTestRealm(Realm testRealm, Byte primaryFieldValue, String secondaryFieldValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedByte obj = new PrimaryKeyAsBoxedByte();
+        obj.setId(primaryFieldValue);
+        obj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    /**
+     * Populates a realm with Byte type Primarykey objects for a number of numberOfPopulation - 1,
+     * starting with iteratorBeginValue. One object is setup to have given values from parameters.
+     */
+    public static void populateTestRealmWithBytePrimaryKey(Realm testRealm, Byte primaryFieldValue, String secondaryFieldValue, int numberOfPopulation, int iteratorBeginValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedByte userObj = new PrimaryKeyAsBoxedByte();
+        userObj.setId(primaryFieldValue);
+        userObj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(userObj);
+        byte idValue = (byte)iteratorBeginValue;
+        for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
+            PrimaryKeyAsBoxedByte obj = new PrimaryKeyAsBoxedByte();
+            obj.setId(new Byte(idValue));
+            obj.setName(String.valueOf(idValue));
+            testRealm.copyToRealm(obj);
+        }
+        testRealm.commitTransaction();
+    }
+
+    /**
+     * Adds a Short type PrimaryKey object to a realm with values for id field (PrimaryKey) and name field
+     */
+    public static PrimaryKeyAsBoxedShort addShortPrimaryKeyObjectToTestRealm(Realm testRealm, Short primaryFieldValue, String secondaryFieldValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedShort obj = new PrimaryKeyAsBoxedShort();
+        obj.setId(primaryFieldValue);
+        obj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    /**
+     * Populates a realm with Short type Primarykey objects for a number of numberOfPopulation - 1,
+     * starting with iteratorBeginValue. One object is setup to have given values from parameters.
+     */
+    public static void populateTestRealmWithShortPrimaryKey(Realm testRealm, Short primaryFieldValue, String secondaryFieldValue, int numberOfPopulation, int iteratorBeginValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedShort userObj = new PrimaryKeyAsBoxedShort();
+        userObj.setId(primaryFieldValue);
+        userObj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(userObj);
+        short idValue = (short)iteratorBeginValue;
+        for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
+            PrimaryKeyAsBoxedShort obj = new PrimaryKeyAsBoxedShort();
+            obj.setId(new Short(idValue));
+            obj.setName(String.valueOf(idValue));
+            testRealm.copyToRealm(obj);
+        }
+        testRealm.commitTransaction();
+    }
+
+    /**
+     * Adds a Integer type PrimaryKey object to a realm with values for id field (PrimaryKey) and name field
+     */
+    public static PrimaryKeyAsBoxedInteger addIntegerPrimaryKeyObjectToTestRealm(Realm testRealm, Integer primaryFieldValue, String secondaryFieldValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedInteger obj = new PrimaryKeyAsBoxedInteger();
+        obj.setId(primaryFieldValue);
+        obj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    /**
+     * Populates a realm with Integer type Primarykey objects for a number of numberOfPopulation - 1,
+     * starting with iteratorBeginValue. One object is setup to have given values from parameters.
+     */
+    public static void populateTestRealmWithIntegerPrimaryKey(Realm testRealm, Integer primaryFieldValue, String secondaryFieldValue, int numberOfPopulation, int iteratorBeginValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedInteger userObj = new PrimaryKeyAsBoxedInteger();
+        userObj.setId(primaryFieldValue);
+        userObj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(userObj);
+        int idValue = iteratorBeginValue;
+        for (int i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
+            PrimaryKeyAsBoxedInteger obj = new PrimaryKeyAsBoxedInteger();
+            obj.setId(new Integer(idValue));
+            obj.setName(String.valueOf(idValue));
+            testRealm.copyToRealm(obj);
+        }
+        testRealm.commitTransaction();
+    }
+
+    /**
+     * Adds a Long type PrimaryKey object to a realm with values for id field (PrimaryKey) and name field
+     */
+    public static PrimaryKeyAsBoxedLong addLongPrimaryKeyObjectToTestRealm(Realm testRealm, Long primaryFieldValue, String secondaryFieldValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedLong obj = new PrimaryKeyAsBoxedLong();
+        obj.setId(primaryFieldValue);
+        obj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    /**
+     * Populates a realm with Long type Primarykey objects for a number of numberOfPopulation - 1,
+     * starting with iteratorBeginValue. One object is setup to have given values from parameters.
+     */
+    public static void populateTestRealmWithLongPrimaryKey(Realm testRealm, Long primaryFieldValue, String secondaryFieldValue, long numberOfPopulation, long iteratorBeginValue) {
+        testRealm.beginTransaction();
+        PrimaryKeyAsBoxedLong userObj = new PrimaryKeyAsBoxedLong();
+        userObj.setId(primaryFieldValue);
+        userObj.setName(secondaryFieldValue);
+        testRealm.copyToRealm(userObj);
+        long idValue = iteratorBeginValue;
+        for (long i = 0; i < numberOfPopulation - 1; ++i, ++idValue) {
+            PrimaryKeyAsBoxedLong obj = new PrimaryKeyAsBoxedLong();
+            obj.setId(new Long(idValue));
+            obj.setName(String.valueOf(idValue));
+            testRealm.copyToRealm(obj);
+        }
+        testRealm.commitTransaction();
+    }
+
     public static void populateTestRealmForNullTests(Realm testRealm) {
 
         // Create 3 NullTypes objects. The objects are self-referenced (link) in
@@ -781,7 +951,7 @@ public static void quitLooperOrFail() {
      * @param executor {@link RealmThreadPoolExecutor} that should replace the current one
      */
     public static RealmThreadPoolExecutor replaceRealmThreadExectutor(RealmThreadPoolExecutor executor) throws NoSuchFieldException, IllegalAccessException {
-        Field field = BaseRealm.class.getDeclaredField("asyncQueryExecutor");
+        Field field = BaseRealm.class.getDeclaredField("asyncTaskExecutor");
         field.setAccessible(true);
         RealmThreadPoolExecutor oldExecutor = (RealmThreadPoolExecutor) field.get(null);
         field.set(field, executor);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index d6a53a17db..ce0a655d32 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -43,7 +43,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsLong;
-import io.realm.proxy.HandlerProxy;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -86,9 +86,9 @@ public void setUp() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -105,9 +105,9 @@ public void run() {
         final Dog dog = realm.createObject(Dog.class);
         realm.commitTransaction();
 
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 assertEquals("Akamaru", dog.getName());
                 typebasedCommitInvocations.incrementAndGet();
             }
@@ -122,9 +122,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject_dynamic_realm() {
         final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
             @Override
-            public void onChange() {
+            public void onChange(DynamicRealm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -142,9 +142,9 @@ public void run() {
         final DynamicRealmObject dog = realm.createObject("Dog");
         realm.commitTransaction();
 
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
-            public void onChange() {
+            public void onChange(DynamicRealmObject object) {
                 assertEquals("Akamaru", dog.getString("name"));
                 typebasedCommitInvocations.incrementAndGet();
             }
@@ -160,9 +160,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealm() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -181,9 +181,9 @@ public void run() {
         final Dog dog = realm.copyToRealm(akamaru);
         realm.commitTransaction();
 
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 assertEquals(8, dog.getAge());
                 typebasedCommitInvocations.incrementAndGet();
             }
@@ -199,9 +199,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealmOrUpdate() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -222,9 +222,9 @@ public void run() {
         final PrimaryKeyAsLong primaryKeyAsLong = realm.copyToRealmOrUpdate(obj);
         realm.commitTransaction();
 
-        primaryKeyAsLong.addChangeListener(new RealmChangeListener() {
+        primaryKeyAsLong.addChangeListener(new RealmChangeListener<PrimaryKeyAsLong>() {
             @Override
-            public void onChange() {
+            public void onChange(PrimaryKeyAsLong object) {
                 assertEquals(1, primaryKeyAsLong.getId());
                 assertEquals("Bar", primaryKeyAsLong.getName());
                 assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
@@ -247,9 +247,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -269,9 +269,9 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
-            objectFromJson.addChangeListener(new RealmChangeListener() {
+            objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
-                public void onChange() {
+                public void onChange(AllTypes object) {
                     assertEquals("ObjectFromJson", objectFromJson.getColumnString());
                     assertEquals(1L, objectFromJson.getColumnLong());
                     assertEquals(1.23F, objectFromJson.getColumnFloat(), 0F);
@@ -296,9 +296,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -324,9 +324,9 @@ public void run() {
             final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, json);
             realm.commitTransaction();
 
-            objectFromJson.addChangeListener(new RealmChangeListener() {
+            objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
-                public void onChange() {
+                public void onChange(AllTypes object) {
                     assertEquals("ObjectFromJson", objectFromJson.getColumnString());
                     assertEquals(1L, objectFromJson.getColumnLong());
                     assertEquals(1.23F, objectFromJson.getColumnFloat(), 0F);
@@ -351,9 +351,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -387,9 +387,9 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
-            objectFromJson.addChangeListener(new RealmChangeListener() {
+            objectFromJson.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
                 @Override
-                public void onChange() {
+                public void onChange(AllTypesPrimaryKey object) {
                     assertEquals("ObjectFromJson", objectFromJson.getColumnString());
                     assertEquals(1L, objectFromJson.getColumnLong());
                     assertEquals(1F, objectFromJson.getColumnFloat(), 0F);
@@ -416,9 +416,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson_from_JSONObject() throws JSONException {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -446,9 +446,9 @@ public void run() {
         final AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
         realm.commitTransaction();
 
-        newObj.addChangeListener(new RealmChangeListener() {
+        newObj.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypesPrimaryKey object) {
                 assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
                 assertEquals("bar", newObj.getColumnString());
                 assertTrue(newObj.getColumnBoxedBoolean());
@@ -479,9 +479,9 @@ public void callback_with_relevant_commit_realmobject_sync() {
         realm.commitTransaction();
 
         final Dog dog = realm.where(Dog.class).findFirst();
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 // Step 4: Respond to relevant change
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals("Akamaru", dog.getName());
@@ -489,9 +489,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -537,9 +537,9 @@ public void callback_with_relevant_commit_realmobject_async() {
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
 
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1:
                         assertEquals("Akamaru", dog.getName());
@@ -554,9 +554,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -605,18 +605,18 @@ public void callback_with_relevant_commit_from_different_looper_realmobject_asyn
         final Handler looperHandler2 = new Handler(looperThread2.getLooper());
         final Handler looperHandler3 = new Handler(looperThread3.getLooper());
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 globalCommitInvocations.incrementAndGet();
             }
         });
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1: // triggered by COMPLETED_ASYNC_REALM_OBJECT from calling dog.load()
                         assertTrue(dog.isLoaded());
@@ -705,18 +705,18 @@ public void run() {
     public void callback_with_relevant_commit_from_different_non_looper_realmobject_async() throws Throwable {
         final CountDownLatch nonLooperThread3CloseLatch = new CountDownLatch(1);
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 globalCommitInvocations.incrementAndGet();
             }
         });
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1:  // triggered by COMPLETED_ASYNC_REALM_OBJECT
                         new RealmBackgroundTask(realm.configuration) {
@@ -798,9 +798,9 @@ public void callback_with_relevant_commit_realmresults_sync() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        dogs.addChangeListener(new RealmChangeListener() {
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 // Step 4: Respond to relevant change
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals(1, dogs.size());
@@ -809,9 +809,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -836,7 +836,6 @@ public void run() {
                                 looperThread.testComplete();
                             }
                         });
-
                 }
             }
         });
@@ -856,9 +855,9 @@ public void callback_with_relevant_commit_realmresults_async() {
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
-        dogs.addChangeListener(new RealmChangeListener() {
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 // Step 4: Respond to relevant change
                 int commits = typebasedCommitInvocations.incrementAndGet();
                 switch (commits) {
@@ -872,9 +871,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -899,7 +898,6 @@ public void run() {
                                 looperThread.testComplete();
                             }
                         });
-
                 }
             }
         });
@@ -915,9 +913,9 @@ public void run() {
     public void multiple_callbacks_should_be_invoked_realmobject_sync() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -934,9 +932,9 @@ public void run() {
 
         Dog dog = realm.where(Dog.class).findFirst();
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dog.addChangeListener(new RealmChangeListener() {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
-                public void onChange() {
+                public void onChange(Dog object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -953,9 +951,9 @@ public void onChange() {
     public void multiple_callbacks_should_be_invoked_realmobject_async() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -975,9 +973,9 @@ public void run() {
         Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dog.addChangeListener(new RealmChangeListener() {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
-                public void onChange() {
+                public void onChange(Dog object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -994,9 +992,9 @@ public void onChange() {
     public void multiple_callbacks_should_be_invoked_realmresults_sync() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -1013,9 +1011,9 @@ public void run() {
 
         RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dogs.addChangeListener(new RealmChangeListener() {
+            dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
-                public void onChange() {
+                public void onChange(RealmResults<Dog> object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -1032,9 +1030,9 @@ public void onChange() {
     public void multiple_callbacks_should_be_invoked_realmresults_async() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -1053,9 +1051,9 @@ public void run() {
         assertTrue(dogs.load());
 
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dogs.addChangeListener(new RealmChangeListener() {
+            dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
-                public void onChange() {
+                public void onChange(RealmResults<Dog> object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -1079,9 +1077,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_sync() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -1099,9 +1097,9 @@ public void run() {
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 typebasedCommitInvocations.incrementAndGet();
             }
         });
@@ -1132,9 +1130,9 @@ public void run() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_async() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Check if the 2nd transaction is committed.
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
@@ -1171,9 +1169,9 @@ public void run() {
         };
 
         Dog dog = realm.where(Dog.class).findFirstAsync();
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 typebasedCommitInvocations.incrementAndGet();
 
                 if (typebasedCommitInvocations.get() == 1) {
@@ -1197,9 +1195,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmresults_sync() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -1217,9 +1215,9 @@ public void run() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        dogs.addChangeListener(new RealmChangeListener() {
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals(2, dogs.size());
             }
@@ -1251,9 +1249,9 @@ public void run() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmresults_async() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -1282,9 +1280,9 @@ public void run() {
         };
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-        dogs.addChangeListener(new RealmChangeListener() {
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 typebasedCommitInvocations.incrementAndGet();
                 if (typebasedCommitInvocations.get() == 1) {
                     // COMPLETED_ASYNC_REALM_RESULTS arrived
@@ -1318,9 +1316,9 @@ public void run() {
                     bgRealm.createObject(Dog.class);
                     bgRealm.commitTransaction();
 
-                    bgRealm.addChangeListener(new RealmChangeListener() {
+                    bgRealm.addChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             fail("Callback should not be registered and invoked on a non-Looper thread");
                         }
                     });
@@ -1350,9 +1348,9 @@ public void run() {
                     bgRealm.commitTransaction();
 
                     Dog dog = bgRealm.where(Dog.class).findFirst();
-                    dog.addChangeListener(new RealmChangeListener() {
+                    dog.addChangeListener(new RealmChangeListener<Dog>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Dog object) {
                             fail("Callback should not be registered and invoked on a non-Looper thread");
                         }
                     });
@@ -1382,9 +1380,9 @@ public void run() {
                     bgRealm.commitTransaction();
 
                     RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
-                    dogs.addChangeListener(new RealmChangeListener() {
+                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<Dog> object) {
                             fail("Callback should not be registered and invoked on a non-Looper thread");
                         }
                     });
@@ -1400,324 +1398,6 @@ public void onChange() {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // ****************************************************************************************** //
-    // UC 5.
-    // Callback should be notified if we call refresh (even without getting the REALM_CHANGE yet)
-    // ***************************************************************************************** //
-    @Test
-    @RunTestInLooperThread
-    public void refresh_should_notify_callbacks_realmobject_sync() {
-        final Realm realm = looperThread.realm;
-        // Swallow all REALM_CHANGED events to test the behaviour of refresh
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerController.REALM_CHANGED: {
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        realm.beginTransaction();
-        realm.createObject(Dog.class);
-        realm.commitTransaction();
-
-        final Dog dog = realm.where(Dog.class).findFirst();
-        assertNull(dog.getName());
-
-        dog.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals("Akamaru", dog.getName());
-                looperThread.testComplete();
-            }
-        });
-
-        Thread thread = new Thread() {
-            @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                bgRealm.beginTransaction();
-                bgRealm.where(Dog.class).findFirst().setName("Akamaru");
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-        thread.start();
-
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
-
-        realm.refresh();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void refresh_should_notify_callbacks_realmobject_async() {
-        final Realm realm = looperThread.realm;
-        // Swallow all REALM_CHANGED events to test the behaviour of refresh
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerController.REALM_CHANGED: {
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        final Dog dog = realm.where(Dog.class).findFirstAsync();
-        assertTrue(dog.load());
-
-        dog.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals("Akamaru", dog.getName());
-                looperThread.testComplete();
-            }
-        });
-
-        Thread thread = new Thread() {
-            @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                bgRealm.beginTransaction();
-                Dog akamaru = bgRealm.createObject(Dog.class);
-                akamaru.setName("Akamaru");
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-        thread.start();
-
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
-
-        realm.refresh();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void refresh_should_notify_callbacks_realmresults_sync() {
-        final Realm realm = looperThread.realm;
-        // Swallow all REALM_CHANGED events to test the behaviour of refresh
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerController.REALM_CHANGED: {
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-
-        dogs.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals("Akamaru", dogs.get(0).getName());
-                looperThread.testComplete();
-            }
-        });
-
-        Thread thread = new Thread() {
-            @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                bgRealm.beginTransaction();
-                Dog akamaru = bgRealm.createObject(Dog.class);
-                akamaru.setName("Akamaru");
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-        thread.start();
-
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
-
-        realm.refresh();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void refresh_should_notify_callbacks_realmresults_async() {
-        final Realm realm = looperThread.realm;
-        // Swallow all REALM_CHANGED events to test the behaviour of refresh
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerController.REALM_CHANGED: {
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-        assertTrue(dogs.load());
-
-        dogs.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                assertEquals("Akamaru", dogs.get(0).getName());
-                looperThread.testComplete();
-            }
-        });
-
-        Thread thread = new Thread() {
-            @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                bgRealm.beginTransaction();
-                Dog akamaru = bgRealm.createObject(Dog.class);
-                akamaru.setName("Akamaru");
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-        thread.start();
-
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
-
-        realm.refresh();
-    }
-
-    // mixed async RealmObject & RealmResults
-    @Test
-    @RunTestInLooperThread
-    public void refresh_should_notify_callbacks_mixed() {
-        final CountDownLatch listenerWasCalledOnRealmObject = new CountDownLatch(1);
-        final CountDownLatch listenerWasCalledOnRealmResults = new CountDownLatch(1);
-
-        final Realm realm = looperThread.realm;
-        // Swallow all REALM_CHANGED events to test the behaviour of an explicit refresh
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerController.REALM_CHANGED: {
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        Dog dog = realm.where(Dog.class).findFirstAsync();
-        RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-
-        assertTrue(dog.load());
-        assertTrue(dogs.load());
-
-        dog.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                listenerWasCalledOnRealmObject.countDown();
-                if (listenerWasCalledOnRealmObject.getCount() == 0 && listenerWasCalledOnRealmResults.getCount() == 0) {
-                    looperThread.testComplete();
-                }
-            }
-        });
-
-        dogs.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                listenerWasCalledOnRealmResults.countDown();
-                if (listenerWasCalledOnRealmObject.getCount() == 0 && listenerWasCalledOnRealmResults.getCount() == 0) {
-                    looperThread.testComplete();
-                }
-            }
-        });
-
-        Thread thread = new Thread() {
-            @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                bgRealm.beginTransaction();
-                Dog akamaru = bgRealm.createObject(Dog.class);
-                akamaru.setName("Akamaru");
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-        thread.start();
-
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
-
-        realm.refresh();
-    }
-
-    // Test modifying realmObjects in RealmObject's change listener
-    @Test
-    @RunTestInLooperThread
-    public void change_realm_objects_map_in_listener() throws InterruptedException {
-        final Realm realm = looperThread.realm;
-        realm.beginTransaction();
-        // At least two objects are needed to make sure list modification happen during iterating.
-        final Cat cat = realm.createObject(Cat.class);
-        final Owner owner = realm.createObject(Owner.class);
-        owner.setCat(cat);
-        realm.commitTransaction();
-
-        RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                Cat cat = owner.getCat();
-                boolean foundKey = false;
-                // Check if cat has been added to the realmObjects in case of the behaviour of getCat changes
-                for (WeakReference<RealmObject> weakReference : realm.handlerController.realmObjects.keySet()) {
-                    if (weakReference.get() == cat) {
-                        foundKey = true;
-                        break;
-                    }
-                }
-                assertTrue(foundKey);
-                looperThread.testComplete();
-            }
-        };
-
-        cat.addChangeListener(listener);
-        owner.addChangeListener(listener);
-
-        realm.beginTransaction();
-        // To make sure the shared group version changed
-        realm.createObject(Owner.class);
-        realm.commitTransaction();
-    }
-
     // Test modifying syncRealmResults in RealmResults's change listener
     @Test
     @RunTestInLooperThread
@@ -1730,12 +1410,12 @@ public void change_realm_results_map_in_listener() throws InterruptedException {
         RealmResults<Cat> results2 = realm.allObjects(Cat.class);
         RealmChangeListener listener = new RealmChangeListener() {
             @Override
-            public void onChange() {
+            public void onChange(Object object) {
                 RealmResults<Owner> results = realm.allObjects(Owner.class);
                 boolean foundKey = false;
                 // Check if the results has been added to the syncRealmResults in case of the behaviour of
                 // allObjects changes
-                for (WeakReference<RealmResults<? extends RealmObject>> weakReference :
+                for (WeakReference<RealmResults<? extends RealmModel>> weakReference :
                         realm.handlerController.syncRealmResults.keySet()) {
                     if (weakReference.get() == results) {
                         foundKey = true;
@@ -1772,9 +1452,9 @@ public void changeListener_onResultsBuiltOnDeletedLinkView() {
 
         final RealmResults<Dog> dogs =
                 allTypes.getColumnRealmList().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
-        dogs.addChangeListener(new RealmChangeListener() {
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 if (typebasedCommitInvocations.getAndIncrement() == 0) {
                     assertTrue(dogs.isValid());
                     assertEquals(0, dogs.size());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
new file mode 100644
index 0000000000..dbd8689566
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyAsBoxedByte extends RealmObject implements NullPrimaryKey<Byte, String> {
+
+    public static final String CLASS_NAME = "PrimaryKeyAsBoxedByte";
+    public static final String FIELD_PRIMARY_KEY = "id";
+
+    @PrimaryKey
+    private Byte id;
+
+    private String name;
+
+    @Override
+    public Byte getId() {
+        return id;
+    }
+
+    public void setId(Byte id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
new file mode 100644
index 0000000000..5465f07de4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyAsBoxedInteger extends RealmObject implements NullPrimaryKey<Integer, String> {
+
+    public static final String CLASS_NAME = "PrimaryKeyAsBoxedInteger";
+    public static final String FIELD_PRIMARY_KEY = "id";
+
+    @PrimaryKey
+    private Integer id;
+
+    private String name;
+
+    @Override
+    public Integer getId() {
+        return id;
+    }
+
+    public void setId(Integer id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
new file mode 100644
index 0000000000..53a0187607
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyAsBoxedLong extends RealmObject implements NullPrimaryKey<Long, String> {
+
+    public static final String CLASS_NAME = "PrimaryKeyAsBoxedLong";
+    public static final String FIELD_PRIMARY_KEY = "id";
+
+    @PrimaryKey
+    private Long id;
+
+    private String name;
+
+    @Override
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
new file mode 100644
index 0000000000..402f4b6b58
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyAsBoxedShort extends RealmObject implements NullPrimaryKey<Short, String> {
+
+    public static final String CLASS_NAME = "PrimaryKeyAsBoxedShort";
+    public static final String FIELD_PRIMARY_KEY = "id";
+
+    @PrimaryKey
+    private Short id;
+
+    private String name;
+
+    @Override
+    public Short getId() {
+        return id;
+    }
+
+    public void setId(Short id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
new file mode 100644
index 0000000000..a7474a743c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class PrimaryKeyAsByte extends RealmObject {
+
+    @PrimaryKey
+    private byte id;
+
+    private String name;
+
+    public byte getId() {
+        return id;
+    }
+
+    public void setId(byte id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
new file mode 100644
index 0000000000..4b12691d84
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class PrimaryKeyAsInteger extends RealmObject {
+
+    @PrimaryKey
+    private int id;
+
+    private String name;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
new file mode 100644
index 0000000000..b2a28c2213
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class PrimaryKeyAsShort extends RealmObject {
+
+    @PrimaryKey
+    private short id;
+
+    private String name;
+
+    public short getId() {
+        return id;
+    }
+
+    public void setId(short id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index ce53189446..c64e9642de 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsString extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsString";
+    public static final String FIELD_PRIMARY_KEY = "name";
+
     @PrimaryKey
     private String name;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
new file mode 100644
index 0000000000..20979c2518
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedByte extends RealmObject implements NullPrimaryKey<Byte, String> {
+
+    @PrimaryKey
+    @Required
+    private Byte id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedByte() {}
+    public PrimaryKeyRequiredAsBoxedByte(Byte id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Byte getId() {
+        return id;
+    }
+
+    public void setId(Byte id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
new file mode 100644
index 0000000000..bb8ecfbf83
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedInteger extends RealmObject implements NullPrimaryKey<Integer, String> {
+
+    @PrimaryKey
+    @Required
+    private Integer id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedInteger() {}
+    public PrimaryKeyRequiredAsBoxedInteger(Integer id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Integer getId() {
+        return id;
+    }
+
+    public void setId(Integer id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
new file mode 100644
index 0000000000..fe526e125a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedLong extends RealmObject implements NullPrimaryKey<Long, String> {
+
+    @PrimaryKey
+    @Required
+    private Long id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedLong() {}
+    public PrimaryKeyRequiredAsBoxedLong(Long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
new file mode 100644
index 0000000000..3c14549a52
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsBoxedShort extends RealmObject implements NullPrimaryKey<Short, String> {
+
+    @PrimaryKey
+    @Required
+    private Short id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsBoxedShort() {}
+    public PrimaryKeyRequiredAsBoxedShort(Short id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public Short getId() {
+        return id;
+    }
+
+    public void setId(Short id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
new file mode 100644
index 0000000000..4daa2d8fe6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.objectid.NullPrimaryKey;
+
+public class PrimaryKeyRequiredAsString extends RealmObject implements NullPrimaryKey<String, String> {
+
+    @PrimaryKey
+    @Required
+    private String id;
+
+    private String name;
+
+    public PrimaryKeyRequiredAsString(){}
+    public PrimaryKeyRequiredAsString(String id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java b/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
deleted file mode 100644
index 35bc61ca1a..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.entities;
-
-import android.content.Context;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ListAdapter;
-import android.widget.TextView;
-
-import io.realm.OrderedRealmCollection;
-import io.realm.RealmBaseAdapter;
-import io.realm.RealmResults;
-
-public class RealmAdapter extends RealmBaseAdapter<AllTypes> implements ListAdapter {
-
-    private static class ViewHolder {
-        TextView textView;
-    }
-
-    public RealmAdapter(Context context, RealmResults<AllTypes> realmResults, boolean automaticUpdate) {
-        super(context, realmResults, automaticUpdate);
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        ViewHolder viewHolder;
-        if (convertView == null) {
-            convertView = inflater.inflate(android.R.layout.simple_list_item_1, parent, false);
-            viewHolder = new ViewHolder();
-            viewHolder.textView = (TextView) convertView.findViewById(android.R.id.text1);
-            convertView.setTag(viewHolder);
-        } else {
-            viewHolder = (ViewHolder) convertView.getTag();
-        }
-
-        AllTypes item = adapterData.get(position);
-        viewHolder.textView.setText(item.getColumnString());
-        return convertView;
-    }
-
-    public OrderedRealmCollection<AllTypes> getRealmResults() {
-        return adapterData;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
new file mode 100644
index 0000000000..6e87305827
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.entities.Dog;
+
+@RealmClass
+public class AllTypesRealmModel implements RealmModel {
+    public static final String CLASS_NAME = "AllTypesRealmModel";
+    public static final String FIELD_LONG = "columnLong";
+    public static final String FIELD_DOUBLE = "columnDouble";
+    public static final String FIELD_STRING = "columnString";
+    public static final String FIELD_BINARY = "columnBinary";
+    public static final String FIELD_BOOLEAN = "columnBoolean";
+
+    @Index
+    public String columnString;
+    @PrimaryKey
+    public long columnLong;
+    public byte columnByte;
+    public float columnFloat;
+    public double columnDouble;
+    public boolean columnBoolean;
+    public Date columnDate;
+    public byte[] columnBinary;
+    public Dog columnRealmObject;
+    public RealmList<Dog> columnRealmList;
+
+    @Override
+    public int hashCode() {
+        return 42;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/InvalidRealmModel.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/InvalidRealmModel.java
new file mode 100644
index 0000000000..0e62fd9f2e
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/InvalidRealmModel.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmModel;
+
+public class InvalidRealmModel implements RealmModel {
+    public String id;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/PojoWithRealmListOfRealmObject.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/PojoWithRealmListOfRealmObject.java
new file mode 100644
index 0000000000..9ed2a1f8a4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/PojoWithRealmListOfRealmObject.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+import io.realm.entities.AllTypes;
+
+@RealmClass
+public class PojoWithRealmListOfRealmObject implements RealmModel {
+    private RealmList<AllTypes> columnRealmList;
+
+    public RealmList<AllTypes> getColumnRealmList() {
+        return columnRealmList;
+    }
+
+    public void setColumnRealmList(RealmList<AllTypes> columnRealmList) {
+        this.columnRealmList = columnRealmList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmListOfRealmModel.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmListOfRealmModel.java
new file mode 100644
index 0000000000..47558665f5
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmListOfRealmModel.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class RealmModelWithRealmListOfRealmModel implements RealmModel {
+    private RealmList<AllTypesRealmModel> columnRealmList;
+
+    public RealmList<AllTypesRealmModel> getColumnRealmList() {
+        return columnRealmList;
+    }
+
+    public void setColumnRealmList(RealmList<AllTypesRealmModel> columnRealmList) {
+        this.columnRealmList = columnRealmList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmModelField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmModelField.java
new file mode 100644
index 0000000000..11c26b9cac
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmModelWithRealmModelField.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class RealmModelWithRealmModelField implements RealmModel {
+    private AllTypesRealmModel allTypesRealmModel;
+
+    public AllTypesRealmModel getAllTypesRealmModel() {
+        return allTypesRealmModel;
+    }
+
+    public void setAllTypesRealmModel(AllTypesRealmModel allTypesRealmModel) {
+        this.allTypesRealmModel = allTypesRealmModel;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmListOfRealmModel.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmListOfRealmModel.java
new file mode 100644
index 0000000000..93007b213b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmListOfRealmModel.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class RealmObjectWithRealmListOfRealmModel extends RealmObject {
+    private RealmList<AllTypesRealmModel> columnRealmList;
+
+    public RealmList<AllTypesRealmModel> getColumnRealmList() {
+        return columnRealmList;
+    }
+
+    public void setColumnRealmList(RealmList<AllTypesRealmModel> columnRealmList) {
+        this.columnRealmList = columnRealmList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
new file mode 100644
index 0000000000..71be5a1a07
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.pojo;
+
+import io.realm.RealmObject;
+
+public class RealmObjectWithRealmModelField extends RealmObject{
+    private AllTypesRealmModel allTypesRealmModel;
+
+    public AllTypesRealmModel getAllTypesRealmModel() {
+        return allTypesRealmModel;
+    }
+
+    public void setAllTypesRealmModel(AllTypesRealmModel allTypesRealmModel) {
+        this.allTypesRealmModel = allTypesRealmModel;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
index bad11e5007..a438e62d78 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
@@ -22,7 +22,7 @@
 import io.realm.RealmResults;
 import io.realm.entities.AllTypes;
 
-public class ActivityLifecycle implements Lifecycle, RealmChangeListener {
+public class ActivityLifecycle implements Lifecycle, RealmChangeListener<RealmResults<AllTypes>> {
     private final RealmConfiguration realmConfiguration;
     private Realm realm;
     private RealmResults<AllTypes> mAllTypes;
@@ -45,7 +45,6 @@ public void onStop() {
     }
 
     @Override
-    public void onChange() {
-
+    public void onChange(RealmResults<AllTypes> object) {
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 5bc96014e0..ba83afb0b2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -92,7 +92,7 @@ public void testFindFirstNonExisting() {
         t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
 
         assertEquals(-1, t.findFirstBoolean(1, false));
-        assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
+        // FIXME: reenable when core implements find_first_timestamp(): assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
         assertEquals(-1, t.findFirstDouble(3, 1.0d));
         assertEquals(-1, t.findFirstFloat(4, 1.0f));
         assertEquals(-1, t.findFirstLong(5, 50));
@@ -103,13 +103,13 @@ public void testFindFirst() {
         final int TEST_SIZE = 10;
         Table t = TestHelper.getTableWithAllColumnTypes();
         for (int i = 0; i < TEST_SIZE; i++) {
-            t.add(new byte[]{1,2,3}, true, new Date(1000*i), (double)i, (float)i, i, new Mixed("mixed " + i), "string " + i, null);
+            t.add(new byte[]{1,2,3}, true, new Date(i), (double)i, (float)i, i, new Mixed("mixed " + i), "string " + i, null);
         }
-        t.add(new byte[]{1, 2, 3}, true, new Date(1000 * TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, new Mixed("mixed " + TEST_SIZE), "", null);
+        t.add(new byte[]{1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, new Mixed("mixed " + TEST_SIZE), "", null);
 
         assertEquals(0, t.findFirstBoolean(1, true));
         for (int i = 0; i < TEST_SIZE; i++) {
-            assertEquals(i, t.findFirstDate(2, new Date(1000*i)));
+            assertEquals(i, t.findFirstDate(2, new Date(i)));
             assertEquals(i, t.findFirstDouble(3, (double) i));
             assertEquals(i, t.findFirstFloat(4, (float) i));
             assertEquals(i, t.findFirstLong(5, i));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
index 91a9f5660b..0f0631baa2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -63,7 +63,7 @@ private Table getTableWithStringPrimaryKey() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         WriteTransaction trans = db.beginWrite();
         Table t = trans.getTable("TestTable");
-        t.addColumn(RealmFieldType.STRING, "colName");
+        t.addColumn(RealmFieldType.STRING, "colName", true);
         t.setPrimaryKey("colName");
         return t;
     }
@@ -365,13 +365,10 @@ public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
     }
 
     @Test
-    public void addEmptyRowWithPrimaryKeyNullStringThrows() {
+    public void addEmptyRowWithPrimaryKeyNullString() {
         Table t = getTableWithStringPrimaryKey();
-        try {
-            t.addEmptyRowWithPrimaryKey(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+        t.addEmptyRowWithPrimaryKey(null);
+        assertEquals(1, t.size());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 27d1aa48da..fb058944aa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -188,7 +188,7 @@ public void testFindFirstNonExisting() {
         TableView v = tt.where().findAll();
 
         assertEquals(-1, v.findFirstBoolean(1, false));
-        assertEquals(-1, v.findFirstDate(2, new Date(138442314986l)));
+        //FIXME: enable when find_first_timestamp() is implemented: assertEquals(-1, v.findFirstDate(2, new Date(138442314986l)));
         assertEquals(-1, v.findFirstDouble(3, 1.0d));
         assertEquals(-1, v.findFirstFloat(4, 1.0f));
         assertEquals(-1, v.findFirstLong(5, 50));
@@ -199,39 +199,39 @@ public void testFindFirstNonExisting() {
     public void testGetValuesFromNonExistingColumn() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableView view = table.where().findAll();
-        
+
         try { view.getBinaryByteArray(-1, 0);   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBinaryByteArray(-10, 0);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBinaryByteArray(100, 0);  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getBoolean(-1, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBoolean(-10, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBoolean(100, 0);          fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getDate(-1, 0);              fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDate(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDate(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getDouble(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDouble(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDouble(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getFloat(-1, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getFloat(-10, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getFloat(100, 0);            fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getLong(-1, 0);              fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getLong(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getLong(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getMixed(-1, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getMixed(-10, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getMixed(100, 0);            fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getString(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getString(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getString(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getSubtable(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getSubtable(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getSubtable(100, 0);         fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
@@ -446,7 +446,7 @@ public void testViewShouldInvalidate() {
         view = t.where().equalTo(new long[]{0}, 2).findAll();
         accessingViewOk(view);
 
-        // Removing any row in Table should invalidate view 
+        // Removing any row in Table should invalidate view
         t.remove(3);
         accessingViewMustThrow(view);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
new file mode 100644
index 0000000000..527825cedd
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectid;
+
+public interface NullPrimaryKey<P, S> {
+
+    public P getId();
+
+    public S getName();
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/RealmThread.java b/realm/realm-library/src/androidTest/java/io/realm/util/RealmThread.java
new file mode 100644
index 0000000000..e87fc2aa8a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/RealmThread.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+// this is a simple example of how Realm can be encapsulated within a Thread wrapper.
+public final class RealmThread extends Thread {
+
+    public interface RealmRunnable {
+        void run(final Realm realm);
+    }
+
+    private final RealmConfiguration realmConfig;
+    private final RealmRunnable task;
+    private Realm realm;
+
+    public RealmThread(RealmConfiguration realmConfig, RealmRunnable task) {
+        super();
+        this.realmConfig = realmConfig;
+        this.task = task;
+    }
+
+    public RealmThread(RealmConfiguration realmConfig, RealmRunnable task, String threadName) {
+        super(threadName);
+        this.realmConfig = realmConfig;
+        this.task = task;
+    }
+
+    @Override
+    public void run() {
+        realm = Realm.getInstance(this.realmConfig);
+        if (task != null) {
+            task.run(realm);
+        }
+        if (!realm.isClosed()) {
+            realm.close();
+        }
+        realm = null;
+    }
+
+    public void end() {
+        if (!this.isAlive()) {
+            return;
+        }
+        if (realm == null) {
+            return;
+        }
+        realm.stopWaitForChange();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 7012e50c45..074bc81e53 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -29,6 +29,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.InvalidRow;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.SharedGroupManager;
 import io.realm.internal.Table;
 import io.realm.internal.TableView;
@@ -56,12 +58,11 @@
     protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
 
     // Thread pool for all async operations (Query & transaction)
-    static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
+    static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
     final long threadId;
     protected RealmConfiguration configuration;
     protected SharedGroupManager sharedGroupManager;
-    protected boolean autoRefresh;
     RealmSchema schema;
     Handler handler;
     HandlerController handlerController;
@@ -75,6 +76,7 @@ protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
         this.configuration = configuration;
         this.sharedGroupManager = new SharedGroupManager(configuration);
         this.schema = new RealmSchema(this, sharedGroupManager.getTransaction());
+        this.handlerController = new HandlerController(this);
         setAutoRefresh(autoRefresh);
     }
 
@@ -95,14 +97,13 @@ public void setAutoRefresh(boolean autoRefresh) {
             throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
         }
 
-        if (autoRefresh && !this.autoRefresh) { // Switch it on
-            handlerController = new HandlerController(this);
+        if (autoRefresh && !handlerController.isAutoRefreshEnabled()) { // Switch it on
             handler = new Handler(handlerController);
             handlers.put(handler, configuration.getPath());
-        } else if (!autoRefresh && this.autoRefresh && handler != null) { // Switch it off
+        } else if (!autoRefresh && handlerController.isAutoRefreshEnabled() && handler != null) { // Switch it off
             removeHandler();
         }
-        this.autoRefresh = autoRefresh;
+        handlerController.setAutoRefresh(autoRefresh);
     }
 
     /**
@@ -111,7 +112,7 @@ public void setAutoRefresh(boolean autoRefresh) {
      * @return the auto-refresh status.
      */
     public boolean isAutoRefresh() {
-        return autoRefresh;
+        return handlerController.isAutoRefreshEnabled();
     }
 
     /**
@@ -124,28 +125,9 @@ public boolean isInTransaction() {
         return !sharedGroupManager.isImmutable();
     }
 
-    /**
-     * Adds a change listener to the Realm.
-     * <p>
-     * The listeners will be executed:
-     * <ul>
-     * <li>Immediately if a change was committed by the local thread</li>
-     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
-     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
-     * </ul>
-     *
-     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
-     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
-     *
-     * @param listener the change listener.
-     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
-     * @see io.realm.RealmChangeListener
-     * @see #removeChangeListener(RealmChangeListener)
-     * @see #removeAllChangeListeners()
-     */
-    public void addChangeListener(RealmChangeListener listener) {
+    protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
         checkIfValid();
-        if (handlerController == null) {
+        if (!handlerController.isAutoRefreshEnabled()) {
             throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
         }
         handlerController.addChangeListener(listener);
@@ -157,11 +139,10 @@ public void addChangeListener(RealmChangeListener listener) {
      * @param listener the change listener to be removed.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
-     * @see #addChangeListener(RealmChangeListener)
      */
-    public void removeChangeListener(RealmChangeListener listener) {
+    public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         checkIfValid();
-        if (handlerController == null) {
+        if (!handlerController.isAutoRefreshEnabled()) {
             throw new IllegalStateException("You can't remove a listener from a non-Looper thread ");
         }
         handlerController.removeChangeListener(listener);
@@ -192,11 +173,10 @@ public void removeChangeListener(RealmChangeListener listener) {
      *
      * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
-     * @see #addChangeListener(RealmChangeListener)
      */
     public void removeAllChangeListeners() {
         checkIfValid();
-        if (handlerController == null) {
+        if (!handlerController.isAutoRefreshEnabled()) {
             throw new IllegalStateException("You can't remove listeners from a non-Looper thread ");
         }
         handlerController.removeAllChangeListeners();
@@ -263,21 +243,71 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IO
      * It also calls the listeners associated to the Realm instance.
      *
      * @throws IllegalStateException if attempting to refresh from within a transaction.
+     * @deprecated Please use {@link #waitForChange()} instead.
      */
     @SuppressWarnings("UnusedDeclaration")
+    @Deprecated
     public void refresh() {
         checkIfValid();
         if (isInTransaction()) {
             throw new IllegalStateException(BaseRealm.CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE);
         }
-        sharedGroupManager.advanceRead();
-        if (handlerController != null) {
-            handlerController.notifyAllListeners();
-            // if we have empty async RealmObject then rerun
-            if (handlerController.threadContainsAsyncEmptyRealmObject()) {
-                handlerController.updateAsyncEmptyRealmObject();
-            }
+        if (!handlerController.isAutoRefreshEnabled()) {
+            // non Looper Thread, just advance the Realm
+            // registering listeners is not allowed, hence nothing to notify
+            sharedGroupManager.advanceRead();
+            handlerController.refreshSynchronousTableViews();
+        } else {
+            handlerController.notifyCurrentThreadRealmChanged();
+        }
+    }
+
+    /**
+     * Blocks the current thread until new changes to the Realm are available or {@link #stopWaitForChange()}
+     * is called from another thread. Once stopWaitForChange is called, all future calls to this method will
+     * return false immediately.
+     *
+     * @return {@code true} if the Realm was updated to the latest version, {@code false} if it was
+     * cancelled by calling stopWaitForChange.
+     * @throws IllegalStateException if calling this from within a transaction or from a Looper thread.
+     */
+    public boolean waitForChange() {
+        checkIfValid();
+        if (isInTransaction()) {
+            throw new IllegalStateException("Cannot wait for changes inside of a transaction.");
+        }
+        if (Looper.myLooper() != null) {
+            throw new IllegalStateException("Cannot wait for changes inside a Looper thread. Use RealmChangeListeners instead.");
         }
+        boolean hasChanged = sharedGroupManager.getSharedGroup().waitForChange();
+        if (hasChanged) {
+            // Since this Realm instance has been waiting for change, advance realm & refresh realm.
+            sharedGroupManager.advanceRead();
+            handlerController.refreshSynchronousTableViews();
+        }
+        return hasChanged;
+    }
+
+    /**
+     * Makes any current {@link #waitForChange()} return {@code false} immediately. Once this is called,
+     * all future calls to waitForChange will immediately return {@code false}.
+     * <p>
+     * This method is thread-safe and should _only_ be called from another thread than the one that
+     * called waitForChange.
+     *
+     * @throws IllegalStateException if the {@link io.realm.Realm} instance has already been closed.
+     */
+    public void stopWaitForChange() {
+        RealmCache.invokeWithLock(new RealmCache.Callback0() {
+            @Override
+            public void onCall() {
+                // Check if the Realm instance has been closed
+                if (sharedGroupManager == null || !sharedGroupManager.isOpen() || sharedGroupManager.getSharedGroup().isClosed()) {
+                    throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+                }
+                sharedGroupManager.getSharedGroup().stopWaitForChange();
+            }
+        });
     }
 
     /**
@@ -337,9 +367,9 @@ void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
             // as the target thread consumes messages at the same time. In this case it is not a problem as worst
             // case we end up with two REALM_CHANGED messages in the queue.
             if (
-                    realmPath.equals(configuration.getPath())            // It's the right realm
-                            && !handler.hasMessages(HandlerController.REALM_CHANGED)       // The right message
-                            && handler.getLooper().getThread().isAlive() // The receiving thread is alive
+                    realmPath.equals(configuration.getPath())                           // It's the right realm
+                            && !handler.hasMessages(HandlerController.REALM_CHANGED)    // The right message
+                            && handler.getLooper().getThread().isAlive()                // The receiving thread is alive
                             && !handler.sendEmptyMessage(HandlerController.REALM_CHANGED)) {
                 RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
                         "to prevent this.");
@@ -515,22 +545,21 @@ public RealmSchema getSchema() {
         return schema;
     }
 
-    <E extends RealmObject> E get(Class<E> clazz, long rowIndex) {
+    <E extends RealmModel> E get(Class<E> clazz, long rowIndex) {
         Table table = schema.getTable(clazz);
         UncheckedRow row = table.getUncheckedRow(rowIndex);
         E result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
-        result.row = row;
-        result.realm = this;
-        result.setTableVersion();
-        if (handlerController != null) {
-            handlerController.addToRealmObjects(result);
-        }
+        RealmObjectProxy proxy = (RealmObjectProxy) result;
+        proxy.realmGet$proxyState().setRow$realm(row);
+        proxy.realmGet$proxyState().setRealm$realm(this);
+        proxy.realmGet$proxyState().setTableVersion$realm();
+
         return result;
     }
 
     // Used by RealmList/RealmResults
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
-    <E extends RealmObject> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
+    <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
         Table table;
         E result;
         if (dynamicClassName != null) {
@@ -542,13 +571,16 @@ public RealmSchema getSchema() {
             table = schema.getTable(clazz);
             result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
         }
-        result.row = table.getUncheckedRow(rowIndex);
-        result.realm = this;
-        result.setTableVersion();
 
-        if (handlerController != null) {
-            handlerController.addToRealmObjects(result);
+        RealmObjectProxy proxy = (RealmObjectProxy) result;
+        proxy.realmGet$proxyState().setRealm$realm(this);
+        if (rowIndex != Table.NO_MATCH) {
+            proxy.realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
+            proxy.realmGet$proxyState().setTableVersion$realm();
+        } else {
+            proxy.realmGet$proxyState().setRow$realm(InvalidRow.INSTANCE);
         }
+
         return result;
     }
 
@@ -564,10 +596,33 @@ public void deleteAll() {
         }
     }
 
+    static private boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
+        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
+
+        List<File> filesToDelete = Arrays.asList(
+                new File(rootFolder, realmFileName),
+                new File(rootFolder, realmFileName + ".lock"),
+                new File(rootFolder, realmFileName + ".log_a"),
+                new File(rootFolder, realmFileName + ".log_b"),
+                new File(rootFolder, realmFileName + ".log"),
+                new File(canonicalPath));
+        for (File fileToDelete : filesToDelete) {
+            if (fileToDelete.exists()) {
+                boolean deleteResult = fileToDelete.delete();
+                if (!deleteResult) {
+                    realmDeleted.set(false);
+                    RealmLog.w("Could not delete the file " + fileToDelete);
+                }
+            }
+        }
+        return realmDeleted.get();
+    }
+
     /**
      * Deletes the Realm file defined by the given configuration.
      */
     static boolean deleteRealm(final RealmConfiguration configuration) {
+        final String management = ".management";
         final AtomicBoolean realmDeleted = new AtomicBoolean(true);
 
         RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
@@ -581,20 +636,10 @@ public void onResult(int count) {
                 String canonicalPath = configuration.getPath();
                 File realmFolder = configuration.getRealmFolder();
                 String realmFileName = configuration.getRealmFileName();
-                List<File> filesToDelete = Arrays.asList(new File(canonicalPath),
-                        new File(realmFolder, realmFileName + ".lock"),
-                        new File(realmFolder, realmFileName + ".log_a"),
-                        new File(realmFolder, realmFileName + ".log_b"),
-                        new File(realmFolder, realmFileName + ".log"));
-                for (File fileToDelete : filesToDelete) {
-                    if (fileToDelete.exists()) {
-                        boolean deleteResult = fileToDelete.delete();
-                        if (!deleteResult) {
-                            realmDeleted.set(false);
-                            RealmLog.w("Could not delete the file " + fileToDelete);
-                        }
-                    }
-                }
+                File managementFolder = new File(realmFolder, realmFileName + management);
+                realmDeleted.set(deletes(realmFolder.getPath()+ "/" + realmFileName + management, managementFolder, realmFileName));
+                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
+
             }
         });
 
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 85401c8183..0a9436b15a 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -88,16 +88,15 @@ public DynamicRealmObject createObject(String className) {
      *
      * @return the new object. All fields will have default values for their type, except for the
      * primary key field which will have the provided value.
-     * @throws IllegalArgumentException if the primary key value is of the wrong type.
-     * @throws IllegalStateException if the class doesn't have a primary key defined.
+     * @throws RealmException if object could not be created due to the primary key being invalid.
+     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     *                                  expectd value.
      */
     public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
         Table table = schema.getTable(className);
         long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
         DynamicRealmObject dynamicRealmObject = new DynamicRealmObject(this, table.getCheckedRow(index));
-        if (handlerController != null) {
-            handlerController.addToRealmObjects(dynamicRealmObject);
-        }
         return dynamicRealmObject;
     }
 
@@ -117,6 +116,30 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
         return RealmQuery.createDynamicQuery(this, className);
     }
 
+
+    /**
+     * Adds a change listener to the Realm.
+     * <p>
+     * The listeners will be executed:
+     * <ul>
+     * <li>Immediately if a change was committed by the local thread</li>
+     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
+     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
+     * </ul>
+     *
+     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
+     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
+     *
+     * @param listener the change listener.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     * @see #removeChangeListener(RealmChangeListener)
+     * @see #removeAllChangeListeners()
+     */
+    public void addChangeListener(RealmChangeListener<DynamicRealm> listener) {
+        super.addListener(listener);
+    }
+
     /**
      * Removes all objects of the specified class.
      *
@@ -167,28 +190,17 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Gets all objects of a specific class name.
-     *
-     * @param className the Class to get objects of.
-     * @return a {@link RealmResults} list containing the objects. If no results where found, an empty list
-     * will be returned.
-     * @see io.realm.RealmResults
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll()} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> allObjects(String className) {
         return where(className).findAll();
     }
 
     /**
-     * Gets all objects of a specific class name sorted by a field. If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of objects
-     * instead.
-     *
-     * @param className the class to get all objects from.
-     * @param fieldName the field name to sort by.
-     * @param sortOrder how to sort the results.
-     * @return a sorted {@link RealmResults} containing the objects.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName, sortOrder)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName, Sort sortOrder) {
         checkIfValid();
         Table table = schema.getTable(className);
@@ -203,19 +215,9 @@ public void executeTransaction(Transaction transaction) {
 
 
     /**
-     * Gets all objects of a specific class name sorted by two specific field names.  If no objects exist,
-     * the returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number
-     * of objects instead.
-     *
-     * @param className the class to get all objects from.
-     * @param fieldName1 the first field name to sort by.
-     * @param sortOrder1 how to sort the first field.
-     * @param fieldName2 the second field name to sort by.
-     * @param sortOrder2 how to sort the second field.
-     * @return a sorted {@link RealmResults} containing the objects. If no results where found an empty list
-     * is returned.
-     * @throws java.lang.IllegalArgumentException if a field name used for sorting does not exist.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName1,
                                                                     Sort sortOrder1, String fieldName2,
                                                                     Sort sortOrder2) {
@@ -224,17 +226,9 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Gets all objects of a specific class name sorted by multiple fields.  If no objects exist, the
-     * returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of
-     * objects instead.
-     *
-     * @param className the class to get all objects from.
-     * @param sortOrders sort ascending if Sort.ASCENDING, sort descending if Sort.DESCENDING.
-     * @param fieldNames an array of field names to sort objects by.
-     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.
-     * @return A sorted {@link RealmResults} containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldNames[], sortOrders[])} instead.
      */
+    @Deprecated
     @SuppressWarnings("unchecked")
     public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldNames[], Sort sortOrders[]) {
         checkAllObjectsSortedParameters(fieldNames, sortOrders);
@@ -255,15 +249,9 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     *
-     * @param className the Class to get objects of.
-     * @param fieldName the field name.
-     * @return A non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(fieldName)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> distinct(String className, String fieldName) {
         checkIfValid();
         Table table = schema.getTable(className);
@@ -273,36 +261,18 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     * This method is only available from a Looper thread.
-     *
-     * @param className the Class to get objects of.
-     * @param fieldName the field name.
-     * @return immediately a {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     * query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).distinctAsync(fieldName)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> distinctAsync(String className, String fieldName) {
         checkIfValid();
         return where(className).distinctAsync(fieldName);
     }
 
     /**
-     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
-     * given, all unique combinations of values in the fields will be returned. In case of multiple
-     * matches, it is undefined which object is returned. Unless the result is sorted, then the
-     * first object will be returned.
-     *
-     * @param className the Class to get objects of.
-     * @param firstFieldName first field name to use when finding distinct objects.
-     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     * is an unsupported type, or points to a linked field.
+     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(firstFieldName, remainingFieldNames)} instead.
      */
+    @Deprecated
     public RealmResults<DynamicRealmObject> distinct(String className, String firstFieldName, String... remainingFieldNames) {
         checkIfValid();
         return where(className).distinct(firstFieldName, remainingFieldNames);
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index fc32816dd8..e9bab17c59 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -21,6 +21,7 @@
 
 import io.realm.internal.CheckedRow;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
@@ -30,16 +31,15 @@
  * Class that wraps a normal RealmObject in order to allow dynamic access instead of a typed interface.
  * Using a DynamicRealmObject is slower than using the regular RealmObject class.
  */
-public final class DynamicRealmObject extends RealmObject {
-    private String className;
-
+public final class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
+    private final ProxyState proxyState = new ProxyState(this);
     /**
      * Creates a dynamic Realm object based on an existing object.
      *
      * @param obj the Realm object to convert to a dynamic object. Only objects managed by {@link Realm} can be used.
      * @throws IllegalArgumentException if object isn't managed by Realm or is a {@link DynamicRealmObject} already.
      */
-    public DynamicRealmObject(RealmObject obj) {
+    public DynamicRealmObject(RealmModel obj) {
         if (obj == null) {
             throw new IllegalArgumentException("A non-null object must be provided.");
         }
@@ -47,13 +47,15 @@ public DynamicRealmObject(RealmObject obj) {
             throw new IllegalArgumentException("The object is already a DynamicRealmObject: " + obj);
         }
 
-        Row row = obj.row;
-        if (!obj.isValid()) {
+        if (!RealmObject.isValid(obj)) {
             throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
                     "is a standalone object or it was deleted.");
         }
-        this.realm = obj.realm;
-        this.row = ((UncheckedRow) row).convertToChecked();
+
+        RealmObjectProxy proxy = (RealmObjectProxy) obj;
+        Row row = proxy.realmGet$proxyState().getRow$realm();
+        proxyState.setRealm$realm(proxy.realmGet$proxyState().getRealm$realm());
+        proxyState.setRow$realm(((UncheckedRow) row).convertToChecked());
     }
 
     // Create a dynamic object. Only used internally
@@ -62,12 +64,12 @@ public DynamicRealmObject(RealmObject obj) {
     }
 
     DynamicRealmObject(BaseRealm realm, Row row) {
-        this.realm = realm;
-        this.row = (row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked();
+        proxyState.setRealm$realm(realm);
+        proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
     }
 
     DynamicRealmObject(String className) {
-        this.className = className;
+        proxyState.setClassName(className);
     }
 
     /**
@@ -79,16 +81,16 @@ public DynamicRealmObject(RealmObject obj) {
      */
     @SuppressWarnings("unchecked")
     public <E> E get(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        RealmFieldType type = row.getColumnType(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         switch (type) {
-            case BOOLEAN: return (E) Boolean.valueOf(row.getBoolean(columnIndex));
-            case INTEGER: return (E) Long.valueOf(row.getLong(columnIndex));
-            case FLOAT: return (E) Float.valueOf(row.getFloat(columnIndex));
-            case DOUBLE: return (E) Double.valueOf(row.getDouble(columnIndex));
-            case STRING: return (E) row.getString(columnIndex);
-            case BINARY: return (E) row.getBinaryByteArray(columnIndex);
-            case DATE: return (E) row.getDate(columnIndex);
+            case BOOLEAN: return (E) Boolean.valueOf(proxyState.getRow$realm().getBoolean(columnIndex));
+            case INTEGER: return (E) Long.valueOf(proxyState.getRow$realm().getLong(columnIndex));
+            case FLOAT: return (E) Float.valueOf(proxyState.getRow$realm().getFloat(columnIndex));
+            case DOUBLE: return (E) Double.valueOf(proxyState.getRow$realm().getDouble(columnIndex));
+            case STRING: return (E) proxyState.getRow$realm().getString(columnIndex);
+            case BINARY: return (E) proxyState.getRow$realm().getBinaryByteArray(columnIndex);
+            case DATE: return (E) proxyState.getRow$realm().getDate(columnIndex);
             case OBJECT: return (E) getObject(fieldName);
             case LIST: return (E) getList(fieldName);
             case UNSUPPORTED_TABLE:
@@ -109,8 +111,8 @@ public DynamicRealmObject(RealmObject obj) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public boolean getBoolean(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getBoolean(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getBoolean(columnIndex);
     }
 
     /**
@@ -152,8 +154,8 @@ public short getShort(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public long getLong(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getLong(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getLong(columnIndex);
     }
 
     /**
@@ -167,8 +169,8 @@ public long getLong(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public byte getByte(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return (byte) row.getLong(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return (byte) proxyState.getRow$realm().getLong(columnIndex);
     }
 
     /**
@@ -182,8 +184,8 @@ public byte getByte(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public float getFloat(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getFloat(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getFloat(columnIndex);
     }
 
     /**
@@ -197,8 +199,8 @@ public float getFloat(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public double getDouble(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getDouble(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getDouble(columnIndex);
     }
 
     /**
@@ -209,8 +211,8 @@ public double getDouble(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain binary data.
      */
     public byte[] getBlob(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getBinaryByteArray(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
     }
 
     /**
@@ -221,8 +223,8 @@ public double getDouble(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Strings.
      */
     public String getString(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getString(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getString(columnIndex);
     }
 
     /**
@@ -233,11 +235,11 @@ public String getString(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Dates.
      */
     public Date getDate(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        if (row.isNull(columnIndex)) {
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        if (proxyState.getRow$realm().isNull(columnIndex)) {
             return null;
         } else {
-            return row.getDate(columnIndex);
+            return proxyState.getRow$realm().getDate(columnIndex);
         }
     }
 
@@ -249,13 +251,13 @@ public Date getDate(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain links to other objects.
      */
     public DynamicRealmObject getObject(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        if (row.isNullLink(columnIndex)) {
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        if (proxyState.getRow$realm().isNullLink(columnIndex)) {
             return null;
         } else {
-            long linkRowIndex = row.getLink(columnIndex);
-            CheckedRow linkRow = row.getTable().getLinkTarget(columnIndex).getCheckedRow(linkRowIndex);
-            return new DynamicRealmObject(realm, linkRow);
+            long linkRowIndex = proxyState.getRow$realm().getLink(columnIndex);
+            CheckedRow linkRow = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getCheckedRow(linkRowIndex);
+            return new DynamicRealmObject(proxyState.getRealm$realm(), linkRow);
         }
     }
 
@@ -267,10 +269,10 @@ public DynamicRealmObject getObject(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain a list of links.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        LinkView linkView = row.getLinkList(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
         String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
-        return new RealmList<DynamicRealmObject>(className, linkView, realm);
+        return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
     }
 
     /**
@@ -281,11 +283,11 @@ public DynamicRealmObject getObject(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exists.
      */
     public boolean isNull(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        RealmFieldType type = row.getColumnType(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         switch (type) {
             case OBJECT:
-                return row.isNullLink(columnIndex);
+                return proxyState.getRow$realm().isNullLink(columnIndex);
             case BOOLEAN:
             case INTEGER:
             case FLOAT:
@@ -293,7 +295,7 @@ public boolean isNull(String fieldName) {
             case STRING:
             case BINARY:
             case DATE:
-                return row.isNull(columnIndex);
+                return proxyState.getRow$realm().isNull(columnIndex);
             case LIST:
             case UNSUPPORTED_TABLE:
             case UNSUPPORTED_MIXED:
@@ -313,7 +315,7 @@ public boolean hasField(String fieldName) {
         if (fieldName == null || fieldName.isEmpty()) {
             return false;
         }
-        return row.hasColumn(fieldName);
+        return proxyState.getRow$realm().hasColumn(fieldName);
     }
 
     /**
@@ -322,9 +324,9 @@ public boolean hasField(String fieldName) {
      * @return list of field names on this objects or the empty list if the object doesn't have any fields.
      */
     public String[] getFieldNames() {
-        String[] keys = new String[(int) row.getColumnCount()];
+        String[] keys = new String[(int) proxyState.getRow$realm().getColumnCount()];
         for (int i = 0; i < keys.length; i++) {
-            keys[i] = row.getColumnName(i);
+            keys[i] = proxyState.getRow$realm().getColumnName(i);
         }
         return keys;
     }
@@ -346,8 +348,8 @@ public void set(String fieldName, Object value) {
         String strValue = isString ? (String) value : null;
 
         // Do implicit conversion if needed
-        long columnIndex = row.getColumnIndex(fieldName);
-        RealmFieldType type = row.getColumnType(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         if (isString && type != RealmFieldType.STRING) {
             switch(type) {
                 case BOOLEAN: value = Boolean.parseBoolean(strValue); break;
@@ -411,8 +413,8 @@ private void setValue(String fieldName, Object value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't a boolean field.
      */
     public void setBoolean(String fieldName, boolean value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setBoolean(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setBoolean(columnIndex, value);
     }
 
     /**
@@ -423,8 +425,8 @@ public void setBoolean(String fieldName, boolean value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
      */
     public void setShort(String fieldName, short value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setLong(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setLong(columnIndex, value);
     }
 
     /**
@@ -435,8 +437,8 @@ public void setShort(String fieldName, short value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
      */
     public void setInt(String fieldName, int value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setLong(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setLong(columnIndex, value);
     }
 
     /**
@@ -447,8 +449,8 @@ public void setInt(String fieldName, int value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
      */
     public void setLong(String fieldName, long value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setLong(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setLong(columnIndex, value);
     }
 
     /**
@@ -459,8 +461,8 @@ public void setLong(String fieldName, long value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
      */
     public void setByte(String fieldName, byte value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setLong(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setLong(columnIndex, value);
     }
 
     /**
@@ -471,8 +473,8 @@ public void setByte(String fieldName, byte value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
      */
     public void setFloat(String fieldName, float value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setFloat(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setFloat(columnIndex, value);
     }
 
     /**
@@ -483,8 +485,8 @@ public void setFloat(String fieldName, float value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't a double field.
      */
     public void setDouble(String fieldName, double value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setDouble(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setDouble(columnIndex, value);
     }
 
     /**
@@ -495,8 +497,8 @@ public void setDouble(String fieldName, double value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't a String field.
      */
     public void setString(String fieldName, String value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setString(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setString(columnIndex, value);
     }
 
     /**
@@ -507,8 +509,8 @@ public void setString(String fieldName, String value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't a binary field.
      */
     public void setBlob(String fieldName, byte[] value) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        row.setBinaryByteArray(columnIndex, value);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        proxyState.getRow$realm().setBinaryByteArray(columnIndex, value);
     }
 
     /**
@@ -519,11 +521,11 @@ public void setBlob(String fieldName, byte[] value) {
      * @throws IllegalArgumentException if field name doesn't exists or isn't a Date field.
      */
     public void setDate(String fieldName, Date value) {
-        long columnIndex = row.getColumnIndex(fieldName);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         if (value == null) {
-            row.setNull(columnIndex);
+            proxyState.getRow$realm().setNull(columnIndex);
         } else {
-            row.setDate(columnIndex, value);
+            proxyState.getRow$realm().setDate(columnIndex, value);
         }
     }
 
@@ -536,23 +538,23 @@ public void setDate(String fieldName, Date value) {
      * of DynamicRealmObject doesn't match or it belongs to a different Realm.
      */
     public void setObject(String fieldName, DynamicRealmObject value) {
-        long columnIndex = row.getColumnIndex(fieldName);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         if (value == null) {
-            row.nullifyLink(columnIndex);
+            proxyState.getRow$realm().nullifyLink(columnIndex);
         } else {
-            if (value.realm == null || value.row == null) {
+            if (value.proxyState.getRealm$realm() == null || value.proxyState.getRow$realm() == null) {
                 throw new IllegalArgumentException("Cannot link to objects that are not part of the Realm.");
             }
-            if (realm != value.realm) {
+            if (proxyState.getRealm$realm() != value.proxyState.getRealm$realm()) {
                 throw new IllegalArgumentException("Cannot add an object from another Realm instance.");
             }
-            Table table = row.getTable().getLinkTarget(columnIndex);
-            Table inputTable = value.row.getTable();
+            Table table = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex);
+            Table inputTable = value.proxyState.getRow$realm().getTable();
             if (!table.hasSameSchema(inputTable)) {
                 throw new IllegalArgumentException(String.format("Type of object is wrong. Was %s, expected %s",
                         inputTable.getName(), table.getName()));
             }
-            row.setLink(columnIndex, value.row.getIndex());
+            proxyState.getRow$realm().setLink(columnIndex, value.proxyState.getRow$realm().getIndex());
         }
     }
 
@@ -565,19 +567,19 @@ public void setObject(String fieldName, DynamicRealmObject value) {
      * of the object represented by the DynamicRealmObject doesn't match or any element in the list belongs to a
      * different Realm.
      */
-    public void setList(String fieldName, RealmList<? extends RealmObject> list) {
+    public void setList(String fieldName, RealmList<? extends RealmModel> list) {
         if (list == null) {
             throw new IllegalArgumentException("Null values not allowed for lists");
         }
 
-        String tableName = row.getTable().getName();
+        String tableName = proxyState.getRow$realm().getTable().getName();
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
             // Standalone lists don't know anything about the types they contain. They might even hold objects of
             // multiple types :(, so we have to check each item in the list.
             typeValidated = false;
         } else {
-            String listType = list.className != null ? list.className : realm.schema.getTable(list.clazz).getName();
+            String listType = list.className != null ? list.className : proxyState.getRealm$realm().schema.getTable(list.clazz).getName();
             if (!tableName.equals(listType)) {
                 throw new IllegalArgumentException(String.format("The elements in the list is not the proper type. " +
                         "Was %s expected %s.", listType, tableName));
@@ -585,21 +587,21 @@ public void setList(String fieldName, RealmList<? extends RealmObject> list) {
             typeValidated = true;
         }
 
-        long columnIndex = row.getColumnIndex(fieldName);
-        LinkView links = row.getLinkList(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        LinkView links = proxyState.getRow$realm().getLinkList(columnIndex);
         links.clear();
         Table linkTargetTable = links.getTargetTable();
         for (int i = 0; i < list.size(); i++) {
-            RealmObject obj = list.get(i);
-            if (obj.realm != realm) {
+            RealmObjectProxy obj = (RealmObjectProxy) list.get(i);
+            if (obj.realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                 throw new IllegalArgumentException("Each element in 'list' must belong to the same Realm instance.");
             }
-            if (!typeValidated && !linkTargetTable.hasSameSchema(obj.row.getTable())) {
+            if (!typeValidated && !linkTargetTable.hasSameSchema(obj.realmGet$proxyState().getRow$realm().getTable())) {
                 throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                         "Element at index %d is not the proper type. " +
-                                "Was '%s' expected '%s'.", i, obj.row.getTable().getName(), linkTargetTable.getName()));
+                                "Was '%s' expected '%s'.", i, obj.realmGet$proxyState().getRow$realm().getTable().getName(), linkTargetTable.getName()));
             }
-            links.add(obj.row.getIndex());
+            links.add(obj.realmGet$proxyState().getRow$realm().getIndex());
         }
     }
 
@@ -610,12 +612,12 @@ public void setList(String fieldName, RealmList<? extends RealmObject> list) {
      * @throws IllegalArgumentException if field name doesn't exists, or the field isn't nullable.
      */
     public void setNull(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        RealmFieldType type = row.getColumnType(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         if (type == RealmFieldType.OBJECT) {
-            row.nullifyLink(columnIndex);
+            proxyState.getRow$realm().nullifyLink(columnIndex);
         } else {
-            row.setNull(columnIndex);
+            proxyState.getRow$realm().setNull(columnIndex);
         }
     }
 
@@ -626,7 +628,7 @@ public void setNull(String fieldName) {
      * @return this objects type.
      */
     public String getType() {
-        return RealmSchema.getSchemaForTable(row.getTable());
+        return RealmSchema.getSchemaForTable(proxyState.getRow$realm().getTable());
     }
 
     /**
@@ -635,15 +637,28 @@ public String getType() {
      * @return the underlying type used by Realm to represent this field.
      */
     public RealmFieldType getFieldType(String fieldName) {
-        long columnIndex = row.getColumnIndex(fieldName);
-        return row.getColumnType(columnIndex);
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        return proxyState.getRow$realm().getColumnType(columnIndex);
     }
 
+    /**
+     * Returns a hash code value for the {@link DynamicRealmObject} object.
+     * <p>
+     * By the general contract of {@link Object#hashCode()}, any two objects for which {@link #equals}
+     * returns {@code true} must return the same hash code value.
+     * <p>
+     * Note that a {@link RealmObject} is a live object, and it might be updated by changes from
+     * other threads. This means that a hash code value of the object is not stable, and the value
+     * should be neither used as a key in HashMap nor saved in HashSet.
+     *
+     * @return  a hash code value for the object.
+     * @see     #equals
+     */
     @Override
     public int hashCode() {
-        String realmName = realm.getPath();
-        String tableName = row.getTable().getName();
-        long rowIndex = row.getIndex();
+        String realmName = proxyState.getRealm$realm().getPath();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        long rowIndex = proxyState.getRow$realm().getIndex();
 
         int result = 17;
         result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
@@ -662,67 +677,67 @@ public boolean equals(Object o) {
         }
         DynamicRealmObject other = (DynamicRealmObject) o;
 
-        String path = realm.getPath();
-        String otherPath = other.realm.getPath();
+        String path = proxyState.getRealm$realm().getPath();
+        String otherPath = other.proxyState.getRealm$realm().getPath();
         if (path != null ? !path.equals(otherPath) : otherPath != null) {
             return false;
         }
 
-        String tableName = row.getTable().getName();
-        String otherTableName = other.row.getTable().getName();
+        String tableName = proxyState.getRow$realm().getTable().getName();
+        String otherTableName = other.proxyState.getRow$realm().getTable().getName();
         //noinspection SimplifiableIfStatement
         if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) {
             return false;
         }
 
-        return row.getIndex() == other.row.getIndex();
+        return proxyState.getRow$realm().getIndex() == other.proxyState.getRow$realm().getIndex();
     }
 
     @Override
     public String toString() {
-        if (row == null || !row.isAttached()) {
+        if (proxyState.getRealm$realm() == null || !proxyState.getRow$realm().isAttached()) {
             return "Invalid object";
         }
 
-        final String className = Table.tableNameToClassName(row.getTable().getName());
+        final String className = Table.tableNameToClassName(proxyState.getRow$realm().getTable().getName());
         StringBuilder sb = new StringBuilder(className + " = [");
         String[] fields = getFieldNames();
         for (String field : fields) {
-            long columnIndex = row.getColumnIndex(field);
-            RealmFieldType type = row.getColumnType(columnIndex);
+            long columnIndex = proxyState.getRow$realm().getColumnIndex(field);
+            RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
             sb.append("{");
             sb.append(field).append(":");
             switch (type) {
                 case BOOLEAN:
-                    sb.append(row.isNull(columnIndex) ? "null" : row.getBoolean(columnIndex));
+                    sb.append(proxyState.getRow$realm().isNull(columnIndex) ? "null" : proxyState.getRow$realm().getBoolean(columnIndex));
                     break;
                 case INTEGER:
-                    sb.append(row.isNull(columnIndex) ? "null" : row.getLong(columnIndex));
+                    sb.append(proxyState.getRow$realm().isNull(columnIndex) ? "null" : proxyState.getRow$realm().getLong(columnIndex));
                     break;
                 case FLOAT:
-                    sb.append(row.isNull(columnIndex) ? "null" : row.getFloat(columnIndex));
+                    sb.append(proxyState.getRow$realm().isNull(columnIndex) ? "null" : proxyState.getRow$realm().getFloat(columnIndex));
                     break;
                 case DOUBLE:
-                    sb.append(row.isNull(columnIndex) ? "null" : row.getDouble(columnIndex));
+                    sb.append(proxyState.getRow$realm().isNull(columnIndex) ? "null" : proxyState.getRow$realm().getDouble(columnIndex));
                     break;
                 case STRING:
-                    sb.append(row.getString(columnIndex));
+                    sb.append(proxyState.getRow$realm().getString(columnIndex));
                     break;
                 case BINARY:
-                    sb.append(Arrays.toString(row.getBinaryByteArray(columnIndex)));
+                    sb.append(Arrays.toString(proxyState.getRow$realm().getBinaryByteArray(columnIndex)));
                     break;
                 case DATE:
-                    sb.append(row.isNull(columnIndex) ? "null" : row.getDate(columnIndex));
+                    sb.append(proxyState.getRow$realm().isNull(columnIndex) ? "null" : proxyState.getRow$realm().getDate(columnIndex));
                     break;
                 case OBJECT:
-                    sb.append(row.isNullLink(columnIndex)
+                    sb.append(proxyState.getRow$realm().isNullLink(columnIndex)
                             ? "null"
-                            : Table.tableNameToClassName(row.getTable().getLinkTarget(columnIndex).getName()));
+                            : Table.tableNameToClassName(proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getName()));
                     break;
                 case LIST:
-                    final String tableName = row.getTable().getLinkTarget(columnIndex).getName();
+                    final String tableName = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getName();
                     String targetType = Table.tableNameToClassName(tableName);
-                    sb.append(String.format("RealmList<%s>[%s]", targetType, row.getLinkList(columnIndex).size()));
+                    sb.append(String.format("RealmList<%s>[%s]", targetType, proxyState.getRow$realm().getLinkList(columnIndex).size()));
                     break;
                 case UNSUPPORTED_TABLE:
                 case UNSUPPORTED_MIXED:
@@ -738,10 +753,7 @@ public String toString() {
     }
 
     @Override
-    protected Table getTable() {
-        if (className != null) {
-            return realm.schema.getTable(className);
-        }
-        return super.getTable();
+    public ProxyState realmGet$proxyState() {
+        return proxyState;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 8713584e04..fbce366d0e 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -17,6 +17,7 @@
 package io.realm;
 
 import android.os.Handler;
+import android.os.Looper;
 import android.os.Message;
 
 import java.lang.ref.Reference;
@@ -32,6 +33,7 @@
 import java.util.concurrent.Future;
 
 import io.realm.internal.IdentitySet;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedGroup;
 import io.realm.internal.async.BadVersionException;
@@ -41,48 +43,53 @@
 /**
  * Centralises all Handler callbacks, including updating async queries and refreshing the Realm.
  */
-public class HandlerController implements Handler.Callback {
-    // Keep a strong reference to the registered RealmChangeListener
-    // user should unregister those listeners
-    protected final CopyOnWriteArrayList<RealmChangeListener> changeListeners =
-            new CopyOnWriteArrayList<RealmChangeListener>();
-
-    // Keep a weak reference to the registered RealmChangeListener those are Weak since
-    // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener
-    protected final List<WeakReference<RealmChangeListener>> weakChangeListeners =
-            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();
+final class HandlerController implements Handler.Callback {
 
     static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
     static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
     static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
     static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
     static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
+
+    // Keep a strong reference to the registered RealmChangeListener
+    // user should unregister those listeners
+    final CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>> changeListeners = new CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>>();
+
+    // Keep a weak reference to the registered RealmChangeListener those are Weak since
+    // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener
+    final List<WeakReference<RealmChangeListener<? extends BaseRealm>>> weakChangeListeners =
+            new CopyOnWriteArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>();
+
     final BaseRealm realm;
-    // pending update of async queries
+    private boolean autoRefresh; // Requires a Looper thread to be true.
+
+    // pending update of async queriess
     private Future updateAsyncQueriesTask;
 
-    final ReferenceQueue<RealmResults<? extends RealmObject>> referenceQueueAsyncRealmResults = new ReferenceQueue<RealmResults<? extends RealmObject>>();
-    final ReferenceQueue<RealmResults<? extends RealmObject>> referenceQueueSyncRealmResults = new ReferenceQueue<RealmResults<? extends RealmObject>>();
-    final ReferenceQueue<RealmObject> referenceQueueRealmObject = new ReferenceQueue<RealmObject>();
+    private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueAsyncRealmResults =
+            new ReferenceQueue<RealmResults<? extends RealmModel>>();
+    private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueSyncRealmResults =
+            new ReferenceQueue<RealmResults<? extends RealmModel>>();
+    final ReferenceQueue<RealmModel> referenceQueueRealmObject = new ReferenceQueue<RealmModel>();
     // keep a WeakReference list to RealmResults obtained asynchronously in order to update them
     // RealmQuery is not WeakReferenced to prevent it from being GC'd. RealmQuery should be
     // cleaned if RealmResults is cleaned. we need to keep RealmQuery because it contains the query
     // pointer (to handover for each update) + all the arguments necessary to rerun the query:
     // sorting orders, soring columns, type (findAll, findFirst, findAllSorted etc.)
-    final Map<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<? extends RealmObject>> asyncRealmResults =
-            new IdentityHashMap<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<? extends RealmObject>>();
+    final Map<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<? extends RealmModel>> asyncRealmResults =
+            new IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<? extends RealmModel>>();
     // Keep a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
     // the query in the background for each commit, until we got a valid Row (pointer)
-    final Map<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>> emptyAsyncRealmObject =
-            new IdentityHashMap<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>>();
+    final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> emptyAsyncRealmObject =
+            new IdentityHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
 
     // keep a reference to the list of sync RealmResults, we'll use it
     // to deliver type based notification once the shared_group advance
-    final IdentitySet<WeakReference<RealmResults<? extends RealmObject>>> syncRealmResults =
-            new IdentitySet<WeakReference<RealmResults<? extends RealmObject>>>();
+    final IdentitySet<WeakReference<RealmResults<? extends RealmModel>>> syncRealmResults =
+            new IdentitySet<WeakReference<RealmResults<? extends RealmModel>>>();
 
-    final Map<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>> realmObjects =
-            new IdentityHashMap<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>>();
+    final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+            new IdentityHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
 
     public HandlerController(BaseRealm realm) {
         this.realm = realm;
@@ -130,7 +137,7 @@ public boolean handleMessage(Message message) {
         return true;
     }
 
-    void addChangeListener(RealmChangeListener listener) {
+    void addChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         changeListeners.addIfAbsent(listener);
     }
 
@@ -141,18 +148,18 @@ void addChangeListener(RealmChangeListener listener) {
      *
      * @param listener the change listener.
      */
-    void addChangeListenerAsWeakReference(RealmChangeListener listener) {
-        Iterator<WeakReference<RealmChangeListener>> iterator = weakChangeListeners.iterator();
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+    void addChangeListenerAsWeakReference(RealmChangeListener<? extends BaseRealm> listener) {
+        Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iterator = weakChangeListeners.iterator();
+        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         boolean addListener = true;
         while (iterator.hasNext()) {
-            WeakReference<RealmChangeListener> weakRef = iterator.next();
-            RealmChangeListener weakListener = weakRef.get();
+            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iterator.next();
+            RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
 
             // Collect all listeners that are GC'ed
             if (weakListener == null) {
                 if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
                 }
                 toRemoveList.add(weakRef);
             }
@@ -166,20 +173,20 @@ void addChangeListenerAsWeakReference(RealmChangeListener listener) {
             weakChangeListeners.removeAll(toRemoveList);
         }
         if (addListener) {
-            weakChangeListeners.add(new WeakReference<RealmChangeListener>(listener));
+            weakChangeListeners.add(new WeakReference<RealmChangeListener<? extends BaseRealm>>(listener));
         }
     }
 
-    void removeWeakChangeListener(RealmChangeListener listener) {
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+    void removeWeakChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
+        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         for (int i = 0; i < weakChangeListeners.size(); i++) {
-            WeakReference<RealmChangeListener> weakRef = weakChangeListeners.get(i);
-            RealmChangeListener weakListener = weakRef.get();
+            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = weakChangeListeners.get(i);
+            RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
 
             // Collect all listeners that are GC'ed or we need to remove
             if (weakListener == null || weakListener == listener) {
                 if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
                 }
                 toRemoveList.add(weakRef);
             }
@@ -188,7 +195,7 @@ void removeWeakChangeListener(RealmChangeListener listener) {
         weakChangeListeners.removeAll(toRemoveList);
     }
 
-    void removeChangeListener(RealmChangeListener listener) {
+    void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         changeListeners.remove(listener);
     }
 
@@ -196,26 +203,26 @@ void removeAllChangeListeners() {
         changeListeners.clear();
     }
 
-    void notifyGlobalListeners() {
+    private void notifyGlobalListeners() {
         // notify strong reference listener
-        Iterator<RealmChangeListener> iteratorStrongListeners = changeListeners.iterator();
+        Iterator<RealmChangeListener<? extends BaseRealm>> iteratorStrongListeners = changeListeners.iterator();
         while (iteratorStrongListeners.hasNext() && !realm.isClosed()) { // every callback could close the realm
             RealmChangeListener listener = iteratorStrongListeners.next();
-            listener.onChange();
+            listener.onChange(realm);
         }
         // notify weak reference listener (internals)
-        Iterator<WeakReference<RealmChangeListener>> iteratorWeakListeners = weakChangeListeners.iterator();
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+        Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iteratorWeakListeners = weakChangeListeners.iterator();
+        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         while (iteratorWeakListeners.hasNext() && !realm.isClosed()) {
-            WeakReference<RealmChangeListener> weakRef = iteratorWeakListeners.next();
+            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iteratorWeakListeners.next();
             RealmChangeListener listener = weakRef.get();
             if (listener == null) {
                 if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
                 }
                 toRemoveList.add(weakRef);
             } else {
-                listener.onChange();
+                listener.onChange(realm);
             }
         }
         if (toRemoveList != null) {
@@ -223,12 +230,12 @@ void notifyGlobalListeners() {
         }
     }
 
-    void updateAsyncEmptyRealmObject() {
-        Iterator<Map.Entry<WeakReference<RealmObject>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
+    private void updateAsyncEmptyRealmObject() {
+        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
         while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmObject>, RealmQuery<?>> next = iterator.next();
+            Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>> next = iterator.next();
             if (next.getKey().get() != null) {
-                Realm.asyncQueryExecutor
+                Realm.asyncTaskExecutor
                         .submit(QueryUpdateTask.newBuilder()
                                 .realmConfiguration(realm.getConfiguration())
                                 .addObject(next.getKey(),
@@ -246,6 +253,14 @@ void updateAsyncEmptyRealmObject() {
     void notifyAllListeners() {
         notifyGlobalListeners();
         notifyTypeBasedListeners();
+
+        // empty async RealmObject shouldn't block the realm to advance
+        // they're empty so no risk for running into a corrupt state
+        // where the pointer (Row) is using one version of a Realm, whereas the
+        // current Realm is advancing to a newer version (they're empty anyway)
+        if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
+            updateAsyncEmptyRealmObject();
+        }
     }
 
     private void notifyTypeBasedListeners() {
@@ -262,12 +277,12 @@ private void notifySyncRealmResultsCallbacks() {
         notifyRealmResultsCallbacks(syncRealmResults.keySet().iterator());
     }
 
-    private void notifyRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmObject>>> iterator) {
-        List<RealmResults<? extends RealmObject>> resultsToBeNotified =
-                new ArrayList<RealmResults<? extends RealmObject>>();
+    private void notifyRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator) {
+        List<RealmResults<? extends RealmModel>> resultsToBeNotified =
+                new ArrayList<RealmResults<? extends RealmModel>>();
         while (iterator.hasNext()) {
-            WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = iterator.next();
-            RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
+            WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = iterator.next();
+            RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
             if (realmResults == null) {
                 iterator.remove();
             } else {
@@ -276,34 +291,34 @@ private void notifyRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? e
             }
         }
 
-        for (Iterator<RealmResults<? extends RealmObject>> it = resultsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
-            RealmResults<? extends RealmObject> realmResults = it.next();
+        for (Iterator<RealmResults<? extends RealmModel>> it = resultsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
+            RealmResults<? extends RealmModel> realmResults = it.next();
             realmResults.notifyChangeListeners();
         }
     }
 
     private void notifyRealmObjectCallbacks() {
-        List<RealmObject> objectsToBeNotified = new ArrayList<RealmObject>();
-        Iterator<WeakReference<RealmObject>> iterator = realmObjects.keySet().iterator();
+        List<RealmObjectProxy> objectsToBeNotified = new ArrayList<RealmObjectProxy>();
+        Iterator<WeakReference<RealmObjectProxy>> iterator = realmObjects.keySet().iterator();
         while (iterator.hasNext()) {
-            WeakReference<? extends RealmObject> weakRealmObject = iterator.next();
-            RealmObject realmObject = weakRealmObject.get();
+            WeakReference<RealmObjectProxy> weakRealmObject = iterator.next();
+            RealmObjectProxy realmObject = weakRealmObject.get();
             if (realmObject == null) {
                 iterator.remove();
 
             } else {
-                if (realmObject.row.isAttached()) {
+                if (realmObject.realmGet$proxyState().getRow$realm().isAttached()) {
                     // It should be legal to modify realmObjects in the listener
                     objectsToBeNotified.add(realmObject);
-                } else if (realmObject.row != Row.EMPTY_ROW) {
+                } else if (realmObject.realmGet$proxyState().getRow$realm() != Row.EMPTY_ROW) {
                     iterator.remove();
                 }
             }
         }
 
-        for (Iterator<RealmObject> it = objectsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
-            RealmObject realmObject = it.next();
-            realmObject.notifyChangeListeners();
+        for (Iterator<RealmObjectProxy> it = objectsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
+            RealmObjectProxy realmObject = it.next();
+            realmObject.realmGet$proxyState().notifyChangeListeners$realm();
         }
     }
 
@@ -311,7 +326,7 @@ private void updateAsyncQueries() {
         if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
             // try to cancel any pending update since we're submitting a new one anyway
             updateAsyncQueriesTask.cancel(true);
-            Realm.asyncQueryExecutor.getQueue().remove(updateAsyncQueriesTask);
+            Realm.asyncTaskExecutor.getQueue().remove(updateAsyncQueriesTask);
             RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates");
         }
         RealmLog.d("REALM_CHANGED realm:"+ HandlerController.this + " updating async queries, total: " + asyncRealmResults.size());
@@ -321,11 +336,11 @@ private void updateAsyncQueries() {
         QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;
 
         // we iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch)
-        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
+        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
         while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>> entry = iterator.next();
-            WeakReference<RealmResults<? extends RealmObject>> weakReference = entry.getKey();
-            RealmResults<? extends RealmObject> realmResults = weakReference.get();
+            Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>> entry = iterator.next();
+            WeakReference<RealmResults<? extends RealmModel>> weakReference = entry.getKey();
+            RealmResults<? extends RealmModel> realmResults = weakReference.get();
             if (realmResults == null) {
                 // GC'd instance remove from the list
                 iterator.remove();
@@ -348,7 +363,7 @@ private void updateAsyncQueries() {
             QueryUpdateTask queryUpdateTask = realmResultsQueryStep
                     .sendToHandler(realm.handler, COMPLETED_UPDATE_ASYNC_QUERIES)
                     .build();
-            updateAsyncQueriesTask = Realm.asyncQueryExecutor.submit(queryUpdateTask);
+            updateAsyncQueriesTask = Realm.asyncTaskExecutor.submit(queryUpdateTask);
         }
     }
 
@@ -361,22 +376,15 @@ private void realmChanged() {
             RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " no async queries, advance_read");
             realm.sharedGroupManager.advanceRead();
             notifyAllListeners();
-            // empty async RealmObject shouldn't block the realm to advance
-            // they're empty so no risk on running into a corrupt state
-            // where the pointer (Row) is using one version of a Realm, whereas the
-            // current Realm is advancing to a newer version (they're empty anyway)
-            if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
-                updateAsyncEmptyRealmObject();
-            }
         }
     }
 
     private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
-        Set<WeakReference<RealmResults<? extends RealmObject>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
+        Set<WeakReference<RealmResults<? extends RealmModel>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
         if (updatedTableViewsKeys.size() > 0) {
-            WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = updatedTableViewsKeys.iterator().next();
+            WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = updatedTableViewsKeys.iterator().next();
 
-            RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
+            RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
             if (realmResults == null) {
                 asyncRealmResults.remove(weakRealmResults);
                 RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] realm:"+ HandlerController.this + " RealmResults GC'd ignore results");
@@ -420,7 +428,7 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                                 .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_RESULTS)
                                 .build();
 
-                        Realm.asyncQueryExecutor.submit(queryUpdateTask);
+                        Realm.asyncTaskExecutor.submit(queryUpdateTask);
 
                     } else {
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
@@ -442,10 +450,8 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
         SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
         int compare = callerVersionID.compareTo(result.versionID);
         if (compare > 0) {
-            RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, rerun updates");
-            // The caller is more advance than the updated queries ==>
-            // need to refresh them again (if there is still async queries)
-            realm.handler.sendEmptyMessage(REALM_CHANGED);
+            // if the caller thread is advanced i.e it already sent a REALM_CHANGE that will update the queries
+            RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, Looper will updates queries");
 
         } else {
             // We're behind or on the same version as the worker thread
@@ -469,11 +475,11 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 }
             }
 
-            ArrayList<RealmResults<? extends RealmObject>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmObject>>(result.updatedTableViews.size());
+            ArrayList<RealmResults<? extends RealmModel>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
             // use updated TableViews pointers for the existing async RealmResults
-            for (Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, Long> query : result.updatedTableViews.entrySet()) {
-                WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = query.getKey();
-                RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
+            for (Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, Long> query : result.updatedTableViews.entrySet()) {
+                WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = query.getKey();
+                RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
                 if (realmResults == null) {
                     // don't update GC'd instance
                     asyncRealmResults.remove(weakRealmResults);
@@ -491,7 +497,7 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 }
             }
 
-            for (RealmResults<? extends RealmObject> query : callbacksToNotify) {
+            for (RealmResults<? extends RealmModel> query : callbacksToNotify) {
                 query.notifyChangeListeners();
             }
 
@@ -506,12 +512,12 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
     }
 
     private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
-        Set<WeakReference<RealmObject>> updatedRowKey = result.updatedRow.keySet();
+        Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
         if (updatedRowKey.size() > 0) {
-            WeakReference<RealmObject> realmObjectWeakReference = updatedRowKey.iterator().next();
-            RealmObject realmObject = realmObjectWeakReference.get();
+            WeakReference<RealmObjectProxy> realmObjectWeakReference = updatedRowKey.iterator().next();
+            RealmObjectProxy proxy = realmObjectWeakReference.get();
 
-            if (realmObject != null) {
+            if (proxy != null) {
                 SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
                 int compare = callerVersionID.compareTo(result.versionID);
                 // we always query on the same version
@@ -523,19 +529,19 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                         emptyAsyncRealmObject.remove(realmObjectWeakReference);
                         realmObjects.put(realmObjectWeakReference, null);
                     }
-                    realmObject.onCompleted(rowPointer);
-                    realmObject.notifyChangeListeners();
+                    proxy.realmGet$proxyState().onCompleted$realm(rowPointer);
+                    proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                 } else if (compare > 0) {
                     // the caller has advanced we need to
                     // retry against the current version of the caller if it's still empty
-                    if (realmObject.isValid()) { // already completed & has a valid pointer no need to re-run
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ realmObject + "] , realm:" + HandlerController.this
+                    if (RealmObject.isValid(proxy)) { // already completed & has a valid pointer no need to re-run
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
                                 + " RealmObject is already loaded, just notify it.");
-                        realmObject.notifyChangeListeners();
+                        proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ realmObject + "] , realm:" + HandlerController.this
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
                                 + " RealmObject is not loaded yet. Rerun the query.");
                         RealmQuery<?> realmQuery = realmObjects.get(realmObjectWeakReference);
                         if (realmQuery == null) { // this is a retry of an empty RealmObject
@@ -550,7 +556,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                                 .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
                                 .build();
 
-                        Realm.asyncQueryExecutor.submit(queryUpdateTask);
+                        Realm.asyncTaskExecutor.submit(queryUpdateTask);
                     }
                 } else {
                     // should not happen, since the the background thread position itself against the provided version
@@ -570,9 +576,9 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
      */
     private boolean threadContainsAsyncQueries() {
         boolean isEmpty = true;
-        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
+        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
         while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>> next = iterator.next();
+            Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>> next = iterator.next();
             if (next.getKey().get() == null) {
                 iterator.remove();
             } else {
@@ -591,9 +597,9 @@ private boolean threadContainsAsyncQueries() {
      */
     boolean threadContainsAsyncEmptyRealmObject() {
         boolean isEmpty = true;
-        Iterator<Map.Entry<WeakReference<RealmObject>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
+        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
         while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmObject>, RealmQuery<?>> next = iterator.next();
+            Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>> next = iterator.next();
             if (next.getKey().get() == null) {
                 iterator.remove();
             } else {
@@ -605,8 +611,8 @@ boolean threadContainsAsyncEmptyRealmObject() {
     }
 
     private void deleteWeakReferences() {
-        Reference<? extends RealmResults<? extends RealmObject>> weakReferenceResults;
-        Reference<? extends RealmObject> weakReferenceObject;
+        Reference<? extends RealmResults<? extends RealmModel>> weakReferenceResults;
+        Reference<? extends RealmModel> weakReferenceObject;
         while ((weakReferenceResults = referenceQueueAsyncRealmResults.poll()) != null ) { // Does not wait for a reference to become available.
             asyncRealmResults.remove(weakReferenceResults);
         }
@@ -618,35 +624,84 @@ private void deleteWeakReferences() {
         }
     }
 
-    WeakReference<RealmResults<? extends RealmObject>> addToAsyncRealmResults(RealmResults<? extends RealmObject> realmResults, RealmQuery<? extends RealmObject> realmQuery) {
-        WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = new WeakReference<RealmResults<? extends RealmObject>>(realmResults,
+    WeakReference<RealmResults<? extends RealmModel>> addToAsyncRealmResults(RealmResults<? extends RealmModel> realmResults, RealmQuery<? extends RealmModel> realmQuery) {
+        WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = new WeakReference<RealmResults<? extends RealmModel>>(realmResults,
                 referenceQueueAsyncRealmResults);
         asyncRealmResults.put(weakRealmResults, realmQuery);
         return weakRealmResults;
     }
 
-    void addToRealmResults(RealmResults<? extends RealmObject> realmResults) {
-        WeakReference<RealmResults<? extends RealmObject>> realmResultsWeakReference
-                = new WeakReference<RealmResults<? extends RealmObject>>(realmResults, referenceQueueSyncRealmResults);
+    void addToRealmResults(RealmResults<? extends RealmModel> realmResults) {
+        WeakReference<RealmResults<? extends RealmModel>> realmResultsWeakReference
+                = new WeakReference<RealmResults<? extends RealmModel>>(realmResults, referenceQueueSyncRealmResults);
         syncRealmResults.add(realmResultsWeakReference);
     }
 
-    // add to the list of RealmObject to be notified after a commit
-    <E extends RealmObject> void addToRealmObjects(E realmobject) {
-        realmObjects.put(new WeakReference<RealmObject>(realmobject), null);
+    // Add to the list of RealmObject to be notified after a commit.
+    // This method will check if the object exists in the list. It won't add the same object multiple times
+    <E extends RealmObjectProxy> void addToRealmObjects(E realmObject) {
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            if (ref.get() == realmObject) {
+                return;
+            }
+        }
+        final WeakReference<RealmObjectProxy> realmObjectWeakReference =
+                new WeakReference<RealmObjectProxy>(realmObject, referenceQueueRealmObject);
+        realmObjects.put(realmObjectWeakReference, null);
     }
 
-    <E extends RealmObject> WeakReference<RealmObject> addToAsyncRealmObject(E realmObject, RealmQuery<? extends RealmObject> realmQuery) {
-        final WeakReference<RealmObject> realmObjectWeakReference = new WeakReference<RealmObject>(realmObject, referenceQueueRealmObject);
+    <E extends RealmObjectProxy> WeakReference<RealmObjectProxy> addToAsyncRealmObject(E realmObject, RealmQuery<? extends RealmModel> realmQuery) {
+        final WeakReference<RealmObjectProxy> realmObjectWeakReference = new WeakReference<RealmObjectProxy>(realmObject, referenceQueueRealmObject);
         realmObjects.put(realmObjectWeakReference, realmQuery);
         return realmObjectWeakReference;
     }
 
-    void removeFromAsyncRealmObject(WeakReference<RealmObject> realmObjectWeakReference) {
+    void removeFromAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakReference) {
         realmObjects.remove(realmObjectWeakReference);
     }
 
-    void addToEmptyAsyncRealmObject(WeakReference<RealmObject> realmObjectWeakReference, RealmQuery<? extends RealmObject> realmQuery) {
+    void addToEmptyAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakReference, RealmQuery<? extends RealmModel> realmQuery) {
         emptyAsyncRealmObject.put(realmObjectWeakReference, realmQuery);
     }
+
+    /**
+     * Refreshes all synchronous RealmResults by calling `sync_if_needed` on them. This will cause any backing queries
+     * to be rerun and any deleted objects will be removed from the TableView.
+     *
+     * WARNING: This will _NOT_ refresh TableViews created from async queries.
+     *
+     * Note this will _not_ notify any registered listeners.
+     */
+    public void refreshSynchronousTableViews() {
+        Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator = syncRealmResults.keySet().iterator();
+        while (iterator.hasNext()) {
+            WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = iterator.next();
+            RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
+            if (realmResults == null) {
+                iterator.remove();
+            } else {
+                realmResults.syncIfNeeded();
+            }
+        }
+    }
+
+    public void setAutoRefresh(boolean autoRefresh) {
+        if (autoRefresh && Looper.myLooper() == null) {
+            throw new IllegalStateException("Cannot enabled autorefresh on a non-looper thread.");
+        }
+        this.autoRefresh = autoRefresh;
+    }
+
+    public boolean isAutoRefreshEnabled() {
+        return autoRefresh;
+    }
+
+    /**
+     * Notify the current thread that the Realm has changed. This will also trigger change listener asynchronously.
+     */
+    public void notifyCurrentThreadRealmChanged() {
+        if (realm != null) {
+            realm.handler.sendEmptyMessage(HandlerController.REALM_CHANGED);
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index c0f11e1e47..f594bdd85a 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -24,7 +24,7 @@
  * index, with the first index being zero. Normally, {@code OrderedRealmCollection}s allow duplicate
  * elements, as compared to Sets, where elements have to be unique.
  */
-public interface OrderedRealmCollection<E extends RealmObject> extends List<E>, RealmCollection<E> {
+public interface OrderedRealmCollection<E extends RealmModel> extends List<E>, RealmCollection<E> {
 
     /**
      * Gets the first object from the collection.
@@ -47,7 +47,7 @@
      *
      * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
      *                  and String are supported.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or it has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
      *                                         an un-managed collection.
@@ -60,7 +60,7 @@
      * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
      *                  and String are supported.
      * @param sortOrder the direction to sort by.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
      *                                         an un-managed collection.
@@ -76,7 +76,7 @@
      * @param fieldName2 second field name. Only fields of type boolean, short, int, long, float,
      *                   double, Date, and String are supported.
      * @param sortOrder2 sort order for second field.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
      *                                         an un-managed collection.
@@ -89,7 +89,7 @@
      * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int, long, float,
      *                   double, Date, and String are supported.
      * @param sortOrders the directions to sort by.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
      *                                         an un-managed collection.
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
new file mode 100644
index 0000000000..96049817d8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Future;
+
+import io.realm.internal.InvalidRow;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+import io.realm.internal.TableQuery;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * This implements {@code RealmObjectProxy} interface, to eliminate copying logic between
+ * {@link RealmObject} and {@link DynamicRealmObject}.
+ */
+public final class ProxyState<E extends RealmModel> {
+    private E model;
+    private String className;
+    private Class<? extends RealmModel> clazzName;
+
+    private Row row;
+    private BaseRealm realm;
+
+    private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
+    private Future<Long> pendingQuery;
+    private boolean isCompleted = false;
+    protected long currentTableVersion = -1;
+
+    public ProxyState() {}
+
+    public ProxyState(E model) {
+        this.model = model;
+    }
+
+    public ProxyState(Class<? extends RealmModel> clazzName, E model) {
+        this.clazzName = clazzName;
+        this.model = model;
+    }
+
+    /**
+     * Sets the Future instance returned by the worker thread, we need this instance to force {@link RealmObject#load()} an async
+     * query, we use it to determine if the current RealmResults is a sync or async one.
+     *
+     * @param pendingQuery pending query.
+     */
+    public void setPendingQuery$realm(Future<Long> pendingQuery) {
+        this.pendingQuery = pendingQuery;
+        if (isLoaded()) {
+            // the query completed before RealmQuery
+            // had a chance to call setPendingQuery to register the pendingQuery (used btw
+            // to determine isLoaded behaviour)
+            onCompleted$realm();
+
+        } // else, it will be handled by the Realm#handler
+    }
+
+    public BaseRealm getRealm$realm() {
+        return realm;
+    }
+
+    public void setRealm$realm(BaseRealm realm) {
+        this.realm = realm;
+    }
+
+    public Row getRow$realm() {
+        return row;
+    }
+
+    public void setRow$realm(Row row) {
+        this.row = row;
+    }
+
+    public Object getPendingQuery$realm() {
+        return pendingQuery;
+    }
+
+    public boolean isCompleted$realm() {
+        return isCompleted;
+    }
+
+    /**
+     * Called to import the handover row pointer and notify listeners.
+     *
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     */
+    public boolean onCompleted$realm() {
+        try {
+            Long handoverResult = pendingQuery.get();// make the query blocking
+            if (handoverResult != 0) {
+                // this may fail with BadVersionException if the caller and/or the worker thread
+                // are not in sync (same shared_group version).
+                // COMPLETED_ASYNC_REALM_OBJECT will be fired by the worker thread
+                // this should handle more complex use cases like retry, ignore etc
+                onCompleted$realm(handoverResult);
+                notifyChangeListeners$realm();
+            } else {
+                isCompleted = true;
+            }
+        } catch (Exception e) {
+            RealmLog.d(e.getMessage());
+            return false;
+        }
+        return true;
+    }
+
+    public List<RealmChangeListener<E>> getListeners$realm() {
+        return listeners;
+    }
+
+    public void onCompleted$realm(long handoverRowPointer) {
+        if (handoverRowPointer == 0) {
+            // we'll retry later to update the row pointer, but we consider
+            // the query done
+            isCompleted = true;
+
+        } else if (!isCompleted || row == Row.EMPTY_ROW) {
+            isCompleted = true;
+            long nativeRowPointer = TableQuery.nativeImportHandoverRowIntoSharedGroup(handoverRowPointer, realm.sharedGroupManager.getNativePointer());
+            Table table = getTable();
+            this.row = table.getUncheckedRowByPointer(nativeRowPointer);
+        }// else: already loaded query no need to import again the pointer
+    }
+
+    /**
+     * Notifies all registered listeners.
+     */
+    void notifyChangeListeners$realm() {
+        if (!listeners.isEmpty()) {
+            boolean notify = false;
+
+            Table table = row.getTable();
+            if (table == null) {
+                // Completed async queries might result in `table == null`, `isCompleted == true` and `row == Row.EMPTY_ROW`
+                // We still want to trigger change notifications for these cases.
+                // isLoaded / isValid should be considered properties on RealmObjects as well so any change to these
+                // should trigger a RealmChangeListener.
+                notify = true;
+            } else {
+                long version = table.getVersion();
+                if (currentTableVersion != version) {
+                    currentTableVersion = version;
+                    notify = true;
+                }
+            }
+
+            if (notify) {
+                for (RealmChangeListener listener : listeners) {
+                    listener.onChange(model);
+                }
+            }
+        }
+    }
+
+    public void setTableVersion$realm() {
+        if (row.getTable() != null) {
+            currentTableVersion = row.getTable().getVersion();
+        }
+    }
+
+    public void setClassName(String className) {
+        this.className = className;
+    }
+
+    private Table getTable () {
+        if (className != null) {
+            return getRealm$realm().schema.getTable(className);
+        }
+        return getRealm$realm().schema.getTable(clazzName);
+    }
+
+    private boolean isLoaded() {
+        realm.checkIfValid();
+        return getPendingQuery$realm() == null || isCompleted$realm();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index c79abe99ae..c8926b45f9 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -122,8 +122,8 @@
     public static final String DEFAULT_REALM_NAME = RealmConfiguration.DEFAULT_REALM_NAME;
 
     // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmObject>, Table> classToTable =
-            new HashMap<Class<? extends RealmObject>, Table>();
+    private final Map<Class<? extends RealmModel>, Table> classToTable =
+            new HashMap<Class<? extends RealmModel>, Table>();
 
     private static RealmConfiguration defaultConfiguration;
 
@@ -305,10 +305,10 @@ private static void initializeRealm(Realm realm) {
             }
 
             RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
-            final Set<Class<? extends RealmObject>> modelClasses = mediator.getModelClasses();
-            final Map<Class<? extends RealmObject>, ColumnInfo> columnInfoMap;
-            columnInfoMap = new HashMap<Class<? extends RealmObject>, ColumnInfo>(modelClasses.size());
-            for (Class<? extends RealmObject> modelClass : modelClasses) {
+            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
+            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap;
+            columnInfoMap = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Create and validate table
                 if (version == UNVERSIONED) {
                     mediator.createTable(modelClass, realm.sharedGroupManager.getTransaction());
@@ -342,7 +342,7 @@ private static void initializeRealm(Realm realm) {
      * @param json an array where each JSONObject must map to the specified class.
      * @throws RealmException if mapping from JSON fails.
      */
-    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) {
+    public <E extends RealmModel> void createAllFromJson(Class<E> clazz, JSONArray json) {
         if (clazz == null || json == null) {
             return;
         }
@@ -350,8 +350,8 @@ private static void initializeRealm(Realm realm) {
         for (int i = 0; i < json.length(); i++) {
             try {
                 configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
-            } catch (Exception e) {
-                throw new RealmException("Could not map Json", e);
+            } catch (JSONException e) {
+                throw new RealmException("Could not map JSON", e);
             }
         }
     }
@@ -370,7 +370,7 @@ private static void initializeRealm(Realm realm) {
      * @throws RealmException if unable to map JSON.
      * @see #createAllFromJson(Class, org.json.JSONArray)
      */
-    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, JSONArray json) {
+    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, JSONArray json) {
         if (clazz == null || json == null) {
             return;
         }
@@ -378,8 +378,8 @@ private static void initializeRealm(Realm realm) {
         for (int i = 0; i < json.length(); i++) {
             try {
                 configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
-            } catch (Exception e) {
-                throw new RealmException("Could not map Json", e);
+            } catch (JSONException e) {
+                throw new RealmException("Could not map JSON", e);
             }
         }
     }
@@ -394,7 +394,7 @@ private static void initializeRealm(Realm realm) {
      * @param json the JSON array as a String where each object can map to the specified class.
      * @throws RealmException if mapping from JSON fails.
      */
-    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, String json) {
+    public <E extends RealmModel> void createAllFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
             return;
         }
@@ -402,7 +402,7 @@ private static void initializeRealm(Realm realm) {
         JSONArray arr;
         try {
             arr = new JSONArray(json);
-        } catch (Exception e) {
+        } catch (JSONException e) {
             throw new RealmException("Could not create JSON array from string", e);
         }
 
@@ -423,7 +423,7 @@ private static void initializeRealm(Realm realm) {
      * @throws RealmException if unable to create a JSON array from the json string.
      * @see #createAllFromJson(Class, String)
      */
-    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, String json) {
+    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
             return;
         }
@@ -451,7 +451,7 @@ private static void initializeRealm(Realm realm) {
      * @throws IOException if something was wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+    public <E extends RealmModel> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
         if (clazz == null || inputStream == null) {
             return;
         }
@@ -483,7 +483,7 @@ private static void initializeRealm(Realm realm) {
      * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException {
         if (clazz == null || in == null) {
             return;
         }
@@ -519,15 +519,15 @@ private static void initializeRealm(Realm realm) {
      * @throws RealmException if the mapping from JSON fails.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
-    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, JSONObject json) {
+    public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, JSONObject json) {
         if (clazz == null || json == null) {
             return null;
         }
 
         try {
             return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
-        } catch (Exception e) {
-            throw new RealmException("Could not map Json", e);
+        } catch (JSONException e) {
+            throw new RealmException("Could not map JSON", e);
         }
     }
 
@@ -545,19 +545,16 @@ private static void initializeRealm(Realm realm) {
      * @throws RealmException if JSON data cannot be mapped.
      * @see #createObjectFromJson(Class, org.json.JSONObject)
      */
-    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json) {
+    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json) {
         if (clazz == null || json == null) {
             return null;
         }
         checkHasPrimaryKey(clazz);
         try {
             E realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
-            if (handlerController != null) {
-                handlerController.addToRealmObjects(realmObject);
-            }
             return realmObject;
         } catch (JSONException e) {
-            throw new RealmException("Could not map Json", e);
+            throw new RealmException("Could not map JSON", e);
         }
     }
 
@@ -572,7 +569,7 @@ private static void initializeRealm(Realm realm) {
      * @return created object or null if json string was empty or null.
      * @throws RealmException if mapping to json failed.
      */
-    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, String json) {
+    public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
@@ -580,7 +577,7 @@ private static void initializeRealm(Realm realm) {
         JSONObject obj;
         try {
             obj = new JSONObject(json);
-        } catch (Exception e) {
+        } catch (JSONException e) {
             throw new RealmException("Could not create Json object from string", e);
         }
 
@@ -602,7 +599,7 @@ private static void initializeRealm(Realm realm) {
      * @throws RealmException if JSON object cannot be mapped from the string parameter.
      * @see #createObjectFromJson(Class, String)
      */
-    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, String json) {
+    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
@@ -611,7 +608,7 @@ private static void initializeRealm(Realm realm) {
         JSONObject obj;
         try {
             obj = new JSONObject(json);
-        } catch (Exception e) {
+        } catch (JSONException e) {
             throw new RealmException("Could not create Json object from string", e);
         }
 
@@ -631,7 +628,7 @@ private static void initializeRealm(Realm realm) {
      * @throws IOException if something was wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+    public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
         if (clazz == null || inputStream == null) {
             return null;
         }
@@ -680,7 +677,7 @@ private static void initializeRealm(Realm realm) {
      * @see #createObjectFromJson(Class, java.io.InputStream)
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException {
         if (clazz == null || in == null) {
             return null;
         }
@@ -713,7 +710,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @return the new object
      * @throws RealmException if an object could not be created
      */
-    public <E extends RealmObject> E createObject(Class<E> clazz) {
+    public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
         Table table = getTable(clazz);
         long rowIndex = table.addEmptyRow();
@@ -721,22 +718,26 @@ private Scanner getFullStringScanner(InputStream in) {
     }
 
     /**
-     * Creates a new object inside the Realm with the Primary key value initially set.
+     * Instantiates and adds a new object to the Realm with the primary key value already set.
+     *
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
      *
      * @param clazz the Class of the object to create.
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
-     * @throws RealmException if object could not be created.
+     * @throws RealmException if object could not be created due to the primary key being invalid.
+     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     *                                  expected value.
      */
-    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
+    public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
         Table table = getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
         return get(clazz, rowIndex);
     }
 
-    void remove(Class<? extends RealmObject> clazz, long objectIndex) {
+    void remove(Class<? extends RealmModel> clazz, long objectIndex) {
         getTable(clazz).moveLastOver(objectIndex);
     }
 
@@ -753,7 +754,7 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * @throws java.lang.IllegalArgumentException if the object is {@code null} or it belongs to a Realm instance
      * in a different thread.
      */
-    public <E extends RealmObject> E copyToRealm(E object) {
+    public <E extends RealmModel> E copyToRealm(E object) {
         checkNotNullObject(object);
         return copyOrUpdate(object, false);
     }
@@ -768,11 +769,11 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      *
      * @param object {@link io.realm.RealmObject} to copy or update.
      * @return the new or updated RealmObject with all its properties backed by the Realm.
-     * @throws java.lang.IllegalArgumentException if the object is {@code null} or it belongs to a Realm instance
-     *         in a different thread.
-     * @see #copyToRealm(RealmObject)
+     * @throws java.lang.IllegalArgumentException if the object is {@code null} or doesn't have a Primary key defined
+     *  or it belongs to a Realm instance in a different thread.
+     * @see #copyToRealm(RealmModel)
      */
-    public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
+    public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object.getClass());
         return copyOrUpdate(object, true);
@@ -791,7 +792,7 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * @throws io.realm.exceptions.RealmException if any of the objects has already been added to Realm.
      * @throws java.lang.IllegalArgumentException if any of the elements in the input collection is {@code null}.
      */
-    public <E extends RealmObject> List<E> copyToRealm(Iterable<E> objects) {
+    public <E extends RealmModel> List<E> copyToRealm(Iterable<E> objects) {
         if (objects == null) {
             return new ArrayList<E>();
         }
@@ -817,7 +818,7 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
      * @see #copyToRealm(Iterable)
      */
-    public <E extends RealmObject> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
+    public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
         if (objects == null) {
             return new ArrayList<E>(0);
         }
@@ -837,7 +838,7 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      *
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmObject)},
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmModel)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects,
      * and can potentially override changes made by other threads.
      *
@@ -847,7 +848,7 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
      * @see #copyToRealmOrUpdate(Iterable)
      */
-    public <E extends RealmObject> List<E> copyFromRealm(Iterable<E> realmObjects) {
+    public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects) {
         return copyFromRealm(realmObjects, Integer.MAX_VALUE);
     }
 
@@ -872,14 +873,14 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      *         {@link DynamicRealmObject}.
      * @see #copyToRealmOrUpdate(Iterable)
      */
-    public <E extends RealmObject> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
+    public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
         checkMaxDepth(maxDepth);
         if (realmObjects == null) {
             return new ArrayList<E>(0);
         }
 
         ArrayList<E> standaloneObjects = new ArrayList<E>();
-        Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> listCache = new HashMap<RealmObject, RealmObjectProxy.CacheData<RealmObject>>();
+        Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
             standaloneObjects.add(createDetachedCopy(object, maxDepth, listCache));
@@ -895,17 +896,17 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      *
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using
-     * {@link #copyToRealmOrUpdate(RealmObject)}, but all fields will be overridden, not just those that were changed.
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using 
+     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
      *
      * @param realmObject {@link RealmObject} to copy
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
-     * @see #copyToRealmOrUpdate(RealmObject)
+     * @see #copyToRealmOrUpdate(RealmModel)
      */
-    public <E extends RealmObject> E copyFromRealm(E realmObject) {
+    public <E extends RealmModel> E copyFromRealm(E realmObject) {
         return copyFromRealm(realmObject, Integer.MAX_VALUE);
     }
 
@@ -916,9 +917,9 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      *
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using
-     * {@link #copyToRealmOrUpdate(RealmObject)}, but all fields will be overridden, not just those that were changed.
-     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using 
+     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed. 
+     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being 
      * reached. This can also potentially override changes made by other threads.
      *
      * @param realmObject {@link RealmObject} to copy
@@ -928,15 +929,15 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
      *         {@link DynamicRealmObject}.
-     * @see #copyToRealmOrUpdate(RealmObject)
+     * @see #copyToRealmOrUpdate(RealmModel)
      */
-    public <E extends RealmObject> E copyFromRealm(E realmObject, int maxDepth) {
+    public <E extends RealmModel> E copyFromRealm(E realmObject, int maxDepth) {
         checkMaxDepth(maxDepth);
         checkValidObjectForDetach(realmObject);
-        return createDetachedCopy(realmObject, maxDepth, new HashMap<RealmObject, RealmObjectProxy.CacheData<RealmObject>>());
+        return createDetachedCopy(realmObject, maxDepth, new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>());
     }
 
-    boolean contains(Class<? extends RealmObject> clazz) {
+    boolean contains(Class<? extends RealmModel> clazz) {
         return configuration.getSchemaMediator().getModelClasses().contains(clazz);
     }
 
@@ -947,34 +948,47 @@ boolean contains(Class<? extends RealmObject> clazz) {
      * @return a typed RealmQuery, which can be used to query for specific objects of this type.
      * @see io.realm.RealmQuery
      */
-    public <E extends RealmObject> RealmQuery<E> where(Class<E> clazz) {
+    public <E extends RealmModel> RealmQuery<E> where(Class<E> clazz) {
         checkIfValid();
         return RealmQuery.createQuery(this, clazz);
     }
 
     /**
-     * Gets all objects of a specific Class. If no objects exist, the returned RealmResults will not be {@code null}.
-     * The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @return a RealmResult list containing the objects.
-     * @see io.realm.RealmResults
+     * Adds a change listener to the Realm.
+     * <p>
+     * The listeners will be executed:
+     * <ul>
+     * <li>Immediately if a change was committed by the local thread</li>
+     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
+     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
+     * </ul>
+     *
+     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
+     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
+     *
+     * @param listener the change listener.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     * @see #removeChangeListener(RealmChangeListener)
+     * @see #removeAllChangeListeners()
+     */
+    public void addChangeListener(RealmChangeListener<Realm> listener) {
+        super.addListener(listener);
+    }
+
+    /**
+     * DEPRECATED: Use {@code realm.where(clazz).findAll()} instead.
      */
-    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz) {
+    @Deprecated
+    public <E extends RealmModel> RealmResults<E> allObjects(Class<E> clazz) {
         return where(clazz).findAll();
     }
 
     /**
-     * Get all objects of a specific Class sorted by a field. If no objects exist, the returned {@link RealmResults}
-     * will not be {@code null}. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name to sort by.
-     * @param sortOrder how to sort the results.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName, sortOrder)} instead.
      */
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
+    @Deprecated
+    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                                     Sort sortOrder) {
         checkIfValid();
         Table table = getTable(clazz);
@@ -989,18 +1003,10 @@ boolean contains(Class<? extends RealmObject> clazz) {
 
 
     /**
-     * Gets all objects of a specific class sorted by two specific field names.  If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the class ti get objects of.
-     * @param fieldName1 first field name to sort by.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name to sort by.
-     * @param sortOrder2 sort order for second field.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
      */
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
+    @Deprecated
+    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                     Sort sortOrder1, String fieldName2,
                                                                     Sort sortOrder2) {
         return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
@@ -1008,20 +1014,11 @@ boolean contains(Class<? extends RealmObject> clazz) {
     }
 
     /**
-     * Gets all objects of a specific class sorted by two specific field names.  If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the class ti get objects of.
-     * @param fieldName1 first field name to sort by.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name to sort by.
-     * @param sortOrder2 sort order for second field.
-     * @param fieldName3 third field name to sort by.
-     * @param sortOrder3 sort order for third field.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2, fieldName3, sortOrder3)}
+     * instead.
      */
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
+    @Deprecated
+    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                     Sort sortOrder1,
                                                                     String fieldName2, Sort sortOrder2,
                                                                     String fieldName3, Sort sortOrder3) {
@@ -1030,18 +1027,11 @@ boolean contains(Class<? extends RealmObject> clazz) {
     }
 
     /**
-     * Gets all objects of a specific Class sorted by multiple fields. If no objects exist, the returned
-     * {@link RealmResults} will not be null. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @param sortOrders sort ascending if Sort.ASCENDING, sort descending if Sort.DESCENDING.
-     * @param fieldNames an array of field names to sort objects by. The objects are first sorted by fieldNames[0], then
-     *                   by fieldNames[1] and so forth.
-     * @return a sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldNames[], sortOrders[])} instead.
      */
+    @Deprecated
     @SuppressWarnings("unchecked")
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
+    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                                     Sort sortOrders[]) {
         checkAllObjectsSortedParameters(fieldNames, sortOrders);
         Table table = this.getTable(clazz);
@@ -1051,16 +1041,10 @@ boolean contains(Class<? extends RealmObject> clazz) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code realm.where(clazz).distinct(fieldName)} instead.
      */
-    public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String fieldName) {
+    @Deprecated
+    public <E extends RealmModel> RealmResults<E> distinct(Class<E> clazz, String fieldName) {
         checkIfValid();
         Table table = schema.getTable(clazz);
         long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
@@ -1069,36 +1053,18 @@ boolean contains(Class<? extends RealmObject> clazz) {
     }
 
     /**
-     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
-     * returned in case of multiple occurrences.
-     * This method is only available from a Looper thread.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name.
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     *         {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     *         query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     *         is not indexed, or points to linked fields.
+     * DEPRECATED: Use {@code realm.where(clazz).distinctAsync(fieldName)} instead.
      */
-    public <E extends RealmObject> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
+    @Deprecated
+    public <E extends RealmModel> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
         checkIfValid();
         return where(clazz).distinctAsync(fieldName);
     }
 
     /**
-     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
-     * given, all unique combinations of values in the fields will be returned. In case of multiple
-     * matches, it is undefined which object is returned. Unless the result is sorted, then the
-     * first object will be returned.
-     *
-     * @param clazz the Class to get objects of.
-     * @param firstFieldName first field name to use when finding distinct objects.
-     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     *         is an unsupported type, or points to a linked field.
+     * DEPRECATED: Use {@code realm.where(clazz).distinct(firstFieldName, remainingFieldNames)} instead.
      */
+    @Deprecated
     public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String firstFieldName, String... remainingFieldNames) {
         checkIfValid();
         return where(clazz).distinct(firstFieldName, remainingFieldNames);
@@ -1162,7 +1128,7 @@ public RealmAsyncTask executeTransaction(final Transaction transaction, final Tr
         // to perform the transaction
         final RealmConfiguration realmConfiguration = getConfiguration();
 
-        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+        final Future<?> pendingTransaction = asyncTaskExecutor.submit(new Runnable() {
             @Override
             public void run() {
                 if (Thread.currentThread().isInterrupted()) {
@@ -1226,7 +1192,7 @@ public void run() {
             }
         });
 
-        return new RealmAsyncTask(pendingQuery);
+        return new RealmAsyncTask(pendingTransaction);
     }
 
     /**
@@ -1303,7 +1269,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
         // to perform the transaction
         final RealmConfiguration realmConfiguration = getConfiguration();
 
-        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+        final Future<?> pendingTransaction= asyncTaskExecutor.submit(new Runnable() {
             @Override
             public void run() {
                 if (Thread.currentThread().isInterrupted()) {
@@ -1397,7 +1363,7 @@ public void run() {
             }
         });
 
-        return new RealmAsyncTask(pendingQuery);
+        return new RealmAsyncTask(pendingTransaction);
     }
 
 
@@ -1410,7 +1376,7 @@ public void run() {
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      */
     @Deprecated
-    public void clear(Class<? extends RealmObject> clazz) {
+    public void clear(Class<? extends RealmModel> clazz) {
         delete(clazz);
     }
 
@@ -1420,30 +1386,30 @@ public void clear(Class<? extends RealmObject> clazz) {
      * @param clazz the class which objects should be removed.
      * @throws IllegalStateException if the corresponding Realm is closed or called from an incorrect thread.
      */
-    public void delete(Class<? extends RealmObject> clazz) {
+    public void delete(Class<? extends RealmModel> clazz) {
         checkIfValid();
         getTable(clazz).clear();
     }
 
 
     @SuppressWarnings("unchecked")
-    private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
+    private <E extends RealmModel> E copyOrUpdate(E object, boolean update) {
         checkIfValid();
-        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, new HashMap<RealmObject, RealmObjectProxy>());
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, new HashMap<RealmModel, RealmObjectProxy>());
     }
 
-    private <E extends RealmObject> E createDetachedCopy(E object, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+    private <E extends RealmModel> E createDetachedCopy(E object, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
         checkIfValid();
         return configuration.getSchemaMediator().createDetachedCopy(object, maxDepth, cache);
     }
 
-    private <E extends RealmObject> void checkNotNullObject(E object) {
+    private <E extends RealmModel> void checkNotNullObject(E object) {
         if (object == null) {
             throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
         }
     }
 
-    private void checkHasPrimaryKey(Class<? extends RealmObject> clazz) {
+    private void checkHasPrimaryKey(Class<? extends RealmModel> clazz) {
         if (!getTable(clazz).hasPrimaryKey()) {
             throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
         }
@@ -1455,11 +1421,11 @@ private void checkMaxDepth(int maxDepth) {
         }
     }
 
-    private <E extends RealmObject> void checkValidObjectForDetach(E realmObject) {
+    private <E extends RealmModel> void checkValidObjectForDetach(E realmObject) {
         if (realmObject == null) {
             throw new IllegalArgumentException("Null objects cannot be copied from Realm.");
         }
-        if (!realmObject.isValid()) {
+        if (!RealmObject.isValid(realmObject)) {
             throw new IllegalArgumentException("RealmObject is not valid, so it cannot be copied.");
         }
         if (realmObject instanceof DynamicRealmObject) {
@@ -1529,11 +1495,11 @@ static String getCanonicalPath(File realmFile) {
         try {
             return realmFile.getCanonicalPath();
         } catch (IOException e) {
-            throw new RealmException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
+            throw new RealmIOException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
         }
     }
 
-    Table getTable(Class<? extends RealmObject> clazz) {
+    Table getTable(Class<? extends RealmModel> clazz) {
         Table table = classToTable.get(clazz);
         if (table == null) {
             clazz = Util.getOriginalModelClass(clazz);
@@ -1549,7 +1515,7 @@ Table getTable(Class<? extends RealmObject> clazz) {
      *
      * @return the default Realm module or null if no default module exists.
      * @throws RealmException if unable to create an instance of the module.
-     * @see io.realm.RealmConfiguration.Builder#setModules(Object, Object...)
+     * @see io.realm.RealmConfiguration.Builder#modules(Object, Object...)
      */
     public static Object getDefaultModule() {
         String moduleName = "io.realm.DefaultRealmModule";
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index df1ec5987d..aa53c0ce8e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -25,11 +25,11 @@
  * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
  * caller's thread callback).
  */
-public class RealmAsyncTask {
+public final class RealmAsyncTask {
     private final Future<?> pendingQuery;
     private volatile boolean isCancelled = false;
 
-    public RealmAsyncTask(Future<?> pendingQuery) {
+    RealmAsyncTask(Future<?> pendingQuery) {
         this.pendingQuery = pendingQuery;
     }
 
@@ -49,7 +49,7 @@ public void cancel() {
         // first thread is attempting to purge the queue the attempt to purge
         // the queue fails and the cancelled object remain in the queue.
         // A better way to cancel objects with thread pools is to use the remove()
-        Realm.asyncQueryExecutor.getQueue().remove(pendingQuery);
+        Realm.asyncTaskExecutor.getQueue().remove(pendingQuery);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java b/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
deleted file mode 100644
index 151b875ece..0000000000
--- a/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.widget.BaseAdapter;
-
-/**
- * The RealmBaseAdapter class is an abstract utility class for binding UI elements to Realm data, much like an
- * {@link android.widget.CursorAdapter}.
- * <p>
- * This adapter will automatically handle any updates to its data and call {@link #notifyDataSetChanged()} as
- * appropriate.
- * <p>
- * The RealmAdapter will stop receiving updates if the Realm instance providing the {@link io.realm.RealmResults} is
- * closed. Trying to access read objects, will at this point also result in a
- * {@link io.realm.exceptions.RealmException}.
- */
-public abstract class RealmBaseAdapter<T extends RealmObject> extends BaseAdapter {
-
-    protected LayoutInflater inflater;
-    protected OrderedRealmCollection<T> adapterData;
-    protected Context context;
-    private final RealmChangeListener listener;
-
-    public RealmBaseAdapter(Context context, OrderedRealmCollection<T> data, boolean automaticUpdate) {
-        if (context == null) {
-            throw new IllegalArgumentException("Context cannot be null");
-        }
-        this.context = context;
-        this.adapterData = data;
-        this.inflater = LayoutInflater.from(context);
-        this.listener = (!automaticUpdate) ? null : new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                notifyDataSetChanged();
-            }
-        };
-
-        if (listener != null && data != null) {
-            addListener(data);
-        }
-    }
-
-    private void addListener(OrderedRealmCollection<T> data) {
-        if (data instanceof RealmResults) {
-            RealmResults realmResults = (RealmResults) data;
-            realmResults.realm.handlerController.addChangeListenerAsWeakReference(listener);
-        } else if (data instanceof RealmList) {
-            RealmList realmList = (RealmList) data;
-            realmList.realm.handlerController.addChangeListenerAsWeakReference(listener);
-        } else {
-            throw new IllegalArgumentException("RealmCollection not supported: " + data.getClass());
-        }
-    }
-
-    private void removeListener(OrderedRealmCollection<T> data) {
-        if (data instanceof RealmResults) {
-            RealmResults realmResults = (RealmResults) data;
-            realmResults.realm.handlerController.removeWeakChangeListener(listener);
-        } else if (data instanceof RealmList) {
-            RealmList realmList = (RealmList) data;
-            realmList.realm.handlerController.removeWeakChangeListener(listener);
-        } else {
-            throw new IllegalArgumentException("RealmCollection not supported: " + data.getClass());
-        }
-    }
-
-    /**
-     * Returns how many items are in the data set.
-     *
-     * @return count of items.
-     */
-    @Override
-    public int getCount() {
-        if (adapterData == null) {
-            return 0;
-        }
-        return adapterData.size();
-    }
-
-    /**
-     * Returns the item associated with the specified position.
-     *
-     * @param i index of item whose data we want.
-     * @return the item at the specified position.
-     */
-    @Override
-    public T getItem(int i) {
-        if (adapterData == null) {
-            return null;
-        }
-        return adapterData.get(i);
-    }
-
-    /**
-     * Returns the current ID for an item. Note that item IDs are not stable so you cannot rely on the item ID being the
-     * same after {@link #notifyDataSetChanged()} or {@link #updateRealmResults(RealmResults)} has been called.
-     *
-     * @param i index of item in the adapter.
-     * @return current item ID.
-     */
-    @Override
-    public long getItemId(int i) {
-        // TODO: find better solution once we have unique IDs
-        return i;
-    }
-
-    /**
-     * DEPRECATED: Use {@link #updateData(OrderedRealmCollection)} instead.
-     */
-    @Deprecated
-    public void updateRealmResults(RealmResults<T> queryResults) {
-        updateData(queryResults);
-    }
-
-    /**
-     * Updates the data associated with the Adapter.
-     *
-     * Note that RealmResults and RealmLists are "live" views, so they will automatically be updated to reflect the
-     * latest changes. This will also trigger {@code notifyDataSetChanged()} to be called on the adapter.
-     *
-     * This method is therefor only useful if you want to display data based on a new query without replacing the
-     * adapter.
-     *
-     * @param data the new {@link OrderedRealmCollection} to display.
-     */
-    public void updateData(OrderedRealmCollection<T> data) {
-        if (listener != null) {
-            if (adapterData != null) {
-                removeListener(adapterData);
-            }
-            if (data != null) {
-                addListener(data);
-            }
-        }
-
-        this.adapterData = data;
-        notifyDataSetChanged();
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 991f596000..35b554dc21 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -30,12 +30,16 @@
  * One {@link RealmCache} is created for each {@link RealmConfiguration}, and it caches all the {@link Realm} and
  * {@link DynamicRealm} instances which are created from the same {@link RealmConfiguration}.
  */
-class RealmCache {
+final class RealmCache {
 
     interface Callback {
         void onResult(int count);
     }
 
+    interface Callback0 {
+        void onCall();
+    }
+
     private static class RefAndCount {
         // The Realm instance in this thread.
         private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<BaseRealm>();
@@ -223,6 +227,19 @@ private void validateConfiguration(RealmConfiguration newConfiguration) {
         if (!Arrays.equals(configuration.getEncryptionKey(), newConfiguration.getEncryptionKey())) {
             throw new IllegalArgumentException(DIFFERENT_KEY_MESSAGE);
         } else {
+            // A common problem is that people are forgetting to override `equals` in their custom migration class.
+            // Try to detect this problem specifically so we can throw a better error message.
+            RealmMigration newMigration = newConfiguration.getMigration();
+            RealmMigration oldMigration = configuration.getMigration();
+            if (oldMigration != null 
+                && newMigration != null 
+                && oldMigration.getClass().equals(newMigration.getClass())
+                && !newMigration.equals(oldMigration)) {
+                throw new IllegalArgumentException("Configurations cannot be different if used to open the same file. " +
+                        "The most likely cause is that equals() and hashCode() are not overridden in the " +
+                        "migration class: " + newConfiguration.getMigration().getClass().getCanonicalName());
+            }
+
             throw new IllegalArgumentException("Configurations cannot be different if used to open the same file. " +
                     "\nCached configuration: \n" + configuration +
                     "\n\nNew configuration: \n" + newConfiguration);
@@ -248,4 +265,13 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
         }
         callback.onResult(totalRefCount);
     }
+
+    /**
+     * Runs the callback function with synchronization on {@class RealmCache}.
+     *
+     * @param callback the callback will be executed.
+     */
+    static synchronized void invokeWithLock(Callback0 callback) {
+        callback.onCall();
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
index 290910d634..f68e7f6be4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -29,19 +29,23 @@
  * for that background thread.
  * <p>
  * All {@link io.realm.RealmObject} and {@link io.realm.RealmResults} will automatically contain their new values when
- * the {@link #onChange()} method is called. Normally this means that it isn't necessary to query again for those
+ * the {@link #onChange(Object)} method is called. Normally this means that it isn't necessary to query again for those
  * objects, but just invalidate any UI elements that are using them. If there is a chance that a object has been been
  * deleted, it can be verified by using {@link RealmObject#isValid()}.
  *
+ * @param <T> The <a href="https://realm.io/docs/java/latest/#auto-updating-objects">live object</a> being returned
+ *         ({@link Realm}, {@link DynamicRealm}, {@link RealmObject}, {@link RealmResults}, {@link DynamicRealmObject}
+ *          or your model implementing {@link RealmModel})
+ *
  * @see Realm#addChangeListener(RealmChangeListener)
  * @see Realm#removeAllChangeListeners()
  * @see Realm#removeChangeListener(RealmChangeListener)
  */
-public interface RealmChangeListener {
+public interface RealmChangeListener<T> {
 
     /**
      * Called when a transaction is committed.
      */
-    void onChange();
+    void onChange(T element);
 
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 4995ecf21b..7c4328c8d8 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -17,9 +17,10 @@
 package io.realm;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Date;
 
+import java.util.Collections;
+
 /**
  * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
  * collections and the behavior that they will have in all implementations of {@code RealmCollection}s.
@@ -30,7 +31,7 @@
  *
  * @param <E> type of {@link RealmObject} stored in the collection.
  */
-public interface RealmCollection<E extends RealmObject> extends Collection<E> {
+public interface RealmCollection<E extends RealmModel> extends Collection<E> {
 
     /**
      * Returns a {@link RealmQuery}, which can be used to query for specific objects from this collection.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index a0789eee76..89d723eeb7 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -54,7 +54,7 @@
  * - It is saved in Context.getFilesDir()
  * - It has its schema version set to 0.
  */
-public class RealmConfiguration {
+public final class RealmConfiguration {
 
     public static final String DEFAULT_REALM_NAME = "default.realm";
     public static final int KEY_LENGTH = 64;
@@ -155,7 +155,7 @@ RealmProxyMediator getSchemaMediator() {
      *
      * @return unmodifiable {@link Set} of model classes.
      */
-    public Set<Class<? extends RealmObject>> getRealmObjectClasses() {
+    public Set<Class<? extends RealmModel>> getRealmObjectClasses() {
         return schemaMediator.getModelClasses();
     }
 
@@ -221,7 +221,7 @@ public int hashCode() {
     private RealmProxyMediator createSchemaMediator(Builder builder) {
 
         Set<Object> modules = builder.modules;
-        Set<Class<? extends RealmObject>> debugSchema = builder.debugSchema;
+        Set<Class<? extends RealmModel>> debugSchema = builder.debugSchema;
 
         // If using debug schema, use special mediator
         if (debugSchema.size() > 0) {
@@ -311,7 +311,7 @@ private static synchronized boolean isRxJavaAvailable() {
     /**
      * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
      */
-    public static class Builder {
+    public static final class Builder {
         private File folder;
         private String fileName;
         private byte[] key;
@@ -320,7 +320,7 @@ private static synchronized boolean isRxJavaAvailable() {
         private boolean deleteRealmIfMigrationNeeded;
         private SharedGroup.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
-        private HashSet<Class<? extends RealmObject>> debugSchema = new HashSet<Class<? extends RealmObject>>();
+        private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
 
@@ -457,6 +457,15 @@ public Builder inMemory() {
             return this;
         }
 
+        /**
+         * DEPRECATED: Use {@link #modules(Object, Object...)} instead.
+         */
+        @Deprecated
+        public Builder setModules(Object baseModule, Object... additionalModules) {
+            modules(baseModule, additionalModules);
+            return this;
+        }
+
         /**
          * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
          * current schema for this Realm with the schema defined by the provided modules.
@@ -465,14 +474,14 @@ public Builder inMemory() {
          * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
          * dependency is thus done using the following code:
          *
-         * {@code builder.setModules(Realm.getDefaultMode(), new MyLibraryModule()); }
+         * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
          *
          * @param baseModule the first Realm module (required).
          * @param additionalModules the additional Realm modules
          * @throws IllegalArgumentException if any of the modules doesn't have the {@link RealmModule} annotation.
          * @see Realm#getDefaultModule()
          */
-        public Builder setModules(Object baseModule, Object... additionalModules) {
+        public Builder modules(Object baseModule, Object... additionalModules) {
             modules.clear();
             addModule(baseModule);
             if (additionalModules != null) {
@@ -518,7 +527,7 @@ private void addModule(Object module) {
          * create a module. These classes must be available in the default module. Calling this will remove any
          * previously configured modules.
          */
-        Builder schema(Class<? extends RealmObject> firstClass, Class<? extends RealmObject>... additionalClasses) {
+        Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmModel>... additionalClasses) {
             if (firstClass == null) {
                 throw new IllegalArgumentException("A non-null class must be provided");
             }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index b5b4df2c0f..ac3f1e6af3 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -37,7 +37,8 @@
     BINARY(4),
     UNSUPPORTED_TABLE(5),
     UNSUPPORTED_MIXED(6),
-    DATE(7),
+    UNSUPPORTED_DATE(7),
+    DATE(8),
     FLOAT(9),
     DOUBLE(10),
     OBJECT(12),
@@ -89,7 +90,8 @@ public boolean isValid(Object obj) {
                     obj instanceof byte[] || obj instanceof ByteBuffer ||
                     obj == null || obj instanceof Object[][] ||
                     obj instanceof java.util.Date);
-            case 7: return (obj instanceof java.util.Date);
+            case 7: return (obj instanceof java.util.Date); // the unused DateTime
+            case 8: return (obj instanceof java.util.Date);
             case 9: return (obj instanceof Float);
             case 10: return (obj instanceof Double);
             case 12: return false;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index d2edb9917a..c7d66424d0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -20,11 +20,16 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.Date;
+import java.util.Iterator;
 import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
 
 import io.realm.internal.InvalidRow;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
 
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
@@ -44,7 +49,7 @@
  * @param <E> the class of objects in list.
  */
 
-public class RealmList<E extends RealmObject> extends AbstractList<E> implements OrderedRealmCollection<E> {
+public final class RealmList<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
     private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
     private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
@@ -133,11 +138,11 @@ private boolean isAttached() {
      * <ol>
      * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
      * objects to a un-managed RealmList they will not be copied to the Realm again if using
-     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
      * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
-     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
-     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
      *
      * @param location the index at which to insert.
@@ -153,11 +158,12 @@ public void add(int location, E object) {
             if (location < 0 || location > size()) {
                 throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size());
             }
-            object = copyToRealmIfNeeded(object);
-            view.insert(location, object.row.getIndex());
+            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
+            view.insert(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
             nonManagedList.add(location, object);
         }
+        modCount++;
     }
 
     /**
@@ -165,11 +171,11 @@ public void add(int location, E object) {
      * <ol>
      * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
      * objects to a un-managed RealmList they will not be copied to the Realm again if using
-     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
      * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
-     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
-     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
      *
      * @param object the object to add.
@@ -181,11 +187,12 @@ public boolean add(E object) {
         checkValidObject(object);
         if (managedMode) {
             checkValidView();
-            object = copyToRealmIfNeeded(object);
-            view.add(object.row.getIndex());
+            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
+            view.add(proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
             nonManagedList.add(object);
         }
+        modCount++;
         return true;
     }
 
@@ -194,11 +201,11 @@ public boolean add(E object) {
      * <ol>
      * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
      * objects to a un-managed RealmList they will not be copied to the Realm again if using
-     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
      * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed.
-     * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)} or
-     * {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
+     * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
      * @param location the index at which to put the specified object.
      * @param object the object to add.
@@ -209,46 +216,52 @@ public boolean add(E object) {
     @Override
     public E set(int location, E object) {
         checkValidObject(object);
+        E oldObject;
         if (managedMode) {
             checkValidView();
-            object = copyToRealmIfNeeded(object);
-            E oldObject = get(location);
-            view.set(location, object.row.getIndex());
+            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
+            oldObject = get(location);
+            view.set(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
             return oldObject;
         } else {
-            return nonManagedList.set(location, object);
+            oldObject = nonManagedList.set(location, object);
         }
+        return oldObject;
     }
 
     // Transparently copies a standalone object or managed object from another Realm to the Realm backing this RealmList.
     private E copyToRealmIfNeeded(E object) {
-        if (object instanceof DynamicRealmObject) {
-            String listClassName = RealmSchema.getSchemaForTable(view.getTargetTable());
-            String objectClassName = ((DynamicRealmObject) object).getType();
-            if (object.realm == realm) {
-                if (listClassName.equals(objectClassName)) {
-                    // Same Realm instance and same target table
-                    return object;
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+
+            if (proxy instanceof DynamicRealmObject) {
+                String listClassName = RealmSchema.getSchemaForTable(view.getTargetTable());
+                String objectClassName = ((DynamicRealmObject) object).getType();
+                if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
+                    if (listClassName.equals(objectClassName)) {
+                        // Same Realm instance and same target table
+                        return object;
+                    } else {
+                        // Different target table
+                        throw new IllegalArgumentException(String.format("The object has a different type from list's." +
+                                " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
+                    }
+                } else if (realm.threadId == proxy.realmGet$proxyState().getRealm$realm().threadId) {
+                    // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
+                    // you have to run a full schema validation for each object.
+                    // And copying from another Realm instance pointed to the same Realm file is not supported as well.
+                    throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
                 } else {
-                    // Different target table
-                    throw new IllegalArgumentException(String.format("The object has a different type from list's." +
-                            " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
+                    throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
                 }
-            } else if (realm.threadId == object.realm.threadId) {
-                // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
-                // you have to run a full schema validation for each object.
-                // And copying from another Realm instance pointed to the same Realm file is not supported as well.
-                throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
             } else {
-                throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
-            }
-        } else {
-            // Object is already in this realm
-            if (object.row != null && object.realm.getPath().equals(realm.getPath())) {
-                if (realm != object.realm) {
-                    throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
+                // Object is already in this realm
+                if (proxy.realmGet$proxyState().getRow$realm() != null && proxy.realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    if (realm != proxy.realmGet$proxyState().getRealm$realm()) {
+                        throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
+                    }
+                    return object;
                 }
-                return object;
             }
         }
 
@@ -303,6 +316,7 @@ public void clear() {
         } else {
             nonManagedList.clear();
         }
+        modCount++;
     }
 
     /**
@@ -315,14 +329,16 @@ public void clear() {
      */
     @Override
     public E remove(int location) {
+        E removedItem;
         if (managedMode) {
             checkValidView();
-            E removedItem = get(location);
+            removedItem = get(location);
             view.remove(location);
-            return removedItem;
         } else {
-            return nonManagedList.remove(location);
+            removedItem = nonManagedList.remove(location);
         }
+        modCount++;
+        return removedItem;
     }
 
     /**
@@ -382,6 +398,7 @@ public boolean deleteFirstFromRealm() {
         if (managedMode) {
             if (size() > 0) {
                 deleteFromRealm(0);
+                modCount++;
                 return true;
             } else {
                 return false;
@@ -399,6 +416,7 @@ public boolean deleteLastFromRealm() {
         if (managedMode) {
             if (size() > 0) {
                 deleteFromRealm(size() - 1);
+                modCount++;
                 return true;
             } else {
                 return false;
@@ -511,6 +529,7 @@ public void deleteFromRealm(int location) {
         if (managedMode) {
             checkValidView();
             view.removeTargetRow(location);
+            modCount++;
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
@@ -630,6 +649,7 @@ public boolean deleteAllFromRealm() {
             checkValidView();
             if (size() > 0) {
                 view.removeAllTargetRows();
+                modCount++;
                 return true;
             } else {
                 return false;
@@ -670,10 +690,10 @@ public boolean contains(Object object) {
         boolean contains = false;
         if (managedMode) {
             realm.checkIfValid();
-            if (object instanceof RealmObject) {
-                RealmObject realmObject = (RealmObject) object;
-                if (realmObject.row != null && realm.getPath().equals(realmObject.realm.getPath()) && realmObject.row != InvalidRow.INSTANCE) {
-                    contains = view.contains(realmObject.row.getIndex());
+            if (object instanceof RealmObjectProxy) {
+                RealmObjectProxy proxy = (RealmObjectProxy) object;
+                if (proxy.realmGet$proxyState().getRow$realm() != null && realm.getPath().equals(proxy.realmGet$proxyState().getRealm$realm().getPath()) && proxy.realmGet$proxyState().getRow$realm() != InvalidRow.INSTANCE) {
+                    contains = view.contains(proxy.realmGet$proxyState().getRow$realm().getIndex());
                 }
             }
         } else {
@@ -682,6 +702,38 @@ public boolean contains(Object object) {
         return contains;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<E> iterator() {
+        if (managedMode) {
+            return new RealmItr();
+        } else {
+            return super.iterator();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public ListIterator<E> listIterator() {
+        return listIterator(0);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public ListIterator<E> listIterator(int location) {
+        if (managedMode) {
+            return new RealmListItr(location);
+        } else {
+            return super.listIterator(location);
+        }
+    }
+
     private void checkValidObject(E object) {
         if (object == null) {
             throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
@@ -712,7 +764,7 @@ public String toString() {
         } else {
             for (int i = 0; i < size(); i++) {
                 if (managedMode) {
-                    sb.append(get(i).row.getIndex());
+                    sb.append(((RealmObjectProxy) get(i)).realmGet$proxyState().getRow$realm().getIndex());
                 } else {
                     sb.append(System.identityHashCode(get(i)));
                 }
@@ -724,4 +776,174 @@ public String toString() {
         sb.append("]");
         return sb.toString();
     }
+
+    // Custom RealmList iterator.
+    private class RealmItr implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        int cursor = 0;
+
+        /**
+         * Index of element returned by most recent call to next or
+         * previous.  Reset to -1 if this element is deleted by a call
+         * to remove.
+         */
+        int lastRet = -1;
+
+        /**
+         * The modCount value that the iterator believes that the backing
+         * List should have.  If this expectation is violated, the iterator
+         * has detected concurrent modification.
+         */
+        int expectedModCount = modCount;
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean hasNext() {
+            realm.checkIfValid();
+            checkConcurrentModification();
+            return cursor != size();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public E next() {
+            realm.checkIfValid();
+            checkConcurrentModification();
+            int i = cursor;
+            try {
+                E next = get(i);
+                lastRet = i;
+                cursor = i + 1;
+                return next;
+            } catch (IndexOutOfBoundsException e) {
+                checkConcurrentModification();
+                throw new NoSuchElementException("Cannot access index " + i + " when size is " + size() +  ". Remember to check hasNext() before using next().");
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void remove() {
+            realm.checkIfValid();
+            if (lastRet < 0) {
+                throw new IllegalStateException("Cannot call remove() twice. Must call next() in between.");
+            }
+            checkConcurrentModification();
+
+            try {
+                RealmList.this.remove(lastRet);
+                if (lastRet < cursor) {
+                    cursor--;
+                }
+                lastRet = -1;
+                expectedModCount = modCount;
+            } catch (IndexOutOfBoundsException e) {
+                throw new ConcurrentModificationException();
+            }
+        }
+
+        final void checkConcurrentModification() {
+            // A Realm ListView is backed by the original Table and not a TableView, this means
+            // that all changes are reflected immediately. It is therefore not possible to use
+            // the same version pinning trick we use for RealmResults (avoiding calling sync_if_needed)
+            // Fortunately a LinkView does not change unless manually altered (unlike RealmResults)
+            // So therefore it should be acceptable to use the same heuristic as a normal AbstractList
+            // when detecting concurrent modifications.
+            if (modCount != expectedModCount) {
+                throw new ConcurrentModificationException();
+            }
+        }
+    }
+
+    private class RealmListItr extends RealmItr implements ListIterator<E> {
+
+        RealmListItr(int index) {
+            if (index >= 0 && index <= size()) {
+                cursor = index;
+            } else {
+                throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, " + (size() - 1) + "]. Index was " + index);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean hasPrevious() {
+            return cursor != 0;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public E previous() {
+            checkConcurrentModification();
+            int i = cursor - 1;
+            try {
+                E previous = get(i);
+                lastRet = cursor = i;
+                return previous;
+            } catch (IndexOutOfBoundsException e) {
+                checkConcurrentModification();
+                throw new NoSuchElementException("Cannot access index less than zero. This was " + i + ". Remember to check hasPrevious() before using previous().");
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public int nextIndex() {
+            return cursor;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public int previousIndex() {
+            return cursor - 1;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public void set(E e) {
+            realm.checkIfValid();
+            if (lastRet < 0) {
+                throw new IllegalStateException();
+            }
+            checkConcurrentModification();
+
+            try {
+                RealmList.this.set(lastRet, e);
+                expectedModCount = modCount;
+            } catch (IndexOutOfBoundsException ex) {
+                throw new ConcurrentModificationException();
+            }
+        }
+
+        /**
+         * Adding a new object to the RealmList. If the object is not already manage by Realm it will be transparently
+         * copied using {@link Realm#copyToRealmOrUpdate(RealmModel)}
+         *
+         * @see #add(RealmModel)
+         */
+        public void add(E e) {
+            realm.checkIfValid();
+            checkConcurrentModification();
+            try {
+                int i = cursor;
+                RealmList.this.add(i, e);
+                lastRet = -1;
+                cursor = i + 1;
+                expectedModCount = modCount;
+            } catch (IndexOutOfBoundsException ex) {
+                throw new ConcurrentModificationException();
+            }
+        }
+    }
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmModel.java b/realm/realm-library/src/main/java/io/realm/RealmModel.java
new file mode 100644
index 0000000000..8fbf94f3ac
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmModel.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.RealmClass;
+
+
+/**
+ * Interface for marking classes as RealmObjects, it can be used instead of extending {@link RealmObject}.
+ *
+ * All helper methods available to classes that extend RealmObject are instead available as static methods:
+ *
+ * <pre>
+ * {@code
+ *   Person p = realm.createObject(Person.class);
+ *
+ *   // With the RealmModel interface
+ *   RealmObject.isValid(p);
+ *
+ *   // With the RealmObject base class
+ *   p.isValid();
+ * }
+ * </pre>
+ *
+ * Note: Object implementing this interface needs also to be annotated with {@link RealmClass}, so the annotation
+ * processor can generate the underlining proxy class.
+ *
+ * @see RealmObject
+ */
+
+public interface RealmModel {
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 3d711f6d7f..141ad52292 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -17,15 +17,11 @@
 package io.realm;
 
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.Future;
 
 import io.realm.annotations.RealmClass;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.Table;
-import io.realm.internal.TableQuery;
-import io.realm.internal.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -64,20 +60,11 @@
  * A RealmObject cannot be passed between different threads.
  *
  * @see Realm#createObject(Class)
- * @see Realm#copyToRealm(RealmObject)
+ * @see Realm#copyToRealm(RealmModel)
  */
 
 @RealmClass
-public abstract class RealmObject {
-
-    protected Row row;
-    protected BaseRealm realm;
-
-    private final List<RealmChangeListener> listeners = new CopyOnWriteArrayList<RealmChangeListener>();
-    private Future<Long> pendingQuery;
-    private boolean isCompleted = false;
-    private long currentTableVersion = -1;
-
+public abstract class RealmObject implements RealmModel {
     /**
      * DEPRECATED: Use {@link #deleteFromRealm()} instead.
      *
@@ -89,7 +76,7 @@
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      */
     @Deprecated
-    public void removeFromRealm() {
+    public final void removeFromRealm() {
         deleteFromRealm();
     }
 
@@ -102,19 +89,40 @@ public void removeFromRealm() {
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      * @see #isValid()
      */
-    public void deleteFromRealm() {
-        if (row == null) {
+    public final void deleteFromRealm() {
+        deleteFromRealm(this);
+    }
+    
+    /**
+     * Deletes the object from the Realm it is currently associated with.
+     * <p>
+     * After this method is called the object will be invalid and any operation (read or write) performed on it will
+     * fail with an IllegalStateException.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * @see #isValid()
+     */
+    public static <E extends RealmModel> void deleteFromRealm(E object) {
+        if (!(object instanceof RealmObjectProxy)) {
+            // TODO What type of exception IllegalArgument/IllegalState?
+            throw new IllegalArgumentException("Object not managed by Realm, so it cannot be removed.");
+        }
+
+        RealmObjectProxy proxy = (RealmObjectProxy) object;
+        if (proxy.realmGet$proxyState().getRow$realm() == null) {
             throw new IllegalStateException("Object malformed: missing object in Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
         }
-        if (realm == null) {
+        if (proxy.realmGet$proxyState().getRealm$realm() == null) {
             throw new IllegalStateException("Object malformed: missing Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
         }
-        realm.checkIfValid();
 
+        proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
+        Row row = proxy.realmGet$proxyState().getRow$realm();
         row.getTable().moveLastOver(row.getIndex());
-        row = InvalidRow.INSTANCE;
+        proxy.realmGet$proxyState().setRow$realm(InvalidRow.INSTANCE);
     }
 
+
     /**
      * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
      * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
@@ -122,28 +130,24 @@ public void deleteFromRealm() {
      * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
      */
     public final boolean isValid() {
-        return row != null && row.isAttached();
-    }
-
-    protected Table getTable () {
-        return realm.schema.getTable(getClass());
+        return RealmObject.isValid(this);
     }
 
     /**
-     * Sets the Future instance returned by the worker thread, we need this instance to force {@link #load()} an async
-     * query, we use it to determine if the current RealmResults is a sync or async one.
+     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
      *
-     * @param pendingQuery pending query.
+     * @param object RealmObject to check validity for.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
      */
-    void setPendingQuery(Future<Long> pendingQuery) {
-        this.pendingQuery = pendingQuery;
-        if (isLoaded()) {
-            // the query completed before RealmQuery
-            // had a chance to call setPendingQuery to register the pendingQuery (used btw
-            // to determine isLoaded behaviour)
-            onCompleted();
-
-        } // else, it will be handled by the Realm#handler
+    public static <E extends RealmModel> boolean isValid(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            Row row = proxy.realmGet$proxyState().getRow$realm();
+            return row != null && row.isAttached();
+        } else {
+            return false;
+        }
     }
 
     /**
@@ -155,11 +159,26 @@ void setPendingQuery(Future<Long> pendingQuery) {
      * progress.
      */
     public final boolean isLoaded() {
-        if (realm == null) {
+        return RealmObject.isLoaded(this);
+    }
+
+    /**
+     * Determines if the RealmObject is obtained synchronously or asynchronously (from a worker thread).
+     * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
+     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     *
+     * @param object RealmObject to check.
+     * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
+     * progress.
+     */
+    public static <E extends RealmModel> boolean isLoaded(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
+            return proxy.realmGet$proxyState().getPendingQuery$realm() == null || proxy.realmGet$proxyState().isCompleted$realm();
+        } else {
             return true;
         }
-        realm.checkIfValid();
-        return pendingQuery == null || isCompleted;
     }
 
     /**
@@ -169,104 +188,123 @@ public final boolean isLoaded() {
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
     public final boolean load() {
-        //noinspection SimplifiableIfStatement
-        if (isLoaded()) {
-            return true;
-        } else {
-            // doesn't guarantee to import correctly the result (because the user may have advanced)
-            // in this case the Realm#handler will be responsible of retrying
-            return onCompleted();
-        }
+        return RealmObject.load(this);
     }
 
     /**
-     * Called to import the handover row pointer & notify listeners.
+     * Makes an asynchronous query blocking. This will also trigger any registered listeners.
+     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
      *
+     * @param object RealmObject to force load.
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
-    boolean onCompleted() {
-        try {
-            Long handoverResult = pendingQuery.get();// make the query blocking
-            if (handoverResult != 0) {
-                // this may fail with BadVersionException if the caller and/or the worker thread
-                // are not in sync (same shared_group version).
-                // COMPLETED_ASYNC_REALM_OBJECT will be fired by the worker thread
-                // this should handle more complex use cases like retry, ignore etc
-                onCompleted(handoverResult);
-                notifyChangeListeners();
+    public static <E extends RealmModel> boolean load(E object) {
+        if (RealmObject.isLoaded(object)) {
+            return true;
+        } else {
+            if (object instanceof RealmObjectProxy) {
+                // doesn't guarantee to import correctly the result (because the user may have advanced)
+                // in this case the Realm#handler will be responsible of retrying
+                return ((RealmObjectProxy) object).realmGet$proxyState().onCompleted$realm();
             } else {
-                isCompleted = true;
+                return false;
             }
-        } catch (Exception e) {
-            RealmLog.d(e.getMessage());
-            return false;
         }
-        return true;
     }
 
-    void onCompleted(Long handoverRowPointer) {
-        if (handoverRowPointer == 0) {
-            // we'll retry later to update the row pointer, but we consider
-            // the query done
-            isCompleted = true;
-
-        } else if (!isCompleted || row == Row.EMPTY_ROW) {
-            isCompleted = true;
-            long nativeRowPointer = TableQuery.nativeImportHandoverRowIntoSharedGroup(handoverRowPointer, realm.sharedGroupManager.getNativePointer());
-            Table table = getTable();
-            this.row = table.getUncheckedRowByPointer(nativeRowPointer);
-        }// else: already loaded query no need to import again the pointer
+    /**
+     * Adds a change listener to this RealmObject.
+     *
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     */
+    public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
+        RealmObject.addChangeListener((E) this, listener);
     }
 
     /**
-     * Adds a change listener to this RealmObject.
+     * Adds a change listener to a RealmObject.
      *
+     * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if object is an un-managed RealmObject.
      */
-    public final void addChangeListener(RealmChangeListener listener) {
+    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
-        if (realm != null) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
             realm.checkIfValid();
+            if (realm.handler == null) {
+                throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+            }
+            List<RealmChangeListener> listeners = proxy.realmGet$proxyState().getListeners$realm();
+            if (!listeners.contains(listener)) {
+                listeners.add(listener);
+            }
+            if (isLoaded(proxy)) {
+                // Try to add this object to the realmObjects if it has already been loaded.
+                // For newly created async objects, it will be handled in RealmQuery.findFirstAsync &
+                // HandlerController.completedAsyncRealmObject.
+                realm.handlerController.addToRealmObjects(proxy);
+            }
         } else {
             throw new IllegalArgumentException("Cannot add listener from this unmanaged RealmObject (created outside of Realm)");
         }
-        if (realm.handler == null) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
-        }
-        if (!listeners.contains(listener)) {
-            listeners.add(listener);
-        }
     }
 
+
     /**
      * Removes a previously registered listener.
      *
      * @param listener the instance to be removed.
      */
     public final void removeChangeListener(RealmChangeListener listener) {
+        RealmObject.removeChangeListener(this, listener);
+    }
+
+    /**
+     * Removes a previously registered listener on the given RealmObject.
+     *
+     * @param object RealmObject to remove listener from.
+     * @param listener the instance to be removed.
+     */
+    public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
-        if (realm != null) {
-            realm.checkIfValid();
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
+            proxy.realmGet$proxyState().getListeners$realm().remove(listener);
         } else {
             throw new IllegalArgumentException("Cannot remove listener from this unmanaged RealmObject (created outside of Realm)");
         }
-        listeners.remove(listener);
     }
 
     /**
      * Removes all registered listeners.
      */
     public final void removeChangeListeners() {
-        if (realm != null) {
-            realm.checkIfValid();
+        RealmObject.removeChangeListeners(this);
+    }
+
+    /**
+     * Removes all registered listeners from the given RealmObject.
+     *
+     * @param object RealmObject to remove all listeners from.
+     * @throws IllegalArgumentException if object is {@code null} or isn't managed by Realm.
+     */
+    public static <E extends RealmModel> void removeChangeListeners(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
+            proxy.realmGet$proxyState().getListeners$realm().clear();
         } else {
-            throw new IllegalArgumentException("Cannot remove listeners from this unmanaged RealmObject (created outside of Realm)");
+            throw new IllegalArgumentException("Cannot remove listeners from this un-managed RealmObject (created outside of Realm)");
         }
-        listeners.clear();
     }
 
     /**
@@ -295,57 +333,54 @@ public final void removeChangeListeners() {
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public <E extends RealmObject> Observable<E> asObservable() {
-        if (realm instanceof Realm) {
-            @SuppressWarnings("unchecked")
-            E obj = (E) this;
-            return realm.configuration.getRxFactory().from((Realm) realm, obj);
-        } else if (realm instanceof DynamicRealm) {
-            DynamicRealm dynamicRealm = (DynamicRealm) realm;
-            DynamicRealmObject dynamicObject = (DynamicRealmObject) this;
-            @SuppressWarnings("unchecked")
-            Observable<E> observable = (Observable<E>) realm.configuration.getRxFactory().from(dynamicRealm,
-                    dynamicObject);
-            return observable;
-        } else {
-            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
-                    " See https://realm.io/docs/java/latest/#rxjava for more details.");
-        }
+    public final <E extends RealmObject> Observable<E> asObservable() {
+        return (Observable<E>) RealmObject.asObservable(this);
     }
 
     /**
-     * Notifies all registered listeners.
+     * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
+     * subscribed to. Object updates will continuously be emitted as the RealmObject is updated -
+     * {@code onComplete} will never be called.
+     *
+     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * type information, otherwise the type of the following observables will be {@code RealmObject}.
+     *
+     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * emit only the first item by using the {@code first()} operator:
+     *
+     * <pre>
+     * {@code
+     * obj.asObservable()
+     *      .filter(obj -> obj.isLoaded())
+     *      .first()
+     *      .subscribe( ... ) // You only get the object once
+     * }
+     * </pre>
+     *
+     * @param object RealmObject class that is being observed. Must be this class or its super types.
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    void notifyChangeListeners() {
-        if (!listeners.isEmpty()) {
-            boolean notify = false;
-
-            Table table = row.getTable();
-            if (table == null) {
-                // Completed async queries might result in `table == null`, `isCompleted == true` and `row == Row.EMPTY_ROW`
-                // We still want to trigger change notifications for these cases.
-                // isLoaded / isValid should be considered properties on RealmObjects as well so any change to these
-                // should trigger a RealmChangeListener.
-                notify = true;
+    public static <E extends RealmModel> Observable<E> asObservable(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
+            if (realm instanceof Realm) {
+                return realm.configuration.getRxFactory().from((Realm) realm, object);
+            } else if (realm instanceof DynamicRealm) {
+                DynamicRealm dynamicRealm = (DynamicRealm) realm;
+                DynamicRealmObject dynamicObject = (DynamicRealmObject) object;
+                @SuppressWarnings("unchecked")
+                Observable<E> observable = (Observable<E>) realm.configuration.getRxFactory().from(dynamicRealm, dynamicObject);
+                return observable;
             } else {
-                long version = table.version();
-                if (currentTableVersion != version) {
-                    currentTableVersion = version;
-                    notify = true;
-                }
+                throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
+                        " See https://realm.io/docs/java/latest/#rxjava for more details.");
             }
-
-            if (notify) {
-                for (RealmChangeListener listener : listeners) {
-                    listener.onChange();
-                }
-            }
-        }
-    }
-
-    void setTableVersion() {
-        if (row.getTable() != null) {
-            currentTableVersion = row.getTable().version();
+        } else {
+            // TODO Is this true? Should we just return Observable.just(object) ?
+            throw new IllegalArgumentException("Cannot create Observables from un-managed RealmObjects");
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index fad1bd5483..7a3d006452 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -16,6 +16,11 @@
 
 package io.realm;
 
+import io.realm.annotations.Required;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
@@ -24,11 +29,6 @@
 import java.util.Map;
 import java.util.Set;
 
-import io.realm.annotations.Required;
-import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-
 /**
  * Class for interacting with the schema for a given RealmObject class. This makes it possible to
  * add, delete or change the fields for given class.
@@ -141,12 +141,11 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
 
         checkNewFieldName(fieldName);
         boolean nullable = metadata.defaultNullable;
-        if (containsAttribute(attributes, FieldAttribute.REQUIRED) ||
-                containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
             nullable = false;
         }
-        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
 
+        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
         try {
             addModifiers(fieldName, attributes);
         } catch (Exception e) {
@@ -222,6 +221,9 @@ public RealmObjectSchema renameField(String currentFieldName, String newFieldNam
         checkFieldNameIsAvailable(newFieldName);
         long columnIndex = getColumnIndex(currentFieldName);
         table.renameColumn(columnIndex, newFieldName);
+
+        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
+
         return this;
     }
 
@@ -422,6 +424,19 @@ public boolean hasPrimaryKey() {
         return table.hasPrimaryKey();
     }
 
+    /**
+     * Returns the name of the primary key field.
+     *
+     * @return the name of the primary key field.
+     * @throws IllegalStateException if the class doesn't have a primary key defined.
+     */
+    public String getPrimaryKey() {
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        return table.getColumnName(table.getPrimaryKey());
+    }
+
     /**
      * Returns all fields in this class.
      *
@@ -660,7 +675,7 @@ public FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
         }
     }
 
-    static class DynamicColumnMap implements Map<String, Long> {
+    static final class DynamicColumnMap implements Map<String, Long> {
         private final Table table;
 
         public DynamicColumnMap(Table table) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index eb539b1cc9..a955dfdc42 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -29,6 +29,7 @@
 
 import io.realm.annotations.Required;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedGroup;
 import io.realm.internal.Table;
@@ -58,7 +59,7 @@
  * @see Realm#where(Class)
  * @see RealmResults#where()
  */
-public class RealmQuery<E extends RealmObject> {
+public final class RealmQuery<E extends RealmModel> {
 
     private BaseRealm realm;
     private Class<E> clazz;
@@ -80,7 +81,7 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-    public static <E extends RealmObject> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
+    public static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
         return new RealmQuery<E>(realm, clazz);
     }
 
@@ -92,7 +93,7 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-    public static <E extends RealmObject> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
+    public static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
         return new RealmQuery<E>(realm, className);
     }
 
@@ -105,7 +106,7 @@
      */
 
     @SuppressWarnings("unchecked")
-    public static <E extends RealmObject> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
+    public static <E extends RealmModel> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
         if (queryResults.classSpec != null) {
             return new RealmQuery<E>(queryResults, queryResults.classSpec);
         } else {
@@ -121,7 +122,7 @@
      * to run it.
      */
     @SuppressWarnings("unchecked")
-    public static <E extends RealmObject> RealmQuery<E> createQueryFromList(RealmList<E> list) {
+    public static <E extends RealmModel> RealmQuery<E> createQueryFromList(RealmList<E> list) {
         if (list.clazz != null) {
             return new RealmQuery(list.realm, list.view, list.clazz);
         } else {
@@ -1159,9 +1160,9 @@ public boolean isValid() {
             realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
         }
 
-        final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
+        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1466,9 +1467,9 @@ public long count() {
             realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
         }
 
-        final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
+        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1583,10 +1584,10 @@ public Long call() throws Exception {
             realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
         }
 
-        final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults =
+        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults =
                 realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1757,9 +1758,9 @@ private boolean isDynamicQuery() {
                 realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
             }
 
-            final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
+            final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-            final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+            final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
                 @Override
                 public Long call() throws Exception {
                     if (!Thread.currentThread().isInterrupted()) {
@@ -1843,22 +1844,9 @@ public Long call() throws Exception {
     }
 
     /**
-     * Finds all objects that fulfill the query conditions and sorted by specific field names in
-     * ascending order.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName1 first field name
-     * @param sortOrder1 sort order for first field
-     * @param fieldName2 second field name
-     * @param sortOrder2 sort order for second field
-     * @param fieldName3 third field names
-     * @param sortOrder3 sort order for third field
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
-     * objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@link #findAllSorted(String[], Sort[])}  instead.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
                                    String fieldName2, Sort sortOrder2,
                                    String fieldName3, Sort sortOrder3) {
@@ -1867,14 +1855,9 @@ public Long call() throws Exception {
     }
 
     /**
-     * Similar to {@link #findAllSorted(String, Sort, String, Sort, String, Sort)} but
-     * runs asynchronously on a worker thread.
-     * This method is only available from a Looper thread.
-     *
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * DEPRECATED: Use {@link #findAllSortedAsync(String[], Sort[])}  instead.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
                                               String fieldName2, Sort sortOrder2,
                                               String fieldName3, Sort sortOrder3) {
@@ -1893,11 +1876,6 @@ public E findFirst() {
         long sourceRowIndex = getSourceRowIndexForFirstObject();
         if (sourceRowIndex >= 0) {
             E realmObject = realm.get(clazz, className, sourceRowIndex);
-            if (realm.handlerController != null) { // non Looper Thread doesn't have a handlerController
-                WeakReference<RealmObject> realmObjectWeakReference
-                        = new WeakReference<RealmObject>(realmObject, realm.handlerController.referenceQueueRealmObject);
-                realm.handlerController.realmObjects.put(realmObjectWeakReference, this);
-            }
             return realmObject;
         } else {
             return null;
@@ -1937,11 +1915,12 @@ public E findFirstAsync() {
             result = realm.getConfiguration().getSchemaMediator().newInstance(clazz, realm.getSchema().getColumnInfo(clazz));
         }
 
-        final WeakReference<RealmObject> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(result, this);
-        result.realm = realm;
-        result.row = Row.EMPTY_ROW;
+        RealmObjectProxy proxy = (RealmObjectProxy) result;
+        final WeakReference<RealmObjectProxy> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(proxy, this);
+        proxy.realmGet$proxyState().setRealm$realm(realm);
+        proxy.realmGet$proxyState().setRow$realm(Row.EMPTY_ROW);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1986,7 +1965,7 @@ public Long call() throws Exception {
                 return INVALID_NATIVE_POINTER;
             }
         });
-        result.setPendingQuery(pendingQuery);
+        proxy.realmGet$proxyState().setPendingQuery$realm(pendingQuery);
 
         return result;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index b2c3543d50..abeb92a9c0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -29,8 +29,8 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
-import io.realm.exceptions.RealmException;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.TableQuery;
@@ -67,7 +67,7 @@
  * @see Realm#allObjects(Class)
  * @see io.realm.Realm#beginTransaction()
  */
-public final class RealmResults<E extends RealmObject> extends AbstractList<E> implements OrderedRealmCollection<E> {
+public final class RealmResults<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
     private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by RealmResults.";
 
@@ -78,23 +78,24 @@
 
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final long TABLE_VIEW_VERSION_NONE = -1;
-    private long currentTableViewVersion = TABLE_VIEW_VERSION_NONE;
 
+    private long currentTableViewVersion = TABLE_VIEW_VERSION_NONE;
     private final TableQuery query;
-    private final List<RealmChangeListener> listeners = new CopyOnWriteArrayList<RealmChangeListener>();
+    private final List<RealmChangeListener<RealmResults<E>>> listeners = new CopyOnWriteArrayList<RealmChangeListener<RealmResults<E>>>();
     private Future<Long> pendingQuery;
-    private boolean isCompleted = false;
+    private boolean asyncQueryCompleted = false;
+    // Keep track of changes to the RealmResult. Is updated after a call to `syncIfNeeded()`. Calling notifyListeners will
+    // clear it.
+    private boolean viewUpdated = false;
 
 
-    static <E extends RealmObject> RealmResults<E> createFromTableQuery(BaseRealm realm, TableQuery query, Class<E> clazz) {
+    static <E extends RealmModel> RealmResults<E> createFromTableQuery(BaseRealm realm, TableQuery query, Class<E> clazz) {
         return new RealmResults<E>(realm, query, clazz);
     }
 
-    static <E extends RealmObject> RealmResults<E> createFromTableOrView(BaseRealm realm, TableOrView table, Class<E> clazz) {
+    static <E extends RealmModel> RealmResults<E> createFromTableOrView(BaseRealm realm, TableOrView table, Class<E> clazz) {
         RealmResults<E> realmResults = new RealmResults<E>(realm, table, clazz);
-        if (realm.handlerController != null) {
-            realm.handlerController.addToRealmResults(realmResults);
-        }
+        realm.handlerController.addToRealmResults(realmResults);
         return realmResults;
     }
 
@@ -104,9 +105,7 @@
 
     static RealmResults<DynamicRealmObject> createFromDynamicTableOrView(BaseRealm realm, TableOrView table, String className) {
         RealmResults<DynamicRealmObject> realmResults = new RealmResults<DynamicRealmObject>(realm, table, className);
-        if (realm.handlerController != null) {
-            realm.handlerController.addToRealmResults(realmResults);
-        }
+        realm.handlerController.addToRealmResults(realmResults);
         return realmResults;
     }
 
@@ -129,7 +128,7 @@ private RealmResults(BaseRealm realm, TableOrView table, Class<E> classSpec) {
 
         this.pendingQuery = null;
         this.query = null;
-        this.currentTableViewVersion = table.sync();
+        this.currentTableViewVersion = table.syncIfNeeded();
     }
 
     private RealmResults(BaseRealm realm, String className) {
@@ -143,6 +142,7 @@ private RealmResults(BaseRealm realm, String className) {
     private RealmResults(BaseRealm realm, TableOrView table, String className) {
         this(realm, className);
         this.table = table;
+        this.currentTableViewVersion = table.syncIfNeeded();
     }
 
     TableOrView getTable() {
@@ -180,10 +180,10 @@ public boolean isValid() {
     @Override
     public boolean contains(Object object) {
         boolean contains = false;
-        if (isLoaded() && object instanceof RealmObject) {
-            RealmObject realmObject = (RealmObject) object;
-            if (realmObject.row != null && realm.getPath().equals(realmObject.realm.getPath()) && realmObject.row != InvalidRow.INSTANCE) {
-                contains = (table.sourceRowIndex(realmObject.row.getIndex()) != TableOrView.NO_MATCH);
+        if (isLoaded() && object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            if (realm.getPath().equals(proxy.realmGet$proxyState().getRealm$realm().getPath()) && proxy.realmGet$proxyState().getRow$realm() != InvalidRow.INSTANCE) {
+                contains = (table.sourceRowIndex(proxy.realmGet$proxyState().getRow$realm().getIndex()) != TableOrView.NO_MATCH);
             }
         }
         return contains;
@@ -562,7 +562,7 @@ public double average(String fieldName) {
     /**
      * Not supported by RealmResults.
      *
-     * @throws UnsupportedOperationException always.
+     * @throws UnsupportedOperationException
      */
     @Deprecated
     @Override
@@ -573,7 +573,7 @@ public E remove(int index) {
     /**
      * Not supported by RealmResults.
      *
-     * @throws UnsupportedOperationException always.
+     * @throws UnsupportedOperationException
      */
     @Deprecated
     @Override
@@ -584,7 +584,7 @@ public boolean remove(Object object) {
     /**
      * Not supported by RealmResults.
      *
-     * @throws UnsupportedOperationException always.
+     * @throws UnsupportedOperationException
      */
     @Deprecated
     @Override
@@ -595,7 +595,7 @@ public boolean removeAll(Collection<?> collection) {
     /**
      * Not supported by RealmResults.
      *
-     * @throws UnsupportedOperationException always.
+     * @throws UnsupportedOperationException
      */
     @Deprecated
     @Override
@@ -608,7 +608,7 @@ public E set(int location, E object) {
     /**
      * Not supported by RealmResults.
      *
-     * @throws UnsupportedOperationException always.
+     * @throws UnsupportedOperationException
      */
     @Deprecated
     @Override
@@ -645,6 +645,12 @@ public boolean deleteLastFromRealm() {
         }
     }
 
+    void syncIfNeeded() {
+        long newVersion = table.syncIfNeeded();
+        viewUpdated = newVersion != currentTableViewVersion;
+        currentTableViewVersion = newVersion;
+    }
+
     /**
      * Removes the first object in the list. This also deletes the object from the underlying Realm.
      *
@@ -652,7 +658,6 @@ public boolean deleteLastFromRealm() {
      */
     @Override
     public boolean deleteFirstFromRealm() {
-        realm.checkIfValid();
         if (size() > 0) {
             TableOrView table = getTable();
             table.removeFirst();
@@ -723,54 +728,54 @@ public boolean addAll(Collection<? extends E> collection) {
         int pos = -1;
 
         RealmResultsIterator() {
-            tableViewVersion = table.sync();
+            tableViewVersion = currentTableViewVersion;
         }
 
+        /**
+         * {@inheritDoc}
+         */
         public boolean hasNext() {
-            assertRealmIsStable();
             return pos + 1 < size();
         }
 
+        /**
+         * {@inheritDoc}
+         */
         public E next() {
-            assertRealmIsStable();
+            realm.checkIfValid();
+            checkRealmIsStable();
             pos++;
             if (pos >= size()) {
-                throw new IndexOutOfBoundsException("Cannot access index " + pos + " when size is " + size() +  ". Remember to check hasNext() before using next().");
+                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + size() +  ". Remember to check hasNext() before using next().");
             }
             return get(pos);
         }
 
         /**
-         * Not supported by RealmResults.
+         * Not supported by RealmResults iterators.
          *
-         * @throws UnsupportedOperationException always.
+         * @throws UnsupportedOperationException
          */
+        @Deprecated
         public void remove() {
-            throw new RealmException("Removing is not supported.");
-    /*        assertRealmIsStable();
-            if (pos == -1) {
-                throw new IllegalStateException("Must call next() before calling remove()");
-            }
-            if (removeUsed) {
-                throw new IllegalStateException("Cannot call remove() twice. Must call next() in between");
-            }
-
-            RealmResults.this.remove(pos);
-            pos--;
-            removeUsed = true;
-            currentTableViewVersion = getTable().sync();
-     */   }
+            throw new UnsupportedOperationException("remove() is not supported by RealmResults iterators.");
+        }
 
-        protected void assertRealmIsStable() {
-            long version = table.sync();
-            if (tableViewVersion > -1 && version != tableViewVersion) {
-                throw new ConcurrentModificationException("No outside changes to a Realm is allowed while iterating a RealmResults. Use iterators methods instead.");
+        protected void checkRealmIsStable() {
+            long version = table.getVersion();
+            // Any change within a write transaction will immediately update the table version. This means that we
+            // cannot depend on the tableVersion heuristic in that case.
+            // You could argue that in that case it is not really a "ConcurrentModification", but this interpretation
+            // is still more lax than what the standard Java Collection API gives.
+            // TODO: Try to come up with a better scheme
+            if (!realm.isInTransaction() && tableViewVersion > -1 && version != tableViewVersion) {
+                throw new ConcurrentModificationException("No outside changes to a Realm is allowed while iterating a RealmResults. Don't call Realm.refresh() while iterating.");
             }
             tableViewVersion = version;
         }
     }
 
-    // Custom RealmResults list iterator. It ensures that we only iterate on a Realm that hasn't changed.
+    // Custom RealmResults list iterator.
     private class RealmResultsListIterator extends RealmResultsIterator implements ListIterator<E> {
 
         RealmResultsListIterator(int start) {
@@ -781,26 +786,40 @@ protected void assertRealmIsStable() {
             }
         }
 
+        /**
+         * Unsupported by RealmResults iterators.
+         *
+         * @throws UnsupportedOperationException
+         */
         @Override
+        @Deprecated
         public void add(E object) {
-            throw new RealmException("Adding elements not supported. Use Realm.createObject() instead.");
+            throw new UnsupportedOperationException("Adding an element is not supported. Use Realm.createObject() instead.");
         }
 
+        /**
+         * {@inheritDoc}
+         */
         @Override
         public boolean hasPrevious() {
-            assertRealmIsStable();
             return pos >= 0;
         }
 
+        /**
+         * {@inheritDoc}
+         */
         @Override
         public int nextIndex() {
-            assertRealmIsStable();
             return pos + 1;
         }
 
+        /**
+         * {@inheritDoc}
+         */
         @Override
         public E previous() {
-            assertRealmIsStable();
+            realm.checkIfValid();
+            checkRealmIsStable();
             try {
                 E obj = get(pos);
                 pos--;
@@ -810,25 +829,24 @@ public E previous() {
             }
         }
 
+        /**
+         * {@inheritDoc}
+         */
         @Override
         public int previousIndex() {
-            assertRealmIsStable();
             return pos;
         }
 
-        @Override
-        public void set(E object) {
-            throw new RealmException("Replacing elements not supported.");
-        }
-
         /**
-         * Removes the RealmObject at the current position from both the list and the underlying Realm.
+         * Unsupported by RealmResults iterators.
          *
-         * WARNING: This method is currently disabled and will always throw an
-         * {@link io.realm.exceptions.RealmException}
+         * @throws UnsupportedOperationException
          */
         @Override
-        public void remove() { throw new RealmException("Removing elements not supported."); }
+        @Deprecated
+        public void set(E object) {
+            throw new UnsupportedOperationException("Replacing and element is not supported.");
+        }
     }
 
     /**
@@ -841,7 +859,7 @@ public void set(E object) {
     void swapTableViewPointer(long handoverTableViewPointer) {
         try {
             table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedGroupManager.getNativePointer());
-            isCompleted = true;
+            asyncQueryCompleted = true;
         } catch (BadVersionException e) {
             throw new IllegalStateException("Caller and Worker Realm should have been at the same version");
         }
@@ -857,9 +875,9 @@ void setPendingQuery(Future<Long> pendingQuery) {
         this.pendingQuery = pendingQuery;
         if (isLoaded()) {
             // the query completed before RealmQuery
-            // had a chance to call setPendingQuery to register the pendingQuery (used btw
+            // had a chance to call setPendingQuery to register the pendingQuery (used
             // to determine isLoaded behaviour)
-            onCompleted();
+            onAsyncQueryCompleted();
         } // else, it will be handled by the {@link BaseRealm#handlerController#handleMessage}
     }
 
@@ -874,24 +892,24 @@ void setPendingQuery(Future<Long> pendingQuery) {
      */
     public boolean isLoaded() {
         realm.checkIfValid();
-        return pendingQuery == null || isCompleted;
+        return pendingQuery == null || asyncQueryCompleted;
     }
 
     /**
-     * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * This will return {@code true} for standalone object (created outside of Realm). {@link RealmChangeListener} when
+     * Makes an asynchronous query blocking. This will also trigger any registered {@link RealmChangeListener} when
      * the query completes.
      *
-     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise. {@code true} will always
+     *         be returned for standalone objects.
      */
     public boolean load() {
         //noinspection SimplifiableIfStatement
         if (isLoaded()) {
             return true;
         } else {
-            // doesn't guarantee to import correctly the result (because the user may have advanced)
+            // doesn't guarantee to correctly import the result (because the user may have advanced)
             // in this case the Realm#handler will be responsible of retrying
-            return onCompleted();
+            return onAsyncQueryCompleted();
         }
     }
 
@@ -901,15 +919,15 @@ public boolean load() {
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
-    private boolean onCompleted() {
+    private boolean onAsyncQueryCompleted() {
         try {
             long tvHandover = pendingQuery.get();// make the query blocking
             // this may fail with BadVersionException if the caller and/or the worker thread
             // are not in sync. COMPLETED_ASYNC_REALM_RESULTS will be fired by the worker thread
             // this should handle more complex use cases like retry, ignore etc
             table = query.importHandoverTableView(tvHandover, realm.sharedGroupManager.getNativePointer());
-            isCompleted = true;
-            notifyChangeListeners();
+            asyncQueryCompleted = true;
+            notifyChangeListeners(false, true);
         } catch (Exception e) {
             RealmLog.d(e.getMessage());
             return false;
@@ -922,7 +940,7 @@ private boolean onCompleted() {
      *
      * @param listener the change listener to be notified.
      */
-    public void addChangeListener(RealmChangeListener listener) {
+    public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -997,16 +1015,21 @@ public void removeChangeListeners() {
      * Notifies all registered listeners.
      */
     void notifyChangeListeners() {
+        notifyChangeListeners(true, false);
+    }
+
+    private void notifyChangeListeners(boolean syncBeforeNotifying, boolean forceNotify) {
+        if (syncBeforeNotifying) {
+            syncIfNeeded();
+        }
         if (!listeners.isEmpty()) {
             // table might be null (if the async query didn't complete
             // but we have already registered listeners for it)
-            if (pendingQuery != null && !isCompleted) return;
-            long version = table.sync();
-            if (currentTableViewVersion != version) {
-                currentTableViewVersion = version;
-                for (RealmChangeListener listener : listeners) {
-                    listener.onChange();
-                }
+            if (pendingQuery != null && !asyncQueryCompleted) return;
+            if (!viewUpdated && !forceNotify) return;
+            viewUpdated = false;
+            for (RealmChangeListener listener : listeners) {
+                listener.onChange(this);
             }
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 2957d646ce..aca535075f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -43,9 +43,9 @@
     // Caches Dynamic Class objects given as Strings (both model classes and proxy classes) to Realm Tables
     private final Map<String, Table> dynamicClassToTable = new HashMap<String, Table>();
     // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmObject>, Table> classToTable = new HashMap<Class<? extends RealmObject>, Table>();
+    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<Class<? extends RealmModel>, Table>();
     // Caches Class objects (both model classes and proxy classes) to their Schema object
-    private final Map<Class<? extends RealmObject>, RealmObjectSchema> classToSchema = new HashMap<Class<? extends RealmObject>, RealmObjectSchema>();
+    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<Class<? extends RealmModel>, RealmObjectSchema>();
     // Caches Class Strings (both model classes and proxy classes) to their Schema object
     private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
 
@@ -130,6 +130,10 @@ public void remove(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
         String internalTableName = TABLE_PREFIX + className;
         checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
+        Table table = getTable(className);
+        if (table.hasPrimaryKey()) {
+            table.setPrimaryKey(null);
+        }
         transaction.removeTable(internalTableName);
     }
 
@@ -149,8 +153,23 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
         if (transaction.hasTable(newInternalName)) {
             throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
         }
+
+        // Check if there is a primary key defined for the old class.
+        Table oldTable = getTable(oldClassName);
+        String pkField = null;
+        if (oldTable.hasPrimaryKey()) {
+            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
+            oldTable.setPrimaryKey(null);
+        }
+
         transaction.renameTable(oldInternalName, newInternalName);
         Table table = transaction.getTable(newInternalName);
+
+        // Set the primary key for the new class if necessary
+        if (pkField != null) {
+            table.setPrimaryKey(pkField);
+        }
+
         RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
         return new RealmObjectSchema(realm, table, columnIndices);
     }
@@ -178,7 +197,7 @@ private void checkHasTable(String className, String errorMsg) {
         }
     }
 
-    ColumnInfo getColumnInfo(Class<? extends RealmObject> clazz) {
+    ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
         final ColumnInfo columnInfo = columnIndices.getColumnInfo(clazz);
         if (columnInfo == null) {
             throw new IllegalStateException("No validated schema information found for " + realm.configuration.getSchemaMediator().getTableName(clazz));
@@ -199,7 +218,7 @@ Table getTable(String className) {
         return table;
     }
 
-    Table getTable(Class<? extends RealmObject> clazz) {
+    Table getTable(Class<? extends RealmModel> clazz) {
         Table table = classToTable.get(clazz);
         if (table == null) {
             clazz = Util.getOriginalModelClass(clazz);
@@ -209,7 +228,7 @@ Table getTable(Class<? extends RealmObject> clazz) {
         return table;
     }
 
-    RealmObjectSchema getSchemaForClass(Class<? extends RealmObject> clazz) {
+    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         RealmObjectSchema classSchema = classToSchema.get(clazz);
         if (classSchema == null) {
             clazz = Util.getOriginalModelClass(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
index f726575adf..e75cbbad5c 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
@@ -23,7 +23,7 @@
  * RealmError should never be caught or ignored. By doing so, the Realm could possibly get corrupted.
  */
 @Keep
-public class RealmError extends Error {
+public final class RealmError extends Error {
     public RealmError(String detailMessage) {
         super(detailMessage);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
index 354e2ce5f0..5cd20f9bff 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
@@ -22,7 +22,7 @@
  * RealmException is Realm specific exceptions.
  */
 @Keep
-public class RealmException extends RuntimeException {
+public final class RealmException extends RuntimeException {
 
     public RealmException(String detailMessage) {
         super(detailMessage);
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
index 3d59ed049e..845093fbc7 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
@@ -22,7 +22,7 @@
  * Class for reporting problems with Realm files.
  */
 @Keep
-public class RealmIOException extends RuntimeException {
+public final class RealmIOException extends RuntimeException {
 
     public RealmIOException(Throwable cause) {
         super(cause);
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
index d1093d6313..cfb7e50fb0 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
@@ -21,7 +21,7 @@
 import io.realm.internal.Keep;
 
 @Keep
-public class RealmMigrationNeededException extends RuntimeException {
+public final class RealmMigrationNeededException extends RuntimeException {
 
     private final String canonicalRealmPath;
 
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
index e24a380ba2..151bf264be 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
@@ -24,7 +24,7 @@
  * @see io.realm.annotations.PrimaryKey
  */
 @Keep
-public class RealmPrimaryKeyConstraintException extends RuntimeException {
+public final class RealmPrimaryKeyConstraintException extends RuntimeException {
     public RealmPrimaryKeyConstraintException(String message) {
         super(message);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 570ec29a54..ae052e69fb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -96,19 +96,18 @@ public boolean isNull(long columnIndex) {
         return super.isNull(columnIndex);
     }
 
+    /**
+     * Set null to a row pointer with checking if a column is nullable, except when the column type
+     * is binary.
+     *
+     * @param columnIndex 0 based index value of the cell column.
+     */
     @Override
     public void setNull(long columnIndex) {
         RealmFieldType columnType = getColumnType(columnIndex);
-        if (columnType == RealmFieldType.STRING) {
-            super.setString(columnIndex, null);
-        }
-        else if (columnType == RealmFieldType.BINARY) {
+        if (columnType == RealmFieldType.BINARY) {
             super.setBinaryByteArray(columnIndex, null);
-        }
-        else {
-            if (!this.getTable().isColumnNullable(columnIndex)) {
-                throw new IllegalArgumentException("field is not nullable");
-            }
+        } else {
             super.setNull(columnIndex);
         }
     }
@@ -121,7 +120,7 @@ else if (columnType == RealmFieldType.BINARY) {
     protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
     protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
     protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetTimestamp(long nativeRowPtr, long columnIndex);
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
@@ -133,7 +132,7 @@ else if (columnType == RealmFieldType.BINARY) {
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
     protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
     protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
-    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
     protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index f05a702b9b..97e2934c3c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -18,30 +18,30 @@
 
 import java.util.Map;
 
-import io.realm.RealmObject;
+import io.realm.RealmModel;
 
 /**
  * Utility class used to cache the mapping between object field names and their column indices.
  */
 public class ColumnIndices {
 
-    private final Map<Class<? extends RealmObject>, ColumnInfo> classes;
+    private final Map<Class<? extends RealmModel>, ColumnInfo> classes;
 
-    public ColumnIndices(Map<Class<? extends RealmObject>, ColumnInfo> classes) {
+    public ColumnIndices(Map<Class<? extends RealmModel>, ColumnInfo> classes) {
         this.classes = classes;
     }
 
     /**
      * Returns {@link ColumnInfo} for the given class or {@code null} if no mapping exists.
      */
-    public ColumnInfo getColumnInfo(Class<? extends RealmObject> clazz) {
+    public ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
         return classes.get(clazz);
     }
 
     /**
      * Returns the column index for a given field on a clazz or {@code -1} if no such field exists.
      */
-    public long getColumnIndex(Class<? extends RealmObject> clazz, String fieldName) {
+    public long getColumnIndex(Class<? extends RealmModel> clazz, String fieldName) {
         final ColumnInfo columnInfo = classes.get(clazz);
         if (columnInfo != null) {
             Long index = columnInfo.getIndicesMap().get(fieldName);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java b/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
index 3de17bb722..69a4b2d71e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
@@ -16,19 +16,20 @@
 
 package io.realm.internal;
 
-import io.realm.RealmObject;
+import io.realm.ProxyState;
+import io.realm.RealmModel;
 
 /**
- * Empty interface making it easy to determine if an object is the generated RealmProxy class or the original class.
+ * Interface making it easy to determine if an object is the generated RealmProxy class or the original class.
  *
  * Ideally all the static methods was also present here, but that is not supported before Java 8.
  */
-public interface RealmObjectProxy {
-
+ public interface RealmObjectProxy extends RealmModel {
+    ProxyState realmGet$proxyState();
     /**
      * Tuple class for saving meta data about a cached RealmObject.
      */
-    class CacheData<E extends RealmObject> {
+    class CacheData<E extends RealmModel> {
         public int minDepth;
         public final E object;
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 4681c8b21d..e2700ee8cd 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -26,6 +26,7 @@
 import java.util.Set;
 
 import io.realm.Realm;
+import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
 
@@ -46,7 +47,7 @@
      * @param clazz the {@link RealmObject} model class to create backing table for.
      * @param transaction the read transaction for the Realm to create table in.
      */
-    public abstract Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
+    public abstract Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction);
 
     /**
      * Validates the backing table in Realm for the given RealmObject class.
@@ -55,7 +56,7 @@
      * @param transaction the read transaction for the Realm to validate against.
      * @return the field indices map.
      */
-    public abstract ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
+    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction);
 
     /**
      * Returns a map of non-obfuscated object field names to their internal Realm name.
@@ -63,7 +64,7 @@
      * @param clazz the {@link RealmObject} class reference.
      * @return The simple name of an RealmObject class (before it has been obfuscated).
      */
-    public abstract List<String> getFieldNames(Class<? extends RealmObject> clazz);
+    public abstract List<String> getFieldNames(Class<? extends RealmModel> clazz);
 
     /**
      * Returns the name that Realm should use for all it's internal tables. This is the un-obfuscated name of the
@@ -73,7 +74,7 @@
      * @return the simple name of an RealmObject class (before it has been obfuscated).
      * @throws java.lang.NullPointerException if null is given as argument.
      */
-    public abstract String getTableName(Class<? extends RealmObject> clazz);
+    public abstract String getTableName(Class<? extends RealmModel> clazz);
 
     /**
      * Creates a new instance of an {@link RealmObjectProxy} for the given RealmObject class.
@@ -82,14 +83,14 @@
      * @param columnInfo the {@link ColumnInfo} object for the RealmObject class of {@code E}.
      * @return created {@link RealmObjectProxy} object.
      */
-    public abstract <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo);
+    public abstract <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo);
 
     /**
      * Returns the list of RealmObject classes that can be saved in this Realm.
      *
      * @return list of class references to RealmObject classes. Empty list if no RealmObjects are supported.
      */
-    public abstract Set<Class<? extends RealmObject>> getModelClasses();
+    public abstract Set<Class<? extends RealmModel>> getModelClasses();
 
     /**
      * Copies a non-managed {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
@@ -101,7 +102,7 @@
      * @param cache the cache for mapping between standalone objects and their {@link RealmObjectProxy} representation.
      * @return the managed Realm object.
      */
-    public abstract <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache);
+    public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
 
     /**
      * Creates or updates a {@link RealmObject} using the provided JSON data.
@@ -114,7 +115,7 @@
      * @return RealmObject that has been created or updated.
      * @throws JSONException if the JSON mapping doesn't match the expected class.
      */
-    public abstract <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException;
+    public abstract <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException;
 
     /**
      * Creates new {@link RealmObject} based on a JSON input stream.
@@ -125,7 +126,7 @@
      * @return the created {@link RealmObject}
      * @throws IOException if an error occurs with the input stream.
      */
-    public abstract <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
+    public abstract <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
 
     /**
      * Creates a deep standalone copy of a RealmObject. This is a deep copy so all links will be copied as well.
@@ -136,7 +137,7 @@
      * @param cache cache used to make sure standalone objects are reused correctly.
      * @return a standalone copy of the given object.
      */
-    public abstract <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache);
+    public abstract <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache);
 
     /**
      * Returns whether Realm transformer has been applied or not. Subclasses of this class are
@@ -163,13 +164,13 @@ public int hashCode() {
         return getModelClasses().hashCode();
     }
 
-    protected static void checkClass(Class<? extends RealmObject> clazz) {
+    protected static void checkClass(Class<? extends RealmModel> clazz) {
         if (clazz == null) {
             throw new NullPointerException("A class extending RealmObject must be provided");
         }
     }
 
-    protected static RealmException getMissingProxyClassException(Class<? extends RealmObject> clazz) {
+    protected static RealmException getMissingProxyClassException(Class<? extends RealmModel> clazz) {
         return new RealmException(clazz + " is not part of the schema for this Realm.");
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
index 2f42292b51..9b640619ee 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
@@ -293,6 +293,22 @@ public int hashCode() {
         }
     }
 
+    /**
+     * Waits for change committed by {@link SharedGroup} in other Thread.
+     *
+     * @return {@code true} if successfully detects change, {@code false} no change has been detected otherwise.
+     */
+    public boolean waitForChange() {
+        return nativeWaitForChange(nativePtr);
+    }
+
+    /**
+     * Stops waiting for change.
+     */
+    public void stopWaitForChange() {
+        nativeStopWaitForChange(nativePtr);
+    }
+
     private native long createNativeWithImplicitTransactions(long nativeReplicationPtr,
                                                              int durability, byte[] key);
     private native long nativeCreateReplication(String databaseFile, byte[] key);
@@ -317,6 +333,8 @@ private native long nativeCreate(String databaseFile,
     private native void nativeCloseReplication(long nativeReplicationPtr);
     private native void nativeRollbackAndContinueAsRead(long nativePtr);
     private native long[] nativeGetVersionID (long nativePtr);
+    private native boolean nativeWaitForChange(long nativePtr);
+    private native void nativeStopWaitForChange(long nativePtr);
     private native void nativeAdvanceRead(long nativePtr);
     private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index) throws BadVersionException;
     private native void nativePromoteToWrite(long nativePtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index f720361122..e5b32ae2df 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -162,7 +162,7 @@ public TableSchema getSubtableSchema(long columnIndex) {
      *
      * @param type the column type.
      * @param name the field/column name.
-     * @param isNullable {@code true} if column can contain null values, {@ code false}e otherwise.
+     * @param isNullable {@code true} if column can contain null values, {@code false} otherwise.
      * @return the index of the new column.
      */
     public long addColumn(RealmFieldType type, String name, boolean isNullable) {
@@ -371,7 +371,6 @@ public long addEmptyRow() {
                         throwDuplicatePrimaryKeyException(INTEGER_DEFAULT_VALUE);
                     }
                     break;
-
                 default:
                     throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
             }
@@ -390,38 +389,55 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
         UncheckedRow row;
 
         // Add with primary key initially set
-        switch (type) {
-            case STRING:
-                if (!(primaryKeyValue instanceof String)) {
-                    throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
-                }
-                if (findFirstString(primaryKeyColumnIndex, (String)primaryKeyValue) != NO_MATCH) {
-                    throwDuplicatePrimaryKeyException(primaryKeyValue);
-                }
-                rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getUncheckedRow(rowIndex);
-                row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
-                break;
+        if (primaryKeyValue == null) {
+            switch (type) {
+                case STRING:
+                case INTEGER:
+                    if (findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
+                        throwDuplicatePrimaryKeyException("null");
+                    }
+                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                    row = getUncheckedRow(rowIndex);
+                    row.setNull(primaryKeyColumnIndex);
+                    break;
 
-            case INTEGER:
-                long pkValue;
-                try {
-                    pkValue = Long.parseLong(primaryKeyValue.toString());
-                } catch (RuntimeException e) {
-                    throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
-                }
-                if (findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
-                    throwDuplicatePrimaryKeyException(pkValue);
-                }
-                rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getUncheckedRow(rowIndex);
-                row.setLong(primaryKeyColumnIndex, pkValue);
-                break;
+                default:
+                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
+            }
 
-            default:
-                throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
-        }
+        } else {
+            switch (type) {
+                case STRING:
+                    if (!(primaryKeyValue instanceof String)) {
+                        throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
+                    }
+                    if (findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
+                        throwDuplicatePrimaryKeyException(primaryKeyValue);
+                    }
+                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                    row = getUncheckedRow(rowIndex);
+                    row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
+                    break;
 
+                case INTEGER:
+                    long pkValue;
+                    try {
+                        pkValue = Long.parseLong(primaryKeyValue.toString());
+                    } catch (RuntimeException e) {
+                        throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
+                    }
+                    if (findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
+                        throwDuplicatePrimaryKeyException(pkValue);
+                    }
+                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                    row = getUncheckedRow(rowIndex);
+                    row.setLong(primaryKeyColumnIndex, pkValue);
+                    break;
+
+                default:
+                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
+            }
+        }
         return rowIndex;
     }
 
@@ -485,9 +501,14 @@ protected long add(Object... values) {
                 nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
                 break;
             case INTEGER:
-                long intValue = ((Number) value).longValue();
-                checkIntValueIsLegal(columnIndex, rowIndex, intValue);
-                nativeSetLong(nativePtr, columnIndex, rowIndex, intValue);
+                if (value == null) {
+                    checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
+                    nativeSetNull(nativePtr, columnIndex, rowIndex);
+                } else {
+                    long intValue = ((Number) value).longValue();
+                    checkIntValueIsLegal(columnIndex, rowIndex, intValue);
+                    nativeSetLong(nativePtr, columnIndex, rowIndex, intValue);
+                }
                 break;
             case FLOAT:
                 nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value);
@@ -496,14 +517,19 @@ protected long add(Object... values) {
                 nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value);
                 break;
             case STRING:
-                String stringValue = (String) value;
-                checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
-                nativeSetString(nativePtr, columnIndex, rowIndex, (String) value);
+                if (value == null) {
+                    checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
+                    nativeSetNull(nativePtr, columnIndex, rowIndex);
+                } else {
+                    String stringValue = (String) value;
+                    checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
+                    nativeSetString(nativePtr, columnIndex, rowIndex, (String) value);
+                }
                 break;
             case DATE:
                 if (value == null)
                     throw new IllegalArgumentException("Null Date is not allowed.");
-                nativeSetDate(nativePtr, columnIndex, rowIndex, ((Date) value).getTime() / 1000);
+                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime());
                 break;
             case UNSUPPORTED_MIXED:
                 if (value == null)
@@ -635,6 +661,25 @@ void checkIntValueIsLegal(long columnIndex, long rowToUpdate, long value) {
         }
     }
 
+    // check if it is ok to use null value for given row and column.
+    void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
+        if (isPrimaryKeyColumn(columnIndex)) {
+            RealmFieldType type = getColumnType(columnIndex);
+            switch (type) {
+                case STRING:
+                case INTEGER:
+                    long rowIndex = findFirstNull(columnIndex);
+                    if (rowIndex != rowToUpdate && rowIndex != TableOrView.NO_MATCH) {
+                        throwDuplicatePrimaryKeyException("null");
+                    }
+                    break;
+                default:
+                    // Since it is sufficient to check the existance of duplicated null values
+                    // on PrimaryKey in supported types only, this part is left empty.
+            }
+        }
+    }
+
     private void throwDuplicatePrimaryKeyException(Object value) {
         throw new RealmPrimaryKeyConstraintException("Value already exists: " + value);
     }
@@ -665,7 +710,7 @@ public double getDouble(long columnIndex, long rowIndex) {
 
     @Override
     public Date getDate(long columnIndex, long rowIndex) {
-        return new Date(nativeGetDateTime(nativePtr, columnIndex, rowIndex)*1000);
+        return new Date(nativeGetTimestamp(nativePtr, columnIndex, rowIndex));
     }
 
     /**
@@ -847,14 +892,26 @@ public void setDate(long columnIndex, long rowIndex, Date date) {
         if (date == null)
             throw new IllegalArgumentException("Null Date is not allowed.");
         checkImmutable();
-        nativeSetDate(nativePtr, columnIndex, rowIndex, date.getTime() / 1000);
+        nativeSetTimestamp(nativePtr, columnIndex, rowIndex, date.getTime());
     }
 
+    /**
+     * Set a String value to a cell of Table, pointed by column and row index.
+     *
+     * @param columnIndex 0 based index value of the cell column.
+     * @param rowIndex 0 based index value of the cell row.
+     * @param value a String value to set in the cell.
+     */
     @Override
     public void setString(long columnIndex, long rowIndex, String value) {
         checkImmutable();
-        checkStringValueIsLegal(columnIndex, rowIndex, value);
-        nativeSetString(nativePtr, columnIndex, rowIndex, value);
+        if (value == null) {
+            checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
+            nativeSetNull(nativePtr, columnIndex, rowIndex);
+        } else {
+            checkStringValueIsLegal(columnIndex, rowIndex, value);
+            nativeSetString(nativePtr, columnIndex, rowIndex, value);
+        }
     }
 
     /**
@@ -1095,12 +1152,12 @@ public double averageDouble(long columnIndex) {
 
     @Override
     public Date maximumDate(long columnIndex) {
-        return new Date(nativeMaximumDate(nativePtr, columnIndex) * 1000);
+        return new Date(nativeMaximumTimestamp(nativePtr, columnIndex));
     }
 
     @Override
     public Date minimumDate(long columnIndex) {
-        return new Date(nativeMinimumDate(nativePtr, columnIndex) * 1000);
+        return new Date(nativeMinimumTimestamp(nativePtr, columnIndex));
     }
 
     //
@@ -1180,7 +1237,7 @@ public long findFirstDate(long columnIndex, Date date) {
         if (date == null) {
             throw new IllegalArgumentException("null is not supported");
         }
-        return nativeFindFirstDate(nativePtr, columnIndex, date.getTime() / 1000);
+        return nativeFindFirstTimestamp(nativePtr, columnIndex, date.getTime());
     }
 
     @Override
@@ -1191,6 +1248,16 @@ public long findFirstString(long columnIndex, String value) {
         return nativeFindFirstString(nativePtr, columnIndex, value);
     }
 
+    /**
+     * Searches for first occurrence of null. Beware that the order in the column is undefined.
+     *
+     * @param columnIndex the column to search in.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
+     */
+    public long findFirstNull(long columnIndex) {
+        return nativeFindFirstNull(nativePtr, columnIndex);
+    }
+
     @Override
     public TableView findAllLong(long columnIndex, long value) {
         context.executeDelayedDisposal();
@@ -1242,19 +1309,6 @@ public TableView findAllDouble(long columnIndex, double value) {
         }
     }
 
-    @Override
-    public TableView findAllDate(long columnIndex, Date date) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeFindAllDate(nativePtr, columnIndex, date.getTime() / 1000);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
-    }
-
     @Override
     public TableView findAllString(long columnIndex, String value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1340,7 +1394,7 @@ public String rowToString(long rowIndex) {
     }
 
     @Override
-    public long sync() {
+    public long syncIfNeeded() {
         throw new RuntimeException("Not supported for tables");
     }
 
@@ -1375,7 +1429,7 @@ public static boolean isMetaTable(String tableName) {
      *
      * @return version_counter for the table.
      */
-    public long version() {
+    public long getVersion() {
         return nativeVersion(nativePtr);
     }
 
@@ -1415,7 +1469,7 @@ public static String tableNameToClassName(String tableName) {
     private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
     private native float nativeGetFloat(long nativeTablePtr, long columnIndex, long rowIndex);
     private native double nativeGetDouble(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native long nativeGetDateTime(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native long nativeGetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex);
     private native String nativeGetString(long nativePtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
     private native int nativeGetMixedType(long nativePtr, long columnIndex, long rowIndex);
@@ -1431,8 +1485,9 @@ public static String tableNameToClassName(String tableName) {
     private native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
     private native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
     private native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-    private native void nativeSetDate(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    private native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
     private native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    private native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
     private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
     private native void nativeSetMixed(long nativeTablePtr, long columnIndex, long rowIndex, Mixed data);
     private native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
@@ -1455,8 +1510,8 @@ public static String tableNameToClassName(String tableName) {
     private native double nativeMaximumDouble(long nativePtr, long columnIndex);
     private native double nativeMinimumDouble(long nativePtr, long columnIndex);
     private native double nativeAverageDouble(long nativePtr, long columnIndex);
-    private native long nativeMaximumDate(long nativePtr, long columnIndex);
-    private native long nativeMinimumDate(long nativePtr, long columnIndex);
+    private native long nativeMaximumTimestamp(long nativePtr, long columnIndex);
+    private native long nativeMinimumTimestamp(long nativePtr, long columnIndex);
     private native long nativeCountLong(long nativePtr, long columnIndex, long value);
     private native long nativeCountFloat(long nativePtr, long columnIndex, float value);
     private native long nativeCountDouble(long nativePtr, long columnIndex, double value);
@@ -1466,13 +1521,14 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindFirstTimestamp(long nativeTablePtr, long columnIndex, long dateTimeValue);
     private native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
+    private native long nativeFindFirstNull(long nativePtr, long columnIndex);
     private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
     private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
     private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
     private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
     private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 956afb695e..32ebc23ed3 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -18,6 +18,7 @@
 
 import java.util.Date;
 
+import io.realm.Realm;
 import io.realm.RealmFieldType;
 
 /**
@@ -327,8 +328,6 @@
 
     TableView findAllDouble(long columnIndex, double value);
 
-    TableView findAllDate(long columnIndex, Date value);
-
     TableView findAllString(long columnIndex, String value);
 
     String toJson();
@@ -353,6 +352,15 @@
 
     long count(long columnIndex, String value);
 
+    /**
+     * Report the current versioning counter for the table. The versioning counter is guaranteed to
+     * change when the contents of the table changes after advance_read() or promote_to_write(), or
+     * immediately after calls to methods which change the table.
+     *
+     * @return version_counter for the table.
+     */
+    long getVersion();
+
     void removeFirst();
 
     enum PivotType {
@@ -372,10 +380,13 @@
     Table pivot(long stringCol, long intCol, PivotType pivotType);
 
     /**
-     * Syncs the tableview with the underlying table data. It is not required to call this explicitly, all other API
-     * methods will automatically sync the view as well.
+     * Syncs the TableView with the underlying table data. This is effectively the same as rerunning the query, so it
+     * should not be called on TableViews created by an async query.
+     *
+     * This method gets automatically called when calling {@link Realm#refresh()} or when another thread updates
+     * the Realm, but it will _not_ be called if the same thread commits a transaction.
      *
-     * @return the version number for the updated tableview.
+     * @return the version number for the updated TableView.
      */
-    long sync();
+    long syncIfNeeded();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index b76d41f269..0b304f86c5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -287,7 +287,7 @@ public TableQuery equalTo(long columnIndex[], Date value){
         if (value == null) {
             nativeIsNull(nativePtr, columnIndex);
         } else {
-            nativeEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+            nativeEqualTimestamp(nativePtr, columnIndex, value.getTime());
         }
         queryValidated = false;
         return this;
@@ -296,7 +296,7 @@ public TableQuery equalTo(long columnIndex[], Date value){
     public TableQuery notEqualTo(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeNotEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeNotEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -304,7 +304,7 @@ public TableQuery notEqualTo(long columnIndex[], Date value){
     public TableQuery greaterThan(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeGreaterDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeGreaterTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -312,7 +312,7 @@ public TableQuery greaterThan(long columnIndex[], Date value){
     public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeGreaterEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeGreaterEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -320,7 +320,7 @@ public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
     public TableQuery lessThan(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeLessDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeLessTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -328,7 +328,7 @@ public TableQuery lessThan(long columnIndex[], Date value){
     public TableQuery lessThanOrEqual(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeLessEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeLessEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -336,7 +336,7 @@ public TableQuery lessThanOrEqual(long columnIndex[], Date value){
     public TableQuery between(long columnIndex[], Date value1, Date value2){
         if (value1 == null || value2 == null)
             throw new IllegalArgumentException("Date values in query criteria must not be null."); // Different text
-        nativeBetweenDateTime(nativePtr, columnIndex, value1.getTime()/1000, value2.getTime()/1000);
+        nativeBetweenTimestamp(nativePtr, columnIndex, value1.getTime(), value2.getTime());
         queryValidated = false;
         return this;
     }
@@ -655,24 +655,24 @@ public double averageDouble(long columnIndex) {
 
     public Date maximumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
-        Long result = nativeMaximumDate(nativePtr, columnIndex, start, end, limit);
+        Long result = nativeMaximumTimestamp(nativePtr, columnIndex, start, end, limit);
         if (result != null) {
-            return new Date(result * 1000);
+            return new Date(result);
         }
         return null;
     }
     public Date maximumDate(long columnIndex) {
         validateQuery();
-        Long result = nativeMaximumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
+        Long result = nativeMaximumTimestamp(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
         if (result != null) {
-            return new Date(result * 1000);
+            return new Date(result);
         }
         return null;
     }
 
     public Date minimumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
-        Long result = nativeMinimumDate(nativePtr, columnIndex, start, end, limit);
+        Long result = nativeMinimumTimestamp(nativePtr, columnIndex, start, end, limit);
         if (result != null) {
             return new Date(result * 1000);
         }
@@ -680,9 +680,9 @@ public Date minimumDate(long columnIndex, long start, long end, long limit) {
     }
     public Date minimumDate(long columnIndex) {
         validateQuery();
-        Long result = nativeMinimumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
+        Long result = nativeMinimumTimestamp(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
         if (result != null) {
-            return new Date(result * 1000);
+            return new Date(result);
         }
         return null;
     }
@@ -772,13 +772,13 @@ private void throwImmutable() {
     private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
     private native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
     private native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
-    private native void nativeEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeNotEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeGreaterDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeGreaterEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeLessDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeLessEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeBetweenDateTime(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeBetweenTimestamp(long nativeQueryPtr, long columnIndex[], long value1, long value2);
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
     private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
     private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
@@ -799,8 +799,8 @@ private void throwImmutable() {
     private native Double nativeMaximumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
     private native Double nativeMinimumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
     private native double nativeAverageDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-    private native Long nativeMaximumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-    private native Long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMaximumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMinimumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
     private native void nativeIsNull(long nativePtr, long columnIndices[]);
     private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index e7d30d4ad1..6928abda3a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -37,6 +37,7 @@
     // Core requests TableView to hold the Query reference.
     @SuppressWarnings({"unused"})
     private final TableQuery query; // the query which created this TableView
+    private long version; // Last seen version number. Call refresh() to update this.
 
     /**
      * Creates a TableView. This constructor is used if the TableView is created from a table.
@@ -78,12 +79,12 @@ public void close() {
         synchronized (context) {
             if (nativePtr != 0) {
                 nativeClose(nativePtr);
-                
+
                 if (DEBUG) {
                     RealmLog.d("==== TableView CLOSE, ptr= " + nativePtr);
                 }
                 nativePtr = 0;
-            } 
+            }
         }
     }
 
@@ -229,7 +230,7 @@ public double getDouble(long columnIndex, long rowIndex){
      */
     @Override
     public Date getDate(long columnIndex, long rowIndex){
-        return new Date(nativeGetDateTimeValue(nativePtr, columnIndex, rowIndex)*1000);
+        return new Date(nativeGetTimestamp(nativePtr, columnIndex, rowIndex));
     }
 
     /**
@@ -369,7 +370,7 @@ public void setDouble(long columnIndex, long rowIndex, double value){
     @Override
     public void setDate(long columnIndex, long rowIndex, Date value){
         if (parent.isImmutable()) throwImmutable();
-        nativeSetDateTimeValue(nativePtr, columnIndex, rowIndex, value.getTime()/1000);
+        nativeSetTimestampValue(nativePtr, columnIndex, rowIndex, value.getTime());
     }
 
     /**
@@ -492,7 +493,9 @@ public long findFirstDouble(long columnIndex, double value) {
 
     @Override
     public long findFirstDate(long columnIndex, Date date) {
-        return nativeFindFirstDate(nativePtr, columnIndex, date.getTime()/1000);
+        // FIXME: waiting for implementation
+        return NO_MATCH;
+        // return nativeFindFirstDate(nativePtr, columnIndex, date.getTime());
     }
 
     @Override
@@ -519,7 +522,7 @@ public TableView findAllLong(long columnIndex, long value){
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllInt(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
@@ -532,12 +535,12 @@ public TableView findAllBoolean(long columnIndex, boolean value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllBool(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
-        }  
+        }
     }
 
     @Override
@@ -545,12 +548,12 @@ public TableView findAllFloat(long columnIndex, float value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllFloat(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
-        }  
+        }
     }
 
     @Override
@@ -558,25 +561,12 @@ public TableView findAllDouble(long columnIndex, double value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllDouble(nativePtr, columnIndex, value);
-        try { 
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }   
-    }
-
-    @Override
-    public TableView findAllDate(long columnIndex, Date date) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeFindAllDate(nativePtr, columnIndex, date.getTime()/1000);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
-        }  
+        }
     }
 
     @Override
@@ -584,7 +574,7 @@ public TableView findAllString(long columnIndex, String value){
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllString(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
@@ -691,20 +681,20 @@ public double averageDouble(long columnIndex) {
 
     @Override
     public Date maximumDate(long columnIndex) {
-        Long result = nativeMaximumDate(nativePtr, columnIndex);
+        Long result = nativeMaximumTimestamp(nativePtr, columnIndex);
         if (result == null) {
             return null;
         }
-        return new Date(result * 1000);
+        return new Date(result);
     }
 
     @Override
     public Date minimumDate(long columnIndex) {
-        Long result = nativeMinimumDate(nativePtr, columnIndex);
+        Long result = nativeMinimumTimestamp(nativePtr, columnIndex);
         if (result == null) {
             return null;
         }
-        return new Date(result * 1000);
+        return new Date(result);
     }
 
     // Sorting
@@ -786,6 +776,11 @@ public long count(long columnIndex, String value) {
         throw new RuntimeException("Not implemented yet.");
     }
 
+    @Override
+    public long getVersion() {
+        return version;
+    }
+
     @Override
     public Table pivot(long stringCol, long intCol, PivotType pivotType){
         if (! this.getColumnType(stringCol).equals(RealmFieldType.STRING ))
@@ -832,8 +827,9 @@ public void distinct(List<Long> columnIndexes) {
     }
 
     @Override
-    public long sync() {
-        return nativeSync(nativePtr);
+    public long syncIfNeeded() {
+        version = nativeSyncIfNeeded(nativePtr);
+        return version;
     }
 
     static native void nativeClose(long nativeViewPtr);
@@ -847,7 +843,7 @@ public long sync() {
     private native boolean nativeGetBoolean(long nativeViewPtr, long columnIndex, long rowIndex);
     private native float nativeGetFloat(long nativeViewPtr, long columnIndex, long rowIndex);
     private native double nativeGetDouble(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetDateTimeValue(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native long nativeGetTimestamp(long nativeViewPtr, long columnIndex, long rowIndex);
     private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
     private native int nativeGetMixedType(long nativeViewPtr, long columnIndex, long rowIndex);
@@ -860,7 +856,7 @@ public long sync() {
     private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
     private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
     private native void nativeSetDouble(long nativeViewPtr, long columnIndex, long rowIndex, double value);
-    private native void nativeSetDateTimeValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    private native void nativeSetTimestampValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
     private native void nativeSetString(long nativeViewPtr, long columnIndex, long rowIndex, String value);
     private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
     private native void nativeSetMixed(long nativeViewPtr, long columnIndex, long rowIndex, Mixed value);
@@ -894,8 +890,8 @@ public long sync() {
     private native Double nativeMaximumDouble(long nativeViewPtr, long columnIndex);
     private native Double nativeMinimumDouble(long nativeViewPtr, long columnIndex);
     private native double nativeAverageDouble(long nativePtr, long columnIndex);
-    private native Long nativeMaximumDate(long nativePtr, long columnIndex);
-    private native Long nativeMinimumDate(long nativePtr, long columnIndex);
+    private native Long nativeMaximumTimestamp(long nativePtr, long columnIndex);
+    private native Long nativeMinimumTimestamp(long nativePtr, long columnIndex);
     private native void nativeSort(long nativeTableViewPtr, long columnIndex, boolean sortOrder);
     private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
     private native long createNativeTableView(Table table, long nativeTablePtr);
@@ -905,6 +901,7 @@ public long sync() {
     private native long nativeWhere(long nativeViewPtr);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
     private native long nativeDistinct(long nativeViewPtr, long columnIndex);
+    private native long nativeSyncIfNeeded(long nativeTablePtr);
     private native long nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
     private native long nativeSync(long nativeTablePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index d12ef09395..d7eda8092f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -145,7 +145,7 @@ public double getDouble(long columnIndex) {
 
     @Override
     public Date getDate(long columnIndex) {
-        return new Date(nativeGetDateTime(nativePointer, columnIndex)*1000);
+        return new Date(nativeGetTimestamp(nativePointer, columnIndex));
     }
 
     @Override
@@ -217,15 +217,26 @@ public void setDate(long columnIndex, Date date) {
         if (date == null) {
             throw new IllegalArgumentException("Null Date is not allowed.");
         }
-        long timestamp = date.getTime() / 1000;
-        nativeSetDate(nativePointer, columnIndex, timestamp);
+        long timestamp = date.getTime();
+        nativeSetTimestamp(nativePointer, columnIndex, timestamp);
     }
 
+    /**
+     * Set a string value to a row pointer.
+     *
+     * @param columnIndex 0 based index value of the cell column.
+     * @param value the value to to a row
+     */
     @Override
     public void setString(long columnIndex, String value) {
         parent.checkImmutable();
-        getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
-        nativeSetString(nativePointer, columnIndex, value);
+        if (value == null) {
+            getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
+            nativeSetNull(nativePointer, columnIndex);
+        } else {
+            getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
+            nativeSetString(nativePointer, columnIndex, value);
+        }
     }
 
     @Override
@@ -260,8 +271,15 @@ public boolean isNull(long columnIndex) {
         return nativeIsNull(nativePointer, columnIndex);
     }
 
+    /**
+     * Set null to a row pointer.
+     *
+     * @param columnIndex 0 based index value of the cell column.
+     */
     @Override
     public void setNull(long columnIndex) {
+        parent.checkImmutable();
+        getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
         nativeSetNull(nativePointer, columnIndex);
     }
 
@@ -293,7 +311,7 @@ public boolean hasColumn(String fieldName) {
     protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
     protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
     protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetTimestamp(long nativeRowPtr, long columnIndex);
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
@@ -305,7 +323,7 @@ public boolean hasColumn(String fieldName) {
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
     protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
     protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
-    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
     protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index a1b5d0b23b..1f075b5110 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -16,6 +16,7 @@
 
 package io.realm.internal;
 
+import io.realm.RealmModel;
 import io.realm.RealmObject;
 
 public class Util {
@@ -87,13 +88,13 @@ public String execute(long parm1) {
      * Normalizes a input class to it's original RealmObject class so it is transparent whether or not the input class
      * was a RealmProxy class.
      */
-    public static Class<? extends RealmObject> getOriginalModelClass(Class<? extends RealmObject> clazz) {
+    public static Class<? extends RealmModel> getOriginalModelClass(Class<? extends RealmModel> clazz) {
         //This cast is correct because 'clazz' is either the type
         //generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked")
-        Class<? extends RealmObject> superclass = (Class<? extends RealmObject>) clazz.getSuperclass();
+        Class<? extends RealmModel> superclass = (Class<? extends RealmModel>) clazz.getSuperclass();
 
-        if (!superclass.equals(RealmObject.class)) {
+        if (!superclass.equals(Object.class) && !superclass.equals(RealmObject.class)) {
             clazz = superclass;
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
index 525456635e..c2558fca93 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -24,8 +24,9 @@
 import java.util.List;
 
 import io.realm.RealmConfiguration;
-import io.realm.RealmObject;
+import io.realm.RealmModel;
 import io.realm.RealmResults;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.SharedGroup;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
@@ -204,8 +205,8 @@ private boolean isAliveHandler(Handler handler) {
 
     // result of the async query
     public static class Result {
-        public IdentityHashMap<WeakReference<RealmResults<? extends RealmObject>>, Long> updatedTableViews;
-        public IdentityHashMap<WeakReference<RealmObject>, Long> updatedRow;
+        public IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long> updatedTableViews;
+        public IdentityHashMap<WeakReference<RealmObjectProxy>, Long> updatedRow;
         public SharedGroup.VersionID versionID;
 
         public static Result newRealmResultsResponse() {
@@ -216,7 +217,7 @@ public static Result newRealmResultsResponse() {
 
         public static Result newRealmObjectResponse() {
             Result result = new Result();
-            result.updatedRow = new IdentityHashMap<WeakReference<RealmObject>, Long>(1);
+            result.updatedRow = new IdentityHashMap<WeakReference<RealmObjectProxy>, Long>(1);
             return result;
         }
     }
@@ -249,16 +250,16 @@ public static Result newRealmObjectResponse() {
         }
 
         public interface UpdateQueryStep {
-            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmObject>> weakReference,
+            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weakReference,
                                           long handoverQueryPointer,
                                           ArgumentsHolder queryArguments);
-            HandlerStep addObject(WeakReference<? extends RealmObject> weakReference,
+            HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
                                   long handoverQueryPointer,
                                   ArgumentsHolder queryArguments);// can only update 1 element
         }
 
         public interface RealmResultsQueryStep {
-            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmObject>> weakReference,
+            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weakReference,
                                           long handoverQueryPointer,
                                           ArgumentsHolder queryArguments);
             BuilderStep sendToHandler(Handler handler, int message);
@@ -297,7 +298,7 @@ public RealmResultsQueryStep add(WeakReference<RealmResults<?>> weakReference,
             }
 
             @Override
-            public HandlerStep addObject(WeakReference<? extends RealmObject> weakReference,
+            public HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
                                          long handoverQueryPointer,
                                          ArgumentsHolder queryArguments) {
                 realmObjectEntry =
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 1c665475c4..cfe7ba1198 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -29,7 +29,7 @@
 import java.util.Set;
 
 import io.realm.Realm;
-import io.realm.RealmObject;
+import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
@@ -42,13 +42,13 @@
  */
 public class CompositeMediator extends RealmProxyMediator {
 
-    private final Map<Class<? extends RealmObject>, RealmProxyMediator> mediators;
+    private final Map<Class<? extends RealmModel>, RealmProxyMediator> mediators;
 
     public CompositeMediator(RealmProxyMediator... mediators) {
-        final HashMap<Class<? extends RealmObject>, RealmProxyMediator> tempMediators = new HashMap<>();
+        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<>();
         if (mediators != null) {
             for (RealmProxyMediator mediator : mediators) {
-                for (Class<? extends RealmObject> realmClass : mediator.getModelClasses()) {
+                for (Class<? extends RealmModel> realmClass : mediator.getModelClasses()) {
                     tempMediators.put(realmClass, mediator);
                 }
             }
@@ -57,67 +57,67 @@ public CompositeMediator(RealmProxyMediator... mediators) {
     }
 
     @Override
-    public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.createTable(clazz, transaction);
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.validateTable(clazz, transaction);
     }
 
     @Override
-    public List<String> getFieldNames(Class<? extends RealmObject> clazz) {
+    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.getFieldNames(clazz);
     }
 
     @Override
-    public String getTableName(Class<? extends RealmObject> clazz) {
+    public String getTableName(Class<? extends RealmModel> clazz) {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.getTableName(clazz);
     }
 
     @Override
-    public <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.newInstance(clazz, columnInfo);
     }
 
     @Override
-    public Set<Class<? extends RealmObject>> getModelClasses() {
+    public Set<Class<? extends RealmModel>> getModelClasses() {
         return mediators.keySet();
     }
 
     @Override
-    public <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
         return mediator.copyOrUpdate(realm, object, update, cache);
     }
 
     @Override
-    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
+    public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.createOrUpdateUsingJsonObject(clazz, realm, json, update);
     }
 
     @Override
-    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException {
+    public <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException {
         RealmProxyMediator mediator = getMediator(clazz);
         return mediator.createUsingJsonStream(clazz, realm, reader);
     }
 
     @Override
-    public <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+    public <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
         RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(realmObject.getClass()));
         return mediator.createDetachedCopy(realmObject, maxDepth, cache);
     }
 
     @Override
     public boolean transformerApplied() {
-        for (Map.Entry<Class<? extends RealmObject>, RealmProxyMediator> entry : mediators.entrySet()) {
+        for (Map.Entry<Class<? extends RealmModel>, RealmProxyMediator> entry : mediators.entrySet()) {
             if (!entry.getValue().transformerApplied()) {
                 return false;
             }
@@ -126,7 +126,7 @@ public boolean transformerApplied() {
     }
 
     // Returns the mediator for a given model class (not RealmProxy) or throws exception
-    private RealmProxyMediator getMediator(Class<? extends RealmObject> clazz) {
+    private RealmProxyMediator getMediator(Class<? extends RealmModel> clazz) {
         RealmProxyMediator mediator = mediators.get(clazz);
         if (mediator == null) {
             throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index c200323c85..ed5122e3e9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -30,7 +30,7 @@
 import java.util.Set;
 
 import io.realm.Realm;
-import io.realm.RealmObject;
+import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
@@ -45,7 +45,7 @@
 public class FilterableMediator extends RealmProxyMediator {
 
     private final RealmProxyMediator originalMediator;
-    private final Set<Class<? extends RealmObject>> allowedClasses;
+    private final Set<Class<? extends RealmModel>> allowedClasses;
 
     /**
      * Creates a filterable {@link RealmProxyMediator}.
@@ -53,13 +53,13 @@
      * @param originalMediator the original auto generated mediator.
      * @param allowedClasses the subset of classes from original mediator to allow.
      */
-    public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<? extends RealmObject>> allowedClasses) {
+    public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<? extends RealmModel>> allowedClasses) {
         this.originalMediator = originalMediator;
 
-        Set<Class<? extends RealmObject>> tempAllowedClasses = new HashSet<Class<? extends RealmObject>>();
+        Set<Class<? extends RealmModel>> tempAllowedClasses = new HashSet<Class<? extends RealmModel>>();
         if (originalMediator != null) {
-            Set<Class<? extends RealmObject>> originalClasses = originalMediator.getModelClasses();
-            for (Class<? extends RealmObject> clazz : allowedClasses) {
+            Set<Class<? extends RealmModel>> originalClasses = originalMediator.getModelClasses();
+            for (Class<? extends RealmModel> clazz : allowedClasses) {
                 if (originalClasses.contains(clazz)) {
                     tempAllowedClasses.add(clazz);
                 }
@@ -73,60 +73,60 @@ public RealmProxyMediator getOriginalMediator() {
     }
 
     @Override
-    public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         checkSchemaHasClass(clazz);
         return originalMediator.createTable(clazz, transaction);
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         checkSchemaHasClass(clazz);
         return originalMediator.validateTable(clazz, transaction);
     }
 
     @Override
-    public List<String> getFieldNames(Class<? extends RealmObject> clazz) {
+    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
         checkSchemaHasClass(clazz);
         return originalMediator.getFieldNames(clazz);
     }
 
     @Override
-    public String getTableName(Class<? extends RealmObject> clazz) {
+    public String getTableName(Class<? extends RealmModel> clazz) {
         checkSchemaHasClass(clazz);
         return originalMediator.getTableName(clazz);
     }
 
     @Override
-    public <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         checkSchemaHasClass(clazz);
         return originalMediator.newInstance(clazz, columnInfo);
     }
 
     @Override
-    public Set<Class<? extends RealmObject>> getModelClasses() {
+    public Set<Class<? extends RealmModel>> getModelClasses() {
         return allowedClasses;
     }
 
     @Override
-    public <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
         return originalMediator.copyOrUpdate(realm, object, update, cache);
     }
 
     @Override
-    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
+    public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
         checkSchemaHasClass(clazz);
         return originalMediator.createOrUpdateUsingJsonObject(clazz, realm, json, update);
     }
 
     @Override
-    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException {
+    public <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException {
         checkSchemaHasClass(clazz);
         return originalMediator.createUsingJsonStream(clazz, realm, reader);
     }
 
     @Override
-    public <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+    public <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
         checkSchemaHasClass(Util.getOriginalModelClass(realmObject.getClass()));
         return originalMediator.createDetachedCopy(realmObject, maxDepth, cache);
     }
@@ -141,7 +141,7 @@ public boolean transformerApplied() {
     }
 
     // Validate if a model class (not RealmProxy) is part of this Schema.
-    private void checkSchemaHasClass(Class<? extends RealmObject> clazz) {
+    private void checkSchemaHasClass(Class<? extends RealmModel> clazz) {
         if (!allowedClasses.contains(clazz)) {
             throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
         }
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 952f24d468..285388bbc8 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -25,6 +25,7 @@
 import io.realm.RealmChangeListener;
 import io.realm.RealmConfiguration;
 import io.realm.RealmList;
+import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
@@ -53,10 +54,10 @@
             return new StrongReferenceCounter<RealmResults>();
         }
     };
-    ThreadLocal<StrongReferenceCounter<RealmObject>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmObject>>() {
+    ThreadLocal<StrongReferenceCounter<RealmModel>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmModel>>() {
         @Override
-        protected StrongReferenceCounter<RealmObject> initialValue() {
-            return new StrongReferenceCounter<RealmObject>();
+        protected StrongReferenceCounter<RealmModel> initialValue() {
+            return new StrongReferenceCounter<RealmModel>();
         }
     };
 
@@ -69,9 +70,9 @@ public void call(final Subscriber<? super Realm> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm realm) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(observableRealm);
                         }
@@ -99,9 +100,9 @@ public void call(final Subscriber<? super DynamicRealm> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<DynamicRealm> listener = new RealmChangeListener<DynamicRealm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(DynamicRealm realm) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(observableRealm);
                         }
@@ -124,7 +125,7 @@ public void call() {
     }
 
     @Override
-    public <E extends RealmObject> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
+    public <E extends RealmModel> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
 
         return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
@@ -135,9 +136,9 @@ public void call(final Subscriber<? super RealmResults<E>> subscriber) {
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<RealmResults<E>> listener = new RealmChangeListener<RealmResults<E>>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(RealmResults<E> result) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(results);
                         }
@@ -171,9 +172,9 @@ public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subs
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<RealmResults<DynamicRealmObject>> listener = new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(RealmResults<DynamicRealmObject> result) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(results);
                         }
@@ -197,7 +198,7 @@ public void call() {
     }
 
     @Override
-    public <E extends RealmObject> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+    public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
         return getRealmListObservable();
     }
 
@@ -206,12 +207,12 @@ public void call() {
         return getRealmListObservable();
     }
 
-    private <E extends RealmObject> Observable<RealmList<E>> getRealmListObservable() {
+    private <E extends RealmModel> Observable<RealmList<E>> getRealmListObservable() {
         throw new RuntimeException("RealmList does not support change listeners yet, so cannot create an Observable");
     }
 
     @Override
-    public <E extends RealmObject> Observable<E> from(final Realm realm, final E object) {
+    public <E extends RealmModel> Observable<E> from(final Realm realm, final E object) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
         return Observable.create(new Observable.OnSubscribe<E>() {
             @Override
@@ -221,22 +222,21 @@ public void call(final Subscriber<? super E> subscriber) {
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<E> listener = new RealmChangeListener<E>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(E object) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(object);
                         }
                     }
                 };
-                object.addChangeListener(listener);
+                RealmObject.addChangeListener(object, listener);
                 subscriber.add(Subscriptions.create(new Action0() {
                     @Override
                     public void call() {
-                        object.removeChangeListener(listener);
+                        RealmObject.removeChangeListener(object, listener);
                         observableRealm.close();
                         objectRefs.get().releaseReference(object);
-
                     }
                 }));
 
@@ -258,19 +258,19 @@ public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<DynamicRealmObject> listener = new RealmChangeListener<DynamicRealmObject>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(DynamicRealmObject object) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(object);
                         }
                     }
                 };
-                object.addChangeListener(listener);
+                RealmObject.addChangeListener(object, listener);
                 subscriber.add(Subscriptions.create(new Action0() {
                     @Override
                     public void call() {
-                        object.removeChangeListener(listener);
+                        RealmObject.removeChangeListener(object, listener);
                         observableRealm.close();
                         objectRefs.get().releaseReference(object);
                     }
@@ -284,7 +284,7 @@ public void call() {
     }
 
     @Override
-    public <E extends RealmObject> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+    public <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
index a0ddeddf1b..535de3837d 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
@@ -20,6 +20,7 @@
 import io.realm.DynamicRealmObject;
 import io.realm.Realm;
 import io.realm.RealmList;
+import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
@@ -63,7 +64,7 @@
      * @param <E> type of RealmObject
      * @return Rx observable that emit all updates to the RealmObject.
      */
-    <E extends RealmObject> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
+    <E extends RealmModel> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
@@ -89,7 +90,7 @@
      * @param realm {@link Realm} instance list is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmObject> Observable<RealmList<E>> from(Realm realm, RealmList<E> list);
+    <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list);
 
     /**
      * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
@@ -114,7 +115,7 @@
      * @param realm {@link Realm} instance object is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmObject> Observable<E> from(Realm realm, E object);
+    <E extends RealmModel> Observable<E> from(Realm realm, E object);
 
     /**
      * Creates an Observable for a {@link DynamicRealmObject}. It should emit the initial object when subscribed to and
@@ -136,7 +137,7 @@
      * @param realm {@link Realm} instance query is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmObject> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
+    <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
 
     /**
      * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
diff --git a/version.txt b/version.txt
index 91ef265118..222360a331 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.89.0-SNAPSHOT
+0.91.0-SNAPSHOT
