diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8a3f6ca335..ed9bad7e72 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -34,6 +34,7 @@
 ### Breaking Changes
 
 * [ObjectServer] Updated protocol version to 18 which is only compatible with ROS > 1.6.0.
+* An `IllegalStateException` will be thrown if the given `RealmModule` doesn't include all required model classes (#3398).
 
 ### Deprecated
 
@@ -74,7 +75,8 @@
 
 ### Internal
 
-* Factor out internal interface ManagedObject
+* Factor out internal interface ManagedObject.
+* Use Object Store to do table initialization.
 
 ## 3.3.1 (2017-05-26)
 
diff --git a/Dockerfile b/Dockerfile
index 3d61d47efe..f5a1726651 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -51,7 +51,7 @@ RUN mkdir "${ANDROID_HOME}/licenses" && \
     echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55" > "${ANDROID_HOME}/licenses/android-sdk-license"
 RUN sdkmanager --update
 RUN sdkmanager 'platform-tools'
-RUN sdkmanager 'build-tools;25.0.3'
+RUN sdkmanager 'build-tools;26.0.0'
 RUN sdkmanager 'extras;android;m2repository'
 RUN sdkmanager 'platforms;android-25'
 
diff --git a/README.md b/README.md
index 7c1c74a672..9c996e8e4a 100644
--- a/README.md
+++ b/README.md
@@ -60,8 +60,9 @@ In case you don't want to use the precompiled version, you can build Realm yours
 ### Prerequisites
 
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK **Build-Tools 25.0.3**, **Android N (API 25)** (for example through Android Studio’s **Android SDK Manager**).
+ * Download & install the Android SDK **Build-Tools 26.0.0**, **Android N (API 25)** (for example through Android Studio’s **Android SDK Manager**).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
+ * If you use Android Studio, Android Studio 3.0 or later is required.
 
  * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
 You may unzip the file wherever you choose.  For macOS, a suggested location is `~/Library/Android`.  The download will unzip as the directory `android-ndk-r10e`.
diff --git a/build.gradle b/build.gradle
index a641a7f5fd..a27e1486e0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -89,6 +89,17 @@ task check {
     dependsOn checkExamples
 }
 
+task assembleUnitTests(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble Android unit tests of the Realm project'
+    dependsOn installTransformer
+    buildFile = file('realm/build.gradle')
+    tasks = ['assembleAndroidTest']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
 task connectedUnitTests(type:GradleBuild) {
     group = 'Test'
     description = 'Run the Android unit tests of the Realm project'
@@ -100,6 +111,17 @@ task connectedUnitTests(type:GradleBuild) {
     }
 }
 
+task assembleBenchmarks(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble benchmark tests for the library '
+    dependsOn installTransformer
+    buildFile = file('library-benchmarks/build.gradle')
+    tasks = ['assembleAndroidTest']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
 task connectedBenchmarks(type:GradleBuild) {
     group = 'Test'
     description = 'Run all the benchmark tests for the library '
diff --git a/examples/build.gradle b/examples/build.gradle
index 1d0e7df2e9..aae1dcefce 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,5 +1,5 @@
 project.ext.sdkVersion = 25
-project.ext.buildTools = '25.0.3'
+project.ext.buildTools = '26.0.0'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
@@ -17,12 +17,13 @@ allprojects {
 
     buildscript {
         repositories {
+            google()
             mavenLocal()
             jcenter()
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:2.3.3'
+            classpath 'com.android.tools.build:gradle:3.0.0-alpha4'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
@@ -35,6 +36,7 @@ allprojects {
     repositories {
         mavenLocal()
         jcenter()
+        google()
     }
 }
 
diff --git a/examples/gradle.properties b/examples/gradle.properties
index 4a9594aeec..3cae06226c 100644
--- a/examples/gradle.properties
+++ b/examples/gradle.properties
@@ -1 +1,5 @@
-org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
+org.gradle.jvmargs=-Xmx2048M
+org.gradle.caching=true
+
+# disable AAPT2 to work around an issue of Robolectric in unitTestExample https://github.com/robolectric/robolectric/issues/3169
+android.enableAapt2=false
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 474e8611e1..8d45e3a5cb 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -37,5 +37,5 @@ android {
 }
 
 dependencies {
-    compile 'com.google.code.gson:gson:2.5'
+    implementation 'com.google.code.gson:gson:2.5'
 }
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index c46861f443..cdd8b8aeab 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -12,6 +12,7 @@ android {
         minSdkVersion 15
         versionCode 1
         versionName "1.0"
+        javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true
     }
     buildTypes {
         release {
@@ -27,6 +28,6 @@ android {
 }
 
 dependencies {
-    provided 'org.projectlombok:lombok:1.16.6'
+    compileOnly 'org.projectlombok:lombok:1.16.6'
     annotationProcessor 'org.projectlombok:lombok:1.16.6'
 }
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 763a8291a7..d4a434d370 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -45,6 +45,6 @@ android {
 }
 
 dependencies {
-    compile "org.jetbrains.kotlin:kotlin-stdlib-jre7:${kotlin_version}"
-    compile 'org.jetbrains.anko:anko-sdk15:0.9.1'
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:${kotlin_version}"
+    implementation 'org.jetbrains.anko:anko-sdk15:0.9.1'
 }
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index cc80f29f72..fe9fbafe10 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -37,5 +37,5 @@ android {
 }
 
 dependencies {
-    compile project(':moduleExample:library')
+    implementation project(':moduleExample:library')
 }
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index dcc0165a06..6e08119b9c 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -32,18 +32,18 @@ android {
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:25.2.0'
+    implementation 'com.android.support:appcompat-v7:25.2.0'
     //noinspection GradleDependency
-    compile 'com.android.support:design:25.2.0'
-    compile 'io.reactivex:rxjava:1.1.0'
-    compile 'io.reactivex:rxandroid:1.1.0'
-    compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
-    compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'
-    compile 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'
-    compile 'com.jakewharton.timber:timber:4.1.0'
-    compile 'com.jakewharton:butterknife:8.5.1'
+    implementation 'com.android.support:design:25.2.0'
+    implementation 'io.reactivex:rxjava:1.1.0'
+    implementation 'io.reactivex:rxandroid:1.1.0'
+    implementation 'com.squareup.retrofit:retrofit:2.0.0-beta2'
+    implementation 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'
+    implementation 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'
+    implementation 'com.jakewharton.timber:timber:4.1.0'
+    implementation 'com.jakewharton:butterknife:8.5.1'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
-    compile 'me.zhanghai.android.materialprogressbar:library:1.1.4'
+    implementation 'me.zhanghai.android.materialprogressbar:library:1.1.4'
 }
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index e976f16d01..f16e3db4bb 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -60,10 +60,10 @@ realm {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:25.2.0'
-    compile 'com.android.support:appcompat-v7:25.2.0'
-    compile 'com.android.support:design:25.2.0'
-    compile 'me.zhanghai.android.materialprogressbar:library:1.3.0'
-    compile 'com.jakewharton:butterknife:8.5.1'
+    implementation 'com.android.support:support-v4:25.2.0'
+    implementation 'com.android.support:appcompat-v7:25.2.0'
+    implementation 'com.android.support:design:25.2.0'
+    implementation 'me.zhanghai.android.materialprogressbar:library:1.3.0'
+    implementation 'com.jakewharton:butterknife:8.5.1'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
 }
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index 9a916ede8a..21c4723cf6 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -29,8 +29,8 @@ android {
 }
 
 dependencies {
-    compile 'io.reactivex:rxandroid:1.1.0'
-    compile 'io.reactivex:rxjava:1.1.0'
-    compile 'com.jakewharton.rxbinding:rxbinding:0.3.0'
-    compile 'com.squareup.retrofit:retrofit:1.9.0'
+    implementation 'io.reactivex:rxandroid:1.1.0'
+    implementation 'io.reactivex:rxjava:1.1.0'
+    implementation 'com.jakewharton.rxbinding:rxbinding:0.3.0'
+    implementation 'com.squareup.retrofit:retrofit:1.9.0'
 }
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
index a15da443ce..2059678cff 100644
--- a/examples/secureTokenAndroidKeyStore/build.gradle
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -24,13 +24,13 @@ android {
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
         exclude group: 'com.android.support', module: 'support-annotations'
     })
-    compile 'com.android.support:appcompat-v7:25.2.0'
-    testCompile 'junit:junit:4.12'
-    compile 'io.realm:secure-userstore:1.0.1'
+    implementation 'com.android.support:appcompat-v7:25.2.0'
+    testImplementation 'junit:junit:4.12'
+    implementation 'io.realm:secure-userstore:1.0.1'
 }
 
 realm {
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index 98ec9f1827..5ebeb267a5 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -25,5 +25,5 @@ android {
 
 dependencies {
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:24.0.0'
+    implementation 'com.android.support:appcompat-v7:24.0.0'
 }
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index 79231649c1..2270fa1ab0 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -30,23 +30,23 @@ android {
 
 
 dependencies {
-    testCompile 'io.reactivex:rxjava:1.1.0'
+    testImplementation 'io.reactivex:rxjava:1.1.0'
 
     // Testing
-    testCompile 'junit:junit:4.12'
-    testCompile "org.robolectric:robolectric:3.3.2"
-    testCompile "org.mockito:mockito-core:1.10.19"
-    testCompile 'org.robolectric:shadows-support-v4:3.0'
+    testImplementation 'junit:junit:4.12'
+    testImplementation "org.robolectric:robolectric:3.3.2"
+    testImplementation "org.mockito:mockito-core:1.10.19"
+    testImplementation 'org.robolectric:shadows-support-v4:3.0'
 
-    testCompile "org.powermock:powermock-module-junit4-rule:1.6.5"
-    testCompile "org.powermock:powermock-module-junit4:1.6.5"
-    testCompile "org.powermock:powermock-api-mockito:1.6.5"
-    testCompile "org.powermock:powermock-classloading-xstream:1.6.5"
+    testImplementation "org.powermock:powermock-module-junit4:1.6.5"
+    testImplementation "org.powermock:powermock-module-junit4-rule:1.6.5"
+    testImplementation "org.powermock:powermock-api-mockito:1.6.5"
+    testImplementation "org.powermock:powermock-classloading-xstream:1.6.5"
 
 
-    androidTestCompile 'com.android.support.test:runner:0.5'
+    androidTestImplementation 'com.android.support.test:runner:0.5'
     // Set this dependency to use JUnit 4 rules
-    androidTestCompile 'com.android.support.test:rules:0.5'
+    androidTestImplementation 'com.android.support.test:rules:0.5'
     // Set this dependency to build and run Espresso tests
-    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'
 }
diff --git a/gradle-plugin/gradle.properties b/gradle-plugin/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/gradle-plugin/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 43bf3f89cd..6a24fa434d 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -23,6 +23,7 @@ import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
+import org.gradle.api.artifacts.UnknownConfigurationException
 
 class Realm implements Plugin<Project> {
 
@@ -40,7 +41,8 @@ class Realm implements Plugin<Project> {
         }
 
         def syncEnabledDefault = false
-        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault)
+        def dependencyConfigurationName = getDependencyConfigurationName(project)
+        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault, dependencyConfigurationName)
 
         def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
         def isKotlinProject = project.plugins.findPlugin('kotlin-android') != null
@@ -57,7 +59,7 @@ class Realm implements Plugin<Project> {
         project.android.registerTransform(new RealmTransformer(project))
 
         project.repositories.add(project.getRepositories().jcenter())
-        project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
+        project.dependencies.add(dependencyConfigurationName, "io.realm:realm-annotations:${Version.VERSION}")
         if (usesAptPlugin) {
             project.dependencies.add("apt", "io.realm:realm-annotations-processor:${Version.VERSION}")
             project.dependencies.add("androidTestApt", "io.realm:realm-annotations-processor:${Version.VERSION}")
@@ -80,6 +82,22 @@ class Realm implements Plugin<Project> {
         }
     }
 
+    private static String getDependencyConfigurationName(Project project) {
+        /*
+         * Dependency configuration name for android gradle plugin 3.0.0-*.
+         * We need to use 'api' instead of 'implementation' since user's model class
+         * might be using Realm's classes and annotations.
+         */
+        def newDependencyName = "api"
+        def oldDependencyName = "compile"
+        try {
+            project.getConfigurations().getByName(newDependencyName)
+            return newDependencyName
+        } catch (UnknownConfigurationException ignored) {
+            oldDependencyName
+        }
+    }
+
     private static boolean shouldApplyAndroidAptPlugin(boolean usesAptPlugin, boolean isKotlinProject,
                                                        boolean hasAnnotationProcessorConfiguration,
                                                        boolean preferAptOnKotlinProject) {
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
index ac2fc4012a..42bd8e5f39 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
@@ -21,9 +21,11 @@ import org.gradle.api.Project
 class RealmPluginExtension {
     private Project project
     def boolean syncEnabled
+    private String dependencyConfigurationName
 
-    RealmPluginExtension(Project project, boolean syncEnabledDefault) {
+    RealmPluginExtension(Project project, boolean syncEnabledDefault, String dependencyConfigurationName) {
         this.project = project
+        this.dependencyConfigurationName = dependencyConfigurationName
         setSyncEnabled(syncEnabledDefault)
     }
 
@@ -31,7 +33,7 @@ class RealmPluginExtension {
         this.syncEnabled = value;
 
         // remove realm android library first
-        def iterator = project.getConfigurations().getByName("compile").getDependencies().iterator();
+        def iterator = project.getConfigurations().getByName(dependencyConfigurationName).getDependencies().iterator();
         while (iterator.hasNext()) {
             def item = iterator.next()
             if (item.group == 'io.realm' && item.name.startsWith('realm-android-library')) {
@@ -41,6 +43,6 @@ class RealmPluginExtension {
 
         // then add again
         def artifactName = "realm-android-library${syncEnabled ? '-object-server' : ''}"
-        project.dependencies.add("compile", "io.realm:${artifactName}:${Version.VERSION}")
+        project.dependencies.add(dependencyConfigurationName, "io.realm:${artifactName}:${Version.VERSION}")
     }
 }
diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
index e185b78386..38703ec6b9 100644
--- a/library-benchmarks/build.gradle
+++ b/library-benchmarks/build.gradle
@@ -1,10 +1,11 @@
 buildscript {
     repositories {
         mavenLocal()
+        google()
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.2'
+        classpath 'com.android.tools.build:gradle:3.0.0-alpha4'
         classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
     }
 }
@@ -26,7 +27,7 @@ apply plugin: 'realm-android'
 
 android {
     compileSdkVersion 25
-    buildToolsVersion "25.0.3"
+    buildToolsVersion "26.0.0"
 
     defaultConfig {
         minSdkVersion 15
@@ -47,14 +48,15 @@ android {
 
 repositories {
     mavenLocal()
+    google()
     jcenter()
 }
 
 dependencies {
-    androidTestCompile 'com.android.support.test:runner:0.5'
-    androidTestCompile 'com.android.support.test:rules:0.5'
-    androidTestCompile 'junit:junit:4.12'
-    androidTestCompile 'dk.ilios:spanner:0.6.0'
-    androidTestCompile 'com.opencsv:opencsv:3.4'
-    androidTestCompile 'junit:junit:4.12'
-}
\ No newline at end of file
+    androidTestImplementation 'com.android.support.test:runner:0.5'
+    androidTestImplementation 'com.android.support.test:rules:0.5'
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation 'dk.ilios:spanner:0.6.0'
+    androidTestImplementation 'com.opencsv:opencsv:3.4'
+    androidTestImplementation 'junit:junit:4.12'
+}
diff --git a/realm-annotations/gradle.properties b/realm-annotations/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/realm-annotations/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/realm-transformer/gradle.properties b/realm-transformer/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/realm-transformer/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index b02d1a637b..bd99fb271d 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -66,6 +66,7 @@ class RealmTransformer extends Transform {
 
     @Override
     Set<Scope> getReferencedScopes() {
+        // Scope.PROJECT_LOCAL_DEPS and Scope.SUB_PROJECTS_LOCAL_DEPS is only for compatibility with AGP 1.x, 2.x
         return Sets.immutableEnumSet(Scope.EXTERNAL_LIBRARIES, Scope.PROJECT_LOCAL_DEPS,
                 Scope.SUB_PROJECTS, Scope.SUB_PROJECTS_LOCAL_DEPS, Scope.TESTED_CODE)
     }
diff --git a/realm/build.gradle b/realm/build.gradle
index eed959332f..37a4993710 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -2,13 +2,14 @@ buildscript {
     ext.kotlin_version = '1.1.2-5'
     repositories {
         mavenLocal()
+        google()
         jcenter()
         maven { url 'https://jitpack.io' }
         maven { url "https://plugins.gradle.org/m2/" }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.android.tools.build:gradle:3.0.0-alpha4'
         classpath 'de.undercouch:gradle-download-task:3.1.1'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
@@ -33,6 +34,7 @@ allprojects {
     version = file("${rootDir}/../version.txt").text.trim();
     repositories {
         mavenLocal()
+        google()
         jcenter()
     }
 }
diff --git a/realm/gradle.properties b/realm/gradle.properties
index f3f16fcaac..0be17a49db 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1 +1,2 @@
 org.gradle.jvmargs=-Xms512m -Xmx2048m
+org.gradle.caching=true
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index bc16c86a53..0e68b14d0c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -51,6 +51,8 @@
             "io.realm.internal.ColumnInfo",
             "io.realm.internal.LinkView",
             "io.realm.internal.OsObject",
+            "io.realm.internal.OsObjectSchemaInfo",
+            "io.realm.internal.Property",
             "io.realm.internal.RealmObjectProxy",
             "io.realm.internal.Row",
             "io.realm.internal.SharedRealm",
@@ -132,7 +134,8 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitInjectContextMethod(writer);
         emitPersistedFieldAccessors(writer);
         emitBacklinkFieldAccessors(writer);
-        emitCreateRealmObjectSchemaMethod(writer);
+        emitCreateExpectedObjectSchemaInfo(writer);
+        emitGetExpectedObjectSchemaInfo(writer);
         emitValidateTableMethod(writer);
         emitGetTableNameMethod(writer);
         emitGetFieldNamesMethod(writer);
@@ -227,7 +230,11 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
 
     private void emitClassFields(JavaWriter writer) throws IOException {
         writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
-                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
+                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE))
+                .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
+                        EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL),
+                        "createExpectedObjectSchemaInfo()");
+
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
@@ -606,23 +613,18 @@ private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOExce
     }
     //@formatter:on
 
-    private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOException {
+    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "RealmObjectSchema", // Return type
-                "createRealmObjectSchema", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "RealmSchema", "realmSchema"); // Argument type & argument name
+                "OsObjectSchemaInfo", // Return type
+                "createExpectedObjectSchemaInfo", // Method name
+                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers
 
-        writer.beginControlFlow("if (realmSchema.contains(\"%s\"))", this.simpleClassName)
-            .emitStatement("return realmSchema.get(\"%s\")", this.simpleClassName)
-            .endControlFlow();
-
-        writer.emitStatement("RealmObjectSchema realmObjectSchema = realmSchema.create(\"%s\")", this.simpleClassName);
+        writer.emitStatement(
+                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\")", this.simpleClassName);
 
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
             Constants.RealmFieldType fieldType = getRealmType(field);
             switch (fieldType) {
@@ -631,27 +633,22 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                     break;
 
                 case OBJECT:
-                    writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
-                            .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
-                            .endControlFlow()
-                            .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\"))",
-                                    fieldName, fieldTypeSimpleName);
+                    String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
+                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
+                            fieldName, fieldTypeSimpleName);
                     break;
 
                 case LIST:
                     String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                    writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName + "\"))")
-                            .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
-                            .endControlFlow()
-                            .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\"))",
-                                    fieldName, genericTypeSimpleName);
+                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
+                            fieldName, genericTypeSimpleName);
                     break;
 
                 default:
                     String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                     String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                     String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                    writer.emitStatement("realmObjectSchema.add(\"%s\", %s, %s, %s, %s)",
+                    writer.emitStatement("builder.addProperty(\"%s\", %s, %s, %s, %s)",
                             fieldName,
                             fieldType.getRealmType(),
                             primaryKeyFlag,
@@ -659,7 +656,19 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                             nullableFlag);
             }
         }
-        writer.emitStatement("return realmObjectSchema");
+        writer.emitStatement("return builder.build()");
+        writer.endMethod()
+                .emitEmptyLine();
+    }
+
+    private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "OsObjectSchemaInfo", // Return type
+                "getExpectedObjectSchemaInfo", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers
+
+        writer.emitStatement(" return expectedObjectSchemaInfo");
+
         writer.endMethod()
                 .emitEmptyLine();
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 65f4e7a843..bd3b75d5b5 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -80,7 +80,7 @@ public void generate() throws IOException {
                 "io.realm.internal.RealmProxyMediator",
                 "io.realm.internal.Row",
                 "io.realm.internal.Table",
-                "io.realm.RealmObjectSchema",
+                "io.realm.internal.OsObjectSchemaInfo",
                 "org.json.JSONException",
                 "org.json.JSONObject"
         );
@@ -96,7 +96,7 @@ public void generate() throws IOException {
         writer.emitEmptyLine();
 
         emitFields(writer);
-        emitCreateRealmObjectSchema(writer);
+        emitGetExpectedObjectSchemaInfoMap(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitGetTableNameMethod(writer);
@@ -126,20 +126,22 @@ private void emitFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitCreateRealmObjectSchema(JavaWriter writer) throws IOException {
+    private void emitGetExpectedObjectSchemaInfoMap(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "RealmObjectSchema",
-                "createRealmObjectSchema",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "RealmSchema", "realmSchema"
-        );
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.createRealmObjectSchema(realmSchema)", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
+                "Map<Class<? extends RealmModel>, OsObjectSchemaInfo>",
+                "getExpectedObjectSchemaInfoMap",
+                EnumSet.of(Modifier.PUBLIC));
+
+        writer.emitStatement(
+                "Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = " +
+                        "new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>()");
+        for (int i = 0; i < qualifiedProxyClasses.size(); i++) {
+            writer.emitStatement("infoMap.put(%s.class, %s.getExpectedObjectSchemaInfo())",
+                    qualifiedModelClasses.get(i), qualifiedProxyClasses.get(i));
+        }
+        writer.emitStatement("return infoMap");
+
         writer.endMethod();
         writer.emitEmptyLine();
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 7e51275132..22dc82ea71 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -9,6 +9,8 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.Property;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -85,6 +87,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private AllTypesColumnInfo columnInfo;
     private ProxyState<some.test.AllTypes> proxyState;
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
     private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
     private static final List<String> FIELD_NAMES;
@@ -397,27 +400,22 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         return parentObjectsBacklinks;
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (realmSchema.contains("AllTypes")) {
-            return realmSchema.get("AllTypes");
-        }
-        RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
-        realmObjectSchema.add("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        if (!realmSchema.contains("AllTypes")) {
-            AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        }
-        realmObjectSchema.add("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes"));
-        if (!realmSchema.contains("AllTypes")) {
-            AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        }
-        realmObjectSchema.add("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes"));
-        return realmObjectSchema;
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes");
+        builder.addProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addLinkedProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
+        builder.addLinkedProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
     }
 
     public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 04b7de7941..4248632d3d 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -9,6 +9,8 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.Property;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -68,6 +70,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private BooleansColumnInfo columnInfo;
     private ProxyState<some.test.Booleans> proxyState;
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -184,16 +187,17 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         proxyState.getRow$realm().setBoolean(columnInfo.anotherBooleanIndex, value);
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (realmSchema.contains("Booleans")) {
-            return realmSchema.get("Booleans");
-        }
-        RealmObjectSchema realmObjectSchema = realmSchema.create("Booleans");
-        realmObjectSchema.add("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        return realmObjectSchema;
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Booleans");
+        builder.addProperty("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
     }
 
     public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index c90fd7dfcc..f7395470d9 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -9,6 +9,8 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.Property;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -119,6 +121,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private NullTypesColumnInfo columnInfo;
     private ProxyState<some.test.NullTypes> proxyState;
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -819,36 +822,34 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (realmSchema.contains("NullTypes")) {
-            return realmSchema.get("NullTypes");
-        }
-        RealmObjectSchema realmObjectSchema = realmSchema.create("NullTypes");
-        realmObjectSchema.add("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        realmObjectSchema.add("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        if (!realmSchema.contains("NullTypes")) {
-            NullTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        }
-        realmObjectSchema.add("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes"));
-        return realmObjectSchema;
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("NullTypes");
+        builder.addProperty("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addProperty("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addLinkedProperty("fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
     }
 
     public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 4460594efa..3c3f0c02b1 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -2,8 +2,8 @@
 
 
 import android.util.JsonReader;
-import io.realm.RealmObjectSchema;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
@@ -32,13 +32,11 @@
     }
 
     @Override
-    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
-        checkClass(clazz);
-
-        if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        }
-        throw getMissingProxyClassException(clazz);
+    public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                    new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        infoMap.put(some.test.AllTypes.class, io.realm.AllTypesRealmProxy.getExpectedObjectSchemaInfo());
+        return infoMap;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index f8ff4c3b6f..f7c85cb206 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -9,6 +9,8 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.LinkView;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.Property;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -62,6 +64,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
     private SimpleColumnInfo columnInfo;
     private ProxyState<some.test.Simple> proxyState;
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -140,14 +143,15 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         proxyState.getRow$realm().setLong(columnInfo.ageIndex, value);
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (realmSchema.contains("Simple")) {
-            return realmSchema.get("Simple");
-        }
-        RealmObjectSchema realmObjectSchema = realmSchema.create("Simple");
-        realmObjectSchema.add("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-        realmObjectSchema.add("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-        return realmObjectSchema;
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Simple");
+        builder.addProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addProperty("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
     }
 
     public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 01283a6b7a..f1e2dfedde 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -38,7 +38,7 @@ ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE
 
 android {
     compileSdkVersion 25
-    buildToolsVersion '25.0.3'
+    buildToolsVersion '26.0.0'
 
     defaultConfig {
         minSdkVersion 9
@@ -111,8 +111,11 @@ android {
         abortOnError false
     }
 
+   flavorDimensions 'api'
+
     productFlavors {
         base {
+            dimension 'api'
             externalNativeBuild {
                 cmake {
                     arguments "-DREALM_FLAVOR=base"
@@ -121,6 +124,7 @@ android {
             consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-base.pro'
         }
         objectServer {
+            dimension 'api'
             externalNativeBuild {
                 cmake {
                     arguments "-DREALM_FLAVOR=objectServer"
@@ -159,26 +163,26 @@ repositories {
 
 dependencies {
 
-    provided 'io.reactivex:rxjava:1.1.0'
-    provided 'com.google.code.findbugs:findbugs-annotations:3.0.1'
+    compileOnly 'io.reactivex:rxjava:1.1.0'
+    compileOnly 'com.google.code.findbugs:findbugs-annotations:3.0.1'
 
-    compile "io.realm:realm-annotations:${version}"
-    compile 'com.getkeepsafe.relinker:relinker:1.2.2'
+    api "io.realm:realm-annotations:${version}"
+    implementation 'com.getkeepsafe.relinker:relinker:1.2.2'
 
     kaptObjectServer project(':realm-annotations-processor')
-    objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
+    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.4.1'
 
     kaptAndroidTest project(':realm-annotations-processor')
-    androidTestCompile fileTree(dir: 'testLibs', include: ['*.jar'])
-    androidTestCompile 'io.reactivex:rxjava:1.1.0'
-    androidTestCompile 'com.android.support:support-annotations:25.3.1'
-    androidTestCompile 'com.android.support.test:runner:0.5'
-    androidTestCompile 'com.android.support.test:rules:0.5'
-    androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
-    androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
-    androidTestCompile "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
-    androidTestCompile "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
+    androidTestImplementation fileTree(dir: 'testLibs', include: ['*.jar'])
+    androidTestImplementation 'io.reactivex:rxjava:1.1.0'
+    androidTestImplementation 'com.android.support:support-annotations:25.3.1'
+    androidTestImplementation 'com.android.support.test:runner:0.5'
+    androidTestImplementation 'com.android.support.test:rules:0.5'
+    androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
+    androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestImplementation 'org.hamcrest:hamcrest-library:1.3'
+    androidTestImplementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
+    androidTestImplementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
 }
 
 task sourcesJar(type: Jar) {
@@ -360,7 +364,7 @@ publishing {
             artifact sourcesJar
             artifact javadocJar
 
-            pom.withXml(createPomDependencies(["baseCompile", "compile"]))
+            pom.withXml(createPomDependencies(["baseImplementation", "implementation", "baseApi", "api"]))
         }
 
         objectServerPublication(MavenPublication) {
@@ -371,7 +375,7 @@ publishing {
             artifact sourcesJar
             artifact javadocJar
 
-            pom.withXml(createPomDependencies(["objectServerCompile", "compile"]))
+            pom.withXml(createPomDependencies(["objectServerImplementation", "implementation", "objectServerApi", "api"]))
         }
     }
     repositories {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
index 1d231e4d23..39c5d346b2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -85,7 +85,7 @@ public void linkingObjects_classIsNull() throws Exception {
             object.linkingObjects(null, AllJavaTypes.FIELD_INT);
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals(StandardRealmSchema.EMPTY_STRING_MSG, expected.getMessage());
+            assertEquals(RealmSchema.EMPTY_STRING_MSG, expected.getMessage());
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index f5ecd5cd4d..5166f24a4a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -262,18 +262,15 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
         }
     }
 
+    // Only Dog is included in the schema definition, but in order to create Dog, the Owner has to be defined as well.
     @Test
-    public void customSchemaDontIncludeLinkedClasses() {
+    public void schemaDoesNotContainAllDefinedObjectShouldThrow() {
         RealmConfiguration config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
                 .schema(Dog.class)
                 .build();
+        thrown.expect(IllegalStateException.class);
         realm = Realm.getInstance(config);
-        try {
-            assertEquals(3, realm.getTable(Owner.class).getColumnCount());
-            fail("Owner should to be part of the schema");
-        } catch (IllegalArgumentException ignored) {
-        }
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index b5ac52a1d5..425fafa499 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -888,7 +888,7 @@ public void getFieldIndex() {
         RealmConfiguration emptyConfig = configFactory.createConfiguration("empty");
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(emptyConfig);
         dynamicRealm.beginTransaction();
-        StandardRealmObjectSchema objectSchema = (StandardRealmObjectSchema) dynamicRealm.getSchema().create(className);
+        RealmObjectSchema objectSchema = dynamicRealm.getSchema().create(className);
 
         assertTrue(objectSchema.getFieldIndex(fieldName) < 0);
 
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 11c3d43caf..3d7e3159a5 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -40,8 +40,8 @@ set(classes_LIST
     io.realm.internal.Table io.realm.internal.CheckedRow
     io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
-    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.OsRealmSchema
-    io.realm.OsRealmObjectSchema io.realm.internal.Collection
+    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.internal.Property io.realm.internal.OsSchemaInfo
+    io.realm.internal.OsObjectSchemaInfo io.realm.internal.Collection
     io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
     io.realm.internal.OsObject
 )
diff --git a/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
similarity index 71%
rename from realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
index c3a954c8f1..52f1efd343 100644
--- a/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <jni.h>
-#include "io_realm_OsRealmObjectSchema.h"
+#include "io_realm_internal_OsObjectSchemaInfo.h"
 
 #include <object-store/src/object_schema.hpp>
 #include <object-store/src/property.hpp>
@@ -23,7 +23,13 @@
 #include "util.hpp"
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_OsRealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
+static void finalize_object_schema(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<ObjectSchema*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
                                                                                         jstring className_)
 {
     TR_ENTER()
@@ -37,18 +43,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_OsRealmObjectSchema_nativeCreateRealmObjec
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
-    TR_ENTER_PTR(native_ptr)
-    try {
-        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
-        delete object_schema;
-    }
-    CATCH_STD()
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_object_schema);
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
                                                                          jlong property_ptr)
 {
     TR_ENTER_PTR(native_ptr)
@@ -63,7 +65,7 @@ JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeAddProperty(JNIEn
     CATCH_STD()
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_OsRealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     try {
diff --git a/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
similarity index 69%
rename from realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
index 20a4852a05..f52e15831f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
@@ -15,18 +15,24 @@
  */
 
 #include <jni.h>
-#include "io_realm_OsRealmSchema.h"
+#include "io_realm_internal_OsSchemaInfo.h"
 
 #include <object-store/src/schema.hpp>
 #include <object-store/src/object_schema.hpp>
 #include <object-store/src/property.hpp>
 
 #include "util.hpp"
+
 using namespace realm;
 
+static void finalize_schema(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<Schema*>(ptr);
+}
 
-JNIEXPORT jlong JNICALL Java_io_realm_OsRealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
-                                                                       jlongArray objectSchemaPtrs_)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeCreateFromList(JNIEnv* env, jclass,
+                                                                                 jlongArray objectSchemaPtrs_)
 {
     TR_ENTER()
     try {
@@ -35,16 +41,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_OsRealmSchema_nativeCreateFromList(JNIEnv*
         for (jsize i = 0; i < array.len(); ++i) {
             object_schemas.push_back(*reinterpret_cast<ObjectSchema*>(array[i]));
         }
-        auto* schema = new Schema(object_schemas);
+        auto* schema = new Schema(std::move(object_schemas));
         return reinterpret_cast<jlong>(schema);
     }
     CATCH_STD()
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_OsRealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
-    TR_ENTER_PTR(nativePtr)
-    Schema* schema = reinterpret_cast<Schema*>(nativePtr);
-    delete schema;
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_schema);
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
similarity index 80%
rename from realm/realm-library/src/main/cpp/io_realm_Property.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
index 38e9dff137..48f58c7c31 100644
--- a/realm/realm-library/src/main/cpp/io_realm_Property.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <jni.h>
-#include "io_realm_Property.h"
+#include "io_realm_internal_Property.h"
 
 #include <stdexcept>
 #include <object-store/src/property.hpp>
@@ -25,7 +25,13 @@
 
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(
+static void finalize_property(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<Property*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(
     JNIEnv* env, jclass, jstring name_, jint type, jboolean is_primary, jboolean is_indexed, jboolean is_nullable)
 {
     TR_ENTER()
@@ -48,7 +54,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(
     JNIEnv* env, jclass, jstring name_, jint type, jstring linkedToName_)
 {
     TR_ENTER()
@@ -63,12 +69,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_Property_nativeClose(JNIEnv* env, jclass, jlong property_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
-    TR_ENTER_PTR(property_ptr)
-    try {
-        Property* property = reinterpret_cast<Property*>(property_ptr);
-        delete property;
-    }
-    CATCH_STD()
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_property);
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index 56746a003f..ed674b6c3a 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -1573,50 +1573,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* en
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup(
-    JNIEnv* env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
-{
-    TR_ENTER_PTR(handoverPtr)
-    SharedGroup::Handover<Row>* handoverRowPtr = HO(Row, handoverPtr);
-    std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
-
-    try {
-        // import_from_handover will free (delete) the handover
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
-        if (!sharedRealm->is_closed()) {
-            using rf = realm::_impl::RealmFriend;
-            auto row = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverRow));
-            return reinterpret_cast<jlong>(row.release());
-        }
-        else {
-            ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
-        }
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery(JNIEnv* env, jobject,
-                                                                              jlong bgSharedRealmPtr,
-                                                                              jlong nativeQueryPtr)
-{
-    TR_ENTER_PTR(nativeQueryPtr)
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery)) {
-        return 0;
-    }
-    try {
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-        using rf = realm::_impl::RealmFriend;
-        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(*pQuery, ConstSourcePayload::Copy);
-        return reinterpret_cast<jlong>(handover.release());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
                                                                          jlongArray columnIndexes,
                                                                          jlongArray tablePointers)
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 383cf39c5c..8679a02d05 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -98,7 +98,7 @@ public void onSchemaVersionChanged(long currentVersion) {
                                 }
                             }
                         }, true);
-        this.schema = new StandardRealmSchema(this);
+        this.schema = new RealmSchema(this);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
deleted file mode 100644
index 8da935e7a6..0000000000
--- a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import java.util.Set;
-
-import io.realm.internal.Table;
-
-
-class OsRealmObjectSchema extends RealmObjectSchema {
-    private long nativePtr;
-
-    /**
-     * Creates a schema object using object store. This constructor is intended to be used by
-     * the validation of schema, object schemas and properties through the object store. Even though the constructor
-     * is public, there is never a purpose which justifies calling it!
-     *
-     * @param schema The parent for this schema: the schema to which this object belongs
-     * @param className name of the class
-     */
-    OsRealmObjectSchema(RealmSchema schema, String className) {
-        this(schema, nativeCreateRealmObjectSchema(className));
-    }
-
-    private OsRealmObjectSchema(RealmSchema schema, long nativePtr) {
-        super(schema);
-        this.nativePtr = nativePtr;
-    }
-
-    @Override
-    public void close() {
-        if (nativePtr != 0L) {
-            nativeClose(nativePtr);
-            nativePtr = 0L;
-        }
-    }
-
-    @Override
-    public String getClassName() {
-        return nativeGetClassName(nativePtr);
-    }
-
-    @Override
-    public OsRealmObjectSchema setClassName(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema removeField(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean hasField(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean hasIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema removeIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addPrimaryKey(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema removePrimaryKey() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema setRequired(String fieldName, boolean required) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema setNullable(String fieldName, boolean nullable) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isRequired(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isNullable(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isPrimaryKey(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean hasPrimaryKey() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public String getPrimaryKey() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Set<String> getFieldNames() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema transform(Function function) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public RealmFieldType getFieldType(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    OsRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
-        final Property property = new Property(name, type, primary, indexed, required);
-        try {
-            nativeAddProperty(nativePtr, property.getNativePtr());
-        } finally {
-            property.close();
-        }
-        return this;
-    }
-
-    @Override
-    OsRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        final Property property = new Property(name, type, linkedTo);
-        try {
-            nativeAddProperty(nativePtr, property.getNativePtr());
-        } finally {
-            property.close();
-        }
-        return this;
-    }
-
-    @Override
-    Table getTable() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    long getAndCheckFieldIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    long getNativePtr() {
-        return nativePtr;
-    }
-
-    static native long nativeCreateRealmObjectSchema(String className);
-
-    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
-
-    static native void nativeClose(long nativePtr);
-
-    static native String nativeGetClassName(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
deleted file mode 100644
index f047e5ec8d..0000000000
--- a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.realm.internal.Table;
-
-
-/**
- * Class for interacting with the Realm schema using a dynamic API. This makes it possible
- * to add, delete and change the classes in the Realm.
- * <p>
- * All changes must happen inside a write transaction for the particular Realm.
- *
- * @see RealmMigration
- */
-class OsRealmSchema extends RealmSchema {
-    static final class Creator extends RealmSchema {
-        private final Map<String, OsRealmObjectSchema> schema = new HashMap<>();
-
-        @Override
-        public void close() {
-            for (Map.Entry<String, OsRealmObjectSchema> entry : schema.entrySet()) {
-                entry.getValue().close();
-            }
-            schema.clear();
-        }
-
-        @Override
-        public RealmObjectSchema get(String className) {
-            checkEmpty(className);
-            return (!contains(className)) ? null : schema.get(className);
-        }
-
-        @Override
-        public Set<RealmObjectSchema> getAll() {
-            return new LinkedHashSet<RealmObjectSchema>(schema.values());
-        }
-
-        @Override
-        public RealmObjectSchema create(String className) {
-            checkEmpty(className);
-            OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(this, className);
-            schema.put(className, realmObjectSchema);
-            return realmObjectSchema;
-        }
-
-        @Override
-        public boolean contains(String className) {
-            return schema.containsKey(className);
-        }
-
-        @Override
-        Table getTable(Class<? extends RealmModel> clazz) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        Table getTable(String className) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        OsRealmObjectSchema getSchemaForClass(String className) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public void remove(String className) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public RealmObjectSchema rename(String oldClassName, String newClassName) {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
-
-    private long nativePtr;
-
-    // TODO:
-    // Because making getAll return Set<? Extends RealmObjectSchema> is a breaking change
-    // Creator.getAll must return Set<RealmObjectSchema> instead of Set<? extends RealmObjectSchema>
-    // That necessitates the cast inside the loop below.
-    OsRealmSchema(Creator creator) {
-        Set<RealmObjectSchema> realmObjectSchemas = creator.getAll();
-        long[] schemaNativePointers = new long[realmObjectSchemas.size()];
-        int i = 0;
-        for (RealmObjectSchema schema : realmObjectSchemas) {
-            schemaNativePointers[i++] = ((OsRealmObjectSchema) schema).getNativePtr();
-        }
-        this.nativePtr = nativeCreateFromList(schemaNativePointers);
-    }
-
-    public long getNativePtr() {
-        return this.nativePtr;
-    }
-
-    // See BaseRealm uses a StandardRealmSchema, not a OsRealmSchema.
-    @Override
-    public void close() {
-        if (nativePtr != 0L) {
-            nativeClose(nativePtr);
-            nativePtr = 0L;
-        }
-    }
-
-    /**
-     * Returns the Realm schema for a given class.
-     *
-     * @param className name of the class
-     * @return schema object for that class or {@code null} if the class doesn't exists.
-     */
-    @Override
-    public RealmObjectSchema get(String className) {
-        checkEmpty(className);
-        return (!contains(className)) ? null : dynamicClassToSchema.get(className);
-    }
-
-    /**
-     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
-     *
-     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
-     */
-    @Override
-    public Set<RealmObjectSchema> getAll() {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Adds a new class to the Realm.
-     *
-     * @param className name of the class.
-     * @return a Realm schema object for that class.
-     */
-    @Override
-    public RealmObjectSchema create(String className) {
-        // Adding a class is always permitted.
-        checkEmpty(className);
-        OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(this, className);
-        dynamicClassToSchema.put(className, realmObjectSchema);
-        return realmObjectSchema;
-    }
-
-    @Override
-    public void remove(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Checks if a given class already exists in the schema.
-     *
-     * @param className class name to check.
-     * @return {@code true} if the class already exists. {@code false} otherwise.
-     */
-    @Override
-    public boolean contains(String className) {
-        return dynamicClassToSchema.containsKey(className);
-    }
-
-    @Override
-    Table getTable(Class<? extends RealmModel> clazz) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    Table getTable(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    OsRealmObjectSchema getSchemaForClass(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    private static void checkEmpty(String str) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException("Null or empty class names are not allowed");
-        }
-    }
-
-    static native long nativeCreateFromList(long[] objectSchemaPtrs);
-
-    static native void nativeClose(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 263bfe9311..f8357eb3c7 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -53,6 +53,7 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsObject;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
@@ -419,11 +420,7 @@ private static Realm createAndValidateFromCache(RealmCache cache) {
 
             // Initializes Realm schema if needed.
             try {
-                if (!syncingConfig) {
-                    initializeRealm(realm);
-                } else {
-                    initializeSyncedRealm(realm);
-                }
+                initializeRealm(realm);
             } catch (RuntimeException e) {
                 realm.doClose();
                 throw e;
@@ -443,23 +440,34 @@ private static void initializeRealm(Realm realm) {
             // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
             // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
             realm.beginTransaction(true);
+            RealmConfiguration configuration = realm.getConfiguration();
             long currentVersion = realm.getVersion();
             boolean unversioned = currentVersion == UNVERSIONED;
-            commitChanges = unversioned;
+            long newVersion = configuration.getSchemaVersion();
 
-            RealmConfiguration configuration = realm.getConfiguration();
             RealmProxyMediator mediator = configuration.getSchemaMediator();
             Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
-            // Only allow creating the schema if not in read-only mode
-            if (unversioned) {
-                if (configuration.isReadOnly()) {
-                    throw new IllegalArgumentException("Cannot create the Realm schema in a read-only file.");
+            if (configuration.isSyncConfiguration()) {
+                // Update/create the schema if allowed
+                if (!configuration.isReadOnly()) {
+                    OsSchemaInfo schema = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
+
+                    // Object Store handles all update logic
+                    realm.sharedRealm.updateSchema(schema, newVersion);
+                    commitChanges = true;
                 }
-                realm.setVersion(configuration.getSchemaVersion());
-                // Create all of the tables.
-                for (Class<? extends RealmModel> modelClass : modelClasses) {
-                    mediator.createRealmObjectSchema(modelClass, realm.getSchema());
+            } else {
+                // Only allow creating the schema if not in read-only mode
+                if (unversioned) {
+                    if (configuration.isReadOnly()) {
+                        throw new IllegalArgumentException("Cannot create the Realm schema in a read-only file.");
+                    }
+
+                    // Let Object Store initialize all tables
+                    OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
+                    realm.sharedRealm.updateSchema(schemaInfo, newVersion);
+                    commitChanges = true;
                 }
             }
 
@@ -468,11 +476,13 @@ private static void initializeRealm(Realm realm) {
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 String className = Table.getClassNameForTable(mediator.getTableName(modelClass));
                 Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(modelClass, className);
-                columnInfoMap.put(key, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                // More fields in the Realm than defined is allowed for synced Realm.
+                columnInfoMap.put(key, mediator.validateTable(modelClass, realm.sharedRealm,
+                        configuration.isSyncConfiguration()));
             }
 
             realm.getSchema().setInitialColumnIndices(
-                    (unversioned) ? configuration.getSchemaVersion() : currentVersion,
+                    (unversioned) ? newVersion : currentVersion,
                     columnInfoMap);
 
             // Finally add any initial data
@@ -492,78 +502,6 @@ private static void initializeRealm(Realm realm) {
         }
     }
 
-    // Everything in this method needs to be behind a transaction lock
-    // to prevent multi-process interaction while the Realm is initialized.
-    private static void initializeSyncedRealm(Realm realm) {
-        boolean commitChanges = false;
-        OsRealmSchema schema = null;
-        OsRealmSchema.Creator schemaCreator = null;
-        try {
-            // We need to start a transaction no matter readOnly mode, because it acts as an interprocess lock.
-            // TODO: For proper inter-process support we also need to move e.g copying the asset file under an
-            // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
-            // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
-            realm.beginTransaction(true);
-            long currentVersion = realm.getVersion();
-            final boolean unversioned = currentVersion == UNVERSIONED;
-
-            RealmConfiguration configuration = realm.getConfiguration();
-
-            final RealmProxyMediator mediator = configuration.getSchemaMediator();
-            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-
-            long newVersion = configuration.getSchemaVersion();
-
-            // Update/create the schema if allowed
-            if (!configuration.isReadOnly()) {
-                schemaCreator = new OsRealmSchema.Creator();
-                for (Class<? extends RealmModel> modelClass : modelClasses) {
-                    mediator.createRealmObjectSchema(modelClass, schemaCreator);
-                }
-
-                // Assumption: When SyncConfiguration then additive schema update mode.
-                schema = new OsRealmSchema(schemaCreator);
-                schemaCreator.close();
-                schemaCreator = null;
-
-                // Object Store handles all update logic
-                realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
-                commitChanges = true;
-            }
-
-            // Validate the schema in the file
-            final Map<Pair<Class<? extends RealmModel>, String>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                String className = Table.getClassNameForTable(mediator.getTableName(modelClass));
-                Pair<Class<? extends RealmModel>, String> key = Pair.<Class<? extends RealmModel>, String>create(modelClass, className);
-                columnInfoMap.put(key, mediator.validateTable(modelClass, realm.sharedRealm, true));
-            }
-            realm.getSchema().setInitialColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
-
-            if (unversioned && !configuration.isReadOnly()) {
-                final Transaction transaction = configuration.getInitialDataTransaction();
-                if (transaction != null) {
-                    transaction.execute(realm);
-                }
-            }
-        } catch (RuntimeException e) {
-            commitChanges = false;
-            throw e;
-        } finally {
-            if (schemaCreator != null) {
-                schemaCreator.close();
-            }
-            if (schema != null) {
-                schema.close();
-            }
-            if (commitChanges) {
-                realm.commitTransaction();
-            } else {
-                realm.cancelTransaction();
-            }
-        }
-    }
-
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 106d97b4a1..fb6fe89e10 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -16,9 +16,16 @@
  */
 
 
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Locale;
+import java.util.Map;
 import java.util.Set;
 
 import io.realm.annotations.Required;
+import io.realm.internal.ColumnInfo;
 import io.realm.internal.Table;
 import io.realm.internal.fields.FieldDescriptor;
 
@@ -29,23 +36,76 @@
  *
  * @see io.realm.RealmMigration
  */
-public abstract class RealmObjectSchema {
+public class RealmObjectSchema {
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
+        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
+        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
+        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
+        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
+        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
+        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
+        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
+        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
+        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
+        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
+        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
+    }
+
     private final RealmSchema schema;
+    private final BaseRealm realm;
+    private final ColumnInfo columnInfo;
+    private final Table table;
+
+    /**
+     * Creates a dynamic schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     */
+    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table) {
+        this(realm, schema, table, new DynamicColumnIndices(table));
+    }
 
     /**
-     * Create a schema.
+     * Creates a schema object for a given Realm class.
      *
-     * @param schema The parent for this schema: the schema to which this object belongs
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     * @param columnInfo mapping between field names and column indexes for the given table
      */
-    protected RealmObjectSchema(RealmSchema schema) {
+    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
         this.schema = schema;
+        this.realm = realm;
+        this.table = table;
+        this.columnInfo = columnInfo;
     }
 
     /**
      * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
      */
     @Deprecated
-    public abstract void close();
+    public void close() {
+    }
 
     /**
      * Returns the name of the RealmObject class being represented by this schema.
@@ -57,7 +117,9 @@ protected RealmObjectSchema(RealmSchema schema) {
      *
      * @return the name of the RealmObject class represented by this schema.
      */
-    public abstract String getClassName();
+    public String getClassName() {
+        return table.getClassName();
+    }
 
     /**
      * Sets a new name for this RealmObject class. This is equivalent to renaming it.
@@ -65,9 +127,38 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @param className the new name for this class.
      * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
      * characters.
-     * @see StandardRealmSchema#rename(String, String)
+     * @see RealmSchema#rename(String, String)
      */
-    public abstract RealmObjectSchema setClassName(String className);
+    public RealmObjectSchema setClassName(String className) {
+        realm.checkNotInSync(); // renaming a table is not permitted
+        checkEmpty(className);
+        String internalTableName = Table.getTableNameForClass(className);
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
+        }
+        if (realm.sharedRealm.hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        // in case this table has a primary key, we need to transfer it after renaming the table.
+        String oldTableName = null;
+        String pkField = null;
+        if (table.hasPrimaryKey()) {
+            oldTableName = table.getName();
+            pkField = getPrimaryKey();
+            table.setPrimaryKey(null);
+        }
+        realm.sharedRealm.renameTable(table.getName(), internalTableName);
+        if (pkField != null && !pkField.isEmpty()) {
+            try {
+                table.setPrimaryKey(pkField);
+            } catch (Exception e) {
+                // revert the table name back when something goes wrong
+                realm.sharedRealm.renameTable(table.getName(), oldTableName);
+                throw e;
+            }
+        }
+        return this;
+    }
 
     /**
      * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
@@ -85,7 +176,34 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
      * already exists.
      */
-    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);
+    public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
+        if (metadata == null) {
+            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
+                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
+            } else {
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "Realm doesn't support this field type: %s(%s)",
+                        fieldName, fieldType));
+            }
+        }
+
+        checkNewFieldName(fieldName);
+        boolean nullable = metadata.defaultNullable;
+        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
+            nullable = false;
+        }
+
+        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
+        try {
+            addModifiers(fieldName, attributes);
+        } catch (Exception e) {
+            // Modifiers have been removed by the addModifiers method()
+            table.removeColumn(columnIndex);
+            throw e;
+        }
+        return this;
+    }
 
     /**
      * Adds a new field that references another {@link RealmObject}.
@@ -95,7 +213,12 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
      */
-    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);
+    public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
+        return this;
+    }
 
     /**
      * Adds a new field that references a {@link RealmList}.
@@ -105,7 +228,12 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
      */
-    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);
+    public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
+        return this;
+    }
 
     /**
      * Removes a field from the class.
@@ -114,7 +242,19 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist.
      */
-    public abstract RealmObjectSchema removeField(String fieldName);
+    public RealmObjectSchema removeField(String fieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(fieldName);
+        if (!hasField(fieldName)) {
+            throw new IllegalStateException(fieldName + " does not exist.");
+        }
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.getPrimaryKey() == columnIndex) {
+            table.setPrimaryKey(null);
+        }
+        table.removeColumn(columnIndex);
+        return this;
+    }
 
     /**
      * Renames a field from one name to another.
@@ -124,7 +264,19 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
      */
-    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);
+    public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(currentFieldName);
+        checkFieldExists(currentFieldName);
+        checkLegalName(newFieldName);
+        checkFieldNameIsAvailable(newFieldName);
+        long columnIndex = getColumnIndex(currentFieldName);
+        table.renameColumn(columnIndex, newFieldName);
+
+        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
+
+        return this;
+    }
 
     /**
      * Tests if the class has field defined with the given name.
@@ -132,7 +284,9 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @param fieldName field name to test.
      * @return {@code true} if the field exists, {@code false} otherwise.
      */
-    public abstract boolean hasField(String fieldName);
+    public boolean hasField(String fieldName) {
+        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
+    }
 
     /**
      * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
@@ -143,7 +297,16 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
      * index defined.
      */
-    public abstract RealmObjectSchema addIndex(String fieldName);
+    public RealmObjectSchema addIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException(fieldName + " already has an index.");
+        }
+        table.addSearchIndex(columnIndex);
+        return this;
+    }
 
     /**
      * Checks if a given field has an index defined.
@@ -153,7 +316,11 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see io.realm.annotations.Index
      */
-    public abstract boolean hasIndex(String fieldName);
+    public boolean hasIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        return table.hasSearchIndex(table.getColumnIndex(fieldName));
+    }
 
     /**
      * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
@@ -162,7 +329,17 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
      */
-    public abstract RealmObjectSchema removeIndex(String fieldName);
+    public RealmObjectSchema removeIndex(String fieldName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException("Field is not indexed: " + fieldName);
+        }
+        table.removeSearchIndex(columnIndex);
+        return this;
+    }
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
@@ -174,7 +351,20 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
      * has a primary key defined.
      */
-    public abstract RealmObjectSchema addPrimaryKey(String fieldName);
+    public RealmObjectSchema addPrimaryKey(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        if (table.hasPrimaryKey()) {
+            throw new IllegalStateException("A primary key is already defined");
+        }
+        table.setPrimaryKey(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
+        return this;
+    }
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
@@ -184,7 +374,18 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
      */
-    public abstract RealmObjectSchema removePrimaryKey();
+    public RealmObjectSchema removePrimaryKey() {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        long columnIndex = table.getPrimaryKey();
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
+        table.setPrimaryKey("");
+        return this;
+    }
 
     /**
      * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
@@ -197,7 +398,31 @@ protected RealmObjectSchema(RealmSchema schema) {
      * the field already have been set as required.
      * @see Required
      */
-    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);
+    public RealmObjectSchema setRequired(String fieldName, boolean required) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        boolean currentColumnRequired = isRequired(fieldName);
+        RealmFieldType type = table.getColumnType(columnIndex);
+
+        if (type == RealmFieldType.OBJECT) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
+        }
+        if (type == RealmFieldType.LIST) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
+        }
+        if (required && currentColumnRequired) {
+            throw new IllegalStateException("Field is already required: " + fieldName);
+        }
+        if (!required && !currentColumnRequired) {
+            throw new IllegalStateException("Field is already nullable: " + fieldName);
+        }
+
+        if (required) {
+            table.convertColumnToNotNullable(columnIndex);
+        } else {
+            table.convertColumnToNullable(columnIndex);
+        }
+        return this;
+    }
 
     /**
      * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
@@ -208,7 +433,10 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
      */
-    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);
+    public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        setRequired(fieldName, !nullable);
+        return this;
+    }
 
     /**
      * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
@@ -218,7 +446,10 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setRequired(String, boolean)
      */
-    public abstract boolean isRequired(String fieldName);
+    public boolean isRequired(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return !table.isColumnNullable(columnIndex);
+    }
 
     /**
      * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
@@ -228,7 +459,10 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setNullable(String, boolean)
      */
-    public abstract boolean isNullable(String fieldName);
+    public boolean isNullable(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.isColumnNullable(columnIndex);
+    }
 
     /**
      * Checks if a given field is the primary key field.
@@ -238,7 +472,10 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #addPrimaryKey(String)
      */
-    public abstract boolean isPrimaryKey(String fieldName);
+    public boolean isPrimaryKey(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return columnIndex == table.getPrimaryKey();
+    }
 
     /**
      * Checks if the class has a primary key defined.
@@ -246,7 +483,9 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return {@code true} if a primary key is defined, {@code false} otherwise.
      * @see io.realm.annotations.PrimaryKey
      */
-    public abstract boolean hasPrimaryKey();
+    public boolean hasPrimaryKey() {
+        return table.hasPrimaryKey();
+    }
 
     /**
      * Returns the name of the primary key field.
@@ -254,14 +493,26 @@ protected RealmObjectSchema(RealmSchema schema) {
      * @return the name of the primary key field.
      * @throws IllegalStateException if the class doesn't have a primary key defined.
      */
-    public abstract String getPrimaryKey();
+    public String getPrimaryKey() {
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        return table.getColumnName(table.getPrimaryKey());
+    }
 
     /**
      * Returns all fields in this class.
      *
      * @return a list of all the fields in this class.
      */
-    public abstract Set<String> getFieldNames();
+    public Set<String> getFieldNames() {
+        int columnCount = (int) table.getColumnCount();
+        Set<String> columnNames = new LinkedHashSet<>(columnCount);
+        for (int i = 0; i < columnCount; i++) {
+            columnNames.add(table.getColumnName(i));
+        }
+        return columnNames;
+    }
 
     /**
      * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
@@ -269,14 +520,26 @@ protected RealmObjectSchema(RealmSchema schema) {
      *
      * @return this schema.
      */
-    public abstract RealmObjectSchema transform(Function function);
+    public RealmObjectSchema transform(Function function) {
+        if (function != null) {
+            long size = table.size();
+            for (long i = 0; i < size; i++) {
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
+            }
+        }
+
+        return this;
+    }
 
     /**
      * Returns the type used by the underlying storage engine to represent this field.
      *
      * @return the underlying type used by Realm to represent this field.
      */
-    public abstract RealmFieldType getFieldType(String fieldName);
+    public RealmFieldType getFieldType(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.getColumnType(columnIndex);
+    }
 
     /**
      * Get a parser for a field descriptor.
@@ -289,13 +552,35 @@ protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmF
         return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
     }
 
-    abstract RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required);
+    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
+        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
 
-    abstract RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo);
+        if (indexed) { table.addSearchIndex(columnIndex); }
 
-    abstract long getAndCheckFieldIndex(String fieldName);
+        if (primary) { table.setPrimaryKey(name); }
 
-    abstract Table getTable();
+        return this;
+    }
+
+    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        table.addColumnLink(
+                type,
+                name,
+                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
+        return this;
+    }
+
+    long getAndCheckFieldIndex(String fieldName) {
+        long index = columnInfo.getColumnIndex(fieldName);
+        if (index < 0) {
+            throw new IllegalArgumentException("Field does not exist: " + fieldName);
+        }
+        return index;
+    }
+
+    Table getTable() {
+        return table;
+    }
 
     private SchemaConnector getSchemaConnector() {
         return new SchemaConnector(schema);
@@ -309,4 +594,151 @@ private SchemaConnector getSchemaConnector() {
     public interface Function {
         void apply(DynamicRealmObject obj);
     }
+
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     * <b>FOR TESTING USE ONLY!</b>
+     *
+     * @param fieldName field name to find index for.
+     * @return column index or -1 if it doesn't exists.
+     */
+    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    long getFieldIndex(String fieldName) {
+        return columnInfo.getColumnIndex(fieldName);
+    }
+
+    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
+    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
+        boolean indexAdded = false;
+        try {
+            if (attributes != null && attributes.length > 0) {
+                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
+                    addIndex(fieldName);
+                    indexAdded = true;
+                }
+
+                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
+                    addPrimaryKey(fieldName);
+                    indexAdded = true;
+                }
+
+                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
+            }
+        } catch (Exception e) {
+            // If something went wrong, revert all attributes.
+            long columnIndex = getColumnIndex(fieldName);
+            if (indexAdded) {
+                table.removeSearchIndex(columnIndex);
+            }
+            throw (RuntimeException) e;
+        }
+    }
+
+    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
+        if (attributeList == null || attributeList.length == 0) {
+            return false;
+        }
+        for (FieldAttribute anAttributeList : attributeList) {
+            if (anAttributeList == attribute) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void checkNewFieldName(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+    }
+
+    private void checkLegalName(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Field name can not be null or empty");
+        }
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Field name can not contain '.'");
+        }
+    }
+
+    private void checkFieldNameIsAvailable(String fieldName) {
+        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private void checkFieldExists(String fieldName) {
+        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private long getColumnIndex(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex == -1) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US,
+                            "Field name '%s' does not exist on schema for '%s'",
+                            fieldName, getClassName()
+                    ));
+        }
+        return columnIndex;
+    }
+
+    private void checkEmpty(String str) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    private static final class DynamicColumnIndices extends ColumnInfo {
+        private final Table table;
+
+        DynamicColumnIndices(Table table) {
+            super(null, false);
+            this.table = table;
+        }
+
+        @Override
+        public long getColumnIndex(String columnName) {
+            return table.getColumnIndex(columnName);
+        }
+
+        @Override
+        public RealmFieldType getColumnType(String columnName) {
+            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
+        }
+
+        @Override
+        public String getLinkedTable(String columnName) {
+            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
+        }
+
+        @Override
+        public void copyFrom(ColumnInfo src) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
+        }
+
+        @Override
+        protected ColumnInfo copy(boolean immutable) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
+        }
+
+
+        @Override
+        protected void copy(ColumnInfo src, ColumnInfo dst) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
+        }
+    }
+
+    // Tuple containing data about each supported Java type.
+    private static final class FieldMetaData {
+        final RealmFieldType realmType;
+        final boolean defaultNullable;
+
+        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
+            this.realmType = realmType;
+            this.defaultNullable = defaultNullable;
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 17049602d4..d7096b3fbf 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -16,12 +16,15 @@
 
 package io.realm;
 
+import java.util.HashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.Table;
+import io.realm.internal.Util;
 import io.realm.internal.util.Pair;
 
 
@@ -33,14 +36,35 @@
  *
  * @see RealmMigration
  */
-public abstract class RealmSchema {
-    private ColumnIndices columnIndices; // Cached field look up
+public class RealmSchema {
+    static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+
+    // Caches Dynamic Class objects given as Strings to Realm Tables
+    private final Map<String, Table> dynamicClassToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to their Schema object
+    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<>();
+    // Caches Class Strings to their Schema object
+    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+
+    private final BaseRealm realm;
+    // Cached field look up
+    private ColumnIndices columnIndices;
+
+    /**
+     * Creates a wrapper to easily manipulate the current schema of a Realm.
+     */
+    RealmSchema(BaseRealm realm) {
+        this.realm = realm;
+    }
 
     /**
      * @deprecated {@link RealmSchema} doesn't have to be released manually.
      */
     @Deprecated
-    public abstract void close();
+    public void close() {
+    }
 
     /**
      * Returns the Realm schema for a given class.
@@ -48,14 +72,32 @@
      * @param className name of the class
      * @return schema object for that class or {@code null} if the class doesn't exists.
      */
-    public abstract RealmObjectSchema get(String className);
+    public RealmObjectSchema get(String className) {
+        checkEmpty(className, EMPTY_STRING_MSG);
+
+        String internalClassName = Table.getTableNameForClass(className);
+        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
+        Table table = realm.getSharedRealm().getTable(internalClassName);
+        return new RealmObjectSchema(realm, this, table);
+    }
 
     /**
      * Returns the {@link RealmObjectSchema}s for all RealmObject classes that can be saved in this Realm.
      *
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
-    public abstract Set<RealmObjectSchema> getAll();
+    public Set<RealmObjectSchema> getAll() {
+        int tableCount = (int) realm.getSharedRealm().size();
+        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+        for (int i = 0; i < tableCount; i++) {
+            String tableName = realm.getSharedRealm().getTableName(i);
+            if (!Table.isModelTable(tableName)) {
+                continue;
+            }
+            schemas.add(new RealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName)));
+        }
+        return schemas;
+    }
 
     /**
      * Adds a new class to the Realm.
@@ -63,7 +105,16 @@
      * @param className name of the class.
      * @return a Realm schema object for that class.
      */
-    public abstract RealmObjectSchema create(String className);
+    public RealmObjectSchema create(String className) {
+        // Adding a class is always permitted.
+        checkEmpty(className, EMPTY_STRING_MSG);
+
+        String internalTableName = Table.getTableNameForClass(className);
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
+        }
+        return new RealmObjectSchema(realm, this, realm.getSharedRealm().createTable(internalTableName));
+    }
 
     /**
      * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
@@ -71,7 +122,17 @@
      *
      * @param className name of the class to remove.
      */
-    public abstract void remove(String className);
+    public void remove(String className) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkEmpty(className, EMPTY_STRING_MSG);
+        String internalTableName = Table.getTableNameForClass(className);
+        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
+        Table table = getTable(className);
+        if (table.hasPrimaryKey()) {
+            table.setPrimaryKey(null);
+        }
+        realm.getSharedRealm().removeTable(internalTableName);
+    }
 
     /**
      * Renames a class already in the Realm.
@@ -80,7 +141,35 @@
      * @param newClassName new class name.
      * @return a schema object for renamed class.
      */
-    public abstract RealmObjectSchema rename(String oldClassName, String newClassName);
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkEmpty(oldClassName, "Class names cannot be empty or null");
+        checkEmpty(newClassName, "Class names cannot be empty or null");
+        String oldInternalName = Table.getTableNameForClass(oldClassName);
+        String newInternalName = Table.getTableNameForClass(newClassName);
+        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
+        if (realm.getSharedRealm().hasTable(newInternalName)) {
+            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
+        }
+
+        // Checks if there is a primary key defined for the old class.
+        Table oldTable = getTable(oldClassName);
+        String pkField = null;
+        if (oldTable.hasPrimaryKey()) {
+            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
+            oldTable.setPrimaryKey(null);
+        }
+
+        realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
+        Table table = realm.getSharedRealm().getTable(newInternalName);
+
+        // Sets the primary key for the new class if necessary.
+        if (pkField != null) {
+            table.setPrimaryKey(pkField);
+        }
+
+        return new RealmObjectSchema(realm, this, table);
+    }
 
     /**
      * Checks if a given class already exists in the schema.
@@ -88,15 +177,89 @@
      * @param className class name to check.
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
-    public abstract boolean contains(String className);
+    public boolean contains(String className) {
+        return realm.getSharedRealm().hasTable(Table.getTableNameForClass(className));
+    }
+
+    private void checkEmpty(String str, String error) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException(error);
+        }
+    }
+
+    private void checkHasTable(String className, String errorMsg) {
+        String internalTableName = Table.getTableNameForClass(className);
+        if (!realm.getSharedRealm().hasTable(internalTableName)) {
+            throw new IllegalArgumentException(errorMsg);
+        }
+    }
+
+    Table getTable(String className) {
+        String tableName = Table.getTableNameForClass(className);
+        Table table = dynamicClassToTable.get(tableName);
+        if (table != null) { return table; }
+
+        table = realm.getSharedRealm().getTable(tableName);
+        dynamicClassToTable.put(tableName, table);
+
+        return table;
+    }
+
+    Table getTable(Class<? extends RealmModel> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table != null) { return table; }
 
-    abstract Table getTable(Class<? extends RealmModel> clazz);
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            table = classToTable.get(originalClass);
+        }
+        if (table == null) {
+            table = realm.getSharedRealm().getTable(realm.getConfiguration().getSchemaMediator().getTableName(originalClass));
+            classToTable.put(originalClass, table);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToTable.put(clazz, table);
+        }
+
+        return table;
+    }
+
+    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        RealmObjectSchema classSchema = classToSchema.get(clazz);
+        if (classSchema != null) { return classSchema; }
 
-    abstract Table getTable(String className);
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            classSchema = classToSchema.get(originalClass);
+        }
+        if (classSchema == null) {
+            Table table = getTable(clazz);
+            classSchema = new RealmObjectSchema(realm, this, table, getColumnInfo(originalClass));
+            classToSchema.put(originalClass, classSchema);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToSchema.put(clazz, classSchema);
+        }
 
-    abstract RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz);
+        return classSchema;
+    }
 
-    abstract RealmObjectSchema getSchemaForClass(String className);
+    RealmObjectSchema getSchemaForClass(String className) {
+        String tableName = Table.getTableNameForClass(className);
+        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(tableName);
+        if (dynamicSchema == null) {
+            if (!realm.getSharedRealm().hasTable(tableName)) {
+                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+            }
+            dynamicSchema = new RealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName));
+            dynamicClassToSchema.put(tableName, dynamicSchema);
+        }
+        return dynamicSchema;
+    }
 
     /**
      * Set the column index cache for this schema.
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
deleted file mode 100644
index e22f77351e..0000000000
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
+++ /dev/null
@@ -1,747 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-
-import io.realm.annotations.Required;
-import io.realm.internal.ColumnInfo;
-import io.realm.internal.Table;
-
-
-class StandardRealmObjectSchema extends RealmObjectSchema {
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
-
-    static {
-        Map<Class<?>, FieldMetaData> m = new HashMap<>();
-        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
-        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
-        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
-        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
-        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
-        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
-        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
-        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
-        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
-        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
-    }
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
-
-    static {
-        Map<Class<?>, FieldMetaData> m = new HashMap<>();
-        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
-        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
-        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
-    }
-
-    private final BaseRealm realm;
-    private final ColumnInfo columnInfo;
-    private final Table table;
-
-    /**
-     * Creates a dynamic schema object for a given Realm class.
-     *
-     * @param realm Realm holding the objects.
-     * @param table table representation of the Realm class
-     */
-    StandardRealmObjectSchema(BaseRealm realm, StandardRealmSchema schema, Table table) {
-        this(realm, schema, table, new StandardRealmObjectSchema.DynamicColumnIndices(table));
-    }
-
-    /**
-     * Creates a schema object for a given Realm class.
-     *
-     * @param realm Realm holding the objects.
-     * @param table table representation of the Realm class
-     * @param columnInfo mapping between field names and column indexes for the given table
-     */
-    StandardRealmObjectSchema(BaseRealm realm, StandardRealmSchema schema, Table table, ColumnInfo columnInfo) {
-        super(schema);
-        this.realm = realm;
-        this.table = table;
-        this.columnInfo = columnInfo;
-    }
-
-    /**
-     * There are no resources here that need closing.
-     */
-    @Override
-    public void close() { }
-
-    /**
-     * Returns the name of the RealmObject class being represented by this schema.
-     * <p>
-     * <ul>
-     * <li>When using a typed {@link Realm} this name is the same as the {@link RealmObject} class.</li>
-     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
-     * </ul>
-     *
-     * @return the name of the RealmObject class represented by this schema.
-     */
-    @Override
-    public String getClassName() {
-        return table.getClassName();
-    }
-
-    /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
-     * {@link StandardRealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
-     *
-     * @param className the new name for this class.
-     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
-     * characters.
-     * @see StandardRealmSchema#rename(String, String)
-     */
-    @Override
-    public StandardRealmObjectSchema setClassName(String className) {
-        realm.checkNotInSync(); // renaming a table is not permitted
-        checkEmpty(className);
-        String internalTableName = Table.getTableNameForClass(className);
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
-        }
-        if (realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
-        }
-        // in case this table has a primary key, we need to transfer it after renaming the table.
-        String oldTableName = null;
-        String pkField = null;
-        if (table.hasPrimaryKey()) {
-            oldTableName = table.getName();
-            pkField = getPrimaryKey();
-            table.setPrimaryKey(null);
-        }
-        realm.sharedRealm.renameTable(table.getName(), internalTableName);
-        if (pkField != null && !pkField.isEmpty()) {
-            try {
-                table.setPrimaryKey(pkField);
-            } catch (Exception e) {
-                // revert the table name back when something goes wrong
-                realm.sharedRealm.renameTable(table.getName(), oldTableName);
-                throw e;
-            }
-        }
-        return this;
-    }
-
-    /**
-     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
-     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
-     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
-     * <p>
-     * To add fields that reference other RealmObjects or RealmLists use
-     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
-     * instead.
-     *
-     * @param fieldName name of the field to add.
-     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
-     * @param attributes set of attributes for this field.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
-     * already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
-        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
-        if (metadata == null) {
-            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
-                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
-            } else {
-                throw new IllegalArgumentException(String.format(Locale.US,
-                        "Realm doesn't support this field type: %s(%s)",
-                        fieldName, fieldType));
-            }
-        }
-
-        checkNewFieldName(fieldName);
-        boolean nullable = metadata.defaultNullable;
-        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
-            nullable = false;
-        }
-
-        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
-        try {
-            addModifiers(fieldName, attributes);
-        } catch (Exception e) {
-            // Modifiers have been removed by the addModifiers method()
-            table.removeColumn(columnIndex);
-            throw e;
-        }
-        return this;
-    }
-
-    /**
-     * Adds a new field that references another {@link RealmObject}.
-     *
-     * @param fieldName name of the field to add.
-     * @param objectSchema schema for the Realm type being referenced.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
-        return this;
-    }
-
-    /**
-     * Adds a new field that references a {@link RealmList}.
-     *
-     * @param fieldName name of the field to add.
-     * @param objectSchema schema for the Realm type being referenced.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
-        return this;
-    }
-
-    /**
-     * Removes a field from the class.
-     *
-     * @param fieldName field name to remove.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     */
-    @Override
-    public StandardRealmObjectSchema removeField(String fieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(fieldName);
-        if (!hasField(fieldName)) {
-            throw new IllegalStateException(fieldName + " does not exist.");
-        }
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.getPrimaryKey() == columnIndex) {
-            table.setPrimaryKey(null);
-        }
-        table.removeColumn(columnIndex);
-        return this;
-    }
-
-    /**
-     * Renames a field from one name to another.
-     *
-     * @param currentFieldName field name to rename.
-     * @param newFieldName the new field name.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(currentFieldName);
-        checkFieldExists(currentFieldName);
-        checkLegalName(newFieldName);
-        checkFieldNameIsAvailable(newFieldName);
-        long columnIndex = getColumnIndex(currentFieldName);
-        table.renameColumn(columnIndex, newFieldName);
-
-        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
-
-        return this;
-    }
-
-    /**
-     * Tests if the class has field defined with the given name.
-     *
-     * @param fieldName field name to test.
-     * @return {@code true} if the field exists, {@code false} otherwise.
-     */
-    @Override
-    public boolean hasField(String fieldName) {
-        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
-    }
-
-    /**
-     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
-     * annotation on the field.
-     *
-     * @param fieldName field to add index to.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
-     * index defined.
-     */
-    @Override
-    public StandardRealmObjectSchema addIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException(fieldName + " already has an index.");
-        }
-        table.addSearchIndex(columnIndex);
-        return this;
-    }
-
-    /**
-     * Checks if a given field has an index defined.
-     *
-     * @param fieldName existing field name to check.
-     * @return {@code true} if field is indexed, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see io.realm.annotations.Index
-     */
-    @Override
-    public boolean hasIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        return table.hasSearchIndex(table.getColumnIndex(fieldName));
-    }
-
-
-    /**
-     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
-     *
-     * @param fieldName field to remove index from.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
-     */
-    @Override
-    public StandardRealmObjectSchema removeIndex(String fieldName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException("Field is not indexed: " + fieldName);
-        }
-        table.removeSearchIndex(columnIndex);
-        return this;
-    }
-
-    /**
-     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
-     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
-     * as well.
-     *
-     * @param fieldName field to set as primary key.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
-     * has a primary key defined.
-     */
-    @Override
-    public StandardRealmObjectSchema addPrimaryKey(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        if (table.hasPrimaryKey()) {
-            throw new IllegalStateException("A primary key is already defined");
-        }
-        table.setPrimaryKey(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            // No exception will be thrown since adding PrimaryKey implies the column has an index.
-            table.addSearchIndex(columnIndex);
-        }
-        return this;
-    }
-
-    /**
-     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
-     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
-     * the field as well.
-     *
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
-     */
-    @Override
-    public StandardRealmObjectSchema removePrimaryKey() {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        long columnIndex = table.getPrimaryKey();
-        if (table.hasSearchIndex(columnIndex)) {
-            table.removeSearchIndex(columnIndex);
-        }
-        table.setPrimaryKey("");
-        return this;
-    }
-
-    /**
-     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
-     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
-     *
-     * @param fieldName name of field in the class.
-     * @param required {@code true} if field should be required, {@code false} otherwise.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
-     * the field already have been set as required.
-     * @see Required
-     */
-    @Override
-    public StandardRealmObjectSchema setRequired(String fieldName, boolean required) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        boolean currentColumnRequired = isRequired(fieldName);
-        RealmFieldType type = table.getColumnType(columnIndex);
-
-        if (type == RealmFieldType.OBJECT) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
-        }
-        if (type == RealmFieldType.LIST) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
-        }
-        if (required && currentColumnRequired) {
-            throw new IllegalStateException("Field is already required: " + fieldName);
-        }
-        if (!required && !currentColumnRequired) {
-            throw new IllegalStateException("Field is already nullable: " + fieldName);
-        }
-
-        if (required) {
-            table.convertColumnToNotNullable(columnIndex);
-        } else {
-            table.convertColumnToNullable(columnIndex);
-        }
-        return this;
-    }
-
-    /**
-     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
-     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
-     *
-     * @param fieldName name of field in the class.
-     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
-     */
-    @Override
-    public StandardRealmObjectSchema setNullable(String fieldName, boolean nullable) {
-        setRequired(fieldName, !nullable);
-        return this;
-    }
-
-    /**
-     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
-     *
-     * @param fieldName field to check.
-     * @return {@code true} if it is required, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see #setRequired(String, boolean)
-     */
-    @Override
-    public boolean isRequired(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return !table.isColumnNullable(columnIndex);
-    }
-
-    /**
-     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
-     *
-     * @param fieldName field to check.
-     * @return {@code true} if it is required, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see #setNullable(String, boolean)
-     */
-    @Override
-    public boolean isNullable(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.isColumnNullable(columnIndex);
-    }
-
-    /**
-     * Checks if a given field is the primary key field.
-     *
-     * @param fieldName field to check.
-     * @return {@code true} if it is the primary key field, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see #addPrimaryKey(String)
-     */
-    @Override
-    public boolean isPrimaryKey(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return columnIndex == table.getPrimaryKey();
-    }
-
-    /**
-     * Checks if the class has a primary key defined.
-     *
-     * @return {@code true} if a primary key is defined, {@code false} otherwise.
-     * @see io.realm.annotations.PrimaryKey
-     */
-    @Override
-    public boolean hasPrimaryKey() {
-        return table.hasPrimaryKey();
-    }
-
-    /**
-     * Returns the name of the primary key field.
-     *
-     * @return the name of the primary key field.
-     * @throws IllegalStateException if the class doesn't have a primary key defined.
-     */
-    @Override
-    public String getPrimaryKey() {
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        return table.getColumnName(table.getPrimaryKey());
-    }
-
-    /**
-     * Returns all fields in this class.
-     *
-     * @return a list of all the fields in this class.
-     */
-    @Override
-    public Set<String> getFieldNames() {
-        int columnCount = (int) table.getColumnCount();
-        Set<String> columnNames = new LinkedHashSet<>(columnCount);
-        for (int i = 0; i < columnCount; i++) {
-            columnNames.add(table.getColumnName(i));
-        }
-        return columnNames;
-    }
-
-    /**
-     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
-     * as a {@link DynamicRealmObject}.
-     *
-     * @return this schema.
-     */
-    @Override
-    public StandardRealmObjectSchema transform(Function function) {
-        if (function != null) {
-            long size = table.size();
-            for (long i = 0; i < size; i++) {
-                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
-            }
-        }
-
-        return this;
-    }
-
-    /**
-     * Returns the type used by the underlying storage engine to represent this field.
-     *
-     * @return the underlying type used by Realm to represent this field.
-     */
-    @Override
-    public RealmFieldType getFieldType(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.getColumnType(columnIndex);
-    }
-
-    @Override
-    Table getTable() {
-        return table;
-    }
-
-    @Override
-    StandardRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
-        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
-
-        if (indexed) { table.addSearchIndex(columnIndex); }
-
-        if (primary) { table.setPrimaryKey(name); }
-
-        return this;
-    }
-
-    @Override
-    StandardRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        table.addColumnLink(
-                type,
-                name,
-                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
-        return this;
-    }
-
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index.
-     * @throws IllegalArgumentException if the field does not exists.
-     */
-    @Override
-    long getAndCheckFieldIndex(String fieldName) {
-        long index = columnInfo.getColumnIndex(fieldName);
-        if (index < 0) {
-            throw new IllegalArgumentException("Field does not exist: " + fieldName);
-        }
-        return index;
-    }
-
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     * <b>FOR TESTING USE ONLY!</b>
-     *
-     * @param fieldName field name to find index for.
-     * @return column index or -1 if it doesn't exists.
-     */
-    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
-    long getFieldIndex(String fieldName) {
-        return columnInfo.getColumnIndex(fieldName);
-    }
-
-    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
-    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
-        boolean indexAdded = false;
-        try {
-            if (attributes != null && attributes.length > 0) {
-                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
-                }
-
-                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
-                    addPrimaryKey(fieldName);
-                    indexAdded = true;
-                }
-
-                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
-            }
-        } catch (Exception e) {
-            // If something went wrong, revert all attributes.
-            long columnIndex = getColumnIndex(fieldName);
-            if (indexAdded) {
-                table.removeSearchIndex(columnIndex);
-            }
-            throw (RuntimeException) e;
-        }
-    }
-
-    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
-        if (attributeList == null || attributeList.length == 0) {
-            return false;
-        }
-        for (int i = 0; i < attributeList.length; i++) {
-            if (attributeList[i] == attribute) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void checkNewFieldName(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-    }
-
-    private void checkLegalName(String fieldName) {
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Field name can not be null or empty");
-        }
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Field name can not contain '.'");
-        }
-    }
-
-    private void checkFieldNameIsAvailable(String fieldName) {
-        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private void checkFieldExists(String fieldName) {
-        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private long getColumnIndex(String fieldName) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex == -1) {
-            throw new IllegalArgumentException(
-                    String.format(Locale.US,
-                            "Field name '%s' does not exist on schema for '%s'",
-                            fieldName, getClassName()
-                    ));
-        }
-        return columnIndex;
-    }
-
-    private void checkEmpty(String str) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException("Null or empty class names are not allowed");
-        }
-    }
-
-    private static final class DynamicColumnIndices extends ColumnInfo {
-        private final Table table;
-
-        DynamicColumnIndices(Table table) {
-            super(null, false);
-            this.table = table;
-        }
-
-        @Override
-        public long getColumnIndex(String columnName) {
-            return table.getColumnIndex(columnName);
-        }
-
-        @Override
-        public RealmFieldType getColumnType(String columnName) {
-            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
-        }
-
-        @Override
-        public String getLinkedTable(String columnName) {
-            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
-        }
-
-        @Override
-        public void copyFrom(ColumnInfo src) {
-            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
-        }
-
-        @Override
-        protected ColumnInfo copy(boolean immutable) {
-            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
-        }
-
-
-        @Override
-        protected void copy(ColumnInfo src, ColumnInfo dst) {
-            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
-        }
-    }
-
-    // Tuple containing data about each supported Java type.
-    private static final class FieldMetaData {
-        final RealmFieldType realmType;
-        final boolean defaultNullable;
-
-        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
-            this.realmType = realmType;
-            this.defaultNullable = defaultNullable;
-        }
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
deleted file mode 100644
index e0bbcb7a75..0000000000
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.realm.internal.Table;
-import io.realm.internal.Util;
-
-
-/**
- * Class for interacting with the Realm schema using a dynamic API. This makes it possible
- * to add, delete and change the classes in the Realm.
- * <p>
- * All changes must happen inside a write transaction for the particular Realm.
- *
- * @see io.realm.RealmMigration
- */
-class StandardRealmSchema extends RealmSchema {
-    public static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
-
-    // Caches Dynamic Class objects given as Strings to Realm Tables
-    private final Map<String, Table> dynamicClassToTable = new HashMap<>();
-    // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
-    // Caches Class objects (both model classes and proxy classes) to their Schema object
-    private final Map<Class<? extends RealmModel>, StandardRealmObjectSchema> classToSchema = new HashMap<>();
-    // Caches Class Strings to their Schema object
-    private final Map<String, StandardRealmObjectSchema> dynamicClassToSchema = new HashMap<>();
-
-    private final BaseRealm realm;
-
-    /**
-     * Creates a wrapper to easily manipulate the current schema of a Realm.
-     */
-    StandardRealmSchema(BaseRealm realm) {
-        this.realm = realm;
-    }
-
-    @Override
-    public void close() { }
-
-    /**
-     * Returns the Realm schema for a given class.
-     *
-     * @param className name of the class
-     * @return schema object for that class or {@code null} if the class doesn't exists.
-     */
-    @Override
-    public RealmObjectSchema get(String className) {
-        checkEmpty(className, EMPTY_STRING_MSG);
-
-        String internalClassName = Table.getTableNameForClass(className);
-        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
-        Table table = realm.getSharedRealm().getTable(internalClassName);
-        return new StandardRealmObjectSchema(realm, this, table);
-    }
-
-    /**
-     * Returns the {@link StandardRealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
-     *
-     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
-     */
-    @Override
-    public Set<RealmObjectSchema> getAll() {
-        int tableCount = (int) realm.getSharedRealm().size();
-        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
-        for (int i = 0; i < tableCount; i++) {
-            String tableName = realm.getSharedRealm().getTableName(i);
-            if (!Table.isModelTable(tableName)) {
-                continue;
-            }
-            schemas.add(new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName)));
-        }
-        return schemas;
-    }
-
-    /**
-     * Adds a new class to the Realm.
-     *
-     * @param className name of the class.
-     * @return a Realm schema object for that class.
-     */
-    @Override
-    public RealmObjectSchema create(String className) {
-        // Adding a class is always permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-
-        String internalTableName = Table.getTableNameForClass(className);
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
-        }
-        return new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().createTable(internalTableName));
-    }
-
-    /**
-     * Checks if a given class already exists in the schema.
-     *
-     * @param className class name to check.
-     * @return {@code true} if the class already exists. {@code false} otherwise.
-     */
-    @Override
-    public boolean contains(String className) {
-        return realm.getSharedRealm().hasTable(Table.getTableNameForClass(className));
-    }
-
-    /**
-     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
-     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
-     *
-     * @param className name of the class to remove.
-     */
-    @Override
-    public void remove(String className) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = Table.getTableNameForClass(className);
-        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
-        Table table = getTable(className);
-        if (table.hasPrimaryKey()) {
-            table.setPrimaryKey(null);
-        }
-        realm.getSharedRealm().removeTable(internalTableName);
-    }
-
-    /**
-     * Renames a class already in the Realm.
-     *
-     * @param oldClassName old class name.
-     * @param newClassName new class name.
-     * @return a schema object for renamed class.
-     */
-    @Override
-    public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(oldClassName, "Class names cannot be empty or null");
-        checkEmpty(newClassName, "Class names cannot be empty or null");
-        String oldInternalName = Table.getTableNameForClass(oldClassName);
-        String newInternalName = Table.getTableNameForClass(newClassName);
-        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
-        if (realm.getSharedRealm().hasTable(newInternalName)) {
-            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
-        }
-
-        // Checks if there is a primary key defined for the old class.
-        Table oldTable = getTable(oldClassName);
-        String pkField = null;
-        if (oldTable.hasPrimaryKey()) {
-            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
-            oldTable.setPrimaryKey(null);
-        }
-
-        realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
-        Table table = realm.getSharedRealm().getTable(newInternalName);
-
-        // Sets the primary key for the new class if necessary.
-        if (pkField != null) {
-            table.setPrimaryKey(pkField);
-        }
-
-        return new StandardRealmObjectSchema(realm, this, table);
-    }
-
-    private void checkEmpty(String str, String error) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException(error);
-        }
-    }
-
-    private void checkHasTable(String className, String errorMsg) {
-        String internalTableName = Table.getTableNameForClass(className);
-        if (!realm.getSharedRealm().hasTable(internalTableName)) {
-            throw new IllegalArgumentException(errorMsg);
-        }
-    }
-
-    @Override
-    Table getTable(String className) {
-        String tableName = Table.getTableNameForClass(className);
-        Table table = dynamicClassToTable.get(tableName);
-        if (table != null) { return table; }
-
-        table = realm.getSharedRealm().getTable(tableName);
-        dynamicClassToTable.put(tableName, table);
-
-        return table;
-    }
-
-    @Override
-    Table getTable(Class<? extends RealmModel> clazz) {
-        Table table = classToTable.get(clazz);
-        if (table != null) { return table; }
-
-        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-        if (isProxyClass(originalClass, clazz)) {
-            // If passed 'clazz' is the proxy, try again with model class.
-            table = classToTable.get(originalClass);
-        }
-        if (table == null) {
-            table = realm.getSharedRealm().getTable(realm.getConfiguration().getSchemaMediator().getTableName(originalClass));
-            classToTable.put(originalClass, table);
-        }
-        if (isProxyClass(originalClass, clazz)) {
-            // 'clazz' is the proxy class for 'originalClass'.
-            classToTable.put(clazz, table);
-        }
-
-        return table;
-    }
-
-    @Override
-    StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        StandardRealmObjectSchema classSchema = classToSchema.get(clazz);
-        if (classSchema != null) { return classSchema; }
-
-        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-        if (isProxyClass(originalClass, clazz)) {
-            // If passed 'clazz' is the proxy, try again with model class.
-            classSchema = classToSchema.get(originalClass);
-        }
-        if (classSchema == null) {
-            Table table = getTable(clazz);
-            classSchema = new StandardRealmObjectSchema(realm, this, table, getColumnInfo(originalClass));
-            classToSchema.put(originalClass, classSchema);
-        }
-        if (isProxyClass(originalClass, clazz)) {
-            // 'clazz' is the proxy class for 'originalClass'.
-            classToSchema.put(clazz, classSchema);
-        }
-
-        return classSchema;
-    }
-
-    @Override
-    StandardRealmObjectSchema getSchemaForClass(String className) {
-        String tableName = Table.getTableNameForClass(className);
-        StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(tableName);
-        if (dynamicSchema == null) {
-            if (!realm.getSharedRealm().hasTable(tableName)) {
-                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-            }
-            dynamicSchema = new StandardRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName));
-            dynamicClassToSchema.put(tableName, dynamicSchema);
-        }
-        return dynamicSchema;
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
new file mode 100644
index 0000000000..55bb98cd7f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+import io.realm.RealmFieldType;
+
+/**
+ * Immutable Java wrapper for Object Store ObjectSchema.
+ *
+ * @see OsSchemaInfo
+ */
+public class OsObjectSchemaInfo implements NativeObject {
+
+    public static class Builder {
+        private String className;
+        private List<Property> propertyList = new ArrayList<Property>();
+
+        /**
+         * Creates an empty builder for {@code OsObjectSchemaInfo}. This constructor is intended to be used by
+         * the validation of schema, object schemas and properties through the object store.
+         *
+         * @param className name of the class
+         */
+        public Builder(String className) {
+            this.className = className;
+        }
+
+        /**
+         * Adds a property to this builder.
+         *
+         * @param name the name of the property.
+         * @param type the type of the property.
+         * @param isPrimaryKey set to true if this property is the primary key.
+         * @param isIndexed set to true if this property needs an index.
+         * @param isRequired set to false if this property is not nullable.
+         * @return this {@code OsObjectSchemaInfo}.
+         */
+        public Builder addProperty(String name, RealmFieldType type, boolean isPrimaryKey, boolean isIndexed,
+                                   boolean isRequired) {
+            final Property property = new Property(name, type, isPrimaryKey, isIndexed, isRequired);
+            propertyList.add(property);
+            return this;
+        }
+
+        /**
+         * Adds a linked property to this {@code OsObjectSchema}.
+         *
+         * @param name the name of the linked property.
+         * @param type the type of the linked property.
+         * @return this {@code OsObjectSchemaInfo}.
+         */
+        public Builder addLinkedProperty(String name, RealmFieldType type, String linkedClassName) {
+            final Property property = new Property(name, type, linkedClassName);
+            propertyList.add(property);
+            return this;
+        }
+
+        public OsObjectSchemaInfo build() {
+            OsObjectSchemaInfo info = new OsObjectSchemaInfo(className);
+            for (Property property : propertyList) {
+                nativeAddProperty(info.nativePtr, property.getNativePtr());
+            }
+
+            return info;
+        }
+    }
+
+    private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    /**
+     * Creates an empty schema object using object store. This constructor is intended to be used by
+     * the validation of schema, object schemas and properties through the object store.
+     *
+     * @param className name of the class
+     */
+    private OsObjectSchemaInfo(String className) {
+        this(nativeCreateRealmObjectSchema(className));
+    }
+
+    /**
+     * Create a java wrapper class for given {@code ObjectSchema} pointer. This java wrapper will take the ownership of
+     * the object's memory and release it through phantom reference.
+     *
+     * @param nativePtr pointer to the {@code ObjectSchema} object.
+     */
+    private OsObjectSchemaInfo(long nativePtr) {
+        this.nativePtr = nativePtr;
+        NativeContext.dummyContext.addReference(this);
+    }
+
+    /**
+     * @return the class name of this {@code OsObjectSchema} represents for.
+     */
+    public String getClassName() {
+        return nativeGetClassName(nativePtr);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    private static native long nativeCreateRealmObjectSchema(String className);
+
+    private static native long nativeGetFinalizerPtr();
+
+    private static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
+
+    private static native String nativeGetClassName(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
new file mode 100644
index 0000000000..f59f750010
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+/**
+ * Java wrapper for the Object Store Schema object.
+ * <p>
+ * When it is created from java binding, it is used for initializing/validating the schemas through Object Store. It
+ * won't contain the column indices information.
+ * <p>
+ * When this is get from the Object Store {@code SharedRealm} instance, this represents the real schema of the Realm
+ * file. It will contain all the schema information as well as the information about the column indices.
+ */
+public class OsSchemaInfo implements NativeObject {
+    private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    /**
+     * Construct a {@code OsSchemaInfo} object from a given {@code OsObjectSchemaInfo} list.
+     *
+     * @param objectSchemaInfoList all the object schemas should be contained in this {@code OsObjectSchemaInfo}.
+     */
+    public OsSchemaInfo(java.util.Collection<OsObjectSchemaInfo> objectSchemaInfoList) {
+        long[] schemaNativePointers = new long[objectSchemaInfoList.size()];
+        int i = 0;
+        for (OsObjectSchemaInfo info : objectSchemaInfoList) {
+            schemaNativePointers[i] = info.getNativePtr();
+            i++;
+        }
+        this.nativePtr = nativeCreateFromList(schemaNativePointers);
+        NativeContext.dummyContext.addReference(this);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    private static native long nativeCreateFromList(long[] objectSchemaPtrs);
+
+    private static native long nativeGetFinalizerPtr();
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Property.java b/realm/realm-library/src/main/java/io/realm/internal/Property.java
similarity index 71%
rename from realm/realm-library/src/main/java/io/realm/Property.java
rename to realm/realm-library/src/main/java/io/realm/internal/Property.java
index 4285be3db5..c2ba207764 100644
--- a/realm/realm-library/src/main/java/io/realm/Property.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Property.java
@@ -14,46 +14,51 @@
  * limitations under the License.
  */
 
-package io.realm;
+package io.realm.internal;
+
+
+import io.realm.RealmFieldType;
 
 
 /**
  * Class for handling properties/fields.
  */
 
-class Property {
+public class Property implements NativeObject {
     public static final boolean PRIMARY_KEY = true;
     public static final boolean REQUIRED = true;
     public static final boolean INDEXED = true;
 
     private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
     Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
         this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), isPrimary, isIndexed, !isRequired);
+        NativeContext.dummyContext.addReference(this);
     }
 
-    Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedTo.getClassName());
+    Property(String name, RealmFieldType type, String linkedClassName) {
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedClassName);
+        NativeContext.dummyContext.addReference(this);
     }
 
     protected Property(long nativePtr) {
         this.nativePtr = nativePtr;
     }
 
-    protected long getNativePtr() {
+    @Override
+    public long getNativePtr() {
         return nativePtr;
     }
 
-    public void close() {
-        if (nativePtr != 0) {
-            nativeClose(nativePtr);
-            nativePtr = 0L;
-        }
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
     }
 
     private static native long nativeCreateProperty(String name, int type, boolean isPrimary, boolean isIndexed, boolean isNullable);
 
     private static native long nativeCreateProperty(String name, int type, String linkedToName);
 
-    private static native void nativeClose(long nativePtr);
+    private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 50c2c72983..bd92154dfb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -29,8 +29,6 @@
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.exceptions.RealmException;
 
 
@@ -46,13 +44,12 @@
 public abstract class RealmProxyMediator {
 
     /**
-     * Creates a object schema for the given RealmObject class.
+     * Returns a map of model classes to their schema information which are defined in this mediator. Classes which have
+     * same class name but in different packages should have different names in the {@code OsObjectSchemaInfo}.
      *
-     * @param clazz the {@link RealmObject} model class to create object schema for.
-     * @param realmSchema the {@link RealmSchema} to associate the object schema with.
-     * @return the object schema.
+     * @return the map with classes and their schema information.
      */
-    public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
+    public abstract Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap();
 
     /**
      * Validates the backing table in Realm for the given RealmObject class.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 98e79f0026..2408560e85 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -366,19 +366,14 @@ public boolean compact() {
     }
 
     /**
-     * Updates the underlying schema based on the schema description.
+     * Initializes the underlying schema based on the schema description.
      * Calling this method must be done from inside a write transaction.
-     * <p>
-     * TODO: This method should not require the caller to get the native pointer.
-     * Instead, the signature should be something like:
-     * public <T extends RealmSchema & NativeObject> </T>void updateSchema(T schema, long version)
-     * ... that is: something that is a schema and that wraps a native object.
      *
-     * @param schemaNativePtr the pointer to a native schema object.
+     * @param schemaInfo the expected schema.
      * @param version the target version.
      */
-    public void updateSchema(long schemaNativePtr, long version) {
-        nativeUpdateSchema(nativePtr, schemaNativePtr, version);
+    public void updateSchema(OsSchemaInfo schemaInfo, long version) {
+        nativeUpdateSchema(nativePtr, schemaInfo.getNativePtr(), version);
     }
 
     public void setAutoRefresh(boolean enabled) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index e953656ce4..92c1725fd4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -417,27 +417,6 @@ public long find() {
         return nativeFind(nativePtr, 0);
     }
 
-    /**
-     * Imports a row from a worker thread to the caller thread.
-     *
-     * @param handoverRowPtr pointer to the handover row object
-     * @param sharedRealm the SharedRealm on the caller thread.
-     * @return the row pointer on the caller thread.
-     */
-    public static long importHandoverRow(long handoverRowPtr, SharedRealm sharedRealm) {
-        return nativeImportHandoverRowIntoSharedGroup(handoverRowPtr, sharedRealm.getNativePtr());
-    }
-
-    /**
-     * Handovers the query, so it can be used by other SharedGroup (in different thread)
-     *
-     * @param sharedRealm the SharedGroup holding the query
-     * @return native pointer to the handover query
-     */
-    public long handoverQuery(SharedRealm sharedRealm) {
-        return nativeHandoverQuery(sharedRealm.getNativePtr(), nativePtr);
-    }
-
     //
     // Aggregation methods
     //
@@ -638,17 +617,6 @@ public long remove() {
         return nativeRemove(nativePtr);
     }
 
-    /**
-     * Converts a list of sort orders to their native values.
-     */
-    public static boolean[] getNativeSortOrderValues(Sort[] sortOrders) {
-        boolean[] nativeValues = new boolean[sortOrders.length];
-        for (int i = 0; i < sortOrders.length; i++) {
-            nativeValues[i] = sortOrders[i].getValue();
-        }
-        return nativeValues;
-    }
-
     private void throwImmutable() {
         throw new IllegalStateException("Mutable method call during read transaction.");
     }
@@ -781,9 +749,5 @@ private void throwImmutable() {
 
     private native long nativeRemove(long nativeQueryPtr);
 
-    private native long nativeHandoverQuery(long callerSharedRealmPtr, long nativeQueryPtr);
-
-    private static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedRealmPtr);
-
     private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 81218ae82e..69bce7a75c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -31,9 +31,8 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
@@ -61,9 +60,13 @@ public CompositeMediator(RealmProxyMediator... mediators) {
     }
 
     @Override
-    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
-        RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.createRealmObjectSchema(clazz, schema);
+    public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        for (RealmProxyMediator mediator : mediators.values()) {
+            infoMap.putAll(mediator.getExpectedObjectSchemaInfoMap());
+        }
+        return infoMap;
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index 3f4f6fa471..5bd26677d4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -24,6 +24,7 @@
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -31,9 +32,8 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
@@ -71,14 +71,17 @@ public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<
         this.allowedClasses = Collections.unmodifiableSet(tempAllowedClasses);
     }
 
-    public RealmProxyMediator getOriginalMediator() {
-        return originalMediator;
-    }
-
     @Override
-    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
-        checkSchemaHasClass(clazz);
-        return originalMediator.createRealmObjectSchema(clazz, schema);
+    public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        for (Map.Entry<Class<? extends RealmModel>, OsObjectSchemaInfo> entry :
+                originalMediator.getExpectedObjectSchemaInfoMap().entrySet()) {
+            if (allowedClasses.contains(entry.getKey())) {
+                infoMap.put(entry.getKey(), entry.getValue());
+            }
+        }
+        return infoMap;
     }
 
     @Override
