diff --git a/dependencies.list b/dependencies.list
index 838c222f42..198c90ffc8 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -5,5 +5,5 @@ REALM_SYNC_SHA256=33c9dace6dc280712101110895d38509bbca74fdb31ba31b61dc0ad383472b
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.0-rc.11
+REALM_OBJECT_SERVER_DE_VERSION=2.0.4
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index d087c59f40..8ab8c830a9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -41,7 +41,7 @@
 import io.realm.entities.Owner;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -99,15 +99,15 @@ public void findFirst() {
 
     @Test
     public void size_returns_Integer_MAX_VALUE_for_huge_results() {
-        final Collection collection = Mockito.mock(Collection.class);
-        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, collection, AllTypes.class);
+        final OsResults osResults = Mockito.mock(OsResults.class);
+        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, osResults, AllTypes.class);
 
-        Mockito.when(collection.isLoaded()).thenReturn(true);
-        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
+        Mockito.when(osResults.isLoaded()).thenReturn(true);
+        Mockito.when(osResults.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
         assertEquals(Integer.MAX_VALUE - 1, targetResult.size());
-        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE));
+        Mockito.when(osResults.size()).thenReturn(((long) Integer.MAX_VALUE));
         assertEquals(Integer.MAX_VALUE, targetResult.size());
-        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
+        Mockito.when(osResults.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
         assertEquals(Integer.MAX_VALUE, targetResult.size());
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index b21e48984a..287d17bf44 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -182,19 +182,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -208,19 +208,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -234,19 +234,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -260,19 +260,19 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 530ca471b2..4ef63520df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -45,7 +45,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.BacklinksSource;
@@ -56,9 +55,8 @@
 import io.realm.entities.PrimaryKeyAsBoxedLong;
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.internal.OsObject;
-import io.realm.internal.OsObjectStore;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmThreadPoolExecutor;
@@ -999,19 +997,19 @@ public static void quitLooperOrFail() {
      * This helper method is useful to create a mocked {@link RealmResults}.
      *
      * @param realm a {@link Realm} or a {@link DynamicRealm} instance.
-     * @param collection a {@link Collection} instance.
+     * @param osResults a {@link OsResults} instance.
      * @param tableClass a Class of Table.
      * @return a created {@link RealmResults} instance.
      */
     public static <T extends RealmObject> RealmResults<T> newRealmResults(
-            BaseRealm realm, Collection collection, Class<T> tableClass) {
+            BaseRealm realm, OsResults osResults, Class<T> tableClass) {
         //noinspection TryWithIdenticalCatches
         try {
             final Constructor<RealmResults> c = RealmResults.class.getDeclaredConstructor(
-                    BaseRealm.class, Collection.class, Class.class);
+                    BaseRealm.class, OsResults.class, Class.class);
             c.setAccessible(true);
             //noinspection unchecked
-            return c.newInstance(realm, collection, tableClass);
+            return c.newInstance(realm, osResults, tableClass);
         } catch (NoSuchMethodException e) {
             throw new RuntimeException(e);
         } catch (InstantiationException e) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
similarity index 64%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
index 9175df0012..c81e4c1aed 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
@@ -47,7 +47,7 @@
 
 
 @RunWith(AndroidJUnit4.class)
-public class CollectionTests {
+public class OsResultsTests {
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
@@ -152,19 +152,19 @@ private void addRow(SharedRealm sharedRealm) {
     @Test
     public void constructor_withDistinct() {
         SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(null, table, "firstName");
-        Collection collection = new Collection(sharedRealm, table.where(), null, distinctDescriptor);
+        OsResults osResults = new OsResults(sharedRealm, table.where(), null, distinctDescriptor);
 
-        assertEquals(3, collection.size());
-        assertEquals("John", collection.getUncheckedRow(0).getString(0));
-        assertEquals("Erik", collection.getUncheckedRow(1).getString(0));
-        assertEquals("Henry", collection.getUncheckedRow(2).getString(0));
+        assertEquals(3, osResults.size());
+        assertEquals("John", osResults.getUncheckedRow(0).getString(0));
+        assertEquals("Erik", osResults.getUncheckedRow(1).getString(0));
+        assertEquals("Henry", osResults.getUncheckedRow(2).getString(0));
     }
 
 
     @Test(expected = UnsupportedOperationException.class)
     public void constructor_queryIsValidated() {
-        // Collection's constructor should call TableQuery.validateQuery()
-        new Collection(sharedRealm, table.where().or());
+        // OsResults's constructor should call TableQuery.validateQuery()
+        new OsResults(sharedRealm, table.where().or());
     }
 
     @Test
@@ -175,86 +175,86 @@ public void constructor_queryOnDeletedTable() {
         sharedRealm.commitTransaction();
         // Query should be checked before creating OS Results.
         thrown.expect(IllegalStateException.class);
-        new Collection(sharedRealm, query);
+        new OsResults(sharedRealm, query);
     }
 
     @Test
     public void size() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        assertEquals(4, collection.size());
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        assertEquals(4, osResults.size());
     }
 
     @Test
     public void where() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        Collection collection2 = new Collection(sharedRealm, collection.where().equalTo(new long[] {0}, oneNullTable, "John"));
-        Collection collection3 = new Collection(sharedRealm, collection2.where().equalTo(new long[] {1}, oneNullTable, "Anderson"));
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults2 = new OsResults(sharedRealm, osResults.where().equalTo(new long[] {0}, oneNullTable, "John"));
+        OsResults osResults3 = new OsResults(sharedRealm, osResults2.where().equalTo(new long[] {1}, oneNullTable, "Anderson"));
 
         // A new native Results should be created.
-        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
-        assertTrue(collection2.getNativePtr() != collection3.getNativePtr());
+        assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
+        assertTrue(osResults2.getNativePtr() != osResults3.getNativePtr());
 
-        assertEquals(4, collection.size());
-        assertEquals(2, collection2.size());
-        assertEquals(1, collection3.size());
+        assertEquals(4, osResults.size());
+        assertEquals(2, osResults2.size());
+        assertEquals(1, osResults3.size());
     }
 
     @Test
     public void sort() {
-        Collection collection = new Collection(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
+        OsResults osResults = new OsResults(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
         SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
-        Collection collection2 = collection.sort(sortDescriptor);
+        OsResults osResults2 = osResults.sort(sortDescriptor);
 
         // A new native Results should be created.
-        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
-        assertEquals(2, collection.size());
-        assertEquals(2, collection2.size());
+        assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
+        assertEquals(2, osResults.size());
+        assertEquals(2, osResults2.size());
 
-        assertEquals(3, collection2.getUncheckedRow(0).getLong(2));
-        assertEquals(4, collection2.getUncheckedRow(1).getLong(2));
+        assertEquals(3, osResults2.getUncheckedRow(0).getLong(2));
+        assertEquals(4, osResults2.getUncheckedRow(1).getLong(2));
     }
 
     @Test
     public void clear() {
         assertEquals(4, table.size());
-        Collection collection = new Collection(sharedRealm, table.where());
+        OsResults osResults = new OsResults(sharedRealm, table.where());
         sharedRealm.beginTransaction();
-        collection.clear();
+        osResults.clear();
         sharedRealm.commitTransaction();
         assertEquals(0, table.size());
     }
 
     @Test
     public void contains() {
-        Collection collection = new Collection(sharedRealm, table.where());
+        OsResults osResults = new OsResults(sharedRealm, table.where());
         UncheckedRow row = table.getUncheckedRow(0);
-        assertTrue(collection.contains(row));
+        assertTrue(osResults.contains(row));
     }
 
     @Test
     public void indexOf() {
         SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
 
-        Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
+        OsResults osResults = new OsResults(sharedRealm, table.where(), sortDescriptor);
         UncheckedRow row = table.getUncheckedRow(0);
-        assertEquals(3, collection.indexOf(row));
+        assertEquals(3, osResults.indexOf(row));
     }
 
     @Test
     public void distinct() {
-        Collection collection = new Collection(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
+        OsResults osResults = new OsResults(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
 
         SortDescriptor distinctDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
-        Collection collection2 = collection.distinct(distinctDescriptor);
+        OsResults osResults2 = osResults.distinct(distinctDescriptor);
 
         // A new native Results should be created.
-        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
-        assertEquals(3, collection.size());
-        assertEquals(2, collection2.size());
+        assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
+        assertEquals(3, osResults.size());
+        assertEquals(2, osResults2.size());
 
-        assertEquals(3, collection2.getUncheckedRow(0).getLong(2));
-        assertEquals(1, collection2.getUncheckedRow(1).getLong(2));
+        assertEquals(3, osResults2.getUncheckedRow(0).getLong(2));
+        assertEquals(1, osResults2.getUncheckedRow(1).getLong(2));
     }
 
     // 1. Create a results and add listener.
@@ -266,13 +266,13 @@ public void addListener_shouldBeCalledToReturnTheQueryResults() {
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(4, collection1.size());
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(4, osResults1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -287,12 +287,12 @@ public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
         final SharedRealm sharedRealm = getSharedRealm();
         Table table = getTable(sharedRealm);
 
-        final Collection collection = new Collection(sharedRealm, table.where());
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(4, collection1.size());
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(4, osResults1.size());
                 sharedRealm.close();
                 onChangeCalled.set(true);
             }
@@ -304,17 +304,17 @@ public void onChange(Collection collection1) {
     @Test
     public void addListener_shouldBeCalledWhenRefreshAfterLocalCommit() {
         final CountDownLatch latch = new CountDownLatch(2);
-        final Collection collection = new Collection(sharedRealm, table.where());
-        assertEquals(4, collection.size()); // See `populateData()`
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        assertEquals(4, osResults.size()); // See `populateData()`
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection element) {
+            public void onChange(OsResults element) {
                 if (latch.getCount() == 2) {
                     // triggered by beginTransaction
-                    assertEquals(4, collection.size());
+                    assertEquals(4, osResults.size());
                 } else if (latch.getCount() == 1) {
                     // triggered by refresh
-                    assertEquals(5, collection.size());
+                    assertEquals(5, osResults.size());
                 } else {
                     fail();
                 }
@@ -332,11 +332,11 @@ public void onChange(Collection element) {
     @Test
     public void addListener_triggeredByRefresh() {
         final CountDownLatch latch = new CountDownLatch(1);
-        Collection collection = new Collection(sharedRealm, table.where());
-        collection.size();
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        osResults.size();
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection element) {
+            public void onChange(OsResults element) {
                 assertEquals(1, latch.getCount());
                 latch.countDown();
             }
@@ -356,13 +356,13 @@ public void addListener_queryNotReturned() {
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(5, collection1.size());
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(5, osResults1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -378,14 +378,14 @@ public void addListener_queryReturned() {
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        assertEquals(4, collection.size()); // Trigger the query to run.
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        assertEquals(4, osResults.size()); // Trigger the query to run.
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(5, collection1.size());
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(5, osResults1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -404,17 +404,17 @@ public void addListener_triggeredByLocalCommit() {
         Table table = getTable(sharedRealm);
         final AtomicInteger listenerCounter = new AtomicInteger(0);
 
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection collection1) {
+            public void onChange(OsResults osResults1) {
                 switch (listenerCounter.getAndIncrement()) {
                     case 0:
-                        assertEquals(4, collection1.size());
+                        assertEquals(4, osResults1.size());
                         break;
                     case 1:
-                        assertEquals(5, collection1.size());
+                        assertEquals(5, osResults1.size());
                         sharedRealm.close();
                         break;
                     default:
@@ -428,9 +428,9 @@ public void onChange(Collection collection1) {
         looperThread.testComplete();
     }
 
-    private static class TestIterator extends Collection.Iterator<Integer> {
-        TestIterator(Collection collection) {
-            super(collection);
+    private static class TestIterator extends OsResults.Iterator<Integer> {
+        TestIterator(OsResults osResults) {
+            super(osResults);
         }
 
         @Override
@@ -439,8 +439,8 @@ protected Integer convertRowToObject(UncheckedRow row) {
         }
 
         boolean isDetached(SharedRealm sharedRealm) {
-            for (WeakReference<Collection.Iterator> iteratorRef : sharedRealm.iterators) {
-                Collection.Iterator iterator = iteratorRef.get();
+            for (WeakReference<OsResults.Iterator> iteratorRef : sharedRealm.iterators) {
+                OsResults.Iterator iterator = iteratorRef.get();
                 if (iterator == this) {
                     return false;
                 }
@@ -451,8 +451,8 @@ boolean isDetached(SharedRealm sharedRealm) {
 
     @Test
     public void collectionIterator_detach_byBeginTransaction() {
-        final Collection collection = new Collection(sharedRealm, table.where());
-        TestIterator iterator = new TestIterator(collection);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(osResults);
         assertFalse(iterator.isDetached(sharedRealm));
         sharedRealm.beginTransaction();
         assertTrue(iterator.isDetached(sharedRealm));
@@ -463,15 +463,15 @@ public void collectionIterator_detach_byBeginTransaction() {
     @Test
     public void collectionIterator_detach_createdInTransaction() {
         sharedRealm.beginTransaction();
-        final Collection collection = new Collection(sharedRealm, table.where());
-        TestIterator iterator = new TestIterator(collection);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(osResults);
         assertTrue(iterator.isDetached(sharedRealm));
     }
 
     @Test
     public void collectionIterator_invalid_nonLooperThread_byRefresh() {
-        final Collection collection = new Collection(sharedRealm, table.where());
-        TestIterator iterator = new TestIterator(collection);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(osResults);
         assertFalse(iterator.isDetached(sharedRealm));
         sharedRealm.refresh();
         thrown.expect(ConcurrentModificationException.class);
@@ -484,13 +484,13 @@ public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
         final SharedRealm sharedRealm = getSharedRealmForLooper();
         populateData(sharedRealm);
         Table table = getTable(sharedRealm);
-        final Collection collection = new Collection(sharedRealm, table.where());
-        final TestIterator iterator = new TestIterator(collection);
-        looperThread.keepStrongReference(collection);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final TestIterator iterator = new TestIterator(osResults);
+        looperThread.keepStrongReference(osResults);
         assertFalse(iterator.isDetached(sharedRealm));
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection element) {
+            public void onChange(OsResults element) {
                 try {
                     iterator.checkValid();
                     fail();
@@ -506,29 +506,29 @@ public void onChange(Collection element) {
 
     @Test
     public void collectionIterator_newInstance_throwsWhenSharedRealmIsClosed() {
-        final Collection collection = new Collection(sharedRealm, table.where());
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
         sharedRealm.close();
         thrown.expect(IllegalStateException.class);
-        new TestIterator(collection);
+        new TestIterator(osResults);
     }
 
     @Test
     public void getMode() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        assertTrue(Collection.Mode.QUERY == collection.getMode());
-        collection.firstUncheckedRow(); // Run the query
-        assertTrue(Collection.Mode.TABLEVIEW == collection.getMode());
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        assertTrue(OsResults.Mode.QUERY == osResults.getMode());
+        osResults.firstUncheckedRow(); // Run the query
+        assertTrue(OsResults.Mode.TABLEVIEW == osResults.getMode());
     }
 
     @Test
     public void createSnapshot() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        Collection snapshot = collection.createSnapshot();
-        assertTrue(Collection.Mode.TABLEVIEW == snapshot.getMode());
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults snapshot = osResults.createSnapshot();
+        assertTrue(OsResults.Mode.TABLEVIEW == snapshot.getMode());
         thrown.expect(IllegalStateException.class);
-        snapshot.addListener(snapshot, new RealmChangeListener<Collection>() {
+        snapshot.addListener(snapshot, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection element) {
+            public void onChange(OsResults element) {
             }
         });
     }
@@ -539,15 +539,15 @@ public void load() {
         final SharedRealm sharedRealm = getSharedRealmForLooper();
         looperThread.closeAfterTest(sharedRealm);
         populateData(sharedRealm);
-        final Collection collection = new Collection(sharedRealm, table.where());
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
             @Override
-            public void onChange(Collection element) {
-                assertTrue(collection.isLoaded());
+            public void onChange(OsResults element) {
+                assertTrue(osResults.isLoaded());
                 looperThread.testComplete();
             }
         });
-        assertFalse(collection.isLoaded());
-        collection.load();
+        assertFalse(osResults.isLoaded());
+        osResults.load();
     }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index eb1d5f79e2..c36935cb8d 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -60,7 +60,7 @@ set(classes_LIST
     io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
     io.realm.log.LogLevel io.realm.log.RealmLog io.realm.internal.Property io.realm.internal.OsSchemaInfo
-    io.realm.internal.OsObjectSchemaInfo io.realm.internal.Collection
+    io.realm.internal.OsObjectSchemaInfo io.realm.internal.OsResults
     io.realm.internal.NativeObjectReference io.realm.internal.OsCollectionChangeSet
     io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
     io.realm.internal.OsObjectStore
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
index e9b6330a90..26f53313cc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "io_realm_internal_Collection.h"
+#include "io_realm_internal_OsResults.h"
 
 #include <shared_realm.hpp>
 #include <results.hpp>
@@ -39,7 +39,7 @@ static void finalize_results(jlong ptr)
     delete reinterpret_cast<ResultsWrapper*>(ptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNIEnv* env, jclass,
                                                                               jlong shared_realm_ptr, jlong query_ptr,
                                                                               jobject j_sort_desc,
                                                                               jobject j_distinct_desc)
@@ -70,7 +70,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JN
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromList(JNIEnv* env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResultsFromList(JNIEnv* env, jclass,
                                                                                           jlong shared_realm_ptr,
                                                                                           jlong list_ptr,
                                                                                           jobject j_sort_desc)
@@ -91,7 +91,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFro
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr);
     try {
@@ -104,7 +104,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateSnapshot(J
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeContains(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeContains(JNIEnv* env, jclass, jlong native_ptr,
                                                                             jlong native_row_ptr)
 {
     TR_ENTER_PTR(native_ptr);
@@ -118,7 +118,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeContains(JNIE
     return JNI_FALSE;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetRow(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeGetRow(JNIEnv* env, jclass, jlong native_ptr,
                                                                        jint index)
 {
     TR_ENTER_PTR(native_ptr)
@@ -131,7 +131,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetRow(JNIEnv* e
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeFirstRow(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -145,7 +145,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv*
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeLastRow(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeLastRow(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -159,7 +159,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeLastRow(JNIEnv*
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeClear(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeClear(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -169,7 +169,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeClear(JNIEnv* env
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSize(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeSize(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -180,7 +180,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSize(JNIEnv* env
     return 0;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jobject JNICALL Java_io_realm_internal_OsResults_nativeAggregate(JNIEnv* env, jclass, jlong native_ptr,
                                                                             jlong column_index, jbyte agg_func)
 {
     TR_ENTER_PTR(native_ptr)
@@ -190,13 +190,13 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
         size_t index = S(column_index);
         Optional<Mixed> value;
         switch (agg_func) {
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_MINIMUM:
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_MINIMUM:
                 value = wrapper->collection().min(index);
                 break;
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_MAXIMUM:
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_MAXIMUM:
                 value = wrapper->collection().max(index);
                 break;
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_AVERAGE: {
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_AVERAGE: {
                 Optional<double> value_count(wrapper->collection().average(index));
                 if (value_count) {
                     value = Optional<Mixed>(Mixed(value_count.value()));
@@ -206,7 +206,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
                 }
                 break;
             }
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_SUM:
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_SUM:
                 value = wrapper->collection().sum(index);
                 break;
             default:
@@ -235,7 +235,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
     return static_cast<jobject>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeSort(JNIEnv* env, jclass, jlong native_ptr,
                                                                      jobject j_sort_desc)
 {
     TR_ENTER_PTR(native_ptr)
@@ -248,7 +248,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeDistinct(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeDistinct(JNIEnv* env, jclass, jlong native_ptr,
                                                                          jobject j_distinct_desc)
 {
     TR_ENTER_PTR(native_ptr)
@@ -262,7 +262,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeDistinct(JNIEnv*
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStartListening(JNIEnv* env, jobject instance,
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeStartListening(JNIEnv* env, jobject instance,
                                                                               jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
@@ -274,7 +274,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStartListening(JN
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
@@ -285,13 +285,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStopListening(JNI
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetFinalizerPtr(JNIEnv*, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_results);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeWhere(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeWhere(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -306,7 +306,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeWhere(JNIEnv* en
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeIndexOf(JNIEnv* env, jclass, jlong native_ptr,
                                                                         jlong row_native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
@@ -320,7 +320,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv*
     return npos;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteLast(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeDeleteLast(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -335,7 +335,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteLast(JN
     return JNI_FALSE;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteFirst(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeDeleteFirst(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
@@ -351,7 +351,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteFirst(J
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeDelete(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeDelete(JNIEnv* env, jclass, jlong native_ptr,
                                                                       jlong index)
 {
     TR_ENTER_PTR(native_ptr)
@@ -366,7 +366,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeDelete(JNIEnv* en
     CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeIsValid(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeIsValid(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -377,29 +377,29 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeIsValid(JNIEn
     return JNI_FALSE;
 }
 
-JNIEXPORT jbyte JNICALL Java_io_realm_internal_Collection_nativeGetMode(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jbyte JNICALL Java_io_realm_internal_OsResults_nativeGetMode(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         switch (wrapper->collection().get_mode()) {
             case Results::Mode::Empty:
-                return io_realm_internal_Collection_MODE_EMPTY;
+                return io_realm_internal_OsResults_MODE_EMPTY;
             case Results::Mode::Table:
-                return io_realm_internal_Collection_MODE_TABLE;
+                return io_realm_internal_OsResults_MODE_TABLE;
             case Results::Mode::Query:
-                return io_realm_internal_Collection_MODE_QUERY;
+                return io_realm_internal_OsResults_MODE_QUERY;
             case Results::Mode::LinkView:
-                return io_realm_internal_Collection_MODE_LINKVIEW;
+                return io_realm_internal_OsResults_MODE_LINKVIEW;
             case Results::Mode::TableView:
-                return io_realm_internal_Collection_MODE_TABLEVIEW;
+                return io_realm_internal_OsResults_MODE_TABLEVIEW;
         }
     }
     CATCH_STD()
     return -1; // Invalid mode value
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromBacklinks(JNIEnv *env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResultsFromBacklinks(JNIEnv *env, jclass,
                                                                                            jlong shared_realm_ptr,
                                                                                            jlong row_ptr,
                                                                                            jlong src_table_ptr,
diff --git a/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
index ed53c62c9f..6b86d91138 100644
--- a/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
+++ b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
@@ -26,8 +26,8 @@ namespace realm {
 namespace _impl {
 
 // Wrapper of Object Store List & Results.
-// We need to control the life cycle of Results/List, weak ref of Java Collection object and the NotificationToken.
-// Wrap all three together, so when the Java Collection object gets GCed, all three of them will be invalidated.
+// We need to control the life cycle of Results/List, weak ref of Java OsResults/OsList object and the NotificationToken.
+// Wrap all three together, so when the Java OsResults/OsList object gets GCed, all three of them will be invalidated.
 template <typename T>
 class ObservableCollectionWrapper {
 public:
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index aad610199f..aa3f85e9e4 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -543,7 +543,7 @@ public boolean isEmpty() {
      */
     public abstract RealmSchema getSchema();
 
-    // Used by RealmList/RealmResults, to create RealmObject from a Collection.
+    // Used by RealmList/RealmResults, to create RealmObject from a OsResults.
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
     <E extends RealmModel> E get(@Nullable Class<E> clazz, @Nullable String dynamicClassName, UncheckedRow row) {
         final boolean isDynamicRealmObject = dynamicClassName != null;
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
index 39163349d9..da24bf45d9 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
@@ -10,7 +10,7 @@
 import javax.annotation.Nullable;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.SortDescriptor;
@@ -33,29 +33,29 @@
     @SuppressFBWarnings("SS_SHOULD_BE_STATIC")
     final boolean forValues = false;
 
-    final Collection collection;
+    final OsResults osResults;
 
-    OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, Class<E> clazz) {
-        this(realm, collection, clazz, null);
+    OrderedRealmCollectionImpl(BaseRealm realm, OsResults osResults, Class<E> clazz) {
+        this(realm, osResults, clazz, null);
     }
 
-    OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, String className) {
-        this(realm, collection, null, className);
+    OrderedRealmCollectionImpl(BaseRealm realm, OsResults osResults, String className) {
+        this(realm, osResults, null, className);
     }
 
-    private OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, @Nullable Class<E> clazz, @Nullable String className) {
+    private OrderedRealmCollectionImpl(BaseRealm realm, OsResults osResults, @Nullable Class<E> clazz, @Nullable String className) {
         this.realm = realm;
-        this.collection = collection;
+        this.osResults = osResults;
         this.classSpec = clazz;
         this.className = className;
     }
 
     Table getTable() {
-        return collection.getTable();
+        return osResults.getTable();
     }
 
-    Collection getCollection() {
-        return collection;
+    OsResults getOsResults() {
+        return osResults;
     }
 
     /**
@@ -63,7 +63,7 @@ Collection getCollection() {
      */
     @Override
     public boolean isValid() {
-        return collection.isValid();
+        return osResults.isValid();
     }
 
     /**
@@ -121,7 +121,7 @@ public E get(int location) {
         }
 
         //noinspection unchecked
-        return (E) realm.get((Class<? extends RealmModel>) classSpec, className, collection.getUncheckedRow(location));
+        return (E) realm.get((Class<? extends RealmModel>) classSpec, className, osResults.getUncheckedRow(location));
     }
 
     /**
@@ -144,7 +144,7 @@ public E first(@Nullable E defaultValue) {
 
     @Nullable
     private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
-        UncheckedRow row = collection.firstUncheckedRow();
+        UncheckedRow row = osResults.firstUncheckedRow();
 
         if (forValues) {
             // TODO implement this
@@ -184,7 +184,7 @@ public E last(@Nullable E defaultValue) {
 
     @Nullable
     private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
-        UncheckedRow row = collection.lastUncheckedRow();
+        UncheckedRow row = osResults.lastUncheckedRow();
 
         if (forValues) {
             // TODO implement this
@@ -210,7 +210,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     public void deleteFromRealm(int location) {
         // TODO: Implement the delete in OS level and do check there!
         realm.checkIfValidAndInTransaction();
-        collection.delete(location);
+        osResults.delete(location);
     }
 
     /**
@@ -220,7 +220,7 @@ public void deleteFromRealm(int location) {
     public boolean deleteAllFromRealm() {
         realm.checkIfValid();
         if (size() > 0) {
-            collection.clear();
+            osResults.clear();
             return true;
         }
         return false;
@@ -277,7 +277,7 @@ private long getColumnIndexForSort(String fieldName) {
         if (fieldName.contains(".")) {
             throw new IllegalArgumentException("Aggregates on child object fields are not supported: " + fieldName);
         }
-        long columnIndex = collection.getTable().getColumnIndex(fieldName);
+        long columnIndex = osResults.getTable().getColumnIndex(fieldName);
         if (columnIndex < 0) {
             throw new IllegalArgumentException(String.format(Locale.US, "Field '%s' does not exist.", fieldName));
         }
@@ -290,10 +290,10 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldName) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(getSchemaConnector(), collection.getTable(), fieldName, Sort.ASCENDING);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, Sort.ASCENDING);
 
-        Collection sortedCollection = collection.sort(sortDescriptor);
-        return createLoadedResults(sortedCollection);
+        OsResults sortedOsResults = osResults.sort(sortDescriptor);
+        return createLoadedResults(sortedOsResults);
     }
 
     /**
@@ -302,10 +302,10 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(getSchemaConnector(), collection.getTable(), fieldName, sortOrder);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, sortOrder);
 
-        Collection sortedCollection = collection.sort(sortDescriptor);
-        return createLoadedResults(sortedCollection);
+        OsResults sortedOsResults = osResults.sort(sortDescriptor);
+        return createLoadedResults(sortedOsResults);
     }
 
     /**
@@ -314,10 +314,10 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(getSchemaConnector(), collection.getTable(), fieldNames, sortOrders);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldNames, sortOrders);
 
-        Collection sortedCollection = collection.sort(sortDescriptor);
-        return createLoadedResults(sortedCollection);
+        OsResults sortedOsResults = osResults.sort(sortDescriptor);
+        return createLoadedResults(sortedOsResults);
     }
 
     /**
@@ -338,7 +338,7 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public int size() {
         if (isLoaded()) {
-            long size = collection.size();
+            long size = osResults.size();
             return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
         }
         return 0;
@@ -351,7 +351,7 @@ public int size() {
     public Number min(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateNumber(io.realm.internal.Collection.Aggregate.MINIMUM, columnIndex);
+        return osResults.aggregateNumber(OsResults.Aggregate.MINIMUM, columnIndex);
     }
 
     /**
@@ -361,7 +361,7 @@ public Number min(String fieldName) {
     public Date minDate(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateDate(Collection.Aggregate.MINIMUM, columnIndex);
+        return osResults.aggregateDate(OsResults.Aggregate.MINIMUM, columnIndex);
     }
 
     /**
@@ -371,7 +371,7 @@ public Date minDate(String fieldName) {
     public Number max(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateNumber(Collection.Aggregate.MAXIMUM, columnIndex);
+        return osResults.aggregateNumber(OsResults.Aggregate.MAXIMUM, columnIndex);
     }
 
     /**
@@ -389,7 +389,7 @@ public Number max(String fieldName) {
     public Date maxDate(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateDate(Collection.Aggregate.MAXIMUM, columnIndex);
+        return osResults.aggregateDate(OsResults.Aggregate.MAXIMUM, columnIndex);
     }
 
 
@@ -400,7 +400,7 @@ public Date maxDate(String fieldName) {
     public Number sum(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateNumber(Collection.Aggregate.SUM, columnIndex);
+        return osResults.aggregateNumber(OsResults.Aggregate.SUM, columnIndex);
     }
 
     /**
@@ -411,7 +411,7 @@ public double average(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
 
-        Number avg = collection.aggregateNumber(Collection.Aggregate.AVERAGE, columnIndex);
+        Number avg = osResults.aggregateNumber(OsResults.Aggregate.AVERAGE, columnIndex);
         return avg.doubleValue();
     }
 
@@ -481,7 +481,7 @@ public boolean retainAll(@SuppressWarnings("NullableProblems") java.util.Collect
     public boolean deleteLastFromRealm() {
         // TODO: Implement the deleteLast in OS level and do check there!
         realm.checkIfValidAndInTransaction();
-        return collection.deleteLast();
+        return osResults.deleteLast();
     }
 
     /**
@@ -493,7 +493,7 @@ public boolean deleteLastFromRealm() {
     public boolean deleteFirstFromRealm() {
         // TODO: Implement the deleteLast in OS level and do check there!
         realm.checkIfValidAndInTransaction();
-        return collection.deleteFirst();
+        return osResults.deleteFirst();
     }
 
     /**
@@ -553,9 +553,9 @@ public boolean addAll(@SuppressWarnings("NullableProblems") java.util.Collection
     }
 
     // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
-    private class RealmCollectionIterator extends Collection.Iterator<E> {
+    private class RealmCollectionIterator extends OsResults.Iterator<E> {
         RealmCollectionIterator() {
-            super(OrderedRealmCollectionImpl.this.collection);
+            super(OrderedRealmCollectionImpl.this.osResults);
         }
 
         @Override
@@ -572,18 +572,18 @@ protected E convertRowToObject(UncheckedRow row) {
     @Override
     public OrderedRealmCollectionSnapshot<E> createSnapshot() {
         if (className != null) {
-            return new OrderedRealmCollectionSnapshot<E>(realm, collection, className);
+            return new OrderedRealmCollectionSnapshot<E>(realm, osResults, className);
         } else {
             // 'classSpec' is non-null when 'className' is null.
             //noinspection ConstantConditions
-            return new OrderedRealmCollectionSnapshot<E>(realm, collection, classSpec);
+            return new OrderedRealmCollectionSnapshot<E>(realm, osResults, classSpec);
         }
     }
 
     // Custom RealmResults list iterator.
-    private class RealmCollectionListIterator extends Collection.ListIterator<E> {
+    private class RealmCollectionListIterator extends OsResults.ListIterator<E> {
         RealmCollectionListIterator(int start) {
-            super(OrderedRealmCollectionImpl.this.collection, start);
+            super(OrderedRealmCollectionImpl.this.osResults, start);
         }
 
         @Override
@@ -597,14 +597,14 @@ protected E convertRowToObject(UncheckedRow row) {
         }
     }
 
-    RealmResults<E> createLoadedResults(Collection newCollection) {
+    RealmResults<E> createLoadedResults(OsResults newOsResults) {
         RealmResults<E> results;
         if (className != null) {
-            results = new RealmResults<E>(realm, newCollection, className);
+            results = new RealmResults<E>(realm, newOsResults, className);
         } else {
             // 'classSpec' is non-null when 'className' is null.
             //noinspection ConstantConditions
-            results = new RealmResults<E>(realm, newCollection, classSpec);
+            results = new RealmResults<E>(realm, newOsResults, classSpec);
         }
         results.load();
         return results;
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
index 5e4ce01545..6b2d9fd30a 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
@@ -18,7 +18,7 @@
 
 import java.util.Locale;
 
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.internal.UncheckedRow;
 
 
@@ -52,12 +52,12 @@
 
     private int size = -1;
 
-    OrderedRealmCollectionSnapshot(BaseRealm realm, Collection collection, Class<E> clazz) {
-        super(realm, collection.createSnapshot(), clazz);
+    OrderedRealmCollectionSnapshot(BaseRealm realm, OsResults osResults, Class<E> clazz) {
+        super(realm, osResults.createSnapshot(), clazz);
     }
 
-    OrderedRealmCollectionSnapshot(BaseRealm realm, Collection collection, String className) {
-        super(realm, collection.createSnapshot(), className);
+    OrderedRealmCollectionSnapshot(BaseRealm realm, OsResults osResults, String className) {
+        super(realm, osResults.createSnapshot(), className);
     }
 
     /**
@@ -171,9 +171,9 @@ public boolean load() {
     @Override
     public void deleteFromRealm(int location) {
         realm.checkIfValidAndInTransaction();
-        UncheckedRow row = collection.getUncheckedRow(location);
+        UncheckedRow row = osResults.getUncheckedRow(location);
         if (row.isAttached()) {
-            collection.delete(location);
+            osResults.delete(location);
         }
     }
 
@@ -186,8 +186,8 @@ public void deleteFromRealm(int location) {
     @Override
     public boolean deleteFirstFromRealm() {
         realm.checkIfValidAndInTransaction();
-        UncheckedRow row = collection.firstUncheckedRow();
-        return row != null && row.isAttached() && collection.deleteFirst();
+        UncheckedRow row = osResults.firstUncheckedRow();
+        return row != null && row.isAttached() && osResults.deleteFirst();
     }
 
     /**
@@ -199,8 +199,8 @@ public boolean deleteFirstFromRealm() {
     @Override
     public boolean deleteLastFromRealm() {
         realm.checkIfValidAndInTransaction();
-        UncheckedRow row = collection.lastUncheckedRow();
-        return row != null && row.isAttached() && collection.deleteLast();
+        UncheckedRow row = osResults.lastUncheckedRow();
+        return row != null && row.isAttached() && osResults.deleteLast();
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 6e5428adfd..c4da704041 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -58,6 +58,7 @@
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.OsObjectStore;
+import io.realm.internal.OsResults;
 import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmNotifier;
@@ -1720,7 +1721,7 @@ public static boolean compactRealm(RealmConfiguration configuration) {
         String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
         SharedRealm.PartialSyncCallback internalCallback = new SharedRealm.PartialSyncCallback(className) {
             @Override
-            public void onSuccess(io.realm.internal.Collection osResults) {
+            public void onSuccess(OsResults osResults) {
                 RealmResults<E> results = new RealmResults<>(Realm.this, osResults, clazz);
                 callback.onSuccess(results);
             }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 45c5521fe2..e1ba427ce4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -36,6 +36,7 @@
 import io.realm.internal.InvalidRow;
 import io.realm.internal.OsList;
 import io.realm.internal.OsObjectStore;
+import io.realm.internal.OsResults;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.rx.CollectionChange;
 
@@ -74,7 +75,7 @@
     final protected BaseRealm realm;
     private List<E> unmanagedList;
     // Used for listeners on RealmList<RealmModel>
-    private io.realm.internal.Collection osResults;
+    private OsResults osResults;
 
     /**
      * Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm.
@@ -760,14 +761,14 @@ private void checkValidRealm() {
         if (className != null) {
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new io.realm.internal.Collection(realm.sharedRealm, osListOperator.getOsList(), null),
+                    new OsResults(realm.sharedRealm, osListOperator.getOsList(), null),
                     className);
         } else {
             // 'clazz' is non-null when 'dynamicClassName' is null.
             //noinspection ConstantConditions
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new io.realm.internal.Collection(realm.sharedRealm, osListOperator.getOsList(), null),
+                    new OsResults(realm.sharedRealm, osListOperator.getOsList(), null),
                     clazz);
         }
     }
@@ -1289,9 +1290,9 @@ private static boolean isClassForRealmModel(Class<?> clazz) {
     // new element. By right results it means the change set only include one insertion. But if the listener is on the
     // OS List, the change set will include all ranges of th list. So we keep the old behaviour for
     // RealmList<RealmModel> for now. See https://github.com/realm/realm-object-store/issues/541
-    private io.realm.internal.Collection getOrCreateOsResultsForListener() {
+    private OsResults getOrCreateOsResultsForListener() {
         if (osResults == null) {
-            this.osResults = new io.realm.internal.Collection(realm.sharedRealm, osListOperator.getOsList(), null);
+            this.osResults = new OsResults(realm.sharedRealm, osListOperator.getOsList(), null);
         }
         return osResults;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 7825f3c72e..89fafb6b95 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -24,7 +24,7 @@
 import javax.annotation.Nullable;
 
 import io.realm.annotations.Required;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.internal.OsList;
 import io.realm.internal.PendingRow;
 import io.realm.internal.RealmObjectProxy;
@@ -160,7 +160,7 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
             this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
             this.table = queryResults.getTable();
             this.osList = null;
-            this.query = queryResults.getCollection().where();
+            this.query = queryResults.getOsResults().where();
         }
     }
 
@@ -199,7 +199,7 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
         this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
-        this.query = queryResults.getCollection().where();
+        this.query = queryResults.getOsResults().where();
         this.osList = null;
     }
 
@@ -2002,7 +2002,7 @@ public E findFirstAsync() {
         if (realm.isInTransaction()) {
             // It is not possible to create async query inside a transaction. So immediately query the first object.
             // See OS Results::prepare_async()
-            row = new Collection(realm.sharedRealm, query).firstUncheckedRow();
+            row = new OsResults(realm.sharedRealm, query).firstUncheckedRow();
         } else {
             // prepares an empty reference of the RealmObject which is backed by a pending query,
             // then update it once the query complete in the background.
@@ -2038,11 +2038,11 @@ public E findFirstAsync() {
             @Nullable SortDescriptor distinctDescriptor,
             boolean loadResults) {
         RealmResults<E> results;
-        Collection collection = new Collection(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+        OsResults osResults = new OsResults(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
         if (isDynamicQuery()) {
-            results = new RealmResults<>(realm, collection, className);
+            results = new RealmResults<>(realm, osResults, className);
         } else {
-            results = new RealmResults<>(realm, collection, clazz);
+            results = new RealmResults<>(realm, osResults, clazz);
         }
         if (loadResults) {
             results.load();
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index e7892701dd..9a553a092f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -22,13 +22,12 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.Observable;
-import javax.annotation.Nonnull;
+
 import javax.annotation.Nullable;
 
 import io.realm.internal.CheckedRow;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.internal.Row;
-import io.realm.internal.SortDescriptor;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
 import io.realm.rx.CollectionChange;
@@ -69,7 +68,7 @@
         Table srcTable = realm.getSchema().getTable(srcTableType);
         return new RealmResults<>(
                 realm,
-                Collection.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
+                OsResults.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
                 srcTableType);
     }
 
@@ -79,16 +78,16 @@
         //noinspection ConstantConditions
         return new RealmResults<>(
                 realm,
-                Collection.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
+                OsResults.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
                 srcClassName);
     }
 
-    RealmResults(BaseRealm realm, Collection collection, Class<E> clazz) {
-        super(realm, collection, clazz);
+    RealmResults(BaseRealm realm, OsResults osResults, Class<E> clazz) {
+        super(realm, osResults, clazz);
     }
 
-    RealmResults(BaseRealm realm, Collection collection, String className) {
-        super(realm, collection, className);
+    RealmResults(BaseRealm realm, OsResults osResults, String className) {
+        super(realm, osResults, className);
     }
 
     /**
@@ -118,7 +117,7 @@
     @Override
     public boolean isLoaded() {
         realm.checkIfValid();
-        return collection.isLoaded();
+        return osResults.isLoaded();
     }
 
     /**
@@ -129,12 +128,12 @@ public boolean isLoaded() {
      */
     @Override
     public boolean load() {
-        // The Collection doesn't have to be loaded before accessing it if the query has not returned.
-        // Instead, accessing the Collection will just trigger the execution of query if needed. We add this flag is
+        // The OsResults doesn't have to be loaded before accessing it if the query has not returned.
+        // Instead, accessing the OsResults will just trigger the execution of query if needed. We add this flag is
         // only to keep the original behavior of those APIs. eg.: For a async RealmResults, before query returns, the
         // size() call should return 0 instead of running the query get the real size.
         realm.checkIfValid();
-        collection.load();
+        osResults.load();
         return true;
     }
 
@@ -173,7 +172,7 @@ public boolean load() {
      */
     public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        osResults.addListener(this, listener);
     }
 
     /**
@@ -211,7 +210,7 @@ public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
      */
     public void addChangeListener(OrderedRealmCollectionChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        osResults.addListener(this, listener);
     }
 
     private void checkForAddRemoveListener(@Nullable Object listener, boolean checkListener) {
@@ -230,7 +229,7 @@ private void checkForAddRemoveListener(@Nullable Object listener, boolean checkL
      */
     public void removeAllChangeListeners() {
         checkForAddRemoveListener(null, false);
-        collection.removeAllListeners();
+        osResults.removeAllListeners();
     }
 
     /**
@@ -243,7 +242,7 @@ public void removeAllChangeListeners() {
      */
     public void removeChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        osResults.removeListener(this, listener);
     }
 
     /**
@@ -256,7 +255,7 @@ public void removeChangeListener(RealmChangeListener<RealmResults<E>> listener)
      */
     public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        osResults.removeListener(this, listener);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Collection.java b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
similarity index 85%
rename from realm/realm-library/src/main/java/io/realm/internal/Collection.java
rename to realm/realm-library/src/main/java/io/realm/internal/OsResults.java
index df0b2c6cf0..ce294974ea 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Collection.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
@@ -30,32 +30,32 @@
  * Java wrapper of Object Store Results class.
  * It is the backend of binding's query results and back links.
  */
-public class Collection implements NativeObject, ObservableCollection {
+public class OsResults implements NativeObject, ObservableCollection {
 
     private static final String CLOSED_REALM_MESSAGE =
             "This Realm instance has already been closed, making it unusable.";
 
-    // Custom Collection iterator. It ensures that we only iterate on a Realm collection that hasn't changed.
+    // Custom OsResults iterator. It ensures that we only iterate on a Realm OsResults that hasn't changed.
     public static abstract class Iterator<T> implements java.util.Iterator<T> {
-        Collection iteratorCollection;
+        OsResults iteratorOsResults;
         protected int pos = -1;
 
-        public Iterator(Collection collection) {
-            if (collection.sharedRealm.isClosed()) {
+        public Iterator(OsResults osResults) {
+            if (osResults.sharedRealm.isClosed()) {
                 throw new IllegalStateException(CLOSED_REALM_MESSAGE);
             }
 
-            this.iteratorCollection = collection;
+            this.iteratorOsResults = osResults;
 
-            if (collection.isSnapshot) {
+            if (osResults.isSnapshot) {
                 // No need to detach a snapshot.
                 return;
             }
 
-            if (collection.sharedRealm.isInTransaction()) {
+            if (osResults.sharedRealm.isInTransaction()) {
                 detach();
             } else {
-                iteratorCollection.sharedRealm.addIterator(this);
+                iteratorOsResults.sharedRealm.addIterator(this);
             }
         }
 
@@ -65,7 +65,7 @@ public Iterator(Collection collection) {
         @Override
         public boolean hasNext() {
             checkValid();
-            return pos + 1 < iteratorCollection.size();
+            return pos + 1 < iteratorOsResults.size();
         }
 
         /**
@@ -76,8 +76,8 @@ public boolean hasNext() {
         public T next() {
             checkValid();
             pos++;
-            if (pos >= iteratorCollection.size()) {
-                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + iteratorCollection.size() +
+            if (pos >= iteratorOsResults.size()) {
+                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + iteratorOsResults.size() +
                         ". Remember to check hasNext() before using next().");
             }
             return get(pos);
@@ -95,7 +95,7 @@ public void remove() {
         }
 
         void detach() {
-            iteratorCollection = iteratorCollection.createSnapshot();
+            iteratorOsResults = iteratorOsResults.createSnapshot();
         }
 
         // The iterator becomes invalid after receiving a remote change notification. In Java, the destruction of
@@ -103,11 +103,11 @@ void detach() {
         // like what realm-cocoa does, we will have a massive overhead since all the iterators created in the previous
         // event loop need to be detached.
         void invalidate() {
-            iteratorCollection = null;
+            iteratorOsResults = null;
         }
 
         void checkValid() {
-            if (iteratorCollection == null) {
+            if (iteratorOsResults == null) {
                 throw new ConcurrentModificationException(
                         "No outside changes to a Realm is allowed while iterating a living Realm collection.");
             }
@@ -115,7 +115,7 @@ void checkValid() {
 
         @Nullable
         T get(int pos) {
-            return convertRowToObject(iteratorCollection.getUncheckedRow(pos));
+            return convertRowToObject(iteratorOsResults.getUncheckedRow(pos));
         }
 
         // Returns the RealmModel by given row in this list. This has to be implemented in the upper layer since
@@ -126,13 +126,13 @@ T get(int pos) {
     // Custom Realm collection list iterator.
     public static abstract class ListIterator<T> extends Iterator<T> implements java.util.ListIterator<T> {
 
-        public ListIterator(Collection collection, int start) {
-            super(collection);
-            if (start >= 0 && start <= iteratorCollection.size()) {
+        public ListIterator(OsResults osResults, int start) {
+            super(osResults);
+            if (start >= 0 && start <= iteratorOsResults.size()) {
                 pos = start - 1;
             } else {
                 throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, "
-                        + (iteratorCollection.size() - 1) + "]. Yours was " + start);
+                        + (iteratorOsResults.size() - 1) + "]. Yours was " + start);
             }
         }
 
@@ -276,17 +276,17 @@ static Mode getByValue(byte value) {
         }
     }
 
-    public static Collection createBacklinksCollection(SharedRealm realm, UncheckedRow row, Table srcTable, String srcFieldName) {
+    public static OsResults createBacklinksCollection(SharedRealm realm, UncheckedRow row, Table srcTable, String srcFieldName) {
         long backlinksPtr = nativeCreateResultsFromBacklinks(
                 realm.getNativePtr(),
                 row.getNativePtr(),
                 srcTable.getNativePtr(),
                 srcTable.getColumnIndex(srcFieldName));
-        return new Collection(realm, srcTable, backlinksPtr, true);
+        return new OsResults(realm, srcTable, backlinksPtr, true);
     }
 
-    public Collection(SharedRealm sharedRealm, TableQuery query,
-            @Nullable SortDescriptor sortDescriptor, @Nullable SortDescriptor distinctDescriptor) {
+    public OsResults(SharedRealm sharedRealm, TableQuery query,
+                     @Nullable SortDescriptor sortDescriptor, @Nullable SortDescriptor distinctDescriptor) {
         query.validateQuery();
 
         this.nativePtr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(),
@@ -300,31 +300,31 @@ public Collection(SharedRealm sharedRealm, TableQuery query,
         this.loaded = false;
     }
 
-    public Collection(SharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor) {
+    public OsResults(SharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor) {
         this(sharedRealm, query, sortDescriptor, null);
     }
 
-    public Collection(SharedRealm sharedRealm, TableQuery query) {
+    public OsResults(SharedRealm sharedRealm, TableQuery query) {
         this(sharedRealm, query, null, null);
     }
 
-    public Collection(SharedRealm sharedRealm, OsList osList, @Nullable SortDescriptor sortDescriptor) {
+    public OsResults(SharedRealm sharedRealm, OsList osList, @Nullable SortDescriptor sortDescriptor) {
         this.nativePtr = nativeCreateResultsFromList(sharedRealm.getNativePtr(), osList.getNativePtr(), sortDescriptor);
 
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
         this.table = osList.getTargetTable();
         this.context.addReference(this);
-        // Collection created from OsList is loaded by default. So that the listener won't be triggered with empty
+        // OsResults created from OsList is loaded by default. So that the listener won't be triggered with empty
         // change set.
         this.loaded = true;
     }
 
-    private Collection(SharedRealm sharedRealm, Table table, long nativePtr) {
+    private OsResults(SharedRealm sharedRealm, Table table, long nativePtr) {
         this(sharedRealm, table, nativePtr, false);
     }
 
-    Collection(SharedRealm sharedRealm, Table table, long nativePtr, boolean loaded) {
+    OsResults(SharedRealm sharedRealm, Table table, long nativePtr, boolean loaded) {
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
         this.table = table;
@@ -333,13 +333,13 @@ private Collection(SharedRealm sharedRealm, Table table, long nativePtr) {
         this.loaded = loaded;
     }
 
-    public Collection createSnapshot() {
+    public OsResults createSnapshot() {
         if (isSnapshot) {
             return this;
         }
-        Collection collection = new Collection(sharedRealm, table, nativeCreateSnapshot(nativePtr));
-        collection.isSnapshot = true;
-        return collection;
+        OsResults osResults = new OsResults(sharedRealm, table, nativeCreateSnapshot(nativePtr));
+        osResults.isSnapshot = true;
+        return osResults;
     }
 
     @Override
@@ -397,12 +397,12 @@ public void clear() {
         nativeClear(nativePtr);
     }
 
-    public Collection sort(SortDescriptor sortDescriptor) {
-        return new Collection(sharedRealm, table, nativeSort(nativePtr, sortDescriptor));
+    public OsResults sort(SortDescriptor sortDescriptor) {
+        return new OsResults(sharedRealm, table, nativeSort(nativePtr, sortDescriptor));
     }
 
-    public Collection distinct(SortDescriptor distinctDescriptor) {
-        return new Collection(sharedRealm, table, nativeDistinct(nativePtr, distinctDescriptor));
+    public OsResults distinct(SortDescriptor distinctDescriptor) {
+        return new OsResults(sharedRealm, table, nativeDistinct(nativePtr, distinctDescriptor));
     }
 
     public boolean contains(UncheckedRow row) {
@@ -532,7 +532,7 @@ private static native long nativeCreateResultsFromList(long sharedRealmPtr, long
 
     private static native void nativeDelete(long nativePtr, long index);
 
-    // Non-static, we need this Collection object in JNI.
+    // Non-static, we need this OsResults object in JNI.
     private native void nativeStartListening(long nativePtr);
 
     private native void nativeStopListening(long nativePtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 638fc3d5f8..ccdad47857 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -32,7 +32,7 @@
             "The query has been executed. This 'PendingRow' is not valid anymore.";
 
     private SharedRealm sharedRealm;
-    private Collection pendingCollection;
+    private OsResults pendingOsResults;
     private RealmChangeListener<PendingRow> listener;
     private WeakReference<FrontEnd> frontEndRef;
     private boolean returnCheckedRow;
@@ -40,7 +40,7 @@
     public PendingRow(SharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor,
             final boolean returnCheckedRow) {
         this.sharedRealm = sharedRealm;
-        pendingCollection = new Collection(sharedRealm, query, sortDescriptor, null);
+        pendingOsResults = new OsResults(sharedRealm, query, sortDescriptor, null);
 
         listener = new RealmChangeListener<PendingRow>() {
             @Override
@@ -48,7 +48,7 @@ public void onChange(PendingRow pendingRow) {
                 notifyFrontEnd();
             }
         };
-        pendingCollection.addListener(this, listener);
+        pendingOsResults.addListener(this, listener);
         this.returnCheckedRow = returnCheckedRow;
         sharedRealm.addPendingRow(this);
     }
@@ -214,8 +214,8 @@ public boolean hasColumn(String fieldName) {
     }
 
     private void clearPendingCollection() {
-        pendingCollection.removeListener(this, listener);
-        pendingCollection = null;
+        pendingOsResults.removeListener(this, listener);
+        pendingOsResults = null;
         listener = null;
         sharedRealm.removePendingRow(this);
     }
@@ -231,9 +231,9 @@ private void notifyFrontEnd() {
             return;
         }
 
-        if (pendingCollection.isValid()) {
+        if (pendingOsResults.isValid()) {
             // PendingRow will always get the first Row of the query since we only support findFirst.
-            UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+            UncheckedRow uncheckedRow = pendingOsResults.firstUncheckedRow();
             // Clear the pending collection immediately in case beginTransaction is called in the listener which will
             // execute the query again.
             clearPendingCollection();
@@ -254,7 +254,7 @@ private void notifyFrontEnd() {
 
     // Execute the query immediately and call frontend's onQueryFinished().
     public void executeQuery() {
-        if (pendingCollection == null) {
+        if (pendingOsResults == null) {
             throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 32a52cc644..bdb0cb3505 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -33,49 +33,6 @@
 @Keep
 public final class SharedRealm implements Closeable, NativeObject {
 
-    // Const value for RealmFileException conversion
-    public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
-    public static final byte FILE_EXCEPTION_KIND_BAD_HISTORY = 1;
-    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 2;
-    public static final byte FILE_EXCEPTION_KIND_EXISTS = 3;
-    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 4;
-    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 5;
-    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 6;
-    public static final byte FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE = 7;
-    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-
-    public static void initialize(File tempDirectory) {
-        if (SharedRealm.temporaryDirectory != null) {
-            // already initialized
-            return;
-        }
-
-        String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
-        if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
-            throw new IOException("failed to create temporary directory: " + temporaryDirectoryPath);
-        }
-
-        if (!temporaryDirectoryPath.endsWith("/")) {
-            temporaryDirectoryPath += "/";
-        }
-        nativeInit(temporaryDirectoryPath);
-        SharedRealm.temporaryDirectory = tempDirectory;
-    }
-
-    public static File getTemporaryDirectory() {
-        return temporaryDirectory;
-    }
-
-    private static volatile File temporaryDirectory;
-
-    private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
-    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<>();
-    public final List<WeakReference<Collection.Iterator>> iterators = new ArrayList<>();
-
-    // JNI will only hold a weak global ref to this.
-    public final RealmNotifier realmNotifier;
-    public final Capabilities capabilities;
-
     public static class VersionID implements Comparable<VersionID> {
         public final long version;
         public final long index;
@@ -140,9 +97,9 @@ public int hashCode() {
          * Callback function.
          *
          * @param sharedRealm the same {@link SharedRealm} instance which has been created from the same
-         * {@link OsRealmConfig} instance.
-         * @param oldVersion the schema version of the existing Realm file.
-         * @param newVersion the expected schema version after migration.
+         *                    {@link OsRealmConfig} instance.
+         * @param oldVersion  the schema version of the existing Realm file.
+         * @param newVersion  the expected schema version after migration.
          */
         void onMigrationNeeded(SharedRealm sharedRealm, long oldVersion, long newVersion);
     }
@@ -161,9 +118,10 @@ public int hashCode() {
     /**
      * Callback function to be called from JNI by Object Store when the schema is changed.
      */
-    @SuppressWarnings("unused")
     @Keep
     public interface SchemaChangedCallback {
+        // Called from JNI
+        @SuppressWarnings("unused")
         void onSchemaChanged();
     }
 
@@ -178,14 +136,34 @@ protected PartialSyncCallback(String className) {
             this.className = className;
         }
 
-        public abstract void onSuccess(Collection results);
+        public abstract void onSuccess(OsResults results);
+
         public abstract void onError(RealmException error);
     }
 
-    private final OsRealmConfig osRealmConfig;
+    // Const value for RealmFileException conversion
+    public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
+    public static final byte FILE_EXCEPTION_KIND_BAD_HISTORY = 1;
+    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 2;
+    public static final byte FILE_EXCEPTION_KIND_EXISTS = 3;
+    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 4;
+    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 5;
+    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 6;
+    public static final byte FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE = 7;
+
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     private final long nativePtr;
+    private final OsRealmConfig osRealmConfig;
     final NativeContext context;
     private final OsSchemaInfo schemaInfo;
+    private static volatile File temporaryDirectory;
+    // JNI will only hold a weak global ref to this.
+    public final RealmNotifier realmNotifier;
+    public final Capabilities capabilities;
+
+    private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
+    // Package protected for testing
+    final List<WeakReference<OsResults.Iterator>> iterators = new ArrayList<>();
 
     private SharedRealm(OsRealmConfig osRealmConfig) {
         Capabilities capabilities = new AndroidCapabilities();
@@ -241,6 +219,28 @@ public static SharedRealm getInstance(OsRealmConfig.Builder configBuilder) {
         return new SharedRealm(osRealmConfig);
     }
 
+    public static void initialize(File tempDirectory) {
+        if (SharedRealm.temporaryDirectory != null) {
+            // already initialized
+            return;
+        }
+
+        String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
+        if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
+            throw new IOException("failed to create temporary directory: " + temporaryDirectoryPath);
+        }
+
+        if (!temporaryDirectoryPath.endsWith("/")) {
+            temporaryDirectoryPath += "/";
+        }
+        nativeInit(temporaryDirectoryPath);
+        SharedRealm.temporaryDirectory = tempDirectory;
+    }
+
+    public static File getTemporaryDirectory() {
+        return temporaryDirectory;
+    }
+
     public void beginTransaction() {
         detachIterators();
         executePendingRowQueries();
@@ -290,12 +290,12 @@ public Table createTable(String name) {
      * Creates a {@link Table} and adds a primary key field to it. Native assertion will happen if the table with the
      * same name exists.
      *
-     * @param tableName the name of table.
+     * @param tableName           the name of table.
      * @param primaryKeyFieldName the name of primary key field.
-     * @param isStringType if this is true, the primary key field will be create as a string field. Otherwise it will
-     *                     be created as an integer field.
-     * @param isNullable if the primary key field is nullable or not.
-     * @return a creatd {@link Table} object.
+     * @param isStringType        if this is true, the primary key field will be create as a string field. Otherwise it will
+     *                            be created as an integer field.
+     * @param isNullable          if the primary key field is nullable or not.
+     * @return a newly created {@link Table} object.
      */
     public Table createTableWithPrimaryKey(String tableName, String primaryKeyFieldName, boolean isStringType,
                                            boolean isNullable) {
@@ -415,14 +415,14 @@ public void registerSchemaChangedCallback(SchemaChangedCallback callback) {
     // The iterator will iterate on a snapshot Results if it is accessed inside a transaction.
     // See https://github.com/realm/realm-java/issues/3883 for more information.
     // Should only be called by Iterator's constructor.
-    void addIterator(Collection.Iterator iterator) {
+    void addIterator(OsResults.Iterator iterator) {
         iterators.add(new WeakReference<>(iterator));
     }
 
     // The detaching should happen before transaction begins.
-    void detachIterators() {
-        for (WeakReference<Collection.Iterator> iteratorRef : iterators) {
-            Collection.Iterator iterator = iteratorRef.get();
+    private void detachIterators() {
+        for (WeakReference<OsResults.Iterator> iteratorRef : iterators) {
+            OsResults.Iterator iterator = iteratorRef.get();
             if (iterator != null) {
                 iterator.detach();
             }
@@ -432,8 +432,8 @@ void detachIterators() {
 
     // Invalidates all iterators when a remote change notification is received.
     void invalidateIterators() {
-        for (WeakReference<Collection.Iterator> iteratorRef : iterators) {
-            Collection.Iterator iterator = iteratorRef.get();
+        for (WeakReference<OsResults.Iterator> iteratorRef : iterators) {
+            OsResults.Iterator iterator = iteratorRef.get();
             if (iterator != null) {
                 iterator.invalidate();
             }
@@ -476,7 +476,7 @@ private void executePendingRowQueries() {
     /**
      * Called from JNI when the expected schema doesn't match the existing one.
      *
-     * @param callback the {@link MigrationCallback} in the {@link RealmConfiguration}.
+     * @param callback   the {@link MigrationCallback} in the {@link RealmConfiguration}.
      * @param oldVersion the schema version of the existing Realm file.
      */
     @SuppressWarnings("unused")
@@ -498,19 +498,20 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
 
     /**
      * Called from JNI when the partial sync callback is invoked from the ObjectStore.
-     * @param error if the partial sync query failed to register.
+     *
+     * @param error            if the partial sync query failed to register.
      * @param nativeResultsPtr pointer to the {@code Results} of the partial sync query.
-     * @param callback the callback registered from the user to notify the success/error of the partial sync query.
+     * @param callback         the callback registered from the user to notify the success/error of the partial sync query.
      */
     @SuppressWarnings("unused")
     private void runPartialSyncRegistrationCallback(@Nullable String error, long nativeResultsPtr,
-                                                           PartialSyncCallback callback) {
+                                                    PartialSyncCallback callback) {
         if (error != null) {
             callback.onError(new RealmException(error));
         } else {
             @SuppressWarnings("ConstantConditions")
             Table table = getTable(Table.getTableNameForClass(callback.className));
-            Collection results = new Collection(this, table, nativeResultsPtr, true);
+            OsResults results = new OsResults(this, table, nativeResultsPtr, true);
             callback.onSuccess(results);
         }
     }
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index 8a936242db..4a79c0f023 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -11,4 +11,8 @@ RUN npm install winston temp httpdispatcher@1.0.0 fs-extra moment
 COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem configuration.yml /
 COPY ros-testing-server.js /usr/bin/
 
+#Bypass the ROS license check
+ENV DOCKER_DATA_PATH /
+ENV ROS_TOS_EMAIL_ADDRESS 'ci@realm.io'
+
 CMD /usr/bin/ros-testing-server.js /tmp/ros-testing-server.log
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index 6225970ad2..d86165a6e8 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -72,7 +72,6 @@ function startRealmObjectServer(onSuccess, onError) {
             var env = Object.create( process.env );
             winston.info(env.NODE_ENV);
             env.NODE_ENV = 'development';
-            env.JENKINS = 1; // Skip email check in ROS
 
             // Manually cleanup Global Notifier State
             // See https://github.com/realm/ros/issues/437#issuecomment-335380095
