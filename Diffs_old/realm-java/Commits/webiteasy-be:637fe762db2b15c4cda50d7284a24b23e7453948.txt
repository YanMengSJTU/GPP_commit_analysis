diff --git a/CHANGELOG.md b/CHANGELOG.md
index db453459fc..2d12cd03c7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,35 +1,87 @@
-## 3.1.0 (YYYY-MM-DD)
+## 3.1.4 (2017-05-04)
+
+## Bug fixes
+
+* Added missing row validation check in certain cases on invalidated/deleted objects (#4540).
+* Initializing Realm is now more resilient if `Context.getFilesDir()` isn't working correctly (#4493).
+* `OrderedRealmCollectionSnapshot.get()` returned a wrong object (#4554).
+* `onSuccess` callback got triggered infinitely if a synced transaction was committed in the async transaction's `onSuccess` callback (#4594).
+
+## 3.1.3 (2017-04-20)
+
+### Enhancements
+
+* [ObjectServer] Resume synchronization as soon as the connectivity is back (#4141).
+
+### Bug Fixes
+
+* `equals()` and `hashCode()` of managed `RealmObject`s that come from linking objects don't work correctly (#4487).
+* Field name was missing in exception message when `null` was set to required field (#4484).
+* Now throws `IllegalStateException` when a getter of linking objects is called against deleted or not yet loaded `RealmObject`s (#4499).
+* `NullPointerException` caused by local transaction inside the listener of `findFirstAsync()`'s results (#4495).
+* Native crash when adding listeners to `RealmObject` after removing listeners from the same `RealmObject` before (#4502).
+* Native crash with "Invalid argument" error happened on some Android 7.1.1 devices when opening Realm on external storage (#4461).
+* `OrderedRealmCollectionChangeListener` didn't report change ranges correctly when circular link's field changed (#4474).
+
+### Internal
+
+* Upgraded to Realm Sync 1.6.0.
+* Upgraded to Realm Core 2.6.1.
+
+## 3.1.2 (2017-04-12)
+
+### Bug Fixes
+
+* Crash caused by JNI couldn't find `OsObject.notifyChangeListeners` when ProGuard is enabled (#4461).
+* Incompatible return type of `RealmSchema.getAll()` and `BaseRealm.getSchema()` (#4443).
+* Memory leaked when synced Realm was initialized (#4465).
+* An `IllegalStateException` will be thrown when starting iterating `OrderedRealmCollection` if the Realm is closed (#4471).
+
+## 3.1.1 (2017-04-07)
+
+### Bug Fixes
+
+* Crash caused by Listeners on `RealmObject` getting triggered the 2nd time with different changed field (#4437).
+* Unintentionally exposing `StandardRealmSchema` (#4443).
+* Workaround for crashes on specific Samsung devices which are caused by a buggy `memmove` call (#3651).
+
+## 3.1.0 (2017-04-05)
 
 ### Breaking Changes
 
-* [ObjectServer] Added `onClientResetRequired(SyncSession, ClientResetHandler)` method to the `ErrorHandler` interface (#4080).
+* Updated file format of Realm files. Existing Realm files will automatically be migrated to the new format when they are opened, but older versions of Realm cannot open these files.
+* [ObjectServer] Due to file format changes, Realm Object Server 1.3.0 or later is required.
 
 ### Enhancements
 
-* Now `targetSdkVersion` is 25.
-* Now using Gradle 3.4.1
-* The real `RealmMigrationNeededException` is now thrown instead of `IllegalArgumentException` if no migration is provided for a Realm that requires it.
-* Partial implementation of `LinkingObjects`.  There is documentation in `io.realm.annotations.LinkingObjects`.  Internal docs are in `io.realm.processor.Backlink`.
-  * Queries on linking objects do not work.  Queries like `were(...).equalTo("field.linkingObjects.id", 7).findAll()` are not yet supported.
-  * Linking objects are not yet supported on dynamic objects
-  * Migration for linking objects is not yet supported.
+* Added support for reverse relationships through the `@LinkingObjects` annotation. See `io.realm.annotations.LinkingObjects` for documentation.  
+  * This feature is in `@Beta`.
+  * Queries on linking objects do not work.  Queries like `where(...).equalTo("field.linkingObjects.id", 7).findAll()` are not yet supported.
   * Backlink verification is incomplete.  Evil code can cause native crashes.
+* The listener on `RealmObject` will only be triggered if the object changes (#3894).
+* Added `RealmObjectChangeListener` interface that provide detailed information about `RealmObject` field changes.
+* Listeners on `RealmList` and `RealmResults` will be triggered immediately when the transaction is committed on the same thread (#4245).
+* The real `RealmMigrationNeededException` is now thrown instead of `IllegalArgumentException` if no migration is provided for a Realm that requires it.
+* `RealmQuery.distinct()` can be performed on unindexed fields (#2285).
+* `targetSdkVersion` is now 25.
 * [ObjectServer] In case of a Client Reset, information about the location of the backed up Realm file is now reported through the `ErrorHandler` interface (#4080).
+* [ObjectServer] Authentication URLs now automatically append `/auth` if no other path segment is set (#4370).
 
 ### Bug Fixes
 
+* Crash with `LogicError` with `Bad version number` on notifier thread (#4369).
 * `Realm.migrateRealm(RealmConfiguration)` now fails correctly with an `IllegalArgumentException` if a `SyncConfiguration` is provided (#4075).
 * Fixed a potential cause for Realm file corruptions (never reported).
 * Add `@Override` annotation to proxy class accessors and stop using raw type in proxy classes in order to remove warnings from javac (#4329).
 * `findFirstAsync()` now returns an invalid object if there is no object matches the query condition instead of running the query repeatedly until it can find one (#4352).
-
-### Deprecated
+* [ObjectServer] Changing the log level after starting a session now works correctly (#4337).
 
 ### Internal
 
 * Using the Object Store's Session and SyncManager.
-* Upgraded to Realm Sync 1.3.2.
-* Upgraded to Realm Core 2.4.0.
+* Upgraded to Realm Sync 1.5.0.
+* Upgraded to Realm Core 2.5.1.
+* Upgraded Gradle to 3.4.1
 
 ## 3.0.0 (2017-02-28)
 
@@ -135,7 +187,7 @@
 * Updated to Realm Sync v1.0.0.
 * Added a Realm backup when receiving a Sync client reset message from the server.
 
-## 2.2.2 (2016-01-16)
+## 2.2.2 (2017-01-16)
 
 ### Object Server API Changes (In Beta)
 
diff --git a/Dockerfile b/Dockerfile
index 47bcded27d..450ccf5cff 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -53,7 +53,7 @@ RUN mkdir "${ANDROID_HOME}/licenses" && \
     echo -en "\nd23d63a1f23e25e2c7a316e29eb60396e7924281" > "${ANDROID_HOME}/licenses/android-sdk-preview-license"
 RUN echo y | android update sdk --no-ui --all --filter tools > /dev/null
 RUN echo y | android update sdk --no-ui --all --filter platform-tools | grep 'package installed'
-RUN echo y | android update sdk --no-ui --all --filter build-tools-25.0.2 | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter build-tools-25.0.3 | grep 'package installed'
 RUN echo y | android update sdk --no-ui --all --filter extra-android-m2repository | grep 'package installed'
 RUN echo y | android update sdk --no-ui --all --filter android-25 | grep 'package installed'
 
diff --git a/README.md b/README.md
index 37ee3b95d1..fcd8d6c7f3 100644
--- a/README.md
+++ b/README.md
@@ -60,7 +60,7 @@ In case you don't want to use the precompiled version, you can build Realm yours
 ### Prerequisites
 
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK **Build-Tools 25.0.2**, **Android N (API 25)** (for example through Android Studio’s **Android SDK Manager**).
+ * Download & install the Android SDK **Build-Tools 25.0.3**, **Android N (API 25)** (for example through Android Studio’s **Android SDK Manager**).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
 
  * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
diff --git a/build.gradle b/build.gradle
index 870ada9c85..3eac28d01d 100644
--- a/build.gradle
+++ b/build.gradle
@@ -195,6 +195,7 @@ task distributionPackage(type:Zip) {
     from('changelog.txt')
     from('LICENSE')
     from('version.txt')
+    from('realm.properties')
     from('realm/realm-library/build/libs') {
         include 'realm-android-${currentVersion}-javadoc.jar'
         into 'docs'
@@ -266,6 +267,37 @@ task clean {
     dependsOn cleanLocalMavenRepos
 }
 
+task manualClean {
+    description = 'Clean build files without using clean tasks defined in sub projects'
+    group = 'Clean'
+
+    doLast {
+        // clean 'build' directories
+        exec {
+            workingDir "${rootDir}"
+            commandLine 'find', '.', '-type', 'd', '-name', 'build', '-print', '-exec', 'rm', '-rf', '{}', ';', '-prune'
+        }
+
+        // clean '.externalNativeBuild' directories
+        exec {
+            workingDir "${rootDir}"
+            commandLine 'find', '.', '-type', 'd', '-name', '.externalNativeBuild', '-print', '-exec', 'rm', '-rf', '{}', ';', '-prune'
+        }
+
+        // clean '.gradle' directories except one in the root
+        exec {
+            workingDir "${rootDir}"
+            commandLine 'find', '.', '-mindepth', '2', '-type', 'd', '-name', '.gradle', '-print', '-exec', 'rm', '-rf', '{}', ';', '-prune'
+        }
+
+        // clean ${System.env.HOME}/.m2/repository/io/realm
+        exec {
+            workingDir "${rootDir}"
+            commandLine 'sh', '-c', "echo \"${System.env.HOME}/.m2/repository/io/realm\" && rm -rf \"${System.env.HOME}/.m2/repository/io/realm\""
+        }
+    }
+}
+
 task uploadDistributionPackage {
     group = 'Release'
     description = 'Upload the distribution package to S3'
diff --git a/dependencies.list b/dependencies.list
index 857165a0d4..06db1eeb3f 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.3.2
-REALM_SYNC_SHA256=be79d334ca8d87785a91fa5d68264bc62de49271936d5c19b6473f34cd47f9f0
+REALM_SYNC_VERSION=1.6.0
+REALM_SYNC_SHA256=e8a973dbe6ab33ac49d3d0e45d6b63d69cec8d1d87d9a2311fcdd02767f76cf8
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
@@ -10,4 +10,4 @@ REALM_SYNC_SHA256=be79d334ca8d87785a91fa5d68264bc62de49271936d5c19b6473f34cd47f9
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
 # install/use between 'realm' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.2.1-270
+REALM_OBJECT_SERVER_DE_VERSION=1.3.0-294
diff --git a/examples/build.gradle b/examples/build.gradle
index 32279e957a..8fd93d0f63 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,5 +1,5 @@
 project.ext.sdkVersion = 25
-project.ext.buildTools = '25.0.2'
+project.ext.buildTools = '25.0.3'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
@@ -22,11 +22,10 @@ allprojects {
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:2.3.0'
+            classpath 'com.android.tools.build:gradle:2.3.1'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
             classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
-            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
         }
     }
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index 35fb1ae090..1149f4ca38 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index ec898ce9bb..cbb9ce3c56 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Fri Mar 03 05:45:58 JST 2017
+#Wed Mar 22 16:44:51 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index 1b9bd2a6a7..c46861f443 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
@@ -29,5 +28,5 @@ android {
 
 dependencies {
     provided 'org.projectlombok:lombok:1.16.6'
-    apt 'org.projectlombok:lombok:1.16.6'
+    annotationProcessor 'org.projectlombok:lombok:1.16.6'
 }
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index a548e407de..737177a801 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.1'
+    ext.kotlin_version = '1.1.2-2'
     repositories {
         jcenter()
         mavenCentral()
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index 778186e266..dcc0165a06 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -43,6 +43,7 @@ dependencies {
     compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'
     compile 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'
     compile 'com.jakewharton.timber:timber:4.1.0'
-    compile 'com.jakewharton:butterknife:7.0.1'
+    compile 'com.jakewharton:butterknife:8.5.1'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
     compile 'me.zhanghai.android.materialprogressbar:library:1.1.4'
 }
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
index 2356f04a76..5222153ecf 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
@@ -27,7 +27,7 @@
 import android.widget.ProgressBar;
 import android.widget.TextView;
 
-import butterknife.Bind;
+import butterknife.BindView;
 import butterknife.ButterKnife;
 import io.realm.examples.newsreader.R;
 import io.realm.examples.newsreader.model.Model;
@@ -37,10 +37,10 @@
 
     private static final String KEY_STORY_ID = "key.storyId";
 
-    @Bind(R.id.details_text) TextView detailsView;
-    @Bind(R.id.read_text) TextView readView;
-    @Bind(R.id.date_text) TextView dateView;
-    @Bind(R.id.loader_view) ProgressBar loaderView;
+    @BindView(R.id.details_text) TextView detailsView;
+    @BindView(R.id.read_text) TextView readView;
+    @BindView(R.id.date_text) TextView dateView;
+    @BindView(R.id.loader_view) ProgressBar loaderView;
 
     private Toolbar toolbar;
     private DetailsPresenter presenter;
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
index b7c81a6c88..fd6030a7c0 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
@@ -34,7 +34,7 @@
 
 import java.util.List;
 
-import butterknife.Bind;
+import butterknife.BindView;
 import butterknife.ButterKnife;
 import io.realm.examples.newsreader.R;
 import io.realm.examples.newsreader.model.Model;
@@ -43,10 +43,10 @@
 
 public class MainActivity extends AppCompatActivity {
 
-    @Bind(R.id.refresh_view) SwipeRefreshLayout refreshView;
-    @Bind(R.id.list_view) ListView listView;
-    @Bind(R.id.progressbar) MaterialProgressBar progressBar;
-    @Bind(R.id.spinner) Spinner spinner;
+    @BindView(R.id.refresh_view) SwipeRefreshLayout refreshView;
+    @BindView(R.id.list_view) ListView listView;
+    @BindView(R.id.progressbar) MaterialProgressBar progressBar;
+    @BindView(R.id.spinner) Spinner spinner;
 
     MainPresenter presenter = new MainPresenter(this, Model.getInstance());
     private ArrayAdapter<NYTimesStory> adapter;
@@ -169,7 +169,7 @@ public View getView(int position, View convertView, ViewGroup parent) {
         }
 
         static class ViewHolder {
-            @Bind(android.R.id.text1) TextView titleView;
+            @BindView(android.R.id.text1) TextView titleView;
             public ViewHolder(View view) {
                 ButterKnife.bind(this, view);
             }
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index 8a42675c8a..e3080cda9f 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -62,6 +62,6 @@ realm {
 dependencies {
     compile 'com.android.support:support-v4:25.2.0'
     compile 'com.android.support:design:25.2.0'
-    compile 'com.jakewharton:butterknife:8.3.0'
-    annotationProcessor 'com.jakewharton:butterknife-compiler:8.3.0'
+    compile 'com.jakewharton:butterknife:8.5.1'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
index c3b567d105..79148eacc4 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
@@ -28,6 +28,8 @@
 import android.widget.SeekBar;
 import android.widget.TextView;
 
+import java.lang.ref.WeakReference;
+
 import io.realm.Realm;
 import io.realm.examples.threads.model.Score;
 
@@ -56,7 +58,7 @@ public void onClick(View v) {
                     asyncTask.cancel(true);
                 }
 
-                asyncTask = new ImportAsyncTask();
+                asyncTask = new ImportAsyncTask(AsyncTaskFragment.this);
                 asyncTask.execute();
             }
         });
@@ -64,6 +66,14 @@ public void onClick(View v) {
         return rootView;
     }
 
+    @Override
+    public void onStop() {
+        super.onStop();
+        if (asyncTask != null) {
+            asyncTask.cancel(false);
+        }
+    }
+
     private void showStatus(String txt) {
         Log.i(TAG, txt);
         TextView tv = new TextView(getActivity());
@@ -80,7 +90,13 @@ private void showStatus(String txt) {
     // UI thread. This means that it is not possible to reuse RealmObjects or RealmResults created
     // in doInBackground() in the other methods. Nor is it possible to use RealmObjects as Progress
     // or Result objects.
-    private class ImportAsyncTask extends AsyncTask<Void, Integer, Integer> {
+    private static class ImportAsyncTask extends AsyncTask<Void, Integer, Integer> {
+
+        private final WeakReference<AsyncTaskFragment> fragmentRef;
+
+        ImportAsyncTask(AsyncTaskFragment outerFragment) {
+            fragmentRef = new WeakReference<AsyncTaskFragment>(outerFragment);
+        }
 
         @Override
         protected Integer doInBackground(Void... params) {
@@ -106,16 +122,25 @@ public void execute(Realm realm) {
 
         @Override
         protected void onPreExecute() {
-            logsView.removeAllViews();
-            progressView.setVisibility(View.VISIBLE);
-            showStatus("Starting import");
+            final AsyncTaskFragment fragment = fragmentRef.get();
+            if (fragment == null || fragment.isDetached()) {
+                cancel(false);
+                return;
+            }
+            fragment.logsView.removeAllViews();
+            fragment.progressView.setVisibility(View.VISIBLE);
+            fragment.showStatus("Starting import");
         }
 
         @Override
         protected void onPostExecute(Integer sum) {
-            progressView.setVisibility(View.GONE);
-            showStatus(TEST_OBJECTS + " objects imported.");
-            showStatus("The total score is : " + sum);
+            final AsyncTaskFragment fragment = fragmentRef.get();
+            if (fragment == null || fragment.isDetached()) {
+                return;
+            }
+            fragment.progressView.setVisibility(View.GONE);
+            fragment.showStatus(TEST_OBJECTS + " objects imported.");
+            fragment.showStatus("The total score is : " + sum);
         }
     }
 }
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index d8af58cce0..1deb4fd325 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index fddc506432..7dd58c667b 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Thu Mar 02 03:11:23 JST 2017
+#Wed Mar 22 16:44:52 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 48a802eecf..34c574f227 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 0c43fa77cc..a5f34943f0 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Thu Mar 02 03:10:56 JST 2017
+#Wed Mar 22 16:45:06 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index 366e45e879..1149be9d86 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index b4fb3b92dc..a5e2a078c3 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Fri Mar 03 05:43:28 JST 2017
+#Wed Mar 22 16:45:01 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
index 4c79b44550..d79258c51d 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
@@ -44,7 +44,7 @@
  * }
  * </pre>
  * In the above example `Person` is related to `Dog` through the field `dog`.
- * This in turn means that an implict reverse relationship exists between the class `Dog`
+ * This in turn means that an implicit reverse relationship exists between the class `Dog`
  * and the class `Person`. This inverse relationship is made public and queryable by the `RealmResults`
  * field annotated with `@LinkingObject`. This makes it possible to query properties of the dogs owner
  * without having to manually maintain a "owner" field in the `Dog` class.
@@ -57,6 +57,8 @@
  *     <li>They are ignored when doing a `copyToRealm().`</li>
  *     <li>They are ignored when doing a `copyFromRealm().`</li>
  *     <li>They are ignored when using the various `createObjectFromJson*` and `createAllFromJson*` methods.</li>
+ *     <li>Listeners on an object with a `@LinkingObject` field will not be triggered if the linking objects change,
+ *     e.g: if another object drops a reference to this object.</li>
  * </ul>
  * <p>
  * In addition, they have the following restrictions:
@@ -92,6 +94,7 @@
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.FIELD)
+@Beta
 public @interface LinkingObjects {
     /**
      * The name of a field that contains a relation to an instance of the
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index 9fe1b93a5f..28afc97bba 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index 362711c0bf..d24868644c 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Fri Mar 03 05:41:34 JST 2017
+#Wed Mar 22 16:45:02 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/realm.properties b/realm.properties
index c2f4f60551..aa5f3da99d 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=3.4
+gradleVersion=3.4.1
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index 53a4573382..b7c98a3e74 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -7,7 +7,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.0'
+        classpath 'com.android.tools.build:gradle:2.3.1'
         classpath 'de.undercouch:gradle-download-task:3.1.1'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
diff --git a/realm/config/checkstyle/checkstyle.xml b/realm/config/checkstyle/checkstyle.xml
index 3926b73b72..1dada765c3 100644
--- a/realm/config/checkstyle/checkstyle.xml
+++ b/realm/config/checkstyle/checkstyle.xml
@@ -22,7 +22,8 @@
     <module name="RegexpSingleline">
         <property name="format" value="\s+$"/>
         <property name="message" value="Line has trailing spaces."/>
-    </module> -->
+    </module>
+    -->
 
     <!-- Space after 'for', 'if', 'while', 'try' -->
     <module name="RegexpSingleline">
@@ -38,14 +39,14 @@
 
     <module name="TreeWalker">
         <property name="cacheFile" value="bin/cachefile"/>
-
         <!-- Checks for Javadoc comments.                     -->
         <!-- See http://checkstyle.sf.net/config_javadoc.html -->
         <!--module name="JavadocMethod"/-->
         <!--module name="JavadocType"/-->
         <!--module name="JavadocVariable"/-->
         <!-- TODO: UNCOMMENT
-        <module name="JavadocStyle"/> -->
+        <module name="JavadocStyle"/>
+        -->
 
 
         <!-- Checks for Naming Conventions.                  -->
@@ -59,7 +60,8 @@
         <module name="PackageName"/>
         <module name="ParameterName"/>
         <module name="StaticVariableName"/>
-        <module name="TypeName"/> -->
+        <module name="TypeName"/>
+        -->
 
 
         <!-- Checks for imports                              -->
@@ -72,13 +74,14 @@
 
         <!-- Checks for Size Violations.                    -->
         <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <!--<module name="MethodLength"/>-->
+        <!--<module name="ParameterNumber"/>-->
         <!-- TODO: UNCOMMENT
         <module name="LineLength">
             <property name="max" value="120"/>
             <property name="severity" value="warning"/>
-        </module> -->
-        <!--<module name="MethodLength"/>-->
-        <!--<module name="ParameterNumber"/>-->
+        </module>
+        -->
 
 
         <!-- Checks for whitespace                               -->
@@ -92,7 +95,8 @@
         <module name="OperatorWrap"/>
         <module name="ParenPad"/>
         <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/> -->
+        <module name="WhitespaceAfter"/>
+        -->
         <module name="WhitespaceAround">
             <property name="tokens" value="LITERAL_DO"/>
         </module>
@@ -100,11 +104,13 @@
 
         <!-- Modifier Checks                                    -->
         <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <!-- TODO: UNCOMMENT
         <module name="ModifierOrder"/>
-        <module name="RedundantModifier"/> -->
+        <module name="RedundantModifier"/>
 
 
+        <!-- Coding Checks                                   -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+
         <!-- Checks for blocks. You know, those {}'s         -->
         <!-- See http://checkstyle.sf.net/config_blocks.html -->
         <!-- <module name="AvoidNestedBlocks"/> -->
@@ -112,25 +118,29 @@
         <!-- <module name="LeftCurly"/> -->
         <!--module name="NeedBraces"/-->
         <!-- <module name="RightCurly"/> -->
+        <module name="EmptyCatchBlock">
+            <property name="exceptionVariableName" value="expected|ignore"/>
+        </module>
 
 
         <!-- Checks for common coding problems               -->
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
         <!-- TODO: UNCOMMENT
-        <module name="CovariantEquals"/>
         <module name="EmptyStatement"/>
         <module name="EqualsAvoidNull"/>
         <module name="EqualsHashCode"/>
         <module name="HiddenField"/>
         <module name="IllegalInstantiation"/>
         <module name="InnerAssignment"/>
+        <module name="MissingSwitchDefault"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
         <module name="MagicNumber">
             <property name="severity" value="warning"/>
         </module>
-        <module name="MissingSwitchDefault"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/> -->
+        -->
+        <module name="CovariantEquals"/>
 
         <!-- Checks for class design                         -->
         <!-- See http://checkstyle.sf.net/config_design.html -->
@@ -140,15 +150,21 @@
             <property name="severity" value="warning"/>
         </module>
         <module name="HideUtilityClassConstructor"/>
-        <module name="InterfaceIsType"/> -->
-        <!--module name="VisibilityModifier"/-->
+        <module name="InterfaceIsType"/>
+        -->
+        <module name="MutableException"/>
+        <module name="VisibilityModifier">
+            <property name="allowPublicImmutableFields" value="true"/>
+        </module>
 
 
         <!-- Miscellaneous other checks.                   -->
         <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <!-- TODO: UNCOMMENT <module name="ArrayTypeStyle"/> -->
         <!--module name="FinalParameters"/-->
         <!--module name="TodoComment"/-->
-        <!-- TODO: UNCOMMENT <module name="UpperEll"/> -->
+        <!-- TODO: UNCOMMENT
+        <module name="UpperEll"/>
+        -->
+        <module name="ArrayTypeStyle"/>
     </module>
 </module>
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index b3558fded1..3123a9e708 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 31c57c1646..783df36eb6 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Thu Mar 02 03:14:47 JST 2017
+#Wed Mar 22 16:44:59 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index e6f4b4d734..b4b9663ba6 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -134,7 +134,7 @@
     private final Set<Backlink> backlinksToValidate = new HashSet<Backlink>();
 
     private boolean hasProcessedModules = false;
-    private int round;
+    private int round = -1;
 
     @Override
     public SourceVersion getSupportedSourceVersion() {
@@ -146,8 +146,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         round++;
 
         if (round == 0) {
-            RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
-            updateChecker.executeRealmVersionUpdate();
+            RealmVersionChecker.getInstance(processingEnv).executeRealmVersionUpdate();
         }
 
         if (roundEnv.errorRaised()) { return true; }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 328426dc3a..44772ce258 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -115,7 +115,6 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitPersistedFieldAccessors(writer);
         emitBacklinkFieldAccessors(writer);
         emitCreateRealmObjectSchemaMethod(writer);
-        emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetTableNameMethod(writer);
         emitGetFieldNamesMethod(writer);
@@ -570,6 +569,7 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
             writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
                 .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
                 .emitStatement("realm.checkIfValid()")
+                .emitStatement("proxyState.getRow$realm().checkIfAttached()")
                 .beginControlFlow("if (" + cacheFieldName + " == null)")
                     .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
                         backlink.getSourceClass(), backlink.getSourceField())
@@ -611,7 +611,7 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                 String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                 String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                 String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", %s, %s, %s, %s))",
+                writer.emitStatement("realmObjectSchema.add(\"%s\", %s, %s, %s, %s)",
                         fieldName,
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         primaryKeyFlag,
@@ -621,14 +621,14 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                 writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
                         .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
                         .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\")))",
+                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\"))",
                                 fieldName, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName + "\"))")
                         .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
                         .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\")))",
+                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\"))",
                                 fieldName, genericTypeSimpleName);
             }
         }
@@ -639,69 +639,6 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                 .emitEmptyLine();
     }
 
-    private void emitInitTableMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "Table", // Return type
-                "initTable", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "SharedRealm", "sharedRealm"); // Argument type & argument name
-
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
-
-        // For each field generate corresponding table index constant
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
-            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
-
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                String nullableFlag;
-                if (metadata.isNullable(field)) {
-                    nullableFlag = "Table.NULLABLE";
-                } else {
-                    nullableFlag = "Table.NOT_NULLABLE";
-                }
-                writer.emitStatement("table.addColumn(%s, \"%s\", %s)",
-                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
-                        fieldName, nullableFlag);
-            } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName)
-                        .emitStatement("%s%s.initTable(sharedRealm)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
-                        .endControlFlow()
-                        .emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", sharedRealm.getTable(\"%s%s\"))",
-                                fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-            } else if (Utils.isRealmList(field)) {
-                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName)
-                        .emitStatement("%s.initTable(sharedRealm)", Utils.getProxyClassName(genericTypeSimpleName))
-                        .endControlFlow()
-                        .emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", sharedRealm.getTable(\"%s%s\"))",
-                                fieldName, Constants.TABLE_PREFIX, genericTypeSimpleName);
-            }
-        }
-
-        for (VariableElement field : metadata.getIndexedFields()) {
-            String fieldName = field.getSimpleName().toString();
-            writer.emitStatement("table.addSearchIndex(table.getColumnIndex(\"%s\"))", fieldName);
-        }
-
-        if (metadata.hasPrimaryKey()) {
-            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            writer.emitStatement("table.setPrimaryKey(\"%s\")", fieldName);
-        } else {
-            writer.emitStatement("table.setPrimaryKey(\"\")");
-        }
-
-        writer.emitStatement("return table");
-
-        writer.endControlFlow();
-
-        writer.emitStatement("return sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 columnInfoClassName(),        // Return type
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index f02aefc106..65f4e7a843 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -38,9 +38,9 @@
 
 public class RealmProxyMediatorGenerator {
     private final String className;
-    private ProcessingEnvironment processingEnvironment;
-    private List<String> qualifiedModelClasses = new ArrayList<String>();
-    private List<String> qualifiedProxyClasses = new ArrayList<String>();
+    private final ProcessingEnvironment processingEnvironment;
+    private final List<String> qualifiedModelClasses = new ArrayList<String>();
+    private final List<String> qualifiedProxyClasses = new ArrayList<String>();
 
     public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
             String className, Set<ClassMetaData> classesToValidate) {
@@ -96,7 +96,6 @@ public void generate() throws IOException {
         writer.emitEmptyLine();
 
         emitFields(writer);
-        emitCreateTableMethod(writer);
         emitCreateRealmObjectSchema(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
@@ -135,7 +134,7 @@ private void emitCreateRealmObjectSchema(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz", "RealmSchema", "realmSchema"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.createRealmObjectSchema(realmSchema)", qualifiedProxyClasses.get(i));
@@ -145,24 +144,6 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitCreateTableMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "Table",
-                "createTable",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "SharedRealm", "sharedRealm"
-        );
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.initTable(sharedRealm)", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
@@ -173,7 +154,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 "SharedRealm", "sharedRealm",
                 "boolean", "allowExtraColumns"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.validateTable(sharedRealm, allowExtraColumns)",
@@ -192,7 +173,7 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.getFieldNames()", qualifiedProxyClasses.get(i));
@@ -210,7 +191,7 @@ private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.getTableName()", qualifiedProxyClasses.get(i));
@@ -236,7 +217,7 @@ private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
         writer.beginControlFlow("try")
                 .emitStatement("objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields)");
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(new %s())", qualifiedProxyClasses.get(i));
@@ -269,7 +250,7 @@ private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
         writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
         writer.emitEmptyLine();
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
@@ -412,7 +393,7 @@ private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcept
                 Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Arrays.asList("JSONException")
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", qualifiedProxyClasses.get(i));
@@ -431,7 +412,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                 Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
                 Arrays.asList("java.io.IOException")
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", qualifiedProxyClasses.get(i));
@@ -453,7 +434,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
         writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass()");
         writer.emitEmptyLine();
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
@@ -492,6 +473,26 @@ private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter write
         }
     }
 
+    // Identical to the above, but eliminates the un-needed "else" clauses for, e.g., return statements
+    private void emitMediatorShortCircuitSwitch(ProxySwitchStatement statement, JavaWriter writer) throws IOException {
+        emitMediatorShortCircuitSwitch(statement, writer, true);
+    }
+
+    private void emitMediatorShortCircuitSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
+            throws IOException {
+        if (nullPointerCheck) {
+            writer.emitStatement("checkClass(clazz)");
+            writer.emitEmptyLine();
+        }
+        for (int i = 0; i < qualifiedModelClasses.size(); i++) {
+            writer.beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses.get(i));
+            statement.emitStatement(i, writer);
+            writer.endControlFlow();
+        }
+        writer.emitStatement("throw getMissingProxyClassException(clazz)");
+    }
+
+
     private String getProxyClassName(String clazz) {
         return clazz + Constants.PROXY_SUFFIX;
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index f8cb971a58..8eeb68202c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -397,6 +397,7 @@ public final AllTypesColumnInfo clone() {
     public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
         BaseRealm realm = proxyState.getRealm$realm();
         realm.checkIfValid();
+        proxyState.getRow$realm().checkIfAttached();
         if (parentObjectsBacklinks == null) {
             parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
         }
@@ -406,51 +407,26 @@ public final AllTypesColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("AllTypes")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
-            realmObjectSchema.add(new Property("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
             if (!realmSchema.contains("AllTypes")) {
                 AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
             }
-            realmObjectSchema.add(new Property("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes")));
+            realmObjectSchema.add("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes"));
             if (!realmSchema.contains("AllTypes")) {
                 AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
             }
-            realmObjectSchema.add(new Property("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes")));
+            realmObjectSchema.add("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes"));
             return realmObjectSchema;
         }
         return realmSchema.get("AllTypes");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            Table table = sharedRealm.getTable("class_AllTypes");
-            table.addColumn(RealmFieldType.STRING, "columnString", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "columnLong", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.FLOAT, "columnFloat", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DOUBLE, "columnDouble", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "columnBoolean", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DATE, "columnDate", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BINARY, "columnBinary", Table.NOT_NULLABLE);
-            if (!sharedRealm.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(sharedRealm);
-            }
-            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", sharedRealm.getTable("class_AllTypes"));
-            if (!sharedRealm.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(sharedRealm);
-            }
-            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", sharedRealm.getTable("class_AllTypes"));
-            table.addSearchIndex(table.getColumnIndex("columnString"));
-            table.setPrimaryKey("columnString");
-            return table;
-        }
-        return sharedRealm.getTable("class_AllTypes");
-    }
-
     public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_AllTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index c630f1f176..5a07ed0d92 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -191,28 +191,15 @@ public final BooleansColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("Booleans")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("Booleans");
-            realmObjectSchema.add(new Property("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
             return realmObjectSchema;
         }
         return realmSchema.get("Booleans");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_Booleans")) {
-            Table table = sharedRealm.getTable("class_Booleans");
-            table.addColumn(RealmFieldType.BOOLEAN, "done", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "isReady", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "mCompleted", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "anotherBoolean", Table.NOT_NULLABLE);
-            table.setPrimaryKey("");
-            return table;
-        }
-        return sharedRealm.getTable("class_Booleans");
-    }
-
     public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_Booleans")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index fa041cfb80..c91b122f0c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -843,68 +843,35 @@ public final NullTypesColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("NullTypes")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("NullTypes");
-            realmObjectSchema.add(new Property("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
             if (!realmSchema.contains("NullTypes")) {
                 NullTypesRealmProxy.createRealmObjectSchema(realmSchema);
             }
-            realmObjectSchema.add(new Property("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes")));
+            realmObjectSchema.add("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes"));
             return realmObjectSchema;
         }
         return realmSchema.get("NullTypes");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_NullTypes")) {
-            Table table = sharedRealm.getTable("class_NullTypes");
-            table.addColumn(RealmFieldType.STRING, "fieldStringNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.STRING, "fieldStringNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.BINARY, "fieldBytesNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BINARY, "fieldBytesNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldByteNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldByteNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldShortNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldShortNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldIntegerNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldIntegerNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldLongNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldLongNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.FLOAT, "fieldFloatNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.FLOAT, "fieldFloatNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.DATE, "fieldDateNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DATE, "fieldDateNull", Table.NULLABLE);
-            if (!sharedRealm.hasTable("class_NullTypes")) {
-                NullTypesRealmProxy.initTable(sharedRealm);
-            }
-            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", sharedRealm.getTable("class_NullTypes"));
-            table.setPrimaryKey("");
-            return table;
-        }
-        return sharedRealm.getTable("class_NullTypes");
-    }
-
     public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_NullTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index e72e461844..4460594efa 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -31,26 +31,14 @@
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
-    @Override
-    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
-        checkClass(clazz);
-
-        if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.initTable(sharedRealm);
-        } else {
-            throw getMissingProxyClassException(clazz);
-        }
-    }
-
     @Override
     public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -59,9 +47,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.validateTable(sharedRealm, allowExtraColumns);
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -70,9 +57,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.getFieldNames();
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -81,9 +67,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.getTableName();
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -95,9 +80,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
 
             if (clazz.equals(some.test.AllTypes.class)) {
                 return clazz.cast(new io.realm.AllTypesRealmProxy());
-            } else {
-                throw getMissingProxyClassException(clazz);
             }
+            throw getMissingProxyClassException(clazz);
         } finally {
             objectContext.clear();
         }
@@ -116,9 +100,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.copyOrUpdate(realm, (some.test.AllTypes) obj, update, cache));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -208,9 +191,8 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -220,9 +202,8 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.createUsingJsonStream(realm, reader));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -233,9 +214,8 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.createDetachedCopy((some.test.AllTypes) realmObject, 0, maxDepth, cache));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 8336e88e4b..030081db38 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -145,24 +145,13 @@ public final SimpleColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("Simple")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("Simple");
-            realmObjectSchema.add(new Property("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
             return realmObjectSchema;
         }
         return realmSchema.get("Simple");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_Simple")) {
-            Table table = sharedRealm.getTable("class_Simple");
-            table.addColumn(RealmFieldType.STRING, "name", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "age", Table.NOT_NULLABLE);
-            table.setPrimaryKey("");
-            return table;
-        }
-        return sharedRealm.getTable("class_Simple");
-    }
-
     public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_Simple")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 7041fd0919..8d8616a30d 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -29,13 +29,15 @@ if (!ext.coreArchiveDir) {
 }
 ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/realm-sync-android-${project.coreVersion}.tar.gz")
 ext.coreDistributionDir = file("${projectDir}/distribution/realm-core/")
-ext.coreDir = file("${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
+ext.coreDir = file(project.coreSourcePath ?
+        "${project.coreSourcePath}/android-lib" :
+        "${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
 ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE')
 ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
 
 android {
     compileSdkVersion 25
-    buildToolsVersion '25.0.2'
+    buildToolsVersion '25.0.3'
 
     defaultConfig {
         minSdkVersion 9
@@ -46,11 +48,11 @@ android {
         externalNativeBuild {
             cmake {
                 arguments "-DREALM_CORE_DIST_DIR:STRING=${project.coreDir.getAbsolutePath()}",
-                          // FIXME:
-                          // This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
-                          // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
-                          // JNI build currently (lack of lto linking support).
-                          // This file should be removed and use the one from Android SDK cmake package when it supports lto.
+                        // FIXME:
+                        // This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
+                        // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
+                        // JNI build currently (lack of lto linking support).
+                        // This file should be removed and use the one from Android SDK cmake package when it supports lto.
                         "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
                 if (project.ccachePath) arguments "-DNDK_CCACHE=$project.ccachePath"
                 if (project.lcachePath) arguments "-DNDK_LCACHE=$project.lcachePath"
@@ -112,6 +114,15 @@ android {
             consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-objectServer.pro'
         }
     }
+
+    variantFilter { variant ->
+        def names = variant.flavors*.name
+
+        // Ignore the objectServer flavour when building from core source.
+        if (coreSourcePath && names.contains("objectServer")) {
+            variant.ignore = true
+        }
+    }
 }
 
 project.afterEvaluate {
@@ -183,7 +194,7 @@ task javadoc(type: Javadoc) {
         links "http://reactivex.io/RxJava/javadoc/"
         linksOffline "https://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
 
-        tags = [ betaTag ]
+        tags = [betaTag]
     }
     exclude '**/internal/**'
     exclude '**/BuildConfig.java'
@@ -236,28 +247,37 @@ task pmd(type: Pmd) {
     }
 }
 
+// Configure Checkstyle
+// Android sourceSets are not sourceSets, so we can't confgure this with the DSL.
 task checkstyle(type: Checkstyle) {
-    group = 'Test'
+    group = 'Verification'
 
     source 'src'
-    include '**/*.java'
-    exclude '**/gen/**'
-    exclude '**/R.java'
-    exclude '**/BuildConfig.java'
+    include '*/java/**/*.java'
+    exclude 'benchmarks/**'
+    // Ingore tests for now.
+    exclude '*Test*/**'
 
-    def configProps = ['proj.module.dir': projectDir.absolutePath]
-    configProperties configProps
+    // empty classpath
+    classpath = files()
+}
+
+checkstyle {
+    toolVersion ="7.6"
 
     configFile = file("${projectDir}/../config/checkstyle/checkstyle.xml")
 
-    // empty classpath
-    classpath = files()
+    def configProps = ['proj.module.dir': projectDir.absolutePath]
+    configProperties configProps
+
+    ignoreFailures = true
 }
+check.dependsOn tasks.checkstyle
 
 // Configuration options can be found here:
 // http://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html
 task connectedBenchmarks(type: GradleBuild) {
-    description =  'Run all benchmarks on connected devices'
+    description = 'Run all benchmarks on connected devices'
     group = 'Verification'
     buildFile = file("${projectDir}/build.gradle")
     startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.package', 'io.realm.benchmarks')
@@ -265,7 +285,7 @@ task connectedBenchmarks(type: GradleBuild) {
 }
 
 task connectedUnitTests(type: GradleBuild) {
-    description =  'Run all unit tests on connected devices'
+    description = 'Run all unit tests on connected devices'
     group = 'Verification'
     buildFile = file("${projectDir}/build.gradle")
     startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.notPackage', 'io.realm.benchmarks')
@@ -363,7 +383,7 @@ publishing {
                 accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
                 secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
             }
-            if(project.version.endsWith('-SNAPSHOT')) {
+            if (project.version.endsWith('-SNAPSHOT')) {
                 url "s3://realm-ci-artifacts/maven/snapshots/"
             } else {
                 url "s3://realm-ci-artifacts/maven/releases/"
@@ -403,7 +423,7 @@ task downloadCore() {
         return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
     }
 
-    def calcSha256Hash = {File targetFile ->
+    def calcSha256Hash = { File targetFile ->
         MessageDigest sha = MessageDigest.getInstance("SHA-256")
         Formatter hexHash = new Formatter()
         sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
@@ -487,9 +507,14 @@ task deployCore(group: 'build setup', description: 'Deploy the latest version of
         coreSourcePath ? compileCore : downloadCore
     }
 
+    // Build with the output from core source dir. No need to deploy anything.
+    onlyIf {
+        return !coreSourcePath
+    }
+
     outputs.upToDateWhen {
-        // Clean up the coreDir if it is newly downloaded or compiled from source
-        if (coreDownloaded || coreSourcePath) {
+        // Clean up the coreDir if it is newly downloaded
+        if (coreDownloaded) {
             return false
         }
 
@@ -580,52 +605,52 @@ android.productFlavors.all { flavor ->
         dependsOn "assemble${flavor.name.capitalize()}"
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
     }
 
     task("bintraySources${flavor.name.capitalize()}", type: Exec) {
         dependsOn sourcesJar
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
     }
 
     task("bintrayJavadoc${flavor.name.capitalize()}", type: Exec) {
         dependsOn javadocJar
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
     }
 
     task("bintrayPom${flavor.name.capitalize()}", type: Exec) {
         dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
     }
 
     // OJO
@@ -729,11 +754,11 @@ def checkNdk(String ndkPath) {
     }
     if (detectedNdkVersion != project.ndkVersion) {
         throw new GradleException("Your NDK version: ${detectedNdkVersion}."
-                +" Realm JNI must be compiled with the version ${project.ndkVersion} of NDK.")
+                + " Realm JNI must be compiled with the version ${project.ndkVersion} of NDK.")
     }
 }
 
-def getValueFromPropertiesFile(File propFile, String key) {
+static def getValueFromPropertiesFile(File propFile, String key) {
     if (!propFile.isFile() || !propFile.canRead()) {
         return null
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index ba33c31d0c..f79aacad6f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -142,7 +142,7 @@ public void insert_realmModel() {
         allTypes.columnBoolean = false;
         allTypes.columnBinary = new byte[]{1, 2, 3};
         allTypes.columnDate = new Date();
-        allTypes.columnDouble = 3.1415;
+        allTypes.columnDouble = Math.PI;
         allTypes.columnFloat = 1.234567f;
         allTypes.columnString = "test data";
         allTypes.columnByte = 0x2A;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 3f99fdf619..9a38ec50b1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -123,7 +123,7 @@ private void fillObject(int index, int totalObjects, AllJavaTypes obj) {
         obj.setFieldBoolean(((index % 2) == 0));
         obj.setFieldBinary(new byte[]{1, 2, 3});
         obj.setFieldDate(new Date(YEAR_MILLIS * 20 * (index - totalObjects / 2)));
-        obj.setFieldDouble(3.1415 + index);
+        obj.setFieldDouble(Math.PI + index);
         obj.setFieldFloat(1.234567f + index);
         obj.setFieldString("test data " + index);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index fac6bd2193..cdd594baf3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -598,25 +598,29 @@ public void setter_nullOnRequiredFieldsThrows() {
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
+                String fieldName = null;
                 try {
                     switch (type) {
                         case OBJECT: continue; // Ignore
-                        case LIST: dObj.setNull(NullTypes.FIELD_LIST_NULL); break;
-                        case BOOLEAN: dObj.setNull(NullTypes.FIELD_BOOLEAN_NOT_NULL); break;
-                        case BYTE: dObj.setNull(NullTypes.FIELD_BYTE_NOT_NULL); break;
-                        case SHORT: dObj.setNull(NullTypes.FIELD_SHORT_NOT_NULL); break;
-                        case INT: dObj.setNull(NullTypes.FIELD_INTEGER_NOT_NULL); break;
-                        case LONG: dObj.setNull(NullTypes.FIELD_LONG_NOT_NULL); break;
-                        case FLOAT: dObj.setNull(NullTypes.FIELD_FLOAT_NOT_NULL); break;
-                        case DOUBLE: dObj.setNull(NullTypes.FIELD_DOUBLE_NOT_NULL); break;
-                        case STRING: dObj.setNull(NullTypes.FIELD_STRING_NOT_NULL); break;
-                        case BINARY: dObj.setNull(NullTypes.FIELD_BYTES_NOT_NULL); break;
-                        case DATE: dObj.setNull(NullTypes.FIELD_DATE_NOT_NULL); break;
+                        case LIST: fieldName = NullTypes.FIELD_LIST_NULL; break;
+                        case BOOLEAN: fieldName = NullTypes.FIELD_BOOLEAN_NOT_NULL; break;
+                        case BYTE: fieldName = NullTypes.FIELD_BYTE_NOT_NULL; break;
+                        case SHORT: fieldName = NullTypes.FIELD_SHORT_NOT_NULL; break;
+                        case INT: fieldName = NullTypes.FIELD_INTEGER_NOT_NULL; break;
+                        case LONG: fieldName = NullTypes.FIELD_LONG_NOT_NULL; break;
+                        case FLOAT: fieldName = NullTypes.FIELD_FLOAT_NOT_NULL; break;
+                        case DOUBLE: fieldName = NullTypes.FIELD_DOUBLE_NOT_NULL; break;
+                        case STRING: fieldName = NullTypes.FIELD_STRING_NOT_NULL; break;
+                        case BINARY: fieldName = NullTypes.FIELD_BYTES_NOT_NULL; break;
+                        case DATE: fieldName = NullTypes.FIELD_DATE_NOT_NULL; break;
                         default:
                             fail("Unknown type: " + type);
                     }
+
+                    dObj.setNull(fieldName);
                     fail("Setting value to null should throw: " + type);
                 } catch (IllegalArgumentException ignored) {
+                    assertTrue(ignored.getMessage().contains(fieldName));
                 }
             }
         } finally {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index b5b1202400..5d5b6ed371 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -93,7 +93,7 @@ private void populateTestRealm(DynamicRealm realm, int objects) {
             allTypes.setBoolean(AllTypes.FIELD_BOOLEAN, (i % 3) == 0);
             allTypes.setBlob(AllTypes.FIELD_BINARY, new byte[]{1, 2, 3});
             allTypes.setDate(AllTypes.FIELD_DATE, new Date());
-            allTypes.setDouble(AllTypes.FIELD_DOUBLE, 3.1415D + i);
+            allTypes.setDouble(AllTypes.FIELD_DOUBLE, Math.PI + i);
             allTypes.setFloat(AllTypes.FIELD_FLOAT, 1.234567F + i);
             allTypes.setString(AllTypes.FIELD_STRING, "test data " + i);
             allTypes.setLong(AllTypes.FIELD_LONG, i);
@@ -356,7 +356,7 @@ public void findFirstAsync() {
                 .between(AllTypes.FIELD_LONG, 4, 9)
                 .findFirstAsync();
         assertFalse(allTypes.isLoaded());
-        looperThread.keepStrongReference.add(allTypes);
+        looperThread.keepStrongReference(allTypes);
         allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
             public void onChange(DynamicRealmObject object) {
@@ -389,7 +389,7 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 looperThread.testComplete();
             }
         });
-        looperThread.keepStrongReference.add(allTypes);
+        looperThread.keepStrongReference(allTypes);
     }
 
     @Test
@@ -414,15 +414,15 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 looperThread.testComplete();
             }
         });
-        looperThread.keepStrongReference.add(allTypes);
+        looperThread.keepStrongReference(allTypes);
     }
 
     // Initializes a Dynamic Realm used by the *Async tests and keeps it ref in the looperThread.
     private DynamicRealm initializeDynamicRealm() {
-        RealmConfiguration defaultConfig = looperThread.realmConfiguration;
+        RealmConfiguration defaultConfig = looperThread.getConfiguration();
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
         populateTestRealm(dynamicRealm, 10);
-        looperThread.keepStrongReference.add(dynamicRealm);
+        looperThread.keepStrongReference(dynamicRealm);
         return dynamicRealm;
     }
 
@@ -531,8 +531,8 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 signalCallbackDone.run();
             }
         });
-        looperThread.keepStrongReference.add(realmResults1);
-        looperThread.keepStrongReference.add(realmResults2);
+        looperThread.keepStrongReference(realmResults1);
+        looperThread.keepStrongReference(realmResults2);
     }
 
     @Test
@@ -675,7 +675,7 @@ public void equalTo_noFieldObjectShouldThrow() {
         dynamicRealm.commitTransaction();
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Field 'nonExisting' does not exist.");
+        thrown.expectMessage("Invalid query: field 'nonExisting' does not exist in table 'NoField'.");
         dynamicRealm.where(className).equalTo("nonExisting", 1);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 1ea36519e9..0ec3cd03fe 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -96,7 +96,7 @@ public void iOSDataTypes() throws IOException {
                 assertEquals(1.234D + (double)i, obj.getDoubleCol(), 0D);
                 assertArrayEquals(new byte[]{1, 2, 3}, obj.getByteCol());
                 assertEquals("String " + Integer.toString(i), obj.getStringCol());
-                assertEquals(new Date((1000 + i) * 1000), obj.getDateCol());
+                assertEquals(new Date((1000L + i) * 1000), obj.getDateCol());
                 assertEquals("Foo", result.get(i).getChild().getName());
                 assertEquals(10, result.get(i).getChildren().size());
                 for (int j = 0; j < 10; j++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index 302c3952e8..b729034259 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -46,6 +46,7 @@
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -151,49 +152,27 @@ public void basic_multipleReferencesFromParentList() {
         assertEquals(parent, child.getListParents().last());
     }
 
-    // A listener registered on the backlinked object should be called when a commit adds a backlink
+    // This test reproduces https://github.com/realm/realm-java/issues/4487
     @Test
-    @RunTestInLooperThread
-    public void notification_onCommitModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
-        looperThreadRealm.commitTransaction();
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
+    public void issue4487_checkIfTableIsCorrect() {
+        realm.beginTransaction();
+        final BacklinksTarget target = realm.createObject(BacklinksTarget.class);
+        target.setId(1);
+        final BacklinksSource source = realm.createObject(BacklinksSource.class);
+        source.setChild(target);
+        realm.commitTransaction();
 
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        parent.setFieldObject(child);
-        looperThreadRealm.commitTransaction();
+        final RealmResults<BacklinksSource> parents = target.getParents();
+        final BacklinksSource sourceFromBacklinks = parents.first();
 
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
+        assertEquals(source, sourceFromBacklinks);
     }
 
-
-
     // A listener registered on the backlinked object should not be called after the listener is removed
     @Test
     @RunTestInLooperThread
     public void notification_notSentAfterUnregisterListenerModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
+        final Realm looperThreadRealm = looperThread.getRealm();
 
         looperThreadRealm.beginTransaction();
         AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
@@ -224,86 +203,11 @@ public void run(Realm realm) {
             child, parent);
     }
 
-    // A listener registered on the backlinked object should be called when a backlinked object is deleted
-    @Test
-    @RunTestInLooperThread
-    public void notification_onDeleteModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        parent.setFieldObject(child);
-        looperThreadRealm.commitTransaction();
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
-
-        looperThreadRealm.beginTransaction();
-        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
-        looperThreadRealm.commitTransaction();
-
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
-    }
-
-    // A listener registered on the backlinked object is called
-    // for an unrelated change on the an object of the same type!!
-    // This test exists only to document existing (but odd) behavior.
-    @Test
-    @RunTestInLooperThread
-    public void notification_notSentOnUnrelatedChangeModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        looperThreadRealm.commitTransaction();
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
-
-        looperThreadRealm.beginTransaction();
-        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
-        looperThreadRealm.commitTransaction();
-
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
-    }
-
     // A listener registered on the backlinked field should be called when a commit adds a backlink
     @Test
     @RunTestInLooperThread
     public void notification_onCommitRealmResults() {
-        final Realm looperThreadRealm = looperThread.realm;
+        final Realm looperThreadRealm = looperThread.getRealm();
 
         looperThreadRealm.beginTransaction();
         AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
@@ -339,7 +243,7 @@ public void run(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void notification_notSentAfterUnregisterListenerRealmResults() {
-        final Realm looperThreadRealm = looperThread.realm;
+        final Realm looperThreadRealm = looperThread.getRealm();
 
         looperThreadRealm.beginTransaction();
         AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
@@ -375,7 +279,7 @@ public void run(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void notification_onDeleteRealmResults() {
-        final Realm looperThreadRealm = looperThread.realm;
+        final Realm looperThreadRealm = looperThread.getRealm();
 
         looperThreadRealm.beginTransaction();
         AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
@@ -412,7 +316,7 @@ public void run(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void notification_notSentOnUnrelatedChangeRealmResults() {
-        final Realm looperThreadRealm = looperThread.realm;
+        final Realm looperThreadRealm = looperThread.getRealm();
 
         looperThreadRealm.beginTransaction();
         AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
@@ -498,61 +402,103 @@ public void json_updateList() {
         assertTrue(parents.contains(parent));
     }
 
-    // A JSON update should generate a notifcation
     @Test
     @RunTestInLooperThread
-    public void json_jsonUpdateCausesNotification() {
-        final Realm looperThreadRealm = looperThread.realm;
+    public void linkingObjects_IllegalStateException_ifNotYetLoaded() {
+        final Realm realm = looperThread.getRealm();
 
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 2);
-        parent.setFieldObject(child);
-        looperThreadRealm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target = realm.createObject(BacklinksTarget.class);
+                target.setId(1);
 
-        RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
-        assertNotNull(results);
-        assertEquals(results.size(), 1);
-        child = results.first();
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target);
+            }
+        });
 
-        RealmResults<AllJavaTypes> parents = child.getObjectParents();
-        assertNotNull(parents);
-        assertEquals(1, parents.size());
 
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
+        final BacklinksTarget targetAsync = realm.where(BacklinksTarget.class)
+                .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirstAsync();
+        // precondition
+        assertFalse(targetAsync.isLoaded());
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection ResultOfMethodCallIgnored
+        targetAsync.getParents();
+        fail();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void linkingObjects_IllegalStateException_ifDeleted() {
+        final Realm realm = looperThread.getRealm();
+
+        realm.executeTransaction(new Realm.Transaction() {
             @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
+            public void execute(Realm realm) {
+                final BacklinksTarget target = realm.createObject(BacklinksTarget.class);
+                target.setId(1);
+
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target);
             }
-        };
-        child.addChangeListener(listener);
+        });
 
-        looperThreadRealm.beginTransaction();
-        try {
-            looperThreadRealm.createOrUpdateAllFromJson(AllJavaTypes.class, "[{ \"fieldId\" : 2, \"fieldObject\" : null }]");
-        } catch (RealmException e) {
-            fail("Failed loading JSON" + e);
-        }
-        looperThreadRealm.commitTransaction();
+        final BacklinksTarget target = realm.where(BacklinksTarget.class)
+                .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
 
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
-                    assertNotNull(results);
-                    assertEquals(results.size(), 1);
-                    AllJavaTypes child = results.first();
-
-                    RealmResults<AllJavaTypes> parents = child.getObjectParents();
-                    assertNotNull(parents);
-                    assertEquals(0, parents.size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                target.deleteFromRealm();
+            }
+        });
+
+        // precondition
+        assertFalse(target.isValid());
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection ResultOfMethodCallIgnored
+        target.getParents();
+        fail();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void linkingObjects_IllegalStateException_ifDeletedIndirectly() {
+        final Realm realm = looperThread.getRealm();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target1);
+            }
+        });
+
+        final BacklinksTarget target = realm.where(BacklinksTarget.class)
+                .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // delete target object indirectly
+                realm.where(BacklinksTarget.class).findAll().deleteAllFromRealm();
+            }
+        });
+
+        // precondition
+        assertFalse(target.isValid());
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection ResultOfMethodCallIgnored
+        target.getParents();
+        fail();
     }
 
     /**
@@ -848,7 +794,9 @@ private void verifyPostConditions(final Realm realm, final PostConditions test,
         realm.commitTransaction();
 
         // Runnable is guaranteed to be enqueued on the Looper queue, after the notifications
-        looperThread.keepStrongReference.addAll(Arrays.asList(refs));
+        for (Object ref : refs) {
+            looperThread.keepStrongReference(ref);
+        }
         looperThread.postRunnable(
             new Runnable() {
                 @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 9cd511e157..387920dc58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -499,11 +499,11 @@ public void avg() {
         // See setUp() for values of fields.
         // N = TEST_DATA_SIZE
 
-        // Type: double; a = 3.1415
+        // Type: double; a = Math.PI
         // a, a+1, ..., a+i, ..., a+N-1
-        // sum = 3.1415*N + N*(N-1)/2
-        // average = sum/N = 3.1415+(N-1)/2
-        double average = 3.1415 + (N - 1.0) * 0.5;
+        // sum = Math.PI*N + N*(N-1)/2
+        // average = sum/N = Math.PI+(N-1)/2
+        double average = Math.PI + (N - 1.0) * 0.5;
         assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);
 
         // Type: long
@@ -575,7 +575,7 @@ public void aggregates_deleteLastRow() {
         assertEquals(sizeAfterRemove - 1, collection.max(AllJavaTypes.FIELD_LONG).intValue());
         // Sum of numbers 0 to M-1: (M-1)*M/2
         assertEquals((sizeAfterRemove - 1) * sizeAfterRemove / 2, collection.sum(AllJavaTypes.FIELD_LONG).intValue());
-        double average = 3.1415 + (sizeAfterRemove - 1.0) * 0.5;
+        double average = Math.PI + (sizeAfterRemove - 1.0) * 0.5;
         assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);
         assertEquals(new Date(YEAR_MILLIS * 20 * (sizeAfterRemove / 2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
         assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 8e3f499af6..9c0ed01755 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -28,7 +28,6 @@
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -163,7 +162,7 @@ public void onChange(Realm object) {
             }
         };
 
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.addChangeListener(listener);
         realm.addChangeListener(listener);
         realm.addChangeListener(new RealmChangeListener<Realm>() {
@@ -181,10 +180,10 @@ public void onChange(Realm object) {
 
     @Test
     public void notificationsNumber() throws InterruptedException, ExecutionException {
+        final CountDownLatch isReady = new CountDownLatch(1);
+        final CountDownLatch isRealmOpen = new CountDownLatch(1);
         final AtomicInteger counter = new AtomicInteger(0);
-        final AtomicBoolean isReady = new AtomicBoolean(false);
         final Looper[] looper = new Looper[1];
-        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
         final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -202,12 +201,12 @@ public Boolean call() throws Exception {
                     looper[0] = Looper.myLooper();
                     realm = Realm.getInstance(realmConfig);
                     realm.addChangeListener(listener);
-                    isReady.set(true);
+                    isReady.countDown();
                     Looper.loop();
                 } finally {
                     if (realm != null) {
                         realm.close();
-                        isRealmOpen.set(false);
+                        isRealmOpen.countDown();
                     }
                 }
                 return true;
@@ -215,10 +214,7 @@ public Boolean call() throws Exception {
         });
 
         // Waits until the looper in the background thread is started.
-        while (!isReady.get()) {
-            Thread.sleep(5);
-        }
-        Thread.sleep(100);
+        TestHelper.awaitOrFail(isReady);
 
         // Triggers OnRealmChanged on background thread.
         realm = Realm.getInstance(realmConfig);
@@ -236,9 +232,7 @@ public Boolean call() throws Exception {
         }
 
         // Waits until the Looper thread is actually closed.
-        while (isRealmOpen.get()) {
-            Thread.sleep(5);
-        }
+        TestHelper.awaitOrFail(isRealmOpen);
 
         assertEquals(1, counter.get());
         RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
@@ -263,7 +257,8 @@ public Boolean call() throws Exception {
                 if (dogs.size() != 0) {
                     return false;
                 }
-                addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages.
+                // Wait for main thread to add update messages.
+                addHandlerMessages.await(TestHelper.VERY_SHORT_WAIT_SECS, TimeUnit.SECONDS);
 
                 // Creates a Handler for the thread now. All message and references for the notification handler will be
                 // cleared once we call close().
@@ -293,7 +288,7 @@ public void run() {
         });
 
         // Waits until the looper is started on a background thread.
-        backgroundLooperStarted.await(1, TimeUnit.SECONDS);
+        backgroundLooperStarted.await(TestHelper.VERY_SHORT_WAIT_SECS, TimeUnit.SECONDS);
 
         // Executes a transaction that will trigger a Realm update.
         Realm realm = Realm.getInstance(realmConfig);
@@ -318,7 +313,7 @@ public void run() {
     @RunTestInLooperThread
     public void globalListener_looperThread_triggeredByLocalCommit() {
         final AtomicInteger success = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -336,7 +331,7 @@ public void onChange(Realm object) {
     @RunTestInLooperThread
     public void globalListener_looperThread_triggeredByRemoteCommit() {
         final AtomicInteger success = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -362,7 +357,7 @@ public void onChange(Realm object) {
                 looperThread.testComplete();
             }
         };
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.addChangeListener(listener);
         realm.beginTransaction();
         realm.commitTransaction();
@@ -371,7 +366,7 @@ public void onChange(Realm object) {
     @Test
     @RunTestInLooperThread
     public void addRemoveListenerConcurrency() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final AtomicInteger counter1 = new AtomicInteger(0);
         final AtomicInteger counter2 = new AtomicInteger(0);
         final AtomicInteger counter3 = new AtomicInteger(0);
@@ -448,7 +443,7 @@ public void realmNotificationOrder() {
         // Test both ways to check accidental ordering from unordered collections.
         final AtomicInteger listenerACalled = new AtomicInteger(0);
         final AtomicInteger listenerBCalled = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         final RealmChangeListener<Realm> listenerA = new RealmChangeListener<Realm>() {
 
@@ -545,8 +540,8 @@ public void onChange(Realm object) {
         realm.commitTransaction();
         // Any REALM_CHANGED message should now only reach the open Handler on Thread1.
         try {
-            // TODO: Waiting 5 seconds is not a reliable condition. Figure out a better way for this.
-            if (!handlerNotified.await(5, TimeUnit.SECONDS)) {
+            // TODO: Waiting a few seconds is not a reliable condition. Figure out a better way for this.
+            if (!handlerNotified.await(TestHelper.SHORT_WAIT_SECS,  TimeUnit.SECONDS)) {
                 fail("Handler didn't receive message");
             }
         } finally {
@@ -574,11 +569,8 @@ public void run() {
                 realm.setAutoRefresh(false);
                 TestHelper.quitLooperOrFail();
                 backgroundLooperStartedAndStopped.countDown();
-                try {
-                    mainThreadCommitCompleted.await();
-                } catch (InterruptedException e) {
-                    fail("Thread interrupted"); // This will prevent backgroundThreadStopped from being called.
-                }
+                // This will prevent backgroundThreadStopped from being called.
+                TestHelper.awaitOrFail(mainThreadCommitCompleted);
                 realm.close();
                 backgroundThreadStopped.countDown();
             }
@@ -691,12 +683,12 @@ public void onChange(Realm object) {
     @Test
     @RunTestInLooperThread
     public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         final AtomicBoolean resultsListenerDone = new AtomicBoolean(false);
         final AtomicBoolean realmListenerDone = new AtomicBoolean(false);
 
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         assertTrue(dogs.load());
         assertEquals(0, dogs.size());
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
@@ -751,7 +743,7 @@ public void execute(Realm realm) {
     public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification() {
         final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(final Realm realm) {
@@ -799,28 +791,6 @@ public void run() {
         });
     }
 
-    // TODO: Fix or delete this test after integration of object notification from Object Store
-    @Test
-    @RunTestInLooperThread
-    @Ignore
-    public void realmObjectListenerAddedAfterCommit() {
-        Realm realm = looperThread.realm;
-        realm.beginTransaction();
-        AllTypes obj = realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        realm.beginTransaction();
-        obj.setColumnLong(42);
-        realm.commitTransaction();
-
-        obj.addChangeListener(new RealmChangeListener<AllTypes>() {
-            @Override
-            public void onChange(AllTypes object) {
-                looperThread.testComplete();
-            }
-        });
-    }
-
     public static class PopulateOneAllTypes implements RunInLooperThread.RunnableBefore {
 
         @Override
@@ -839,7 +809,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread(before = PopulateOneAllTypes.class)
     public void realmListener_realmResultShouldBeSynced() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         assertEquals(1, results.size());
 
@@ -867,13 +837,13 @@ public void onChange(Realm element) {
     @Test
     @RunTestInLooperThread
     public void accessingSyncRealmResultInsideAsyncResultListener() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final AtomicInteger asyncResultCallback = new AtomicInteger(0);
 
         final RealmResults<AllTypes> syncResults = realm.where(AllTypes.class).findAll();
 
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> results) {
@@ -907,11 +877,11 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void accessingSyncRealmResultsInsideAnotherResultListener() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmResults<AllTypes> syncResults1 = realm.where(AllTypes.class).findAll();
         final RealmResults<AllTypes> syncResults2 = realm.where(AllTypes.class).findAll();
 
-        looperThread.keepStrongReference.add(syncResults1);
+        looperThread.keepStrongReference(syncResults1);
         syncResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -929,7 +899,7 @@ public void onChange(RealmResults<AllTypes> element) {
     @Test
     @RunTestInLooperThread(threadName = "IntentService[1]")
     public void listenersNotAllowedOnIntentServiceThreads() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
new file mode 100644
index 0000000000..2755132a69
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
@@ -0,0 +1,466 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+import io.realm.entities.Owner;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.fail;
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+
+// Tests for detailed change notification on RealmObject.
+@RunWith(AndroidJUnit4.class)
+public class ObjectChangeSetTests {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    public static class PopulateOneAllTypes implements RunInLooperThread.RunnableBefore {
+
+        @Override
+        public void run(RealmConfiguration realmConfig) {
+            Realm realm = Realm.getInstance(realmConfig);
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    AllTypes allTypes = realm.createObject(AllTypes.class);
+                    allTypes.setColumnRealmObject(realm.createObject(Dog.class));
+                    allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+                }
+            });
+            realm.close();
+        }
+    }
+
+    private void checkDeleted(AllTypes allTypes) {
+        allTypes.addChangeListener(new RealmObjectChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object, ObjectChangeSet changeSet) {
+                assertEquals(0, changeSet.getChangedFields().length);
+                assertFalse(object.isValid());
+                assertTrue(changeSet.isDeleted());
+                looperThread.testComplete();
+            }
+        });
+        looperThread.keepStrongReference(allTypes);
+    }
+
+    private void checkChangedField(AllTypes allTypes, final String... fieldNames) {
+        assertNotNull(fieldNames);
+        allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                assertEquals(fieldNames.length, changeSet.getChangedFields().length);
+                List<String> changedFields = Arrays.asList(changeSet.getChangedFields());
+                for (String name : fieldNames) {
+                    assertTrue(changeSet.isFieldChanged(name));
+                    assertFalse(changeSet.isFieldChanged(name + "NotThere"));
+                    if (!changedFields.contains(name)) {
+                        fail("Cannot find field " + name + " in field changes.");
+                    }
+                }
+                looperThread.testComplete();
+            }
+        });
+        looperThread.keepStrongReference(allTypes);
+    }
+
+    private void listenerShouldNotBeCalled(AllTypes allTypes) {
+        allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                fail();
+            }
+        });
+        looperThread.postRunnableDelayed(new Runnable() {
+            @Override
+            public void run() {
+                looperThread.testComplete();
+            }
+        }, 100);
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void objectDeleted() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkDeleted(allTypes);
+        realm.beginTransaction();
+        allTypes.deleteFromRealm();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLongField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_LONG);
+        realm.beginTransaction();
+        allTypes.setColumnLong(42);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeStringField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_STRING);
+        realm.beginTransaction();
+        allTypes.setColumnString("42");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeFloatField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_FLOAT);
+        realm.beginTransaction();
+        allTypes.setColumnFloat(42.0f);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeDoubleField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_DOUBLE);
+        realm.beginTransaction();
+        allTypes.setColumnDouble(42.0d);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeBooleanField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_BOOLEAN);
+        realm.beginTransaction();
+        allTypes.setColumnBoolean(true);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeDateField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_DATE);
+        realm.beginTransaction();
+        allTypes.setColumnDate(new Date());
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeBinaryField() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_BINARY);
+        realm.beginTransaction();
+        allTypes.setColumnBinary(new byte[] { 42 });
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldSetNewObject() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMOBJECT);
+        realm.beginTransaction();
+        allTypes.setColumnRealmObject(realm.createObject(Dog.class));
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldSetNull() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMOBJECT);
+        realm.beginTransaction();
+        allTypes.setColumnRealmObject(null);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldRemoveObject() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMOBJECT);
+        realm.beginTransaction();
+        allTypes.getColumnRealmObject().deleteFromRealm();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldOriginalObjectChanged_notTrigger() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        listenerShouldNotBeCalled(allTypes);
+        realm.beginTransaction();
+        allTypes.getColumnRealmObject().setAge(42);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkListAddObject() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMLIST);
+        realm.beginTransaction();
+        allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkListClear() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMLIST);
+        realm.beginTransaction();
+        allTypes.getColumnRealmList().clear();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeAllFields() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_LONG, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_REALMOBJECT,
+                AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT, AllTypes.FIELD_STRING, AllTypes.FIELD_BOOLEAN,
+                AllTypes.FIELD_BINARY, AllTypes.FIELD_DATE);
+        realm.beginTransaction();
+        allTypes.setColumnLong(42);
+        allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+        allTypes.setColumnRealmObject(realm.createObject(Dog.class));
+        allTypes.setColumnDouble(42.0d);
+        allTypes.setColumnFloat(42.0f);
+        allTypes.setColumnString("42");
+        allTypes.setColumnBoolean(true);
+        allTypes.setColumnBinary(new byte[] { 42 });
+        allTypes.setColumnDate(new Date());
+        realm.commitTransaction();
+    }
+
+    // Relevant to https://github.com/realm/realm-java/issues/4437
+    // When the object listener triggered at the 2nd time, the local ref m_field_names_array has not been reset and it
+    // contains an invalid local ref which has been released before.
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeDifferentFieldOneAfterAnother() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        final AtomicBoolean stringChanged = new AtomicBoolean(false);
+        final AtomicBoolean longChanged = new AtomicBoolean(false);
+        final AtomicBoolean floatChanged = new AtomicBoolean(false);
+
+        allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                assertEquals(1, changeSet.getChangedFields().length);
+                if (changeSet.isFieldChanged(AllTypes.FIELD_STRING)) {
+                    assertFalse(stringChanged.get());
+                    stringChanged.set(true);
+                } else if (changeSet.isFieldChanged(AllTypes.FIELD_LONG)) {
+                    assertFalse(longChanged.get());
+                    longChanged.set(true);
+                } else if (changeSet.isFieldChanged(AllTypes.FIELD_FLOAT)) {
+                    assertTrue(stringChanged.get());
+                    assertTrue(longChanged.get());
+                    assertFalse(floatChanged.get());
+                    floatChanged.set(true);
+                    looperThread.testComplete();
+                } else {
+                    fail();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        allTypes.setColumnString("42");
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        allTypes.setColumnLong(42);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        allTypes.setColumnFloat(42.0f);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void findFirstAsync_changeSetIsNullWhenQueryReturns() {
+        Realm realm = looperThread.getRealm();
+        AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        allTypes.addChangeListener(new RealmObjectChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object, ObjectChangeSet changeSet) {
+                assertTrue(object.isValid());
+                assertNull(changeSet);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // Due to the fact that Object Store disallow adding notification block inside a transaction, the pending query
+    // for findFirstAsync needs to be executed first then move the listener from collection to the object before begin
+    // transaction.
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void findFirstAsync_queryExecutedByLocalCommit() {
+        Realm realm = looperThread.getRealm();
+        final AtomicInteger listenerCounter = new AtomicInteger(0);
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        allTypes.addChangeListener(new RealmObjectChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object, ObjectChangeSet changeSet) {
+                int counter = listenerCounter.getAndIncrement();
+                switch (counter) {
+                    case 0:
+                        assertTrue(object.isValid());
+                        assertNull(changeSet);
+                        break;
+                    case 1:
+                        assertFalse(object.isValid());
+                        assertTrue(changeSet.isDeleted());
+                        assertEquals(0, changeSet.getChangedFields().length);
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
+                }
+            }
+        });
+        realm.beginTransaction();
+        allTypes.deleteFromRealm();
+        realm.commitTransaction();
+    }
+
+    // When there are more than 512 fields change, the JNI local ref table size limitation may be reached.
+    @Test
+    @RunTestInLooperThread
+    public void moreFieldsChangedThanLocalRefTableSize() {
+        final String CLASS_NAME = "ManyFields";
+        final int FIELD_COUNT = 1024;
+        RealmConfiguration config = looperThread.createConfiguration("many_fields");
+        final DynamicRealm realm = DynamicRealm.getInstance(config);
+
+        realm.beginTransaction();
+        RealmSchema schema = realm.getSchema();
+        RealmObjectSchema objectSchema = schema.create(CLASS_NAME);
+        for (int i = 0; i < FIELD_COUNT; i++) {
+            objectSchema.addField("field" + i, int.class);
+        }
+        DynamicRealmObject obj = realm.createObject(CLASS_NAME);
+        realm.commitTransaction();
+
+        obj.addChangeListener(new RealmObjectChangeListener<DynamicRealmObject>() {
+            @Override
+            public void onChange(DynamicRealmObject object, ObjectChangeSet changeSet) {
+                assertEquals(FIELD_COUNT, changeSet.getChangedFields().length);
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        for (int i = 0; i < FIELD_COUNT; i++) {
+            obj.setInt("field" + i, 42);
+        }
+        realm.commitTransaction();
+    }
+
+    // For https://github.com/realm/realm-java/issues/4474
+    @Test
+    @RunTestInLooperThread
+    public void allParentObjectShouldBeInChangeSet() {
+        Realm realm = looperThread.getRealm();
+
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
+        Dog dog1 = realm.createObject(Dog.class);
+        dog1.setOwner(owner);
+        dog1.setHasTail(true);
+        owner.getDogs().add(dog1);
+        Dog dog2 = realm.createObject(Dog.class);
+        dog2.setOwner(owner);
+        dog2.setHasTail(true);
+        owner.getDogs().add(dog2);
+        Dog dog3 = realm.createObject(Dog.class);
+        dog3.setOwner(owner);
+        dog3.setHasTail(true);
+        owner.getDogs().add(dog3);
+
+        realm.commitTransaction();
+
+        RealmResults<Dog> dogs = realm.where(Dog.class).equalTo(Dog.FIELD_HAS_TAIL, true).findAll();
+        looperThread.keepStrongReference(dogs);
+        dogs.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
+            @Override
+            public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
+                assertEquals(1, changeSet.getDeletions().length);
+                assertEquals(0, changeSet.getInsertions().length);
+
+                assertEquals(1, changeSet.getChangeRanges().length);
+                assertEquals(0, changeSet.getChangeRanges()[0].startIndex);
+                assertEquals(2, changeSet.getChangeRanges()[0].length);
+
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        dog3.setHasTail(false);
+        realm.commitTransaction();
+        looperThread.testComplete();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
index 30f6521816..f05ca4163a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -157,7 +157,7 @@ private void registerCheckListener(Realm realm, final ChangesCheck changesCheck)
         switch (type) {
             case REALM_RESULTS:
                 RealmResults<Dog> results = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
-                looperThread.keepStrongReference.add(results);
+                looperThread.keepStrongReference(results);
                 results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
                     @Override
                     public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
@@ -167,7 +167,7 @@ public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet ch
                 break;
             case REALM_LIST:
                 RealmList<Dog> list = realm.where(Owner.class).findFirst().getDogs();
-                looperThread.keepStrongReference.add(list);
+                looperThread.keepStrongReference(list);
                 list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
                     @Override
                     public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changeSet) {
@@ -181,7 +181,7 @@ public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet chang
     @Test
     @RunTestInLooperThread
     public void deletion() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
 
         final ChangesCheck changesCheck = new ChangesCheck() {
@@ -213,7 +213,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
     @Test
     @RunTestInLooperThread
     public void insertion() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 0); // We need to create the owner.
         realm.beginTransaction();
         createObjects(realm, 0, 2, 5, 6, 7, 9);
@@ -247,7 +247,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
     @Test
     @RunTestInLooperThread
     public void changes() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         ChangesCheck changesCheck = new ChangesCheck() {
             @Override
@@ -278,7 +278,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
     @Test
     @RunTestInLooperThread
     public void moves() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         ChangesCheck changesCheck = new ChangesCheck() {
             @Override
@@ -307,7 +307,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
     @Test
     @RunTestInLooperThread
     public void mixed_changes() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         ChangesCheck changesCheck = new ChangesCheck() {
             @Override
@@ -347,7 +347,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
     @Test
     @RunTestInLooperThread
     public void changes_then_delete() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         ChangesCheck changesCheck = new ChangesCheck() {
             @Override
@@ -377,7 +377,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
     @Test
     @RunTestInLooperThread
     public void insert_then_delete() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         ChangesCheck changesCheck = new ChangesCheck() {
             @Override
@@ -409,7 +409,8 @@ public void emptyChangeSet_findAllAsync(){
             looperThread.testComplete();
             return;
         }
-        Realm realm = looperThread.realm;
+
+        Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
         results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
@@ -429,7 +430,7 @@ public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet ch
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Realm realm = Realm.getInstance(looperThread.realmConfiguration)      ;
+                Realm realm = Realm.getInstance(looperThread.getConfiguration())      ;
                 realm.beginTransaction();
                 realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 0).findFirst().deleteFromRealm();
                 realm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index a9608250db..6bd6945524 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -37,7 +37,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
-import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
@@ -72,7 +71,7 @@
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -100,7 +99,7 @@ public void onError(Throwable error) {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_onSuccess() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -122,7 +121,7 @@ public void onSuccess() {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_onSuccessCallerRealmClosed() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -135,9 +134,10 @@ public void execute(Realm realm) {
             @Override
             public void onSuccess() {
                 assertTrue(realm.isClosed());
-                Realm newRealm = Realm.getInstance(looperThread.realmConfiguration);
+                Realm newRealm = Realm.getInstance(looperThread.getConfiguration());
                 assertEquals(1, newRealm.where(Owner.class).count());
                 assertEquals("Owner", newRealm.where(Owner.class).findFirst().getName());
+                newRealm.close();
                 looperThread.testComplete();
             }
         });
@@ -147,7 +147,7 @@ public void onSuccess() {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_onError() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RuntimeException runtimeException = new RuntimeException("Oh! What a Terrible Failure");
         assertEquals(0, realm.where(Owner.class).count());
 
@@ -170,7 +170,7 @@ public void onError(Throwable error) {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_onErrorCallerRealmClosed() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RuntimeException runtimeException = new RuntimeException("Oh! What a Terrible Failure");
         assertEquals(0, realm.where(Owner.class).count());
 
@@ -183,10 +183,11 @@ public void execute(Realm realm) {
             @Override
             public void onError(Throwable error) {
                 assertTrue(realm.isClosed());
-                Realm newRealm = Realm.getInstance(looperThread.realmConfiguration);
+                Realm newRealm = Realm.getInstance(looperThread.getConfiguration());
                 assertEquals(0, newRealm.where(Owner.class).count());
                 assertNull(newRealm.where(Owner.class).findFirst());
                 assertEquals(runtimeException, error);
+                newRealm.close();
                 looperThread.testComplete();
             }
         });
@@ -196,7 +197,7 @@ public void onError(Throwable error) {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_NoCallbacks() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -222,7 +223,7 @@ public void executeTransactionAsync_cancelTransactionInside() throws Throwable {
         final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);
         RealmLog.add(testLogger);
 
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         assertEquals(0, realm.where(Owner.class).count());
 
@@ -256,7 +257,7 @@ public void onError(Throwable error) {
     @RunTestInLooperThread
     public void executeTransactionAsync_realmClosedOnSuccess() {
         final AtomicInteger counter = new AtomicInteger(100);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmCache.Callback cacheCallback = new RealmCache.Callback() {
             @Override
             public void onResult(int count) {
@@ -295,7 +296,7 @@ public void execute(Realm realm) {
     @RunTestInLooperThread
     public void executeTransaction_async_realmClosedOnError() {
         final AtomicInteger counter = new AtomicInteger(100);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmCache.Callback cacheCallback = new RealmCache.Callback() {
             @Override
             public void onResult(int count) {
@@ -336,7 +337,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_asyncQuery() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
         assertEquals(0, results.size());
 
@@ -369,30 +370,92 @@ public void onError(Throwable error) {
     public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {
         Realm realm = Realm.getInstance(configFactory.createConfiguration());
         thrown.expect(IllegalStateException.class);
-        realm.executeTransactionAsync(new Realm.Transaction() {
+        try {
+            realm.executeTransactionAsync(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+
+                }
+            }, new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                }
+            });
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {
+        Realm realm = Realm.getInstance(configFactory.createConfiguration());
+        thrown.expect(IllegalStateException.class);
+        try {
+            realm.executeTransactionAsync(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+
+                }
+            }, new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                }
+            });
+        } finally {
+            realm.close();
+        }
+    }
+
+    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411
+    // onSuccess might commit another transaction which will call didChange. So before calling async transaction
+    // callbacks, the callback should be cleared.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling() {
+        final AtomicInteger callbackCounter = new AtomicInteger(0);
+        final Realm foregroundRealm = looperThread.getRealm();
+
+        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.
+        // We just disable the auto refresh here then the did_change won't be called.
+        foregroundRealm.setAutoRefresh(false);
+        foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-
+                realm.createObject(AllTypes.class);
             }
         }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
+                // This will be called first and only once
+                assertEquals(0, callbackCounter.getAndIncrement());
+
+                // This transaction should never trigger the onSuccess.
+                foregroundRealm.beginTransaction();
+                foregroundRealm.createObject(AllTypes.class);
+                foregroundRealm.commitTransaction();
             }
         });
-    }
 
-    @Test
-    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {
-        Realm realm = Realm.getInstance(configFactory.createConfiguration());
-        thrown.expect(IllegalStateException.class);
-        realm.executeTransactionAsync(new Realm.Transaction() {
+        foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-
+                realm.createObject(AllTypes.class);
+                // Delay to post this to ensure the async transaction posted callback will arrive first.
+                looperThread.postRunnableDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Manually call refresh, so the did_change will be triggered.
+                        foregroundRealm.sharedRealm.refresh();
+                        foregroundRealm.setAutoRefresh(true);
+                    }
+                }, 50);
             }
-        }, new Realm.Transaction.OnError() {
+        }, new Realm.Transaction.OnSuccess() {
             @Override
-            public void onError(Throwable error) {
+            public void onSuccess() {
+                // This will be called 2nd and only once
+                assertEquals(1, callbackCounter.getAndIncrement());
+                looperThread.testComplete();
             }
         });
     }
@@ -405,7 +468,7 @@ public void onError(Throwable error) {
     @Test
     @RunTestInLooperThread
     public void findAllAsync() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
         final RealmResults<AllTypes> results = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
@@ -414,7 +477,7 @@ public void findAllAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -429,7 +492,7 @@ public void onChange(RealmResults<AllTypes> object) {
     @Test
     @RunTestInLooperThread
     public void accessingRealmListOnUnloadedRealmObjectShouldThrow() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
         final AllTypes results = realm.where(AllTypes.class)
                 .equalTo("columnLong", 0)
@@ -472,7 +535,7 @@ public void findAllAsync_throwsOnNonLooperThread() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void findAllAsync_withNotification() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
         final RealmResults<AllTypes> results = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
@@ -487,7 +550,7 @@ public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
 
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
@@ -498,13 +561,13 @@ public void onChange(RealmResults<AllTypes> object) {
     @Test
     @RunTestInLooperThread
     public void findAllAsync_forceLoad() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
         final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
                 .findAllAsync();
 
-        looperThread.keepStrongReference.add(realmResults);
+        looperThread.keepStrongReference(realmResults);
         // Notification should be called as well.
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -534,13 +597,13 @@ public void onChange(RealmResults<AllTypes> object) {
     @Test
     @RunTestInLooperThread
     public void findFirstAsync() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
 
         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
         assertFalse(asyncObj.isValid());
         assertFalse(asyncObj.isLoaded());
-        looperThread.keepStrongReference.add(asyncObj);
+        looperThread.keepStrongReference(asyncObj);
         asyncObj.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -555,9 +618,9 @@ public void onChange(AllTypes object) {
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_initialEmptyRow() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();
-        looperThread.keepStrongReference.add(firstAsync);
+        looperThread.keepStrongReference(firstAsync);
         firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -571,19 +634,19 @@ public void onChange(AllTypes object) {
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_updatedIfSyncRealmObjectIsUpdated() throws Throwable {
-        populateTestRealm(looperThread.realm, 1);
-        AllTypes firstSync = looperThread.realm.where(AllTypes.class).findFirst();
+        populateTestRealm(looperThread.getRealm(), 1);
+        AllTypes firstSync = looperThread.getRealm().where(AllTypes.class).findFirst();
         assertEquals(0, firstSync.getColumnLong());
         assertEquals("test data 0", firstSync.getColumnString());
 
-        final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
+        final AllTypes firstAsync = looperThread.getRealm().where(AllTypes.class).findFirstAsync();
         assertTrue(firstAsync.load());
         assertTrue(firstAsync.isLoaded());
         assertTrue(firstAsync.isValid());
         assertEquals(0, firstAsync.getColumnLong());
         assertEquals("test data 0", firstAsync.getColumnString());
 
-        looperThread.keepStrongReference.add(firstAsync);
+        looperThread.keepStrongReference(firstAsync);
         firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -592,9 +655,9 @@ public void onChange(AllTypes object) {
             }
         });
 
-        looperThread.realm.beginTransaction();
+        looperThread.getRealm().beginTransaction();
         firstSync.setColumnString("Galacticon");
-        looperThread.realm.commitTransaction();
+        looperThread.getRealm().commitTransaction();
     }
 
     // Finds elements [0-4] asynchronously then waits for the promise to be loaded
@@ -602,13 +665,13 @@ public void onChange(AllTypes object) {
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_withNotification() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
         final AllTypes realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 9)
                 .findFirstAsync();
 
-        looperThread.keepStrongReference.add(realmResults);
+        looperThread.keepStrongReference(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -628,25 +691,68 @@ public void onChange(AllTypes object) {
         }
     }
 
-    // Similar UC as #testForceLoadAsync using 'findFirst'.
+    // load should trigger the listener with empty change set.
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_forceLoad() throws Throwable {
-        Realm Realm = looperThread.realm;
-        populateTestRealm(Realm, 10);
-        final AllTypes realmResults = Realm.where(AllTypes.class)
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        Realm realm = looperThread.getRealm();
+        populateTestRealm(realm, 10);
+        final AllTypes realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 9)
                 .findFirstAsync();
 
         assertFalse(realmResults.isLoaded());
 
+        realmResults.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                assertNull(changeSet);
+                assertFalse(listenerCalled.get());
+                listenerCalled.set(true);
+            }
+        });
+
         assertTrue(realmResults.load());
         assertTrue(realmResults.isLoaded());
         assertEquals("test data 4", realmResults.getColumnString());
 
+        assertTrue(listenerCalled.get());
         looperThread.testComplete();
     }
 
+    // For issue https://github.com/realm/realm-java/issues/4495
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_twoListenersOnSameInvalidObjectsCauseNPE() {
+        final Realm realm = looperThread.getRealm();
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        final AtomicBoolean firstListenerCalled = new AtomicBoolean(false);
+
+        allTypes.addChangeListener(new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes element) {
+                allTypes.removeChangeListener(this);
+                assertFalse(firstListenerCalled.getAndSet(true));
+                if (!element.isValid()) {
+                    realm.beginTransaction();
+                    realm.createObject(AllTypes.class);
+                    realm.commitTransaction();
+                }
+            }
+        });
+
+        allTypes.addChangeListener(new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes element) {
+                allTypes.removeChangeListener(this);
+                assertTrue(firstListenerCalled.get());
+                assertFalse(element.isValid());
+                looperThread.testComplete();
+            }
+        });
+    }
+
     // **************************************
     // *** 'findAllSorted' async queries  ***
     // **************************************
@@ -655,7 +761,7 @@ public void findFirstAsync_forceLoad() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync() throws Throwable {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class)
@@ -665,7 +771,7 @@ public void findAllSortedAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -683,9 +789,9 @@ public void onChange(RealmResults<AllTypes> object) {
     @Test
     @RunTestInLooperThread
     public void combiningAsyncAndSync() {
-        populateTestRealm(looperThread.realm, 10);
+        populateTestRealm(looperThread.getRealm(), 10);
 
-        final RealmResults<AllTypes> allTypesAsync = looperThread.realm.where(AllTypes.class).greaterThan("columnLong", 5).findAllAsync();
+        final RealmResults<AllTypes> allTypesAsync = looperThread.getRealm().where(AllTypes.class).greaterThan("columnLong", 5).findAllAsync();
         final RealmResults<AllTypes> allTypesSync = allTypesAsync.where().greaterThan("columnLong", 3).findAll();
 
         // Call where() on an async results will load query. But to maintain the pre version 2.4.0 behaviour of
@@ -700,7 +806,7 @@ public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
-        looperThread.keepStrongReference.add(allTypesAsync);
+        looperThread.keepStrongReference(allTypesAsync);
     }
 
     // Keeps advancing the Realm by sending 1 commit for each frame (16ms).
@@ -718,7 +824,7 @@ public void stressTestBackgroundCommits() throws Throwable {
             @Override
             public void run() {
                 Random random = new Random(System.currentTimeMillis());
-                Realm backgroundThreadRealm = Realm.getInstance(looperThread.realm.getConfiguration());
+                Realm backgroundThreadRealm = Realm.getInstance(looperThread.getRealm().getConfiguration());
                 for (int i = 0; i < NUMBER_OF_COMMITS; i++) {
                     backgroundThreadRealm.beginTransaction();
                     AllTypes object = backgroundThreadRealm.createObject(AllTypes.class);
@@ -736,13 +842,13 @@ public void run() {
             }
         };
 
-        final RealmResults<AllTypes> allAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
+        final RealmResults<AllTypes> allAsync = looperThread.getRealm().where(AllTypes.class).findAllAsync();
         allAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(allAsync.isLoaded());
                 if (allAsync.size() == NUMBER_OF_COMMITS) {
-                    AllTypes lastInserted = looperThread.realm.where(AllTypes.class)
+                    AllTypes lastInserted = looperThread.getRealm().where(AllTypes.class)
                             .equalTo("columnLong", latestLongValue[0])
                             .equalTo("columnFloat", latestFloatValue[0])
                             .findFirst();
@@ -752,7 +858,7 @@ public void onChange(RealmResults<AllTypes> object) {
                 }
             }
         });
-        looperThread.keepStrongReference.add(allAsync);
+        looperThread.keepStrongReference(allAsync);
 
         looperThread.postRunnableDelayed(new Runnable() {
             @Override
@@ -765,7 +871,7 @@ public void run() {
     @Test
     @RunTestInLooperThread
     public void distinctAsync() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
@@ -801,10 +907,10 @@ public void run() {
             }
         };
 
-        looperThread.keepStrongReference.add(distinctBool);
-        looperThread.keepStrongReference.add(distinctLong);
-        looperThread.keepStrongReference.add(distinctDate);
-        looperThread.keepStrongReference.add(distinctString);
+        looperThread.keepStrongReference(distinctBool);
+        looperThread.keepStrongReference(distinctLong);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
         distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -841,7 +947,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     @Test
     @RunTestInLooperThread()
     public void distinctAsync_rememberQueryParams() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         final int TEST_SIZE = 10;
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -866,26 +972,87 @@ public void onChange(RealmResults<AllJavaTypes> results) {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_notIndexedFields() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String fieldName : new String[]{"Boolean", "Long", "Date", "String"}) {
-            try {
-                realm.where(AnnotationIndexTypes.class).distinctAsync("notIndex" + fieldName);
-                fail("notIndex" + fieldName);
-            } catch (IllegalArgumentException ignored) {
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable changeListenerDone = new Runnable() {
+            final AtomicInteger signalCallbackFinished = new AtomicInteger(4);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
             }
-        }
+        };
 
-        looperThread.testComplete();
+        looperThread.keepStrongReference(distinctBool);
+        looperThread.keepStrongReference(distinctLong);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(2, distinctBool.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctString.size());
+                changeListenerDone.run();
+            }
+        });
     }
 
     @Test
     @RunTestInLooperThread
     public void distinctAsync_noneExistingField() throws Throwable {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
@@ -901,7 +1068,7 @@ public void distinctAsync_noneExistingField() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void batchUpdateDifferentTypeOfQueries() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         for (int i = 0; i < 5; ) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -923,10 +1090,10 @@ public void batchUpdateDifferentTypeOfQueries() {
                 new Sort[]{Sort.ASCENDING, Sort.DESCENDING});
         RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
 
-        looperThread.keepStrongReference.add(findAllAsync);
-        looperThread.keepStrongReference.add(findAllSorted);
-        looperThread.keepStrongReference.add(findAllSortedMulti);
-        looperThread.keepStrongReference.add(findDistinct);
+        looperThread.keepStrongReference(findAllAsync);
+        looperThread.keepStrongReference(findAllSorted);
+        looperThread.keepStrongReference(findAllSortedMulti);
+        looperThread.keepStrongReference(findDistinct);
 
         final CountDownLatch queriesCompleted = new CountDownLatch(4);
         final CountDownLatch bgRealmClosedLatch = new CountDownLatch(1);
@@ -1013,20 +1180,16 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
         new Thread() {
             @Override
             public void run() {
-                try {
-                    queriesCompleted.await();
-                    Realm bgRealm = Realm.getInstance(realm.getConfiguration());
-
-                    bgRealm.beginTransaction();
-                    bgRealm.createObject(AllTypes.class);
-                    bgRealm.createObject(AnnotationIndexTypes.class);
-                    bgRealm.commitTransaction();
-
-                    bgRealm.close();
-                    bgRealmClosedLatch.countDown();
-                } catch (InterruptedException e) {
-                    fail(e.getMessage());
-                }
+                TestHelper.awaitOrFail(queriesCompleted);
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+
+                bgRealm.beginTransaction();
+                bgRealm.createObject(AllTypes.class);
+                bgRealm.createObject(AnnotationIndexTypes.class);
+                bgRealm.commitTransaction();
+
+                bgRealm.close();
+                bgRealmClosedLatch.countDown();
             }
         }.start();
     }
@@ -1036,10 +1199,10 @@ public void run() {
     @RunTestInLooperThread
     public void queryingLinkHandover() throws Throwable {
         final AtomicInteger numberOfInvocations = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         final RealmResults<Dog> allAsync = realm.where(Dog.class).equalTo("owner.name", "kiba").findAllAsync();
-        looperThread.keepStrongReference.add(allAsync);
+        looperThread.keepStrongReference(allAsync);
         allAsync.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -1089,11 +1252,11 @@ public void doInBackground(Realm realm) {
     @RunTestInLooperThread
     public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAccessException {
         final AtomicInteger listenerCount = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
 
         // 1. Makes sure that async query is not started.
         final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
-        looperThread.keepStrongReference.add(result);
+        looperThread.keepStrongReference(result);
         result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1137,7 +1300,7 @@ public void onChange(RealmResults<AllTypes> object) {
     @Test
     @RunTestInLooperThread
     public void batchUpdate_localRefIsDeletedInLoopOfNativeBatchUpdateQueries() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         // For Android, the size of local ref map is 512. Uses 1024 for more pressure.
         final int TEST_COUNT = 1024;
         final AtomicBoolean updatesTriggered = new AtomicBoolean(false);
@@ -1171,7 +1334,7 @@ public void execute(Realm realm) {
                         // Step 2: Creates 2nd - TEST_COUNT queries.
                         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
                         results.addChangeListener(this);
-                        looperThread.keepStrongReference.add(results);
+                        looperThread.keepStrongReference(results);
                     }
                 }
             }
@@ -1179,7 +1342,7 @@ public void execute(Realm realm) {
         // Step 1. Creates first async to kick the test start.
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
         results.addChangeListener(listener);
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
     }
 
     // *** Helper methods ***
@@ -1193,7 +1356,7 @@ private void populateTestRealm(final Realm testRealm, int objects) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -1214,11 +1377,11 @@ private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOf
                 AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
                 obj.setIndexBoolean(j % 2 == 0);
                 obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setIndexString(withNull ? null : "Test " + j);
                 obj.setNotIndexBoolean(j % 2 == 0);
                 obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setNotIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setNotIndexString(withNull ? null : "Test " + j);
             }
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index 1085a371b6..b0ca7ffce1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -255,7 +255,7 @@ public void run() {
         });
         thread.start();
 
-        closeLatch.await();
+        TestHelper.awaitOrFail(closeLatch);
         RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(1));
         realmA.close();
         RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(0));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
index b058f3357a..b44bcc868f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
@@ -63,7 +63,7 @@ public void tearDown() {
     @Test
     @RunTestInLooperThread
     public void returnedRealmIsNotNull() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm realm) {
@@ -79,7 +79,7 @@ public void onChange(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void returnedDynamicRealmIsNotNull() {
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         dynamicRealm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
             @Override
             public void onChange(DynamicRealm dynRealm) {
@@ -96,9 +96,9 @@ public void onChange(DynamicRealm dynRealm) {
     @Test
     @RunTestInLooperThread
     public void returnedRealmResultsIsNotNull() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         RealmResults<Cat> cats = realm.where(Cat.class).findAll();
-        looperThread.keepStrongReference.add(cats);
+        looperThread.keepStrongReference(cats);
         cats.addChangeListener(new RealmChangeListener<RealmResults<Cat>>() {
             @Override
             public void onChange(RealmResults<Cat> result) {
@@ -115,9 +115,9 @@ public void onChange(RealmResults<Cat> result) {
     @Test
     @RunTestInLooperThread
     public void returnedRealmResultsOfModelIsNotNull() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         RealmResults<AllTypesRealmModel> alltypes = realm.where(AllTypesRealmModel.class).findAll();
-        looperThread.keepStrongReference.add(alltypes);
+        looperThread.keepStrongReference(alltypes);
         alltypes.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
             public void onChange(RealmResults<AllTypesRealmModel> result) {
@@ -136,12 +136,12 @@ public void onChange(RealmResults<AllTypesRealmModel> result) {
     @Test
     @RunTestInLooperThread
     public void returnedRealmObjectIsNotNull() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
-        Cat cat = looperThread.realm.createObject(Cat.class);
+        Cat cat = realm.createObject(Cat.class);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(cat);
+        looperThread.keepStrongReference(cat);
         cat.addChangeListener(new RealmChangeListener<Cat>() {
             @Override
             public void onChange(Cat object) {
@@ -158,12 +158,12 @@ public void onChange(Cat object) {
     @Test
     @RunTestInLooperThread
     public void returnedRealmModelIsNotNull() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class, 0);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(model);
+        looperThread.keepStrongReference(model);
         RealmObject.addChangeListener(model, new RealmChangeListener<AllTypesRealmModel>() {
             @Override
             public void onChange(AllTypesRealmModel object) {
@@ -180,15 +180,15 @@ public void onChange(AllTypesRealmModel object) {
     @Test
     @RunTestInLooperThread
     public void returnedDynamicRealmObjectIsNotNull() {
-        Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+        Realm realm = Realm.getInstance(looperThread.getConfiguration());
         realm.close();
 
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         dynamicRealm.beginTransaction();
         DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
         dynamicRealm.commitTransaction();
 
-        looperThread.keepStrongReference.add(allTypes);
+        looperThread.keepStrongReference(allTypes);
         allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
             public void onChange(DynamicRealmObject object) {
@@ -205,12 +205,12 @@ public void onChange(DynamicRealmObject object) {
     @Test
     @RunTestInLooperThread
     public void returnedDynamicRealmResultsIsNotNull() {
-        Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+        Realm realm = Realm.getInstance(looperThread.getConfiguration());
         realm.close();
 
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         RealmResults<DynamicRealmObject> all = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
-        looperThread.keepStrongReference.add(all);
+        looperThread.keepStrongReference(all);
         all.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
             public void onChange(RealmResults<DynamicRealmObject> result) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index 8fd06f3310..1b41af1114 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -217,7 +217,7 @@ public void run() {
 
                 // Waits until Realm instance closed in main thread.
                 try {
-                    realmInMainClosedLatch.await(3, TimeUnit.SECONDS);
+                    realmInMainClosedLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     threadError[0] = new AssertionFailedError("Worker thread was interrupted.");
                     realm.close();
@@ -232,7 +232,7 @@ public void run() {
 
 
         // Waits until the worker thread started.
-        workerCommittedLatch.await(3, TimeUnit.SECONDS);
+        workerCommittedLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // Refreshes will be ran in the next loop, manually refreshes it here.
@@ -253,7 +253,7 @@ public void run() {
         realmInMainClosedLatch.countDown();
 
         // Waits until the worker thread finished.
-        workerClosedLatch.await(3, TimeUnit.SECONDS);
+        workerClosedLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index c4e597eb45..76c5c4c377 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -38,6 +38,7 @@
 import io.realm.entities.AllTypes;
 import io.realm.services.RemoteProcessService;
 
+
 // This is built for testing multi processes related cases.
 // To build a test case, create an InterprocessHandler in your test case. This handler will run in the newly
 // created thread's Looper. Remember to call Looper.loop() to start handling messages.
@@ -97,7 +98,7 @@ public void run() {
         });
 
         thread.start();
-        latch.await();
+        TestHelper.awaitOrFail(latch);
 
         if (throwableArray[0] != null) {
             throw throwableArray[0];
@@ -161,7 +162,7 @@ protected void setUp() throws Exception {
         serviceStartLatch = new CountDownLatch(1);
         Intent intent = new Intent(getContext(), RemoteProcessService.class);
         getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
-        assertTrue(serviceStartLatch.await(10, TimeUnit.SECONDS));
+        assertTrue(serviceStartLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS));
     }
 
     @Override
@@ -205,7 +206,7 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
     // be retained by the system to be used next time.
     // Use getRemoteProcessInfo if you want to check the existence of remote process.
     private ActivityManager.RunningServiceInfo getServiceInfo() {
-        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager manager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
         List<ActivityManager.RunningServiceInfo> serviceInfoList = manager.getRunningServices(Integer.MAX_VALUE);
         for (ActivityManager.RunningServiceInfo service : serviceInfoList) {
             if (RemoteProcessService.class.getName().equals(service.service.getClassName())) {
@@ -217,7 +218,7 @@ private void triggerServiceStep(RemoteProcessService.Step step) {
 
     // Gets the remote process info if it is alive.
     private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
-        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager manager = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
         List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
         for (ActivityManager.RunningAppProcessInfo info : processInfoList) {
             if (info.processName.equals(getContext().getPackageName() + ":remote")) {
@@ -255,12 +256,12 @@ public void handleMessage(Message msg) {
                             ActivityManager.RunningAppProcessInfo processInfo = getRemoteProcessInfo();
                             if (processInfo != null && processInfo.pid == servicePid && i >= 6) {
                                 // The process is still alive.
-                                assertTrue(false);
+                                fail("Process is still alive");
                             } else if (processInfo == null || processInfo.pid != servicePid) {
                                 // The process is gone.
                                 break;
                             }
-                            Thread.sleep(500, 0);
+                            Thread.sleep(500);
                         }
                     } catch (InterruptedException e) {
                         e.printStackTrace();
@@ -288,7 +289,8 @@ public void run() {
 
                 // Step A
                 triggerServiceStep(RemoteProcessService.stepCreateInitialRealm_A);
-            }}) {
+            }
+        }) {
 
             @Override
             public void handleMessage(Message msg) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 351024dcd8..2d50dacb12 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -1447,6 +1447,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(0));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_STRING_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1456,6 +1457,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(1));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BYTES_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1474,6 +1476,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(3));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BYTE_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1483,6 +1486,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(4));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_SHORT_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1492,6 +1496,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(5));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_INTEGER_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1501,6 +1506,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(6));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_LONG_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1510,6 +1516,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(7));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_FLOAT_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1519,6 +1526,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(8));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_DOUBLE_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1528,6 +1536,7 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
             realm.createObjectFromJson(NullTypes.class, array.getJSONObject(9));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_DATE_NOT_NULL));
         } catch (Exception e) {
             fail("Unexpected exception: " + e);
         }
@@ -1552,6 +1561,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(0)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_STRING_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1561,6 +1571,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(1)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BYTES_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1570,6 +1581,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(2)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BOOLEAN_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1579,6 +1591,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(3)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BYTE_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1588,6 +1601,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(4)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_SHORT_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1597,6 +1611,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(5)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_INTEGER_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1606,6 +1621,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(6)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_LONG_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1615,6 +1631,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(7)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_FLOAT_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1624,6 +1641,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(8)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_DOUBLE_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1633,6 +1651,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
             realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(9)));
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_DATE_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 2af194d3ef..2e802eb7f2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -484,22 +484,22 @@ public void queryMultipleRelationsString() {
     public void queryShouldFail() {
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat..hasTail", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (double dot)");
         } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo(".cat.hasTail", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (initial dot)");
         } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat.hasTail.", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (final dot)");
         } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("not.there", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (non-existent column)");
         } catch (IllegalArgumentException ignored) {
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 78fdc0e8df..038ccc905d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -38,6 +38,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -993,7 +994,7 @@ public void add_set_dynamicObjectCreatedFromTypedRealm() {
     }
 
     private RealmList<Dog> prepareRealmListInLooperThread() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         Owner owner = realm.createObject(Owner.class);
         owner.setName("Owner");
@@ -1010,7 +1011,7 @@ public void add_set_dynamicObjectCreatedFromTypedRealm() {
     @RunTestInLooperThread
     public void addChangeListener() {
         collection = prepareRealmListInLooperThread();
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final AtomicInteger listenerCalledCount = new AtomicInteger(0);
         collection.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
             @Override
@@ -1039,7 +1040,7 @@ public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet chang
     @RunTestInLooperThread
     public void removeAllChangeListeners() {
         collection = prepareRealmListInLooperThread();
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final AtomicInteger listenerCalledCount = new AtomicInteger(0);
         collection.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
             @Override
@@ -1053,24 +1054,31 @@ public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet chang
                 fail();
             }
         });
-        realm.beginTransaction();
-        collection.get(0).setAge(42);
-        realm.commitTransaction();
 
         collection.removeAllChangeListeners();
 
+        // This one is added after removal, so it should be triggered.
+        collection.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
+            @Override
+            public void onChange(RealmList<Dog> element) {
+                listenerCalledCount.incrementAndGet();
+                looperThread.testComplete();
+            }
+        });
+
         // This should trigger the listener if there is any.
         realm.beginTransaction();
-        realm.cancelTransaction();
-        assertEquals(0, listenerCalledCount.get());
-        looperThread.testComplete();
+        collection.get(0).setAge(42);
+        realm.commitTransaction();
+
+        assertEquals(1, listenerCalledCount.get());
     }
 
     @Test
     @RunTestInLooperThread
     public void removeChangeListener() {
         collection = prepareRealmListInLooperThread();
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         final AtomicInteger listenerCalledCount = new AtomicInteger(0);
         RealmChangeListener<RealmList<Dog>> listener1 = new RealmChangeListener<RealmList<Dog>>() {
             @Override
@@ -1083,21 +1091,33 @@ public void onChange(RealmList<Dog> element) {
                     @Override
                     public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changes) {
                         assertEquals(0, listenerCalledCount.getAndIncrement());
+                        looperThread.testComplete();
                     }
                 };
 
         collection.addChangeListener(listener1);
         collection.addChangeListener(listener2);
-        realm.beginTransaction();
-        collection.get(0).setAge(42);
-        realm.commitTransaction();
 
         collection.removeChangeListener(listener1);
 
         // This should trigger the listener if there is any.
         realm.beginTransaction();
-        realm.cancelTransaction();
+        collection.get(0).setAge(42);
+        realm.commitTransaction();
         assertEquals(1, listenerCalledCount.get());
-        looperThread.testComplete();
+    }
+
+    // https://github.com/realm/realm-java/issues/4554
+    @Test
+    public void createSnapshot_shouldUseTargetTable() {
+        int sizeBefore = collection.size();
+        OrderedRealmCollectionSnapshot<Dog> snapshot = collection.createSnapshot();
+        realm.beginTransaction();
+        snapshot.get(0).deleteFromRealm();
+        realm.commitTransaction();
+        assertEquals(sizeBefore - 1, collection.size());
+
+        assertNotNull(collection.view);
+        assertEquals(collection.view.getTargetTable().getName(), snapshot.getTable().getName());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 7a5d21a4e5..1e04dca3e3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -1300,7 +1300,7 @@ public void migrationRequired_throwsOriginalException() {
             }
         }
     }
-    
+
     // TODO Add unit tests for default nullability
     // TODO Add unit tests for default Indexing for Primary keys
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 387f098153..1bf59fdf2a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -91,7 +91,7 @@ private void populateTestRealm(Realm realm, int objects) {
             allTypes.columnBoolean = (i % 3) == 0;
             allTypes.columnBinary = new byte[]{1, 2, 3};
             allTypes.columnDate = new Date();
-            allTypes.columnDouble = 3.1415 + i;
+            allTypes.columnDouble = Math.PI + i;
             allTypes.columnFloat = 1.234567f;
             allTypes.columnString = "test data ";
             allTypes.columnByte = 0x2A;
@@ -195,11 +195,11 @@ public void query() {
     @Test
     @RunTestInLooperThread
     public void async_query() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctAsync(AllTypesRealmModel.FIELD_STRING);
-        looperThread.keepStrongReference.add(allTypesRealmModels);
+        looperThread.keepStrongReference(allTypesRealmModels);
         allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
             public void onChange(RealmResults<AllTypesRealmModel> object) {
@@ -231,8 +231,8 @@ public void dynamicObject() {
     @Test
     @RunTestInLooperThread
     public void dynamicRealm() {
-        populateTestRealm(looperThread.realm, TEST_DATA_SIZE);
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        populateTestRealm(looperThread.getRealm(), TEST_DATA_SIZE);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
 
         dynamicRealm.beginTransaction();
         DynamicRealmObject dog = dynamicRealm.createObject(AllTypesRealmModel.CLASS_NAME, 42);
@@ -251,7 +251,7 @@ public void dynamicRealm() {
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypesRealmModel.CLASS_NAME).findAll();
         assertEquals(TEST_DATA_SIZE, results.size());
         for (int i = 0; i < TEST_DATA_SIZE; i++) {
-            assertEquals(3.1415 + i, results.get(i).getDouble(AllTypesRealmModel.FIELD_DOUBLE), 0.0000001);
+            assertEquals(Math.PI + i, results.get(i).getDouble(AllTypesRealmModel.FIELD_DOUBLE), 0.0000001);
             assertEquals((i % 3) == 0, results.get(i).getBoolean(AllTypesRealmModel.FIELD_BOOLEAN));
         }
         dynamicRealm.close();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 01745e62f6..d89911896d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -738,7 +738,7 @@ public void getFieldIndex() {
         RealmConfiguration emptyConfig = configFactory.createConfiguration("empty");
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(emptyConfig);
         dynamicRealm.beginTransaction();
-        RealmObjectSchema objectSchema = dynamicRealm.getSchema().create(className);
+        StandardRealmObjectSchema objectSchema = (StandardRealmObjectSchema) dynamicRealm.getSchema().create(className);
 
         assertNull(objectSchema.getFieldIndex(fieldName));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 4df192b9a3..f99ae25334 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -16,13 +16,11 @@
 
 package io.realm;
 
-import android.support.test.annotation.UiThreadTest;
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -32,7 +30,6 @@
 import java.util.Calendar;
 import java.util.Date;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -67,6 +64,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class RealmObjectTests {
 
@@ -716,10 +714,7 @@ public void run() {
                 realm.commitTransaction();
 
                 createLatch.countDown();
-                try {
-                    testEndLatch.await();
-                } catch (InterruptedException ignored) {
-                }
+                TestHelper.awaitOrFail(testEndLatch);
 
                 // 3. Closes Realm in this thread and finishes.
                 realm.close();
@@ -727,7 +722,7 @@ public void run() {
         };
         thread.start();
 
-        createLatch.await();
+        TestHelper.awaitOrFail(createLatch);
         // 2. Sets created object to target.
         realm.beginTransaction();
         try {
@@ -871,10 +866,7 @@ public void run() {
                 realm.commitTransaction();
 
                 createLatch.countDown();
-                try {
-                    testEndLatch.await();
-                } catch (InterruptedException ignored) {
-                }
+                TestHelper.awaitOrFail(testEndLatch);
 
                 // 3. Close Realm in this thread and finishes.
                 realm.close();
@@ -882,7 +874,7 @@ public void run() {
         };
         thread.start();
 
-        createLatch.await();
+        TestHelper.awaitOrFail(createLatch);
         // 2. Sets created object to target.
         realm.beginTransaction();
         try {
@@ -1019,9 +1011,9 @@ public void get_set_nonNullValueOnNullableFields() {
         // 3 Boolean
         nullTypes.setFieldBooleanNull(true);
         // 4 Byte
-        nullTypes.setFieldByteNull((byte)42);
+        nullTypes.setFieldByteNull((byte) 42);
         // 5 Short
-        nullTypes.setFieldShortNull((short)42);
+        nullTypes.setFieldShortNull((short) 42);
         // 6 Integer
         nullTypes.setFieldIntegerNull(42);
         // 7 Long
@@ -1042,9 +1034,9 @@ public void get_set_nonNullValueOnNullableFields() {
         // 3 Boolean
         assertTrue(nullTypes.getFieldBooleanNull());
         // 4 Byte
-        assertEquals((byte)42, (byte)nullTypes.getFieldByteNull().intValue());
+        assertEquals((byte) 42, (byte) nullTypes.getFieldByteNull().intValue());
         // 5 Short
-        assertEquals((short)42, (short)nullTypes.getFieldShortNull().intValue());
+        assertEquals((short) 42, (short) nullTypes.getFieldShortNull().intValue());
         // 6 Integer
         assertEquals(42, nullTypes.getFieldIntegerNull().intValue());
         // 7 Long
@@ -1441,6 +1433,7 @@ public void setter_nullValueInRequiredField() {
             list.first().setFieldStringNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_STRING_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1451,6 +1444,7 @@ public void setter_nullValueInRequiredField() {
             list.first().setFieldBytesNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BYTES_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1461,6 +1455,7 @@ public void setter_nullValueInRequiredField() {
             list.first().setFieldBooleanNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BOOLEAN_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1468,9 +1463,10 @@ public void setter_nullValueInRequiredField() {
         // 4 Byte
         try {
             realm.beginTransaction();
-            list.first().setFieldBytesNotNull(null);
+            list.first().setFieldByteNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_BYTE_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1483,6 +1479,7 @@ public void setter_nullValueInRequiredField() {
             list.first().setFieldFloatNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_FLOAT_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1493,6 +1490,7 @@ public void setter_nullValueInRequiredField() {
             list.first().setFieldDoubleNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_DOUBLE_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1503,6 +1501,7 @@ public void setter_nullValueInRequiredField() {
             list.first().setFieldDateNotNull(null);
             fail();
         } catch (IllegalArgumentException ignored) {
+            assertTrue(ignored.getMessage().contains(NullTypes.FIELD_DATE_NOT_NULL));
         } finally {
             realm.cancelTransaction();
         }
@@ -1571,42 +1570,45 @@ public void setter_changePrimaryKeyThrows() {
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.addChangeListener(null);
+            dog.addChangeListener((RealmChangeListener) null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            dog.addChangeListener((RealmObjectChangeListener) null);
             fail("adding null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
-        } finally {
-            looperThread.testComplete();
         }
+
+        looperThread.testComplete();
     }
 
     @Test
     public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
-        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
-            @Override
-            public void run() throws Exception {
-                final Realm realm = Realm.getInstance(realmConfig);
-                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+        final Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
-                //noinspection TryFinallyCanBeTryWithResources
-                try {
-                    dog.addChangeListener(null);
-                    fail("adding null change listener must throw an exception.");
-                } catch (IllegalArgumentException ignore) {
-                } finally {
-                    realm.close();
-                }
-            }
-        });
+        try {
+            dog.addChangeListener((RealmChangeListener) null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            dog.addChangeListener((RealmObjectChangeListener) null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
     }
 
     @Test
     @RunTestInLooperThread
-    public void changeListener_triggeredWhenObjectIsdeleted() {
-        final Realm realm = looperThread.realm;
+    public void changeListener_triggeredWhenObjectIsDeleted() {
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
@@ -1637,44 +1639,115 @@ public void onChange(Dog object) {
             });
             fail("adding change listener on unmanaged object must throw an exception.");
         } catch (IllegalArgumentException ignore) {
-        } finally {
-            looperThread.testComplete();
         }
+
+        try {
+            dog.addChangeListener(new RealmObjectChangeListener<Dog>() {
+                @Override
+                public void onChange(Dog object, ObjectChangeSet changeSet) {
+                }
+            });
+            fail("adding change listener on unmanaged object must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        looperThread.testComplete();
+    }
+
+    // Object Store will throw when adding change listener inside a transaction.
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwInsiderTransaction() {
+        Realm realm = looperThread.getRealm();
+
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        try {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
+                @Override
+                public void onChange(Dog element) {
+                    fail();
+                }
+            });
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            dog.addChangeListener(new RealmObjectChangeListener<Dog>() {
+                @Override
+                public void onChange(Dog object, ObjectChangeSet changeSet) {
+                    fail();
+                }
+            });
+        } catch (IllegalStateException ignored) {
+        }
+        realm.cancelTransaction();
+
+        looperThread.testComplete();
     }
 
     @Test
     @RunTestInLooperThread
     public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.removeChangeListener(null);
+            dog.removeChangeListener((RealmChangeListener) null);
             fail("removing null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
-        } finally {
-            looperThread.testComplete();
         }
+
+        try {
+            dog.removeChangeListener((RealmObjectChangeListener) null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        looperThread.testComplete();
     }
 
     @Test
     public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
-        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
-            @Override
-            public void run() throws Exception {
-                final Realm realm = Realm.getInstance(realmConfig);
-                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+        final Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
-                //noinspection TryFinallyCanBeTryWithResources
-                try {
-                    dog.removeChangeListener(null);
-                    fail("removing null change listener must throw an exception.");
-                } catch (IllegalArgumentException ignore) {
-                } finally {
-                    realm.close();
-                }
+        try {
+            dog.removeChangeListener((RealmChangeListener) null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            dog.removeChangeListener((RealmObjectChangeListener) null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_insideTransaction() {
+        Realm realm = looperThread.getRealm();
+        final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+        RealmChangeListener<Dog> realmChangeListener = new RealmChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog element) {
             }
-        });
+        };
+        RealmObjectChangeListener<Dog> realmObjectChangeListener = new RealmObjectChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object, ObjectChangeSet changeSet) {
+            }
+        };
+
+        dog.addChangeListener(realmChangeListener);
+        dog.addChangeListener(realmObjectChangeListener);
+
+        realm.beginTransaction();
+        dog.removeChangeListener(realmChangeListener);
+        dog.removeChangeListener(realmObjectChangeListener);
+        realm.cancelTransaction();
+        looperThread.testComplete();
     }
 
     /**
@@ -1683,7 +1756,7 @@ public void run() throws Exception {
     @Test
     @RunTestInLooperThread
     public void removeAllChangeListeners() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         Dog dog = realm.createObject(Dog.class);
         dog.setAge(13);
@@ -1691,7 +1764,13 @@ public void removeAllChangeListeners() {
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                assertTrue(false);
+                fail();
+            }
+        });
+        dog.addChangeListener(new RealmObjectChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object, ObjectChangeSet changeSet) {
+                fail();
             }
         });
         dog.removeAllChangeListeners();
@@ -1700,9 +1779,40 @@ public void onChange(Dog object) {
         Dog sameDog = realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 13).findFirst();
         sameDog.setName("Jesper");
         realm.commitTransaction();
+        // Try to trigger the listeners.
+        realm.sharedRealm.refresh();
         looperThread.testComplete();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners_thenAdd() {
+        final Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setAge(13);
+        realm.commitTransaction();
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object) {
+                fail();
+            }
+        });
+        dog.removeAllChangeListeners();
+
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog dog) {
+                assertEquals(14, dog.getAge());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        dog.setAge(14);
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void removeChangeListener_throwOnUnmanagedObject() {
@@ -1712,13 +1822,25 @@ public void removeChangeListener_throwOnUnmanagedObject() {
             public void onChange(Dog object) {
             }
         };
+        RealmObjectChangeListener objectChangeListener = new RealmObjectChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object, ObjectChangeSet changeSet) {
+            }
+        };
 
         try {
             dog.removeChangeListener(listener);
             fail("Failed to remove a listener from null Realm.");
         } catch (IllegalArgumentException ignore) {
-            looperThread.testComplete();
         }
+
+        try {
+            dog.removeChangeListener(objectChangeListener);
+            fail("Failed to remove a listener from null Realm.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        looperThread.testComplete();
     }
 
     @Test
@@ -1738,7 +1860,7 @@ public void removeAllChangeListeners_throwOnUnmanagedObject() {
     @Test
     @RunTestInLooperThread
     public void addChangeListener_returnedObjectOfCopyToRealmOrUpdate() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         realm.createObject(AllTypesPrimaryKey.class, 1);
 
@@ -1748,7 +1870,7 @@ public void addChangeListener_returnedObjectOfCopyToRealmOrUpdate() {
         allTypesPrimaryKey = realm.copyToRealmOrUpdate(allTypesPrimaryKey);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(allTypesPrimaryKey);
+        looperThread.keepStrongReference(allTypesPrimaryKey);
         allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey element) {
@@ -1770,14 +1892,14 @@ public void onChange(AllTypesPrimaryKey element) {
     @RunTestInLooperThread
     public void addChangeListener_listenerShouldBeCalledIfObjectChangesAfterAsyncReturn() {
         final AtomicInteger listenerCounter = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         realm.createObject(AllTypesPrimaryKey.class, 1);
         realm.commitTransaction();
 
         // Step 1
         final AllTypesPrimaryKey allTypesPrimaryKey = realm.where(AllTypesPrimaryKey.class).findFirstAsync();
-        looperThread.keepStrongReference.add(allTypesPrimaryKey);
+        looperThread.keepStrongReference(allTypesPrimaryKey);
         allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey element) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 27f6cae43e..8be7cc00fa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -70,12 +70,12 @@
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
-    protected final static int TEST_DATA_SIZE = 10;
-    protected final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
+    private final static int TEST_DATA_SIZE = 10;
+    private final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
 
     private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
 
-    protected Realm realm;
+    private Realm realm;
 
     @Before
     public void setUp() throws Exception {
@@ -98,7 +98,7 @@ private void populateTestRealm(Realm testRealm, int dataSize) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.2345f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -139,8 +139,8 @@ private void populateNoPrimaryKeyNullTypesRows(Realm testRealm, int dataSize) {
             noPrimaryKeyNullTypes.setFieldLongNotNull((long) i);
             noPrimaryKeyNullTypes.setFieldFloatNull((i % 3) == 0 ? null : 1.2345f + i);
             noPrimaryKeyNullTypes.setFieldFloatNotNull(1.2345f + i);
-            noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : 3.1415 + i);
-            noPrimaryKeyNullTypes.setFieldDoubleNotNull(3.1415 + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : Math.PI + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNotNull(Math.PI + i);
             noPrimaryKeyNullTypes.setFieldDateNull((i % 3) == 0 ? null : new Date(DECADE_MILLIS * (i - (dataSize / 2))));
             noPrimaryKeyNullTypes.setFieldDateNotNull(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
         }
@@ -821,13 +821,13 @@ private void doTestForInDouble(String targetField) {
             fail();
         } catch (IllegalArgumentException ignored) {
         }
-        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1}).findAll();
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{Math.PI + 1}).findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{Math.PI + 2}).findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{Math.PI + 1, Math.PI + 2}).findAll();
         assertEquals(2, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Double[]{Math.PI + 1, Math.PI + 2}).findAll();
         assertEquals(198, resultList.size());
     }
 
@@ -996,7 +996,7 @@ public void in_dateNull() {
     public void in_doubleNotNull() {
         doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL);
         try {
-            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL, new Double[]{Math.PI + 1, null, Math.PI + 2}).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -1005,7 +1005,7 @@ public void in_doubleNotNull() {
     @Test
     public void in_doubleNull() {
         doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL);
-        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL, new Double[]{Math.PI + 1, null, Math.PI + 2}).findAll();
         assertEquals(131, resultList.size());
     }
 
@@ -2558,14 +2558,14 @@ public void isNull_listFieldThrows() {
             realm.where(Owner.class).isNull("dogs");
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+            assertEquals("Illegal Argument: RealmList(dogs) is not nullable.", expected.getMessage());
         }
 
         try {
             realm.where(Cat.class).isNull("owner.dogs");
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+            assertEquals("Illegal Argument: RealmList(dogs) is not nullable.", expected.getMessage());
         }
     }
 
@@ -2576,14 +2576,14 @@ public void isNotNull_listFieldThrows() {
             realm.where(Owner.class).isNotNull("dogs");
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+            assertEquals("Illegal Argument: RealmList(dogs) is not nullable.", expected.getMessage());
         }
 
         try {
             realm.where(Cat.class).isNotNull("owner.dogs");
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+            assertEquals("Illegal Argument: RealmList(dogs) is not nullable.", expected.getMessage());
         }
     }
 
@@ -2624,7 +2624,7 @@ public void run() {
             thread.start();
         }
 
-        latch.await();
+        TestHelper.awaitOrFail(latch);
     }
 
     @Test
@@ -2994,11 +2994,11 @@ public void findAllSorted_onSubObjectField() {
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync_onSubObjectField() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
                 .findAllSortedAsync(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> results) {
@@ -3029,7 +3029,7 @@ public void findAllSorted_listOnSubObjectField() {
     @Test
     @RunTestInLooperThread
     public void findAllSortedAsync_listOnSubObjectField() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         String[] fieldNames = new String[2];
         fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
         fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
@@ -3041,7 +3041,7 @@ public void findAllSortedAsync_listOnSubObjectField() {
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
                 .findAllSortedAsync(fieldNames, sorts);
-        looperThread.keepStrongReference.add(results);
+        looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> results) {
@@ -3060,11 +3060,11 @@ private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOf
                 AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
                 obj.setIndexBoolean(j % 2 == 0);
                 obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setIndexString(withNull ? null : "Test " + j);
                 obj.setNotIndexBoolean(j % 2 == 0);
                 obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setNotIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setNotIndexString(withNull ? null : "Test " + j);
                 obj.setFieldObject(obj);
             }
@@ -3114,12 +3114,13 @@ public void distinct_notIndexedFields() {
         final long numberOfObjects = 10;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).distinct(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
+                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
+                AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
 
@@ -3192,7 +3193,7 @@ public void distinct_invalidTypesLinkedFields() {
     @RunTestInLooperThread
     public void distinctAsync() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
@@ -3227,10 +3228,10 @@ public void run() {
             }
         };
 
-        looperThread.keepStrongReference.add(distinctBool);
-        looperThread.keepStrongReference.add(distinctLong);
-        looperThread.keepStrongReference.add(distinctDate);
-        looperThread.keepStrongReference.add(distinctString);
+        looperThread.keepStrongReference(distinctBool);
+        looperThread.keepStrongReference(distinctLong);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
         distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -3268,7 +3269,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     @RunTestInLooperThread
     public void distinctAsync_withNullValues() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(2);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
@@ -3287,8 +3288,8 @@ public void run() {
             }
         };
 
-        looperThread.keepStrongReference.add(distinctDate);
-        looperThread.keepStrongReference.add(distinctString);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
 
         distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index e2ebc99b39..b4ead0c1bf 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -267,12 +267,14 @@ public void distinct_notIndexedFields() {
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
+                .findAll().distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
+                AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll()
+                    .distinct(field);
+            assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
 
@@ -346,7 +348,7 @@ public void distinct_invalidTypesLinkedFields() {
     @Test
     @RunTestInLooperThread
     public void changeListener_syncIfNeeded_updatedFromOtherThread() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 10).findAll();
@@ -378,7 +380,7 @@ private void populateTestRealm(int objects) {
             allTypes.setColumnBoolean((i % 2) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - objects / 2)));
-            allTypes.setColumnDouble(3.1415 + i);
+            allTypes.setColumnDouble(Math.PI + i);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -402,7 +404,7 @@ private void populateTestRealm(Realm testRealm, int objects) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (objects / 2))));
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -419,7 +421,7 @@ private void populateTestRealm(Realm testRealm, int objects) {
     @RunTestInLooperThread
     public void distinctAsync() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
@@ -454,10 +456,10 @@ public void run() {
             }
         };
 
-        looperThread.keepStrongReference.add(distinctBool);
-        looperThread.keepStrongReference.add(distinctLong);
-        looperThread.keepStrongReference.add(distinctDate);
-        looperThread.keepStrongReference.add(distinctString);
+        looperThread.keepStrongReference(distinctBool);
+        looperThread.keepStrongReference(distinctLong);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
         distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -495,7 +497,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     @RunTestInLooperThread
     public void distinctAsync_withNullValues() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(2);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
@@ -520,8 +522,8 @@ public void run() {
             }
         };
 
-        looperThread.keepStrongReference.add(distinctDate);
-        looperThread.keepStrongReference.add(distinctString);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
         distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -542,18 +544,81 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_notIndexedFields() {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
+        Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING);
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
             }
-        }
-        looperThread.testComplete();
+        };
+
+        looperThread.keepStrongReference(distinctBool);
+        looperThread.keepStrongReference(distinctLong);
+        looperThread.keepStrongReference(distinctDate);
+        looperThread.keepStrongReference(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(2, distinctBool.size());
+                endTest.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                endTest.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                endTest.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctString.size());
+                endTest.run();
+            }
+        });
     }
 
     @Test
@@ -804,10 +869,10 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
     @Test
     @RunTestInLooperThread
     public void accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         // Step 1
         RealmResults<Dog> dogs = populateRealmResultsOnLinkView(realm);
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> dogs) {
@@ -865,9 +930,9 @@ public void execute(Realm realm) {
     @RunTestInLooperThread
     public void accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit() {
         // Step 1
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         RealmResults<Dog> dogs = populateRealmResultsOnLinkView(realm);
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> dogs) {
@@ -918,10 +983,10 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void addChangeListener() {
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -938,7 +1003,7 @@ public void onChange(RealmResults<AllTypes> object) {
     @RunTestInLooperThread
     public void addChangeListener_twice() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -966,7 +1031,7 @@ public void run() {
         });
 
         // Adding it twice will be ignored, so removing it will not cause the listener to be triggered.
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addChangeListener(listener);
         collection.addChangeListener(listener);
         collection.removeChangeListener(listener);
@@ -990,7 +1055,7 @@ public void addChangeListener_null() {
     @RunTestInLooperThread
     public void removeChangeListener() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -1000,7 +1065,7 @@ public void onChange(RealmResults<AllTypes> object) {
             }
         };
 
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addChangeListener(listener);
         collection.removeChangeListener(listener);
 
@@ -1035,7 +1100,7 @@ public void removeChangeListener_null() {
     @RunTestInLooperThread
     public void removeAllChangeListeners() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         RealmChangeListener<RealmResults<AllTypes>> listenerA = new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -1051,7 +1116,7 @@ public void onChange(RealmResults<AllTypes> object) {
             }
         };
 
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addChangeListener(listenerA);
         collection.addChangeListener(listenerB);
         collection.removeAllChangeListeners();
@@ -1073,6 +1138,33 @@ public void run() {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners_thenAdd() {
+        final Realm realm = looperThread.getRealm();
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+
+        collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                fail();
+            }
+        });
+        collection.removeAllChangeListeners();
+
+        collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                assertEquals(1, results.size());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
     @Test
     public void deleteAndDeleteAll() {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 92774d8fee..b4bce17087 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -38,12 +38,17 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
 import org.junit.runner.RunWith;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
 import java.io.File;
 import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
@@ -56,6 +61,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
@@ -116,6 +122,9 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 
 @RunWith(AndroidJUnit4.class)
 public class RealmTests {
@@ -128,6 +137,8 @@
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
+    public final TemporaryFolder tmpFolder = new TemporaryFolder();
+    @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
     private Context context;
@@ -168,7 +179,7 @@ private void populateTestRealm(Realm realm, int objects) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.234567f + i);
 
             allTypes.setColumnString("test data " + i);
@@ -370,13 +381,13 @@ public void where_equalTo_invalidFieldName() throws IOException {
         }
 
         try {
-            realm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415d).findAll();
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", Math.PI).findAll();
             fail("Invalid field name");
         } catch (Exception ignored) {
         }
 
         try {
-            realm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415f).findAll();
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", Math.PI).findAll();
             fail("Invalid field name");
         } catch (Exception ignored) {
         }
@@ -455,7 +466,7 @@ public void beginTransaction() throws IOException {
 
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
-        allTypes.setColumnFloat(3.1415f);
+        allTypes.setColumnFloat(3.14F);
         allTypes.setColumnString("a unique string");
         realm.commitTransaction();
 
@@ -464,7 +475,7 @@ public void beginTransaction() throws IOException {
 
         resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "a unique string").findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 3.1415f).findAll();
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 3.14F).findAll();
         assertEquals(1, resultList.size());
     }
 
@@ -1974,10 +1985,7 @@ public void deleteRealm() throws InterruptedException {
             public void run() {
                 Realm realm = Realm.getInstance(configuration);
                 bgThreadReadyLatch.countDown();
-                try {
-                    readyToCloseLatch.await();
-                } catch (InterruptedException ignored) {
-                }
+                TestHelper.awaitOrFail(readyToCloseLatch);
                 realm.close();
                 closedLatch.countDown();
             }
@@ -1995,7 +2003,7 @@ public void run() {
         readyToCloseLatch.countDown();
 
         realm.close();
-        closedLatch.await();
+        TestHelper.awaitOrFail(closedLatch);
         // Now we get log files back!
         assertTrue(tempDirRenamed.renameTo(tempDir));
 
@@ -2582,7 +2590,7 @@ public void run() {
         thatThread.start();
 
         // Timeout should never happen.
-        latch.await();
+        TestHelper.awaitOrFail(latch);
         if (threadAssertionError[0] != null) {
             throw threadAssertionError[0];
         }
@@ -2620,7 +2628,7 @@ public void run() {
         thatThread.start();
 
         // Timeout should never happen.
-        latch.await();
+        TestHelper.awaitOrFail(latch);
         if (threadAssertionError[0] != null) {
             throw threadAssertionError[0];
         }
@@ -2696,7 +2704,7 @@ public void closingRealmWhileOtherThreadIsOpeningRealm() throws Exception {
             @Override
             public void run() {
                 try {
-                    startLatch.await();
+                    startLatch.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     exception.add(e);
                     return;
@@ -2725,7 +2733,7 @@ public void run() {
             realm = null;
         }
 
-        endLatch.await();
+        TestHelper.awaitOrFail(endLatch);
 
         if (!exception.isEmpty()) {
             throw exception.get(0);
@@ -2752,7 +2760,7 @@ public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 realmOpenedInBgLatch.countDown();
                 try {
-                    realmClosedInFgLatch.await();
+                    realmClosedInFgLatch.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     exception.add(e);
                     realm.close();
@@ -2763,7 +2771,7 @@ public void run() {
                 realm.beginTransaction();
                 transBeganInBgLatch.countDown();
                 try {
-                    fgFinishedLatch.await();
+                    fgFinishedLatch.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS);
                 } catch (InterruptedException e) {
                     exception.add(e);
                 }
@@ -2775,16 +2783,16 @@ public void run() {
         });
         thread.start();
 
-        realmOpenedInBgLatch.await();
+        TestHelper.awaitOrFail(realmOpenedInBgLatch);
         // Step 3: Closes all realm instances in foreground thread.
         realm.close();
         realmClosedInFgLatch.countDown();
-        transBeganInBgLatch.await();
+        TestHelper.awaitOrFail(transBeganInBgLatch);
 
         // Step 5: Gets a new Realm instance in foreground.
         realm = Realm.getInstance(realmConfig);
         fgFinishedLatch.countDown();
-        bgFinishedLatch.await();
+        TestHelper.awaitOrFail(bgFinishedLatch);
 
         if (!exception.isEmpty()) {
             throw exception.get(0);
@@ -3074,7 +3082,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -3115,7 +3123,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnObject() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -3160,7 +3168,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnResults() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         final RealmChangeListener<RealmResults<AllTypes>> dummyListener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -3199,7 +3207,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         try {
             realm.addChangeListener(null);
@@ -3232,7 +3240,7 @@ public void run() throws Exception {
     @Test
     @RunTestInLooperThread
     public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         try {
             realm.removeChangeListener(null);
@@ -3690,34 +3698,34 @@ public void run(Realm realm) {
 
     @Test
     public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
-        final CatRealmProxy.CatColumnInfo catColumnInfo;
-        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.columnIndices.getColumnInfo(Cat.class);
+        final AtomicLong nameIndexNew = new AtomicLong(-1L);
 
+        // get the pre-update index for the "name" column.
+        CatRealmProxy.CatColumnInfo catColumnInfo
+                = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnInfo(Cat.class);
         final long nameIndex = catColumnInfo.nameIndex;
-        final AtomicLong nameIndexNew = new AtomicLong(-1L);
 
-        // Changes column index of "name".
+        // Change the index of the column "name".
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
                 final Table catTable = realm.getSchema().getTable(Cat.CLASS_NAME);
                 final long nameIndex = catTable.getColumnIndex(Cat.FIELD_NAME);
                 catTable.removeColumn(nameIndex);
-                final long newIndex = catTable.addColumn(RealmFieldType.STRING,
-                        Cat.FIELD_NAME, true);
-
+                final long newIndex = catTable.addColumn(RealmFieldType.STRING, Cat.FIELD_NAME, true);
                 realm.setVersion(realm.getConfiguration().getSchemaVersion() + 1);
-
                 nameIndexNew.set(newIndex);
             }
         });
+
         // We need to update index cache if the schema version was changed in the same thread.
         realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
 
-        // Checks if the index was changed.
+        // Verify that the index has changed.
         assertNotEquals(nameIndex, nameIndexNew);
 
-        // Checks if index in the ColumnInfo is updated.
+        // Verify that the index in the ColumnInfo has been updated.
+        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnInfo(Cat.class);
         assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
         assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
 
@@ -3829,4 +3837,37 @@ public boolean accept(File dir, String name) {
         realmOnExternalStorage = Realm.getInstance(config);
         realmOnExternalStorage.close();
     }
+
+    // Verify that the logic for waiting for the users file dir to be come available isn't totally broken
+    // This is pretty hard to test, so forced to break encapsulation in this case.
+    @Test
+    public void init_waitForFilesDir() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {
+        java.lang.reflect.Method m = Realm.class.getDeclaredMethod("checkFilesDirAvailable", Context.class);
+        m.setAccessible(true);
+
+        // A) Check it fails if getFilesDir is never created
+        Context mockContext = mock(Context.class);
+        when(mockContext.getFilesDir()).thenReturn(null);
+
+        try {
+            m.invoke(null, mockContext);
+            fail();
+        } catch (InvocationTargetException e) {
+            assertEquals(IllegalStateException.class, e.getCause().getClass());
+        }
+
+        // B) Check we return if the filesDir becomes available after a while
+        mockContext = mock(Context.class);
+        when(mockContext.getFilesDir()).then(new Answer<File>() {
+            int calls = 0;
+            File userFolder = tmpFolder.newFolder();
+            @Override
+            public File answer(InvocationOnMock invocationOnMock) throws Throwable {
+                calls++;
+                return (calls > 5) ? userFolder : null; // Start returning the correct folder after 5 attempts
+            }
+        });
+
+        assertNull(m.invoke(null, mockContext));
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index e306343516..eafe61d82d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -105,7 +105,7 @@ public void call(AllTypes rxObject) {
     @RunTestInLooperThread
     public void realmObject_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
@@ -167,7 +167,7 @@ public void call(AllTypes rxObject) {
     @RunTestInLooperThread
     public void findFirstAsync_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
@@ -189,7 +189,7 @@ public void call(AllTypes rxObject) {
     @RunTestInLooperThread
     public void findFirstAsync_emittedOnDelete() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
@@ -282,7 +282,7 @@ public void call(RealmResults<DynamicRealmObject> rxResults) {
     @RunTestInLooperThread
     public void realmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.commitTransaction();
@@ -305,7 +305,7 @@ public void call(RealmResults<AllTypes> allTypes) {
     @RunTestInLooperThread
     public void realmList_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
@@ -329,7 +329,7 @@ public void call(RealmList<Dog> dogs) {
     @RunTestInLooperThread
     public void dynamicRealmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         dynamicRealm.beginTransaction();
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         dynamicRealm.commitTransaction();
@@ -370,7 +370,7 @@ public void call(RealmResults<AllTypes> rxResults) {
     @RunTestInLooperThread
     public void findAllAsync_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         subscription = realm.where(AllTypes.class).findAllAsync().asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
             @Override
             public void call(RealmResults<AllTypes> rxResults) {
@@ -404,7 +404,7 @@ public void call(Realm rxRealm) {
     @RunTestInLooperThread
     public void realm_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
+        Realm realm = looperThread.getRealm();
         subscription = realm.asObservable().subscribe(new Action1<Realm>() {
             @Override
             public void call(Realm rxRealm) {
@@ -445,7 +445,7 @@ public void call(Throwable throwable) {
     @Test
     @RunTestInLooperThread
     public void dynamicRealm_emittedOnUpdate() {
-        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
             @Override
@@ -700,7 +700,7 @@ public void call(DynamicRealmObject obj) {
     public void realmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -743,7 +743,7 @@ public void call(Throwable throwable) {
     public void dynamicRealmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
-        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
 
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -787,7 +787,7 @@ public void call(Throwable throwable) {
     public void realmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -830,7 +830,7 @@ public void call(Throwable throwable) {
     public void dynamicRealmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
-        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
 
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 6e95a08106..06f6bd6b49 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -343,7 +343,7 @@ public void realmSortMultiFailures() {
     public void resorting() throws InterruptedException {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
 
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.setAutoRefresh(true);
 
         final Runnable endTest = new Runnable() {
@@ -364,7 +364,7 @@ public void run() {
 
         // rr0: [0, 1, 2, 3]
         final RealmResults<AllTypes> rr0 = realm.where(AllTypes.class).findAll();
-        looperThread.keepStrongReference.add(rr0);
+        looperThread.keepStrongReference(rr0);
         rr0.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -376,7 +376,7 @@ public void onChange(RealmResults<AllTypes> element) {
 
         // rr1: [1, 2, 0, 3]
         final RealmResults<AllTypes> rr1 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.ASCENDING);
-        looperThread.keepStrongReference.add(rr1);
+        looperThread.keepStrongReference(rr1);
         rr1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -392,7 +392,7 @@ public void onChange(RealmResults<AllTypes> element) {
 
         // rr2: [0, 3, 1, 2]
         final RealmResults<AllTypes> rr2 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.DESCENDING);
-        looperThread.keepStrongReference.add(rr2);
+        looperThread.keepStrongReference(rr2);
         rr2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -481,7 +481,7 @@ public void run() {
 
         RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
         assertEquals(TEST_SIZE, objectsAscending.size());
-        looperThread.keepStrongReference.add(objectsAscending);
+        looperThread.keepStrongReference(objectsAscending);
         objectsAscending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -497,7 +497,7 @@ public void onChange(RealmResults<AllTypes> element) {
 
         RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
         assertEquals(TEST_SIZE, objectsDescending.size());
-        looperThread.keepStrongReference.add(objectsDescending);
+        looperThread.keepStrongReference(objectsDescending);
         objectsDescending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 064af91f02..a688249e8c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -31,7 +31,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
@@ -67,8 +66,13 @@
 import static junit.framework.Assert.fail;
 
 public class TestHelper {
+    public static final int VERY_SHORT_WAIT_SECS = 1;
+    public static final int SHORT_WAIT_SECS = 10;
+    public static final int STANDARD_WAIT_SECS = 100;
+    public static final int LONG_WAIT_SECS = 1000;
 
     private static final Charset UTF_8 = Charset.forName("UTF-8");
+    private static final Random RANDOM = new Random();
 
     public static class ExpectedCountCallback implements RealmCache.Callback {
 
@@ -159,7 +163,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     // Returns a random key used by encrypted Realms.
     public static byte[] getRandomKey() {
         byte[] key = new byte[64];
-        new Random().nextBytes(key);
+        RANDOM.nextBytes(key);
         return key;
     }
 
@@ -778,14 +782,14 @@ public static void populateForDistinctFieldsOrder(Realm realm, long numberOfBloc
     }
 
     public static void awaitOrFail(CountDownLatch latch) {
-        awaitOrFail(latch, 60);
+        awaitOrFail(latch, STANDARD_WAIT_SECS);
     }
 
     public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
         try {
             if (android.os.Debug.isDebuggerConnected()) {
-                // If we are debugging the tests, just waits without a timeout. In case we are stopping at a break point
-                // and timeout happens.
+                // If we are debugging the tests, just waits without a timeout.
+                // Don't want a timeout while we are stopped at a break point.
                 latch.await();
             } else if (!latch.await(numberOfSeconds, TimeUnit.SECONDS)) {
                 fail("Test took longer than " + numberOfSeconds + " seconds");
@@ -795,36 +799,40 @@ public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
         }
     }
 
+    public interface LooperTest {
+        CountDownLatch getRealmClosedSignal();
+        Looper getLooper();
+        Throwable getAssertionError();
+    }
+
     // Cleans resource, shutdowns the executor service and throws any background exception.
     @SuppressWarnings("Finally")
-    public static void exitOrThrow(final ExecutorService executorService,
-                                   final CountDownLatch signalTestFinished,
-                                   final CountDownLatch signalClosedRealm,
-                                   final Looper[] looper,
-                                   final Throwable[] throwable) throws Throwable {
+    public static void exitOrThrow(ExecutorService executorService, CountDownLatch testFinishedSignal, LooperTest test) throws Throwable {
 
         // Waits for the signal indicating the test's use case is done.
         try {
             // Even if this fails we want to try as hard as possible to cleanup. If we fail to close all resources
             // properly, the `after()` method will most likely throw as well because it tries do delete any Realms
             // used. Any exception in the `after()` code will mask the original error.
-            TestHelper.awaitOrFail(signalTestFinished);
+            TestHelper.awaitOrFail(testFinishedSignal);
         } finally {
-            if (looper[0] != null) {
+            Looper looper = test.getLooper();
+            if (looper != null) {
                 // Failing to quit the looper will not execute the finally block responsible
                 // of closing the Realm.
-                looper[0].quit();
+                looper.quit();
             }
 
             // Waits for the finally block to execute and closes the Realm.
-            TestHelper.awaitOrFail(signalClosedRealm);
+            TestHelper.awaitOrFail(test.getRealmClosedSignal());
             // Closes the executor.
             // This needs to be called after waiting since it might interrupt waitRealmThreadExecutorFinish().
             executorService.shutdownNow();
 
-            if (throwable[0] != null) {
+            Throwable fault = test.getAssertionError();
+            if (fault != null) {
                 // Throws any assertion errors happened in the background thread.
-                throw throwable[0];
+                throw fault;
             }
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index e3150acf8c..aa4c01fc54 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -82,7 +82,7 @@ public void setUp() {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -102,7 +102,7 @@ public void run() {
         final Dog dog = realm.createObject(Dog.class);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -119,8 +119,8 @@ public void onChange(Dog object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject_dynamic_realm() {
-        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
-        looperThread.keepStrongReference.add(realm);
+        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.keepStrongReference(realm);
         realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
             @Override
             public void onChange(DynamicRealm object) {
@@ -141,7 +141,7 @@ public void run() {
         final DynamicRealmObject dog = realm.createObject("Dog");
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
             public void onChange(DynamicRealmObject object) {
@@ -159,7 +159,7 @@ public void onChange(DynamicRealmObject object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealm() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -181,7 +181,7 @@ public void run() {
         final Dog dog = realm.copyToRealm(akamaru);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -199,7 +199,7 @@ public void onChange(Dog object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealmOrUpdate() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -223,7 +223,7 @@ public void run() {
         final PrimaryKeyAsLong primaryKeyAsLong = realm.copyToRealmOrUpdate(obj);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(primaryKeyAsLong);
+        looperThread.keepStrongReference(primaryKeyAsLong);
         primaryKeyAsLong.addChangeListener(new RealmChangeListener<PrimaryKeyAsLong>() {
             @Override
             public void onChange(PrimaryKeyAsLong object) {
@@ -250,22 +250,7 @@ public void onChange(PrimaryKeyAsLong object) {
     public void callback_should_trigger_for_createObjectFromJson() {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
 
-        final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                if (globalCommitInvocations.incrementAndGet() == 1) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(1, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
-
+        final Realm realm = looperThread.getRealm();
         try {
             InputStream in = TestHelper.loadJsonFromAssets(InstrumentationRegistry.getTargetContext(), "all_simple_types.json");
             realm.beginTransaction();
@@ -273,7 +258,7 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
-            looperThread.keepStrongReference.add(objectFromJson);
+            looperThread.keepStrongReference(objectFromJson);
             objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
                 public void onChange(AllTypes object) {
@@ -283,7 +268,7 @@ public void onChange(AllTypes object) {
                     assertEquals(1.23D, objectFromJson.getColumnDouble(), 0D);
                     assertEquals(true, objectFromJson.isColumnBoolean());
                     assertArrayEquals(new byte[]{1, 2, 3}, objectFromJson.getColumnBinary());
-                    typebasedCommitInvocations.incrementAndGet();
+                    looperThread.testComplete();
                 }
             });
 
@@ -300,21 +285,7 @@ public void onChange(AllTypes object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
-        final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                if (globalCommitInvocations.incrementAndGet() == 1) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(1, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
+        final Realm realm = looperThread.getRealm();
 
         try {
             JSONObject json = new JSONObject();
@@ -329,7 +300,7 @@ public void run() {
             final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, json);
             realm.commitTransaction();
 
-            looperThread.keepStrongReference.add(objectFromJson);
+            looperThread.keepStrongReference(objectFromJson);
             objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
                 public void onChange(AllTypes object) {
@@ -339,7 +310,7 @@ public void onChange(AllTypes object) {
                     assertEquals(1.23D, objectFromJson.getColumnDouble(), 0D);
                     assertEquals(true, objectFromJson.isColumnBoolean());
                     assertArrayEquals(new byte[]{1, 2, 3}, objectFromJson.getColumnBinary());
-                    typebasedCommitInvocations.incrementAndGet();
+                    looperThread.testComplete();
                 }
             });
 
@@ -358,7 +329,7 @@ public void onChange(AllTypes object) {
     public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
 
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -395,7 +366,7 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
-            looperThread.keepStrongReference.add(objectFromJson);
+            looperThread.keepStrongReference(objectFromJson);
             objectFromJson.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
                 @Override
                 public void onChange(AllTypesPrimaryKey object) {
@@ -424,7 +395,7 @@ public void onChange(AllTypesPrimaryKey object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson_from_JSONObject() throws JSONException {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -455,7 +426,7 @@ public void run() {
         final AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
         realm.commitTransaction();
 
-        looperThread.keepStrongReference.add(newObj);
+        looperThread.keepStrongReference(newObj);
         newObj.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey object) {
@@ -480,7 +451,7 @@ public void onChange(AllTypesPrimaryKey object) {
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmobject_sync() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         // Step 1: Creates object
         realm.beginTransaction();
@@ -489,7 +460,7 @@ public void callback_with_relevant_commit_realmobject_sync() {
         realm.commitTransaction();
 
         final Dog dog = realm.where(Dog.class).findFirst();
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -520,7 +491,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmobject_async() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         // Step 1: Creates object.
         realm.beginTransaction();
@@ -530,7 +501,7 @@ public void callback_with_relevant_commit_realmobject_async() {
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
 
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -572,7 +543,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmresults_sync() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         // Step 1: Creates object.
         realm.beginTransaction();
@@ -581,7 +552,7 @@ public void callback_with_relevant_commit_realmresults_sync() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -614,7 +585,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void callback_with_relevant_commit_realmresults_async() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         // Step 1: Creates object.
         realm.beginTransaction();
@@ -623,7 +594,7 @@ public void callback_with_relevant_commit_realmresults_async() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -670,7 +641,7 @@ public void execute(Realm realm) {
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmobject_sync() {
         final int NUMBER_OF_LISTENERS = 7;
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -689,7 +660,7 @@ public void run() {
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
@@ -709,21 +680,7 @@ public void onChange(Dog object) {
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmobject_async() {
         final int NUMBER_OF_LISTENERS = 7;
-        final Realm realm = looperThread.realm;
-        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                looperThread.postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
-                        looperThread.testComplete();
-                    }
-                });
-            }
-        };
-
-        realm.addChangeListener(listener);
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
         Dog akamaru = realm.createObject(Dog.class);
@@ -731,12 +688,23 @@ public void run() {
 
         Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
                 public void onChange(Dog object) {
                     typebasedCommitInvocations.incrementAndGet();
+                    if (typebasedCommitInvocations.get() > NUMBER_OF_LISTENERS) {
+                        fail();
+                    } else if (typebasedCommitInvocations.get() == NUMBER_OF_LISTENERS) {
+                        // Delayed post in case the listener gets triggered more time than expected.
+                        looperThread.postRunnableDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                looperThread.testComplete();
+                            }
+                        }, 500);
+                    }
                 }
             });
         }
@@ -751,14 +719,14 @@ public void onChange(Dog object) {
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmresults_sync() {
         final int NUMBER_OF_LISTENERS = 7;
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
         Dog akamaru = realm.createObject(Dog.class);
         realm.commitTransaction();
 
         RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
@@ -782,7 +750,7 @@ public void onChange(RealmResults<Dog> results) {
     @RunTestInLooperThread
     public void multiple_callbacks_should_be_invoked_realmresults_async() {
         final int NUMBER_OF_LISTENERS = 7;
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
         Dog akamaru = realm.createObject(Dog.class);
@@ -804,7 +772,7 @@ public void run() {
         RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
 
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
@@ -831,117 +799,67 @@ public void onChange(RealmResults<Dog> object) {
     @Test
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_sync() {
-        final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                if (realm.where(Dog.class).count() == 2) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(1, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
         realm.createObject(Dog.class);
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                typebasedCommitInvocations.incrementAndGet();
+                assertEquals(17, object.getAge());
+                looperThread.testComplete();
             }
         });
 
-        Thread thread = new Thread() {
+        realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
-                bgRealm.beginTransaction();
-                bgRealm.createObject(Dog.class);
-                bgRealm.commitTransaction();
-                bgRealm.close();
+            public void execute(Realm realm) {
+                realm.where(Dog.class).findFirst().setAge(17);
             }
-        };
-        thread.start();
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
+        });
     }
 
     // UC 3 Async RealmObject.
     // 1. Creates RealmObject async query.
-    // 2. Waits COMPLETED_ASYNC_REALM_OBJECT then commits transaction in another non-looper thread.
+    // 2. Waits async returns then change the object.
     // 3. Listener on the RealmObject gets triggered again.
     @Test
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_async() {
-        final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                // Checks if the 2nd transaction is committed.
-                if (realm.where(Dog.class).count() == 2) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(2, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
+        final Realm realm = looperThread.getRealm();
 
         realm.beginTransaction();
-        realm.createObject(Dog.class);
+        realm.createObject(Dog.class).setAge(1);
         realm.commitTransaction();
 
-        final Thread thread = new Thread() {
-            @Override
-            public void run() {
-                if (typebasedCommitInvocations.get() != 1) {
-                    try {
-                        Thread.sleep(200);
-                    } catch (InterruptedException e) {
-                        fail(e.getMessage());
-                    }
-                }
-                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
-                bgRealm.beginTransaction();
-                bgRealm.createObject(Dog.class);
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-
         Dog dog = realm.where(Dog.class).findFirstAsync();
-        looperThread.keepStrongReference.add(dog);
+        looperThread.keepStrongReference(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                typebasedCommitInvocations.incrementAndGet();
-
-                if (typebasedCommitInvocations.get() == 1) {
-                    try {
-                        thread.join();
-                    } catch (InterruptedException e) {
-                        fail(e.getMessage());
-                    }
+                switch (typebasedCommitInvocations.incrementAndGet()) {
+                    case 1:
+                        assertEquals(1, object.getAge());
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.where(Dog.class).findFirst().setAge(17);
+                            }
+                        });
+                        break;
+                    case 2:
+                        assertEquals(17, object.getAge());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
                 }
             }
         });
-
-        thread.start();
     }
 
     // UC 3 Sync RealmResults.
@@ -951,7 +869,7 @@ public void onChange(Dog object) {
     @Test
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmresults_sync() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -972,7 +890,7 @@ public void run() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -1006,7 +924,7 @@ public void run() {
     @Test
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmresults_async() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
@@ -1038,7 +956,7 @@ public void run() {
         };
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -1162,7 +1080,7 @@ public void onChange(RealmResults<Dog> object) {
     @Test
     @RunTestInLooperThread
     public void changeListener_onResultsBuiltOnDeletedLinkView() {
-        final Realm realm = looperThread.realm;
+        final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
         for (int i = 0; i < 10; i++) {
@@ -1174,7 +1092,7 @@ public void changeListener_onResultsBuiltOnDeletedLinkView() {
 
         final RealmResults<Dog> dogs =
                 allTypes.getColumnRealmList().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
-        looperThread.keepStrongReference.add(dogs);
+        looperThread.keepStrongReference(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
index 1419d5368b..ece9bca332 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
@@ -18,6 +18,9 @@
 import io.realm.RealmObject;
 
 public class BacklinksSource extends RealmObject {
+    public static final String CLASS_NAME = "BacklinksSource";
+    public static final String FIELD_CHILD = "child";
+
     private BacklinksTarget child;
 
     public BacklinksTarget getChild() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
index ddb0ea6f80..da3ee95be2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
@@ -20,6 +20,10 @@
 import io.realm.annotations.LinkingObjects;
 
 public class BacklinksTarget extends RealmObject {
+    public static final String CLASS_NAME = "BacklinksTarget";
+    public static final String FIELD_ID = "id";
+    public static final String FIELD_PARENTS = "parents";
+
     private int id;
 
     @LinkingObjects("child")
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
index d6b2046a9f..4064e2b395 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
@@ -30,6 +30,7 @@
     public static final String FIELD_HEIGHT = "height";
     public static final String FIELD_WEIGHT = "weight";
     public static final String FIELD_BIRTHDAY = "birthday";
+    public static final String FIELD_HAS_TAIL = "hasTail";
 
     @Index
     private String name;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index e63fd0fb1a..83ca6db974 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -196,12 +196,12 @@ public void sort() {
 
     @Test
     public void clear() {
-        assertEquals(table.size(), 4);
+        assertEquals(4, table.size());
         Collection collection = new Collection(sharedRealm, table.where());
         sharedRealm.beginTransaction();
         collection.clear();
         sharedRealm.commitTransaction();
-        assertEquals(table.size(), 0);
+        assertEquals(0, table.size());
     }
 
     @Test
@@ -217,7 +217,7 @@ public void indexOf() {
 
         Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
         UncheckedRow row = table.getUncheckedRow(0);
-        assertEquals(collection.indexOf(row), 3);
+        assertEquals(3, collection.indexOf(row));
     }
 
     @Test
@@ -225,7 +225,7 @@ public void indexOf_long() {
         SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
 
         Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
-        assertEquals(collection.indexOf(0), 3);
+        assertEquals(3, collection.indexOf(0));
     }
 
     @Test
@@ -240,8 +240,8 @@ public void distinct() {
         assertEquals(3, collection.size());
         assertEquals(2, collection2.size());
 
-        assertEquals(collection2.getUncheckedRow(0).getLong(2), 3);
-        assertEquals(collection2.getUncheckedRow(1).getLong(2), 1);
+        assertEquals(3, collection2.getUncheckedRow(0).getLong(2));
+        assertEquals(1, collection2.getUncheckedRow(1).getLong(2));
     }
 
     // 1. Create a results and add listener.
@@ -253,12 +253,12 @@ public void addListener_shouldBeCalledToReturnTheQueryResults() {
         Table table = sharedRealm.getTable("test_table");
 
         final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 4);
+                assertEquals(collection, collection1);
+                assertEquals(4, collection1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -277,8 +277,8 @@ public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 4);
+                assertEquals(collection, collection1);
+                assertEquals(4, collection1.size());
                 sharedRealm.close();
                 onChangeCalled.set(true);
             }
@@ -323,7 +323,7 @@ public void addListener_triggeredByRefresh() {
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection element) {
-                assertEquals(latch.getCount(), 1);
+                assertEquals(1, latch.getCount());
                 latch.countDown();
             }
         });
@@ -342,12 +342,12 @@ public void addListener_queryNotReturned() {
         Table table = sharedRealm.getTable("test_table");
 
         final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 5);
+                assertEquals(collection, collection1);
+                assertEquals(5, collection1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -363,13 +363,13 @@ public void addListener_queryReturned() {
         Table table = sharedRealm.getTable("test_table");
 
         final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         assertEquals(collection.size(), 4); // Trigger the query to run.
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
-                assertEquals(collection1, collection);
-                assertEquals(collection1.size(), 5);
+                assertEquals(collection, collection1);
+                assertEquals(5, collection1.size());
                 sharedRealm.close();
                 looperThread.testComplete();
             }
@@ -378,7 +378,8 @@ public void onChange(Collection collection1) {
         addRowAsync();
     }
 
-    // Local commit will trigger the listener first when beginTransaction gets called then again in the next event loop.
+    // Local commit will trigger the listener first when beginTransaction gets called then again when transaction
+    // committed.
     @Test
     @RunTestInLooperThread
     public void addListener_triggeredByLocalCommit() {
@@ -387,24 +388,27 @@ public void addListener_triggeredByLocalCommit() {
         final AtomicInteger listenerCounter = new AtomicInteger(0);
 
         final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
             public void onChange(Collection collection1) {
                 switch (listenerCounter.getAndIncrement()) {
                     case 0:
-                        assertEquals(collection1.size(), 4);
+                        assertEquals(4, collection1.size());
                         break;
                     case 1:
-                        assertEquals(collection1.size(), 5);
+                        assertEquals(5, collection1.size());
                         sharedRealm.close();
-                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
                         break;
                 }
             }
         });
         addRow(sharedRealm);
-        assertEquals(collection.size(), 5);
+        assertEquals(2, listenerCounter.get());
+        looperThread.testComplete();
     }
 
     private static class TestIterator extends Collection.Iterator<Integer> {
@@ -464,7 +468,7 @@ public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
         Table table = sharedRealm.getTable("test_table");
         final Collection collection = new Collection(sharedRealm, table.where());
         final TestIterator iterator = new TestIterator(collection);
-        looperThread.keepStrongReference.add(collection);
+        looperThread.keepStrongReference(collection);
         assertFalse(iterator.isDetached(sharedRealm));
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
@@ -482,6 +486,14 @@ public void onChange(Collection element) {
         addRowAsync();
     }
 
+    @Test
+    public void collectionIterator_newInstance_throwsWhenSharedRealmIsClosed() {
+        final Collection collection = new Collection(sharedRealm, table.where());
+        sharedRealm.close();
+        thrown.expect(IllegalStateException.class);
+        new TestIterator(collection);
+    }
+
     @Test
     public void getMode() {
         Collection collection = new Collection(sharedRealm, table.where());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index bbe3cbfa19..e387e92c1f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -75,13 +75,13 @@ public void rowOperationsOnZeroRow(){
 
         Table t = new Table();
         // Removes rows without columns.
-        try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { t.moveLastOver(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { t.moveLastOver(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
 
         // Column added, remove rows again.
         t.addColumn(RealmFieldType.STRING, "");
-        try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { t.moveLastOver(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { t.moveLastOver(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
 
     }
 
@@ -315,34 +315,6 @@ public void tableNumbers() {
         assertEquals(3000.0f, t.getFloat(2, 5));
     }
 
-    @Test
-    public void maximumDate() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
-
-        table.add(new Date(0));
-        table.add(new Date(10000));
-        table.add(new Date(1000));
-
-        assertEquals(new Date(10000), table.maximumDate(0));
-
-    }
-
-    @Test
-    public void minimumDate() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
-
-        table.add(new Date(10000));
-        table.add(new Date(0));
-        table.add(new Date(1000));
-
-        assertEquals(new Date(0), table.minimumDate(0));
-
-    }
-
     // Tests the migration of a string column to be nullable.
     @Test
     public void convertToNullable() {
@@ -387,7 +359,7 @@ public void convertToNullable() {
                         }
                     } catch (IllegalArgumentException ignored) {
                     }
-                    table.removeLast();
+                    table.moveLastOver(table.size() - 1);
                     assertEquals(1, table.size());
 
                     table.convertColumnToNullable(colIndex);
@@ -485,7 +457,7 @@ else if (columnType == RealmFieldType.STRING)
                         }
                     } catch (IllegalArgumentException ignored) {
                     }
-                    table.removeLast();
+                    table.moveLastOver(table.size() -1);
                     assertEquals(2, table.size());
 
                     if (columnType == RealmFieldType.BINARY) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index cbf00b2ceb..e04e8b4d4f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -242,7 +242,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         table2.addSearchIndex(column2);
         try {
             table2.setPrimaryKey(column2);
-        } catch (RealmError ignored) {
+        } catch (IllegalStateException ignored) {
             // Column has no search index.
         }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
index 6c70f71d1a..0516f0e115 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -85,7 +85,7 @@ public void run() {
     @RunTestInLooperThread
     public void addChangeListener_byLocalChanges() {
         final AtomicBoolean commitReturns = new AtomicBoolean(false);
-        SharedRealm sharedRealm = getSharedRealm(looperThread.realmConfiguration);
+        SharedRealm sharedRealm = getSharedRealm(looperThread.getConfiguration());
         sharedRealm.realmNotifier.addChangeListener(sharedRealm, new RealmChangeListener<SharedRealm>() {
             @Override
             public void onChange(SharedRealm sharedRealm) {
@@ -121,10 +121,10 @@ public void addChangeListener_byRemoteChanges() {
         final AtomicInteger commitCounter = new AtomicInteger(0);
         final AtomicInteger listenerCounter = new AtomicInteger(0);
 
-        looperThread.realm.close();
+        looperThread.getRealm().close();
 
-        SharedRealm sharedRealm = getSharedRealm(looperThread.realmConfiguration);
-        looperThread.keepStrongReference.add(sharedRealm);
+        SharedRealm sharedRealm = getSharedRealm(looperThread.getConfiguration());
+        looperThread.keepStrongReference(sharedRealm);
         sharedRealm.realmNotifier.addChangeListener(sharedRealm, new RealmChangeListener<SharedRealm>() {
             @Override
             public void onChange(SharedRealm sharedRealm) {
@@ -135,21 +135,22 @@ public void onChange(SharedRealm sharedRealm) {
                     sharedRealm.close();
                     looperThread.testComplete();
                 } else {
-                    makeRemoteChanges(looperThread.realmConfiguration);
+                    makeRemoteChanges(looperThread.getConfiguration());
                     commitCounter.getAndIncrement();
                 }
             }
         });
-        makeRemoteChanges(looperThread.realmConfiguration);
+        makeRemoteChanges(looperThread.getConfiguration());
         commitCounter.getAndIncrement();
     }
 
     @Test
     @RunTestInLooperThread
     public void removeChangeListeners() {
-        SharedRealm sharedRealm = getSharedRealm(looperThread.realmConfiguration);
+        SharedRealm sharedRealm = getSharedRealm(looperThread.getConfiguration());
         Integer dummyObserver = 1;
-        looperThread.keepStrongReference.add(dummyObserver);
+        looperThread.keepStrongReference(dummyObserver);
+        looperThread.keepStrongReference(sharedRealm);
         sharedRealm.realmNotifier.addChangeListener(dummyObserver, new RealmChangeListener<Integer>() {
             @Override
             public void onChange(Integer dummy) {
@@ -167,6 +168,6 @@ public void onChange(SharedRealm sharedRealm) {
         // This should only remove the listeners related with dummyObserver
         sharedRealm.realmNotifier.removeChangeListeners(dummyObserver);
 
-        makeRemoteChanges(looperThread.realmConfiguration);
+        makeRemoteChanges(looperThread.getConfiguration());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index fde073a78c..c735e2dcf1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -53,7 +53,9 @@ public void setUp() {
 
     @After
     public void tearDown() {
-        sharedRealm.close();
+        if (sharedRealm != null) {
+            sharedRealm.close();
+        }
     }
 
     @Test
@@ -100,6 +102,13 @@ public void isInTransaction() {
         assertFalse(sharedRealm.isInTransaction());
     }
 
+    @Test
+    public void isInTransaction_returnFalseWhenRealmClosed() {
+        sharedRealm.close();
+        assertFalse(sharedRealm.isInTransaction());
+        sharedRealm = null;
+    }
+
     @Test
     public void removeTable() {
         sharedRealm.beginTransaction();
@@ -231,4 +240,19 @@ public void onSchemaVersionChanged(long currentVersion) {
         assertTrue(listenerCalled.get());
         assertEquals(before + 1, schemaVersionFromListener.get());
     }
+
+    @Test
+    public void isClosed() {
+        sharedRealm.close();
+        assertTrue(sharedRealm.isClosed());
+        sharedRealm = null;
+    }
+
+    @Test
+    public void close_twice() {
+        sharedRealm.close();
+        sharedRealm.close();
+        assertTrue(sharedRealm.isClosed());
+        sharedRealm = null;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index b5c26f71fd..1212415ce0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -120,16 +120,6 @@ public void getInstanceForDistinct_multipleFields() {
         assertEquals(intColumn, sortDescriptor.getColumnIndices()[1][0]);
     }
 
-    @Test
-    public void getInstanceForDistinct_shouldThrowIfNoSearchIndex() {
-        RealmFieldType type = RealmFieldType.STRING;
-        table.addColumn(type, type.name());
-
-        thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("must be indexed");
-        SortDescriptor.getInstanceForDistinct(table, type.name());
-    }
-
     @Test
     public void getInstanceForDistinct_shouldThrowOnInvalidField() {
         List<RealmFieldType> types = new ArrayList<RealmFieldType>();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java b/realm/realm-library/src/androidTest/java/io/realm/log/RealmLogTests.java
similarity index 74%
rename from realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/log/RealmLogTests.java
index c10ebbbb5b..8584214176 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/log/RealmLogTests.java
@@ -1,4 +1,4 @@
-package io.realm;
+package io.realm.log;
 
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
@@ -7,10 +7,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.log.LogLevel;
-import io.realm.log.RealmLog;
+import io.realm.Realm;
+import io.realm.TestHelper;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNull;
 import static junit.framework.Assert.assertTrue;
 
@@ -27,10 +28,8 @@ public void add_remove() {
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         RealmLog.add(testLogger);
         RealmLog.fatal("TEST");
-        assertEquals("TEST", testLogger.message);
         RealmLog.remove(testLogger);
         RealmLog.fatal("TEST_AGAIN");
-        assertEquals("TEST", testLogger.message);
     }
 
     @Test
@@ -91,4 +90,23 @@ public void throwable_passedToTheJavaLogger() {
         assertTrue(testLogger.message.contains("RealmLogTests.java"));
         RealmLog.remove(testLogger);
     }
+
+    @Test
+    public void coreLoggerBridge() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.setLevel(LogLevel.INFO);
+        RealmLog.add(testLogger);
+
+        long ptr = RealmLog.nativeCreateCoreLoggerBridge("TEST");
+        RealmLog.nativeLogToCoreLoggerBridge(ptr, LogLevel.INFO, "42");
+        assertTrue(testLogger.message.equals("42"));
+
+        RealmLog.setLevel(LogLevel.FATAL);
+        RealmLog.nativeLogToCoreLoggerBridge(ptr, LogLevel.INFO, "44");
+        assertTrue(testLogger.message.equals("42"));
+        assertFalse(testLogger.message.equals("44"));
+        RealmLog.nativeLogToCoreLoggerBridge(ptr, LogLevel.FATAL, "45");
+        assertTrue(testLogger.message.equals("45"));
+        RealmLog.nativeCloseCoreLoggerBridge(ptr);
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 186040bdec..49d1ececa6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -20,11 +20,12 @@
 import android.os.Looper;
 
 import org.junit.runner.Description;
+import org.junit.runners.model.MultipleFailureException;
 import org.junit.runners.model.Statement;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
+import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.UUID;
@@ -38,188 +39,222 @@
 import io.realm.RealmConfiguration;
 import io.realm.TestHelper;
 
-import static org.junit.Assert.fail;
 
 /**
  * Rule that runs the test inside a worker looper thread. This rule is responsible
- * of creating a temp directory containing a Realm instance then delete it, once the test finishes.
- *
+ * of creating a temp directory containing a Realm instance then deleting it, once the test finishes.
+ * <p>
  * All Realms used in a method method annotated with {@code @RunTestInLooperThread } should use
- * {@link RunInLooperThread#createConfiguration()} and friends to create their configurations. Failing to do so can
- * result in the test failing because the Realm could not be deleted (Reason is that {@link TestRealmConfigurationFactory}
- * and this class does not agree in which order to delete all open Realms.
+ * {@link RunInLooperThread#createConfiguration()} and friends to create their configurations.
+ * Failing to do so can result in the test failing because the Realm could not be deleted
+ * (this class and {@link TestRealmConfigurationFactory} do not agree in which order to delete
+ * the open Realms).
  */
 public class RunInLooperThread extends TestRealmConfigurationFactory {
+    private static final long WAIT_TIMEOUT_MS = 60 * 1000;
+
+    // lock protecting objects shared with the test thread
+    private final Object lock = new Object();
+
+    // Thread safe
+    private final CountDownLatch signalTestCompleted = new CountDownLatch(1);
+
+    // Access guarded by 'lock'
+    private RealmConfiguration realmConfiguration;
 
     // Default Realm created by this Rule. It is guaranteed to be closed when the test finishes.
-    public Realm realm;
-    // Custom Realm used by the test. Saving the reference here will guarantee the instance is closed when exiting the test.
-    public List<Realm> testRealms = new ArrayList<Realm>();
-    public RealmConfiguration realmConfiguration;
-    private CountDownLatch signalTestCompleted;
+    // Access guarded by 'lock'
+    private Realm realm;
+
+    // Access guarded by 'lock'
     private Handler backgroundHandler;
 
     // the variables created inside the test are local and eligible for GC.
     // but sometimes we need the variables to survive across different Looper
     // events (Callbacks happening in the future), so we add a strong reference
     // to them for the duration of the test.
-    public LinkedList<Object> keepStrongReference;
+    // Access guarded by 'lock'
+    private LinkedList<Object> keepStrongReference;
 
-    @Override
-    protected void before() throws Throwable {
-        super.before();
-        realmConfiguration = createConfiguration(UUID.randomUUID().toString());
-        signalTestCompleted = new CountDownLatch(1);
-        keepStrongReference = new LinkedList<Object>();
-    }
+    // Custom Realm used by the test. Saving the reference here will guarantee
+    // that the instance is closed when exiting the test.
+    // Access guarded by 'lock'
+    private List<Realm> testRealms;
 
-    @Override
-    protected void after() {
-        super.after();
-        realmConfiguration = null;
-        realm = null;
-        testRealms.clear();
-        keepStrongReference = null;
+    /**
+     * Get the configuration for the test realm.
+     * <p>
+     * Set on main thread, accessed from test thread.
+     * Valid after {@code before}.
+     *
+     * @return the test realm configuration.
+     */
+    public RealmConfiguration getConfiguration() {
+        synchronized (lock) {
+            return realmConfiguration;
+        }
     }
 
-    @Override
-    public Statement apply(final Statement base, Description description) {
-        final RunTestInLooperThread annotation = description.getAnnotation(RunTestInLooperThread.class);
-        if (annotation == null) {
-            return base;
-        }
-        return new Statement() {
-            private Throwable testException;
-
-            @Override
-            @SuppressWarnings({"ClassNewInstance", "Finally"})
-            public void evaluate() throws Throwable {
-                before();
-                final String threadName = annotation.threadName();
-                Class<? extends RunnableBefore> runnableBefore = annotation.before();
-                if (!runnableBefore.isInterface()) {
-                    runnableBefore.newInstance().run(realmConfiguration);
-                }
+    /**
+     * Get the test realm.
+     * <p>
+     * Set on test thread, accessed from main thread.
+     * Valid only after the test thread has started.
+     *
+     * @return the test realm.
+     */
+    public Realm getRealm() {
+        synchronized (lock) {
+            while (backgroundHandler == null) {
                 try {
-                    final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-                    final Throwable[] threadAssertionError = new Throwable[1];
-                    final Looper[] backgroundLooper = new Looper[1];
-                    final ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
-                        @Override
-                        public Thread newThread(Runnable runnable) {
-                            return new Thread(runnable, threadName);
-                        }
-                    });
-                    //noinspection unused
-                    final Future<?> submit = executorService.submit(new Runnable() {
-                        @Override
-                        public void run() {
-                            Looper.prepare();
-                            backgroundLooper[0] = Looper.myLooper();
-                            backgroundHandler = new Handler(backgroundLooper[0]);
-                            try {
-                                realm = Realm.getInstance(realmConfiguration);
-                                base.evaluate();
-                                Looper.loop();
-                            } catch (Throwable e) {
-                                threadAssertionError[0] = e;
-                                unitTestFailed = true;
-                            } finally {
-                                try {
-                                    looperTearDown();
-                                } catch (Throwable t) {
-                                    if (threadAssertionError[0] == null) {
-                                        threadAssertionError[0] = t;
-                                    }
-                                    unitTestFailed = true;
-                                }
-                                signalTestCompleted.countDown();
-                                if (realm != null) {
-                                    realm.close();
-                                }
-                                if (!testRealms.isEmpty()) {
-                                    for (Realm testRealm : testRealms) {
-                                        testRealm.close();
-                                    }
-                                }
-                                signalClosedRealm.countDown();
-                            }
-                        }
-                    });
-                    TestHelper.exitOrThrow(executorService, signalTestCompleted, signalClosedRealm, backgroundLooper, threadAssertionError);
-                } catch (Throwable error) {
-                    // These exceptions should only come from TestHelper.awaitOrFail()
-                    testException = error;
-                } finally {
-                    // Tries as hard as possible to close down gracefully, while still keeping all exceptions intact.
-                    try {
-                        after();
-                    } catch (Throwable e) {
-                        if (testException != null) {
-                            // Both TestHelper.awaitOrFail() and after() threw an exception. Make sure we are aware of
-                            // that fact by printing both exceptions.
-                            StringWriter testStackTrace = new StringWriter();
-                            testException.printStackTrace(new PrintWriter(testStackTrace));
-
-                            StringWriter afterStackTrace = new StringWriter();
-                            e.printStackTrace(new PrintWriter(afterStackTrace));
-
-                            StringBuilder errorMessage = new StringBuilder()
-                                    .append("after() threw an error that shadows a test case error")
-                                    .append('\n')
-                                    .append("== Test case exception ==\n")
-                                    .append(testStackTrace.toString())
-                                    .append('\n')
-                                    .append("== after() exception ==\n")
-                                    .append(afterStackTrace.toString());
-                            fail(errorMessage.toString());
-                        } else {
-                            // Only after() threw an exception
-                            throw e;
-                        }
-                    }
-
-                    // Only TestHelper.awaitOrFail() threw an exception
-                    if (testException != null) {
-                        //noinspection ThrowFromFinallyBlock
-                        throw testException;
-                    }
+                    lock.wait(WAIT_TIMEOUT_MS);
+                } catch (InterruptedException ignore) {
+                    break;
                 }
             }
-        };
+            return realm;
+        }
     }
 
     /**
-     * Signal that the test has completed.
+     * Hold a reference to an object, to prevent it from being GCed,
+     * until after the test completes.
+     * <p>
+     * Accessed only from the main thread, here, but synchronized in case it is called from within a test.
+     * Valid after {@code before}.
      */
-    public void testComplete() {
-        signalTestCompleted.countDown();
+    public void keepStrongReference(Object obj) {
+        synchronized (lock) {
+            keepStrongReference.add(obj);
+        }
     }
 
     /**
-     * Signal that the test has completed.
-     *
-     * @param latches additional latches to wait before set the test completed flag.
+     * Add a Realm to be closed when test is complete.
+     * <p>
+     * Accessed from both test and main threads.
+     * Valid after {@code before}.
      */
-    public void testComplete(CountDownLatch... latches) {
-        for (CountDownLatch latch : latches) {
-            TestHelper.awaitOrFail(latch);
+    public void addTestRealm(Realm realm) {
+        synchronized (lock) {
+            testRealms.add(realm);
         }
-        signalTestCompleted.countDown();
     }
 
     /**
-     * Posts a runnable to this worker threads looper.
+     * Explicitly close all held realms.
+     * <p>
+     * 'testRealms' is accessed from both test and main threads.
+     * 'testRealms' is valid after {@code before}.
+     */
+    public void closeTestRealms() {
+        List<Realm> realms = new ArrayList<>();
+        synchronized (lock) {
+            List<Realm> tmp = testRealms;
+            testRealms = realms;
+            realms = tmp;
+        }
+
+        for (Realm testRealm : realms) {
+            testRealm.close();
+        }
+    }
+
+    /**
+     * Posts a runnable to the currently running looper.
      */
     public void postRunnable(Runnable runnable) {
-        backgroundHandler.post(runnable);
+        getBackgroundHandler().post(runnable);
     }
 
     /**
      * Posts a runnable to this worker threads looper with a delay in milli second.
      */
     public void postRunnableDelayed(Runnable runnable, long delayMillis) {
-        backgroundHandler.postDelayed(runnable, delayMillis);
+        getBackgroundHandler().postDelayed(runnable, delayMillis);
+    }
+
+    /**
+     * Signal that the test has completed.
+     * <p>
+     * Used on both the main and test threads.
+     * Valid after {@code before}.
+     */
+    public void testComplete() {
+        signalTestCompleted.countDown();
+    }
+
+    /**
+     * Signal that the test has completed, after waiting for any additional latches.
+     *
+     * @param latches additional latches to wait on, before setting the test completed flag.
+     */
+    public void testComplete(CountDownLatch... latches) {
+        for (CountDownLatch latch : latches) {
+            TestHelper.awaitOrFail(latch);
+        }
+        testComplete();
+    }
+
+    // Accessed from both test and main threads
+    // Valid after the test thread has started.
+    private Handler getBackgroundHandler() {
+        synchronized (lock) {
+            while (backgroundHandler == null) {
+                try {
+                    lock.wait(WAIT_TIMEOUT_MS);
+                } catch (InterruptedException ignore) {
+                    break;
+                }
+            }
+            return this.backgroundHandler;
+        }
+    }
+
+    // Accessed from both test and main threads
+    // Storing the handler is the gate that indicates that the test thread has started.
+    void setBackgroundHandler(Handler backgroundHandler) {
+        synchronized (lock) {
+            this.backgroundHandler = backgroundHandler;
+            lock.notifyAll();
+        }
+    }
+
+    @Override
+    protected void before() throws Throwable {
+        super.before();
+
+        RealmConfiguration config = createConfiguration(UUID.randomUUID().toString());
+        LinkedList<Object> refs = new LinkedList<>();
+        List<Realm> realms = new LinkedList<>();
+
+        synchronized (lock) {
+            realmConfiguration = config;
+            realm = null;
+            backgroundHandler = null;
+            keepStrongReference = refs;
+            testRealms = realms;
+        }
+    }
+
+    @Override
+    protected void after() {
+        super.after();
+
+        // probably belt *and* suspenders...
+        synchronized (lock) {
+            backgroundHandler = null;
+            keepStrongReference = null;
+        }
+    }
+
+    @Override
+    public Statement apply(Statement base, Description description) {
+        final RunTestInLooperThread annotation = description.getAnnotation(RunTestInLooperThread.class);
+        if (annotation == null) {
+            return base;
+        }
+        return new RunInLooperThreadStatement(annotation, base);
     }
 
     /**
@@ -229,6 +264,28 @@ public void postRunnableDelayed(Runnable runnable, long delayMillis) {
     public void looperTearDown() {
     }
 
+    private void initRealm() {
+        synchronized (lock) {
+            realm = Realm.getInstance(realmConfiguration);
+        }
+    }
+
+    private void closeRealms() {
+        closeTestRealms();
+
+        Realm oldRealm;
+        synchronized (lock) {
+            oldRealm = realm;
+
+            realm = null;
+            realmConfiguration = null;
+        }
+
+        if (oldRealm != null) {
+            oldRealm.close();
+        }
+    }
+
     /**
      * If an implementation of this is supplied with the annotation, the {@link RunnableBefore#run(RealmConfiguration)}
      * will be executed before the looper thread starts. It is normally for populating the Realm before the test.
@@ -236,4 +293,144 @@ public void looperTearDown() {
     public interface RunnableBefore {
         void run(RealmConfiguration realmConfig);
     }
+
+    private class RunInLooperThreadStatement extends Statement {
+        private final RunTestInLooperThread annotation;
+        private final Statement base;
+
+        RunInLooperThreadStatement(RunTestInLooperThread annotation, Statement base) {
+            this.annotation = annotation;
+            this.base = base;
+        }
+
+        @Override
+        @SuppressWarnings("ClassNewInstance")
+        public void evaluate() throws Throwable {
+            before();
+
+            Class<? extends RunnableBefore> runnableBefore = annotation.before();
+            if (!runnableBefore.isInterface()) {
+                // this is dangerous: newInstance can throw checked exceptions.
+                // this is dangerous: config is mutable.
+                runnableBefore.newInstance().run(getConfiguration());
+            }
+
+            runTest(annotation.threadName());
+        }
+
+        private void runTest(final String threadName) throws Throwable {
+            Throwable failure = null;
+
+            try {
+                ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
+                    @Override
+                    public Thread newThread(Runnable runnable) { return new Thread(runnable, threadName); }
+                });
+
+                TestThread test = new TestThread(base);
+
+                @SuppressWarnings({"UnusedAssignment", "unused"})
+                Future<?> ignored = executorService.submit(test);
+
+                TestHelper.exitOrThrow(executorService, signalTestCompleted, test);
+            } catch (Throwable testfailure) {
+                // These exceptions should only come from TestHelper.awaitOrFail()
+                failure = testfailure;
+            } finally {
+                // Tries as hard as possible to close down gracefully, while still keeping all exceptions intact.
+                failure = cleanUp(failure);
+            }
+            if (failure != null) {
+                throw failure;
+            }
+        }
+
+        private Throwable cleanUp(Throwable testfailure) {
+            try {
+                after();
+                return testfailure;
+            } catch (Throwable afterFailure) {
+                if (testfailure == null) {
+                    // Only after() threw an exception
+                    return afterFailure;
+                }
+
+                // Both TestHelper.awaitOrFail() and after() threw exceptions
+                return new MultipleFailureException(Arrays.asList(testfailure, afterFailure)) {
+                    @Override
+                    public void printStackTrace(PrintStream out) {
+                        int i = 0;
+                        for (Throwable t : getFailures()) {
+                            out.println("Error " + i + ": " + t.getMessage());
+                            t.printStackTrace(out);
+                            out.println();
+                            i++;
+                        }
+                    }
+                };
+            }
+        }
+    }
+
+    private class TestThread implements Runnable, TestHelper.LooperTest {
+        private final CountDownLatch signalClosedRealm = new CountDownLatch(1);
+        private final Statement base;
+        private Looper looper;
+        private Throwable threadAssertionError;
+
+        TestThread(Statement base) {
+            this.base = base;
+        }
+
+        @Override
+        public CountDownLatch getRealmClosedSignal() {
+            return signalClosedRealm;
+        }
+
+        @Override
+        public synchronized Looper getLooper() {
+            return looper;
+        }
+
+        private synchronized void setLooper(Looper looper) {
+            this.looper = looper;
+            setBackgroundHandler(new Handler(looper));
+        }
+
+        @Override
+        public synchronized Throwable getAssertionError() {
+            return threadAssertionError;
+        }
+
+        // Only record the first error
+        private synchronized void setAssertionError(Throwable threadAssertionError) {
+            if (this.threadAssertionError == null) {
+                this.threadAssertionError = threadAssertionError;
+            }
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            try {
+                initRealm();
+                setLooper(Looper.myLooper());
+                base.evaluate();
+                Looper.loop();
+            } catch (Throwable t) {
+                setAssertionError(t);
+                setUnitTestFailed();
+            } finally {
+                try {
+                    looperTearDown();
+                } catch (Throwable t) {
+                    setAssertionError(t);
+                    setUnitTestFailed();
+                }
+                testComplete();
+                closeRealms();
+                signalClosedRealm.countDown();
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 979717e96a..04bc9a4f6d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -51,7 +51,8 @@
 public class TestRealmConfigurationFactory extends TemporaryFolder {
     private final Map<RealmConfiguration, Boolean> map = new ConcurrentHashMap<RealmConfiguration, Boolean>();
     private final Set<RealmConfiguration> configurations = Collections.newSetFromMap(map);
-    protected boolean unitTestFailed = false;
+
+    private boolean unitTestFailed = false;
 
     @Override
     public Statement apply(final Statement base, Description description) {
@@ -62,7 +63,7 @@ public void evaluate() throws Throwable {
                 try {
                     base.evaluate();
                 } catch (Throwable throwable) {
-                    unitTestFailed = true;
+                    setUnitTestFailed();
                     throw throwable;
                 } finally {
                     after();
@@ -89,7 +90,7 @@ protected void after() {
             }
         } catch (IllegalStateException e) {
             // Only throws the exception caused by deleting the opened Realm if the test case itself doesn't throw.
-            if (!unitTestFailed) {
+            if (!isUnitTestFailed()) {
                 throw e;
             }
         } finally {
@@ -98,6 +99,14 @@ protected void after() {
         }
     }
 
+    public synchronized void setUnitTestFailed() {
+        this.unitTestFailed = true;
+    }
+
+    private synchronized boolean isUnitTestFailed() {
+        return this.unitTestFailed;
+    }
+
     // This builder creates a configuration that is *NOT* managed.
     // You have to delete it yourself.
     public RealmConfiguration.Builder createConfigurationBuilder() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java b/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
index cc570efb8d..fc6a06f19b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
@@ -21,6 +21,8 @@
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.TestHelper;
+
 
 /**
  * Utility class for running a task on a non-looper background thread.
@@ -62,7 +64,7 @@ public void run() {
         }, "RealmBackgroundTask").start();
 
         try {
-            if (!jobDone.await(10, TimeUnit.SECONDS)) {
+            if (!jobDone.await(TestHelper.STANDARD_WAIT_SECS, TimeUnit.SECONDS)) {
                 exceptionHolder.setError("Job timed out!");
             }
         } catch (InterruptedException e) {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 2c53ce2bd5..d5c949a1bf 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -71,11 +71,12 @@ public void errorHandler_clientResetReported() {
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
-                        fail("Wrong error " + error.toString());
-                    }
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
 
-                    @Override
-                    public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
                         String filePathFromError = handler.getOriginalFile().getAbsolutePath();
                         String filePathFromConfig = session.getConfiguration().getPath();
                         assertEquals(filePathFromError, filePathFromConfig);
@@ -87,7 +88,7 @@ public void onClientResetRequired(SyncSession session, ClientResetHandler handle
                 .build();
 
         Realm realm = Realm.getInstance(config);
-        looperThread.testRealms.add(realm);
+        looperThread.addTestRealm(realm);
 
         // Trigger error
         SyncManager.simulateClientReset(SyncManager.getSession(config));
@@ -103,11 +104,12 @@ public void errorHandler_manualExecuteClientReset() {
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
-                        fail("Wrong error " + error.toString());
-                    }
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
 
-                    @Override
-                    public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
                         try {
                             handler.executeClientReset();
                             fail("All Realms should be closed before executing Client Reset can be allowed");
@@ -115,7 +117,7 @@ public void onClientResetRequired(SyncSession session, ClientResetHandler handle
                         }
 
                         // Execute Client Reset
-                        looperThread.testRealms.get(0).close();
+                        looperThread.closeTestRealms();
                         handler.executeClientReset();
 
                         // Validate that files have been moved
@@ -127,10 +129,9 @@ public void onClientResetRequired(SyncSession session, ClientResetHandler handle
                 .build();
 
         Realm realm = Realm.getInstance(config);
-        looperThread.testRealms.add(realm);
+        looperThread.addTestRealm(realm);
 
         // Trigger error
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
-
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 2e294ffe75..3b7a2a466f 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -225,11 +225,6 @@ public void errorHandler() {
             public void onError(SyncSession session, ObjectServerError error) {
 
             }
-
-            @Override
-            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-
-            }
         };
         SyncConfiguration config = builder.errorHandler(errorHandler).build();
         assertEquals(errorHandler, config.getErrorHandler());
@@ -243,11 +238,6 @@ public void errorHandler_fromSyncManager() {
             public void onError(SyncSession session, ObjectServerError error) {
 
             }
-
-            @Override
-            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-
-            }
         };
         SyncManager.setDefaultSessionErrorHandler(errorHandler);
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 3e2c69544c..0f4fa8b0b9 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -36,6 +36,7 @@
 
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.util.SyncTestUtils;
 
@@ -213,4 +214,35 @@ public void login_withAccessToken() {
             SyncManager.setAuthServerImpl(originalServer);
         }
     }
+
+    // Checks that `/auth` is correctly added to any URL without a path
+    @Test
+    public void login_appendAuthSegment() {
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        AuthenticationServer originalServer = SyncManager.getAuthServer();
+        SyncManager.setAuthServerImpl(authServer);
+        String[][] urls = {
+                {"http://ros.realm.io", "http://ros.realm.io/auth"},
+                {"http://ros.realm.io:8080", "http://ros.realm.io:8080/auth"},
+                {"http://ros.realm.io/", "http://ros.realm.io/"},
+                {"http://ros.realm.io/?foo=bar", "http://ros.realm.io/?foo=bar"},
+                {"http://ros.realm.io/auth", "http://ros.realm.io/auth"},
+                {"http://ros.realm.io/auth/", "http://ros.realm.io/auth/"},
+                {"http://ros.realm.io/custom-path/", "http://ros.realm.io/custom-path/"}
+        };
+
+        try {
+            for (String[] url : urls) {
+                RealmLog.error(url[0]);
+                String input = url[0];
+                String normalizedInput = url[1];
+                SyncCredentials credentials = SyncCredentials.accessToken("token", UUID.randomUUID().toString());
+                SyncUser user = SyncUser.login(credentials, input);
+                assertEquals(normalizedInput, user.getAuthenticationUrl().toString());
+                user.logout();
+            }
+        } finally {
+            SyncManager.setAuthServerImpl(originalServer);
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 0b64588552..11c3d43caf 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -17,6 +17,10 @@ set(CMAKE_VERBOSE_MAKEFILE ON)
 # Generate compile_commands.json
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 
+# Initialize common compile & link flags.
+set(REALM_LINKER_FLAGS "")
+set(REALM_COMMON_CXX_FLAGS "")
+
 # Setup lcache
 if(NDK_LCACHE)
     set(CMAKE_CXX_CREATE_SHARED_LIBRARY "${NDK_LCACHE} ${CMAKE_CXX_CREATE_SHARED_LIBRARY}")
@@ -36,16 +40,17 @@ set(classes_LIST
     io.realm.internal.Table io.realm.internal.CheckedRow
     io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
-    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.RealmSchema
-    io.realm.RealmObjectSchema io.realm.internal.Collection
+    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.OsRealmSchema
+    io.realm.OsRealmObjectSchema io.realm.internal.Collection
     io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
+    io.realm.internal.OsObject
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
 set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
 if (build_SYNC)
     list(APPEND classes_LIST
-        io.realm.ClientResetHandler io.realm.RealmFileUserStore
+        io.realm.ClientResetRequiredError io.realm.RealmFileUserStore
         io.realm.SyncManager io.realm.SyncSession
     )
 endif()
@@ -86,23 +91,25 @@ add_library(lib_realm_core STATIC IMPORTED)
 set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH}
                                                 IMPORTED_LINK_INTERFACE_LIBRARIES atomic)
 
-# Sync static library
-set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
-# Workaround for old core's funny ABI nicknames
-if (NOT EXISTS ${sync_lib_PATH})
-    if (ARMEABI)
-        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
-    elseif (ARMEABI_V7A)
-        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
-    elseif (ARM64_V8A)
-        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
-    else()
-        message(FATAL_ERROR "Cannot find core lib file: ${sync_lib_PATH}")
+if (build_SYNC)
+    # Sync static library
+    set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
+    # Workaround for old core's funny ABI nicknames
+    if (NOT EXISTS ${sync_lib_PATH})
+        if (ARMEABI)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
+        elseif (ARMEABI_V7A)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
+        elseif (ARM64_V8A)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
+        else()
+            message(FATAL_ERROR "Cannot find sync lib file: ${sync_lib_PATH}")
+        endif()
     endif()
+    add_library(lib_realm_sync STATIC IMPORTED)
+    set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH}
+                                                    IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
 endif()
-add_library(lib_realm_sync STATIC IMPORTED)
-set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH}
-                                                IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
 
 # build application's shared lib
 include_directories(${REALM_CORE_DIST_DIR}/include
@@ -120,6 +127,14 @@ elseif (ARMEABI_V7A)
     set(ABI_CXX_FLAGS "-mthumb -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16")
 endif()
 
+# Hack the memmove bug on Samsung device.
+if (ARMEABI OR ARMEABI_V7A)
+    set(REALM_LINKER_FLAGS "${REALM_LINKER_FLAGS} -Wl,--wrap,memmove -Wl,--wrap,memcpy")
+    set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_WRAP_MEMMOVE=1")
+else()
+    set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_WRAP_MEMMOVE=0")
+endif()
+
 #FIXME uninitialized is reported by query_expression.hpp:1070
 #      d.init(ValueBase::m_from_link_list, ValueBase::m_values, D{});
 #FIXME maybe-uninitialized is reported by table_view.cpp:272:15:
@@ -128,7 +143,7 @@ endif()
 set(WARNING_CXX_FLAGS "-Werror -Wall -Wextra -pedantic -Wmissing-declarations \
     -Wempty-body -Wparentheses -Wunknown-pragmas -Wunreachable-code \
     -Wno-missing-field-initializers  -Wno-maybe-uninitialized -Wno-uninitialized")
-set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
+set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
 if (build_SYNC)
     set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_ENABLE_SYNC=1")
 endif()
@@ -140,7 +155,6 @@ set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
 
 # Set link flags
-set(REALM_LINKER_FLAGS "")
 if (build_SYNC)
     set(REALM_LINKER_FLAGS "${REALM_LINKER_FLAGS} -lz")
 endif()
@@ -155,7 +169,7 @@ file(GLOB jni_SRC
 # Those source file are only needed for sync.
 if (NOT build_SYNC)
     list(REMOVE_ITEM jni_SRC
-        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_ClientResetHandler.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_ClientResetRequiredError.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_RealmFileUserStore.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncManager.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncSession.cpp
diff --git a/realm/realm-library/src/main/cpp/io_realm_ClientResetHandler.cpp b/realm/realm-library/src/main/cpp/io_realm_ClientResetRequiredError.cpp
similarity index 89%
rename from realm/realm-library/src/main/cpp/io_realm_ClientResetHandler.cpp
rename to realm/realm-library/src/main/cpp/io_realm_ClientResetRequiredError.cpp
index 61a72c1145..39e5484af4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_ClientResetHandler.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_ClientResetRequiredError.cpp
@@ -19,11 +19,11 @@
 #include <sync/sync_manager.hpp>
 
 #include "util.hpp"
-#include "io_realm_ClientResetHandler.h"
+#include "io_realm_ClientResetRequiredError.h"
 
 using namespace realm;
 
-JNIEXPORT void JNICALL Java_io_realm_ClientResetHandler_nativeExecuteClientReset(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_ClientResetRequiredError_nativeExecuteClientReset(JNIEnv* env, jobject,
                                                                                jstring localRealmPath)
 {
     TR_ENTER()
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
similarity index 57%
rename from realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
rename to realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
index e6804a0ad5..c3a954c8f1 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <jni.h>
-#include "io_realm_RealmObjectSchema.h"
+#include "io_realm_OsRealmObjectSchema.h"
 
 #include <object-store/src/object_schema.hpp>
 #include <object-store/src/property.hpp>
@@ -23,8 +23,8 @@
 #include "util.hpp"
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
-                                                                                      jstring className_)
+JNIEXPORT jlong JNICALL Java_io_realm_OsRealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
+                                                                                        jstring className_)
 {
     TR_ENTER()
     try {
@@ -37,7 +37,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectS
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -48,7 +48,7 @@ JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv* env,
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
                                                                          jlong property_ptr)
 {
     TR_ENTER_PTR(native_ptr)
@@ -63,7 +63,7 @@ JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv*
     CATCH_STD()
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
+JNIEXPORT jstring JNICALL Java_io_realm_OsRealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     try {
@@ -75,28 +75,3 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmObjectSchema_nativeGetClassName(JNI
 
     return nullptr;
 }
-
-JNIEXPORT jlongArray JNICALL Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv* env, jclass, jlong nativePtr)
-{
-    TR_ENTER_PTR(nativePtr)
-    try {
-        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
-        size_t size = object_schema->persisted_properties.size();
-        jlongArray native_ptr_array = env->NewLongArray(static_cast<jsize>(size));
-        jlong* tmp = new jlong[size];
-        auto it = object_schema->persisted_properties.begin();
-        size_t index = 0;
-        while (it != object_schema->persisted_properties.end()) {
-            Property property = *it;
-            tmp[index] = reinterpret_cast<jlong>(new Property(std::move(property)));
-            ++index;
-            ++it;
-        }
-        env->SetLongArrayRegion(native_ptr_array, 0, static_cast<jsize>(size), tmp);
-        delete tmp;
-        return native_ptr_array;
-    }
-    CATCH_STD()
-
-    return nullptr;
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
similarity index 52%
rename from realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
rename to realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
index 7bc774c51c..20a4852a05 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <jni.h>
-#include "io_realm_RealmSchema.h"
+#include "io_realm_OsRealmSchema.h"
 
 #include <object-store/src/schema.hpp>
 #include <object-store/src/object_schema.hpp>
@@ -25,7 +25,7 @@
 using namespace realm;
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_OsRealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
                                                                        jlongArray objectSchemaPtrs_)
 {
     TR_ENTER()
@@ -33,8 +33,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv* e
         std::vector<ObjectSchema> object_schemas;
         JniLongArray array(env, objectSchemaPtrs_);
         for (jsize i = 0; i < array.len(); ++i) {
-            ObjectSchema object_schema = *reinterpret_cast<ObjectSchema*>(array[i]);
-            object_schemas.push_back(std::move(object_schema));
+            object_schemas.push_back(*reinterpret_cast<ObjectSchema*>(array[i]));
         }
         auto* schema = new Schema(object_schemas);
         return reinterpret_cast<jlong>(schema);
@@ -43,33 +42,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv* e
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_RealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
+JNIEXPORT void JNICALL Java_io_realm_OsRealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     Schema* schema = reinterpret_cast<Schema*>(nativePtr);
     delete schema;
 }
-
-JNIEXPORT jlongArray JNICALL Java_io_realm_RealmSchema_nativeGetAll(JNIEnv* env, jclass, jlong nativePtr)
-{
-    TR_ENTER_PTR(nativePtr)
-    try {
-        Schema* schema = reinterpret_cast<Schema*>(nativePtr);
-        size_t size = schema->size();
-        jlongArray native_ptr_array = env->NewLongArray(static_cast<jsize>(size));
-        jlong* tmp = new jlong[size];
-        auto it = schema->begin();
-        size_t index = 0;
-        while (it != schema->end()) {
-            auto object_schema = *it;
-            tmp[index] = reinterpret_cast<jlong>(new ObjectSchema(std::move(object_schema)));
-            ++index;
-            ++it;
-        }
-        env->SetLongArrayRegion(native_ptr_array, 0, static_cast<jsize>(size), tmp);
-        delete tmp;
-        return native_ptr_array;
-    }
-    CATCH_STD()
-    return nullptr;
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
index 3aaedada73..38e9dff137 100644
--- a/realm/realm-library/src/main/cpp/io_realm_Property.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
@@ -57,8 +57,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_
         JStringAccessor link_name(env, linkedToName_);
         PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
         bool is_nullable = (p_type == PropertyType::Object);
-        std::unique_ptr<Property> property(new Property(name, p_type, link_name, "", false, false, is_nullable));
-        return reinterpret_cast<jlong>(property.release());
+        return reinterpret_cast<jlong>(new Property(name, p_type, link_name, "", false, false, is_nullable));
     }
     CATCH_STD()
     return 0;
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index bb9d1dab0d..d9f15dd859 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -47,10 +47,10 @@ struct AndroidClientListener : public realm::BindingCallbackThreadObserver {
 } s_client_thread_listener;
 
 struct AndroidSyncLoggerFactory : public realm::SyncLoggerFactory {
-    std::unique_ptr<util::Logger> make_logger(Logger::Level level) override
+    // The level param is ignored. Use the global RealmLog.setLevel() to control all log levels.
+    std::unique_ptr<util::Logger> make_logger(Logger::Level) override
     {
         auto logger = std::make_unique<CoreLoggerBridge>(std::string("REALM_SYNC"));
-        logger->set_level_threshold(level);
         // Cast to std::unique_ptr<util::Logger>
         return std::move(logger);
     }
@@ -100,3 +100,12 @@ JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeSimulateSyncError(JNIEnv*
     }
     CATCH_STD()
 }
+
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeReconnect(JNIEnv* env, jclass)
+{
+    TR_ENTER()
+    try {
+        SyncManager::shared().reconnect();
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index 142e64d0c4..b584438ada 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -35,7 +35,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName(
                                                                                 jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex)) {
-        return NULL;
+        return nullptr;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetColumnName(env, obj, nativeRowPtr, columnIndex);
@@ -82,7 +82,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean(JN
                                                                               jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool)) {
-        return 0;
+        return JNI_FALSE;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetBoolean(env, obj, nativeRowPtr, columnIndex);
@@ -122,7 +122,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString(JNIE
                                                                             jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String)) {
-        return 0;
+        return nullptr;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetString(env, obj, nativeRowPtr, columnIndex);
@@ -133,7 +133,7 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArra
                                                                                   jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary)) {
-        return 0;
+        return nullptr;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
@@ -153,7 +153,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink(JN
                                                                               jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link)) {
-        return 0;
+        return JNI_FALSE;
     }
 
     return Java_io_realm_internal_UncheckedRow_nativeIsNullLink(env, obj, nativeRowPtr, columnIndex);
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
new file mode 100644
index 0000000000..62887708c9
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsObject.h"
+
+#include <realm/row.hpp>
+#include <object_schema.hpp>
+#include <object.hpp>
+
+#include "util.hpp"
+
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+
+// We need to control the life cycle of Object, weak ref of Java OsObject and the NotificationToken.
+// Wrap all three together, so when the Java object gets GCed, all three of them will be invalidated.
+struct ObjectWrapper {
+    JavaGlobalWeakRef m_row_object_weak_ref;
+    NotificationToken m_notification_token;
+    realm::Object m_object;
+
+    ObjectWrapper(realm::Object& object)
+        : m_row_object_weak_ref()
+        , m_notification_token()
+        , m_object(std::move(object))
+    {
+    }
+
+    ObjectWrapper(ObjectWrapper&&) = delete;
+    ObjectWrapper& operator=(ObjectWrapper&&) = delete;
+
+    ObjectWrapper(ObjectWrapper const&) = delete;
+    ObjectWrapper& operator=(ObjectWrapper const&) = delete;
+
+    ~ObjectWrapper()
+    {
+    }
+};
+
+struct ChangeCallback {
+    ChangeCallback(ObjectWrapper* wrapper)
+        : m_wrapper(wrapper)
+    {
+    }
+
+    void parse_fields(JNIEnv* env, CollectionChangeSet const& change_set)
+    {
+        if (m_field_names_array) {
+            return;
+        }
+
+        if (!change_set.deletions.empty()) {
+            m_deleted = true;
+            return;
+        }
+
+        // The local ref of jstring needs to be released to avoid reach the local ref table size limitation.
+        std::vector<JavaGlobalRef> field_names;
+        auto table = m_wrapper->m_object.row().get_table();
+        for (size_t i = 0; i < change_set.columns.size(); ++i) {
+            if (change_set.columns[i].empty()) {
+                continue;
+            }
+            // FIXME: After full integration of the OS schema, parse the column name from
+            // wrapper->m_object.get_object_schema() will be faster.
+            field_names.push_back(JavaGlobalRef(env, to_jstring(env, table->get_column_name(i)), true));
+        }
+        m_field_names_array = env->NewObjectArray(field_names.size(), java_lang_string, 0);
+        for (size_t i = 0; i < field_names.size(); ++i) {
+            env->SetObjectArrayElement(m_field_names_array, i, field_names[i].get());
+        }
+    }
+
+    JNIEnv* check_env()
+    {
+        JNIEnv* env = JniUtils::get_env(false);
+        if (!env || env->ExceptionCheck()) {
+            // JVM detached or java exception has been thrown before.
+            return nullptr;
+        }
+        return env;
+    }
+
+    void before(CollectionChangeSet const& change_set)
+    {
+        JNIEnv* env = check_env();
+        if (!env) {
+            return;
+        }
+
+        parse_fields(env, change_set);
+    }
+
+    void after(CollectionChangeSet const& change_set)
+    {
+        JNIEnv* env = check_env();
+        if (!env) {
+            return;
+        }
+        if (change_set.empty()) {
+            return;
+        }
+
+        parse_fields(env, change_set);
+
+        m_wrapper->m_row_object_weak_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
+            static JavaMethod notify_change_listeners(env, row_obj, "notifyChangeListeners",
+                                                      "([Ljava/lang/String;)V");
+            env->CallVoidMethod(row_obj, notify_change_listeners, m_deleted ? nullptr : m_field_names_array);
+        });
+        m_field_names_array = nullptr;
+        m_deleted = false;
+    }
+
+    void error(std::exception_ptr err)
+    {
+        if (err) {
+            try {
+                std::rethrow_exception(err);
+            }
+            catch (const std::exception& e) {
+                Log::e("Caught exception in object change callback %1", e.what());
+            }
+        }
+    }
+
+private:
+    ObjectWrapper* m_wrapper;
+    bool m_deleted = false;
+    jobjectArray m_field_names_array = nullptr;
+};
+
+static void finalize_object(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<ObjectWrapper*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_object);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreate(JNIEnv*, jclass, jlong shared_realm_ptr,
+                                                                      jlong row_ptr)
+{
+    TR_ENTER_PTR(row_ptr)
+
+    // FIXME: Currently OsObject is only used for object notifications. Since the Object Store's schema has not been
+    // fully integrated with realm-java, we pass a dummy ObjectSchema to create Object.
+    static const ObjectSchema dummy_object_schema;
+
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& row = *(reinterpret_cast<Row*>(row_ptr));
+    Object object(shared_realm, dummy_object_schema, row); // no throw
+    auto wrapper = new ObjectWrapper(object);              // no throw
+
+    return reinterpret_cast<jlong>(wrapper);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStartListening(JNIEnv* env, jobject instance,
+                                                                             jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ObjectWrapper*>(native_ptr);
+        if (!wrapper->m_row_object_weak_ref) {
+            wrapper->m_row_object_weak_ref = JavaGlobalWeakRef(env, instance);
+        }
+
+        // The wrapper pointer will be used in the callback. But it should never become an invalid pointer when the
+        // notification block gets called. This should be guaranteed by the Object Store that after the notification
+        // token is destroyed, the block shouldn't be called.
+        wrapper->m_notification_token = wrapper->m_object.add_notification_callback(ChangeCallback(wrapper));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ObjectWrapper*>(native_ptr);
+        wrapper->m_notification_token = {};
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 531611f4d1..f542b345b0 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -28,6 +28,7 @@
 #include "util.hpp"
 
 #include "jni_util/java_method.hpp"
+#include "jni_util/java_class.hpp"
 
 using namespace realm;
 using namespace realm::_impl;
@@ -74,11 +75,12 @@ class JniConfigWrapper {
         : m_config(std::move(config))
     {
 #if REALM_ENABLE_SYNC
+        static JavaClass sync_manager_class(env, "io/realm/SyncManager");
         // Doing the methods lookup from the thread that loaded the lib, to avoid
         // https://developer.android.com/training/articles/perf-jni.html#faq_FindClass
-        static JavaMethod java_error_callback_method(env, java_syncmanager, "notifyErrorHandler",
+        static JavaMethod java_error_callback_method(env, sync_manager_class, "notifyErrorHandler",
                                                      "(ILjava/lang/String;Ljava/lang/String;)V", true);
-        static JavaMethod java_bind_session_method(env, java_syncmanager, "bindSessionWithConfig",
+        static JavaMethod java_bind_session_method(env, sync_manager_class, "bindSessionWithConfig",
                                                    "(Ljava/lang/String;)Ljava/lang/String;", true);
 
         // error handler will be called form the sync client thread
@@ -96,7 +98,7 @@ class JniConfigWrapper {
             }
 
             JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
-            env->CallStaticVoidMethod(java_syncmanager, java_error_callback_method, error_code,
+            env->CallStaticVoidMethod(sync_manager_class, java_error_callback_method, error_code,
                                       to_jstring(env, error_message), to_jstring(env, session.get()->path()));
         };
 
@@ -110,7 +112,7 @@ class JniConfigWrapper {
             JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
 
             jstring access_token_string = (jstring)env->CallStaticObjectMethod(
-                java_syncmanager, java_bind_session_method, to_jstring(env, path.c_str()));
+                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()));
             if (access_token_string) {
                 // reusing cached valid token
                 JStringAccessor access_token(env, access_token_string);
@@ -223,7 +225,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     // Close the SharedRealm only. Let the finalizer daemon thread free the SharedRealm
-    shared_realm->close();
+    if (!shared_realm->is_closed()) {
+        shared_realm->close();
+    }
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv* env, jclass,
@@ -246,6 +250,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCommitTransactio
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->commit_transaction();
+        // Realm could be closed in the RealmNotifier.didChange().
+        if (!shared_realm->is_closed()) {
+            // To trigger async queries, so the UI can be refreshed immediately to avoid inconsistency.
+            // See more discussion on https://github.com/realm/realm-java/issues/4245
+            shared_realm->refresh();
+        }
     }
     CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index eca86a2800..2a2c339ebc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -497,29 +497,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(JNIEnv* e
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemove(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                 jlong rowIndex)
-{
-    if (!TBL_AND_ROW_INDEX_VALID(env, TBL(nativeTablePtr), rowIndex)) {
-        return;
-    }
-    try {
-        TBL(nativeTablePtr)->remove(S(rowIndex));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveLast(JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
-        return;
-    }
-    try {
-        TBL(nativeTablePtr)->remove_last();
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                        jlong rowIndex)
 {
@@ -956,198 +933,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink(JNIEnv* en
     CATCH_STD()
 }
 
-//---------------------- Aggregate methods for integers
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSumInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                  jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->sum_int(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                      jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->maximum_int(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                      jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->minimum_int(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                        jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->average_int(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-//--------------------- Aggregate methods for float
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                      jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->sum_float(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMaximumFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                         jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->maximum_float(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMinimumFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                         jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->minimum_float(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageFloat(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                          jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->average_float(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-//--------------------- Aggregate methods for double
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                       jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->sum_double(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMaximumDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                           jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->maximum_double(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMinimumDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                           jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->minimum_double(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                           jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double)) {
-        return 0;
-    }
-    try {
-        return TBL(nativeTablePtr)->average_double(S(columnIndex));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-//--------------------- Aggregate methods for date
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp(JNIEnv* env, jobject,
-                                                                            jlong nativeTablePtr, jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp)) {
-        return 0;
-    }
-    try {
-        return to_milliseconds(TBL(nativeTablePtr)->maximum_timestamp(S(columnIndex)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp(JNIEnv* env, jobject,
-                                                                            jlong nativeTablePtr, jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp)) {
-        return 0;
-    }
-    try {
-        return to_milliseconds(TBL(nativeTablePtr)->minimum_timestamp(S(columnIndex)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
 //---------------------- Count
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountLong(JNIEnv* env, jobject, jlong nativeTablePtr,
@@ -1533,7 +1318,9 @@ static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData
             return true;
 
         default:
-            ThrowException(env, IllegalArgument, "Invalid primary key type: " + column_type);
+            std::ostringstream error_msg;
+            error_msg << "Invalid primary key type for column: " << column_name;
+            ThrowException(env, IllegalArgument, error_msg.str());
             return false;
     }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index ca9baad7ef..bfa10d391f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -17,7 +17,7 @@
 #include "io_realm_internal_TableQuery.h"
 
 #include <realm.hpp>
-#include <realm/group_shared.hpp>
+#include <realm/query_expression.hpp>
 
 #include <shared_realm.hpp>
 #include <object_store.hpp>
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index bdb36b7709..8b491db0b4 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -385,11 +385,19 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn(J
     return to_jbool(ndx != to_jlong_or_not_found(realm::not_found));
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull(JNIEnv*, jobject, jlong nativeRowPtr,
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull(JNIEnv* env, jobject, jlong nativeRowPtr,
                                                                             jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    return to_jbool(ROW(nativeRowPtr)->is_null(columnIndex));
+    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
+        return JNI_FALSE;
+    }
+
+    try {
+        return to_jbool(ROW(nativeRowPtr)->is_null(columnIndex));
+    }
+    CATCH_STD()
+    return JNI_FALSE;
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull(JNIEnv* env, jobject, jlong nativeRowPtr,
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 070de208b9..2c26299cbe 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -17,11 +17,11 @@
 #include <jni.h>
 
 #include "jni_util/jni_utils.hpp"
+#include "jni_util/hack.hpp"
 
 #include <realm/string_data.hpp>
 #include <realm/unicode.hpp>
 
-#include "mem_usage.hpp"
 #include "util.hpp"
 
 using std::string;
@@ -37,6 +37,9 @@ const string TABLE_PREFIX("class_");
 
 JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 {
+    // Workaround for some known bugs in system calls on specific devices.
+    hack_init();
+
     JNIEnv* env;
     if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
         return JNI_ERR;
@@ -53,9 +56,6 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
         java_util_date = GetClass(env, "java/util/Date");
         java_util_date_init = env->GetMethodID(java_util_date, "<init>", "(J)V");
-#if REALM_ENABLE_SYNC
-        java_syncmanager = GetClass(env, "io/realm/SyncManager");
-#endif
     }
 
     return JNI_VERSION_1_6;
@@ -73,18 +73,10 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
         env->DeleteGlobalRef(java_lang_double);
         env->DeleteGlobalRef(java_util_date);
         env->DeleteGlobalRef(java_lang_string);
-#if REALM_ENABLE_SYNC
-        env->DeleteGlobalRef(java_syncmanager);
-#endif
+        JniUtils::release();
     }
 }
 
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
-{
-    return static_cast<jlong>(GetMemUsage());
-}
-
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(JNIEnv* env, jclass)
 {
     realm::StringData sd(TABLE_PREFIX);
diff --git a/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
index d18455b97b..4c6a16a095 100644
--- a/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
@@ -82,3 +82,22 @@ JNIEXPORT jint JNICALL Java_io_realm_log_RealmLog_nativeGetLogLevel(JNIEnv* env,
 
     return static_cast<jint>(Log::Level::all);
 }
+
+// Methods for testing only.
+JNIEXPORT jlong JNICALL Java_io_realm_log_RealmLog_nativeCreateCoreLoggerBridge(JNIEnv* env, jclass, jstring tag)
+{
+    return reinterpret_cast<jlong>(new CoreLoggerBridge(JStringAccessor(env, tag)));
+}
+
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeCloseCoreLoggerBridge(JNIEnv*, jclass, jlong native_ptr)
+{
+    delete reinterpret_cast<CoreLoggerBridge*>(native_ptr);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_log_RealmLog_nativeLogToCoreLoggerBridge(JNIEnv* env, jclass, jlong native_ptr,
+                                                                              jint level, jstring msg)
+{
+    CoreLoggerBridge* bridge = reinterpret_cast<CoreLoggerBridge*>(native_ptr);
+    std::string message = JStringAccessor(env, msg);
+    bridge->log(Log::convert_to_core_log_level(static_cast<Log::Level>(level)), message.c_str());
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/hack.cpp b/realm/realm-library/src/main/cpp/jni_util/hack.cpp
new file mode 100644
index 0000000000..1ca6414ee0
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/hack.cpp
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hack.hpp"
+#include "log.hpp"
+
+#include <string.h>
+
+#include <realm/util/assert.hpp>
+
+#ifndef REALM_WRAP_MEMMOVE
+#error "REALM_WRAP_MEMMOVE is not defined!"
+#endif
+
+#if REALM_WRAP_MEMMOVE
+extern "C" {
+void* __wrap_memmove(void *dest, const void *src, size_t n);
+void* __real_memmove(void *dest, const void *src, size_t n);
+
+void* __wrap_memcpy(void *dest, const void *src, size_t n);
+void* __real_memcpy(void *dest, const void *src, size_t n);
+}
+
+using namespace realm::jni_util;
+
+typedef void* (*MemMoveFunc)(void *dest, const void *src, size_t n);
+static MemMoveFunc s_wrap_memmove_ptr = &__real_memmove;
+static MemMoveFunc s_wrap_memcpy_ptr = &__real_memcpy;
+
+static void* hacked_memmove(void* s1, const void* s2, size_t n)
+{
+    // adapted from https://github.com/dryc/libc11/blob/master/src/string/memmove.c
+    char* dest = (char*)s1;
+    const char* src = (const char*)s2;
+    if (dest <= src) {
+        while (n--) {
+            *dest++ = *src++;
+        }
+    }
+    else {
+        src += n;
+        dest += n;
+        while (n--) {
+            *--dest = *--src;
+        }
+    }
+    return static_cast<void*>(s1);
+}
+
+static void* hacked_memcpy(void* s1, const void* s2, size_t n)
+{
+    // adapted from https://github.com/dryc/libc11/blob/master/src/string/memcpy.c
+    char* dest = (char*)s1;
+    const char* src = (const char*)s2;
+    while (n--) {
+        *dest++ = *src++;
+    }
+    return static_cast<void*>(s1);
+}
+
+void* __wrap_memmove(void *dest, const void *src, size_t n)
+{
+    return (*s_wrap_memmove_ptr)(dest, src, n);
+}
+
+void* __wrap_memcpy(void *dest, const void *src, size_t n)
+{
+    return (*s_wrap_memcpy_ptr)(dest, src, n);
+}
+
+
+// See https://github.com/realm/realm-java/issues/3651#issuecomment-290290228
+// There is a bug in memmove for some Samsung devices which will return "dest-n" instead of dest.
+// The bug was originally found by QT, see https://bugreports.qt.io/browse/QTBUG-34984 .
+// To work around it, we use linker's wrap feature to use a pure C implementation of memmove if the device has the
+// problem.
+static void check_memmove()
+{
+    char* array = strdup("Foobar");
+    size_t len = strlen(array);
+    void* ptr = __real_memmove(array + 1, array, len - 1);
+    if (ptr != array + 1 || strncmp(array, "FFooba", len) != 0) {
+        Log::e("memmove is broken on this device. Switching to the builtin implementation.");
+        s_wrap_memmove_ptr = &hacked_memmove;
+        s_wrap_memcpy_ptr  = &hacked_memcpy;
+    }
+    free(array);
+}
+#endif
+
+namespace realm {
+namespace jni_util {
+
+void hack_init()
+{
+#if REALM_WRAP_MEMMOVE
+    check_memmove();
+#endif
+}
+
+}
+}
+
diff --git a/realm/realm-library/src/main/cpp/mem_usage.hpp b/realm/realm-library/src/main/cpp/jni_util/hack.hpp
similarity index 67%
rename from realm/realm-library/src/main/cpp/mem_usage.hpp
rename to realm/realm-library/src/main/cpp/jni_util/hack.hpp
index e3935c6360..62ac347ee5 100644
--- a/realm/realm-library/src/main/cpp/mem_usage.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/hack.hpp
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,13 +14,15 @@
  * limitations under the License.
  */
 
-#ifndef __SUPPORT_MEM__
-#define __SUPPORT_MEM__
+#ifndef REALM_JNI_UTIL_HACK_HPP
+#define REALM_JNI_UTIL_HACK_HPP
 
-#include <cstdlib> // size_t
+namespace realm {
+namespace jni_util {
 
-/// This function requires that REALM_ENABLE_MEM_USAGE is specified
-/// during building. Otherwise it always returns zero.
-size_t GetMemUsage();
+// Workaround bugs on some devices.
+void hack_init();
 
-#endif //__SUPPORT_MEM__
+}
+}
+#endif // REALM_JNI_UTIL_HACK_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
new file mode 100644
index 0000000000..f0bb7530c5
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_class.hpp"
+#include "jni_utils.hpp"
+
+#include <realm/util/assert.hpp>
+
+using namespace realm::jni_util;
+
+JavaClass::JavaClass(JNIEnv* env, const char* class_name, bool free_on_unload)
+    : m_ref_owner(get_jclass(env, class_name))
+    , m_class(reinterpret_cast<jclass>(m_ref_owner.get()))
+{
+    if (free_on_unload) {
+        // Move the ownership of global ref to JNIUtils which will be released when JNI_OnUnload.
+        JniUtils::keep_global_ref(m_ref_owner);
+    }
+}
+
+JavaGlobalRef JavaClass::get_jclass(JNIEnv* env, const char* class_name)
+{
+    jclass cls = env->FindClass(class_name);
+    REALM_ASSERT_DEBUG(cls);
+
+    JavaGlobalRef cls_ref(env, cls);
+    env->DeleteLocalRef(cls);
+    return cls_ref;
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.hpp b/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
new file mode 100644
index 0000000000..c95dce29d4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JAVA_CLASS_HPP
+#define REALM_JNI_UTIL_JAVA_CLASS_HPP
+
+#include <jni.h>
+
+#include "java_global_ref.hpp"
+
+namespace realm {
+namespace jni_util {
+
+// To find the jclass and manage the lifecycle for the jclass's global ref.
+class JavaClass {
+public:
+    // when free_on_unload is true, the jclass's global ref will be released when JNI_OnUnload called. This is useful
+    // when the JavaClass instance is static. Otherwise the jclass's global ref will be released when this object is
+    // deleted.
+    JavaClass(JNIEnv* env, const char* class_name, bool free_on_unload = true);
+    ~JavaClass()
+    {
+    }
+
+    inline jclass get() noexcept
+    {
+        return m_class;
+    }
+
+    inline operator jclass() const noexcept
+    {
+        return m_class;
+    }
+
+    // Not implemented for now.
+    JavaClass(JavaClass&&) = delete;
+    JavaClass(JavaClass&) = delete;
+    JavaClass& operator=(JavaClass&&) = delete;
+
+private:
+    JavaGlobalRef m_ref_owner;
+    jclass m_class;
+    static JavaGlobalRef get_jclass(JNIEnv* env, const char* class_name);
+};
+
+} // jni_util
+} // realm
+
+#endif
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
new file mode 100644
index 0000000000..fd6036cf95
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_global_ref.hpp"
+#include "jni_utils.hpp"
+
+#include <memory>
+
+using namespace realm::jni_util;
+
+JavaGlobalRef::~JavaGlobalRef()
+{
+    if (m_ref) {
+        JniUtils::get_env()->DeleteGlobalRef(m_ref);
+    }
+}
+
+JavaGlobalRef& JavaGlobalRef::operator=(JavaGlobalRef&& rhs)
+{
+    this->~JavaGlobalRef();
+    new (this) JavaGlobalRef(std::move(rhs));
+    return *this;
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
new file mode 100644
index 0000000000..f2d0c3320d
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JAVA_GLOBAL_REF_HPP
+#define REALM_JNI_UTIL_JAVA_GLOBAL_REF_HPP
+
+#include <jni.h>
+
+namespace realm {
+namespace jni_util {
+
+// Manage the lifecycle of jobject's global ref.
+class JavaGlobalRef {
+public:
+    JavaGlobalRef()
+        : m_ref(nullptr)
+    {
+    }
+    // Acquire a global ref on the given jobject. The local ref will be released if given release_local_ref is true.
+    JavaGlobalRef(JNIEnv* env, jobject obj, bool release_local_ref = false)
+        : m_ref(obj ? env->NewGlobalRef(obj) : nullptr)
+    {
+        if (release_local_ref) {
+            env->DeleteLocalRef(obj);
+        }
+    }
+    JavaGlobalRef(JavaGlobalRef&& rhs)
+        : m_ref(rhs.m_ref)
+    {
+        rhs.m_ref = nullptr;
+    }
+    ~JavaGlobalRef();
+
+    JavaGlobalRef& operator=(JavaGlobalRef&& rhs);
+
+    inline operator bool() const noexcept
+    {
+        return m_ref != nullptr;
+    }
+
+    inline jobject get() noexcept
+    {
+        return m_ref;
+    }
+
+    // Not implemented for now.
+    JavaGlobalRef(JavaGlobalRef&) = delete;
+
+private:
+    jobject m_ref;
+};
+}
+}
+
+#endif // REALM_JNI_UTIL_JAVA_GLOBAL_REF_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
index e28bfc184a..882e4ef38f 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
@@ -29,14 +29,14 @@ JavaMethod::JavaMethod(JNIEnv* env, jclass cls, const char* method_name, const c
         m_method_id = env->GetMethodID(cls, method_name, signature);
     }
 
-    REALM_ASSERT_DEBUG(m_method_id != nullptr);
+    REALM_ASSERT_RELEASE(m_method_id != nullptr);
 }
 
 JavaMethod::JavaMethod(JNIEnv* env, jobject obj, const char* method_name, const char* signature)
 {
     jclass cls = env->GetObjectClass(obj);
     m_method_id = env->GetMethodID(cls, method_name, signature);
-    REALM_ASSERT_DEBUG(m_method_id != nullptr);
+    REALM_ASSERT_RELEASE(m_method_id != nullptr);
     env->DeleteLocalRef(cls);
 }
 
@@ -44,7 +44,7 @@ JavaMethod::JavaMethod(JNIEnv* env, const char* class_name, const char* method_n
                        bool static_method)
 {
     jclass cls = env->FindClass(class_name);
-    REALM_ASSERT_DEBUG(cls != nullptr);
+    REALM_ASSERT_RELEASE(cls != nullptr);
     if (static_method) {
         m_method_id = env->GetStaticMethodID(cls, method_name, signature);
     }
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
index 88a23ebb01..0ca6f526a3 100644
--- a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
@@ -31,6 +31,12 @@ void JniUtils::initialize(JavaVM* vm, jint vm_version) noexcept
     s_instance = std::unique_ptr<JniUtils>(new JniUtils(vm, vm_version));
 }
 
+void JniUtils::release()
+{
+    REALM_ASSERT_DEBUG(s_instance);
+    s_instance.release();
+}
+
 JNIEnv* JniUtils::get_env(bool attach_if_needed)
 {
     REALM_ASSERT_DEBUG(s_instance);
@@ -53,3 +59,9 @@ void JniUtils::detach_current_thread()
 {
     s_instance->m_vm->DetachCurrentThread();
 }
+
+void JniUtils::keep_global_ref(JavaGlobalRef& ref)
+{
+    s_instance->m_global_refs.push_back(std::move(ref));
+}
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
index 7d2bcf4b9d..689aa1232c 100644
--- a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
@@ -19,6 +19,10 @@
 
 #include <jni.h>
 
+#include <vector>
+
+#include "java_global_ref.hpp"
+
 namespace realm {
 namespace jni_util {
 
@@ -31,12 +35,16 @@ class JniUtils {
 
     // Call this only once in JNI_OnLoad.
     static void initialize(JavaVM* vm, jint vm_version) noexcept;
+    // Call this in JNI_OnUnload.
+    static void release();
     // When attach_if_needed is false, returns the JNIEnv if there is one attached to this thread. Assert if there is
     // none. When attach_if_needed is true, try to attach and return a JNIEnv if necessary.
     static JNIEnv* get_env(bool attach_if_needed = false);
     // Detach the current thread from the JVM. Only required for C++ threads that where attached in the first place.
     // Failing to do so is a resource leak.
     static void detach_current_thread();
+    // Keep the given global reference until JNI_OnUnload is called.
+    static void keep_global_ref(JavaGlobalRef& ref);
 
 private:
     JniUtils(JavaVM* vm, jint vm_version) noexcept
@@ -47,6 +55,7 @@ class JniUtils {
 
     JavaVM* m_vm;
     jint m_vm_version;
+    std::vector<JavaGlobalRef> m_global_refs;
 };
 
 } // namespace realm
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
index d8b804549d..c90a4d5e25 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -16,6 +16,8 @@
 
 #include <algorithm>
 
+#include <realm/util/assert.hpp>
+
 #include "jni_util/log.hpp"
 
 using namespace realm;
@@ -24,6 +26,8 @@ using namespace realm::util;
 
 const char* Log::REALM_JNI_TAG = "REALM_JNI";
 Log::Level Log::s_level = Log::Level::warn;
+std::vector<CoreLoggerBridge*> CoreLoggerBridge::s_bridges;
+std::mutex CoreLoggerBridge::s_mutex;
 
 // Native wrapper for Java RealmLogger class
 class JavaLogger : public JniLogger {
@@ -157,6 +161,7 @@ void Log::clear_loggers()
 void Log::set_level(Level level)
 {
     s_level = level;
+    CoreLoggerBridge::set_levels(level);
 }
 
 void Log::log(Level level, const char* tag, jthrowable throwable, const char* message)
@@ -169,6 +174,53 @@ void Log::log(Level level, const char* tag, jthrowable throwable, const char* me
     }
 }
 
+realm::util::RootLogger::Level Log::convert_to_core_log_level(Level level)
+{
+        switch (level) {
+            case Log::trace:
+                return RootLogger::Level::trace;
+            case Log::debug:
+                return RootLogger::Level::debug;
+            case Log::info:
+                return RootLogger::Level::info;
+            case Log::warn:
+                return RootLogger::Level::warn;
+            case Log::error:
+                return RootLogger::Level::error;
+            case Log::fatal:
+                return RootLogger::Level::fatal;
+            case Log::all:
+                return RootLogger::Level::all;
+            case Log::off:
+                return RootLogger::Level::off;
+            default:
+                break;
+        }
+        REALM_UNREACHABLE();
+}
+
+CoreLoggerBridge::CoreLoggerBridge(std::string tag)
+    : m_tag(std::move(tag))
+{
+    std::lock_guard<std::mutex> lock(s_mutex);
+    s_bridges.push_back(this);
+    set_level_threshold(Log::convert_to_core_log_level(Log::shared().get_level()));
+}
+
+CoreLoggerBridge::~CoreLoggerBridge()
+{
+    std::lock_guard<std::mutex> lock(s_mutex);
+    s_bridges.erase(std::remove(s_bridges.begin(), s_bridges.end(), this), s_bridges.end());
+}
+
+void CoreLoggerBridge::set_levels(Log::Level level)
+{
+    std::lock_guard<std::mutex> lock(s_mutex);
+    for (auto bridge : s_bridges) {
+        bridge->set_level_threshold(Log::convert_to_core_log_level(level));
+    }
+}
+
 void CoreLoggerBridge::do_log(realm::util::Logger::Level level, std::string msg)
 {
     // Ignore the level threshold from the root logger.
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.hpp b/realm/realm-library/src/main/cpp/jni_util/log.hpp
index d138f287d2..98cc58d1c9 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.hpp
@@ -142,6 +142,8 @@ class Log {
         shared().log(fatal, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
     }
 
+    static realm::util::RootLogger::Level convert_to_core_log_level(Level level);
+
     // Get the shared Log instance.
     static Log& shared();
 
@@ -178,13 +180,26 @@ class JniLogger {
 // Implement this function to return the default logger which will be registered during initialization.
 extern std::shared_ptr<JniLogger> get_default_logger();
 
+// Do NOT call set_level_threshold on the bridge to set the log level. Instead, call the Log::set_level which will
+// set all logger levels.
 class CoreLoggerBridge : public realm::util::RootLogger {
 public:
-    CoreLoggerBridge(std::string tag) : m_tag(std::move(tag)) {}
+    CoreLoggerBridge(std::string tag);
+    ~CoreLoggerBridge();
+    CoreLoggerBridge(CoreLoggerBridge&&) = delete;
+    CoreLoggerBridge(CoreLoggerBridge&) = delete;
+    CoreLoggerBridge operator=(CoreLoggerBridge&&) = delete;
+    CoreLoggerBridge operator=(CoreLoggerBridge&) = delete;
     void do_log(Logger::Level, std::string msg) override;
 
 private:
+    // Set log level for all logger bridges.
+    static void set_levels(Log::Level level);
+    friend class Log;
+
     const std::string m_tag;
+    static std::vector<CoreLoggerBridge*> s_bridges;
+    static std::mutex s_mutex;
 };
 
 } // namespace jni_util
diff --git a/realm/realm-library/src/main/cpp/mem_usage.cpp b/realm/realm-library/src/main/cpp/mem_usage.cpp
deleted file mode 100644
index 21a81ef15a..0000000000
--- a/realm/realm-library/src/main/cpp/mem_usage.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mem_usage.hpp"
-
-#ifndef REALM_ENABLE_MEM_USAGE
-
-size_t GetMemUsage()
-{
-    return 0;
-}
-
-#elif defined(_MSC_VER) // Microsoft Windows
-
-
-#include <windows.h>
-#include <psapi.h>
-
-namespace {
-
-// Pre-declarations
-DWORD CalculateWSPrivate(DWORD processID);
-
-// Calculate Private Working Set
-// Source: http://www.codeproject.com/KB/cpp/XPWSPrivate.aspx
-
-int Compare(const void* Val1, const void* Val2)
-{
-    if (*(PDWORD)Val1 == *(PDWORD)Val2)
-        return 0;
-
-    return *(PDWORD)Val1 > *(PDWORD)Val2 ? 1 : -1;
-}
-
-DWORD dWorkingSetPages[1024 * 128]; // hold the working set
-                                    // information get from QueryWorkingSet()
-DWORD dPageSize = 0x1000;
-
-DWORD CalculateWSPrivate(DWORD processID)
-{
-    DWORD dSharedPages = 0;
-    DWORD dPrivatePages = 0;
-    DWORD dPageTablePages = 0;
-
-    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);
-
-    if (!hProcess)
-        return 0;
-
-    __try {
-        if (!QueryWorkingSet(hProcess, dWorkingSetPages, sizeof(dWorkingSetPages)))
-            __leave;
-
-        DWORD dPages = dWorkingSetPages[0];
-
-        qsort(&dWorkingSetPages[1], dPages, sizeof(DWORD), Compare);
-
-        for (DWORD i = 1; i <= dPages; i++) {
-            DWORD dCurrentPageStatus = 0;
-            DWORD dCurrentPageAddress;
-            DWORD dNextPageAddress;
-            DWORD dNextPageFlags;
-            DWORD dPageAddress = dWorkingSetPages[i] & 0xFFFFF000;
-            DWORD dPageFlags = dWorkingSetPages[i] & 0x00000FFF;
-
-            while (i <= dPages) // iterate all pages
-            {
-                dCurrentPageStatus++;
-
-                if (i == dPages) // if last page
-                    break;
-
-                dCurrentPageAddress = dWorkingSetPages[i] & 0xFFFFF000;
-                dNextPageAddress = dWorkingSetPages[i + 1] & 0xFFFFF000;
-                dNextPageFlags = dWorkingSetPages[i + 1] & 0x00000FFF;
-
-                // decide whether iterate further or exit
-                //(this is non-contiguous page or have different flags)
-                if ((dNextPageAddress == (dCurrentPageAddress + dPageSize)) && (dNextPageFlags == dPageFlags)) {
-                    i++;
-                }
-                else
-                    break;
-            }
-
-            if ((dPageAddress < 0xC0000000) || (dPageAddress > 0xE0000000)) {
-                if (dPageFlags & 0x100) // this is shared one
-                    dSharedPages += dCurrentPageStatus;
-
-                else // private one
-                    dPrivatePages += dCurrentPageStatus;
-            }
-            else
-                dPageTablePages += dCurrentPageStatus; // page table region
-        }
-
-        DWORD dTotal = dPages * 4;
-        DWORD dShared = dSharedPages * 4;
-        DWORD WSPrivate = dTotal - dShared;
-
-        return WSPrivate;
-    }
-    __finally {
-        CloseHandle(hProcess);
-    }
-    return -1;
-}
-
-} // anonymous namespace
-
-size_t GetMemUsage()
-{
-    return CalculateWSPrivate(GetCurrentProcessId());
-}
-
-
-#elif defined(__APPLE__) // Mac / Darwin
-
-
-#include <mach/mach.h>
-
-size_t GetMemUsage()
-{
-    struct task_basic_info t_info;
-
-    mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;
-
-    if (KERN_SUCCESS != task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count))
-        return -1;
-
-    // resident size is in t_info.resident_size;
-    // virtual size is in t_info.virtual_size;
-    return t_info.resident_size;
-}
-
-
-#else // POSIX
-
-
-#include <cstdio>
-// Debian package: libproc-dev
-// Linker flag   : -lproc
-// Documentation : /usr/include/proc/readproc.h
-#include <proc/readproc.h>
-
-size_t GetMemUsage()
-{
-    struct proc_t usage;
-    look_up_our_self(&usage);
-    return usage.vsize;
-}
-
-
-#endif
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 14c2c7e703..dfddfa7f7b 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 14c2c7e7038850302f60f6fa1e36a22bceb3ab94
+Subproject commit dfddfa7f7bf564619e2257243c252ffad6d5c9c3
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index a2f4516ede..e562c12564 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -43,9 +43,6 @@ jclass java_lang_string;
 jmethodID java_lang_double_init;
 jclass java_util_date;
 jmethodID java_util_date_init;
-#if REALM_ENABLE_SYNC
-jclass java_syncmanager;
-#endif
 
 void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
@@ -109,6 +106,9 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalState, ss.str());
     }
+    catch (realm::LogicError e) {
+        ThrowException(env, IllegalState, e.what());
+    }
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
     }
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 76378a8e42..29c2813d17 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -29,7 +29,6 @@
 #include <realm.hpp>
 #include <realm/lang_bind_helper.hpp>
 #include <realm/timestamp.hpp>
-#include <realm/util/meta.hpp>
 #include <realm/util/safe_int_ops.hpp>
 
 #include <util/format.hpp>
@@ -344,7 +343,7 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColTy
     int colType = pTable->get_column_type(col);
     if (colType != expectColType) {
         realm::jni_util::Log::e("Expected columnType %1, but got %2.", expectColType, pTable->get_column_type(col));
-        ThrowException(env, IllegalArgument, "ColumnType invalid.");
+        ThrowException(env, IllegalArgument, "ColumnType of '" + std::string(pTable->get_column_name(col)) + "' is invalid.");
         return false;
     }
     return true;
@@ -361,7 +360,8 @@ inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
 
     realm::jni_util::Log::e("Expected columnType %1 or %2, but got %3", realm::type_Link, realm::type_LinkList,
                             colType);
-    ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
+    ThrowException(env, IllegalArgument, "ColumnType of '" + std::string(pTable->get_column_name(col)) + "' is invalid:"
+                                         " expected type_Link or type_LinkList");
     return false;
 }
 
@@ -375,7 +375,7 @@ inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
     }
 
     if (colType == realm::type_LinkList) {
-        ThrowException(env, IllegalArgument, "RealmList is not nullable.");
+        ThrowException(env, IllegalArgument, "RealmList(" + std::string(pTable->get_column_name(col)) + ") is not nullable.");
         return false;
     }
 
@@ -384,7 +384,7 @@ inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
     }
 
     realm::jni_util::Log::e("Expected nullable column type");
-    ThrowException(env, IllegalArgument, "This field is not nullable.");
+    ThrowException(env, IllegalArgument, "This field(" + std::string(pTable->get_column_name(col)) + ") is not nullable.");
     return false;
 }
 
@@ -703,9 +703,6 @@ extern jclass java_lang_string;
 extern jmethodID java_lang_double_init;
 extern jclass java_util_date;
 extern jmethodID java_util_date_init;
-#if REALM_ENABLE_SYNC
-extern jclass java_syncmanager;
-#endif
 
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index f3fc9a16b4..894e581e0a 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -62,16 +62,16 @@
     static final String LISTENER_NOT_ALLOWED_MESSAGE = "Listeners cannot be used on current thread.";
 
 
-    volatile static Context applicationContext;
+    static volatile Context applicationContext;
 
     // Thread pool for all async operations (Query & transaction)
     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
     final long threadId;
-    protected RealmConfiguration configuration;
+    protected final RealmConfiguration configuration;
     protected SharedRealm sharedRealm;
 
-    RealmSchema schema;
+    protected final StandardRealmSchema schema;
 
     protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
@@ -85,7 +85,7 @@ public void onSchemaVersionChanged(long currentVersion) {
                                 RealmCache.updateSchemaCache((Realm) BaseRealm.this);
                             }
                         }, true);
-        this.schema = new RealmSchema(this);
+        this.schema = new StandardRealmSchema(this);
     }
 
     /**
@@ -481,8 +481,6 @@ public RealmSchema getSchema() {
             result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
                     false, Collections.<String>emptyList());
         }
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setTableVersion$realm();
         return result;
     }
 
@@ -491,8 +489,6 @@ public RealmSchema getSchema() {
         UncheckedRow row = table.getUncheckedRow(rowIndex);
         E result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
                 acceptDefaultValue, excludeFields);
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setTableVersion$realm();
         return result;
     }
 
@@ -515,11 +511,6 @@ public RealmSchema getSchema() {
                     schema.getColumnInfo(clazz), false, Collections.<String>emptyList());
         }
 
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
-        if (rowIndex != Table.NO_MATCH) {
-            proxy.realmGet$proxyState().setTableVersion$realm();
-        }
-
         return result;
     }
 
@@ -651,6 +642,10 @@ protected void finalize() throws Throwable {
         super.finalize();
     }
 
+    SharedRealm getSharedRealm() {
+        return sharedRealm;
+    }
+
     // Internal delegate for migrations.
     protected interface MigrationCallback {
         void migrationComplete();
@@ -672,7 +667,7 @@ public void set(BaseRealm realm, Row row, ColumnInfo columnInfo,
             this.excludeFields = excludeFields;
         }
 
-        public BaseRealm getRealm() {
+        BaseRealm getRealm() {
             return realm;
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 862255f0b5..0d1d518201 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -344,7 +344,7 @@ public DynamicRealmObject getObject(String fieldName) {
         try {
             LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
             String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
-            return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
+            return new RealmList<>(className, linkView, proxyState.getRealm$realm());
         } catch (IllegalArgumentException e) {
             checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
             throw e;
@@ -713,7 +713,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
             typeValidated = false;
         } else {
             String listType = list.className != null ? list.className
-                    : Table.tableNameToClassName(proxyState.getRealm$realm().schema.getTable(list.clazz).getName());
+                    : Table.tableNameToClassName(proxyState.getRealm$realm().getSchema().getTable(list.clazz).getName());
             if (!linkTargetTableName.equals(listType)) {
                 throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                         "The elements in the list are not the proper type. " +
diff --git a/realm/realm-library/src/main/java/io/realm/ObjectChangeSet.java b/realm/realm-library/src/main/java/io/realm/ObjectChangeSet.java
new file mode 100644
index 0000000000..1c5277c903
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/ObjectChangeSet.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Information about the changes made to an object.
+ *
+ * @see RealmObject#addChangeListener(RealmObjectChangeListener) .
+ */
+public interface ObjectChangeSet {
+
+    /**
+     * @return true if the object has been deleted from the Realm.
+     */
+    boolean isDeleted();
+
+    /**
+     * @return the names of changed fields if the object still exists and there are field changes. Returns an empty
+     * {@code String[]} if the object has been deleted.
+     */
+    String[] getChangedFields();
+
+    /**
+     * Checks if a given field has been changed.
+     *
+     * @param fieldName to be checked if its value has been changed.
+     * @return {@code true} if the field has been changed. It returns {@code false} if the object is deleted, the field
+     * cannot be found or the field hasn't been changed.
+     */
+    boolean isFieldChanged(String fieldName);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
new file mode 100644
index 0000000000..6078699ec8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import io.realm.internal.Table;
+
+
+class OsRealmObjectSchema extends RealmObjectSchema {
+    private long nativePtr;
+
+    /**
+     * Creates a schema object using object store. This constructor is intended to be used by
+     * the validation of schema, object schemas and properties through the object store. Even though the constructor
+     * is public, there is never a purpose which justifies calling it!
+     *
+     * @param className name of the class
+     */
+    OsRealmObjectSchema(String className) {
+        this.nativePtr = nativeCreateRealmObjectSchema(className);
+    }
+
+    OsRealmObjectSchema(long nativePtr) {
+        this.nativePtr = nativePtr;
+    }
+
+    @Override
+    public void close() {
+        if (nativePtr != 0L) {
+            nativeClose(nativePtr);
+            nativePtr = 0L;
+        }
+    }
+
+    @Override
+    public String getClassName() {
+        return nativeGetClassName(nativePtr);
+    }
+
+    @Override
+    public OsRealmObjectSchema setClassName(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema removeField(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasField(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema removeIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addPrimaryKey(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema removePrimaryKey() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema setRequired(String fieldName, boolean required) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isRequired(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isNullable(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isPrimaryKey(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasPrimaryKey() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getPrimaryKey() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Set<String> getFieldNames() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema transform(Function function) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public RealmFieldType getFieldType(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    OsRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
+        final Property property = new Property(name, type, primary, indexed, required);
+        try {
+            nativeAddProperty(nativePtr, property.getNativePtr());
+        } finally {
+            property.close();
+        }
+        return this;
+    }
+
+    @Override
+    OsRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        final Property property = new Property(name, type, linkedTo);
+        try {
+            nativeAddProperty(nativePtr, property.getNativePtr());
+        } finally {
+            property.close();
+        }
+        return this;
+    }
+
+    long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    Table getTable() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    long getAndCheckFieldIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    static native long nativeCreateRealmObjectSchema(String className);
+
+    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
+
+    static native void nativeClose(long nativePtr);
+
+    static native String nativeGetClassName(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
new file mode 100644
index 0000000000..7d96117d9d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.internal.Table;
+
+
+/**
+ * Class for interacting with the Realm schema using a dynamic API. This makes it possible
+ * to add, delete and change the classes in the Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
+ *
+ * @see RealmMigration
+ */
+class OsRealmSchema extends RealmSchema {
+    static final class Creator extends RealmSchema {
+        private final Map<String, RealmObjectSchema> schema = new HashMap<>();
+
+        @Override
+        public void close() {
+            for (Map.Entry<String, RealmObjectSchema> entry : schema.entrySet()) {
+                entry.getValue().close();
+            }
+            schema.clear();
+        }
+
+        @Override
+        public RealmObjectSchema get(String className) {
+            checkEmpty(className);
+            return (!contains(className)) ? null : schema.get(className);
+        }
+
+        @Override
+        public Set<RealmObjectSchema> getAll() {
+            return new LinkedHashSet<>(schema.values());
+        }
+
+        @Override
+        public RealmObjectSchema create(String className) {
+            checkEmpty(className);
+            OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
+            schema.put(className, realmObjectSchema);
+            return realmObjectSchema;
+        }
+
+        @Override
+        public boolean contains(String className) {
+            return schema.containsKey(className);
+        }
+
+        @Override
+        Table getTable(Class<? extends RealmModel> clazz) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        Table getTable(String className) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        OsRealmObjectSchema getSchemaForClass(String className) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void remove(String className) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public RealmObjectSchema rename(String oldClassName, String newClassName) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+
+    private long nativePtr;
+
+    OsRealmSchema(Creator creator) {
+        Set<RealmObjectSchema> realmObjectSchemas = creator.getAll();
+        long[] schemaNativePointers = new long[realmObjectSchemas.size()];
+        int i = 0;
+        for (RealmObjectSchema schema : realmObjectSchemas) {
+            schemaNativePointers[i++] = ((OsRealmObjectSchema) schema).getNativePtr();
+        }
+        this.nativePtr = nativeCreateFromList(schemaNativePointers);
+    }
+
+    public long getNativePtr() {
+        return this.nativePtr;
+    }
+
+    // See BaseRealm uses a StandardRealmSchema, not a OsRealmSchema.
+    @Override
+    public void close() {
+        if (nativePtr != 0L) {
+            nativeClose(nativePtr);
+            nativePtr = 0L;
+        }
+    }
+
+    /**
+     * Returns the Realm schema for a given class.
+     *
+     * @param className name of the class
+     * @return schema object for that class or {@code null} if the class doesn't exists.
+     */
+    @Override
+    public RealmObjectSchema get(String className) {
+        checkEmpty(className);
+        return (!contains(className)) ? null : dynamicClassToSchema.get(className);
+    }
+
+    /**
+     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     *
+     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
+     */
+    @Override
+    public Set<RealmObjectSchema> getAll() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Adds a new class to the Realm.
+     *
+     * @param className name of the class.
+     * @return a Realm schema object for that class.
+     */
+    @Override
+    public RealmObjectSchema create(String className) {
+        // Adding a class is always permitted.
+        checkEmpty(className);
+        OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
+        dynamicClassToSchema.put(className, realmObjectSchema);
+        return realmObjectSchema;
+    }
+
+    @Override
+    public void remove(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Checks if a given class already exists in the schema.
+     *
+     * @param className class name to check.
+     * @return {@code true} if the class already exists. {@code false} otherwise.
+     */
+    @Override
+    public boolean contains(String className) {
+        return dynamicClassToSchema.containsKey(className);
+    }
+
+    @Override
+    Table getTable(Class<? extends RealmModel> clazz) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    Table getTable(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    OsRealmObjectSchema getSchemaForClass(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    static void checkEmpty(String str) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    static native long nativeCreateFromList(long[] objectSchemaPtrs);
+
+    static native void nativeClose(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Property.java b/realm/realm-library/src/main/java/io/realm/Property.java
index 02557c6cd6..4285be3db5 100644
--- a/realm/realm-library/src/main/java/io/realm/Property.java
+++ b/realm/realm-library/src/main/java/io/realm/Property.java
@@ -26,15 +26,14 @@
     public static final boolean REQUIRED = true;
     public static final boolean INDEXED = true;
 
-    private final long nativePtr;
+    private long nativePtr;
 
-    public Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
+    Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
         this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), isPrimary, isIndexed, !isRequired);
     }
 
-    public Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        String linkedToName = linkedTo.getClassName();
-        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedToName);
+    Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedTo.getClassName());
     }
 
     protected Property(long nativePtr) {
@@ -48,6 +47,7 @@ protected long getNativePtr() {
     public void close() {
         if (nativePtr != 0) {
             nativeClose(nativePtr);
+            nativePtr = 0L;
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 74b72fb127..58ef76c7ec 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -17,11 +17,11 @@
 package io.realm;
 
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
 
-import io.realm.internal.InvalidRow;
+import io.realm.internal.ObserverPairList;
 import io.realm.internal.PendingRow;
 import io.realm.internal.Row;
+import io.realm.internal.OsObject;
 import io.realm.internal.UncheckedRow;
 
 
@@ -30,18 +30,57 @@
  * {@link RealmObject} and {@link DynamicRealmObject}.
  */
 public final class ProxyState<E extends RealmModel> implements PendingRow.FrontEnd {
+
+    static class RealmChangeListenerWrapper<T extends RealmModel> implements RealmObjectChangeListener<T> {
+        private final RealmChangeListener<T> listener;
+
+        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
+            if (listener == null) {
+                throw new IllegalArgumentException("Listener should not be null");
+            }
+            this.listener = listener;
+        }
+
+        @Override
+        public void onChange(T object, ObjectChangeSet changes) {
+            listener.onChange(object);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof RealmChangeListenerWrapper &&
+                    listener == ((RealmChangeListenerWrapper) obj).listener;
+        }
+
+        @Override
+        public int hashCode() {
+            return listener.hashCode();
+        }
+    }
+
+    private static class QueryCallback implements ObserverPairList.Callback<OsObject.ObjectObserverPair> {
+
+        @Override
+        public void onCalled(OsObject.ObjectObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange((RealmModel) observer, null);
+        }
+    }
+
     private E model;
 
     // true only while executing the constructor of the enclosing proxy object
     private boolean underConstruction = true;
 
     private Row row;
+    private OsObject osObject;
     private BaseRealm realm;
     private boolean acceptDefaultValue;
     private List<String> excludeFields;
 
-    private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
-    protected long currentTableVersion = -1;
+    private ObserverPairList<OsObject.ObjectObserverPair> observerPairs =
+            new ObserverPairList<OsObject.ObjectObserverPair>();
+    private static QueryCallback queryCallback = new QueryCallback();
 
     public ProxyState() {}
 
@@ -84,44 +123,34 @@ public ProxyState(E model) {
     /**
      * Notifies all registered listeners.
      */
-    private void notifyChangeListeners() {
-        if (!listeners.isEmpty()) {
-            for (RealmChangeListener<E> listener : listeners) {
-                if (realm.sharedRealm == null || realm.sharedRealm.isClosed()) {
-                    return;
-                }
-                listener.onChange(model);
-            }
-        }
+    private void notifyQueryFinished() {
+        observerPairs.foreach(queryCallback);
     }
 
-    public void addChangeListener(RealmChangeListener<E> listener) {
-        if (!listeners.contains(listener)) {
-            listeners.add(listener);
-        }
-        // this might be called after query returns. So it is still necessary to register.
-        if (row instanceof UncheckedRow) {
-            registerToRealmNotifier();
+    public void addChangeListener(RealmObjectChangeListener<E> listener) {
+        if (row instanceof PendingRow) {
+            observerPairs.add(new OsObject.ObjectObserverPair<E>(model, listener));
+        } else if (row instanceof UncheckedRow) {
+            registerToObjectNotifier();
+            if (osObject != null) {
+                osObject.addListener(model, listener);
+            }
         }
     }
 
-    public void removeChangeListener(RealmChangeListener<E> listener) {
-        listeners.remove(listener);
-        if (listeners.isEmpty() && row instanceof UncheckedRow) {
-            realm.sharedRealm.realmNotifier.removeChangeListeners(this);
+    public void removeChangeListener(RealmObjectChangeListener<E> listener) {
+        if (osObject != null) {
+            osObject.removeListener(model, listener);
+        } else {
+            observerPairs.remove(model, listener);
         }
     }
 
     public void removeAllChangeListeners() {
-        listeners.clear();
-        if (row instanceof UncheckedRow) {
-            realm.sharedRealm.realmNotifier.removeChangeListeners(this);
-        }
-    }
-
-    public void setTableVersion$realm() {
-        if (row.getTable() != null) {
-            currentTableVersion = row.getTable().getVersion();
+        if (osObject != null) {
+            osObject.removeListener(model);
+        } else {
+            observerPairs.clear();
         }
     }
 
@@ -135,25 +164,17 @@ public void setConstructionFinished() {
         excludeFields = null;
     }
 
-    private void registerToRealmNotifier() {
+    private void registerToObjectNotifier() {
         if (realm.sharedRealm == null || realm.sharedRealm.isClosed() || !row.isAttached()) {
             return;
         }
 
-        realm.sharedRealm.realmNotifier.addChangeListener(this, new RealmChangeListener<ProxyState<E>>() {
-            @Override
-            public void onChange(ProxyState<E> element) {
-                long tableVersion = -1;
-                if (row.isAttached()) {
-                    // If the Row gets detached, table version will be -1 and it is different from current value.
-                    tableVersion = row.getTable().getVersion();
-                }
-                if (currentTableVersion != tableVersion) {
-                    currentTableVersion = tableVersion;
-                    notifyChangeListeners();
-                }
-            }
-        });
+        if (osObject == null) {
+            osObject = new OsObject(realm.sharedRealm, (UncheckedRow) row);
+            osObject.setObserverPairs(observerPairs);
+            // We should never need observerPairs after pending row returns.
+            observerPairs = null;
+        }
     }
 
     public boolean isLoaded() {
@@ -162,22 +183,17 @@ public boolean isLoaded() {
 
     public void load() {
         if (row instanceof PendingRow) {
-            row = ((PendingRow) row).executeQuery();
-            if (!(row instanceof InvalidRow)) {
-                registerToRealmNotifier();
-            }
-            notifyChangeListeners();
+            ((PendingRow) row).executeQuery();
         }
     }
 
     @Override
     public void onQueryFinished(Row row) {
         this.row = row;
-        notifyChangeListeners();
+        // getTable should return a non-null table since the row should always be valid here.
+        notifyQueryFinished();
         if (row.isAttached()) {
-            // getTable should return a non-null table since the row should always be valid here.
-            currentTableVersion = row.getTable().getVersion();
-            registerToRealmNotifier();
+            registerToObjectNotifier();
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 2cbbd09b81..efcf14c5ba 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -20,6 +20,7 @@
 import android.app.IntentService;
 import android.content.Context;
 import android.os.Build;
+import android.os.SystemClock;
 import android.util.JsonReader;
 
 import org.json.JSONArray;
@@ -180,6 +181,7 @@
      *
      * @param context the Application Context.
      * @throws IllegalArgumentException if a {@code null} context is provided.
+     * @throws IllegalStateException if {@link Context#getFilesDir()} could not be found.
      * @see #getDefaultInstance()
      */
     public static synchronized void init(Context context) {
@@ -187,6 +189,7 @@ public static synchronized void init(Context context) {
             if (context == null) {
                 throw new IllegalArgumentException("Non-null context required.");
             }
+            checkFilesDirAvailable(context);
             RealmCore.loadLibrary(context);
             defaultConfiguration = new RealmConfiguration.Builder(context).build();
             ObjectServerFacade.getSyncFacadeIfPossible().init(context);
@@ -195,6 +198,58 @@ public static synchronized void init(Context context) {
         }
     }
 
+    /**
+     * In some cases, Context.getFilesDir() is not available when the app launches the first time.
+     * This should never happen according to the official Android documentation, but the race condition wasn't fixed
+     * until Android 4.4.
+     * <p>
+     * This method attempts to fix that situation. If this doesn't work an {@link IllegalStateException} will be
+     * thrown.
+     * <p>
+     * See these links for further details:
+     * https://issuetracker.google.com/issues/36918154
+     * https://github.com/realm/realm-java/issues/4493#issuecomment-295349044
+     */
+    private static void checkFilesDirAvailable(Context context) {
+        File filesDir = context.getFilesDir();
+        if (filesDir != null) {
+            if (filesDir.exists()) {
+                return; // Everything is fine. Escape as soon as possible
+            } else {
+                try {
+                    // This was reported as working on some devices, which I really hope is just the race condition
+                    // kicking in, otherwise something is seriously wrong with the permission system on those devices.
+                    // We will try it anyway, since starting a loop will be slower by many magnitudes.
+                    filesDir.mkdirs();
+                } catch (SecurityException ignored) {
+                }
+            }
+        }
+        if (filesDir == null || !filesDir.exists()) {
+            // Wait a "reasonable" amount of time before quitting.
+            // In this case we define reasonable as 200 ms (~12 dropped frames) before giving up (which most likely
+            // will result in the app crashing). This lag would only be seen in worst case scenarios, and then, only
+            // when the app is started the first time.
+            long[] timeoutsMs = new long[]{1, 2, 5, 10, 16}; // Exponential waits, capped at 16 ms;
+            long maxTotalWaitMs = 200;
+            long currentTotalWaitMs = 0;
+            int waitIndex = -1;
+            while (context.getFilesDir() == null || !context.getFilesDir().exists()) {
+                long waitMs = timeoutsMs[Math.min(++waitIndex, timeoutsMs.length - 1)];
+                SystemClock.sleep(waitMs);
+                currentTotalWaitMs += waitMs;
+                if (currentTotalWaitMs > maxTotalWaitMs) {
+                    break;
+                }
+            }
+        }
+
+        // One final check before giving up
+        if (context.getFilesDir() == null || !context.getFilesDir().exists()) {
+            throw new IllegalStateException("Context.getFilesDir() returns " + context.getFilesDir() + " which is not an existing directory. See https://issuetracker.google.com/issues/36918154");
+        }
+    }
+
     /**
      * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
      * by {@link #setDefaultConfiguration(RealmConfiguration)}
@@ -294,7 +349,7 @@ private static Realm createAndValidate(RealmConfiguration configuration, ColumnI
 
         if (columnIndices != null) {
             // Copies global cache as a Realm local indices cache.
-            realm.schema.columnIndices = columnIndices.clone();
+            realm.schema.setInitialColumnIndices(columnIndices);
         } else {
             final boolean syncingConfig = configuration.isSyncConfiguration();
 
@@ -338,29 +393,34 @@ private static void initializeRealm(Realm realm) {
             boolean unversioned = currentVersion == UNVERSIONED;
             commitChanges = unversioned;
 
+            RealmConfiguration configuration = realm.getConfiguration();
+
             if (unversioned) {
-                realm.setVersion(realm.configuration.getSchemaVersion());
+                realm.setVersion(configuration.getSchemaVersion());
             }
-            final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+
+            final RealmProxyMediator mediator = configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             if (unversioned) {
                 // Create all of the tables.
                 for (Class<? extends RealmModel> modelClass : modelClasses) {
-                    mediator.createTable(modelClass, realm.sharedRealm);
+                    mediator.createRealmObjectSchema(modelClass, realm.getSchema());
                 }
             }
+
+            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Now that they have all been created, validate them.
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
-            realm.schema.columnIndices = new ColumnIndices(
-                    (unversioned) ? realm.configuration.getSchemaVersion() : currentVersion, columnInfoMap);
+            realm.getSchema().setInitialColumnIndices(
+                    (unversioned) ? configuration.getSchemaVersion() : currentVersion,
+                    columnInfoMap);
 
             if (unversioned) {
-                final Transaction transaction = realm.configuration.getInitialDataTransaction();
+                final Transaction transaction = configuration.getInitialDataTransaction();
                 if (transaction != null) {
                     transaction.execute(realm);
                 }
@@ -377,35 +437,45 @@ private static void initializeRealm(Realm realm) {
         }
     }
 
+    // Everything in this method needs to be behind a transaction lock
+    // to prevent multi-process interaction while the Realm is initialized.
     private static void initializeSyncedRealm(Realm realm) {
-        // Everything in this method needs to be behind a transaction lock to prevent multi-process interaction while
-        // the Realm is initialized.
         boolean commitChanges = false;
+        OsRealmSchema schema = null;
+        OsRealmSchema.Creator schemaCreator = null;
         try {
             realm.beginTransaction();
             long currentVersion = realm.getVersion();
-            final boolean unversioned = (currentVersion == UNVERSIONED);
+            final boolean unversioned = currentVersion == UNVERSIONED;
 
-            final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+            RealmConfiguration configuration = realm.getConfiguration();
+
+            final RealmProxyMediator mediator = configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
-            final ArrayList<RealmObjectSchema> realmObjectSchemas = new ArrayList<>();
-            final RealmSchema realmSchemaCache = new RealmSchema();
+            schemaCreator = new OsRealmSchema.Creator();
             for (Class<? extends RealmModel> modelClass : modelClasses) {
-                RealmObjectSchema realmObjectSchema = mediator.createRealmObjectSchema(modelClass, realmSchemaCache);
-                realmObjectSchemas.add(realmObjectSchema);
+                mediator.createRealmObjectSchema(modelClass, schemaCreator);
             }
 
             // Assumption: When SyncConfiguration then additive schema update mode.
-            final RealmSchema schema = new RealmSchema(realmObjectSchemas);
-            long newVersion = realm.configuration.getSchemaVersion();
-            if (realm.sharedRealm.requiresMigration(schema)) {
+            schema = new OsRealmSchema(schemaCreator);
+            schemaCreator.close();
+            schemaCreator = null;
+
+            long newVersion = configuration.getSchemaVersion();
+            // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
+            // It absolutely breaks encapsulation and needs to be fixed!
+            long schemaNativePointer = schema.getNativePtr();
+            if (realm.sharedRealm.requiresMigration(schemaNativePointer)) {
                 if (currentVersion >= newVersion) {
-                    throw new IllegalArgumentException(String.format("The schema was changed but the schema version " +
-                            "was not updated. The configured schema version (%d) must be higher than the one in the Realm " +
-                            "file (%d) in order to update the schema.", newVersion, currentVersion));
+                    throw new IllegalArgumentException(String.format(
+                            "The schema was changed but the schema version was not updated. " +
+                                    "The configured schema version (%d) must be greater than the version " +
+                                    " in the Realm file (%d) in order to update the schema.",
+                            newVersion, currentVersion));
                 }
-                realm.sharedRealm.updateSchema(schema, newVersion);
+                realm.sharedRealm.updateSchema(schemaNativePointer, newVersion);
                 // The OS currently does not handle setting the schema version. We have to do it manually.
                 realm.setVersion(newVersion);
                 commitChanges = true;
@@ -416,18 +486,27 @@ private static void initializeSyncedRealm(Realm realm) {
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
-            realm.schema.columnIndices = new ColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
+            realm.getSchema().setInitialColumnIndices(
+                    (unversioned) ? newVersion : currentVersion,
+                    columnInfoMap);
 
             if (unversioned) {
-                final Transaction transaction = realm.configuration.getInitialDataTransaction();
+                final Transaction transaction = configuration.getInitialDataTransaction();
                 if (transaction != null) {
                     transaction.execute(realm);
                 }
             }
-        } catch (Exception e) {
+        } catch (RuntimeException e) {
             commitChanges = false;
             throw e;
         } finally {
+            if (schemaCreator != null) {
+                schemaCreator.close();
+            }
+
+            if (schema != null) {
+                schema.close();
+            }
             if (commitChanges) {
                 realm.commitTransaction();
             } else {
@@ -613,11 +692,11 @@ private static void initializeSyncedRealm(Realm realm) {
      * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) {
         createOrUpdateAllFromJsonAndReturn(clazz, in);
     }
 
-    public <E extends RealmModel> List<E> createOrUpdateAllFromJsonAndReturn(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> List<E> createOrUpdateAllFromJsonAndReturn(Class<E> clazz, InputStream in) {
         if (clazz == null || in == null) {
             return null;
         }
@@ -829,7 +908,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * @see #createObjectFromJson(Class, java.io.InputStream)
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) {
         if (clazz == null || in == null) {
             return null;
         }
@@ -994,10 +1073,10 @@ private Scanner getFullStringScanner(InputStream in) {
      */
     public <E extends RealmModel> List<E> copyToRealm(Iterable<E> objects) {
         if (objects == null) {
-            return new ArrayList<E>();
+            return new ArrayList<>();
         }
-        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
-        ArrayList<E> realmObjects = new ArrayList<E>();
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
+        ArrayList<E> realmObjects = new ArrayList<>();
         for (E object : objects) {
             checkNotNullObject(object);
             realmObjects.add(copyOrUpdate(object, false, cache));
@@ -1070,7 +1149,7 @@ public void insert(RealmModel object) {
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
-        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>();
+        Map<RealmModel, Long> cache = new HashMap<>();
         configuration.getSchemaMediator().insert(this, object, cache);
     }
 
@@ -1140,7 +1219,7 @@ public void insertOrUpdate(RealmModel object) {
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
-        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>();
+        Map<RealmModel, Long> cache = new HashMap<>();
         configuration.getSchemaMediator().insertOrUpdate(this, object, cache);
     }
 
@@ -1159,11 +1238,11 @@ public void insertOrUpdate(RealmModel object) {
      */
     public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
         if (objects == null) {
-            return new ArrayList<E>(0);
+            return new ArrayList<>(0);
         }
 
-        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
-        ArrayList<E> realmObjects = new ArrayList<E>();
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
+        ArrayList<E> realmObjects = new ArrayList<>();
         for (E object : objects) {
             checkNotNullObject(object);
             realmObjects.add(copyOrUpdate(object, true, cache));
@@ -1217,11 +1296,11 @@ public void insertOrUpdate(RealmModel object) {
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
         checkMaxDepth(maxDepth);
         if (realmObjects == null) {
-            return new ArrayList<E>(0);
+            return new ArrayList<>(0);
         }
 
-        ArrayList<E> unmanagedObjects = new ArrayList<E>();
-        Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>();
+        ArrayList<E> unmanagedObjects = new ArrayList<>();
+        Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
             unmanagedObjects.add(createDetachedCopy(object, maxDepth, listCache));
@@ -1673,7 +1752,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
      */
     ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
         final long currentSchemaVersion = sharedRealm.getSchemaVersion();
-        final long cacheSchemaVersion = schema.columnIndices.getSchemaVersion();
+        final long cacheSchemaVersion = schema.getSchemaVersion();
         if (currentSchemaVersion == cacheSchemaVersion) {
             return null;
         }
@@ -1686,7 +1765,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
             // Not found in global cache. create it.
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
             final Map<Class<? extends RealmModel>, ColumnInfo> map;
-            map = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            map = new HashMap<>(modelClasses.size());
             try {
                 for (Class<? extends RealmModel> clazz : modelClasses) {
                     final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
@@ -1698,7 +1777,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
 
             cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
         }
-        schema.columnIndices.copyFrom(cacheForCurrentVersion, mediator);
+        schema.updateColumnIndices(cacheForCurrentVersion, mediator);
         return createdGlobalCache;
     }
 
@@ -1775,7 +1854,7 @@ public static int getLocalInstanceCount(RealmConfiguration configuration) {
         class Callback {
             public void onSuccess() {}
 
-            public void onError(Exception e) {}
+            public void onError(Exception ignore) {}
         }
 
         /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index ae372e6f37..b4cab8a8ec 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -51,9 +51,9 @@
 
     private static class RefAndCount {
         // The Realm instance in this thread.
-        private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<BaseRealm>();
+        private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<>();
         // How many references to this Realm instance in this thread.
-        private final ThreadLocal<Integer> localCount = new ThreadLocal<Integer>();
+        private final ThreadLocal<Integer> localCount = new ThreadLocal<>();
         // How many threads have instances refer to this configuration.
         private int globalCount = 0;
     }
@@ -85,14 +85,14 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
 
     // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
     // are not allowed and an exception will be thrown when trying to add it to the cache map.
-    private static Map<String, RealmCache> cachesMap = new HashMap<String, RealmCache>();
+    private static final Map<String, RealmCache> cachesMap = new HashMap<>();
 
     private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
     private static final String WRONG_REALM_CLASS_MESSAGE = "The type of Realm class must be Realm or DynamicRealm.";
 
     private RealmCache(RealmConfiguration config) {
         configuration = config;
-        refAndCountMap = new EnumMap<RealmCacheType, RefAndCount>(RealmCacheType.class);
+        refAndCountMap = new EnumMap<>(RealmCacheType.class);
         for (RealmCacheType type : RealmCacheType.values()) {
             refAndCountMap.put(type, new RefAndCount());
         }
@@ -164,7 +164,7 @@ private RealmCache(RealmConfiguration config) {
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
                 final BaseRealm realm = refAndCount.localRealm.get();
                 // Stores a copy of local ColumnIndices as a global cache.
-                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.columnIndices.clone());
+                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.cloneColumnIndices());
             }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 549908bb4f..ec33d39900 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -74,7 +74,7 @@
     public RealmList() {
         collection = null;
         view = null;
-        unmanagedList = new ArrayList<E>();
+        unmanagedList = new ArrayList<>();
     }
 
     /**
@@ -92,7 +92,7 @@ public RealmList(E... objects) {
         }
         collection = null;
         view = null;
-        unmanagedList = new ArrayList<E>(objects.length);
+        unmanagedList = new ArrayList<>(objects.length);
         Collections.addAll(unmanagedList, objects);
     }
 
@@ -246,7 +246,7 @@ private E copyToRealmIfNeeded(E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
 
             if (proxy instanceof DynamicRealmObject) {
-                String listClassName = RealmSchema.getSchemaForTable(view.getTargetTable());
+                String listClassName = StandardRealmSchema.getSchemaForTable(view.getTargetTable());
                 if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
                     String objectClassName = ((DynamicRealmObject) object).getType();
                     if (listClassName.equals(objectClassName)) {
@@ -813,11 +813,13 @@ private void checkValidView() {
         }
         checkValidView();
         if (className != null) {
-            return new OrderedRealmCollectionSnapshot<E>(realm,
+            return new OrderedRealmCollectionSnapshot<>(
+                    realm,
                     new io.realm.internal.Collection(realm.sharedRealm, view, null),
                     className);
         } else {
-            return new OrderedRealmCollectionSnapshot<E>(realm,
+            return new OrderedRealmCollectionSnapshot<>(
+                    realm,
                     new io.realm.internal.Collection(realm.sharedRealm, view, null),
                     clazz);
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index e76a0e2746..74025c2544 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -313,12 +313,28 @@ public final boolean load() {
     }
 
     /**
-     * Adds a change listener to this RealmObject.
+     * Adds a change listener to this RealmObject to get detailed information about changes. The listener will be
+     * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
+     * changed.
+     *
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
+     */
+    public final <E extends RealmModel> void addChangeListener(RealmObjectChangeListener<E> listener) {
+        //noinspection unchecked
+        RealmObject.addChangeListener((E) this, listener);
+    }
+
+    /**
+     * Adds a change listener to this RealmObject that will be triggered if any value field or referenced RealmObject
+     * field is changed, or the RealmList field itself is changed.
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
-     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
     public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
         //noinspection unchecked
@@ -326,15 +342,18 @@ public final boolean load() {
     }
 
     /**
-     * Adds a change listener to a RealmObject.
+     * Adds a change listener to a RealmObject to get detailed information about the changes. The listener will be
+     * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
+     * changed.
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
-     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
-     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalArgumentException if the {@code object} is {@code null} or an unmanaged object, or the change
+     * listener is {@code null}.
      * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
-    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
+    public static <E extends RealmModel> void addChangeListener(E object, RealmObjectChangeListener<E> listener) {
         if (object == null) {
             throw new IllegalArgumentException("Object should not be null");
         }
@@ -353,6 +372,32 @@ public final boolean load() {
         }
     }
 
+    /**
+     * Adds a change listener to a RealmObject that will be triggered if any value field or referenced RealmObject field
+     * is changed, or the RealmList field itself is changed.
+     *
+     * @param object RealmObject to add listener to.
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the {@code object} is {@code null} or an unmanaged object, or the change
+     * listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
+     */
+    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
+        addChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+    }
+
+    /**
+     * Removes a previously registered listener.
+     *
+     * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     */
+    public final void removeChangeListener(RealmObjectChangeListener listener) {
+        RealmObject.removeChangeListener(this, listener);
+    }
+
     /**
      * Removes a previously registered listener.
      *
@@ -373,7 +418,7 @@ public final void removeChangeListener(RealmChangeListener listener) {
      * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
-    public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener listener) {
+    public static <E extends RealmModel> void removeChangeListener(E object, RealmObjectChangeListener listener) {
         if (object == null) {
             throw new IllegalArgumentException("Object should not be null");
         }
@@ -392,6 +437,19 @@ public final void removeChangeListener(RealmChangeListener listener) {
         }
     }
 
+    /**
+     * Removes a previously registered listener on the given RealmObject.
+     *
+     * @param object RealmObject to remove listener from.
+     * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     */
+    public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener<E> listener) {
+        removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+    }
+
     /**
      * Removes all registered listeners.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
new file mode 100644
index 0000000000..af172a0e16
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.LinkingObjects;
+
+/**
+ * {@code RealmObjectChangeListener} can be registered on a {@link RealmModel} or {@link RealmObject} to receive
+ * detailed notifications when an object changes.
+ * <p>
+ * Realm instances on a thread without an {@link android.os.Looper} cannot register a {@code RealmObjectChangeListener}.
+ * <p>
+ * Listener cannot be registered inside a transaction.
+ *
+ * @param <T> The type of {@link RealmModel} on which your listener will be registered.
+ * @see Realm#addChangeListener(RealmChangeListener)
+ * @see Realm#removeAllChangeListeners()
+ * @see Realm#removeChangeListener(RealmChangeListener)
+ */
+public interface RealmObjectChangeListener<T extends RealmModel> {
+
+    /**
+     * When this gets called to return the results of an asynchronous query made by {@link RealmQuery#findFirstAsync()},
+     * {@code changeSet} will be {@code null}.
+     * <p>
+     * When this gets called because the object was deleted, {@code changeSet.isDeleted()} will return {@code true}
+     * and {@code changeSet.getFieldChanges()} will return {@code null}.
+     * <p>
+     * When this gets called because the object was modified, {@code changeSet.isDeleted()} will return {@code false}
+     * and {@code changeSet.getFieldChanges()} will return the detailed information about the fields' changes.
+     * <p>
+     * If a field points to another RealmObject this listener will only be triggered if the field is set to a new object
+     * or null. Updating the referenced RealmObject will not trigger this listener.
+     * <p>
+     * If a field points to a RealmList, this listener will only be triggered if one or multiple objects are inserted,
+     * removed or moved within the List. Updating the objects in the RealmList will not trigger this listener.
+     * <p>
+     * Changes to {@link LinkingObjects} annotated {@link RealmResults} fields will not be monitored, nor reported
+     * through this change listener.
+     * @param object the {@code RealmObject} this listener is registered to.
+     * @param changeSet the detailed information about the changes.
+     */
+    void onChange(T object, ObjectChangeSet changeSet);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index fd71b473d3..bed6061e1f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -1,5 +1,6 @@
+package io.realm;
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +15,7 @@
  * limitations under the License.
  */
 
-package io.realm;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
 import java.util.Set;
 
 import io.realm.annotations.Required;
@@ -34,97 +28,12 @@
  *
  * @see io.realm.RealmMigration
  */
-public class RealmObjectSchema {
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
-
-    static {
-        SUPPORTED_SIMPLE_FIELDS = new HashMap<Class<?>, FieldMetaData>();
-        SUPPORTED_SIMPLE_FIELDS.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
-        SUPPORTED_SIMPLE_FIELDS.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
-        SUPPORTED_SIMPLE_FIELDS.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
-        SUPPORTED_SIMPLE_FIELDS.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
-        SUPPORTED_SIMPLE_FIELDS.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
-        SUPPORTED_SIMPLE_FIELDS.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
-    }
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
-
-    static {
-        SUPPORTED_LINKED_FIELDS = new HashMap<Class<?>, FieldMetaData>();
-        SUPPORTED_LINKED_FIELDS.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
-        SUPPORTED_LINKED_FIELDS.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
-    }
-
-    private final BaseRealm realm;
-    final Table table;
-    private final Map<String, Long> columnIndices;
-    private final long nativePtr;
+public abstract class RealmObjectSchema {
 
     /**
-     * Creates a schema object for a given Realm class.
-     *
-     * @param realm Realm holding the objects.
-     * @param table table representation of the Realm class
-     * @param columnIndices mapping between field names and column indexes for the given table
+     * Release the object schema and any of native resources it might hold.
      */
-    RealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
-        this.realm = realm;
-        this.table = table;
-        this.columnIndices = columnIndices;
-        this.nativePtr = 0;
-    }
-
-    /**
-     * Creates a schema object using object store. This constructor is intended to be used by
-     * the validation of schema, object schemas and prorperties through the object store. Even though the constructor
-     * is public, there is never a purpose which justifies calling it!
-     *
-     * @param className name of the class
-     */
-    RealmObjectSchema(String className) {
-        this.realm = null;
-        this.table = null;
-        this.columnIndices = null;
-        this.nativePtr = nativeCreateRealmObjectSchema(className);
-    }
-
-    protected RealmObjectSchema(long nativePtr) {
-        this.realm = null;
-        this.table = null;
-        this.columnIndices = null;
-        this.nativePtr = nativePtr;
-    }
-
-    /**
-     * Closes/frees native resource. Even though the method is public, there is never a purpose which justifies calling
-     * it!
-     */
-    public void close() {
-        if (nativePtr != 0) {
-            Set<Property> properties = getProperties();
-            for (Property property : properties) {
-                property.close();
-            }
-            nativeClose(nativePtr);
-        }
-    }
-
-
-    protected long getNativePtr() {
-        return nativePtr;
-    }
+    public abstract void close();
 
     /**
      * Returns the name of the RealmObject class being represented by this schema.
@@ -136,53 +45,17 @@ protected long getNativePtr() {
      *
      * @return the name of the RealmObject class represented by this schema.
      */
-    public String getClassName() {
-        if (realm == null) {
-            return nativeGetClassName(nativePtr);
-        } else {
-            return table.getName().substring(Table.TABLE_PREFIX.length());
-        }
-    }
+    public abstract String getClassName();
 
     /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
-     * {@link RealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
      *
      * @param className the new name for this class.
      * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
      * characters.
-     * @see RealmSchema#rename(String, String)
+     * @see StandardRealmSchema#rename(String, String)
      */
-    public RealmObjectSchema setClassName(String className) {
-        realm.checkNotInSync(); // renaming a table is not permitted
-        checkEmpty(className);
-        String internalTableName = Table.TABLE_PREFIX + className;
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
-        }
-        if (realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
-        }
-        // in case this table has a primary key, we need to transfer it after renaming the table.
-        String oldTableName = null;
-        String pkField = null;
-        if (table.hasPrimaryKey()) {
-            oldTableName = table.getName();
-            pkField = getPrimaryKey();
-            table.setPrimaryKey(null);
-        }
-        realm.sharedRealm.renameTable(table.getName(), internalTableName);
-        if (pkField != null && !pkField.isEmpty()) {
-            try {
-                table.setPrimaryKey(pkField);
-            } catch (Exception e) {
-                // revert the table name back when something goes wrong
-                realm.sharedRealm.renameTable(table.getName(), oldTableName);
-                throw e;
-            }
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema setClassName(String className);
 
     /**
      * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
@@ -200,33 +73,7 @@ public RealmObjectSchema setClassName(String className) {
      * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
      * already exists.
      */
-    public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
-        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
-        if (metadata == null) {
-            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
-                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
-            } else {
-                throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
-                        fieldName, fieldType));
-            }
-        }
-
-        checkNewFieldName(fieldName);
-        boolean nullable = metadata.defaultNullable;
-        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
-            nullable = false;
-        }
-
-        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
-        try {
-            addModifiers(fieldName, attributes);
-        } catch (Exception e) {
-            // Modifiers have been removed by the addModifiers method()
-            table.removeColumn(columnIndex);
-            throw e;
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);
 
     /**
      * Adds a new field that references another {@link RealmObject}.
@@ -236,12 +83,7 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
      * @return the updated schema.
      * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
      */
-    public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
-        return this;
-    }
+    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);
 
     /**
      * Adds a new field that references a {@link RealmList}.
@@ -251,40 +93,7 @@ public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
      */
-    public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
-        return this;
-    }
-
-    /**
-     * Adds a property to an object schema. This method should only be used by proxy classes to set up a schema.
-     *
-     * @param property the property to add.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the method is called after opening a Realm.
-     */
-    protected RealmObjectSchema add(Property property) {
-        if (realm != null && nativePtr == 0) {
-            throw new IllegalArgumentException("Don't use this method.");
-        }
-        nativeAddProperty(nativePtr, property.getNativePtr());
-        return this;
-    }
-
-    private Set<Property> getProperties() {
-        if (realm == null) {
-            long[] ptrs = nativeGetProperties(nativePtr);
-            Set<Property> properties = new LinkedHashSet<Property>(ptrs.length);
-            for (int i = 0; i < ptrs.length; i++) {
-                properties.add(new Property(ptrs[i]));
-            }
-            return properties;
-        } else {
-            throw new IllegalArgumentException("Not possible");
-        }
-    }
+    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);
 
     /**
      * Removes a field from the class.
@@ -293,19 +102,7 @@ protected RealmObjectSchema add(Property property) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist.
      */
-    public RealmObjectSchema removeField(String fieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(fieldName);
-        if (!hasField(fieldName)) {
-            throw new IllegalStateException(fieldName + " does not exist.");
-        }
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.getPrimaryKey() == columnIndex) {
-            table.setPrimaryKey(null);
-        }
-        table.removeColumn(columnIndex);
-        return this;
-    }
+    public abstract RealmObjectSchema removeField(String fieldName);
 
     /**
      * Renames a field from one name to another.
@@ -315,19 +112,7 @@ public RealmObjectSchema removeField(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
      */
-    public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(currentFieldName);
-        checkFieldExists(currentFieldName);
-        checkLegalName(newFieldName);
-        checkFieldNameIsAvailable(newFieldName);
-        long columnIndex = getColumnIndex(currentFieldName);
-        table.renameColumn(columnIndex, newFieldName);
-
-        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
-
-        return this;
-    }
+    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);
 
     /**
      * Tests if the class has field defined with the given name.
@@ -335,9 +120,7 @@ public RealmObjectSchema renameField(String currentFieldName, String newFieldNam
      * @param fieldName field name to test.
      * @return {@code true} if the field exists, {@code false} otherwise.
      */
-    public boolean hasField(String fieldName) {
-        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
-    }
+    public abstract boolean hasField(String fieldName);
 
     /**
      * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
@@ -348,16 +131,7 @@ public boolean hasField(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
      * index defined.
      */
-    public RealmObjectSchema addIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException(fieldName + " already has an index.");
-        }
-        table.addSearchIndex(columnIndex);
-        return this;
-    }
+    public abstract RealmObjectSchema addIndex(String fieldName);
 
     /**
      * Checks if a given field has an index defined.
@@ -367,12 +141,7 @@ public RealmObjectSchema addIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see io.realm.annotations.Index
      */
-    public boolean hasIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        return table.hasSearchIndex(table.getColumnIndex(fieldName));
-    }
-
+    public abstract boolean hasIndex(String fieldName);
 
     /**
      * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
@@ -381,17 +150,7 @@ public boolean hasIndex(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
      */
-    public RealmObjectSchema removeIndex(String fieldName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException("Field is not indexed: " + fieldName);
-        }
-        table.removeSearchIndex(columnIndex);
-        return this;
-    }
+    public abstract RealmObjectSchema removeIndex(String fieldName);
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
@@ -403,20 +162,7 @@ public RealmObjectSchema removeIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
      * has a primary key defined.
      */
-    public RealmObjectSchema addPrimaryKey(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        if (table.hasPrimaryKey()) {
-            throw new IllegalStateException("A primary key is already defined");
-        }
-        table.setPrimaryKey(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            // No exception will be thrown since adding PrimaryKey implies the column has an index.
-            table.addSearchIndex(columnIndex);
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema addPrimaryKey(String fieldName);
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
@@ -426,18 +172,7 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
      */
-    public RealmObjectSchema removePrimaryKey() {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        long columnIndex = table.getPrimaryKey();
-        if (table.hasSearchIndex(columnIndex)) {
-            table.removeSearchIndex(columnIndex);
-        }
-        table.setPrimaryKey("");
-        return this;
-    }
+    public abstract RealmObjectSchema removePrimaryKey();
 
     /**
      * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
@@ -450,31 +185,7 @@ public RealmObjectSchema removePrimaryKey() {
      * the field already have been set as required.
      * @see Required
      */
-    public RealmObjectSchema setRequired(String fieldName, boolean required) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        boolean currentColumnRequired = isRequired(fieldName);
-        RealmFieldType type = table.getColumnType(columnIndex);
-
-        if (type == RealmFieldType.OBJECT) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
-        }
-        if (type == RealmFieldType.LIST) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
-        }
-        if (required && currentColumnRequired) {
-            throw new IllegalStateException("Field is already required: " + fieldName);
-        }
-        if (!required && !currentColumnRequired) {
-            throw new IllegalStateException("Field is already nullable: " + fieldName);
-        }
-
-        if (required) {
-            table.convertColumnToNotNullable(columnIndex);
-        } else {
-            table.convertColumnToNullable(columnIndex);
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);
 
     /**
      * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
@@ -485,10 +196,7 @@ public RealmObjectSchema setRequired(String fieldName, boolean required) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
      */
-    public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
-        setRequired(fieldName, !nullable);
-        return this;
-    }
+    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);
 
     /**
      * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
@@ -498,10 +206,7 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setRequired(String, boolean)
      */
-    public boolean isRequired(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return !table.isColumnNullable(columnIndex);
-    }
+    public abstract boolean isRequired(String fieldName);
 
     /**
      * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
@@ -511,10 +216,7 @@ public boolean isRequired(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setNullable(String, boolean)
      */
-    public boolean isNullable(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.isColumnNullable(columnIndex);
-    }
+    public abstract boolean isNullable(String fieldName);
 
     /**
      * Checks if a given field is the primary key field.
@@ -524,10 +226,7 @@ public boolean isNullable(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #addPrimaryKey(String)
      */
-    public boolean isPrimaryKey(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return columnIndex == table.getPrimaryKey();
-    }
+    public abstract boolean isPrimaryKey(String fieldName);
 
     /**
      * Checks if the class has a primary key defined.
@@ -535,9 +234,7 @@ public boolean isPrimaryKey(String fieldName) {
      * @return {@code true} if a primary key is defined, {@code false} otherwise.
      * @see io.realm.annotations.PrimaryKey
      */
-    public boolean hasPrimaryKey() {
-        return table.hasPrimaryKey();
-    }
+    public abstract boolean hasPrimaryKey();
 
     /**
      * Returns the name of the primary key field.
@@ -545,26 +242,14 @@ public boolean hasPrimaryKey() {
      * @return the name of the primary key field.
      * @throws IllegalStateException if the class doesn't have a primary key defined.
      */
-    public String getPrimaryKey() {
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        return table.getColumnName(table.getPrimaryKey());
-    }
+    public abstract String getPrimaryKey();
 
     /**
      * Returns all fields in this class.
      *
      * @return a list of all the fields in this class.
      */
-    public Set<String> getFieldNames() {
-        int columnCount = (int) table.getColumnCount();
-        Set<String> columnNames = new LinkedHashSet<String>(columnCount);
-        for (int i = 0; i < columnCount; i++) {
-            columnNames.add(table.getColumnName(i));
-        }
-        return columnNames;
-    }
+    public abstract Set<String> getFieldNames();
 
     /**
      * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
@@ -572,204 +257,20 @@ public String getPrimaryKey() {
      *
      * @return this schema.
      */
-    public RealmObjectSchema transform(Function function) {
-        if (function != null) {
-            long size = table.size();
-            for (long i = 0; i < size; i++) {
-                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
-            }
-        }
-
-        return this;
-    }
-
-    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
-    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
-        boolean indexAdded = false;
-        try {
-            if (attributes != null && attributes.length > 0) {
-                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
-                }
-
-                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
-                    addPrimaryKey(fieldName);
-                    indexAdded = true;
-                }
-
-                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
-            }
-        } catch (Exception e) {
-            // If something went wrong, revert all attributes.
-            long columnIndex = getColumnIndex(fieldName);
-            if (indexAdded) {
-                table.removeSearchIndex(columnIndex);
-            }
-            throw (RuntimeException) e;
-        }
-    }
-
-    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
-        if (attributeList == null || attributeList.length == 0) {
-            return false;
-        }
-        for (int i = 0; i < attributeList.length; i++) {
-            if (attributeList[i] == attribute) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void checkNewFieldName(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-    }
-
-    private void checkLegalName(String fieldName) {
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Field name can not be null or empty");
-        }
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Field name can not contain '.'");
-        }
-    }
-
-    private void checkFieldNameIsAvailable(String fieldName) {
-        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private void checkFieldExists(String fieldName) {
-        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private long getColumnIndex(String fieldName) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex == -1) {
-            throw new IllegalArgumentException(
-                    String.format("Field name '%s' does not exist on schema for '%s",
-                            fieldName, getClassName()
-                    ));
-        }
-        return columnIndex;
-    }
-
-    private void checkEmpty(String str) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException("Null or empty class names are not allowed");
-        }
-    }
+    public abstract RealmObjectSchema transform(Function function);
 
     /**
-     * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned.
+     * Returns the type used by the underlying storage engine to represent this field.
      *
-     * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes valid field type for the last field in a linked field
-     * @return list of column indices.
+     * @return the underlying type used by Realm to represent this field.
      */
-    // TODO: consider another caching strategy so linked classes are included in the cache.
-    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        if (fieldDescription == null || fieldDescription.equals("")) {
-            throw new IllegalArgumentException("Non-empty fieldname must be provided");
-        }
-        if (fieldDescription.startsWith(".") || fieldDescription.endsWith(".")) {
-            throw new IllegalArgumentException("Illegal field name. It cannot start or end with a '.': " + fieldDescription);
-        }
-        Table table = this.table;
-        boolean checkColumnType = validColumnTypes != null && validColumnTypes.length > 0;
-        if (fieldDescription.contains(".")) {
-            // Resolves field description down to last field name.
-            String[] names = fieldDescription.split("\\.");
-            long[] columnIndices = new long[names.length];
-            for (int i = 0; i < names.length - 1; i++) {
-                long index = table.getColumnIndex(names[i]);
-                if (index < 0) {
-                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
-                }
-                RealmFieldType type = table.getColumnType(index);
-                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
-                    table = table.getLinkTarget(index);
-                    columnIndices[i] = index;
-                } else {
-                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
-                }
-            }
-
-            // Checks if last field name is a valid field.
-            String columnName = names[names.length - 1];
-            long columnIndex = table.getColumnIndex(columnName);
-            columnIndices[names.length - 1] = columnIndex;
-            if (columnIndex < 0) {
-                throw new IllegalArgumentException(columnName + " is not a field name in class " + table.getName());
-            }
-            if (checkColumnType && !isValidType(table.getColumnType(columnIndex), validColumnTypes)) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch.", names[names.length - 1]));
-            }
-            return columnIndices;
-        } else {
-            Long fieldIndex = getFieldIndex(fieldDescription);
-            if (fieldIndex == null) {
-                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
-            }
-            RealmFieldType tableColumnType = table.getColumnType(fieldIndex);
-            if (checkColumnType && !isValidType(tableColumnType, validColumnTypes)) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch. Was %s, expected %s.",
-                        fieldDescription, tableColumnType, Arrays.toString(validColumnTypes)));
-            }
-            return new long[] {fieldIndex};
-        }
-    }
+    public abstract RealmFieldType getFieldType(String fieldName);
 
-    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
-        for (int i = 0; i < validColumnTypes.length; i++) {
-            if (validColumnTypes[i] == columnType) {
-                return true;
-            }
-        }
-        return false;
-    }
+    abstract long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes);
 
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index or null if it doesn't exists.
-     */
-    Long getFieldIndex(String fieldName) {
-        return columnIndices.get(fieldName);
-    }
+    abstract RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required);
 
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index.
-     * @throws IllegalArgumentException if the field does not exists.
-     */
-    long getAndCheckFieldIndex(String fieldName) {
-        Long index = columnIndices.get(fieldName);
-        if (index == null) {
-            throw new IllegalArgumentException("Field does not exist: " + fieldName);
-        }
-        return index;
-    }
-
-    /**
-     * Returns the type used by the underlying storage engine to represent this field.
-     *
-     * @return the underlying type used by Realm to represent this field.
-     */
-    public RealmFieldType getFieldType(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.getColumnType(columnIndex);
-    }
+    abstract RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo);
 
     /**
      * Function interface, used when traversing all objects of the current class and apply a function on each.
@@ -781,92 +282,16 @@ public RealmFieldType getFieldType(String fieldName) {
     }
 
     // Tuple containing data about each supported Java type.
-    private static class FieldMetaData {
-        public final RealmFieldType realmType;
-        public final boolean defaultNullable;
+    protected static class FieldMetaData {
+        protected final RealmFieldType realmType;
+        protected final boolean defaultNullable;
 
-        public FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
+        protected FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
             this.realmType = realmType;
             this.defaultNullable = defaultNullable;
         }
     }
 
-    static final class DynamicColumnMap implements Map<String, Long> {
-        private final Table table;
-
-        public DynamicColumnMap(Table table) {
-            this.table = table;
-        }
-
-        @Override
-        public Long get(Object key) {
-            long ret = table.getColumnIndex((String) key);
-            return ret < 0 ? null : ret;
-        }
-
-        @Override
-        public void clear() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean containsKey(Object key) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean containsValue(Object value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Set<Entry<String, Long>> entrySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean isEmpty() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Set<String> keySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long put(String key, Long value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public void putAll(Map<? extends String, ? extends Long> map) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long remove(Object key) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public int size() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Collection<Long> values() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    static native long nativeCreateRealmObjectSchema(String className);
-
-    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
-
-    static native long[] nativeGetProperties(long nativePtr);
-
-    static native void nativeClose(long nativePtr);
-
-    static native String nativeGetClassName(long nativePtr);
+    abstract Table getTable();
+    abstract long getAndCheckFieldIndex(String fieldName);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 38056e37c8..e9fbfdd5cb 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -51,13 +51,13 @@
  */
 public class RealmQuery<E extends RealmModel> {
 
-    private BaseRealm realm;
+    private final Table table;
+    private final BaseRealm realm;
+    private final TableQuery query;
+    private final RealmObjectSchema schema;
     private Class<E> clazz;
     private String className;
-    private Table table;
-    private RealmObjectSchema schema;
     private LinkView linkView;
-    private TableQuery query;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
     static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
@@ -71,7 +71,7 @@
      * to run it.
      */
     public static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
-        return new RealmQuery<E>(realm, clazz);
+        return new RealmQuery<>(realm, clazz);
     }
 
     /**
@@ -83,7 +83,7 @@
      * to run it.
      */
     public static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
-        return new RealmQuery<E>(realm, className);
+        return new RealmQuery<>(realm, className);
     }
 
     /**
@@ -97,7 +97,7 @@
     @SuppressWarnings("unchecked")
     public static <E extends RealmModel> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
         if (queryResults.classSpec != null) {
-            return new RealmQuery<E>(queryResults, queryResults.classSpec);
+            return new RealmQuery<>(queryResults, queryResults.classSpec);
         } else {
             return new RealmQuery(queryResults, queryResults.className);
         }
@@ -122,8 +122,8 @@
     private RealmQuery(Realm realm, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.schema.getSchemaForClass(clazz);
-        this.table = schema.table;
+        this.schema = realm.getSchema().getSchemaForClass(clazz);
+        this.table = schema.getTable();
         this.linkView = null;
         this.query = table.where();
     }
@@ -131,7 +131,7 @@ private RealmQuery(Realm realm, Class<E> clazz) {
     private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
-        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.schema = realm.getSchema().getSchemaForClass(clazz);
         this.table = queryResults.getTable();
         this.linkView = null;
         this.query = queryResults.getCollection().where();
@@ -140,8 +140,8 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
     private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.schema.getSchemaForClass(clazz);
-        this.table = schema.table;
+        this.schema = realm.getSchema().getSchemaForClass(clazz);
+        this.table = schema.getTable();
         this.linkView = linkView;
         this.query = linkView.where();
     }
@@ -149,24 +149,24 @@ private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
     private RealmQuery(BaseRealm realm, String className) {
         this.realm = realm;
         this.className = className;
-        this.schema = realm.schema.getSchemaForClass(className);
-        this.table = schema.table;
+        this.schema = realm.getSchema().getSchemaForClass(className);
+        this.table = schema.getTable();
         this.query = table.where();
     }
 
     private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String className) {
         this.realm = queryResults.realm;
         this.className = className;
-        this.schema = realm.schema.getSchemaForClass(className);
-        this.table = schema.table;
+        this.schema = realm.getSchema().getSchemaForClass(className);
+        this.table = schema.getTable();
         this.query = queryResults.getCollection().where();
     }
 
     private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
         this.realm = realm;
         this.className = className;
-        this.schema = realm.schema.getSchemaForClass(className);
-        this.table = schema.table;
+        this.schema = realm.getSchema().getSchemaForClass(className);
+        this.table = schema.getTable();
         this.linkView = linkView;
         this.query = linkView.where();
     }
@@ -185,7 +185,7 @@ public boolean isValid() {
         if (linkView != null) {
             return linkView.isAttached();
         }
-        return table != null && table.getTable().isValid();
+        return table != null && table.isValid();
     }
 
     /**
@@ -203,7 +203,7 @@ public boolean isValid() {
     public RealmQuery<E> isNull(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName);
+        long[] columnIndices = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
         this.query.isNull(columnIndices);
@@ -221,7 +221,7 @@ public boolean isValid() {
     public RealmQuery<E> isNotNull(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName);
+        long[] columnIndices = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
         this.query.isNotNull(columnIndices);
@@ -256,7 +256,7 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, String value, Case casing) {
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.equalTo(columnIndices, value, casing);
         return this;
     }
@@ -464,7 +464,7 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Date value) {
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.equalTo(columnIndices, value);
         return this;
     }
@@ -705,7 +705,7 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         if (columnIndices.length > 1 && !casing.getValue()) {
             throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
         }
@@ -936,7 +936,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.greaterThan(columnIndices, value);
         return this;
     }
@@ -952,7 +952,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.greaterThan(columnIndices, value);
         return this;
     }
@@ -968,7 +968,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.greaterThan(columnIndices, value);
         return this;
     }
@@ -984,7 +984,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1000,7 +1000,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1016,7 +1016,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1032,7 +1032,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1048,7 +1048,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1064,7 +1064,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, int value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1080,7 +1080,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, long value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1096,7 +1096,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1112,7 +1112,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1128,7 +1128,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1144,7 +1144,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1160,7 +1160,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1176,7 +1176,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1192,7 +1192,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1208,7 +1208,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1225,7 +1225,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, int from, int to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1242,7 +1242,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, long from, long to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1259,7 +1259,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, double from, double to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1276,7 +1276,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, float from, float to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1293,7 +1293,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1323,7 +1323,7 @@ public boolean isValid() {
     public RealmQuery<E> contains(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.contains(columnIndices, value, casing);
         return this;
     }
@@ -1352,7 +1352,7 @@ public boolean isValid() {
     public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.beginsWith(columnIndices, value, casing);
         return this;
     }
@@ -1381,7 +1381,7 @@ public boolean isValid() {
     public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.endsWith(columnIndices, value, casing);
         return this;
     }
@@ -1418,7 +1418,7 @@ public boolean isValid() {
     public RealmQuery<E> like(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.like(columnIndices, value, casing);
         return this;
     }
@@ -1497,7 +1497,7 @@ public boolean isValid() {
     public RealmQuery<E> isEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
         this.query.isEmpty(columnIndices);
         return this;
     }
@@ -1513,7 +1513,7 @@ public boolean isValid() {
     public RealmQuery<E> isNotEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
         this.query.isNotEmpty(columnIndices);
         return this;
     }
@@ -1522,11 +1522,13 @@ public boolean isValid() {
      * Returns a distinct set of objects of a specific class. If the result is sorted, the first
      * object will be returned in case of multiple occurrences, otherwise it is undefined which
      * object is returned.
+     * <p>
+     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
      *
      * @param fieldName the field name.
      * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
+     * to linked fields.
      */
     public RealmResults<E> distinct(String fieldName) {
         realm.checkIfValid();
@@ -1539,13 +1541,14 @@ public boolean isValid() {
      * Asynchronously returns a distinct set of objects of a specific class. If the result is
      * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
      * undefined which object is returned.
+     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
      *
      * @param fieldName the field name.
      * @return immediately a {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
      * query completes.
-     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
+     * to linked fields.
      */
     public RealmResults<E> distinctAsync(String fieldName) {
         realm.checkIfValid();
@@ -1574,7 +1577,7 @@ public boolean isValid() {
 
         fieldNames[0] = firstFieldName;
         System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table.getTable(), fieldNames);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table, fieldNames);
         return createRealmResults(query, null, distinctDescriptor, true);
     }
 
@@ -1832,7 +1835,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
-    public RealmResults<E> findAllSorted(String fieldNames[], Sort sortOrders[]) {
+    public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
 
         SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
@@ -1854,7 +1857,7 @@ private boolean isDynamicQuery() {
      * {@link RealmObject} or a child {@link RealmList}.
      * @see io.realm.RealmResults
      */
-    public RealmResults<E> findAllSortedAsync(String fieldNames[], final Sort[] sortOrders) {
+    public RealmResults<E> findAllSortedAsync(String[] fieldNames, final Sort[] sortOrders) {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
@@ -1906,24 +1909,18 @@ public E findFirst() {
         realm.checkIfValid();
 
         long tableRowIndex = getSourceRowIndexForFirstObject();
-        if (tableRowIndex >= 0) {
-            E realmObject = realm.get(clazz, className, tableRowIndex);
-            return realmObject;
-        } else {
-            return null;
-        }
+        return (tableRowIndex < 0) ? null : realm.get(clazz, className, tableRowIndex);
     }
 
     /**
-     * Similar to {@link #findFirst()} but runs asynchronously on a worker thread
-     * This method is only available from a Looper thread.
+     * Similar to {@link #findFirst()} but runs asynchronously on a worker thread. An listener should be registered to
+     * the returned {@link RealmObject} to get the notification when query completes. The registered listener will also
+     * be triggered if there are changes made to the queried {@link RealmObject}. If the {@link RealmObject} is deleted,
+     * the listener will be called one last time and then stop. The query will not be re-run.
      *
-     * @return immediately an empty {@link RealmObject}. Trying to access any field on the returned object
-     * before it is loaded will throw an {@code IllegalStateException}. Use {@link RealmObject#isLoaded()} to check if
-     * the object is fully loaded or register a listener {@link io.realm.RealmObject#addChangeListener}
-     * to be notified when the query completes. If no RealmObject was found after the query completed, the returned
-     * RealmObject will have {@link RealmObject#isLoaded()} set to {@code true} and {@link RealmObject#isValid()} set to
-     * {@code false}.
+     * @return immediately an empty {@link RealmObject} with {@code isLoaded() == false}. Trying to access any field on
+     * the returned object before it is loaded will throw an {@code IllegalStateException}.
+     * @throws IllegalStateException if this is called on a non-looper thread.
      */
     public E findFirstAsync() {
         realm.checkIfValid();
@@ -1968,9 +1965,9 @@ public E findFirstAsync() {
         RealmResults<E> results;
         Collection collection = new Collection(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
         if (isDynamicQuery()) {
-            results = new RealmResults<E>(realm, collection, className);
+            results = new RealmResults<>(realm, collection, className);
         } else {
-            results = new RealmResults<E>(realm, collection, clazz);
+            results = new RealmResults<>(realm, collection, clazz);
         }
         if (loadResults) {
             results.load();
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 631ce02530..0968433c78 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -16,16 +16,13 @@
 
 package io.realm;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
-import io.realm.internal.Util;
 
 
 /**
@@ -34,69 +31,15 @@
  * <p>
  * All changes must happen inside a write transaction for the particular Realm.
  *
- * @see io.realm.RealmMigration
+ * @see RealmMigration
  */
-public class RealmSchema {
-
-    private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
-    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
-
-    // Caches Dynamic Class objects given as Strings to Realm Tables
-    private final Map<String, Table> dynamicClassToTable = new HashMap<String, Table>();
-    // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<Class<? extends RealmModel>, Table>();
-    // Caches Class objects (both model classes and proxy classes) to their Schema object
-    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<Class<? extends RealmModel>, RealmObjectSchema>();
-    // Caches Class Strings to their Schema object
-    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
-
-    private final BaseRealm realm;
-    private long nativePtr;
-    ColumnIndices columnIndices; // Cached field look up
+public abstract class RealmSchema {
+    private ColumnIndices columnIndices; // Cached field look up
 
     /**
-     * Creates a wrapper to easily manipulate the current schema of a Realm.
+     * Release the schema and any of native resources it might hold.
      */
-    RealmSchema(BaseRealm realm) {
-        this.realm = realm;
-        this.nativePtr = 0;
-    }
-
-    /**
-     * Creates a wrappor to easily manipulate Object Store schemas. This constructor should only be called by
-     * proxy classes during validation of schema.
-     */
-    RealmSchema() {
-        // This is the case where the schema is created from the proxy classes.
-        // dynamicClassToSchema is used to keep track of which model classes have been processed.
-        this.realm = null;
-        this.nativePtr = 0;
-        // TODO: create a Object Store realm::Schema object and store the native pointer
-    }
-
-
-    RealmSchema(ArrayList<RealmObjectSchema> realmObjectSchemas) {
-        long list[] = new long[realmObjectSchemas.size()];
-        for (int i = 0; i < realmObjectSchemas.size(); i++) {
-            list[i] = realmObjectSchemas.get(i).getNativePtr();
-        }
-        this.nativePtr = nativeCreateFromList(list);
-        this.realm = null;
-    }
-
-    public long getNativePtr() {
-        return this.nativePtr;
-    }
-
-    public void close() {
-        if (nativePtr != 0) {
-            Set<RealmObjectSchema> schemas = getAll();
-            for (RealmObjectSchema schema : schemas) {
-                schema.close();
-            }
-            nativeClose(nativePtr);
-        }
-    }
+    public abstract void close();
 
     /**
      * Returns the Realm schema for a given class.
@@ -104,54 +47,14 @@ public void close() {
      * @param className name of the class
      * @return schema object for that class or {@code null} if the class doesn't exists.
      */
-    public RealmObjectSchema get(String className) {
-        checkEmpty(className, EMPTY_STRING_MSG);
-        if (realm == null) {
-            if (contains(className)) {
-                return dynamicClassToSchema.get(className);
-            } else {
-                return null;
-            }
-        } else {
-            String internalClassName = TABLE_PREFIX + className;
-            if (realm.sharedRealm.hasTable(internalClassName)) {
-                Table table = realm.sharedRealm.getTable(internalClassName);
-                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-                return new RealmObjectSchema(realm, table, columnIndices);
-            } else {
-                return null;
-            }
-        }
-    }
+    public abstract RealmObjectSchema get(String className);
 
     /**
-     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     * Returns the {@link RealmObjectSchema}s for all RealmObject classes that can be saved in this Realm.
      *
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
-    public Set<RealmObjectSchema> getAll() {
-        if (realm == null) {
-            long[] ptrs = nativeGetAll(nativePtr);
-            Set<RealmObjectSchema> schemas = new LinkedHashSet<RealmObjectSchema>(ptrs.length);
-            for (int i = 0; i < ptrs.length; i++) {
-                schemas.add(new RealmObjectSchema(ptrs[i]));
-            }
-            return schemas;
-        } else {
-            int tableCount = (int) realm.sharedRealm.size();
-            Set<RealmObjectSchema> schemas = new LinkedHashSet<RealmObjectSchema>(tableCount);
-            for (int i = 0; i < tableCount; i++) {
-                String tableName = realm.sharedRealm.getTableName(i);
-                if (!Table.isModelTable(tableName)) {
-                    continue;
-                }
-                Table table = realm.sharedRealm.getTable(tableName);
-                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-                schemas.add(new RealmObjectSchema(realm, table, columnIndices));
-            }
-            return schemas;
-        }
-    }
+    public abstract Set<RealmObjectSchema> getAll();
 
     /**
      * Adds a new class to the Realm.
@@ -159,26 +62,7 @@ public RealmObjectSchema get(String className) {
      * @param className name of the class.
      * @return a Realm schema object for that class.
      */
-    public RealmObjectSchema create(String className) {
-        // Adding a class is always permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-        if (realm == null) {
-            RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
-            dynamicClassToSchema.put(className, realmObjectSchema);
-            return realmObjectSchema;
-        } else {
-            String internalTableName = TABLE_PREFIX + className;
-            if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-                throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
-            }
-            if (realm.sharedRealm.hasTable(internalTableName)) {
-                throw new IllegalArgumentException("Class already exists: " + className);
-            }
-            Table table = realm.sharedRealm.getTable(internalTableName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            return new RealmObjectSchema(realm, table, columnIndices);
-        }
-    }
+    public abstract RealmObjectSchema create(String className);
 
     /**
      * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
@@ -186,17 +70,7 @@ public RealmObjectSchema create(String className) {
      *
      * @param className name of the class to remove.
      */
-    public void remove(String className) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = TABLE_PREFIX + className;
-        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
-        Table table = getTable(className);
-        if (table.hasPrimaryKey()) {
-            table.setPrimaryKey(null);
-        }
-        realm.sharedRealm.removeTable(internalTableName);
-    }
+    public abstract void remove(String className);
 
     /**
      * Renames a class already in the Realm.
@@ -205,36 +79,7 @@ public void remove(String className) {
      * @param newClassName new class name.
      * @return a schema object for renamed class.
      */
-    public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(oldClassName, "Class names cannot be empty or null");
-        checkEmpty(newClassName, "Class names cannot be empty or null");
-        String oldInternalName = TABLE_PREFIX + oldClassName;
-        String newInternalName = TABLE_PREFIX + newClassName;
-        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
-        if (realm.sharedRealm.hasTable(newInternalName)) {
-            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
-        }
-
-        // Checks if there is a primary key defined for the old class.
-        Table oldTable = getTable(oldClassName);
-        String pkField = null;
-        if (oldTable.hasPrimaryKey()) {
-            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
-            oldTable.setPrimaryKey(null);
-        }
-
-        realm.sharedRealm.renameTable(oldInternalName, newInternalName);
-        Table table = realm.sharedRealm.getTable(newInternalName);
-
-        // Sets the primary key for the new class if necessary.
-        if (pkField != null) {
-            table.setPrimaryKey(pkField);
-        }
-
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
-    }
+    public abstract RealmObjectSchema rename(String oldClassName, String newClassName);
 
     /**
      * Checks if a given class already exists in the schema.
@@ -242,116 +87,67 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
      * @param className class name to check.
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
-    public boolean contains(String className) {
-        if (realm == null) {
-            return dynamicClassToSchema.containsKey(className);
-        } else {
-            return realm.sharedRealm.hasTable(Table.TABLE_PREFIX + className);
-        }
-    }
-
-    private void checkEmpty(String str, String error) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException(error);
-        }
-    }
+    public abstract boolean contains(String className);
 
-    private void checkHasTable(String className, String errorMsg) {
-        String internalTableName = TABLE_PREFIX + className;
-        if (!realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException(errorMsg);
+    final void setInitialColumnIndices(ColumnIndices columnIndices) {
+        if (this.columnIndices != null) {
+            throw new IllegalStateException("An instance of ColumnIndices is already set.");
         }
+        this.columnIndices = columnIndices.clone();
     }
 
-    ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
-        final ColumnInfo columnInfo = columnIndices.getColumnInfo(clazz);
-        if (columnInfo == null) {
-            throw new IllegalStateException("No validated schema information found for " + realm.configuration.getSchemaMediator().getTableName(clazz));
+    final void setInitialColumnIndices(long version, Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap) {
+        if (this.columnIndices != null) {
+            throw new IllegalStateException("An instance of ColumnIndices is already set.");
         }
-        return columnInfo;
+        columnIndices = new ColumnIndices(version, columnInfoMap);
     }
 
-    Table getTable(String className) {
-        className = Table.TABLE_PREFIX + className;
-        Table table = dynamicClassToTable.get(className);
-        if (table == null) {
-            if (!realm.sharedRealm.hasTable(className)) {
-                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-            }
-            table = realm.sharedRealm.getTable(className);
-            dynamicClassToTable.put(className, table);
-        }
-        return table;
+    /**
+     * Updates all {@link ColumnInfo} elements in {@code columnIndices}.
+     *
+     * <p>
+     * The ColumnInfo elements are shared between all {@link RealmObject}s created by the Realm instance
+     * which owns this RealmSchema. Updating them also means updating indices information in those {@link RealmObject}s.
+     *
+     * @param schemaVersion new schema version.
+     * @param mediator mediator for the Realm.
+     */
+    void updateColumnIndices(ColumnIndices schemaVersion, RealmProxyMediator mediator) {
+        columnIndices.copyFrom(schemaVersion, mediator);
     }
 
-    Table getTable(Class<? extends RealmModel> clazz) {
-        Table table = classToTable.get(clazz);
-        if (table == null) {
-            Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-            if (isProxyClass(originalClass, clazz)) {
-                // If passed 'clazz' is the proxy, try again with model class.
-                table = classToTable.get(originalClass);
-            }
-            if (table == null) {
-                table = realm.sharedRealm.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass));
-                classToTable.put(originalClass, table);
-            }
-            if (isProxyClass(originalClass, clazz)) {
-                // 'clazz' is the proxy class for 'originalClass'.
-                classToTable.put(clazz, table);
-            }
-        }
-        return table;
+    final ColumnIndices cloneColumnIndices() {
+        checkIndices();
+        return columnIndices.clone();
     }
 
-    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        RealmObjectSchema classSchema = classToSchema.get(clazz);
-        if (classSchema == null) {
-            Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-            if (isProxyClass(originalClass, clazz)) {
-                // If passed 'clazz' is the proxy, try again with model class.
-                classSchema = classToSchema.get(originalClass);
-            }
-            if (classSchema == null) {
-                Table table = getTable(clazz);
-                classSchema = new RealmObjectSchema(realm, table, columnIndices.getColumnInfo(originalClass).getIndicesMap());
-                classToSchema.put(originalClass, classSchema);
-            }
-            if (isProxyClass(originalClass, clazz)) {
-                // 'clazz' is the proxy class for 'originalClass'.
-                classToSchema.put(clazz, classSchema);
-            }
-        }
-        return classSchema;
+    final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
+        checkIndices();
+        return columnIndices.getColumnInfo(clazz);
     }
 
-    private static boolean isProxyClass(Class<? extends RealmModel> modelClass,
-            Class<? extends RealmModel> testee) {
-        return modelClass != testee;
+    final long getSchemaVersion() {
+        checkIndices();
+        return this.columnIndices.getSchemaVersion();
     }
 
-    RealmObjectSchema getSchemaForClass(String className) {
-        className = Table.TABLE_PREFIX + className;
-        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
-        if (dynamicSchema == null) {
-            if (!realm.sharedRealm.hasTable(className)) {
-                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-            }
-            Table table = realm.sharedRealm.getTable(className);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
-            dynamicClassToSchema.put(className, dynamicSchema);
-        }
-        return dynamicSchema;
+    final boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
+        return modelClass.equals(testee);
     }
 
     static String getSchemaForTable(Table table) {
         return table.getName().substring(Table.TABLE_PREFIX.length());
     }
 
-    static native long nativeCreateFromList(long[] objectSchemaPtrs);
-
-    static native void nativeClose(long nativePtr);
+    private void checkIndices() {
+        if (this.columnIndices == null) {
+            throw new IllegalStateException("Attempt to use column index before set.");
+        }
+    }
 
-    static native long[] nativeGetAll(long nativePtr);
+    abstract Table getTable(Class<? extends RealmModel> clazz);
+    abstract Table getTable(String className);
+    abstract RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz);
+    abstract RealmObjectSchema getSchemaForClass(String className);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
new file mode 100644
index 0000000000..d46fb453ea
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
@@ -0,0 +1,829 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.annotations.Required;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Table;
+
+
+class StandardRealmObjectSchema extends RealmObjectSchema {
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
+        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
+        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
+        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
+        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
+        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
+        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
+        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
+        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
+        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
+        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
+        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    private final BaseRealm realm;
+    private final Map<String, Long> columnIndices;
+    private final Table table;
+
+    /**
+     * Creates a schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     * @param columnIndices mapping between field names and column indexes for the given table
+     */
+    StandardRealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
+        this.realm = realm;
+        this.table = table;
+        this.columnIndices = columnIndices;
+    }
+
+    @Override
+    Table getTable() {
+        return table;
+    }
+
+    /**
+     * There are no resources here that need closing.
+     */
+    @Override
+    public void close() { }
+
+    /**
+     * Returns the name of the RealmObject class being represented by this schema.
+     * <p>
+     * <ul>
+     * <li>When using a typed {@link Realm} this name is the same as the {@link RealmObject} class.</li>
+     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
+     * </ul>
+     *
+     * @return the name of the RealmObject class represented by this schema.
+     */
+    @Override
+    public String getClassName() {
+        return table.getName().substring(Table.TABLE_PREFIX.length());
+    }
+
+    /**
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
+     * {@link StandardRealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
+     *
+     * @param className the new name for this class.
+     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
+     * characters.
+     * @see StandardRealmSchema#rename(String, String)
+     */
+    @Override
+    public StandardRealmObjectSchema setClassName(String className) {
+        realm.checkNotInSync(); // renaming a table is not permitted
+        checkEmpty(className);
+        String internalTableName = Table.TABLE_PREFIX + className;
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
+        }
+        if (realm.sharedRealm.hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        // in case this table has a primary key, we need to transfer it after renaming the table.
+        String oldTableName = null;
+        String pkField = null;
+        if (table.hasPrimaryKey()) {
+            oldTableName = table.getName();
+            pkField = getPrimaryKey();
+            table.setPrimaryKey(null);
+        }
+        realm.sharedRealm.renameTable(table.getName(), internalTableName);
+        if (pkField != null && !pkField.isEmpty()) {
+            try {
+                table.setPrimaryKey(pkField);
+            } catch (Exception e) {
+                // revert the table name back when something goes wrong
+                realm.sharedRealm.renameTable(table.getName(), oldTableName);
+                throw e;
+            }
+        }
+        return this;
+    }
+
+    /**
+     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
+     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
+     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
+     * <p>
+     * To add fields that reference other RealmObjects or RealmLists use
+     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
+     * instead.
+     *
+     * @param fieldName name of the field to add.
+     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
+     * @param attributes set of attributes for this field.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
+     * already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
+        if (metadata == null) {
+            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
+                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
+            } else {
+                throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
+                        fieldName, fieldType));
+            }
+        }
+
+        checkNewFieldName(fieldName);
+        boolean nullable = metadata.defaultNullable;
+        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
+            nullable = false;
+        }
+
+        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
+        try {
+            addModifiers(fieldName, attributes);
+        } catch (Exception e) {
+            // Modifiers have been removed by the addModifiers method()
+            table.removeColumn(columnIndex);
+            throw e;
+        }
+        return this;
+    }
+
+    /**
+     * Adds a new field that references another {@link RealmObject}.
+     *
+     * @param fieldName name of the field to add.
+     * @param objectSchema schema for the Realm type being referenced.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Adds a new field that references a {@link RealmList}.
+     *
+     * @param fieldName name of the field to add.
+     * @param objectSchema schema for the Realm type being referenced.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Removes a field from the class.
+     *
+     * @param fieldName field name to remove.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     */
+    @Override
+    public StandardRealmObjectSchema removeField(String fieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(fieldName);
+        if (!hasField(fieldName)) {
+            throw new IllegalStateException(fieldName + " does not exist.");
+        }
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.getPrimaryKey() == columnIndex) {
+            table.setPrimaryKey(null);
+        }
+        table.removeColumn(columnIndex);
+        return this;
+    }
+
+    /**
+     * Renames a field from one name to another.
+     *
+     * @param currentFieldName field name to rename.
+     * @param newFieldName the new field name.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(currentFieldName);
+        checkFieldExists(currentFieldName);
+        checkLegalName(newFieldName);
+        checkFieldNameIsAvailable(newFieldName);
+        long columnIndex = getColumnIndex(currentFieldName);
+        table.renameColumn(columnIndex, newFieldName);
+
+        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
+
+        return this;
+    }
+
+    /**
+     * Tests if the class has field defined with the given name.
+     *
+     * @param fieldName field name to test.
+     * @return {@code true} if the field exists, {@code false} otherwise.
+     */
+    @Override
+    public boolean hasField(String fieldName) {
+        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
+    }
+
+    /**
+     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
+     * annotation on the field.
+     *
+     * @param fieldName field to add index to.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
+     * index defined.
+     */
+    @Override
+    public StandardRealmObjectSchema addIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException(fieldName + " already has an index.");
+        }
+        table.addSearchIndex(columnIndex);
+        return this;
+    }
+
+    /**
+     * Checks if a given field has an index defined.
+     *
+     * @param fieldName existing field name to check.
+     * @return {@code true} if field is indexed, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see io.realm.annotations.Index
+     */
+    @Override
+    public boolean hasIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        return table.hasSearchIndex(table.getColumnIndex(fieldName));
+    }
+
+
+    /**
+     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
+     *
+     * @param fieldName field to remove index from.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
+     */
+    @Override
+    public StandardRealmObjectSchema removeIndex(String fieldName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException("Field is not indexed: " + fieldName);
+        }
+        table.removeSearchIndex(columnIndex);
+        return this;
+    }
+
+    /**
+     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
+     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
+     * as well.
+     *
+     * @param fieldName field to set as primary key.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
+     * has a primary key defined.
+     */
+    @Override
+    public StandardRealmObjectSchema addPrimaryKey(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        if (table.hasPrimaryKey()) {
+            throw new IllegalStateException("A primary key is already defined");
+        }
+        table.setPrimaryKey(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
+        return this;
+    }
+
+    /**
+     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
+     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
+     * the field as well.
+     *
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
+     */
+    @Override
+    public StandardRealmObjectSchema removePrimaryKey() {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        long columnIndex = table.getPrimaryKey();
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
+        table.setPrimaryKey("");
+        return this;
+    }
+
+    /**
+     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
+     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
+     *
+     * @param fieldName name of field in the class.
+     * @param required {@code true} if field should be required, {@code false} otherwise.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
+     * the field already have been set as required.
+     * @see Required
+     */
+    @Override
+    public StandardRealmObjectSchema setRequired(String fieldName, boolean required) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        boolean currentColumnRequired = isRequired(fieldName);
+        RealmFieldType type = table.getColumnType(columnIndex);
+
+        if (type == RealmFieldType.OBJECT) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
+        }
+        if (type == RealmFieldType.LIST) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
+        }
+        if (required && currentColumnRequired) {
+            throw new IllegalStateException("Field is already required: " + fieldName);
+        }
+        if (!required && !currentColumnRequired) {
+            throw new IllegalStateException("Field is already nullable: " + fieldName);
+        }
+
+        if (required) {
+            table.convertColumnToNotNullable(columnIndex);
+        } else {
+            table.convertColumnToNullable(columnIndex);
+        }
+        return this;
+    }
+
+    /**
+     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
+     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
+     *
+     * @param fieldName name of field in the class.
+     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
+     */
+    @Override
+    public StandardRealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        setRequired(fieldName, !nullable);
+        return this;
+    }
+
+    /**
+     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is required, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #setRequired(String, boolean)
+     */
+    @Override
+    public boolean isRequired(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return !table.isColumnNullable(columnIndex);
+    }
+
+    /**
+     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is required, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #setNullable(String, boolean)
+     */
+    @Override
+    public boolean isNullable(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.isColumnNullable(columnIndex);
+    }
+
+    /**
+     * Checks if a given field is the primary key field.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is the primary key field, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #addPrimaryKey(String)
+     */
+    @Override
+    public boolean isPrimaryKey(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return columnIndex == table.getPrimaryKey();
+    }
+
+    /**
+     * Checks if the class has a primary key defined.
+     *
+     * @return {@code true} if a primary key is defined, {@code false} otherwise.
+     * @see io.realm.annotations.PrimaryKey
+     */
+    @Override
+    public boolean hasPrimaryKey() {
+        return table.hasPrimaryKey();
+    }
+
+    /**
+     * Returns the name of the primary key field.
+     *
+     * @return the name of the primary key field.
+     * @throws IllegalStateException if the class doesn't have a primary key defined.
+     */
+    @Override
+    public String getPrimaryKey() {
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        return table.getColumnName(table.getPrimaryKey());
+    }
+
+    /**
+     * Returns all fields in this class.
+     *
+     * @return a list of all the fields in this class.
+     */
+    @Override
+    public Set<String> getFieldNames() {
+        int columnCount = (int) table.getColumnCount();
+        Set<String> columnNames = new LinkedHashSet<>(columnCount);
+        for (int i = 0; i < columnCount; i++) {
+            columnNames.add(table.getColumnName(i));
+        }
+        return columnNames;
+    }
+
+    /**
+     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
+     * as a {@link DynamicRealmObject}.
+     *
+     * @return this schema.
+     */
+    @Override
+    public StandardRealmObjectSchema transform(Function function) {
+        if (function != null) {
+            long size = table.size();
+            for (long i = 0; i < size; i++) {
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
+            }
+        }
+
+        return this;
+    }
+
+    /**
+     * Returns the type used by the underlying storage engine to represent this field.
+     *
+     * @return the underlying type used by Realm to represent this field.
+     */
+    @Override
+    public RealmFieldType getFieldType(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.getColumnType(columnIndex);
+    }
+
+    @Override
+    StandardRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
+        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
+
+        if (indexed) { table.addSearchIndex(columnIndex); }
+
+        if (primary) { table.setPrimaryKey(name); }
+
+        return this;
+    }
+
+    @Override
+    StandardRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        table.addColumnLink(
+                type,
+                name,
+                realm.getSharedRealm().getTable(StandardRealmSchema.TABLE_PREFIX + linkedTo.getClassName()));
+        return this;
+    }
+
+    /**
+     * Returns the column indices for the given field name. If a linked field is defined, the column index for
+     * each field is returned.
+     *
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validColumnTypes valid field type for the last field in a linked field
+     * @return list of column indices.
+     */
+    // TODO: consider another caching strategy so linked classes are included in the cache.
+    @Override
+    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        if (fieldDescription == null || fieldDescription.equals("")) {
+            throw new IllegalArgumentException("Invalid query: field name is empty");
+        }
+        if (fieldDescription.endsWith(".")) {
+            throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
+        }
+        String[] names = fieldDescription.split("\\.");
+
+        //final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+
+        long[] columnIndices = new long[names.length];
+        Table currentTable = table;
+        RealmFieldType columnType;
+        String columnName;
+        String tableName;
+        for (int i = 0; /* loop exits in the middle */ ; i++) {
+            columnName = names[i];
+            if (columnName.length() <= 0) {
+                throw new IllegalArgumentException(String.format(
+                        "Invalid query: empty column name in field '%s'.  " +
+                                "A field name must not begin with, end with, or contain adjacent periods ('.').",
+                                fieldDescription));
+            }
+
+            tableName = getTableName(currentTable);
+            long index = currentTable.getColumnIndex(columnName);
+            if (index < 0) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: field '%s' does not exist in table '%s'.",
+                                columnName, tableName));
+            }
+            columnIndices[i] = index;
+
+            columnType = currentTable.getColumnType(index);
+
+            if (i >= names.length - 1) { break; }
+
+            if ((columnType != RealmFieldType.OBJECT) && (columnType != RealmFieldType.LIST)) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: field '%s' in table '%s' is of type '%s'.  It must be a LIST or OBJECT type.",
+                                columnName, tableName, columnType.toString()));
+            }
+
+            currentTable = currentTable.getLinkTarget(index);
+        }
+
+        if ((validColumnTypes != null) && (validColumnTypes.length > 0) && !isValidType(columnType, validColumnTypes)) {
+            throw new IllegalArgumentException(
+                    String.format("Invalid query: field '%s' in table '%s' is of invalid type '%s'.",
+                            columnName, tableName, columnType.toString()));
+        }
+
+        return columnIndices;
+    }
+
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     *
+     * @param fieldName field name to find index for.
+     * @return column index or null if it doesn't exists.
+     */
+    Long getFieldIndex(String fieldName) {
+        return columnIndices.get(fieldName);
+    }
+
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     *
+     * @param fieldName field name to find index for.
+     * @return column index.
+     * @throws IllegalArgumentException if the field does not exists.
+     */
+    @Override
+    long getAndCheckFieldIndex(String fieldName) {
+        Long index = columnIndices.get(fieldName);
+        if (index == null) {
+            throw new IllegalArgumentException("Field does not exist: " + fieldName);
+        }
+        return index;
+    }
+
+    private String getTableName(Table table) {
+        return table.getName().substring(StandardRealmSchema.TABLE_PREFIX.length());
+    }
+
+    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
+    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
+        boolean indexAdded = false;
+        try {
+            if (attributes != null && attributes.length > 0) {
+                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
+                    addIndex(fieldName);
+                    indexAdded = true;
+                }
+
+                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
+                    addPrimaryKey(fieldName);
+                    indexAdded = true;
+                }
+
+                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
+            }
+        } catch (Exception e) {
+            // If something went wrong, revert all attributes.
+            long columnIndex = getColumnIndex(fieldName);
+            if (indexAdded) {
+                table.removeSearchIndex(columnIndex);
+            }
+            throw (RuntimeException) e;
+        }
+    }
+
+    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
+        if (attributeList == null || attributeList.length == 0) {
+            return false;
+        }
+        for (int i = 0; i < attributeList.length; i++) {
+            if (attributeList[i] == attribute) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void checkNewFieldName(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+    }
+
+    private void checkLegalName(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Field name can not be null or empty");
+        }
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Field name can not contain '.'");
+        }
+    }
+
+    private void checkFieldNameIsAvailable(String fieldName) {
+        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private void checkFieldExists(String fieldName) {
+        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private long getColumnIndex(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex == -1) {
+            throw new IllegalArgumentException(
+                    String.format("Field name '%s' does not exist on schema for '%s",
+                            fieldName, getClassName()
+                    ));
+        }
+        return columnIndex;
+    }
+
+    private void checkEmpty(String str) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
+        for (int i = 0; i < validColumnTypes.length; i++) {
+            if (validColumnTypes[i] == columnType) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static final class DynamicColumnMap implements Map<String, Long> {
+        private final Table table;
+
+        DynamicColumnMap(Table table) {
+            this.table = table;
+        }
+
+        @Override
+        public Long get(Object key) {
+            long ret = table.getColumnIndex((String) key);
+            return ret < 0 ? null : ret;
+        }
+
+        @Override
+        public void clear() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsValue(Object value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Set<Entry<String, Long>> entrySet() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Set<String> keySet() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Long put(String key, Long value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void putAll(Map<? extends String, ? extends Long> map) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Long remove(Object key) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int size() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Collection<Long> values() {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
new file mode 100644
index 0000000000..bcec1169fb
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.internal.Table;
+import io.realm.internal.Util;
+
+
+/**
+ * Class for interacting with the Realm schema using a dynamic API. This makes it possible
+ * to add, delete and change the classes in the Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
+ *
+ * @see io.realm.RealmMigration
+ */
+class StandardRealmSchema extends RealmSchema {
+
+    static final String TABLE_PREFIX = Table.TABLE_PREFIX;
+    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+
+    // Caches Dynamic Class objects given as Strings to Realm Tables
+    private final Map<String, Table> dynamicClassToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to their Schema object
+    private final Map<Class<? extends RealmModel>, StandardRealmObjectSchema> classToSchema = new HashMap<>();
+    // Caches Class Strings to their Schema object
+    private final Map<String, StandardRealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+
+    private final BaseRealm realm;
+
+    /**
+     * Creates a wrapper to easily manipulate the current schema of a Realm.
+     */
+    StandardRealmSchema(BaseRealm realm) {
+        this.realm = realm;
+    }
+
+    @Override
+    public void close() { }
+
+    /**
+     * Returns the Realm schema for a given class.
+     *
+     * @param className name of the class
+     * @return schema object for that class or {@code null} if the class doesn't exists.
+     */
+    @Override
+    public RealmObjectSchema get(String className) {
+        checkEmpty(className, EMPTY_STRING_MSG);
+
+        String internalClassName = TABLE_PREFIX + className;
+        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
+
+        Table table = realm.getSharedRealm().getTable(internalClassName);
+        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+        return new StandardRealmObjectSchema(realm, table, columnIndices);
+    }
+
+    /**
+     * Returns the {@link StandardRealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     *
+     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
+     */
+    @Override
+    public Set<RealmObjectSchema> getAll() {
+        int tableCount = (int) realm.getSharedRealm().size();
+        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+        for (int i = 0; i < tableCount; i++) {
+            String tableName = realm.getSharedRealm().getTableName(i);
+            if (!Table.isModelTable(tableName)) {
+                continue;
+            }
+            Table table = realm.getSharedRealm().getTable(tableName);
+            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+            schemas.add(new StandardRealmObjectSchema(realm, table, columnIndices));
+        }
+        return schemas;
+    }
+
+    /**
+     * Adds a new class to the Realm.
+     *
+     * @param className name of the class.
+     * @return a Realm schema object for that class.
+     */
+    @Override
+    public RealmObjectSchema create(String className) {
+        // Adding a class is always permitted.
+        checkEmpty(className, EMPTY_STRING_MSG);
+
+        String internalTableName = TABLE_PREFIX + className;
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
+        }
+        if (realm.getSharedRealm().hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        Table table = realm.getSharedRealm().getTable(internalTableName);
+        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+        return new StandardRealmObjectSchema(realm, table, columnIndices);
+    }
+
+    /**
+     * Checks if a given class already exists in the schema.
+     *
+     * @param className class name to check.
+     * @return {@code true} if the class already exists. {@code false} otherwise.
+     */
+    @Override
+    public boolean contains(String className) {
+        return realm.getSharedRealm().hasTable(Table.TABLE_PREFIX + className);
+    }
+
+    /**
+     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
+     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
+     *
+     * @param className name of the class to remove.
+     */
+    @Override
+    public void remove(String className) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkEmpty(className, EMPTY_STRING_MSG);
+        String internalTableName = TABLE_PREFIX + className;
+        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
+        Table table = getTable(className);
+        if (table.hasPrimaryKey()) {
+            table.setPrimaryKey(null);
+        }
+        realm.getSharedRealm().removeTable(internalTableName);
+    }
+
+    /**
+     * Renames a class already in the Realm.
+     *
+     * @param oldClassName old class name.
+     * @param newClassName new class name.
+     * @return a schema object for renamed class.
+     */
+    @Override
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkEmpty(oldClassName, "Class names cannot be empty or null");
+        checkEmpty(newClassName, "Class names cannot be empty or null");
+        String oldInternalName = TABLE_PREFIX + oldClassName;
+        String newInternalName = TABLE_PREFIX + newClassName;
+        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
+        if (realm.getSharedRealm().hasTable(newInternalName)) {
+            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
+        }
+
+        // Checks if there is a primary key defined for the old class.
+        Table oldTable = getTable(oldClassName);
+        String pkField = null;
+        if (oldTable.hasPrimaryKey()) {
+            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
+            oldTable.setPrimaryKey(null);
+        }
+
+        realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
+        Table table = realm.getSharedRealm().getTable(newInternalName);
+
+        // Sets the primary key for the new class if necessary.
+        if (pkField != null) {
+            table.setPrimaryKey(pkField);
+        }
+
+        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+        return new StandardRealmObjectSchema(realm, table, columnIndices);
+    }
+
+    private void checkEmpty(String str, String error) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException(error);
+        }
+    }
+
+    private void checkHasTable(String className, String errorMsg) {
+        String internalTableName = TABLE_PREFIX + className;
+        if (!realm.getSharedRealm().hasTable(internalTableName)) {
+            throw new IllegalArgumentException(errorMsg);
+        }
+    }
+
+    @Override
+    Table getTable(String className) {
+        className = Table.TABLE_PREFIX + className;
+        Table table = dynamicClassToTable.get(className);
+        if (table != null) { return table; }
+
+        if (!realm.getSharedRealm().hasTable(className)) {
+            throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+        }
+        table = realm.getSharedRealm().getTable(className);
+        dynamicClassToTable.put(className, table);
+
+        return table;
+    }
+
+    @Override
+    Table getTable(Class<? extends RealmModel> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table != null) { return table; }
+
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            table = classToTable.get(originalClass);
+        }
+        if (table == null) {
+            table = realm.getSharedRealm().getTable(realm.getConfiguration().getSchemaMediator().getTableName(originalClass));
+            classToTable.put(originalClass, table);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToTable.put(clazz, table);
+        }
+
+        return table;
+    }
+
+    @Override
+    StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        StandardRealmObjectSchema classSchema = classToSchema.get(clazz);
+        if (classSchema != null) { return classSchema; }
+
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            classSchema = classToSchema.get(originalClass);
+        }
+        if (classSchema == null) {
+            Table table = getTable(clazz);
+            classSchema = new StandardRealmObjectSchema(realm, table, getColumnInfo(originalClass).getIndicesMap());
+            classToSchema.put(originalClass, classSchema);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToSchema.put(clazz, classSchema);
+        }
+        return classSchema;
+    }
+
+    @Override
+    StandardRealmObjectSchema getSchemaForClass(String className) {
+        className = Table.TABLE_PREFIX + className;
+        StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
+        if (dynamicSchema == null) {
+            if (!realm.getSharedRealm().hasTable(className)) {
+                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+            }
+            Table table = realm.getSharedRealm().getTable(className);
+            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+            dynamicSchema = new StandardRealmObjectSchema(realm, table, columnIndices);
+            dynamicClassToSchema.put(className, dynamicSchema);
+        }
+        return dynamicSchema;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 0f62923c49..a3d474beaf 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -33,7 +33,7 @@
     @SuppressWarnings({"unused", "FieldCanBeLocal"})
     private UncheckedRow originalRow;
 
-    private CheckedRow(Context context, Table parent, long nativePtr) {
+    private CheckedRow(NativeContext context, Table parent, long nativePtr) {
         super(context, parent, nativePtr);
     }
 
@@ -50,7 +50,7 @@ private CheckedRow(UncheckedRow row) {
      * @param index the index of the row.
      * @return an instance of Row for the table and index specified.
      */
-    public static CheckedRow get(Context context, Table table, long index) {
+    public static CheckedRow get(NativeContext context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.getNativePtr(), index);
         return new CheckedRow(context, table, nativeRowPointer);
     }
@@ -63,7 +63,7 @@ public static CheckedRow get(Context context, Table table, long index) {
      * @param index the index of the row.
      * @return a checked instance of {@link Row} for the {@link LinkView} and index specified.
      */
-    public static CheckedRow get(Context context, LinkView linkView, long index) {
+    public static CheckedRow get(NativeContext context, LinkView linkView, long index) {
         long nativeRowPointer = linkView.nativeGetRow(linkView.getNativePtr(), index);
         return new CheckedRow(context, linkView.getTargetTable(), nativeRowPointer);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Collection.java b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
index aeb8231262..635a6e52a9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Collection.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
@@ -32,6 +32,9 @@
 @Keep
 public class Collection implements NativeObject {
 
+    private static final String CLOSED_REALM_MESSAGE =
+            "This Realm instance has already been closed, making it unusable.";
+
     private static class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
         public CollectionObserverPair(T observer, Object listener) {
             super(observer, listener);
@@ -94,6 +97,10 @@ public void onCalled(CollectionObserverPair pair, Object observer) {
         protected int pos = -1;
 
         public Iterator(Collection collection) {
+            if (collection.sharedRealm.isClosed()) {
+                throw new IllegalStateException(CLOSED_REALM_MESSAGE);
+            }
+
             this.iteratorCollection = collection;
 
             if (collection.isSnapshot) {
@@ -252,7 +259,7 @@ public void set(T object) {
     private final long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     private final SharedRealm sharedRealm;
-    private final Context context;
+    private final NativeContext context;
     private final Table table;
     private boolean loaded;
     private boolean isSnapshot = false;
@@ -328,7 +335,7 @@ public static Collection createBacklinksCollection(SharedRealm realm, UncheckedR
                 row.getNativePtr(),
                 srcTable.getNativePtr(),
                 srcTable.getColumnIndex(srcFieldName));
-        return new Collection(realm, row.getTable(), backlinksPtr, true);
+        return new Collection(realm, srcTable, backlinksPtr, true);
     }
 
     public Collection(SharedRealm sharedRealm, TableQuery query,
@@ -360,7 +367,7 @@ public Collection(SharedRealm sharedRealm, LinkView linkView, SortDescriptor sor
 
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
-        this.table = linkView.getTable();
+        this.table = linkView.getTargetTable();
         this.context.addReference(this);
         // Collection created from LinkView is loaded by default. So that the listener will be triggered first time
         // with empty change set.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
index c4958e92e9..9064f8fcde 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
@@ -44,7 +44,7 @@
 
     public CollectionChangeSet(long nativePtr) {
         this.nativePtr = nativePtr;
-        Context.dummyContext.addReference(this);
+        NativeContext.dummyContext.addReference(this);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
index 734e7a4261..a6819bdba4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
@@ -169,6 +169,11 @@ public boolean isAttached() {
         return false;
     }
 
+    @Override
+    public void checkIfAttached() {
+        throw getStubException();
+    }
+
     @Override
     public boolean hasColumn(String fieldName) {
         throw getStubException();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index 8eb61a3de3..2562bf88dc 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -24,13 +24,13 @@
  */
 public class LinkView implements NativeObject {
 
-    private final Context context;
+    private final NativeContext context;
     final Table parent;
     final long columnIndexInParent;
     private final long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
-    public LinkView(Context context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
+    public LinkView(NativeContext context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
         this.context = context;
         this.parent = parent;
         this.columnIndexInParent = columnIndexInParent;
@@ -134,13 +134,6 @@ public boolean isAttached() {
         return nativeIsAttached(nativePtr);
     }
 
-    /**
-     * Returns the {@link Table} which all links point to.
-     */
-    public Table getTable() {
-        return parent;
-    }
-
     /**
      * Removes all target rows pointed to by links in this link view, and clear this link view.
      */
@@ -159,8 +152,7 @@ public void removeTargetRow(int index) {
 
     public Table getTargetTable() {
         long nativeTablePointer = nativeGetTargetTable(nativePtr);
-        Table table = new Table(this.parent, nativeTablePointer);
-        return table;
+        return new Table(this.parent, nativeTablePointer);
     }
 
     private void checkImmutable() {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Context.java b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
similarity index 92%
rename from realm/realm-library/src/main/java/io/realm/internal/Context.java
rename to realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
index 253396b037..f559678b76 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Context.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
@@ -21,16 +21,16 @@
 
 // Currently we free native objects in two threads, the SharedGroup is freed in the caller thread, others are freed in
 // RealmFinalizingDaemon thread. And the destruction in both threads are locked by the corresponding context.
-// The purpose of locking on Context is:
+// The purpose of locking on NativeContext is:
 // Destruction of SharedGroup (and hence Group and Table) is currently not thread-safe with respect to destruction of
 // other accessors, you have to ensure mutual exclusion. This is also illustrated by the use of locks in the test
 // test_destructor_thread_safety.cpp. Explicit call of SharedGroup::close() or Table::detach() is also not thread-safe
 // with respect to destruction of other accessors.
-public class Context {
+public class NativeContext {
     private final static ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
     private final static Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
     // Dummy context which will be used by native objects which's destructors are always thread safe.
-    final static Context dummyContext = new Context();
+    final static NativeContext dummyContext = new NativeContext();
 
     static {
         finalizingThread.setName("RealmFinalizingDaemon");
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
index dce71e3fdf..28a6493868 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
@@ -63,13 +63,13 @@ synchronized void remove(NativeObjectReference ref) {
     private final long nativePtr;
     // The pointer to the native finalize function
     private final long nativeFinalizerPtr;
-    private final Context context;
+    private final NativeContext context;
     private NativeObjectReference prev;
     private NativeObjectReference next;
 
     private static ReferencePool referencePool = new ReferencePool();
 
-    NativeObjectReference(Context context,
+    NativeObjectReference(NativeContext context,
             NativeObject referent,
             ReferenceQueue<? super NativeObject> referenceQueue) {
         super(referent, referenceQueue);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
index 7e726a0df3..876b031b9d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
@@ -33,13 +33,13 @@
  *
  * @param <T> the type of {@link ObserverPair}.
  */
-class ObserverPairList<T extends ObserverPairList.ObserverPair> {
+public class ObserverPairList<T extends ObserverPairList.ObserverPair> {
 
     /**
      * @param <T> the type of observer.
      * @param <S> the type of listener.
      */
-    abstract static class ObserverPair<T, S> {
+    public abstract static class ObserverPair<T, S> {
         final WeakReference<T> observerRef;
         protected final S listener;
         // Should only be set by the outer class. To marked it as removed in case it is removed in foreach callback.
@@ -81,7 +81,7 @@ public int hashCode() {
      *
      * @param <T> type of ObserverPair.
      */
-    interface Callback<T extends ObserverPair> {
+    public interface Callback<T extends ObserverPair> {
         void onCalled(T pair, Object observer);
     }
 
@@ -96,7 +96,7 @@ public int hashCode() {
      *
      * @param callback to be executed on the pair.
      */
-    void foreach(Callback<T> callback) {
+    public void foreach(Callback<T> callback) {
         for (T pair : pairs) {
             if (cleared) {
                 break;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
new file mode 100644
index 0000000000..33e1807b04
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.ObjectChangeSet;
+import io.realm.RealmModel;
+import io.realm.RealmObjectChangeListener;
+
+
+/**
+ * Java wrapper for Object Store's {@code Object} class. Currently it is only used for object notifications.
+ */
+@KeepMember
+public class OsObject implements NativeObject {
+
+    private static class OsObjectChangeSet implements ObjectChangeSet {
+        final String[] changedFields;
+        final boolean deleted;
+
+        OsObjectChangeSet(String[] changedFields, boolean deleted) {
+            this.changedFields = changedFields;
+            this.deleted = deleted;
+        }
+
+        @Override
+        public boolean isDeleted() {
+            return deleted;
+        }
+
+        @Override
+        public String[] getChangedFields() {
+            return changedFields;
+        }
+
+        @Override
+        public boolean isFieldChanged(String fieldName) {
+            for (String name : changedFields) {
+                if (name.equals(fieldName)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    public static class ObjectObserverPair<T extends RealmModel>
+            extends ObserverPairList.ObserverPair<T, RealmObjectChangeListener<T>> {
+        public ObjectObserverPair(T observer, RealmObjectChangeListener<T> listener) {
+            super(observer, listener);
+        }
+
+        public void onChange(T observer, ObjectChangeSet changeSet) {
+            listener.onChange(observer, changeSet);
+        }
+    }
+
+    private static class Callback implements ObserverPairList.Callback<ObjectObserverPair> {
+        private final String[] changedFields;
+
+        Callback(String[] changedFields) {
+            this.changedFields = changedFields;
+        }
+
+        private ObjectChangeSet createChangeSet() {
+            boolean isDeleted = changedFields == null;
+            return new OsObjectChangeSet(isDeleted ? new String[0] : changedFields, isDeleted);
+        }
+
+        @Override
+        public void onCalled(ObjectObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange((RealmModel) observer, createChangeSet());
+        }
+    }
+
+    private final long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    private ObserverPairList<ObjectObserverPair> observerPairs = new ObserverPairList<ObjectObserverPair>();
+
+    public OsObject(SharedRealm sharedRealm, UncheckedRow row) {
+        nativePtr = nativeCreate(sharedRealm.getNativePtr(), row.getNativePtr());
+        sharedRealm.context.addReference(this);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public <T extends RealmModel> void addListener(T observer, RealmObjectChangeListener<T> listener) {
+        if (observerPairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+        ObjectObserverPair<T> pair = new ObjectObserverPair<T>(observer, listener);
+        observerPairs.add(pair);
+    }
+
+    public <T extends RealmModel> void removeListener(T observer) {
+        observerPairs.removeByObserver(observer);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    public <T extends RealmModel> void removeListener(T observer, RealmObjectChangeListener<T> listener) {
+        observerPairs.remove(observer, listener);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    // Set the ObserverPairList. This is useful for the findAllAsync. When the pendingRow returns the results, the whole
+    // listener list has to be moved from ProxyState to here.
+    public void setObserverPairs(ObserverPairList<ObjectObserverPair> pairs) {
+        if (!observerPairs.isEmpty()) {
+            throw new IllegalStateException("'observerPairs' is not empty. Listeners have been added before.");
+        }
+
+        observerPairs = pairs;
+        if (!pairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+    }
+
+    // Called by JNI
+    @SuppressWarnings("unused")
+    @KeepMember
+    private void notifyChangeListeners(String[] changedFields) {
+        observerPairs.foreach(new Callback(changedFields));
+    }
+
+    private static native long nativeGetFinalizerPtr();
+
+    private static native long nativeCreate(long shared_realm_ptr, long rowPtr);
+
+    private native void nativeStartListening(long nativePtr);
+
+    private native void nativeStopListening(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 90c1dbc74e..63a86d2bb0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -29,6 +29,7 @@
     private static final String QUERY_EXECUTED_MESSAGE =
             "The query has been executed. This 'PendingRow' is not valid anymore.";
 
+    private SharedRealm sharedRealm;
     private Collection pendingCollection;
     private RealmChangeListener<PendingRow> listener;
     private WeakReference<FrontEnd> frontEndRef;
@@ -36,39 +37,18 @@
 
     public PendingRow(SharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor,
             final boolean returnCheckedRow) {
+        this.sharedRealm = sharedRealm;
         pendingCollection = new Collection(sharedRealm, query, sortDescriptor, null);
 
         listener = new RealmChangeListener<PendingRow>() {
             @Override
             public void onChange(PendingRow pendingRow) {
-                if (frontEndRef == null) {
-                    throw new IllegalStateException(PROXY_NOT_SET_MESSAGE);
-                }
-                FrontEnd frontEnd = frontEndRef.get();
-                if (frontEnd == null) {
-                    // The front end is GCed.
-                    clearPendingCollection();
-                    return;
-                }
-
-                if (pendingCollection.isValid()) {
-                    // PendingRow will always get the first Row of the query since we only support findFirst.
-                    UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
-                    // If no rows returned by the query, notify the frontend with an invalid row.
-                    if (uncheckedRow != null) {
-                        Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
-                        // Ask the front end to reset the row and stop async query.
-                        frontEnd.onQueryFinished(row);
-                    } else {
-                        frontEnd.onQueryFinished(InvalidRow.INSTANCE);
-                    }
-                }
-
-                clearPendingCollection();
+                notifyFrontEnd();
             }
         };
         pendingCollection.addListener(this, listener);
         this.returnCheckedRow = returnCheckedRow;
+        sharedRealm.addPendingRow(this);
     }
 
     // To set the front end of this PendingRow.
@@ -216,6 +196,11 @@ public boolean isAttached() {
         return false;
     }
 
+    @Override
+    public void checkIfAttached() {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
     @Override
     public boolean hasColumn(String fieldName) {
         throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
@@ -225,22 +210,47 @@ private void clearPendingCollection() {
         pendingCollection.removeListener(this, listener);
         pendingCollection = null;
         listener = null;
+        sharedRealm.removePendingRow(this);
     }
 
-    public Row executeQuery() {
-        if (pendingCollection == null) {
-            throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
-        }
+    private void notifyFrontEnd() {
         if (frontEndRef == null) {
             throw new IllegalStateException(PROXY_NOT_SET_MESSAGE);
         }
+        FrontEnd frontEnd = frontEndRef.get();
+        if (frontEnd == null) {
+            // The front end is GCed.
+            clearPendingCollection();
+            return;
+        }
 
-        UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
-        clearPendingCollection();
+        if (pendingCollection.isValid()) {
+            // PendingRow will always get the first Row of the query since we only support findFirst.
+            UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+            // Clear the pending collection immediately in case beginTransaction is called in the listener which will
+            // execute the query again.
+            clearPendingCollection();
+            // If no rows returned by the query, notify the frontend with an invalid row.
+            if (uncheckedRow != null) {
+                Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
+                // Ask the front end to reset the row and stop async query.
+                frontEnd.onQueryFinished(row);
+            } else {
+                // No row matches the query, return a invalid row.
+                frontEnd.onQueryFinished(InvalidRow.INSTANCE);
+            }
+        } else {
+            clearPendingCollection();
+        }
+
+    }
 
-        if (uncheckedRow == null) {
-            return InvalidRow.INSTANCE;
+    // Execute the query immediately and call frontend's onQueryFinished().
+    public void executeQuery() {
+        if (pendingCollection == null) {
+            throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
         }
-        return returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
+
+        notifyFrontEnd();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
index 3493dd4707..279c559606 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -97,10 +97,16 @@ protected RealmNotifier(SharedRealm sharedRealm) {
     // called from java_binding_context.cpp
     void didChange() {
         realmObserverPairs.foreach(onChangeCallBack);
-        for (Runnable runnable : transactionCallbacks) {
-            runnable.run();
+
+        if (!transactionCallbacks.isEmpty()) {
+            // The callback list needs to be cleared before calling to avoid synchronized transactions in the callback
+            // triggers it recursively.
+            List<Runnable> callbacks = transactionCallbacks;
+            transactionCallbacks = new ArrayList<Runnable>();
+            for (Runnable runnable : callbacks) {
+                runnable.run();
+            }
         }
-        transactionCallbacks.clear();
     }
 
     // Called from JavaBindingContext::before_notify.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index d2c7319f5c..50c2c72983 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -54,14 +54,6 @@
      */
     public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
 
-    /**
-     * Creates the backing table in Realm for the given RealmObject class.
-     *
-     * @param clazz the {@link RealmObject} model class to create backing table for.
-     * @param sharedRealm the wrapper object of underlying native database.
-     */
-    public abstract Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm);
-
     /**
      * Validates the backing table in Realm for the given RealmObject class.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index e3c81dc4ee..1e448d2058 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -110,6 +110,11 @@
      */
     boolean isAttached();
 
+    /**
+     * Throws {@link IllegalStateException} if the row is not attached.
+     */
+    void checkIfAttached();
+
     /**
      * Returns {@code true} if the field name exists.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 814af27fb8..21b041baec 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -24,7 +24,6 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 
 import io.realm.RealmConfiguration;
-import io.realm.RealmSchema;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
@@ -110,12 +109,13 @@ public byte getNativeValue() {
         }
     }
 
+    private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
+    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<>();
+    public final List<WeakReference<Collection.Iterator>> iterators = new ArrayList<>();
+
     // JNI will only hold a weak global ref to this.
     public final RealmNotifier realmNotifier;
-    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<WeakReference<Collection>>();
     public final Capabilities capabilities;
-    public final List<WeakReference<Collection.Iterator>> iterators =
-            new ArrayList<WeakReference<Collection.Iterator>>();
 
     public static class VersionID implements Comparable<VersionID> {
         public final long version;
@@ -174,9 +174,10 @@ public int hashCode() {
         void onSchemaVersionChanged(long currentVersion);
     }
 
-    private long nativePtr;
-    private RealmConfiguration configuration;
-    final Context context;
+    private final RealmConfiguration configuration;
+
+    final private long nativePtr;
+    final NativeContext context;
     private long lastSchemaVersion;
     private final SchemaVersionListener schemaChangeListener;
 
@@ -192,7 +193,7 @@ private SharedRealm(long nativeConfigPtr,
         this.capabilities = capabilities;
         this.realmNotifier = realmNotifier;
         this.schemaChangeListener = schemaVersionListener;
-        context = new Context();
+        context = new NativeContext();
         context.addReference(this);
         this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
         nativeSetAutoRefresh(nativePtr, capabilities.canDeliverNotification());
@@ -241,6 +242,7 @@ public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionLi
 
     public void beginTransaction() {
         detachIterators();
+        executePendingRowQueries();
         nativeBeginTransaction(nativePtr);
         invokeSchemaChangeListenerIfSchemaChanged();
     }
@@ -317,7 +319,7 @@ public long getLastSnapshotVersion() {
     }
 
     public boolean isClosed() {
-        return nativePtr == 0 || nativeIsClosed(nativePtr);
+        return nativeIsClosed(nativePtr);
     }
 
     public void writeCopy(File file, byte[] key) {
@@ -343,8 +345,8 @@ public boolean compact() {
      * Updates the underlying schema based on the schema description.
      * Calling this method must be done from inside a write transaction.
      */
-    public void updateSchema(RealmSchema schema, long version) {
-        nativeUpdateSchema(nativePtr, schema.getNativePtr(), version);
+    public void updateSchema(long schemaNativePointer, long version) {
+        nativeUpdateSchema(nativePtr, schemaNativePointer, version);
     }
 
     public void setAutoRefresh(boolean enabled) {
@@ -356,8 +358,8 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
-    public boolean requiresMigration(RealmSchema schema) {
-        return nativeRequiresMigration(nativePtr, schema.getNativePtr());
+    public boolean requiresMigration(long schemaNativePointer) {
+        return nativeRequiresMigration(nativePtr, schemaNativePointer);
     }
 
     @Override
@@ -366,12 +368,9 @@ public void close() {
             realmNotifier.close();
         }
         synchronized (context) {
-            if (nativePtr != 0) {
-                nativeCloseSharedRealm(nativePtr);
-                // It is OK to clear the nativePtr. It has been saved to the NativeObjectReference when adding to the
-                // context.
-                nativePtr = 0;
-            }
+            nativeCloseSharedRealm(nativePtr);
+            // Don't reset the nativePtr since we still rely on Object Store to check if the given SharedRealm ptr
+            // is closed or not.
         }
     }
 
@@ -403,7 +402,7 @@ public void invokeSchemaChangeListenerIfSchemaChanged() {
     // See https://github.com/realm/realm-java/issues/3883 for more information.
     // Should only be called by Iterator's constructor.
     void addIterator(Collection.Iterator iterator) {
-        iterators.add(new WeakReference<Collection.Iterator>(iterator));
+        iterators.add(new WeakReference<>(iterator));
     }
 
     // The detaching should happen before transaction begins.
@@ -428,6 +427,38 @@ void invalidateIterators() {
         iterators.clear();
     }
 
+    // addPendingRow, removePendingRow and executePendingRow queries are to solve that the listener cannot be added
+    // inside a transaction. For the findFirstAsync(), listener is registered on an Object Store Results first, then move
+    // the listeners to the Object when the query for Results returns. When beginTransaction() called, all listeners'
+    // on the results will be triggered first, that leads to the registration of listeners on the Object which will
+    // throw because of the transaction has already begun. So here we execute all PendingRow queries first before
+    // calling the Object Store begin_transaction to avoid the problem.
+    // Add pending row to the list when it is created. It should be called in the PendingRow constructor.
+    void addPendingRow(PendingRow pendingRow) {
+       pendingRows.add(new WeakReference<PendingRow>(pendingRow));
+    }
+
+    // Remove pending row from the list. It should be called when pending row's query finished.
+    void removePendingRow(PendingRow pendingRow) {
+        for (WeakReference<PendingRow> ref : pendingRows) {
+            PendingRow row = ref.get();
+            if (row == null || row == pendingRow) {
+                pendingRows.remove(ref);
+            }
+        }
+    }
+
+    // Execute all pending row queries.
+    private void executePendingRowQueries() {
+        for (WeakReference<PendingRow> ref : pendingRows) {
+            PendingRow row = ref.get();
+            if (row != null) {
+                row.executeQuery();
+            }
+        }
+        pendingRows.clear();
+    }
+
     private static native void nativeInit(String temporaryDirectoryPath);
 
     // Keep last session as an 'object' to avoid any reference to sync code
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
index 181df8820c..3df785ef92 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
@@ -121,11 +121,6 @@ private static void checkFieldTypeForDistinct(FieldDescriptor descriptor, String
                     "Distinct is not supported on '%s' field '%s' in '%s'.",
                     descriptor.getFieldType().toString(), descriptor.getFieldName(), fieldDescriptions));
         }
-        if (!descriptor.hasSearchIndex()) {
-            throw new IllegalArgumentException(String.format(
-                    "Field '%s' in '%s' must be indexed in order to use it for distinct queries.",
-                    descriptor.getFieldName(), fieldDescriptions));
-        }
     }
 
     // Called by JNI.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 707272d4cd..67e744ca3e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -60,7 +60,7 @@
 
     private long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    final Context context;
+    final NativeContext context;
     private final SharedRealm sharedRealm;
     private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
@@ -69,7 +69,7 @@
      * allowed only for empty tables. It creates a native reference of the object and keeps a reference to it.
      */
     public Table() {
-        this.context = new Context();
+        this.context = new NativeContext();
         // Native methods work will be initialized here. Generated classes will
         // have nothing to do with the native functions. Generated Java Table
         // classes will work as a wrapper on top of table.
@@ -102,10 +102,6 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    public Table getTable() {
-        return this;
-    }
-
     public long getNativeTablePointer() {
         return nativePtr;
     }
@@ -343,27 +339,12 @@ public RealmFieldType getColumnType(long columnIndex) {
         return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
     }
 
-
     /**
-     * Removes a row from the specific index. As of now the entry is simply removed from the table.
+     * Removes a row from the specific index. If it is not the last row in the table, it then moves the last row into
+     * the vacated slot.
      *
      * @param rowIndex the row index (starting with 0)
      */
-    public void remove(long rowIndex) {
-        checkImmutable();
-        nativeRemove(nativePtr, rowIndex);
-    }
-
-    public void removeFirst() {
-        checkImmutable();
-        remove(0);
-    }
-
-    public void removeLast() {
-        checkImmutable();
-        nativeRemoveLast(nativePtr);
-    }
-
     public void moveLastOver(long rowIndex) {
         checkImmutable();
         nativeMoveLastOver(nativePtr, rowIndex);
@@ -714,8 +695,7 @@ public long getLink(long columnIndex, long rowIndex) {
     public Table getLinkTarget(long columnIndex) {
         long nativeTablePointer = nativeGetLinkTarget(nativePtr, columnIndex);
         // Copies context reference from parent.
-        Table table = new Table(this.sharedRealm, nativeTablePointer);
-        return table;
+        return new Table(this.sharedRealm, nativeTablePointer);
     }
 
     public boolean isNull(long columnIndex, long rowIndex) {
@@ -931,71 +911,6 @@ private void checkHasPrimaryKey() {
         }
     }
 
-    //
-    // Aggregate functions
-    //
-
-    // Integers
-    public long sumLong(long columnIndex) {
-        return nativeSumInt(nativePtr, columnIndex);
-    }
-
-    public Long maximumLong(long columnIndex) {
-        return nativeMaximumInt(nativePtr, columnIndex);
-    }
-
-    public Long minimumLong(long columnIndex) {
-        return nativeMinimumInt(nativePtr, columnIndex);
-    }
-
-    public double averageLong(long columnIndex) {
-        return nativeAverageInt(nativePtr, columnIndex);
-    }
-
-    // Floats
-    public double sumFloat(long columnIndex) {
-        return nativeSumFloat(nativePtr, columnIndex);
-    }
-
-    public Float maximumFloat(long columnIndex) {
-        return nativeMaximumFloat(nativePtr, columnIndex);
-    }
-
-    public Float minimumFloat(long columnIndex) {
-        return nativeMinimumFloat(nativePtr, columnIndex);
-    }
-
-    public double averageFloat(long columnIndex) {
-        return nativeAverageFloat(nativePtr, columnIndex);
-    }
-
-    // Doubles
-    public double sumDouble(long columnIndex) {
-        return nativeSumDouble(nativePtr, columnIndex);
-    }
-
-    public Double maximumDouble(long columnIndex) {
-        return nativeMaximumDouble(nativePtr, columnIndex);
-    }
-
-    public Double minimumDouble(long columnIndex) {
-        return nativeMinimumDouble(nativePtr, columnIndex);
-    }
-
-    public double averageDouble(long columnIndex) {
-        return nativeAverageDouble(nativePtr, columnIndex);
-    }
-
-    // Date aggregates
-
-    public Date maximumDate(long columnIndex) {
-        return new Date(nativeMaximumTimestamp(nativePtr, columnIndex));
-    }
-
-    public Date minimumDate(long columnIndex) {
-        return new Date(nativeMinimumTimestamp(nativePtr, columnIndex));
-    }
-
     //
     // Count
     //
@@ -1206,10 +1121,6 @@ public static String tableNameToClassName(String tableName) {
 
     private native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
 
-    private native void nativeRemove(long nativeTablePtr, long rowIndex);
-
-    private native void nativeRemoveLast(long nativeTablePtr);
-
     private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
 
     public static native long nativeAddEmptyRow(long nativeTablePtr, long rows);
@@ -1281,34 +1192,6 @@ public static String tableNameToClassName(String tableName) {
 
     public static native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
 
-    private native long nativeSumInt(long nativePtr, long columnIndex);
-
-    private native long nativeMaximumInt(long nativePtr, long columnIndex);
-
-    private native long nativeMinimumInt(long nativePtr, long columnIndex);
-
-    private native double nativeAverageInt(long nativePtr, long columnIndex);
-
-    private native double nativeSumFloat(long nativePtr, long columnIndex);
-
-    private native float nativeMaximumFloat(long nativePtr, long columnIndex);
-
-    private native float nativeMinimumFloat(long nativePtr, long columnIndex);
-
-    private native double nativeAverageFloat(long nativePtr, long columnIndex);
-
-    private native double nativeSumDouble(long nativePtr, long columnIndex);
-
-    private native double nativeMaximumDouble(long nativePtr, long columnIndex);
-
-    private native double nativeMinimumDouble(long nativePtr, long columnIndex);
-
-    private native double nativeAverageDouble(long nativePtr, long columnIndex);
-
-    private native long nativeMaximumTimestamp(long nativePtr, long columnIndex);
-
-    private native long nativeMinimumTimestamp(long nativePtr, long columnIndex);
-
     private native long nativeCountLong(long nativePtr, long columnIndex, long value);
 
     private native long nativeCountFloat(long nativePtr, long columnIndex, float value);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index ad81a72afd..8d0be81e47 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -28,7 +28,7 @@
     protected long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     protected final Table table;
-    private final Context context;
+    private final NativeContext context;
 
     // All actions (find(), findAll(), sum(), etc.) must call validateQuery() before performing
     // the actual action. The other methods must set queryValidated to false in order to enforce
@@ -36,7 +36,7 @@
     private boolean queryValidated = true;
 
     // TODO: Can we protect this?
-    public TableQuery(Context context, Table table, long nativeQueryPtr) {
+    public TableQuery(NativeContext context, Table table, long nativeQueryPtr) {
         if (DEBUG) {
             System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
         }
@@ -100,43 +100,43 @@ public TableQuery not() {
 
     // Queries for integer values.
 
-    public TableQuery equalTo(long columnIndexes[], long value) {
+    public TableQuery equalTo(long[] columnIndexes, long value) {
         nativeEqual(nativePtr, columnIndexes, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], long value) {
+    public TableQuery notEqualTo(long[] columnIndex, long value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], long value) {
+    public TableQuery greaterThan(long[] columnIndex, long value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], long value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], long value) {
+    public TableQuery lessThan(long[] columnIndex, long value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], long value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, long value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], long value1, long value2) {
+    public TableQuery between(long[] columnIndex, long value1, long value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
@@ -144,43 +144,43 @@ public TableQuery between(long columnIndex[], long value1, long value2) {
 
     // Queries for float values.
 
-    public TableQuery equalTo(long columnIndex[], float value) {
+    public TableQuery equalTo(long[] columnIndex, float value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], float value) {
+    public TableQuery notEqualTo(long[] columnIndex, float value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], float value) {
+    public TableQuery greaterThan(long[] columnIndex, float value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], float value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, float value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], float value) {
+    public TableQuery lessThan(long[] columnIndex, float value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], float value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, float value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], float value1, float value2) {
+    public TableQuery between(long[] columnIndex, float value1, float value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
@@ -188,43 +188,43 @@ public TableQuery between(long columnIndex[], float value1, float value2) {
 
     // Queries for double values.
 
-    public TableQuery equalTo(long columnIndex[], double value) {
+    public TableQuery equalTo(long[] columnIndex, double value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], double value) {
+    public TableQuery notEqualTo(long[] columnIndex, double value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], double value) {
+    public TableQuery greaterThan(long[] columnIndex, double value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], double value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, double value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], double value) {
+    public TableQuery lessThan(long[] columnIndex, double value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], double value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, double value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], double value1, double value2) {
+    public TableQuery between(long[] columnIndex, double value1, double value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
@@ -232,7 +232,7 @@ public TableQuery between(long columnIndex[], double value1, double value2) {
 
     // Query for boolean values.
 
-    public TableQuery equalTo(long columnIndex[], boolean value) {
+    public TableQuery equalTo(long[] columnIndex, boolean value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
@@ -240,9 +240,9 @@ public TableQuery equalTo(long columnIndex[], boolean value) {
 
     // Queries for Date values.
 
-    private final static String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
+    private static final String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
 
-    public TableQuery equalTo(long columnIndex[], Date value) {
+    public TableQuery equalTo(long[] columnIndex, Date value) {
         if (value == null) {
             nativeIsNull(nativePtr, columnIndex);
         } else {
@@ -252,42 +252,42 @@ public TableQuery equalTo(long columnIndex[], Date value) {
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], Date value) {
+    public TableQuery notEqualTo(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeNotEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], Date value) {
+    public TableQuery greaterThan(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeGreaterTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], Date value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeGreaterEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], Date value) {
+    public TableQuery lessThan(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeLessTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], Date value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeLessEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], Date value1, Date value2) {
+    public TableQuery between(long[] columnIndex, Date value1, Date value2) {
         if (value1 == null || value2 == null) {
             throw new IllegalArgumentException("Date values in query criteria must not be null."); // Different text
         }
@@ -312,7 +312,7 @@ public TableQuery notEqualTo(long[] columnIndices, byte[] value) {
 
     // Query for String values.
 
-    private final static String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
+    private static final String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
 
     // Equals
     public TableQuery equalTo(long[] columnIndexes, String value, Case caseSensitive) {
@@ -328,61 +328,61 @@ public TableQuery equalTo(long[] columnIndexes, String value) {
     }
 
     // Not Equals
-    public TableQuery notEqualTo(long columnIndex[], String value, Case caseSensitive) {
+    public TableQuery notEqualTo(long[] columnIndex, String value, Case caseSensitive) {
         nativeNotEqual(nativePtr, columnIndex, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], String value) {
+    public TableQuery notEqualTo(long[] columnIndex, String value) {
         nativeNotEqual(nativePtr, columnIndex, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery beginsWith(long[] columnIndices, String value, Case caseSensitive) {
         nativeBeginsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long columnIndices[], String value) {
+    public TableQuery beginsWith(long[] columnIndices, String value) {
         nativeBeginsWith(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery endsWith(long[] columnIndices, String value, Case caseSensitive) {
         nativeEndsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long columnIndices[], String value) {
+    public TableQuery endsWith(long[] columnIndices, String value) {
         nativeEndsWith(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery like(long[] columnIndices, String value, Case caseSensitive) {
         nativeLike(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long columnIndices[], String value) {
+    public TableQuery like(long[] columnIndices, String value) {
         nativeLike(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery contains(long[] columnIndices, String value, Case caseSensitive) {
         nativeContains(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long columnIndices[], String value) {
+    public TableQuery contains(long[] columnIndices, String value) {
         nativeContains(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
@@ -604,13 +604,13 @@ public Date minimumDate(long columnIndex) {
     }
 
     // isNull and isNotNull
-    public TableQuery isNull(long columnIndices[]) {
+    public TableQuery isNull(long[] columnIndices) {
         nativeIsNull(nativePtr, columnIndices);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isNotNull(long columnIndices[]) {
+    public TableQuery isNotNull(long[] columnIndices) {
         nativeIsNotNull(nativePtr, columnIndices);
         queryValidated = false;
         return this;
@@ -660,63 +660,63 @@ private void throwImmutable() {
 
     private native void nativeNot(long nativeQueryPtr);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLess(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeLess(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], float value1, float value2);
+    private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, float value1, float value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeLess(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
+    private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, double value1, double value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, boolean value);
 
-    private native void nativeEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreaterTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLessTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeBetweenTimestamp(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeBetweenTimestamp(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
 
@@ -724,15 +724,15 @@ private void throwImmutable() {
 
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, String value, boolean caseSensitive);
 
-    private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeBeginsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
-    private native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeEndsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
-    private native void nativeLike(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeLike(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
-    private native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeContains(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
     private native void nativeIsEmpty(long nativePtr, long[] columnIndices);
 
@@ -768,9 +768,9 @@ private void throwImmutable() {
 
     private native Long nativeMinimumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
-    private native void nativeIsNull(long nativePtr, long columnIndices[]);
+    private native void nativeIsNull(long nativePtr, long[] columnIndices);
 
-    private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
+    private native void nativeIsNotNull(long nativePtr, long[] columnIndices);
 
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
index 48cdee87fb..c611cb6674 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
@@ -18,9 +18,9 @@
 
 class TestUtil {
 
-    public native static long getMaxExceptionNumber();
+    public static native long getMaxExceptionNumber();
 
-    public native static String getExpectedMessage(long exceptionKind);
+    public static native String getExpectedMessage(long exceptionKind);
 
-    public native static void testThrowExceptions(long exceptionKind);
+    public static native void testThrowExceptions(long exceptionKind);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index c018cc5cfe..48f2e77233 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -33,11 +33,11 @@
 public class UncheckedRow implements NativeObject, Row {
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
-    private final Context context; // This is only kept because for now it's needed by the constructor of LinkView
+    private final NativeContext context; // This is only kept because for now it's needed by the constructor of LinkView
     private final Table parent;
     private final long nativePtr;
 
-    UncheckedRow(Context context, Table parent, long nativePtr) {
+    UncheckedRow(NativeContext context, Table parent, long nativePtr) {
         this.context = context;
         this.parent = parent;
         this.nativePtr = nativePtr;
@@ -71,7 +71,7 @@ public long getNativeFinalizerPtr() {
      * @param index the index of the row.
      * @return an instance of Row for the table and index specified.
      */
-    static UncheckedRow getByRowIndex(Context context, Table table, long index) {
+    static UncheckedRow getByRowIndex(NativeContext context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.getNativePtr(), index);
         return new UncheckedRow(context, table, nativeRowPointer);
     }
@@ -84,7 +84,7 @@ static UncheckedRow getByRowIndex(Context context, Table table, long index) {
      * @param nativeRowPointer pointer of a row.
      * @return an instance of Row for the table and row specified.
      */
-    static UncheckedRow getByRowPointer(Context context, Table table, long nativeRowPointer) {
+    static UncheckedRow getByRowPointer(NativeContext context, Table table, long nativeRowPointer) {
         return new UncheckedRow(context, table, nativeRowPointer);
     }
 
@@ -96,7 +96,7 @@ static UncheckedRow getByRowPointer(Context context, Table table, long nativeRow
      * @param index the index of the row.
      * @return an instance of Row for the LinkView and index specified.
      */
-    static UncheckedRow getByRowIndex(Context context, LinkView linkView, long index) {
+    static UncheckedRow getByRowIndex(NativeContext context, LinkView linkView, long index) {
         long nativeRowPointer = linkView.nativeGetRow(linkView.getNativePtr(), index);
         return new UncheckedRow(context, linkView.getTargetTable(), nativeRowPointer);
     }
@@ -292,6 +292,13 @@ public boolean isAttached() {
         return nativePtr != 0 && nativeIsAttached(nativePtr);
     }
 
+    @Override
+    public void checkIfAttached() {
+        if (!isAttached()) {
+            throw new IllegalStateException("Object is no longer managed by Realm. Has it been deleted?");
+        }
+    }
+
     @Override
     public boolean hasColumn(String fieldName) {
         return nativeHasColumn(nativePtr, fieldName);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 1e89b70597..2fc7778786 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -32,17 +32,6 @@
 
 public class Util {
 
-    public static long getNativeMemUsage() {
-        return nativeGetMemUsage();
-    }
-
-    static native long nativeGetMemUsage();
-
-    // Called by JNI. Do not remove.
-    static void javaPrint(String txt) {
-        System.out.print(txt);
-    }
-
     public static String getTablePrefix() {
         return nativeGetTablePrefix();
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index dc410380d8..81218ae82e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -38,7 +38,6 @@
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
-import io.realm.internal.Table;
 import io.realm.internal.Util;
 
 
@@ -50,7 +49,7 @@
     private final Map<Class<? extends RealmModel>, RealmProxyMediator> mediators;
 
     public CompositeMediator(RealmProxyMediator... mediators) {
-        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<Class<? extends RealmModel>, RealmProxyMediator>();
+        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<>();
         if (mediators != null) {
             for (RealmProxyMediator mediator : mediators) {
                 for (Class<? extends RealmModel> realmClass : mediator.getModelClasses()) {
@@ -67,12 +66,6 @@ public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> cla
         return mediator.createRealmObjectSchema(clazz, schema);
     }
 
-    @Override
-    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
-        RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.createTable(clazz, sharedRealm);
-    }
-
     @Override
     public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
             boolean allowExtraColumns) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index f0cdbf22b8..3f4f6fa471 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -38,7 +38,6 @@
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
-import io.realm.internal.Table;
 import io.realm.internal.Util;
 
 
@@ -60,7 +59,7 @@
     public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<? extends RealmModel>> allowedClasses) {
         this.originalMediator = originalMediator;
 
-        Set<Class<? extends RealmModel>> tempAllowedClasses = new HashSet<Class<? extends RealmModel>>();
+        Set<Class<? extends RealmModel>> tempAllowedClasses = new HashSet<>();
         if (originalMediator != null) {
             Set<Class<? extends RealmModel>> originalClasses = originalMediator.getModelClasses();
             for (Class<? extends RealmModel> clazz : allowedClasses) {
@@ -82,12 +81,6 @@ public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> cla
         return originalMediator.createRealmObjectSchema(clazz, schema);
     }
 
-    @Override
-    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
-        checkSchemaHasClass(clazz);
-        return originalMediator.createTable(clazz, sharedRealm);
-    }
-
     @Override
     public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
             boolean allowExtraColumns) {
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index 984a06f2c0..e24211efca 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -298,4 +298,11 @@ private static void log(int level, Throwable throwable, String message, Object..
     private static native void nativeSetLogLevel(int level);
 
     private static native int nativeGetLogLevel();
+
+    // Methods below are used for testing core logger bridge only.
+    static native long nativeCreateCoreLoggerBridge(String tag);
+
+    static native void nativeCloseCoreLoggerBridge(long nativePtr);
+
+    static native void nativeLogToCoreLoggerBridge(long nativePtr, int level, String message);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ClientResetHandler.java b/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
similarity index 91%
rename from realm/realm-library/src/objectServer/java/io/realm/ClientResetHandler.java
rename to realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
index 1fdc1adf8b..f9a2fbe1e1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ClientResetHandler.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
@@ -21,16 +21,16 @@
 /**
  * Class encapsulating information needed for handling a Client Reset event.
  *
- * @see io.realm.SyncSession.ErrorHandler#onClientResetRequired(SyncSession, ClientResetHandler) for more information
+ * @see io.realm.SyncSession.ErrorHandler#onError(SyncSession, ObjectServerError) for more information
  *      about when and why Client Reset occurs and how to deal with it.
  */
-public class ClientResetHandler extends ObjectServerError {
+public class ClientResetRequiredError extends ObjectServerError {
 
     private final RealmConfiguration configuration;
     private final File backupFile;
     private final File originalFile;
 
-    public ClientResetHandler(ErrorCode errorCode, String errorMessage, String backupFilePath, RealmConfiguration configuration) {
+    public ClientResetRequiredError(ErrorCode errorCode, String errorMessage, String backupFilePath, RealmConfiguration configuration) {
         super(errorCode, errorMessage);
         this.configuration = configuration;
         this.backupFile = new File(backupFilePath);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index a8e4a827ec..1a5438ba92 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -127,8 +127,8 @@ public static ErrorCode fromInt(int errorCode) {
         throw new IllegalArgumentException("Unknown error code: " + errorCode);
     }
 
-public enum Category {
+    public enum Category {
         FATAL,          // Abort session as soon as possible
-        RECOVERABLE    // Still possible to recover the session by either rebinding or providing the required information.
+        RECOVERABLE,    // Still possible to recover the session by either rebinding or providing the required information.
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 9590f702f2..e2eb671721 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -60,7 +60,6 @@
  *
  * <ul>
  *     <li>{@code deleteRealmIfMigrationNeeded()}</li>
- *     <li>{@code schemaVersion(long version)}</li>
  *     <li>{@code migration(Migration)}</li>
  * </ul>
  *
@@ -464,8 +463,25 @@ public Builder encryptionKey(byte[] key) {
         }
 
         /**
-         * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
-         * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
+         * Sets the schema version of the Realm.
+         * <p>
+         * While synced Realms only support additive schema changes which can be applied without requiring a manual
+         * migration, the schema version must still be incremented as an indication to Realm that the change was
+         * intentional.
+         * <p>
+         * Failing to increment the schema version will cause Realm to throw a {@link io.realm.exceptions.RealmMigrationNeededException}
+         * when the Realm is opened and the changed schema will not be applied.
+         * <p>
+         * <b>WARNING:</b> There is no guarantee that the value inserted here is the same returned by {@link Realm#getVersion()}.
+         * Due to the nature of synced Realms, the value can both be higher and lower.
+         * <ul>
+         *     <li>It will be lower if another client with a lesser {@code schemaVersion} connected to the server for
+         *         the first time after this schemaVersion was used.
+     *         </li>
+         *     <li>It will be higher if another client with a higher {@code schemaVersion} connected to the server after
+         *         this Realm was created.
+     *         </li>
+         * </ul>
          *
          * @param schemaVersion the schema version.
          * @throws IllegalArgumentException if schema version is invalid.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 691538c59b..8ef5862f5f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -26,6 +26,7 @@
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.Keep;
 import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.network.OkHttpAuthenticationServer;
 import io.realm.log.RealmLog;
 
@@ -69,6 +70,11 @@
     private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {
         @Override
         public void onError(SyncSession session, ObjectServerError error) {
+            if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {
+                RealmLog.error("Client Reset required for: " + session.getConfiguration().getServerUrl());
+                return;
+            }
+
             String errorMsg = String.format("Session Error[%s]: %s",
                     session.getConfiguration().getServerUrl(),
                     error.toString());
@@ -83,11 +89,6 @@ public void onError(SyncSession session, ObjectServerError error) {
                     throw new IllegalArgumentException("Unsupported error category: " + error.getErrorCode().getCategory());
             }
         }
-
-        @Override
-        public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-            RealmLog.error("Client Reset required for: " + session.getConfiguration().getPath());
-        }
     };
     // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
     private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
@@ -98,6 +99,19 @@ public void onClientResetRequired(SyncSession session, ClientResetHandler handle
     private static volatile AuthenticationServer authServer = new OkHttpAuthenticationServer();
     private static volatile UserStore userStore;
 
+    private static NetworkStateReceiver.ConnectionListener networkListener = new NetworkStateReceiver.ConnectionListener() {
+        @Override
+        public void onChange(boolean connectionAvailable) {
+            if (connectionAvailable) {
+                RealmLog.debug("NetworkListener: Connection available");
+                // notify all sessions
+                notifyNetworkIsBack();
+            } else {
+                RealmLog.debug("NetworkListener: Connection lost");
+            }
+        }
+    };
+
     static volatile SyncSession.ErrorHandler defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
 
     // Initialize the SyncManager
@@ -181,6 +195,10 @@ public static synchronized SyncSession getSession(SyncConfiguration syncConfigur
         if (session == null) {
             session = new SyncSession(syncConfiguration);
             sessions.put(syncConfiguration.getPath(), session);
+            if (sessions.size() == 1) {
+                RealmLog.debug("first session created add network listener");
+                NetworkStateReceiver.addListener(networkListener);
+            }
         }
 
         return session;
@@ -199,6 +217,10 @@ private static synchronized void removeSession(SyncConfiguration syncConfigurati
         if (syncSession != null) {
             syncSession.close();
         }
+        if (sessions.isEmpty()) {
+            RealmLog.debug("last session dropped, remove network listener");
+            NetworkStateReceiver.removeListener(networkListener);
+        }
     }
 
     static AuthenticationServer getAuthServer() {
@@ -248,6 +270,14 @@ private static synchronized void notifyErrorHandler(int errorCode, String errorM
         }
     }
 
+    private static synchronized void notifyNetworkIsBack() {
+        try {
+            nativeReconnect();
+        } catch (Exception exception) {
+            RealmLog.error(exception);
+        }
+    }
+
     /**
      * This is called from the Object Store (through JNI) to request an {@code access_token} for
      * the session specified by sessionPath.
@@ -303,4 +333,5 @@ static void simulateClientReset(SyncSession session) {
     protected static native void nativeInitializeSyncManager(String syncBaseDir);
     private static native void nativeReset();
     private static native void nativeSimulateSyncError(String realmPath, int errorCode, String errorMessage, boolean isFatal);
+    private static native void nativeReconnect();
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index f2c40281ba..b456318617 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -102,7 +102,7 @@ void notifySessionError(int errorCode, String errorMessage) {
         ErrorCode errCode = ErrorCode.fromInt(errorCode);
         if (errCode == ErrorCode.CLIENT_RESET) {
             // errorMessage contains the path to the backed up file
-            errorHandler.onClientResetRequired(this, new ClientResetHandler(errCode, "A Client Reset is required. " +
+            errorHandler.onError(this, new ClientResetRequiredError(errCode, "A Client Reset is required. " +
                     "Read more here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup.",
                     errorMessage, getConfiguration()));
         } else {
@@ -131,13 +131,9 @@ void close() {
          * When an exception is thrown in the error handler, the occurrence will be logged and the exception
          * will be ignored.
          *
-         * @param session {@link SyncSession} this error happened on.
-         * @param error type of error.
-         */
-        void onError(SyncSession session, ObjectServerError error);
-
-        /**
-         * An error that indicates the Realm needs to be reset.
+         * <p>
+         * When the {@code error.getErrorCode()} returns {@link ErrorCode#CLIENT_RESET}, it indicates the Realm
+         * needs to be reset and the {@code error} can be cast to {@link ClientResetRequiredError}.
          * <p>
          * A synced Realm may need to be reset because the Realm Object Server encountered an error and had
          * to be restored from a backup. If the backup copy of the remote Realm is of an earlier version
@@ -155,7 +151,7 @@ void close() {
          * The client reset process can be initiated in one of two ways:
          * <ol>
          *     <li>
-         *         Run {@link ClientResetHandler#executeClientReset()} manually. All Realm instances must be
+         *         Run {@link ClientResetRequiredError#executeClientReset()} manually. All Realm instances must be
          *         closed before this method is called.
          *     </li>
          *     <li>
@@ -170,11 +166,11 @@ void close() {
          * synchronized to the Object Server. Those changes will only be present in the backed up file. It is therefore
          * recommended to close all open Realm instances as soon as possible.
          *
+         *
          * @param session {@link SyncSession} this error happened on.
-         * @param handler reference to the specific Client Reset error.
-         * @see <a href="https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup">Client Recovery From A Backup</a>
+         * @param error type of error.
          */
-        void onClientResetRequired(SyncSession session, ClientResetHandler handler);
+        void onError(SyncSession session, ObjectServerError error);
     }
 
     String accessToken(final AuthenticationServer authServer) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 899411cd70..b1a78314af 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -70,14 +70,13 @@ synchronized SyncConfiguration initAndGetManagementRealmConfig(
                         .errorHandler(new SyncSession.ErrorHandler() {
                             @Override
                             public void onError(SyncSession session, ObjectServerError error) {
-                                RealmLog.error(String.format("Unexpected error with %s's management Realm: %s",
-                                        user.getIdentity(),
-                                        error.toString()));
-                            }
-
-                            @Override
-                            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-                                RealmLog.error("Client Reset required for users management Realm: " + user.toString());
+                                if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {
+                                    RealmLog.error("Client Reset required for user's management Realm: " + user.toString());
+                                } else {
+                                    RealmLog.error(String.format("Unexpected error with %s's management Realm: %s",
+                                            user.getIdentity(),
+                                            error.toString()));
+                                }
                             }
                         })
                         .modules(new PermissionModule())
@@ -172,9 +171,13 @@ public static SyncUser fromJson(String user) {
      * @throws IllegalArgumentException if the URL is malformed.
      */
     public static SyncUser login(final SyncCredentials credentials, final String authenticationUrl) throws ObjectServerError {
-        final URL authUrl;
+        URL authUrl;
         try {
             authUrl = new URL(authenticationUrl);
+            // If no path segment is provided append `/auth` which is the standard location.
+            if (authUrl.getPath().equals("")) {
+                authUrl = new URL(authUrl.toString() + "/auth");
+            }
         } catch (MalformedURLException e) {
             throw new IllegalArgumentException("Invalid URL " + authenticationUrl + ".", e);
         }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index b25ce7f907..c4364b53f0 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -6,7 +6,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.ClientResetHandler;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
@@ -74,16 +73,11 @@ public void onSuccess(SyncUser user) {
                             public void onError(SyncSession session, ObjectServerError error) {
                                 fail("Session failed: " + error);
                             }
-
-                            @Override
-                            public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-                                fail("Client Reset");
-                            }
                         })
                         .build();
 
                 final Realm realm = Realm.getInstance(config);
-                looperThread.testRealms.add(realm);
+                looperThread.addTestRealm(realm);
 
                 // FIXME: Right now we have no Java API for detecting when a session is established
                 // So we optimistically assume it has been connected after 1 second.
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index 2754115d44..0ad9688104 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -26,7 +26,6 @@
 import java.util.Date;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.ClientResetHandler;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
@@ -67,15 +66,10 @@ public void create_acceptOffer() {
                     public void onError(SyncSession session, ObjectServerError error) {
                         fail("Realm 1 unexpected error: " + error);
                     }
-
-                    @Override
-                    public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-                        fail("Client Reset");
-                    }
                 })
                 .build();
         final Realm realm1 = Realm.getInstance(config1);
-        looperThread.testRealms.add(realm1);
+        looperThread.addTestRealm(realm1);
         realm1.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -89,7 +83,7 @@ public void execute(Realm realm) {
         // 3. Create PermissionOffer
         final AtomicReference<String> offerId = new AtomicReference<String>(null);
         final Realm user1ManagementRealm = user1.getManagementRealm();
-        looperThread.testRealms.add(user1ManagementRealm);
+        looperThread.addTestRealm(user1ManagementRealm);
         user1ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -109,7 +103,7 @@ public void onSuccess() {
                 RealmResults<PermissionOffer> offers = user1ManagementRealm.where(PermissionOffer.class)
                         .equalTo("id", offerId.get())
                         .findAllAsync();
-                looperThread.keepStrongReference.add(offers);
+                looperThread.keepStrongReference(offers);
                 offers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
                     @Override
                     public void onChange(RealmResults<PermissionOffer> offers) {
@@ -119,7 +113,7 @@ public void onChange(RealmResults<PermissionOffer> offers) {
                             final String offerToken = offer.getToken();
                             final AtomicReference<String> offerResponseId = new AtomicReference<String>();
                             final Realm user2ManagementRealm = user2.getManagementRealm();
-                            looperThread.testRealms.add(user2ManagementRealm);
+                            looperThread.addTestRealm(user2ManagementRealm);
                             user2ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
                                 @Override
                                 public void execute(Realm realm) {
@@ -134,7 +128,7 @@ public void onSuccess() {
                                     RealmResults<PermissionOfferResponse> responses = user2ManagementRealm.where(PermissionOfferResponse.class)
                                             .equalTo("id", offerResponseId.get())
                                             .findAllAsync();
-                                    looperThread.keepStrongReference.add(responses);
+                                    looperThread.keepStrongReference(responses);
                                     responses.addChangeListener(new RealmChangeListener<RealmResults<PermissionOfferResponse>>() {
                                         @Override
                                         public void onChange(RealmResults<PermissionOfferResponse> responses) {
@@ -142,9 +136,9 @@ public void onChange(RealmResults<PermissionOfferResponse> responses) {
                                             if (response != null && response.isSuccessful() && response.getToken().equals(offerToken)) {
                                                 // 7. Response accepted. It should now be possible for user2 to access user1's Realm
                                                 Realm realm = Realm.getInstance(config2);
-                                                looperThread.testRealms.add(realm);
+                                                looperThread.addTestRealm(realm);
                                                 RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-                                                looperThread.keepStrongReference.add(dogs);
+                                                looperThread.keepStrongReference(dogs);
                                                 dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                                                     @Override
                                                     public void onChange(RealmResults<Dog> element) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index ffb20cd32c..dfd7b31859 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -32,7 +32,6 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import io.realm.ClientResetHandler;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
@@ -78,11 +77,6 @@ public void run() {
                                 public void onError(SyncSession session, ObjectServerError error) {
                                     fail("Sync failure: " + error);
                                 }
-
-                                @Override
-                                public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-                                    fail("Client Reset");
-                                }
                             })
                             .build();
                     Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
@@ -144,11 +138,6 @@ public void run() {
                                 public void onError(SyncSession session, ObjectServerError error) {
                                     fail("Sync failure: " + error);
                                 }
-
-                                @Override
-                                public void onClientResetRequired(SyncSession session, ClientResetHandler handler) {
-                                    fail("Client Reset");
-                                }
                             })
                             .build();
                     Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index e5347effc8..02d9ddf64c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -18,9 +18,11 @@
 
 public class Constants {
 
-    public static String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
-    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
+    public static final String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
+    public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
 
-    public static String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
-    public static String AUTH_URL = AUTH_SERVER_URL + "auth";
+    public static final String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
+    public static final String AUTH_URL = AUTH_SERVER_URL + "auth";
+
+    public static final long TEST_TIMEOUT_SECS = 300;
 }
diff --git a/tools/release.sh b/tools/release.sh
new file mode 100755
index 0000000000..33a01831b7
--- /dev/null
+++ b/tools/release.sh
@@ -0,0 +1,239 @@
+#!/usr/bin/env bash
+
+# Script to make release on the local machine.
+# See https://github.com/realm/realm-wiki/wiki/Java-Release-Checklist for more details.
+# FIXME: Only patch release is supported now.
+
+set -euo pipefail
+IFS=$'\n\t'
+
+usage() {
+cat <<EOF
+Usage: $0 <branch-to-release>
+EOF
+}
+
+######################################
+# Input Validation
+######################################
+
+if [ "$#" -eq 0 ] || [ "$#" -gt 1 ] ; then
+    usage
+    exit 1
+fi
+
+######################################
+# Variables
+######################################
+
+BRANCH_TO_RELEASE="$1"
+VERSION=""
+REALM_IO_PATH=${REALM_IO_PATH:-}
+REALM_JAVA_PATH=$(pwd)
+
+check_adb_device() {
+    if ! adb get-state 1>/dev/null 2>&1 ; then
+        read -n 1 -s -p -r "Attach a test device or start the emulator then press any key to continue..."
+        echo ""
+        check_adb_device
+    fi
+}
+
+check_env() {
+    echo "Checking environment..."
+
+    # Try to find s3cmd
+    path_to_s3cmd=$(which s3cmd)
+    if [[ ! -x "$path_to_s3cmd" ]] ; then
+        echo "Cannot find executable file 's3cmd'."
+        exit -1
+    fi
+    if [[ ! -e "$HOME/.s3cfg" ]] ; then
+        echo "'$HOME/.s3cfg' cannot be found."
+        exit -1
+    fi
+
+    # Check BinTray credentials
+    if ! grep "bintrayUser=realm" "$HOME/.gradle/gradle.properties" > /dev/null ; then
+        echo "'bintrayUser' is not set in the '$HOME/.gradle/gradle.properties'."
+        exit -1
+    fi
+
+    if ! grep "bintrayKey=.*" "$HOME/.gradle/gradle.properties" > /dev/null; then
+        echo "'bintrayKey' is not set in the '$HOME/.gradle/gradle.properties'."
+        exit -1
+    fi
+
+    # Check gradle params
+    if grep buildTargetABIs "$HOME/.gradle/gradle.properties" | grep -v "^#" > /dev/null ; then
+        echo "'buildTargetABIs' should be disabled in the '$HOME/.gradle/gradle.properties'."
+        exit -1
+    fi
+    if grep ccachePath "$HOME/.gradle/gradle.properties" | grep -v "^#" > /dev/null ; then
+        echo "'ccachePath' should be disabled in the '$HOME/.gradle/gradle.properties'."
+        exit -1
+    fi
+    if grep lcachePath "$HOME/.gradle/gradle.properties" | grep -v "^#" > /dev/null ; then
+        echo "'lcachePath' should be disabled in the '$HOME/.gradle/gradle.properties'."
+        exit -1
+    fi
+
+    if [[ -z ${REALM_IO_PATH} ]] ; then
+        REALM_IO_PATH="$(pwd)/../realm.io"
+    fi
+    if [[ ! -e ${REALM_IO_PATH} ]] ; then
+        echo "Please set 'REALM_IO_PATH' to the 'realm.io' repository path to publish javadoc."
+        exit -1
+    fi
+}
+
+prepare_branch() {
+    echo "Preparing release branch..."
+
+    git fetch --all
+    git checkout releases
+    git reset --hard origin/releases
+    if [[ "$BRANCH_TO_RELEASE" != "releases" ]] ; then
+        echo "Releasing from other branches than 'releases' is not supported right now."
+        exit -1
+    fi
+
+    git clean -xfd
+    git submodule update --init --recursive
+
+    if ! grep -q "SNAPSHOT" version.txt ; then
+        echo "'version.txt' doesn't contain 'SNAPSHOT'."
+        exit -1
+    fi
+
+    version_in_changelog=$(head -1 CHANGELOG.md | grep -o "[0-9]*\.[0-9]*\.[0-9]*")
+    VERSION=$(grep -o "[0-9]*\.[0-9]*\.[0-9]*" version.txt)
+    if [[ "${VERSION}" != "${version_in_changelog}" ]] ; then
+        echo "'version.txt' doens't match the entry in 'CHANGELOG.md'. ${VERSION} vs ${version_in_changelog}."
+        exit -1
+    fi
+
+    # Check if tag exists in remote
+    if git ls-remote --tags origin | grep "v${VERSION}" > /dev/null ; then
+        echo "Tag 'v${VERSION}' exists in remote!"
+        exit -1
+    fi
+    if git tag | grep "v${VERSION}" > /dev/null ; then
+        git tag -d "v${VERSION}"
+    fi
+
+    # Update date in change log
+    cur_date=$(date "+%F")
+    sed -i "1 s/YYYY-MM-DD/${cur_date}/" CHANGELOG.md
+    git add CHANGELOG.md
+    git commit -m "Update changelog date"
+
+    # This will create 2 new commits to change the version.txt. The top one is the next release version + SNAPSHOT.
+    ./gradlew release
+    # Checkout the one with current version number.
+    git checkout HEAD~1
+}
+
+build() {
+    echo "Building..."
+
+    ./gradlew assemble
+
+    echo "Verifying examples..."
+
+    check_adb_device
+
+    # Verify examples
+    (cd examples && ./gradlew uninstallAll && ./gradlew monkeyDebug)
+}
+
+upload_to_bintray() {
+    echo "Uploading artifacts to Bintray..."
+    # Upload to bintray
+    ./gradlew bintrayUpload
+
+    echo "Done."
+    echo "1. Log into BinTray(https://bintray.com) with the Realm account;"
+    echo "2. Goto https://bintray.com/realm/maven and check if there are 16 artifacts to publish."
+    echo "3. Press 'Publish'."
+    while true
+    do
+        read -r -p "Have you published 16 artifacts on Bintray? Type 'Yes' to continue... " input
+
+        case "$input" in
+            [yY][eE][sS])
+                break
+                ;;
+        esac
+    done
+}
+
+publish_distribution() {
+    echo "Publishing distribution package..."
+
+    # Create distribution package
+    ./gradlew distributionPackage
+    pushd build/outputs/distribution
+    unzip "realm-java-${VERSION}.zip"
+
+    # Test
+    check_adb_device
+    pushd examples/
+    ./gradlew uninstallAll
+    ./gradlew monkeyRelease
+    popd
+    popd
+    ./gradlew distribute
+}
+
+push_release() {
+    echo "Pushing releases branch to origin..."
+
+    # Push branch & tag
+    git checkout releases
+    git push origin releases
+    git push origin "v${VERSION}"
+}
+
+publish_javadoc() {
+    echo "Publishing javadoc..."
+    cd "${REALM_IO_PATH}"
+    git fetch --all
+    branch_name=publish_java_doc/${VERSION}
+    git checkout origin/master -b "${branch_name}"
+
+    while true
+    do
+        read -r -p "Type 'Yes' to clean uncommitted files in 'source/en/docs/java'... " input
+
+        case "$input" in
+            [yY][eE][sS])
+                break
+                ;;
+        esac
+    done
+    git clean -xfd ./source/en/docs/java/
+    bundle exec rake generate:java_docs[$VERSION]
+    cp -R "${REALM_JAVA_PATH}/realm/realm-library/build/docs/javadoc/*" ./source/en/docs/java/latest/api/
+    bundle exec rake generate:inject_ga_latest_java_api
+    git add ./source/en/docs/java/
+    git commit -m "Release realm-java doc ${VERSION}"
+    git push origin "${branch_name}"
+    path_to_hub=$(which hub)
+    if [[ ! -x "$path_to_hub" ]] ; then
+        echo "'hub' cannot be found in the executable path."
+        echo "Please create a pull request manually in realm.io repo with branch ${branch_name}."
+        exit -1
+    else
+        hub pull-request
+        echo "A pull request has been created for branch ${branch_name}."
+    fi
+}
+
+check_env
+prepare_branch
+build
+upload_to_bintray
+publish_distribution
+push_release
+publish_javadoc
diff --git a/version.txt b/version.txt
index 0628777500..b532f3dc33 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.1.0-SNAPSHOT
\ No newline at end of file
+3.1.4
\ No newline at end of file
