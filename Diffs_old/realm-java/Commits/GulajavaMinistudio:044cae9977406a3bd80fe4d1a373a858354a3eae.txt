diff --git a/CHANGELOG.md b/CHANGELOG.md
index 46d46cebd1..d56fa1432b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -14,7 +14,8 @@
 ### Bug Fixes
 
 * [ObjectServer] Using Android Network Security Configuration is necessary to install the custom root CA for tests (API >= 24) (#5970).
-
+* Fixes issue with the incremental build causing direct access to model without accessor to fail (#6056).
+* `RealmQuery.distinct()` is now correctly applied when calling `RealmQuery.count()` (#5958).
 
 ## 5.3.1 (2018-06-19)
 
diff --git a/realm-transformer/src/main/java/io/realm/transformer/Utils.java b/realm-transformer/src/main/java/io/realm/transformer/Utils.java
index 8d50ec7ac8..1357940076 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/Utils.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/Utils.java
@@ -72,7 +72,8 @@ public static String getMinSdk(Project project) {
     }
 
     public static boolean isSyncEnabled(Project project) {
-        return ((RealmPluginExtension) project.getExtensions().getByName("realm")).syncEnabled;
+        RealmPluginExtension realmExtension = (RealmPluginExtension) project.getExtensions().findByName("realm");
+        return realmExtension != null && realmExtension.syncEnabled;
     }
 
     public static List<File> getBootClasspath(Project project) {
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt
index 7839c95b22..0d972f6784 100644
--- a/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/ByteCodeModifier.kt
@@ -162,9 +162,16 @@ class BytecodeModifier {
         @Throws(CannotCompileException::class)
         override fun edit(fieldAccess: FieldAccess) {
             logger.debug("      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}")
-            if (isRealmModelClass(fieldAccess.enclosingClass) && isModelField(fieldAccess.field)) {
+
+            val fieldAccessCtClass: CtClass? = try { classPool.get(fieldAccess.className) } catch (e: NotFoundException) { null }
+            if (fieldAccessCtClass != null && isRealmModelClass(fieldAccessCtClass) && isModelField(fieldAccess.field)) {
                 logger.debug("        Realm: Manipulating ${ctClass.simpleName}.${behaviour.name}(): ${fieldAccess.fieldName}")
                 logger.debug("        Methods: ${ctClass.declaredMethods}")
+
+                // make sure accessors are added, otherwise javassist will fail with
+                // javassist.CannotCompileException: [source error] realmGet$id() not found in 'foo.Model'
+                addRealmAccessors(fieldAccessCtClass)
+
                 val fieldName: String = fieldAccess . fieldName
                 if (fieldAccess.isReader) {
                     fieldAccess.replace("\$_ = \$0.realmGet\$$fieldName();")
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt
index ffbd4d11ea..3ee6c117dd 100644
--- a/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmTransformer.kt
@@ -95,23 +95,23 @@ class RealmTransformer(val project: Project) : Transform() {
         timer.splitTime("Prepare output classes")
         if (build.hasNoOutput()) {
             // Abort transform as quickly as possible if no files where found for processing.
-            exitTransform(emptySet(), emptyList(), timer)
+            exitTransform(emptySet(), emptySet(), timer)
             return
         }
-        build.prepareReferencedClasses(referencedInputs!!);
+        build.prepareReferencedClasses(referencedInputs!!)
         timer.splitTime("Prepare referenced classes")
         build.markMediatorsAsTransformed()
         timer.splitTime("Mark mediators as transformed")
-        build.transformModelClasses();
+        build.transformModelClasses()
         timer.splitTime("Transform model classes")
-        build.transformDirectAccessToModelFields();
+        build.transformDirectAccessToModelFields()
         timer.splitTime("Transform references to model fields")
-        build.copyResourceFiles();
+        build.copyResourceFiles()
         timer.splitTime("Copy resource files")
         exitTransform(inputs, build.getOutputModelClasses(), timer)
     }
 
-    private fun exitTransform(inputs: Collection<TransformInput>, outputModelClasses: Collection<CtClass>, timer: Stopwatch) {
+    private fun exitTransform(inputs: Collection<TransformInput>, outputModelClasses: Set<CtClass>, timer: Stopwatch) {
         timer.stop()
         this.sendAnalytics(inputs, outputModelClasses)
     }
@@ -122,7 +122,7 @@ class RealmTransformer(val project: Project) : Transform() {
      * @param inputs the inputs provided by the Transform API
      * @param inputModelClasses a list of ctClasses describing the Realm models
      */
-    private fun sendAnalytics(inputs: Collection<TransformInput>, outputModelClasses: Collection<CtClass>) {
+    private fun sendAnalytics(inputs: Collection<TransformInput>, outputModelClasses: Set<CtClass>) {
         val disableAnalytics: Boolean = "true".equals(System.getenv()["REALM_DISABLE_ANALYTICS"])
         if (inputs.isEmpty() || disableAnalytics) {
             // Don't send analytics for incremental builds or if they have ben explicitly disabled.
@@ -147,16 +147,16 @@ class RealmTransformer(val project: Project) : Transform() {
             }
         }
 
-        val packages: Collection<String> = outputModelClasses.map {
+        val packages: Set<String> = outputModelClasses.map {
             it.packageName
-        }
+        }.toSet()
 
         val targetSdk: String? = Utils.getTargetSdk(project)
         val minSdk: String?  = Utils.getMinSdk(project)
 
-        if (disableAnalytics) {
+        if (!disableAnalytics) {
             val sync: Boolean = Utils.isSyncEnabled(project)
-            val analytics = RealmAnalytics(packages as Set, containsKotlin, sync, targetSdk, minSdk)
+            val analytics = RealmAnalytics(packages, containsKotlin, sync, targetSdk, minSdk)
             analytics.execute()
         }
     }
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt
index 7d8cd8c9ec..3e7c1e9d09 100644
--- a/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/build/BuildTemplate.kt
@@ -159,8 +159,8 @@ abstract class BuildTemplate(val project: Project, val outputProvider: Transform
         }
     }
 
-    fun getOutputModelClasses(): Collection<CtClass> {
-        return outputModelClasses
+    fun getOutputModelClasses(): Set<CtClass> {
+        return outputModelClasses.toSet()
     }
 
     protected abstract fun findModelClasses(classNames: Set<String>): Collection<CtClass>
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 103038444d..1601b59ea7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -24,6 +24,7 @@
 import java.lang.reflect.Field;
 import java.util.Date;
 import java.util.Locale;
+import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -2278,6 +2279,20 @@ public void count() {
         assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
     }
 
+    // Verify that count correctly when using distinct.
+    // See https://github.com/realm/realm-java/issues/5958
+    @Test
+    public void distinctCount() {
+        realm.executeTransaction(r -> {
+            for (int i = 0; i < 5; i++) {
+                AllTypes obj = new AllTypes();
+                obj.setColumnString("Foo");
+                realm.copyToRealm(obj);
+            }
+        });
+        assertEquals(1, realm.where(AllTypes.class).distinct(AllTypes.FIELD_STRING).count());
+    }
+
     // Tests isNull on link's nullable field.
     @Test
     public void isNull_linkField() {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 32ddf59c87..10327254d4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -1749,8 +1749,12 @@ public Date maximumDate(String fieldName) {
      */
     public long count() {
         realm.checkIfValid();
-
-        return this.query.count();
+        // The fastest way of doing `count()` is going through `TableQuery.count()`. Unfortunately
+        // doing this does not correctly apply all side effects of queries (like subscriptions). Also
+        // some queries constructs, like doing distinct is not easily supported this way.
+        // In order to get the best of both worlds we thus need to create a Java RealmResults object
+        // and then directly access the `Results` class from Object Store.
+        return lazyFindAll().size();
     }
 
     /**
@@ -1766,6 +1770,24 @@ public long count() {
         return createRealmResults(query, sortDescriptor, distinctDescriptor, true, SubscriptionAction.NO_SUBSCRIPTION);
     }
 
+    /**
+     * The same as {@link #findAll()} expect the RealmResult is not forcefully evaluated. This
+     * means this method will return a more "pure" wrapper around the Object Store Results class.
+     *
+     * This can be useful for internal usage where we still want to take advantage of optimizations
+     * and additional functionality provided by Object Store, but do not wish to trigger the query
+     * unless needed.
+     */
+    private OsResults lazyFindAll() {
+        realm.checkIfValid();
+        return createRealmResults(
+                query,
+                sortDescriptor,
+                distinctDescriptor,
+                false,
+                SubscriptionAction.NO_SUBSCRIPTION).osResults;
+    }
+
     /**
      * Finds all objects that fulfill the query conditions. This method is only available from a Looper thread.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 1f9ba3d387..2750ad689e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -614,6 +614,13 @@ public long count(long start, long end, long limit) {
         return nativeCount(nativePtr, start, end, limit);
     }
 
+    /**
+     * Returns only the number of matching objects.
+     * This method is very fast compared to evaluating a query completely, but it does not
+     * goes around any logic implemented in Object Store and other parts of the API that works
+     * on query results. So the primary use case for this method is testing.
+     */
+    @Deprecated
     public long count() {
         validateQuery();
         return nativeCount(nativePtr, 0, Table.INFINITE, Table.INFINITE);
