diff --git a/CHANGELOG.md b/CHANGELOG.md
index ef54a97dd0..d8b83a5e0c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,23 @@
 ## 3.2.0 (YYYY-MM-DD)
 
+### Enhancements
+
+* Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore' annotation (#4279).
+
+## 3.1.1 (2017-04-07)
+
+### Deprecated
+
+### Enhancements
+
+### Bug Fixes
+
+* Crash caused by Listeners on `RealmObject` getting triggered the 2nd time with different changed field (#4437).
+* Unintentionally exposing `StandardRealmSchema` (#4443).
+* Workaround for crashes on specific Samsung devices which are caused by a buggy `memmove` call (#3651).
+
+### Internal
+
 
 ## 3.1.0 (2017-04-05)
 
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index d64572ea3c..2ad7183dd2 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -30,6 +30,10 @@ class BytecodeModifier {
 
     private static final Logger logger = LoggerFactory.getLogger('realm-logger')
 
+    static boolean isModelField(CtField field) {
+        return !field.hasAnnotation(Ignore.class) && !Modifier.isTransient(field.getModifiers()) && !Modifier.isStatic(field.getModifiers())
+    }
+
     /**
      * Adds Realm specific accessors to a model class.
      * All the declared fields will be associated with a getter and a setter.
@@ -40,7 +44,7 @@ class BytecodeModifier {
         logger.debug "  Realm: Adding accessors to ${clazz.simpleName}"
         def methods = clazz.getDeclaredMethods()*.name
         clazz.declaredFields.each { CtField field ->
-            if (!Modifier.isStatic(field.getModifiers()) && !field.hasAnnotation(Ignore.class)) {
+            if (isModelField(field)) {
                 if (!methods.contains("realmGet\$${field.name}".toString())) {
                     clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
                 }
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index d7ca24a76a..b02d1a637b 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -121,7 +121,7 @@ class RealmTransformer extends Transform {
         def allManagedFields = []
         allModelClasses.each {
             allManagedFields.addAll(it.declaredFields.findAll {
-                !it.hasAnnotation(Ignore.class) && !Modifier.isStatic(it.getModifiers())
+                BytecodeModifier.isModelField(it)
             })
         }
         logger.debug "Managed Fields: ${allManagedFields*.name}"
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 02b1e46921..474c39cc8f 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -248,7 +248,6 @@ public boolean generate() {
         if (!checkReferenceTypes()) { return false; }
         if (!checkDefaultConstructor()) { return false; }
         if (!checkForFinalFields()) { return false; }
-        if (!checkForTransientFields()) { return false; }
         if (!checkForVolatileFields()) { return false; }
 
         return true; // Meta data was successfully generated
@@ -347,19 +346,6 @@ private boolean checkForFinalFields() {
         return true;
     }
 
-    private boolean checkForTransientFields() {
-        for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.TRANSIENT)) {
-                Utils.error(String.format(
-                        "Class \"%s\" contains illegal transient field \"%s\".",
-                        className,
-                        field.getSimpleName().toString()));
-                return false;
-            }
-        }
-        return true;
-    }
-
     private boolean checkForVolatileFields() {
         for (VariableElement field : fields) {
             if (field.getModifiers().contains(Modifier.VOLATILE)) {
@@ -374,40 +360,43 @@ private boolean checkForVolatileFields() {
     }
 
     private boolean categorizeField(Element element) {
-        VariableElement variableElement = (VariableElement) element;
+        VariableElement field = (VariableElement) element;
 
         // completely ignore any static fields
-        if (variableElement.getModifiers().contains(Modifier.STATIC)) { return true; }
+        if (field.getModifiers().contains(Modifier.STATIC)) { return true; }
 
-        if (variableElement.getAnnotation(Ignore.class) != null) { return true; }
+        // Ignore fields marked with @Ignore or if they are transient
+        if (field.getAnnotation(Ignore.class) != null || field.getModifiers().contains(Modifier.TRANSIENT)) {
+            return true;
+        }
 
-        if (variableElement.getAnnotation(Index.class) != null) {
-            if (!categorizeIndexField(element, variableElement)) { return false; }
+        if (field.getAnnotation(Index.class) != null) {
+            if (!categorizeIndexField(element, field)) { return false; }
         }
 
-        if (variableElement.getAnnotation(Required.class) != null) {
-            categorizeRequiredField(element, variableElement);
+        if (field.getAnnotation(Required.class) != null) {
+            categorizeRequiredField(element, field);
         } else {
             // The field doesn't have the @Required annotation.
             // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
             // nullableFields.
             // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
-            if (!Utils.isPrimitiveType(variableElement) && !Utils.isRealmList(variableElement)) {
-                nullableFields.add(variableElement);
+            if (!Utils.isPrimitiveType(field) && !Utils.isRealmList(field)) {
+                nullableFields.add(field);
             }
         }
 
-        if (variableElement.getAnnotation(PrimaryKey.class) != null) {
-            if (!categorizePrimaryKeyField(variableElement)) { return false; }
+        if (field.getAnnotation(PrimaryKey.class) != null) {
+            if (!categorizePrimaryKeyField(field)) { return false; }
         }
 
         // Check @LinkingObjects last since it is not allowed to be either @Index, @Required or @PrimaryKey
-        if (variableElement.getAnnotation(LinkingObjects.class) != null) {
-            return categorizeBacklinkField(variableElement);
+        if (field.getAnnotation(LinkingObjects.class) != null) {
+            return categorizeBacklinkField(field);
         }
 
         // Standard field that appear valid (more fine grained checks might fail later).
-        fields.add(variableElement);
+        fields.add(field);
 
         return true;
     }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index b888290450..1e43cb20b7 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -392,11 +392,11 @@ public void failOnFinalFields() throws Exception {
     }
 
     @Test
-    public void failOnTransientFields() throws Exception {
+    public void compileTransientFields() throws Exception {
         ASSERT.about(javaSource())
                 .that(transientModel)
                 .processedWith(new RealmProcessor())
-                .failsToCompile();
+                .compilesWithoutError();
     }
 
     @Test
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java b/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
index c130b20f7f..e54e4a26d4 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
@@ -23,18 +23,10 @@
     private int age;
 
     public String getName() {
-        return realmGet$name();
-    }
-
-    public void setName(String name) {
-        realmSet$name(name);
-    }
-
-    public String realmGet$name() {
         return name;
     }
 
-    public void realmSet$name(String name) {
+    public void setName(String name) {
         this.name = name;
     }
 
@@ -53,32 +45,4 @@ public void setAge(int age) {
     public void realmSet$age(int age) {
         this.age = age;
     }
-
-    @Override
-    public String toString() {
-        return "Simple{" +
-                "name='" + name + '\'' +
-                ", age=" + age +
-                '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        Simple simple = (Simple) o;
-
-        if (age != simple.age) return false;
-        if (name != null ? !name.equals(simple.name) : simple.name != null) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = name != null ? name.hashCode() : 0;
-        result = 31 * result + age;
-        return result;
-    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
index c36aef4b56..947b197eea 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
@@ -18,8 +18,6 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,6 +25,7 @@
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
@@ -289,6 +288,53 @@ public void changeAllFields() {
         realm.commitTransaction();
     }
 
+    // Relevant to https://github.com/realm/realm-java/issues/4437
+    // When the object listener triggered at the 2nd time, the local ref m_field_names_array has not been reset and it
+    // contains an invalid local ref which has been released before.
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeDifferentFieldOneAfterAnother() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        final AtomicBoolean stringChanged = new AtomicBoolean(false);
+        final AtomicBoolean longChanged = new AtomicBoolean(false);
+        final AtomicBoolean floatChanged = new AtomicBoolean(false);
+
+        allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                assertEquals(1, changeSet.getChangedFields().length);
+                if (changeSet.isFieldChanged(AllTypes.FIELD_STRING)) {
+                    assertFalse(stringChanged.get());
+                    stringChanged.set(true);
+                } else if (changeSet.isFieldChanged(AllTypes.FIELD_LONG)) {
+                    assertFalse(longChanged.get());
+                    longChanged.set(true);
+                } else if (changeSet.isFieldChanged(AllTypes.FIELD_FLOAT)) {
+                    assertTrue(stringChanged.get());
+                    assertTrue(longChanged.get());
+                    assertFalse(floatChanged.get());
+                    floatChanged.set(true);
+                    looperThread.testComplete();
+                } else {
+                    fail();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        allTypes.setColumnString("42");
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        allTypes.setColumnLong(42);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        allTypes.setColumnFloat(42.0f);
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread(before = PopulateOneAllTypes.class)
     public void findFirstAsync_changeSetIsNullWhenQueryReturns() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index 5b5084f004..3e18d70e5a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -54,6 +54,7 @@ public void setUp() {
         object.setNotIndexString("String 1");
         object.setIndexString("String 2");
         object.setIgnoreString("String 3");
+        object.setTransientString("String 4");
         realm.commitTransaction();
     }
 
@@ -67,7 +68,8 @@ public void tearDown() {
     @Test
     public void ignore() {
         Table table = realm.getTable(AnnotationTypes.class);
-        assertEquals(-1, table.getColumnIndex("ignoreString"));
+        assertEquals(-1, table.getColumnIndex(AnnotationTypes.FIELD_IGNORE_STRING));
+        assertEquals(-1, table.getColumnIndex(AnnotationTypes.FIELD_TRANSIENT_STRING));
     }
 
     // Tests if "index" annotation works with supported types.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
index 9926b7bce6..894804edbb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
@@ -23,6 +23,11 @@
 
 public class AnnotationTypes extends RealmObject {
 
+    public static final String FIELD_INDEX_STRING = "indexString";
+    public static final String FIELD_NOT_INDEX_STRING = "notIndexString";
+    public static final String FIELD_IGNORE_STRING= "ignoreString";
+    public static final String FIELD_TRANSIENT_STRING = "transientString";
+
     @PrimaryKey
     private long id;
 
@@ -33,6 +38,8 @@
     @Ignore
     private String ignoreString;
 
+    private transient String transientString;
+
     public long getId() {
         return id;
     }
@@ -65,5 +72,11 @@ public void setIgnoreString(String ignoreString) {
         this.ignoreString = ignoreString;
     }
 
+    public String getTransientString() {
+        return transientString;
+    }
 
+    public void setTransientString(String transientString) {
+        this.transientString = transientString;
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 5913e1872e..11c3d43caf 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -17,6 +17,10 @@ set(CMAKE_VERBOSE_MAKEFILE ON)
 # Generate compile_commands.json
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 
+# Initialize common compile & link flags.
+set(REALM_LINKER_FLAGS "")
+set(REALM_COMMON_CXX_FLAGS "")
+
 # Setup lcache
 if(NDK_LCACHE)
     set(CMAKE_CXX_CREATE_SHARED_LIBRARY "${NDK_LCACHE} ${CMAKE_CXX_CREATE_SHARED_LIBRARY}")
@@ -123,6 +127,14 @@ elseif (ARMEABI_V7A)
     set(ABI_CXX_FLAGS "-mthumb -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16")
 endif()
 
+# Hack the memmove bug on Samsung device.
+if (ARMEABI OR ARMEABI_V7A)
+    set(REALM_LINKER_FLAGS "${REALM_LINKER_FLAGS} -Wl,--wrap,memmove -Wl,--wrap,memcpy")
+    set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_WRAP_MEMMOVE=1")
+else()
+    set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_WRAP_MEMMOVE=0")
+endif()
+
 #FIXME uninitialized is reported by query_expression.hpp:1070
 #      d.init(ValueBase::m_from_link_list, ValueBase::m_values, D{});
 #FIXME maybe-uninitialized is reported by table_view.cpp:272:15:
@@ -131,7 +143,7 @@ endif()
 set(WARNING_CXX_FLAGS "-Werror -Wall -Wextra -pedantic -Wmissing-declarations \
     -Wempty-body -Wparentheses -Wunknown-pragmas -Wunreachable-code \
     -Wno-missing-field-initializers  -Wno-maybe-uninitialized -Wno-uninitialized")
-set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
+set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
 if (build_SYNC)
     set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_ENABLE_SYNC=1")
 endif()
@@ -143,7 +155,6 @@ set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
 
 # Set link flags
-set(REALM_LINKER_FLAGS "")
 if (build_SYNC)
     set(REALM_LINKER_FLAGS "${REALM_LINKER_FLAGS} -lz")
 endif()
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index c35c042672..95c3fa24c5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -122,8 +122,10 @@ struct ChangeCallback {
         m_wrapper->m_row_object_weak_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
             static JavaMethod notify_change_listeners(env, row_obj, "notifyChangeListeners",
                                                       "([Ljava/lang/String;)V");
-            env->CallVoidMethod(row_obj, notify_change_listeners, m_field_names_array);
+            env->CallVoidMethod(row_obj, notify_change_listeners, m_deleted ? nullptr : m_field_names_array);
         });
+        m_field_names_array = nullptr;
+        m_deleted = false;
     }
 
     void error(std::exception_ptr err)
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 48e47cf726..ab772f42bd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -17,6 +17,7 @@
 #include <jni.h>
 
 #include "jni_util/jni_utils.hpp"
+#include "jni_util/hack.hpp"
 
 #include <realm/string_data.hpp>
 #include <realm/unicode.hpp>
@@ -37,6 +38,9 @@ const string TABLE_PREFIX("class_");
 
 JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 {
+    // Workaround for some known bugs in system calls on specific devices.
+    hack_init();
+
     JNIEnv* env;
     if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
         return JNI_ERR;
diff --git a/realm/realm-library/src/main/cpp/jni_util/hack.cpp b/realm/realm-library/src/main/cpp/jni_util/hack.cpp
new file mode 100644
index 0000000000..1ca6414ee0
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/hack.cpp
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "hack.hpp"
+#include "log.hpp"
+
+#include <string.h>
+
+#include <realm/util/assert.hpp>
+
+#ifndef REALM_WRAP_MEMMOVE
+#error "REALM_WRAP_MEMMOVE is not defined!"
+#endif
+
+#if REALM_WRAP_MEMMOVE
+extern "C" {
+void* __wrap_memmove(void *dest, const void *src, size_t n);
+void* __real_memmove(void *dest, const void *src, size_t n);
+
+void* __wrap_memcpy(void *dest, const void *src, size_t n);
+void* __real_memcpy(void *dest, const void *src, size_t n);
+}
+
+using namespace realm::jni_util;
+
+typedef void* (*MemMoveFunc)(void *dest, const void *src, size_t n);
+static MemMoveFunc s_wrap_memmove_ptr = &__real_memmove;
+static MemMoveFunc s_wrap_memcpy_ptr = &__real_memcpy;
+
+static void* hacked_memmove(void* s1, const void* s2, size_t n)
+{
+    // adapted from https://github.com/dryc/libc11/blob/master/src/string/memmove.c
+    char* dest = (char*)s1;
+    const char* src = (const char*)s2;
+    if (dest <= src) {
+        while (n--) {
+            *dest++ = *src++;
+        }
+    }
+    else {
+        src += n;
+        dest += n;
+        while (n--) {
+            *--dest = *--src;
+        }
+    }
+    return static_cast<void*>(s1);
+}
+
+static void* hacked_memcpy(void* s1, const void* s2, size_t n)
+{
+    // adapted from https://github.com/dryc/libc11/blob/master/src/string/memcpy.c
+    char* dest = (char*)s1;
+    const char* src = (const char*)s2;
+    while (n--) {
+        *dest++ = *src++;
+    }
+    return static_cast<void*>(s1);
+}
+
+void* __wrap_memmove(void *dest, const void *src, size_t n)
+{
+    return (*s_wrap_memmove_ptr)(dest, src, n);
+}
+
+void* __wrap_memcpy(void *dest, const void *src, size_t n)
+{
+    return (*s_wrap_memcpy_ptr)(dest, src, n);
+}
+
+
+// See https://github.com/realm/realm-java/issues/3651#issuecomment-290290228
+// There is a bug in memmove for some Samsung devices which will return "dest-n" instead of dest.
+// The bug was originally found by QT, see https://bugreports.qt.io/browse/QTBUG-34984 .
+// To work around it, we use linker's wrap feature to use a pure C implementation of memmove if the device has the
+// problem.
+static void check_memmove()
+{
+    char* array = strdup("Foobar");
+    size_t len = strlen(array);
+    void* ptr = __real_memmove(array + 1, array, len - 1);
+    if (ptr != array + 1 || strncmp(array, "FFooba", len) != 0) {
+        Log::e("memmove is broken on this device. Switching to the builtin implementation.");
+        s_wrap_memmove_ptr = &hacked_memmove;
+        s_wrap_memcpy_ptr  = &hacked_memcpy;
+    }
+    free(array);
+}
+#endif
+
+namespace realm {
+namespace jni_util {
+
+void hack_init()
+{
+#if REALM_WRAP_MEMMOVE
+    check_memmove();
+#endif
+}
+
+}
+}
+
diff --git a/realm/realm-library/src/main/cpp/jni_util/hack.hpp b/realm/realm-library/src/main/cpp/jni_util/hack.hpp
new file mode 100644
index 0000000000..62ac347ee5
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/hack.hpp
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_HACK_HPP
+#define REALM_JNI_UTIL_HACK_HPP
+
+namespace realm {
+namespace jni_util {
+
+// Workaround bugs on some devices.
+void hack_init();
+
+}
+}
+#endif // REALM_JNI_UTIL_HACK_HPP
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
index 13097cf10a..c7908c3765 100644
--- a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
@@ -21,6 +21,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import io.realm.internal.Table;
+
 
 /**
  * Class for interacting with the Realm schema using a dynamic API. This makes it possible
@@ -61,6 +63,26 @@ public boolean contains(String className) {
             return schema.containsKey(className);
         }
 
+        @Override
+        Table getTable(Class<? extends RealmModel> clazz) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        Table getTable(String className) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        OsRealmObjectSchema getSchemaForClass(String className) {
+            throw new UnsupportedOperationException();
+        }
+
         @Override
         public void remove(String className) {
             throw new UnsupportedOperationException();
@@ -163,6 +185,26 @@ public boolean contains(String className) {
         return dynamicClassToSchema.containsKey(className);
     }
 
+    @Override
+    Table getTable(Class<? extends RealmModel> clazz) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    Table getTable(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    OsRealmObjectSchema getSchemaForClass(String className) {
+        throw new UnsupportedOperationException();
+    }
+
     static void checkEmpty(String str) {
         if (str == null || str.isEmpty()) {
             throw new IllegalArgumentException("Null or empty class names are not allowed");
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 74025c2544..0648341216 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -49,9 +49,9 @@
  * The types <code>short</code>, <code>int</code>, and <code>long</code> are mapped to <code>long</code> when storing
  * within a Realm.
  * <p>
- * The only restriction a RealmObject has is that fields are not allowed to be final, transient' or volatile.
+ * The only restriction a RealmObject has is that fields are not allowed to be final or volatile.
  * Any method as well as public fields are allowed. When providing custom constructors, a public constructor with
- * no arguments must be declared and be empty.
+ * no arguments must be declared.
  * <p>
  * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and don't require either a
  * getter or setter.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index ea53642122..4b3dcda6c9 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -145,4 +145,9 @@ private void checkIndices() {
             throw new IllegalStateException("Attempt to use column index before set.");
         }
     }
+
+    abstract Table getTable(Class<? extends RealmModel> clazz);
+    abstract Table getTable(String className);
+    abstract RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz);
+    abstract RealmObjectSchema getSchemaForClass(String className);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
index 3d3933d451..bcec1169fb 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -203,6 +203,7 @@ private void checkHasTable(String className, String errorMsg) {
         }
     }
 
+    @Override
     Table getTable(String className) {
         className = Table.TABLE_PREFIX + className;
         Table table = dynamicClassToTable.get(className);
@@ -217,6 +218,7 @@ Table getTable(String className) {
         return table;
     }
 
+    @Override
     Table getTable(Class<? extends RealmModel> clazz) {
         Table table = classToTable.get(clazz);
         if (table != null) { return table; }
@@ -238,6 +240,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
         return table;
     }
 
+    @Override
     StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         StandardRealmObjectSchema classSchema = classToSchema.get(clazz);
         if (classSchema != null) { return classSchema; }
@@ -259,6 +262,7 @@ StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         return classSchema;
     }
 
+    @Override
     StandardRealmObjectSchema getSchemaForClass(String className) {
         className = Table.TABLE_PREFIX + className;
         StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
