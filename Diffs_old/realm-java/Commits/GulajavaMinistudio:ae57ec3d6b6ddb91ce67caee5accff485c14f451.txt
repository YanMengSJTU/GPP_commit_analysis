diff --git a/CHANGELOG.md b/CHANGELOG.md
index ba50900c1a..594942d070 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,22 @@
+## 5.10.0(2019-03-22)
+
+## Enhancements
+* [ObjectServer] Added 4 new fields to query-based Subscriptions: `createdAt`, `updatedAt`, `expiresAt` and `timeToLive`. These make it possible to better reason about and control current subscriptions. (Issue [#6453](https://github.com/realm/realm-java/issues/6453))
+* [ObjectServer] Added the option of updating the query controlled by a Subscription using either `RealmQuery.findAllAsync(String name, boolean update)`,  `RealmQuery.subscribe(String name, boolean update)` or `Subscription.setQuery(RealmQuery query)`. (Issue [#6453](https://github.com/realm/realm-java/issues/6453))
+* [ObjectServer] Added the option of setting a time-to-live for subscriptions. Setting this will automatically delete the subscription after the provided TTL has expired and the subscription hasn't been used. (Issue [#6453](https://github.com/realm/realm-java/issues/6453))
+
+## Fixed
+* Dates returned from the Realm file no longer overflow or underflow if they exceed `Long.MAX_VALUE` or `Long.MIN_VALUE` but instead clamp to their respective value. (Issue [#2722](https://github.com/realm/realm-java/issues/2722)) 
+
+## Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats).
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+## Internal
+* Updated to Object Store commit: e9819ed9c77ed87b5d7bed416a76cd5bcf255802
+
+
 ## 5.9.1(2019-02-21)
 
 ### Enhancements
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index bd1ed35c67..e7ab4d0c69 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -163,7 +163,7 @@ public void iOSDataTypesMinimumValues() throws IOException {
             assertEquals(-Double.MAX_VALUE, obj.getDoubleCol(), 0D);
             assertArrayEquals(new byte[0], obj.getByteCol());
             assertEquals("", obj.getStringCol());
-            assertEquals(0x8000000000000000L * 1000L, obj.getDateCol().getTime());
+            assertEquals(Long.MIN_VALUE, obj.getDateCol().getTime());
         }
     }
 
@@ -184,7 +184,7 @@ public void iOSDataTypesMaximumValues() throws IOException {
             assertEquals(Double.MAX_VALUE, obj.getDoubleCol(), 0D);
             assertArrayEquals(new byte[0], obj.getByteCol());
             assertEquals("", obj.getStringCol());
-            assertEquals(0x8000000000000000L * 1000L, obj.getDateCol().getTime());
+            assertEquals(Long.MIN_VALUE, obj.getDateCol().getTime());
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
index 8847528a20..b8dbec776b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
@@ -38,4 +38,16 @@ public void nativeExceptions() {
             }
         }
     }
+
+    @Test
+    public void clampMaxTimestamps() {
+        assertEquals(Long.MAX_VALUE, TestUtil.getDateFromTimestamp(Long.MAX_VALUE, 999999999));
+        assertEquals(Long.MAX_VALUE, TestUtil.getDateFromTimestamp((Long.MAX_VALUE / 1000) + 1, 0)); // 1 second above MAX in milliseconds
+    }
+
+    @Test
+    public void clampMinTimestamps() {
+        assertEquals(Long.MIN_VALUE, TestUtil.getDateFromTimestamp(Long.MIN_VALUE, -999999999));
+        assertEquals(Long.MIN_VALUE, TestUtil.getDateFromTimestamp((Long.MIN_VALUE / 1000) - 1, 0)); // 1 second below MIN in milliseconds
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 914b2e76c4..a5c0c12c32 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -563,11 +563,10 @@ public void isConnected_falseForInvalidUser() {
     }
 
     @Test
-    public void close_doesNotThrowIfCalledWhenRealmIsClosed() {
+    public void stop_doesNotThrowIfCalledWhenRealmIsClosed() {
         Realm realm = Realm.getInstance(configuration);
         SyncSession session = SyncManager.getSession(configuration);
         realm.close();
         session.stop();
-        assertEquals(SyncSession.State.INACTIVE, session.getState());
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java
index 53ff16cdc3..1037ff8200 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java
@@ -15,6 +15,7 @@
  */
 package io.realm;
 
+import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -23,6 +24,11 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.util.Date;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
 import io.realm.rule.RunInLooperThread;
@@ -63,6 +69,10 @@ public void tearDown() {
         }
     }
 
+    private String randomName() {
+        return UUID.randomUUID().toString();
+    }
+
     private Realm getPartialRealm() {
         SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/partialSync")
                 .build();
@@ -83,27 +93,90 @@ public void subscribe() {
         realm = getPartialRealm();
         realm.beginTransaction();
         RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Date now = new Date();
+        SystemClock.sleep(2);
         Subscription sub = query.subscribe();
         assertTrue(sub.getName().startsWith("[AllTypes] "));
         assertEquals(Subscription.State.PENDING, sub.getState());
         assertEquals("", sub.getErrorMessage());
         assertEquals(query.getDescription(), sub.getQueryDescription());
         assertEquals("AllTypes", sub.getQueryClassName());
+        assertTrue(now.getTime() < sub.getCreatedAt().getTime());
+        assertTrue(now.getTime() < sub.getUpdatedAt().getTime());
+        assertTrue(sub.getCreatedAt().getTime() == sub.getUpdatedAt().getTime());
+        assertEquals(Long.MAX_VALUE, sub.getTimeToLive());
+        assertEquals(new Date(Long.MAX_VALUE), sub.getExpiresAt());
     }
 
     @Test
     public void subscribe_withName() {
+        String name = randomName();
         realm = getPartialRealm();
         realm.beginTransaction();
         RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
-        Subscription sub = query.subscribe("sub");
-        assertEquals("sub", sub.getName());
+        Subscription sub = query.subscribe(name);
+        assertEquals(name, sub.getName());
         assertEquals(Subscription.State.PENDING, sub.getState());
         assertEquals("", sub.getErrorMessage());
         assertEquals(query.getDescription(), sub.getQueryDescription());
         assertEquals("AllTypes", sub.getQueryClassName());
     }
 
+    @Test
+    public void subscribe_withTimeToLive() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Date now = new Date();
+        SystemClock.sleep(2);
+        Subscription sub = query.subscribe(randomName(), 0, TimeUnit.MILLISECONDS);
+        assertTrue(now.getTime() < sub.getCreatedAt().getTime());
+        assertEquals(sub.getCreatedAt(), sub.getUpdatedAt());
+        assertEquals(sub.getUpdatedAt(), sub.getExpiresAt());
+        assertEquals(0, sub.getTimeToLive());
+    }
+
+    @Test
+    public void subscribeOrUpdate() {
+        String name = randomName();
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query1 = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Subscription sub1 = query1.subscribe(name);
+        Date firstUpdate = sub1.getUpdatedAt();
+        RealmQuery<AllTypes> query2 = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_BOOLEAN, false);
+        SystemClock.sleep(2);
+        Subscription sub2 = query2.subscribeOrUpdate(name);
+        assertEquals(sub1, sub2);
+        assertEquals(query2.getDescription(), sub2.getQueryDescription());
+        assertTrue(firstUpdate.getTime() < sub2.getUpdatedAt().getTime());
+    }
+
+    @Test
+    public void subscribeOrUpdate_failsWithDifferentQueryType() {
+        String name = randomName();
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo").subscribe(name);
+        try {
+            realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_BOOLEAN, false).subscribeOrUpdate(name);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void subscribeOrUpdate_withTimeToLive() {
+        String name = randomName();
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo").subscribe(name, 10, TimeUnit.MILLISECONDS);
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_BOOLEAN, false);
+        Subscription sub = query.subscribeOrUpdate(name, 20, TimeUnit.DAYS);
+        assertEquals(TimeUnit.MILLISECONDS.convert(20, TimeUnit.DAYS), sub.getTimeToLive());
+        assertEquals(query.getDescription(), sub.getQueryDescription());
+    }
+
     @Test
     public void subscribe_throwIfNameIsAlreadyUsed() {
         realm = getPartialRealm();
@@ -177,4 +250,79 @@ public void subscribe_throwIfRealmClosed() {
         } catch (IllegalStateException ignore) {
         }
     }
+
+    @Test
+    public void subscription_setQuery() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query1 = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Date now = new Date();
+        SystemClock.sleep(2);
+        Subscription sub = query1.subscribe("sub3");
+        RealmQuery<AllTypes> query2 = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_BOOLEAN, false);
+        assertEquals("AllTypes", sub.getQueryClassName());
+        assertTrue(now.getTime() < sub.getUpdatedAt().getTime());
+        Date query1Updated = sub.getUpdatedAt();
+        SystemClock.sleep(2);
+        sub.setQuery(query2);
+        assertEquals(query2.getDescription(), sub.getQueryDescription());
+        assertEquals("AllTypes", sub.getQueryClassName());
+        assertTrue(query1Updated.getTime() < sub.getUpdatedAt().getTime());
+    }
+
+    @Test
+    public void subscription_setQuery_wrongTypeThrows() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query1 = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Subscription sub = query1.subscribe("sub4");
+        RealmQuery<AllJavaTypes> query2 = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_BOOLEAN, false);
+        try {
+            sub.setQuery(query2);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("It is only allowed to replace a query"));
+        }
+    }
+
+    @Test
+    public void subscription_setTimeToLive() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+
+        Subscription sub = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo").subscribe();
+        assertEquals(Long.MAX_VALUE, sub.getExpiresAt().getTime());
+        assertEquals(Long.MAX_VALUE, sub.getTimeToLive());
+
+        Date now = new Date();
+        Date now_plus_1_sec = new Date(now.getTime() + 1000);
+        Date now_plus_11_sec = new Date(now.getTime() + 11000);
+        SystemClock.sleep(2);
+        sub.setTimeToLive(10, TimeUnit.SECONDS);
+        assertEquals(10000, sub.getTimeToLive());
+        assertTrue(now.getTime() < sub.getUpdatedAt().getTime());
+        assertTrue(now.getTime() < sub.getExpiresAt().getTime());
+        assertTrue(sub.getUpdatedAt().getTime() < now_plus_1_sec.getTime());
+        assertTrue(sub.getExpiresAt().getTime() < now_plus_11_sec.getTime());
+    }
+
+    @Test
+    public void subscription_setTimeToLive_illegalValuesThrows() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        Subscription sub = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo").subscribe();
+        try {
+            sub.setTimeToLive(-1, TimeUnit.SECONDS);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("A negative time-to-live is not allowed"));
+        }
+        try {
+            sub.setTimeToLive(0, null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-null 'timeUnit' required"));
+        }
+    }
+
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
index 521b5443fa..270007ac3e 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
@@ -4,6 +4,7 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -242,6 +243,7 @@ public void sslVerifyCallback_shouldFailOnExpiredCert() {
         assertFalse(SyncManager.sslVerifyCallback(serverAddress, pem_depth0, 0));
     }
 
+    @Ignore("FIXME: Certificate expired")
     @Test
     public void sslVerifyCallback_shouldVerifyHostname() {
         // simulating the following certificate chain
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
index 03c66b6b49..d1671d404c 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
@@ -40,7 +40,8 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmQuery_nativeSerializeQuery(JNIEnv*
     return to_jstring(env, "");
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_RealmQuery_nativeSubscribe(JNIEnv* env, jclass, jlong shared_realm_ptr, jstring j_name, jlong table_query_ptr, jlong descriptor_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_RealmQuery_nativeSubscribe(JNIEnv* env, jclass, jlong shared_realm_ptr,
+        jstring j_name, jlong table_query_ptr, jlong descriptor_ptr, REALM_UNUSED jlong time_to_live_ms, REALM_UNUSED jboolean update)
 {
     TR_ENTER()
     try {
@@ -50,7 +51,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_RealmQuery_nativeSubscribe(JNIEnv* env, jc
         auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
         Results r(realm, *query, *descriptor);
 #if REALM_ENABLE_SYNC
-        RowExpr row = partial_sync::subscribe_blocking(r, name);
+        RowExpr row = partial_sync::subscribe_blocking(r, name, util::Optional<int64_t>(time_to_live_ms), update);
         return to_jlong_or_not_found(row.get_index());
 #endif
     }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index c801492d88..6e83b62c1d 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -76,16 +76,19 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsRealmConfig_nativeGetFinalizerP
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreate(JNIEnv* env, jclass, jstring j_realm_path,
+                                                                          jstring j_fifo_fallback_dir,
                                                                           jboolean enable_cache,
                                                                           jboolean enable_format_upgrade)
 {
     TR_ENTER()
     try {
         JStringAccessor realm_path(env, j_realm_path);
+        JStringAccessor fifo_fallback_dir(env, j_fifo_fallback_dir);
         auto* config_ptr = new Realm::Config();
         config_ptr->path = realm_path;
         config_ptr->cache = enable_cache;
         config_ptr->disable_format_upgrade = !enable_format_upgrade;
+        config_ptr->fifo_files_fallback_path = fifo_fallback_dir;
         return reinterpret_cast<jlong>(config_ptr);
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
index 7b7fcb5198..eb111592a8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
@@ -1,6 +1,11 @@
+#define __STDC_LIMIT_MACROS // See https://stackoverflow.com/a/3233069/1389357
+#include <cstdint>
+
 #include "io_realm_internal_TestUtil.h"
 #include "util.hpp"
 
+#include <realm/timestamp.hpp>
+
 static jstring throwOrGetExpectedMessage(JNIEnv* env, jlong testcase, bool should_throw);
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TestUtil_getMaxExceptionNumber(JNIEnv*, jclass)
@@ -19,6 +24,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TestUtil_testThrowExceptions(JNIEn
     throwOrGetExpectedMessage(env, exception_kind, true);
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TestUtil_getDateFromTimestamp(JNIEnv*, jclass, jlong seconds, jint nanoseconds)
+{
+    return to_milliseconds(realm::Timestamp(static_cast<int64_t>(seconds), static_cast<int32_t>(nanoseconds)));
+}
+
 static jstring throwOrGetExpectedMessage(JNIEnv* env, jlong testcase, bool should_throw)
 {
     std::string expect;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
index 5f9641eea1..d41e02f5c2 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
@@ -39,14 +39,14 @@ static void finalize_subscription(jlong ptr)
     delete reinterpret_cast<SubscriptionWrapper*>(ptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_sync_OsSubscription_nativeCreate(JNIEnv* env, jclass, jlong results_ptr, jstring j_subscription_name)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_sync_OsSubscription_nativeCreateOrUpdate(JNIEnv* env, jclass, jlong results_ptr, jstring j_subscription_name, jlong time_to_live, jboolean update)
 {
     TR_ENTER()
     try {
         const auto results = reinterpret_cast<ResultsWrapper*>(results_ptr);
         JStringAccessor subscription_name(env, j_subscription_name);
         auto key = subscription_name.is_null_or_empty() ? util::none : util::Optional<std::string>(subscription_name);
-        auto subscription = partial_sync::subscribe(results->collection(), key);
+        auto subscription = partial_sync::subscribe(results->collection(), key, util::Optional<int64_t>(time_to_live), update);
         auto wrapper = new SubscriptionWrapper(std::move(subscription));
         return reinterpret_cast<jlong>(wrapper);
     }
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index f964c2640f..e9819ed9c7 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit f964c2640f635e76839559cb703732e9e906ba4c
+Subproject commit e9819ed9c77ed87b5d7bed416a76cd5bcf255802
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 4aa3a5474d..fd76c6de25 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -138,6 +138,9 @@ void ConvertException(JNIEnv* env, const char* file, int line)
     catch (partial_sync::ExistingSubscriptionException& e) {
         ThrowException(env, IllegalArgument, e.what());
     }
+    catch (partial_sync::QueryTypeMismatchException& e) {
+        ThrowException(env, IllegalArgument, e.what());
+    }
 #endif
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 6b9c2d2a3f..da2d4d5df3 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -70,6 +70,8 @@ std::string num_to_string(T pNumber)
 
 #define MAX_JINT 0x7FFFFFFFL
 #define MAX_JSIZE MAX_JINT
+#define MAX_JLONG 0x7fffffffffffffffLL
+#define MIN_JLONG (-MAX_JLONG-1)
 
 // TODO: Clean up those marcos. Casting with marcos reduces the readability, and it is actually breaking the C++ type
 // conversion. e.g.: You cannot cast a pointer with S64 below.
@@ -496,12 +498,32 @@ class JStringAccessor {
 
 inline jlong to_milliseconds(const realm::Timestamp& ts)
 {
-    // From core's reference implementation aka unit test
-    // FIXME: check for overflow/underflow
     const int64_t seconds = ts.get_seconds();
     const int32_t nanoseconds = ts.get_nanoseconds();
-    const int64_t milliseconds = seconds * 1000 + nanoseconds / 1000000; // This may overflow
-    return milliseconds;
+    int64_t result_ms = seconds;
+
+    // Convert seconds to milliseconds.
+    // Clamp to MAX/MIN in case of overflow/underflow.
+    int64_t sec_min_limit = MIN_JLONG/1000LL;
+    int64_t sec_max_limit = MAX_JLONG/1000LL;
+    if (seconds < 0 && sec_min_limit > seconds) {
+        return static_cast<jlong>(MIN_JLONG);
+    } else if (seconds > 0 && sec_max_limit < seconds) {
+        return static_cast<jlong>(MAX_JLONG);
+    } else {
+        result_ms = seconds * 1000; // Here it is safe to convert to milliseconds
+    }
+
+    // Convert nanoseconds to milliseconds and add to final result.
+    // Clamp to MAX/MIN in case of the result overflowing/underflowing.
+    if (realm::util::int_add_with_overflow_detect(result_ms, nanoseconds / 1000000)) {
+        // The nanoseconds part is at max 1 sec. which means that if overflow/underflow
+        // is detected we can infer the direction from `result_ms` since we must be close
+        // to the limit boundary.
+        return static_cast<jlong>((result_ms < 0) ? MIN_JLONG : MAX_JLONG);
+    }
+
+    return static_cast<jlong>(result_ms);
 }
 
 inline realm::Timestamp from_milliseconds(jlong milliseconds)
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 1c94cc6413..a391381abe 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -128,6 +128,7 @@ public void onInit(OsSharedRealm sharedRealm) {
         }
 
         OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration)
+                .fifoFallbackDir(new File(BaseRealm.applicationContext.getFilesDir(), ".realm.temp"))
                 .autoUpdateNotification(true)
                 .migrationCallback(migrationCallback)
                 .schemaInfo(schemaInfo)
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 55dff041d2..b1adcbf10c 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.Locale;
+import java.util.concurrent.TimeUnit;
 
 import javax.annotation.Nullable;
 
@@ -144,7 +145,7 @@ private RealmQuery(Realm realm, Class<E> clazz) {
         this.clazz = clazz;
         this.forValues = !isClassForRealmModel(clazz);
         if (forValues) {
-            // TODO implement this
+            // TODO Queries on primitive lists are not yet supported
             this.schema = null;
             this.table = null;
             this.osList = null;
@@ -163,7 +164,7 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.clazz = clazz;
         this.forValues = !isClassForRealmModel(clazz);
         if (forValues) {
-            // TODO implement this
+            // TODO Queries on primitive lists are not yet supported
             this.schema = null;
             this.table = null;
             this.osList = null;
@@ -182,7 +183,7 @@ private RealmQuery(BaseRealm realm, OsList osList, Class<E> clazz) {
         this.clazz = clazz;
         this.forValues = !isClassForRealmModel(clazz);
         if (forValues) {
-            // TODO implement this
+            // TODO Queries on primitive lists are not yet supported
             this.schema = null;
             this.table = null;
             this.osList = null;
@@ -1826,12 +1827,81 @@ private OsResults lazyFindAll() {
      * that will synchronize all server data matching the query. Named subscriptions can be removed again by
      * calling {@code Realm.unsubscribe(subscriptionName}.
      *
+     * @param subscriptionName name of the underlying subscription being created.
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
      * @see io.realm.RealmResults
-     * @throws IllegalStateException If the Realm is a not a query-based synchronized Realm.
+     * @throws IllegalStateException If the Realm is a not a query-based synchronized Realm or the query is on a {@link RealmList}.
      */
+    @ObjectServer
     public RealmResults<E> findAllAsync(String subscriptionName) {
+        return findAllAsync(subscriptionName, Long.MAX_VALUE, TimeUnit.MILLISECONDS, false);
+    }
+
+    /**
+     * Finds all objects that fulfil the query condition(s). This method is only available from a Looper thread.
+     * <p>
+     * This method is only available on query-based synchronized Realms and will also create a named subscription
+     * that will synchronize all server data matching the query. Named subscriptions can be removed again by
+     * calling {@code Realm.unsubscribe(subscriptionName}.
+     *
+     * @param subscriptionName name of the underlying subscription being created.
+     * @param update if an existing subscription exists with a different query. It will be replaced with this
+     *               one instead of an error being reported through {@link OrderedRealmCollectionChangeListener}.
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @see io.realm.RealmResults
+     * @throws IllegalStateException If the Realm is a not a query-based synchronized Realm or the query is on a {@link RealmList}.
+     */
+    @ObjectServer
+    @Beta
+    public RealmResults<E> findAllAsync(String subscriptionName, boolean update) {
+        return findAllAsync(subscriptionName, Long.MAX_VALUE, TimeUnit.MILLISECONDS, update);
+    }
+
+    /**
+     * Finds all objects that fulfil the query condition(s). This method is only available from a Looper thread.
+     * <p>
+     * This method is only available on query-based synchronized Realms and will also create a named subscription
+     * that will synchronize all server data matching the query. Named subscriptions can be removed again by
+     * calling {@code Realm.unsubscribe(subscriptionName}.
+     *
+     * @param subscriptionName name of the underlying subscription being created.
+     * @param timeToLive the amount of time the Subscription must be kept alive after last being used. After this
+     *                   period Realm will automatically remove it.
+     * @param timeUnit the unit for {@code timeToLive}.
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @see io.realm.RealmResults
+     * @throws IllegalStateException If the Realm is a not a query-based synchronized Realm or the query is on a {@link RealmList}.
+     */
+    @ObjectServer
+    @Beta
+    public RealmResults<E> findAllAsync(String subscriptionName, long timeToLive, TimeUnit timeUnit) {
+        return findAllAsync(subscriptionName, timeToLive, timeUnit, false);
+    }
+
+    /**
+     * Finds all objects that fulfil the query condition(s). This method is only available from a Looper thread.
+     * <p>
+     * This method is only available on query-based synchronized Realms and will also create a named subscription
+     * that will synchronize all server data matching the query. Named subscriptions can be removed again by
+     * calling {@code Realm.unsubscribe(subscriptionName}.
+     *
+     * @param subscriptionName name of the underlying subscription being created.
+     * @param timeToLive the amount of time the Subscription must be kept alive after last being used. After this
+     *                   period Realm will automatically remove it.
+     * @param timeUnit the unit for {@code timeToLive}.
+     * @param update if an existing subscription exists with a different query. It will be replaced with this
+     *               one instead of an error being reported through {@link OrderedRealmCollectionChangeListener}.
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @see io.realm.RealmResults
+     * @throws IllegalStateException If the Realm is a not a query-based synchronized Realm or the query is on a {@link RealmList}.
+     */
+    @ObjectServer
+    @Beta
+    public RealmResults<E> findAllAsync(String subscriptionName, long timeToLive, TimeUnit timeUnit, boolean update) {
         realm.checkIfValid();
         realm.checkIfPartialRealm();
         if (osList != null) {
@@ -1840,11 +1910,20 @@ private OsResults lazyFindAll() {
         if (Util.isEmptyString(subscriptionName)) {
             throw new IllegalArgumentException("Non-empty 'subscriptionName' required.");
         }
-
+        if (timeToLive < 0) {
+            throw new IllegalArgumentException("Negative values for 'timeToLive' are not allowed: " + timeToLive);
+        }
+        //noinspection ConstantConditions
+        if (timeUnit == null) {
+            throw new IllegalArgumentException("Non-null 'timeUnit' required.");
+        }
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        return createRealmResults(query, queryDescriptors, false, SubscriptionAction.create(subscriptionName));
+        long timeToLiveMs = timeUnit.toMillis(timeToLive);
+        SubscriptionAction action = (update) ? SubscriptionAction.update(subscriptionName, timeToLiveMs) : SubscriptionAction.create(subscriptionName, timeToLiveMs);
+        return createRealmResults(query, queryDescriptors, false, action);
     }
 
+
     /**
      * Sorts the query result by the specific field name in ascending order.
      * <p>
@@ -2035,10 +2114,11 @@ public Subscription subscribe() {
     }
 
     /**
-     * Creates an anonymous subscription from this query or returns the existing Subscription if
-     * one already existed.
+     * Creates a named subscription from this query or returns the existing Subscription if
+     * one already existed. Subscriptions created this way will live forever or until the
+     * subscription is manually deleted.
      *
-     * @return the name of the query.
+     * @return the name of the subscription representing this query.
      * @return the subscription representing this query.
      * @throws IllegalStateException if this method is not called inside a write transaction, if
      * the query is on a {@link DynamicRealm} or a {@link RealmList}.
@@ -2048,6 +2128,93 @@ public Subscription subscribe() {
     @ObjectServer
     @Beta
     public Subscription subscribe(String name) {
+        return subscribe(name, Long.MAX_VALUE, TimeUnit.MILLISECONDS, false);
+    }
+
+    /**
+     * Creates a named subscription from this query or returns the existing Subscription if
+     * one already exists.
+     * <p>
+     * {@code timeToLive} indicates for how long Realm must keep the subscription alive after last
+     * being used. After this period expires Realm are allowed to delete the subscription.
+     * This happens automatically. The period is reset, whenever someone resubscribes or updates
+     * the subscription itself.
+     * </p>
+     * When a subscription is deleted, the data covered by the subscription is removed from the
+     * device, but not the server.
+     *
+     * @param name the name subscription representing this query.
+     * @param timeToLive the amount of time the Subscription must be kept alive after last being used. After this
+     *                   period Realm will automatically remove it.
+     * @param timeUnit the unit for {@code timeToLive}.
+     * @return the subscription representing this query.
+     * @throws IllegalStateException if this method is not called inside a write transaction, if
+     * the query is on a {@link DynamicRealm} or a {@link RealmList}.
+     * @throws IllegalArgumentException if a subscription for a different query with the same name
+     * already exists.
+     */
+    @ObjectServer
+    @Beta
+    public Subscription subscribe(String name, long timeToLive, TimeUnit timeUnit) {
+        return subscribe(name, timeToLive, timeUnit, false);
+    }
+
+    /**
+     * Creates a named subscription from this query or returns the existing Subscription if
+     * one already existed. If an existing subscription already exists and the existing query
+     * is different, it will be replaced by this query.
+     * <p>
+     * It is only allowed to update a subscription that queries for objects of the same type. If
+     * the existing subscription queries for objects of a different type, an {@link IllegalArgumentException}
+     * is thrown.
+     *
+     * @param name the name of the subscription.
+     * @return the subscription representing this query.
+     * @throws IllegalStateException if this method is not called inside a write transaction, if
+     * the query is on a {@link DynamicRealm} or a {@link RealmList}.
+     * @throws IllegalArgumentException if this query are for other objects than those already being
+     * returned by an existing subscription.
+     */
+    @ObjectServer
+    @Beta
+    public Subscription subscribeOrUpdate(String name) {
+        return subscribe(name, Long.MAX_VALUE, TimeUnit.MILLISECONDS, true);
+    }
+
+    /**
+     * Creates a named subscription from this query or returns the existing Subscription if
+     * one already existed. If a subscription already exists and the query
+     * is different, it will be replaced by this query.
+     * <p>
+     * It is only allowed to update a subscription that queries for objects of the same type. If
+     * the existing subscription queries for objects of a different type, an {@link IllegalArgumentException}
+     * is thrown.
+     * <p>
+     * {@code timeToLive} indicates for how long Realm must keep the subscription alive after last
+     * being used. After this period expires Realm are allowed to delete the subscription.
+     * This happens automatically. The period is reset, whenever the subscription is resubscribed or updated
+     * </p>
+     * When a subscription is deleted, the data covered by the subscription is removed from the
+     * device, but not the server.
+     *
+     * @param name the name of the subscription.
+     * @param timeToLive the amount of time the Subscription must be kept alive after last being used.
+     * @param timeUnit the unit for {@code timeToLive}.
+     * @return the subscription representing this query.
+     * @throws IllegalStateException if this method is not called inside a write transaction, if
+     * the query is on a {@link DynamicRealm} or a {@link RealmList}.
+     * @throws IllegalArgumentException if this query are for other objects than those already being
+     * returned by an existing subscription.
+     */
+    @ObjectServer
+    @Beta
+    public Subscription subscribeOrUpdate(String name, long timeToLive, TimeUnit timeUnit) {
+        return subscribe(name, timeToLive, timeUnit, true);
+    }
+
+
+    @ObjectServer
+    private Subscription subscribe(String name, long timeToLive, TimeUnit timeUnit, boolean update) {
         realm.checkIfValid();
         if (realm instanceof DynamicRealm) {
             throw new IllegalStateException("'subscribe' is not supported for queries on Dynamic Realms.");
@@ -2058,11 +2225,21 @@ public Subscription subscribe(String name) {
         if (TextUtils.isEmpty(name)) {
             throw new IllegalArgumentException("Non-empty 'name' required.");
         }
-        long rowIndex = nativeSubscribe(realm.getSharedRealm().getNativePtr(), name, query.getNativePtr(), queryDescriptors.getNativePtr());
+        //noinspection ConstantConditions
+        if (timeUnit == null) {
+            throw new IllegalArgumentException("Non-null 'timeUnit' is required.");
+        }
+
+        // Convert timestamp to milliseconds and clamp at max
+        long timeToLiveMs = TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);
+
+        long rowIndex = nativeSubscribe(realm.getSharedRealm().getNativePtr(), name, query.getNativePtr(),
+                queryDescriptors.getNativePtr(), timeToLiveMs, update);
         CheckedRow row = ((Realm) realm).getTable(Subscription.class).getCheckedRow(rowIndex);
         return realm.get(Subscription.class, null, row);
     }
 
+
     /**
      * Returns a textual description of this query.
      *
@@ -2072,6 +2249,16 @@ public String getDescription() {
         return nativeSerializeQuery(query.getNativePtr(), queryDescriptors.getNativePtr());
     }
 
+    /**
+     * Returns the internal Realm name of the type being queried.
+     *
+     * @return the internal name of the Realm model class being queried.
+     */
+    public String getTypeQueried() {
+        // TODO Revisit this when primitve list queries are implemented.
+        return table.getClassName();
+    }
+
     private boolean isDynamicQuery() {
         return className != null;
     }
@@ -2157,7 +2344,7 @@ public E findFirstAsync() {
         RealmResults<E> results;
         OsResults osResults;
         if (subscriptionAction.shouldCreateSubscriptions()) {
-            osResults = SubscriptionAwareOsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors, subscriptionAction.getName());
+            osResults = SubscriptionAwareOsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors, subscriptionAction);
         } else {
             osResults = OsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors);
         }
@@ -2192,6 +2379,7 @@ private SchemaConnector getSchemaConnector() {
     }
 
     private static native String nativeSerializeQuery(long tableQueryPtr, long descriptorPtr);
-    private static native long nativeSubscribe(long sharedRealmPtr, String name, long tableQueryPtr, long descriptorPtr);
+    private static native long nativeSubscribe(long sharedRealmPtr, String name, long tableQueryPtr,
+                                               long descriptorPtr, long timeToLiveMs, boolean update);
 
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index 3240ddd7e8..2ef03d1046 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -16,6 +16,7 @@
 
 package io.realm.internal;
 
+import java.io.File;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.Map;
@@ -87,6 +88,7 @@ public byte getNativeValue() {
         private OsSharedRealm.MigrationCallback migrationCallback = null;
         private OsSharedRealm.InitializationCallback initializationCallback = null;
         private boolean autoUpdateNotification = false;
+        private String fifoFallbackDir = "";
 
         /**
          * Initialize a {@link OsRealmConfig.Builder} with a given {@link RealmConfiguration}.
@@ -144,9 +146,14 @@ public Builder autoUpdateNotification(boolean autoUpdateNotification) {
         // Package private because of the OsRealmConfig needs to carry the NativeContext. This should only be called
         // by the OsSharedRealm.
         OsRealmConfig build() {
-            return new OsRealmConfig(configuration, autoUpdateNotification, schemaInfo,
+            return new OsRealmConfig(configuration, fifoFallbackDir, autoUpdateNotification, schemaInfo,
                     migrationCallback, initializationCallback);
         }
+
+        public Builder fifoFallbackDir(File dir) {
+            this.fifoFallbackDir = dir.getAbsolutePath();
+            return this;
+        }
     }
 
     private static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
@@ -181,12 +188,13 @@ OsRealmConfig build() {
     private final OsSharedRealm.InitializationCallback initializationCallback;
 
     private OsRealmConfig(final RealmConfiguration config,
+                          String fifoFallbackDir,
                           boolean autoUpdateNotification,
                           @Nullable OsSchemaInfo schemaInfo,
                           @Nullable OsSharedRealm.MigrationCallback migrationCallback,
                           @Nullable OsSharedRealm.InitializationCallback initializationCallback) {
         this.realmConfiguration = config;
-        this.nativePtr = nativeCreate(config.getPath(), false, true);
+        this.nativePtr = nativeCreate(config.getPath(), fifoFallbackDir,false, true);
         NativeContext.dummyContext.addReference(this);
 
         // Retrieve Sync settings first. We need syncRealmUrl to identify if this is a SyncConfig
@@ -302,7 +310,7 @@ NativeContext getContext() {
         return context;
     }
 
-    private static native long nativeCreate(String path, boolean enableCache, boolean enableFormatUpdate);
+    private static native long nativeCreate(String path, String fifoFallbackDir, boolean enableCache, boolean enableFormatUpdate);
 
     private static native void nativeSetEncryptionKey(long nativePtr, byte[] key);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
index 0f601cde9c..7ba0cc06d5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
@@ -19,6 +19,7 @@
 import io.realm.RealmChangeListener;
 import io.realm.internal.core.DescriptorOrdering;
 import io.realm.internal.sync.OsSubscription;
+import io.realm.internal.sync.SubscriptionAction;
 
 /**
  * Wrapper around Object Stores Results class that is capable of combining partial sync Subscription
@@ -38,17 +39,17 @@
 
     public static SubscriptionAwareOsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query,
                                                              DescriptorOrdering queryDescriptors,
-                                                             String subscriptionName) {
+                                                             SubscriptionAction subscriptionInfo) {
         query.validateQuery();
         long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(), queryDescriptors.getNativePtr());
-        return new SubscriptionAwareOsResults(sharedRealm, query.getTable(), ptr, subscriptionName);
+        return new SubscriptionAwareOsResults(sharedRealm, query.getTable(), ptr, subscriptionInfo);
     }
 
-    SubscriptionAwareOsResults(OsSharedRealm sharedRealm, Table table, long nativePtr, String subscriptionName) {
+    SubscriptionAwareOsResults(OsSharedRealm sharedRealm, Table table, long nativePtr, SubscriptionAction subscriptionInfo) {
         super(sharedRealm, table, nativePtr);
 
         this.firstCallback = true;
-        this.subscription = new OsSubscription(this, subscriptionName);
+        this.subscription = new OsSubscription(this, subscriptionInfo);
         this.subscription.addChangeListener(new RealmChangeListener<OsSubscription>() {
             @Override
             public void onChange(OsSubscription o) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
index c611cb6674..a945534a33 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
@@ -23,4 +23,9 @@
     public static native String getExpectedMessage(long exceptionKind);
 
     public static native void testThrowExceptions(long exceptionKind);
+
+    /**
+     * Returns the Date representation of a Core timestamp
+     */
+    public static native long getDateFromTimestamp(long seconds, int nanoseconds);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index e9ef4d800a..6850af8c8e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -122,6 +122,9 @@ public static boolean deleteRealm(String canonicalPath, File realmFolder, String
         final String management = ".management";
         File managementFolder = new File(realmFolder, realmFileName + management);
         File realmFile = new File(canonicalPath);
+        // This file is not always stored here, but if it is we want to delete it.
+        // If it isn't found it is placed in a temporary folder, so no reason to delete it.
+        File fifoFile = new File(canonicalPath + ".note");
 
         // Deletes files in management directory and the directory.
         // There is no subfolders in the management directory.
@@ -150,6 +153,12 @@ public static boolean deleteRealm(String canonicalPath, File realmFolder, String
         } else {
             realmDeleted = true;
         }
+
+        if (fifoFile.exists() && !fifoFile.delete()) {
+            RealmLog.warn(String.format(Locale.ENGLISH,".note file at %s cannot be deleted",
+                        fifoFile.getAbsolutePath()));
+        }
+
         return realmDeleted;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java b/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
index adbc7b4804..49313701e0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
@@ -74,8 +74,9 @@ public void onCalled(SubscriptionObserverPair pair, Object observer) {
     private final long nativePtr;
     protected final ObserverPairList<SubscriptionObserverPair> observerPairs = new ObserverPairList<>();
 
-    public OsSubscription(OsResults results, String subscriptionName) {
-        this.nativePtr = nativeCreate(results.getNativePtr(), subscriptionName);
+    public OsSubscription(OsResults results, SubscriptionAction subscriptionInfo) {
+        this.nativePtr = nativeCreateOrUpdate(results.getNativePtr(), subscriptionInfo.getName(),
+                subscriptionInfo.getTimeToLiveMs(), subscriptionInfo.isUpdate());
     }
 
     @Override
@@ -117,7 +118,7 @@ private void notifyChangeListeners() {
         observerPairs.foreach(new Callback());
     }
 
-    private static native long nativeCreate(long resultsNativePtr, String subscriptionName);
+    private static native long nativeCreateOrUpdate(long resultsNativePtr, String subscriptionName, long timeToLiveMs, boolean update);
 
     private static native long nativeGetFinalizerPtr();
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java b/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java
index 72c5ea0d72..4a6b91a988 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java
@@ -16,21 +16,31 @@
 
 package io.realm.internal.sync;
 
+import java.util.concurrent.TimeUnit;
+
 /**
  * Wrapper class describing if and how a subscription should be created when creating a query result.
  */
 public class SubscriptionAction {
-    public static final SubscriptionAction NO_SUBSCRIPTION = new SubscriptionAction(null);
-    public static final SubscriptionAction ANONYMOUS_SUBSCRIPTION = new SubscriptionAction("");
+    public static final SubscriptionAction NO_SUBSCRIPTION = new SubscriptionAction(null, 0, false);
+    public static final SubscriptionAction ANONYMOUS_SUBSCRIPTION = new SubscriptionAction("", Long.MAX_VALUE, false);
+
+    public static SubscriptionAction create(String subscriptionName, long timeToLiveMs) {
+        return new SubscriptionAction(subscriptionName, timeToLiveMs, false);
+    }
 
-    public static SubscriptionAction create(String subscriptionName) {
-        return new SubscriptionAction(subscriptionName);
+    public static SubscriptionAction update(String subscriptionName, long timeToLiveMs) {
+        return new SubscriptionAction(subscriptionName, timeToLiveMs, true);
     }
 
     private final String subscriptionName;
+    private final long timeToLiveMs;
+    private final boolean update;
 
-    private SubscriptionAction(String name) {
-        this.subscriptionName = name;
+    public SubscriptionAction(String subscriptionName, long timeToLiveMs, boolean update) {
+        this.subscriptionName = subscriptionName;
+        this.timeToLiveMs = timeToLiveMs;
+        this.update = update;
     }
 
     public boolean shouldCreateSubscriptions() {
@@ -40,4 +50,12 @@ public boolean shouldCreateSubscriptions() {
     public String getName() {
         return subscriptionName;
     }
+
+    public long getTimeToLiveMs() {
+        return timeToLiveMs;
+    }
+
+    public boolean isUpdate() {
+        return update;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/sync/Subscription.java b/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
index 15429b0eb8..aab282847d 100644
--- a/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
+++ b/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
@@ -15,6 +15,13 @@
  */
 package io.realm.sync;
 
+import java.lang.reflect.Field;
+import java.util.Date;
+import java.util.concurrent.TimeUnit;
+
+import javax.annotation.Nullable;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.RealmObject;
 import io.realm.RealmQuery;
 import io.realm.annotations.Beta;
@@ -22,6 +29,7 @@
 import io.realm.annotations.RealmClass;
 import io.realm.annotations.RealmField;
 import io.realm.annotations.Required;
+import io.realm.internal.Table;
 import io.realm.internal.annotations.ObjectServer;
 
 /**
@@ -135,6 +143,47 @@ public Subscription(String name, RealmQuery<?> query) {
     @RealmField("query_parse_counter")
     private int queryParseCounter;
 
+    /**
+     * Field indicating when this subscription was created.
+     */
+    @RealmField("created_at")
+    private Date createdAt;
+
+    /**
+     * Field indicating when this subscription was last used or updated.
+     * <p>
+     * "Used" in this context means that someone resubscribed to the subscription.
+     * <p>
+     * "Updated" means that someone updated the {@link #query} or some other field part of this class.
+     * <p>
+     * This field is NOT updated whenever the results of the query changes.
+     * <p>
+     * This field plus {@link #timeToLive} defines {@link #expiresAt}.
+     */
+    @RealmField("updated_at")
+    private Date updatedAt;
+
+    /**
+     * Field indicating when it is safe to delete this subscription.
+     * <p>
+     * If {@code null} is returned, this subscription will live until manually deleted.
+     */
+    @Nullable
+    @RealmField("expires_at")
+    private Date expiresAt;
+
+    /**
+     * Field indicating for how long after last being used Realm must keep this subscription. After
+     * the TTL expires, Realm is allowed to remove the subscription.
+     * <p>
+     * If {@code null} is returned, the subscription should live forever.
+     * <p>
+     * This field plus {@link #updatedAt} defines {@link #expiresAt}.
+     */
+    @Nullable
+    @RealmField("time_to_live")
+    private Long timeToLive;
+
     /**
      * Returns the name of the subscription.
      *
@@ -144,6 +193,90 @@ public String getName() {
         return name;
     }
 
+    /**
+     * Returns when this subscription was initially created. If {@code new Date(0)} is returned,
+     * it is unknown when the subscription was created.
+     *
+     * @return when this subscription was initially created.
+     */
+    @SuppressFBWarnings({"EI_EXPOSE_REP"})
+    public Date getCreatedAt() {
+        return createdAt;
+    }
+
+    /**
+     * Returns when this subscription was last used or updated.
+     * <p>
+     * "Used" in this context means that someone resubscribed to the subscription.
+     * <p>
+     * "Updated" means that someone updated the {@link #query} or some other field part of this class.
+     * <p>
+     * This field is NOT updated whenever the results of the query changes.
+     * <p>
+     * This field plus {@link #timeToLive} defines {@link #expiresAt}.
+     *
+     * @return the point in time this subscription was last used or updated.
+     */
+    @SuppressFBWarnings({"EI_EXPOSE_REP"})
+    public Date getUpdatedAt() {
+        return updatedAt;
+    }
+
+    /**
+     * Returns the point in time from which Realm can safely delete this subscription. This will
+     * happen automatically.
+     * <p>
+     * Realm will attempt to cleanup expired subscriptions when the app is started or whenever
+     * any subscription is modified, there is no guarantee it will happen immediately after it
+     * expires.
+     *
+     * @return the point in time after which Realm can safely delete this subscription.
+     */
+    @SuppressFBWarnings({"EI_EXPOSE_REP"})
+    public Date getExpiresAt() {
+        if (expiresAt == null) {
+            return new Date(Long.MAX_VALUE);
+        } else {
+            return expiresAt;
+        }
+    }
+
+    /**
+     * Returns for how long the subscription must be kept alive after last being used. The value
+     * returned are in milliseconds.
+     *
+     * @return in milliseconds, for how long the subscription must be kept alive after last being used.
+     */
+    public long getTimeToLive() {
+        return (timeToLive != null) ? timeToLive : Long.MAX_VALUE;
+    }
+
+    /**
+     * Sets the time-to-live in milliseconds for this subscription. This defines for how long Realm
+     * must keep the subscription alive after last being used.
+     *
+     * @param timeToLive for how long Realm must keep the subscription after last being used.
+     * @param timeUnit time unit for {@code timeToLive}.
+     * @throws IllegalArgumentException if a negative time-to-live or null timeUnit is provided.
+     */
+    public void setTimeToLive(long timeToLive, TimeUnit timeUnit) {
+        if (timeToLive < 0) {
+            throw new IllegalArgumentException("A negative time-to-live is not allowed: " + timeToLive);
+        }
+        if (timeUnit == null) {
+            throw new IllegalArgumentException("Non-null 'timeUnit' required.");
+        }
+        this.updatedAt = new Date(System.currentTimeMillis());
+        this.timeToLive = TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);
+        long expiryTime = this.updatedAt.getTime();
+        if (expiryTime + this.timeToLive < expiryTime) {
+            expiryTime = Long.MAX_VALUE; // Clamp overflow to max
+        } else {
+            expiryTime = expiryTime + this.timeToLive;
+        }
+        this.expiresAt = new Date(expiryTime);
+    }
+
     /**
      * Returns a textual description of the query that created this subscription.
      *
@@ -153,6 +286,23 @@ public String getQueryDescription() {
         return query;
     }
 
+    /**
+     * Replaces the current query controlled by this subscription with a new query.
+     *
+     * @param query the query which should replace the current one.
+     */
+    public void setQuery(RealmQuery query) {
+        if (query == null) {
+            throw new IllegalArgumentException("Non-null 'query' required");
+        }
+        if (!query.getTypeQueried().equals(getQueryClassName())) {
+            throw new IllegalArgumentException(String.format("It is only allowed to replace a query with another query on the same type." +
+                    "Existing query: '%s'. New query: '%s'", getQueryClassName(), query.getTypeQueried()));
+        }
+        this.query = query.getDescription();
+        this.updatedAt = new Date();
+    }
+
     /**
      * Returns the internal name of the Class being queried.
      *
@@ -219,10 +369,13 @@ public void unsubscribe() {
     public String toString() {
         return "Subscription{" +
                 "name='" + name + '\'' +
-                ", status=" + getState().toString() +
+                ", status=" + status +
                 ", errorMessage='" + errorMessage + '\'' +
-                ", className='" + getQueryClassName() + '\'' +
                 ", query='" + query + '\'' +
+                ", createdAt=" + createdAt +
+                ", updatedAt=" + updatedAt +
+                ", expiresAt=" + expiresAt +
+                ", timeToLive=" + timeToLive +
                 '}';
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
index 621b7a70cb..a6e4203a55 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
@@ -1,16 +1,22 @@
 package io.realm.objectserver;
 
+import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Date;
+import java.util.concurrent.TimeUnit;
+
 import io.realm.DynamicRealm;
 import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmList;
+import io.realm.RealmQuery;
 import io.realm.RealmResults;
 import io.realm.Sort;
 import io.realm.StandardIntegrationTest;
@@ -154,7 +160,159 @@ public void namedSubscription() throws InterruptedException {
                 }
             }
         });
+    }
 
+    @Test
+    @RunTestInLooperThread
+    public void namedSubscription_update() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        Date now = new Date();
+        SystemClock.sleep(2);
+
+        RealmQuery<PartialSyncObjectA> query1 = realm.where(PartialSyncObjectA.class).greaterThan("number", 5);
+        RealmResults<PartialSyncObjectA> results = query1.findAllAsync("update-test");
+        results.addChangeListener((objects1, changeSet1) -> {
+            if (changeSet1.isCompleteResult()) {
+                results.removeAllChangeListeners();
+                final Subscription sub1 = realm.getSubscription("update-test");
+                final Date firstUpdated = sub1.getUpdatedAt();
+                assertEquals(query1.getDescription(), sub1.getQueryDescription());
+                assertTrue(now.getTime() < sub1.getUpdatedAt().getTime());
+                assertEquals(sub1.getCreatedAt(), sub1.getUpdatedAt());
+                assertEquals(Long.MAX_VALUE, sub1.getExpiresAt().getTime());
+                assertEquals(Long.MAX_VALUE, sub1.getTimeToLive());
+
+                SystemClock.sleep(2);
+                RealmQuery<PartialSyncObjectA> query2 = realm.where(PartialSyncObjectA.class).equalTo("string", "foo");
+                RealmResults<PartialSyncObjectA> results2 = query2.findAllAsync("update-test", true);
+                results2.addChangeListener((objects2, changeSet2) -> {
+                    if (changeSet2.isCompleteResult()) {
+                        assertEquals(query2.getDescription(), sub1.getQueryDescription());
+                        assertTrue(firstUpdated.getTime() < sub1.getUpdatedAt().getTime());
+                        looperThread.testComplete();
+                    }
+                });
+                looperThread.keepStrongReference(results2);
+            }
+        });
+        looperThread.keepStrongReference(results);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void namedSubscription_update_timeToLive() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        RealmQuery<PartialSyncObjectA> query1 = realm.where(PartialSyncObjectA.class).greaterThan("number", 5);
+        RealmResults<PartialSyncObjectA> results = query1.findAllAsync("update-test-ttl");
+        results.addChangeListener((objects1, changeSet1) -> {
+            if (changeSet1.isCompleteResult()) {
+                results.removeAllChangeListeners();
+                final Subscription sub1 = realm.getSubscription("update-test-ttl");
+                final Date firstUpdatedAt = sub1.getUpdatedAt();
+                final Date firstExpiresAt = sub1.getExpiresAt();
+                assertEquals(Long.MAX_VALUE, sub1.getExpiresAt().getTime());
+                assertEquals(Long.MAX_VALUE, sub1.getTimeToLive());
+
+                SystemClock.sleep(2);
+                RealmQuery<PartialSyncObjectA> query2 = realm.where(PartialSyncObjectA.class).equalTo("string", "foo");
+                RealmResults<PartialSyncObjectA> results2 = query2.findAllAsync("update-test-ttl", 10, TimeUnit.MILLISECONDS, true);
+                results2.addChangeListener((objects2, changeSet2) -> {
+                    if (changeSet2.isCompleteResult()) {
+                        assertEquals(10, sub1.getTimeToLive());
+                        assertTrue(sub1.getExpiresAt().getTime() < firstExpiresAt.getTime());
+                        assertTrue(firstUpdatedAt.getTime() < sub1.getUpdatedAt().getTime());
+                        looperThread.testComplete();
+                    }
+                });
+                looperThread.keepStrongReference(results2);
+            }
+        });
+        looperThread.keepStrongReference(results);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void namedSubscription_withTimeToLive() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        RealmQuery<PartialSyncObjectA> query = realm.where(PartialSyncObjectA.class);
+        Date now = new Date();
+        Date now_plus_10_sec = new Date(now.getTime() + 10000);
+        RealmResults<PartialSyncObjectA> results = query.findAllAsync("test-ttl", 5, TimeUnit.SECONDS);
+        results.addChangeListener((objects, changeSet) -> {
+            if (changeSet.isCompleteResult()) {
+                results.removeAllChangeListeners();
+                final Subscription sub = realm.getSubscription("test-ttl");
+                // Fuzzy check of expiresAt since we don't control exactly when the Subscription is created.
+                assertTrue(now.getTime() <= sub.getExpiresAt().getTime());
+                assertTrue(sub.getExpiresAt().getTime() < now_plus_10_sec.getTime());
+                assertEquals(5000, sub.getTimeToLive());
+                looperThread.testComplete();
+            }
+        });
+        looperThread.keepStrongReference(results);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void namedSubscription_update_throwsIfDifferentQueryType() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        RealmResults<PartialSyncObjectA> results = realm.where(PartialSyncObjectA.class).findAllAsync("type-conflict");
+        results.addChangeListener((objects1, changeSet1) -> {
+            if (changeSet1.isCompleteResult()) {
+                results.removeAllChangeListeners();
+                RealmResults<PartialSyncObjectB> results2 = realm.where(PartialSyncObjectB.class).findAllAsync("type-conflict", true);
+                results2.addChangeListener((objects2, changeSet2) -> {
+                    if (changeSet2.getState() == OrderedCollectionChangeSet.State.ERROR) {
+                        assertTrue(changeSet2.getError() instanceof IllegalArgumentException);
+                        assertTrue(changeSet2.getError().getMessage().startsWith("Replacing an existing query with a query on a different type is not allowed"));
+                        looperThread.testComplete();
+                    }
+                });
+                looperThread.keepStrongReference(results2);
+            }
+        });
+        looperThread.keepStrongReference(results);
+    }
+
+    @RunTestInLooperThread
+    public void creatingSubscriptionsAlsoCleanupExpiredSubscriptions() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        RealmResults<PartialSyncObjectA> results = realm.where(PartialSyncObjectA.class).findAllAsync("sub1", 0, TimeUnit.MILLISECONDS);
+        results.addChangeListener((objects1, changeSet1) -> {
+            if (changeSet1.isCompleteResult()) {
+                results.removeAllChangeListeners();
+                assertEquals(1, realm.getSubscriptions().size());
+                final Subscription firstSub = realm.getSubscription("sub1");
+                SystemClock.sleep(2);
+
+                RealmResults<PartialSyncObjectB> results2 = realm.where(PartialSyncObjectB.class).findAllAsync("sub2");
+                results2.addChangeListener((objects2, changeSet2) -> {
+                    if (changeSet2.isCompleteResult()) {
+                        assertEquals(1, realm.getSubscriptions().size());
+                        assertEquals("sub2", realm.getSubscriptions().first().getName());
+                        assertFalse(firstSub.isValid());
+                        looperThread.testComplete();
+                    }
+                });
+                looperThread.keepStrongReference(results2);
+            }
+        });
+        looperThread.keepStrongReference(results);
     }
 
     @Test
@@ -490,4 +648,5 @@ private void createServerData(SyncUser user, String url) throws InterruptedExcep
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
    }
+
 }
diff --git a/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
index 2d8a6a5096..d65692fb5d 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
@@ -1195,7 +1195,9 @@ public static boolean isSelinuxEnforcing() {
             return false;
         }
         try {
-            final Process process = new ProcessBuilder("/system/bin/getenforce").start();
+            final Process process = new ProcessBuilder("/system/bin/getenforce")
+                    .redirectErrorStream(true)
+                    .start();
             try {
                 final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), UTF_8));
                 //noinspection TryFinallyCanBeTryWithResources
diff --git a/version.txt b/version.txt
index ba94863e02..48092a8f91 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.10.0-SNAPSHOT
+5.11.0-SNAPSHOT
\ No newline at end of file
