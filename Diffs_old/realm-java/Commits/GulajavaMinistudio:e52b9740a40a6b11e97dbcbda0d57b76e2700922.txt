diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8d74041d3a..5055d2304c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -6,10 +6,12 @@
 
 * [ObjectServer] Added support for `SyncUser.isAdmin()` (#4353).
 * [ObjectServer] Added support for changing passwords through `SyncUser.changePassword()` (#4423).
+* [ObjectServer] Added support for `SyncConfiguration.Builder.waitForInitialRemoteData()` (#4270).
 * Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore` annotation (#4279).
 * Added `Realm.refresh()` and `DynamicRealm.refresh()` (#3476).
 * Added `Realm.getInstanceAsync()` and `DynamicRealm.getInstanceAsync()` (#2299).
 * Added `DynamicRealmObject#linkingObjects(String,String)` to support linking objects on `DynamicRealm` (#4492).
+* Change listeners will now auto-expand variable names to be more descriptive when using Android Studio.
 
 ### Bug Fixes
 
@@ -17,6 +19,14 @@
 
 * Use separated locks for different `RealmCache`s ($4551).
 
+
+# 3.1.5 (YYYY-MM-DD)
+
+## Bug fixes
+
+* `@LinkingObjects` annotation now also works with Kotlin (#4611).
+
+
 ## 3.1.4 (2017-05-04)
 
 ## Bug fixes
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 737177a801..fdaceba7dd 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -46,5 +46,5 @@ android {
 
 dependencies {
     compile "org.jetbrains.kotlin:kotlin-stdlib:${kotlin_version}"
-    compile 'org.jetbrains.anko:anko-sdk15:0.8.2'
+    compile 'org.jetbrains.anko:anko-sdk15:0.9.1'
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index aba7c85d6e..d54d096e1f 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -26,7 +26,7 @@ import io.realm.Sort
 import io.realm.examples.kotlin.model.Cat
 import io.realm.examples.kotlin.model.Dog
 import io.realm.examples.kotlin.model.Person
-import org.jetbrains.anko.async
+import org.jetbrains.anko.doAsync
 import org.jetbrains.anko.uiThread
 import kotlin.properties.Delegates
 
@@ -63,11 +63,10 @@ class KotlinExampleActivity : Activity() {
         basicLinkQuery(realm)
 
         // More complex operations can be executed on another thread, for example using
-        // Anko's async extension method.
-        async {
+        // Anko's doAsync extension method.
+        doAsync {
             var info = complexReadWrite()
             info += complexQuery()
-
             uiThread {
                 showStatus(info)
             }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
index 803eb7fcef..60e21b81b5 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
@@ -19,5 +19,5 @@ package io.realm.examples.kotlin.model
 import io.realm.RealmObject
 
 open class Cat : RealmObject() {
-    open var name: String? = null
+    var name: String? = null
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
index dd4b8452e8..17d8b5fd75 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
@@ -17,7 +17,11 @@
 package io.realm.examples.kotlin.model
 
 import io.realm.RealmObject
+import io.realm.RealmResults
+import io.realm.annotations.LinkingObjects
 
 open class Dog : RealmObject() {
-    open var name: String? = null
+    var name: String? = null
+    @LinkingObjects("dog")
+    val owners: RealmResults<Person>? = null
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
index c408a12472..829fb1b8cd 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
@@ -21,8 +21,7 @@ import io.realm.RealmObject
 import io.realm.annotations.Ignore
 import io.realm.annotations.PrimaryKey
 
-// Your model has to extend RealmObject. Furthermore, the class and all of the
-// properties must be annotated with open (Kotlin classes and methods are final
+// Your model has to extend RealmObject. Furthermore, the class must be annotated with open (Kotlin classes are final
 // by default).
 open class Person(
         // You can put properties in the constructor as long as all of them are initialized with
@@ -30,20 +29,20 @@ open class Person(
         // All properties are by default persisted.
         // Properties can be annotated with PrimaryKey or Index.
         // If you use non-nullable types, properties must be initialized with non-null values.
-        @PrimaryKey open var id: Long = 0,
+        @PrimaryKey var id: Long = 0,
 
-        open var name: String = "",
+        var name: String = "",
 
-        open var age: Int = 0,
+        var age: Int = 0,
 
         // Other objects in a one-to-one relation must also subclass RealmObject
-        open var dog: Dog? = null,
+        var dog: Dog? = null,
 
         // One-to-many relations is simply a RealmList of the objects which also subclass RealmObject
-        open var cats: RealmList<Cat> = RealmList(),
+        var cats: RealmList<Cat> = RealmList(),
 
         // You can instruct Realm to ignore a field and not persist it.
-        @Ignore open var tempReference: Int = 0
+        @Ignore var tempReference: Int = 0
 
 ) : RealmObject() {
     // The Kotlin compiler generates standard getters and setters.
diff --git a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
index d79258c51d..3eb4afa3b9 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
@@ -92,7 +92,7 @@
  * assert fido.owners.size() == 2;
  * }
  */
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 @Target(ElementType.FIELD)
 @Beta
 public @interface LinkingObjects {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
index 0516f0e115..ace2f24229 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -54,6 +54,11 @@ public boolean canDeliverNotification() {
         @Override
         public void checkCanDeliverNotification(String exceptionMessage) {
         }
+
+        @Override
+        public boolean isMainThread() {
+            return false;
+        }
     };
 
     @Before
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index e3a58bbad2..8165ea5cb5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -22,9 +22,15 @@
 #include "object-store/src/sync/sync_session.hpp"
 
 #include "util.hpp"
+#include "jni_util/java_global_ref.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_local_ref.hpp"
+#include "jni_util/jni_utils.hpp"
 
 using namespace std;
 using namespace realm;
+using namespace jni_util;
 using namespace sync;
 
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
@@ -43,7 +49,42 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JN
             return JNI_TRUE;
         }
         else {
-            realm::jni_util::Log::d("no active/inactive session found");
+            Log::d("no active/inactive session found");
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadCompletion(JNIEnv* env,
+                                                                                     jobject session_object,
+                                                                                     jstring localRealmPath)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, localRealmPath);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            static JavaClass java_sync_session_class(env, "io/realm/SyncSession");
+            static JavaMethod java_notify_result_method(env, java_sync_session_class, "notifyAllChangesDownloaded",
+                                                        "(Ljava/lang/Long;Ljava/lang/String;)V");
+            JavaGlobalRef java_session_object_ref(env, session_object);
+
+            bool listener_registered =
+                session->wait_for_download_completion([java_session_object_ref](std::error_code error) {
+                    JNIEnv* env = JniUtils::get_env(true);
+                    jobject java_error_code = nullptr;
+                    jstring java_error_message = nullptr;
+                    if (error != std::error_code{}) {
+                        java_error_code = NewLong(env, error.value());
+                        java_error_message = env->NewStringUTF(error.message().c_str());
+                    }
+                    env->CallVoidMethod(java_session_object_ref.get(), java_notify_result_method, java_error_code,
+                                        java_error_message);
+                });
+
+            return to_jbool(listener_registered);
         }
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index f542b345b0..09af1fe85e 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -164,7 +164,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
     JNIEnv* env, jclass, jstring realm_path, jbyteArray key, jbyte schema_mode, jboolean in_memory, jboolean cache,
-    jlong /* schema_version */, jboolean disable_format_upgrade, jboolean auto_change_notification,
+    jlong /* schema_version */, jboolean enable_format_upgrade, jboolean auto_change_notification,
     REALM_UNUSED jstring sync_server_url, REALM_UNUSED jstring sync_server_auth_url,
     REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token)
 {
@@ -180,7 +180,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
         config.schema_mode = static_cast<SchemaMode>(schema_mode);
         config.in_memory = in_memory;
         config.cache = cache;
-        config.disable_format_upgrade = disable_format_upgrade;
+        config.disable_format_upgrade = !enable_format_upgrade;
         config.automatic_change_notifications = auto_change_notification;
         if (sync_server_url) {
             return reinterpret_cast<jlong>(new JniConfigWrapper(env, config, sync_server_url, sync_server_auth_url,
@@ -223,7 +223,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     // Close the SharedRealm only. Let the finalizer daemon thread free the SharedRealm
     if (!shared_realm->is_closed()) {
         shared_realm->close();
@@ -235,7 +235,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeBeginTransaction
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->begin_transaction();
     }
@@ -247,7 +247,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCommitTransactio
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->commit_transaction();
         // Realm could be closed in the RealmNotifier.didChange().
@@ -265,7 +265,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCancelTransactio
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->cancel_transaction();
     }
@@ -278,7 +278,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsInTransact
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     return static_cast<jboolean>(shared_realm->is_in_transaction());
 }
 
@@ -287,7 +287,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEn
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return reinterpret_cast<jlong>(&shared_realm->read_group());
     }
@@ -301,7 +301,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
     }
@@ -314,7 +314,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEn
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         if (!shared_realm->is_in_transaction()) {
             std::ostringstream ss;
@@ -333,7 +333,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jboolean>(ObjectStore::is_empty(shared_realm->read_group()));
     }
@@ -345,7 +345,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRefresh(JNIEnv*
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->refresh();
     }
@@ -357,7 +357,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersion
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         SharedGroup::VersionID version_id = rf::get_shared_group(*shared_realm).get_version_of_current_transaction();
@@ -384,7 +384,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsClosed(JNI
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     return static_cast<jboolean>(shared_realm->is_closed());
 }
 
@@ -396,7 +396,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv
 
     try {
         JStringAccessor name(env, table_name); // throws
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         if (!shared_realm->read_group().has_table(name) && !shared_realm->is_in_transaction()) {
             std::ostringstream ss;
             ss << "Class " << name << " doesn't exist and the shared Realm is not in transaction.";
@@ -417,7 +417,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedRealm_nativeGetTableName(
 
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return to_jstring(env, shared_realm->read_group().get_table_name(static_cast<size_t>(index)));
     }
@@ -431,7 +431,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeHasTable(JNI
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor name(env, table_name);
         return static_cast<jboolean>(shared_realm->read_group().has_table(name));
@@ -447,7 +447,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor old_name(env, old_table_name);
         if (!shared_realm->is_in_transaction()) {
@@ -468,7 +468,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor name(env, table_name);
         if (!shared_realm->is_in_transaction()) {
@@ -486,7 +486,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv* en
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jlong>(shared_realm->read_group().size());
     }
@@ -500,7 +500,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor path_str(env, path);
         JniByteArray key_buffer(env, key);
@@ -514,7 +514,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeWaitForChang
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         return static_cast<jboolean>(rf::get_shared_group(*shared_realm).wait_for_change());
@@ -529,7 +529,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeStopWaitForChang
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         rf::get_shared_group(*shared_realm).wait_for_change_release();
@@ -542,7 +542,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeCompact(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jboolean>(shared_realm->compact());
     }
@@ -551,28 +551,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeCompact(JNIE
     return JNI_FALSE;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSnapshotVersion(JNIEnv* env, jclass,
-                                                                                    jlong shared_realm_ptr)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        using rf = realm::_impl::RealmFriend;
-        auto& shared_group = rf::get_shared_group(*shared_realm);
-        return LangBindHelper::get_version_of_latest_snapshot(shared_group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv* env, jclass,
                                                                              jlong shared_realm_ptr, jlong schema_ptr,
                                                                              jlong version)
 {
     TR_ENTER_PTR(shared_realm_ptr)
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         auto* schema = reinterpret_cast<Schema*>(schema_ptr);
         shared_realm->update_schema(*schema, static_cast<uint64_t>(version), nullptr, true);
     }
@@ -586,7 +571,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeRequiresMigr
 
     TR_ENTER()
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
         auto* schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
         const std::vector<SchemaChange>& change_list = shared_realm->schema().compare(*schema);
         return static_cast<jboolean>(!change_list.empty());
@@ -613,7 +598,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetAutoRefresh(J
 {
     TR_ENTER_PTR(shared_realm_ptr)
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         shared_realm->set_auto_refresh(to_bool(enabled));
     }
     CATCH_STD()
@@ -624,7 +609,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsAutoRefres
 {
     TR_ENTER_PTR(shared_realm_ptr)
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         return to_jbool(shared_realm->auto_refresh());
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
index f0bb7530c5..eaf526e75c 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
@@ -36,7 +36,6 @@ JavaGlobalRef JavaClass::get_jclass(JNIEnv* env, const char* class_name)
     jclass cls = env->FindClass(class_name);
     REALM_ASSERT_DEBUG(cls);
 
-    JavaGlobalRef cls_ref(env, cls);
-    env->DeleteLocalRef(cls);
+    JavaGlobalRef cls_ref(env, cls, true);
     return cls_ref;
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
index fd6036cf95..68d9fd99de 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
@@ -34,3 +34,8 @@ JavaGlobalRef& JavaGlobalRef::operator=(JavaGlobalRef&& rhs)
     new (this) JavaGlobalRef(std::move(rhs));
     return *this;
 }
+
+JavaGlobalRef::JavaGlobalRef(JavaGlobalRef& rhs)
+        : m_ref(rhs.m_ref ? jni_util::JniUtils::get_env(true)->NewGlobalRef(rhs.m_ref) : nullptr)
+{
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
index f2d0c3320d..1b118074e3 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
@@ -45,20 +45,18 @@ class JavaGlobalRef {
     ~JavaGlobalRef();
 
     JavaGlobalRef& operator=(JavaGlobalRef&& rhs);
+    JavaGlobalRef(JavaGlobalRef&);
 
     inline operator bool() const noexcept
     {
         return m_ref != nullptr;
     }
 
-    inline jobject get() noexcept
+    inline jobject get() const noexcept
     {
         return m_ref;
     }
 
-    // Not implemented for now.
-    JavaGlobalRef(JavaGlobalRef&) = delete;
-
 private:
     jobject m_ref;
 };
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index 283c948fba..3026ee5a08 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -41,15 +41,24 @@ class JavaLocalRef {
     inline JavaLocalRef(JNIEnv* env, T obj, NeedToCreateLocalRef) noexcept
         : m_jobject(env->NewLocalRef(obj))
         , m_env(env){};
+
     inline ~JavaLocalRef()
     {
         m_env->DeleteLocalRef(m_jobject);
     }
 
-    JavaLocalRef(const JavaLocalRef&) = delete;
-    JavaLocalRef& operator=(const JavaLocalRef&) = delete;
-    JavaLocalRef(JavaLocalRef&& rhs) = delete;
-    JavaLocalRef& operator=(JavaLocalRef&& rhs) = delete;
+    JavaLocalRef& operator=(JavaLocalRef&& rhs)
+    {
+        this->~JavaLocalRef();
+        new (this) JavaLocalRef(std::move(rhs));
+        return *this;
+    }
+
+    inline JavaLocalRef(JavaLocalRef&& rhs)
+            : m_env(rhs.m_env), m_jobject(rhs.m_jobject)
+    {
+        rhs.m_jobject = nullptr;
+    }
 
     inline operator bool() const noexcept
     {
@@ -59,6 +68,13 @@ class JavaLocalRef {
     {
         return m_jobject;
     }
+    inline T get() const noexcept
+    {
+        return m_jobject;
+    };
+
+    JavaLocalRef(const JavaLocalRef&) = delete;
+    JavaLocalRef& operator=(const JavaLocalRef&) = delete;
 
 private:
     T m_jobject;
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
index 8c51f2a570..b9a5261c85 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
@@ -32,9 +32,9 @@
     /**
      * This will be called when the async query is finished the first time or the collection of objects has changed.
      *
-     * @param collection the collection this listener is registered to.
+     * @param t the collection this listener is registered to.
      * @param changeSet object with information about which rows in the collection were added, removed or modified.
      * {@code null} is returned the first time an async query is completed.
      */
-    void onChange(T collection, OrderedCollectionChangeSet changeSet);
+    void onChange(T t, OrderedCollectionChangeSet changeSet);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 10068d8fb0..1ee29a820d 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -260,6 +260,8 @@ private static void checkFilesDirAvailable(Context context) {
      * @throws RealmMigrationNeededException if no migration has been provided by the default configuration and the
      * RealmObject classes or version has has changed so a migration is required.
      * @throws RealmFileException if an error happened when accessing the underlying Realm file.
+     * @throws io.realm.exceptions.DownloadingRealmInterruptedException if {@link SyncConfiguration.Builder#waitForInitialRemoteData()}
+     * was set and the thread opening the Realm was interrupted while the download was in progress.
      */
     public static Realm getDefaultInstance() {
         if (defaultConfiguration == null) {
@@ -277,6 +279,8 @@ public static Realm getDefaultInstance() {
      * classes or version has has changed so a migration is required.
      * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
+     * @throws io.realm.exceptions.DownloadingRealmInterruptedException if {@link SyncConfiguration.Builder#waitForInitialRemoteData()}
+     * was set and the thread opening the Realm was interrupted while the download was in progress.
      * @see RealmConfiguration for details on how to configure a Realm.
      */
     public static Realm getInstance(RealmConfiguration configuration) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 8b158e4ba1..6d479323a8 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -24,12 +24,12 @@
 import java.util.Collection;
 import java.util.EnumMap;
 import java.util.Iterator;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.exceptions.RealmFileException;
@@ -111,6 +111,7 @@ public void setFuture(Future future) {
         public void run() {
             T instance = null;
             try {
+                // First call that will run all schema validation, migrations or initial transactions.
                 instance = createRealmOrGetFromCache(configuration, realmClass);
                 boolean results = notifier.post(new Runnable() {
                     @Override
@@ -128,6 +129,9 @@ public void run() {
                         T instanceToReturn = null;
                         Throwable throwable = null;
                         try {
+                            // This will run on the caller thread, but since the first `createRealmOrGetFromCache`
+                            // should have completed at this point, all expensive initializer functions have already
+                            // run.
                             instanceToReturn = createRealmOrGetFromCache(configuration, realmClass);
                         } catch (Throwable e) {
                             throwable = e;
@@ -152,13 +156,18 @@ public void run() {
             } catch (InterruptedException e) {
                 RealmLog.warn(e, "`CreateRealmRunnable` has been interrupted.");
             } catch (final Throwable e) {
-                RealmLog.error(e, "`CreateRealmRunnable` failed.");
-                notifier.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        callback.onError(e);
-                    }
-                });
+                // DownloadingRealmInterruptedException is treated specially.
+                // It async open is canceled, this could interrupt the download, but the user should
+                // not care in this case, so just ignore it.
+                if (!ObjectServerFacade.getSyncFacadeIfPossible().wasDownloadInterrupted(e)) {
+                    RealmLog.error(e, "`CreateRealmRunnable` failed.");
+                    notifier.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onError(e);
+                        }
+                    });
+                }
             } finally {
                 if (instance != null) {
                     instance.close();
@@ -281,10 +290,30 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
 
         if (getTotalGlobalRefCount() == 0) {
             copyAssetFileIfNeeded(configuration);
+            boolean fileExists = configuration.realmExists();
 
             SharedRealm sharedRealm = null;
             try {
                 sharedRealm = SharedRealm.getInstance(configuration);
+
+                // If waitForInitialRemoteData() was enabled, we need to make sure that all data is downloaded
+                // before proceeding. We need to open the Realm instance first to start any potential underlying
+                // SyncSession so this will work. TODO: This needs to be decoupled.
+                if (!fileExists) {
+                    try {
+                        ObjectServerFacade.getSyncFacadeIfPossible().downloadRemoteChanges(configuration);
+                    } catch (Throwable t) {
+                        // If an error happened while downloading initial data, we need to reset the file so we can
+                        // download it again on the next attempt.
+                        // Realm.deleteRealm() is under the same lock as this method and globalCount is still 0, so
+                        // this should be safe.
+                        sharedRealm.close();
+                        sharedRealm = null;
+                        Realm.deleteRealm(configuration);
+                        throw t;
+                    }
+                }
+
                 if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
                     sharedRealm.beginTransaction();
                     if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
@@ -492,6 +521,8 @@ synchronized void invokeWithLock(Callback0 callback) {
      * Copies Realm database file from Android asset directory to the directory given in the {@link RealmConfiguration}.
      * Copy is performed only at the first time when there is no Realm database file.
      *
+     * WARNING: This method is not thread-safe so external synchronization is required before using it.
+     *
      * @param configuration configuration object for Realm instance.
      * @throws RealmFileException if copying the file fails.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
index fac6e8f70b..fed06316bb 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -42,6 +42,6 @@
     /**
      * Called when a transaction is committed.
      */
-    void onChange(T element);
+    void onChange(T t);
 
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index fd8312fde2..064a656a37 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -200,10 +200,27 @@ InputStream getAssetFile() throws IOException {
         return schemaMediator.getModelClasses();
     }
 
+    /**
+     * Returns the absolute path to where the Realm file will be saved.
+     *
+     * @return the absolute path to the Realm file defined by this configuration.
+     */
     public String getPath() {
         return canonicalPath;
     }
 
+    /**
+     * Checks if the Realm file defined by this configuration already exists.
+     *
+     * WARNING: This method is just a point-in-time check. Unless protected by external synchronization another
+     * thread or process might have created or deleted the Realm file right after this method has returned.
+     *
+     * @return {@code true} if the Realm file exists, {@code false} otherwise.
+     */
+    boolean realmExists() {
+        return new File(canonicalPath).exists();
+    }
+
     /**
      * Returns the {@link RxObservableFactory} that is used to create Rx Observables from Realm objects.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
index af172a0e16..4ab96596aa 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
@@ -51,8 +51,8 @@
      * <p>
      * Changes to {@link LinkingObjects} annotated {@link RealmResults} fields will not be monitored, nor reported
      * through this change listener.
-     * @param object the {@code RealmObject} this listener is registered to.
+     * @param t the {@code RealmObject} this listener is registered to.
      * @param changeSet the detailed information about the changes.
      */
-    void onChange(T object, ObjectChangeSet changeSet);
+    void onChange(T t, ObjectChangeSet changeSet);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java b/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
index 5eaa72a770..062fdcd285 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
@@ -35,4 +35,10 @@
      * @param exceptionMessage message which is contained in the exception.
      */
     void checkCanDeliverNotification(String exceptionMessage);
+
+    /**
+     * Multiple threads might be able to deliver notifications, but the Main thread in GUI applications often have
+     * special rules that need to be enforced.
+     */
+    boolean isMainThread();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 7493da59d9..253694a12b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -88,4 +88,21 @@ public static ObjectServerFacade getSyncFacadeIfPossible() {
     // If no session yet exists for this path. Wrap a new Java Session around an existing OS one.
     public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
     }
+
+    /**
+     * Block until all latest changes have been downloaded from the server.
+     *
+     * @throws {@code DownloadingRealmInterruptedException}  if the thread was interrupted while blocked waiting for
+     * this to complete.
+     */
+    public void downloadRemoteChanges(RealmConfiguration config) {
+        // Do nothing
+    }
+
+    /**
+     * Check if an exception is a {@code DownloadingRealmInterruptedException}
+     */
+    public boolean wasDownloadInterrupted(Throwable throwable) {
+        return false;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 21b041baec..70acf9617e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -128,6 +128,7 @@ public byte getNativeValue() {
 
         @Override
         public int compareTo(@SuppressWarnings("NullableProblems") VersionID another) {
+            //noinspection ConstantConditions
             if (another == null) {
                 throw new IllegalArgumentException("Version cannot be compared to a null value.");
             }
@@ -214,17 +215,18 @@ public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionLi
         String syncRealmUrl = syncUserConf[1];
         String syncRealmAuthUrl = syncUserConf[2];
         String syncRefreshToken = syncUserConf[3];
-        boolean enable_caching = false; // Handled in Java currently
-        boolean disableFormatUpgrade = false; // TODO Double negatives :/
+
+        final boolean enableCaching = false; // Handled in Java currently
+        final boolean enableFormatUpgrade = true;
 
         long nativeConfigPtr = nativeCreateConfig(
                 config.getPath(),
                 config.getEncryptionKey(),
                 syncRealmUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
                 config.getDurability() == Durability.MEM_ONLY,
-                enable_caching,
+                enableCaching,
                 config.getSchemaVersion(),
-                disableFormatUpgrade,
+                enableFormatUpgrade,
                 autoChangeNotifications,
                 syncRealmUrl,
                 syncRealmAuthUrl,
@@ -314,10 +316,6 @@ public void refresh() {
         return new SharedRealm.VersionID(versionId[0], versionId[1]);
     }
 
-    public long getLastSnapshotVersion() {
-        return nativeGetSnapshotVersion(nativePtr);
-    }
-
     public boolean isClosed() {
         return nativeIsClosed(nativePtr);
     }
@@ -463,7 +461,9 @@ private void executePendingRowQueries() {
 
     // Keep last session as an 'object' to avoid any reference to sync code
     private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
-            boolean cache, long schemaVersion, boolean disableFormatUpgrade,
+            boolean cache,
+            long schemaVersion,
+            boolean enabledFormatUpgrade,
             boolean autoChangeNotification,
             String syncServerURL,
             String syncServerAuthURL,
@@ -488,8 +488,6 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
 
     private static native long nativeGetVersion(long nativeSharedRealmPtr);
 
-    private static native long nativeGetSnapshotVersion(long nativeSharedRealmPtr);
-
     private static native void nativeSetVersion(long nativeSharedRealmPtr, long version);
 
     private static native long nativeReadGroup(long nativeSharedRealmPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
index 78ea5a92dc..c7f08f7ae5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
@@ -25,22 +25,22 @@
  */
 public class AndroidCapabilities implements Capabilities {
 
-    private final boolean hasLooper;
+    private final Looper looper;
     private final boolean isIntentServiceThread;
 
     public AndroidCapabilities() {
-        hasLooper = Looper.myLooper() != null;
+        looper = Looper.myLooper();
         isIntentServiceThread = isIntentServiceThread();
     }
 
     @Override
     public boolean canDeliverNotification() {
-        return hasLooper && !isIntentServiceThread;
+        return hasLooper() && !isIntentServiceThread;
     }
 
     @Override
     public void checkCanDeliverNotification(String exceptionMessage) {
-        if (!hasLooper) {
+        if (!hasLooper()) {
             throw new IllegalStateException(exceptionMessage == null ? "" : (exceptionMessage + " ") +
                     "Realm cannot be automatically updated on a thread without a looper.");
         }
@@ -50,6 +50,15 @@ public void checkCanDeliverNotification(String exceptionMessage) {
         }
     }
 
+    @Override
+    public boolean isMainThread() {
+        return looper != null && looper == Looper.getMainLooper();
+    }
+
+    private boolean hasLooper() {
+        return looper != null;
+    }
+
     private static boolean isIntentServiceThread() {
         // Tries to determine if a thread is an IntentService thread. No public API can detect this,
         // so use the thread name as a heuristic:
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index e2eb671721..160c506996 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -78,6 +78,7 @@
     private final SyncUser user;
     private final SyncSession.ErrorHandler errorHandler;
     private final boolean deleteRealmOnLogout;
+    private final boolean waitForInitialData;
 
     private SyncConfiguration(File directory,
                                 String filename,
@@ -94,7 +95,9 @@ private SyncConfiguration(File directory,
                                 SyncUser user,
                                 URI serverUrl,
                                 SyncSession.ErrorHandler errorHandler,
-                                boolean deleteRealmOnLogout
+                                boolean deleteRealmOnLogout,
+                                boolean waitForInitialData
+
     ) {
         super(directory,
                 filename,
@@ -114,6 +117,7 @@ private SyncConfiguration(File directory,
         this.serverUrl = serverUrl;
         this.errorHandler = errorHandler;
         this.deleteRealmOnLogout = deleteRealmOnLogout;
+        this.waitForInitialData = waitForInitialData;
     }
 
     static URI resolveServerUrl(URI serverUrl, String userIdentifier) {
@@ -149,6 +153,7 @@ public boolean equals(Object o) {
         if (!serverUrl.equals(that.serverUrl)) return false;
         if (!user.equals(that.user)) return false;
         if (!errorHandler.equals(that.errorHandler)) return false;
+        if (waitForInitialData != that.waitForInitialData) return false;
         return true;
     }
 
@@ -159,6 +164,7 @@ public int hashCode() {
         result = 31 * result + user.hashCode();
         result = 31 * result + (deleteRealmOnLogout ? 1 : 0);
         result = 31 * result + errorHandler.hashCode();
+        result = 31 * result + (waitForInitialData ? 1 : 0);
         return result;
     }
 
@@ -173,6 +179,8 @@ public String toString() {
         stringBuilder.append("errorHandler: " + errorHandler);
         stringBuilder.append("\n");
         stringBuilder.append("deleteRealmOnLogout: " + deleteRealmOnLogout);
+        stringBuilder.append("\n");
+        stringBuilder.append("waitForInitialRemoteData: " + waitForInitialData);
         return stringBuilder.toString();
     }
 
@@ -209,6 +217,18 @@ public boolean shouldDeleteRealmOnLogout() {
         return deleteRealmOnLogout;
     }
 
+
+    /**
+     * Returns {@code true} if the Realm will download all known changes from the remote server before being opened the
+     * first time.
+     *
+     * @return {@code true} if all remote changes will be downloaded before the Realm can be opened. {@code false} if
+     * the Realm can be opened immediately.
+     */
+    public boolean shouldWaitForInitialRemoteData() {
+        return waitForInitialData;
+    }
+
     @Override
     boolean isSyncConfiguration() {
         return true;
@@ -237,6 +257,7 @@ boolean isSyncConfiguration() {
         private SharedRealm.Durability durability = SharedRealm.Durability.FULL;
         private boolean deleteRealmOnLogout = false;
         private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
+        private boolean waitForServerChanges = false;
 
         /**
          * Creates an instance of the Builder for the SyncConfiguration.
@@ -573,6 +594,23 @@ public Builder errorHandler(SyncSession.ErrorHandler errorHandler) {
             return this;
         }
 
+        /**
+         * Setting this will cause the Realm to download all known changes from the server the first time a Realm is
+         * opened. The Realm will not open until all the data has been downloaded. This means that if a device is
+         * offline the Realm will not open.
+         * <p>
+         * Since downloading all changes can be an lengthy operation that might block the UI thread, Realms with this
+         * setting enabled should only be opened on background threads or with
+         * {@link Realm#getInstanceAsync(RealmConfiguration, Realm.Callback)} on the UI thread.
+         * <p>
+         * This check is only enforced the first time a Realm is created. If you otherwise want to make sure a Realm
+         * has the latest changes, use {@link SyncSession#downloadAllServerChanges()}.
+         */
+        public Builder waitForInitialRemoteData() {
+            this.waitForServerChanges = true;
+            return this;
+        }
+
         private String MD5(String in) {
             try {
                 MessageDigest digest = MessageDigest.getInstance("MD5");
@@ -685,7 +723,8 @@ public SyncConfiguration build() {
                     user,
                     resolvedServerUrl,
                     errorHandler,
-                    deleteRealmOnLogout
+                    deleteRealmOnLogout,
+                    waitForServerChanges
             );
         }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index b456318617..b008a2fae3 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -17,15 +17,18 @@
 package io.realm;
 
 import java.net.URI;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.internal.Keep;
 import io.realm.internal.KeepMember;
 import io.realm.internal.SyncObjectServerFacade;
+import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
@@ -59,6 +62,8 @@
     private RealmAsyncTask refreshTokenNetworkRequest;
     private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean(false);
     private volatile boolean isClosed = false;
+    private final AtomicReference<WaitForServerChangesWrapper> waitingForServerChanges = new AtomicReference<>(null);
+    private final Object waitForChangesMutex = new Object();
 
     SyncSession(SyncConfiguration configuration) {
         this.configuration = configuration;
@@ -118,6 +123,70 @@ void close() {
         clearScheduledAccessTokenRefresh();
     }
 
+    // This method will be called once all changes have been downloaded.
+    // This method might be called on another thread than the one that called `downloadAllServerChanges`.
+    // Be very careful with synchronized blocks.
+    // If the native listener was successfully registered, Object Store guarantees that this method will be called at
+    // least once, even if the session is closed.
+    @SuppressWarnings("unused")
+    private void notifyAllChangesDownloaded(Long errorcode, String errorMessage) {
+        WaitForServerChangesWrapper wrapper = waitingForServerChanges.get();
+        if (wrapper != null) {
+            wrapper.handleResult(errorcode, errorMessage);
+        }
+    }
+
+    /**
+     * Calling this method will block until all known remote changes have been downloaded and applied to the Realm.
+     * This will involve network access, so calling this method should only be done from a non-UI thread.
+     * <p>
+     * If the device is offline, this method might never return.
+     * <p>
+     * This method cannot be called before the session has been started.
+     *
+     * @throws IllegalStateException if called on the Android main thread.
+     * @throws InterruptedException if the thread was interrupted while downloading was in progress.
+     */
+    public void downloadAllServerChanges() throws InterruptedException {
+        checkIfNotOnMainThread("downloadAllServerChanges() cannot be called from the main thread.");
+
+        // Blocking only happens at the Java layer. To prevent deadlocking the underlying SyncSession we register
+        // an async listener there and let it callback to the Java Session when done. This feels icky at best, but
+        // since all operations on the SyncSession operate under a shared mutex, we would prevent all other actions on the
+        // session, including trying to stop it.
+        // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
+        // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
+        synchronized (waitForChangesMutex) {
+            if (!isClosed) {
+                WaitForServerChangesWrapper wrapper = new WaitForServerChangesWrapper();
+                waitingForServerChanges.set(wrapper);
+                boolean listenerRegistered = nativeWaitForDownloadCompletion(configuration.getPath());
+                if (!listenerRegistered) {
+                    waitingForServerChanges.set(null);
+                    throw new ObjectServerError(ErrorCode.UNKNOWN, "It was not possible to download all changes. Has the SyncClient been started?");
+                }
+                wrapper.waitForServerChanges();
+
+                // This might return after the session was closed. In that case, just ignore any result
+                try {
+                    if (!isClosed) {
+                        if (!wrapper.isSuccess()) {
+                            wrapper.throwExceptionIfNeeded();
+                        }
+                    }
+                } finally {
+                    waitingForServerChanges.set(null);
+                }
+            }
+        }
+    }
+
+    private void checkIfNotOnMainThread(String errorMessage) {
+        if (new AndroidCapabilities().isMainThread()) {
+            throw new IllegalStateException(errorMessage);
+        }
+    }
+
     /**
      * Interface used to report any session errors.
      *
@@ -351,6 +420,52 @@ private void clearScheduledAccessTokenRefresh() {
         }
     }
 
+    // Wrapper class for handling the async operations of the underlying SyncSession calling `async_wait_for_download_completion`
+    private static class WaitForServerChangesWrapper {
+
+        private final CountDownLatch waitForChanges = new CountDownLatch(1);
+        private volatile boolean resultReceived = false;
+        private Long errorCode = null;
+        private String errorMessage;
+
+        /**
+         * Block until the wait either completes or is terminated for other reasons.
+         */
+        public void waitForServerChanges() throws InterruptedException {
+            if (!resultReceived) {
+               waitForChanges.await();
+            }
+        }
+
+        /**
+         * Process the result of a waiting action. This will also unblock anyone who called {@link #waitForChanges}.
+         *
+         * @param errorCode error code if an error occurred, {@code null} if changes were successfully downloaded.
+         * @param errorMessage error message (if any).
+         */
+        public void handleResult(Long errorCode, String errorMessage) {
+            this.errorCode = errorCode;
+            this.errorMessage = errorMessage;
+            this.resultReceived = true;
+            waitForChanges.countDown();
+        }
+
+        public boolean isSuccess() {
+            return resultReceived && errorCode == null;
+        }
+
+        /**
+         * Will throw an exception if the wait was terminated with an error. If it was canceled, this method will
+         * do nothing.
+         */
+        public void throwExceptionIfNeeded() {
+            if (resultReceived && errorCode != null) {
+                throw new ObjectServerError(ErrorCode.UNKNOWN, String.format("Internal error (%d): %s", errorCode, errorMessage));
+            }
+        }
+    }
+
     private static native boolean nativeRefreshAccessToken(String path, String accessToken, String authURL);
+    private native boolean nativeWaitForDownloadCompletion(String path);
 }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java b/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
new file mode 100644
index 0000000000..0460d297d5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import io.realm.SyncConfiguration;
+
+
+/**
+ * Exception class used when a Realm was interrupted while downloading the initial data set.
+ * This can only happen if {@link SyncConfiguration.Builder#waitForInitialRemoteData()} is set.
+ */
+public class DownloadingRealmInterruptedException extends RuntimeException {
+    public DownloadingRealmInterruptedException(SyncConfiguration syncConfig, Throwable exception) {
+        super("Realm was interrupted while downloading the latest changes from the server: " + syncConfig.getPath(),
+                exception);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index c976c0bc08..4bc4eff614 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -27,6 +27,8 @@
 import io.realm.RealmConfiguration;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.network.NetworkStateReceiver;
 
@@ -129,4 +131,24 @@ private void invokeRemoveSession(SyncConfiguration syncConfig) {
             throw new RealmException("Could not remove session: " + syncConfig.toString(), e);
         }
     }
+
+    @Override
+    public void downloadRemoteChanges(RealmConfiguration config) {
+        if (config instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) config;
+            if (syncConfig.shouldWaitForInitialRemoteData()) {
+                SyncSession session = SyncManager.getSession(syncConfig);
+                try {
+                    session.downloadAllServerChanges();
+                } catch (InterruptedException e) {
+                    throw new DownloadingRealmInterruptedException(syncConfig, e);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean wasDownloadInterrupted(Throwable throwable) {
+        return (throwable instanceof DownloadingRealmInterruptedException);
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java
new file mode 100644
index 0000000000..4881139b82
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.Random;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.Realm;
+import io.realm.RealmAsyncTask;
+import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.exceptions.DownloadingRealmInterruptedException;
+import io.realm.objectserver.utils.Constants;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+/**
+ * Catch all class for tests that not naturally fit anywhere else.
+ */
+public class SyncedRealmTests extends BaseIntegrationTest {
+
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
+    @Test
+    @UiThreadTest
+    public void waitForInitialRemoteData_mainThreadThrows() {
+        final SyncUser user = loginUser();
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (IllegalStateException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // Login user on a worker thread, so this method can be used from both UI and non-ui threads.
+    @NonNull
+    private SyncUser loginUser() {
+        final CountDownLatch userReady = new CountDownLatch(1);
+        final AtomicReference<SyncUser> user = new AtomicReference<>();
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+                user.set(SyncUser.login(credentials, Constants.AUTH_URL));
+                userReady.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(userReady);
+        return user.get();
+    }
+
+    @Test
+    public void waitForInitialRemoteData() {
+        // TODO We can improve this test once we got Sync Progress Notifications. Right now we cannot detect
+        // when a Realm has been uploaded.
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            assertTrue(realm.isEmpty());
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that
+    // We cannot do much better since we cannot control the order of events internally in Realm which would be
+    // needed to correctly test all error paths.
+    @Test
+    public void waitForInitialData_resilientInCaseOfRetries() throws InterruptedException {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        for (int i = 0; i < 10; i++) {
+            Thread t = new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Realm realm = null;
+                    try {
+                        // This will cause the download latch called later to immediately throw an InterruptedException.
+                        Thread.currentThread().interrupt();
+                        realm = Realm.getInstance(config);
+                    } catch (DownloadingRealmInterruptedException ignored) {
+                        assertFalse(new File(config.getPath()).exists());
+                    } finally {
+                        if (realm != null) {
+                            realm.close();
+                            Realm.deleteRealm(config);
+                        }
+                    }
+                }
+            });
+            t.start();
+            t.join();
+        }
+    }
+
+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that
+    // We cannot do much better since we cannot control the order of events internally in Realm which would be
+    // needed to correctly test all error paths.
+    @Test
+    @RunTestInLooperThread
+    public void waitForInitialData_resilientInCaseOfRetriesAsync() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+        Random randomizer = new Random();
+
+        for (int i = 0; i < 10; i++) {
+            final int iteration = i;
+            RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    fail();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    fail(exception.toString());
+                }
+            });
+            SystemClock.sleep(randomizer.nextInt(5));
+            task.cancel();
+        }
+        looperThread.testComplete();
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index 02d9ddf64c..71f273f865 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -18,6 +18,7 @@
 
 public class Constants {
 
+    public static final String USER_REALM = "realm://127.0.0.1:9080/~/tests";
     public static final String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
     public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
 
