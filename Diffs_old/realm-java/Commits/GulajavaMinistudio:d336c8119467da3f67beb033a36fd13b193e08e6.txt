diff --git a/CHANGELOG.md b/CHANGELOG.md
index 18d5167ed2..1bd465fb72 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,16 +1,25 @@
 ## 4.1.0 (YYYY-MM-DD)
 
-## Breaking Changes
-
 ## Enhancements
 
+* `Realm.deleteRealm()` and `RealmConfiguration.assetFile()` are multi-processes safe now.
+
 ## Bug Fixes
 
+* Fix some potential database corruption caused by deleting the Realm file while a Realm instance are still opened in another process or the sync client thread.
+
 ## Internal
 
 ### Credits
 
 
+## 4.0.1 (YYYY-MM-DD)
+
+## Bug Fixes
+
+* Added `realm.ignoreKotlinNullability` as a kapt argument to disable treating kotlin non-null types as `@Required` (#5412) (introduced in `v3.6.0`).
+
+
 ## 4.0.0 (2016-10-16)
 
 ## Breaking Changes
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 3f9cae0b10..cb8b7a54c7 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -51,6 +51,8 @@
  * Utility class for holding metadata for RealmProxy classes.
  */
 public class ClassMetaData {
+    private static final String OPTION_IGNORE_KOTLIN_NULLABILITY = "realm.ignoreKotlinNullability";
+
     private final TypeElement classType; // Reference to model class.
     private final String className; // Model class simple name.
     private final List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
@@ -71,6 +73,8 @@
     private final Types typeUtils;
     private final Elements elements;
 
+    private final boolean ignoreKotlinNullability;
+
     public ClassMetaData(ProcessingEnvironment env, TypeMirrors typeMirrors, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
@@ -111,6 +115,9 @@ public ClassMetaData(ProcessingEnvironment env, TypeMirrors typeMirrors, TypeEle
                 }
             }
         }
+
+        ignoreKotlinNullability = Boolean.valueOf(
+                env.getOptions().getOrDefault(OPTION_IGNORE_KOTLIN_NULLABILITY, "false"));
     }
 
     @Override
@@ -524,6 +531,10 @@ private boolean isRequiredField(VariableElement field) {
             return true;
         }
 
+        if (ignoreKotlinNullability) {
+            return false;
+        }
+
         // Kotlin uses the `org.jetbrains.annotations.NotNull` annotation to mark non-null fields.
         // In order to fully support the Kotlin type system we interpret `@NotNull` as an alias
         // for `@Required`
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 758a5ce031..1d68cae873 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -124,7 +124,7 @@
         "io.realm.annotations.RealmModule",
         "io.realm.annotations.Required"
 })
-@SupportedOptions(value = {"realm.suppressWarnings"})
+@SupportedOptions(value = {"realm.suppressWarnings", "realm.ignoreKotlinNullability"})
 public class RealmProcessor extends AbstractProcessor {
 
     // Don't consume annotations. This allows 3rd party annotation processors to run.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 463d43a410..48d43d74d0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -2301,8 +2301,11 @@ public void run() {
 
         assertTrue(Realm.deleteRealm(configuration));
 
-        // Directory should be empty now.
-        assertEquals(0, tempDir.listFiles().length);
+        assertEquals(1, tempDir.listFiles().length);
+
+        // Lock file should never be deleted
+        File lockFile = new File(configuration.getPath() + ".lock");
+        assertTrue(lockFile.exists());
     }
 
     // Tests that all methods that require a transaction. (ie. any function that mutates Realm data)
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
index 52e5711b8b..9175df0012 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -57,15 +57,13 @@
 
     private final long[] oneNullTable = new long[] {NativeObject.NULLPTR};
 
-    private RealmConfiguration config;
     private SharedRealm sharedRealm;
     private Table table;
 
     @Before
     public void setUp() {
-        config = configFactory.createConfiguration();
         sharedRealm = getSharedRealm();
-        populateData();
+        populateData(sharedRealm);
     }
 
     @After
@@ -74,6 +72,16 @@ public void tearDown() {
     }
 
     private SharedRealm getSharedRealm() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        return getSharedRealm(config);
+    }
+
+    private SharedRealm getSharedRealmForLooper() {
+        RealmConfiguration config = looperThread.createConfiguration();
+        return getSharedRealm(config);
+    }
+
+    private SharedRealm getSharedRealm(RealmConfiguration config) {
         OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
                 .autoUpdateNotification(true);
         SharedRealm sharedRealm = SharedRealm.getInstance(configBuilder);
@@ -87,7 +95,7 @@ private Table getTable(SharedRealm sharedRealm) {
         return sharedRealm.getTable(Table.getTableNameForClass("test_table"));
     }
 
-    private void populateData() {
+    private void populateData(SharedRealm sharedRealm) {
         sharedRealm.beginTransaction();
         table = sharedRealm.createTable(Table.getTableNameForClass("test_table"));
         // Specify the column types and names
@@ -119,12 +127,13 @@ private void populateData() {
         sharedRealm.commitTransaction();
     }
 
-    private void addRowAsync() {
+    private void addRowAsync(final SharedRealm sharedRealm) {
         final CountDownLatch latch = new CountDownLatch(1);
+        final RealmConfiguration configuration = sharedRealm.getConfiguration();
         new Thread(new Runnable() {
             @Override
             public void run() {
-                SharedRealm sharedRealm = getSharedRealm();
+                SharedRealm sharedRealm = getSharedRealm(configuration);
                 addRow(sharedRealm);
                 sharedRealm.close();
                 latch.countDown();
@@ -253,7 +262,8 @@ public void distinct() {
     @Test
     @RunTestInLooperThread
     public void addListener_shouldBeCalledToReturnTheQueryResults() {
-        final SharedRealm sharedRealm = getSharedRealm();
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
@@ -332,7 +342,7 @@ public void onChange(Collection element) {
             }
         });
 
-        addRowAsync();
+        addRowAsync(sharedRealm);
 
         sharedRealm.waitForChange();
         sharedRealm.refresh();
@@ -342,7 +352,8 @@ public void onChange(Collection element) {
     @Test
     @RunTestInLooperThread
     public void addListener_queryNotReturned() {
-        final SharedRealm sharedRealm = getSharedRealm();
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
@@ -357,13 +368,14 @@ public void onChange(Collection collection1) {
             }
         });
 
-        addRowAsync();
+        addRowAsync(sharedRealm);
     }
 
     @Test
     @RunTestInLooperThread
     public void addListener_queryReturned() {
-        final SharedRealm sharedRealm = getSharedRealm();
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
         Table table = getTable(sharedRealm);
 
         final Collection collection = new Collection(sharedRealm, table.where());
@@ -379,7 +391,7 @@ public void onChange(Collection collection1) {
             }
         });
 
-        addRowAsync();
+        addRowAsync(sharedRealm);
     }
 
     // Local commit will trigger the listener first when beginTransaction gets called then again when transaction
@@ -387,7 +399,8 @@ public void onChange(Collection collection1) {
     @Test
     @RunTestInLooperThread
     public void addListener_triggeredByLocalCommit() {
-        final SharedRealm sharedRealm = getSharedRealm();
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
         Table table = getTable(sharedRealm);
         final AtomicInteger listenerCounter = new AtomicInteger(0);
 
@@ -468,7 +481,8 @@ public void collectionIterator_invalid_nonLooperThread_byRefresh() {
     @Test
     @RunTestInLooperThread
     public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
-        final SharedRealm sharedRealm = getSharedRealm();
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
         Table table = getTable(sharedRealm);
         final Collection collection = new Collection(sharedRealm, table.where());
         final TestIterator iterator = new TestIterator(collection);
@@ -487,7 +501,7 @@ public void onChange(Collection element) {
             }
         });
 
-        addRowAsync();
+        addRowAsync(sharedRealm);
     }
 
     @Test
@@ -522,6 +536,9 @@ public void onChange(Collection element) {
     @Test
     @RunTestInLooperThread
     public void load() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        looperThread.closeAfterTest(sharedRealm);
+        populateData(sharedRealm);
         final Collection collection = new Collection(sharedRealm, table.where());
         collection.addListener(collection, new RealmChangeListener<Collection>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
index 74e66ff861..a0c0d8cac8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
@@ -19,6 +19,7 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -39,16 +40,13 @@
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    @SuppressWarnings("FieldCanBeLocal")
-    private RealmConfiguration config;
-    @SuppressWarnings("FieldCanBeLocal")
     private SharedRealm sharedRealm;
     private Table table;
 
     @Before
     public void setUp() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        config = configFactory.createConfiguration();
+        RealmConfiguration config = configFactory.createConfiguration();
         sharedRealm = SharedRealm.getInstance(config);
 
         table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
@@ -60,6 +58,13 @@ public void execute(Table table) {
         });
     }
 
+    @After
+    public void tearDown() {
+        if (sharedRealm != null) {
+            sharedRealm.close();
+        }
+    }
+
     @Test
     public void shouldGetColumnInformation() {
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 3ddea3c362..dc61fbf252 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -19,6 +19,7 @@
 import android.support.test.runner.AndroidJUnit4;
 import android.util.Pair;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -60,6 +61,13 @@ public void setUp() {
         sharedRealm = SharedRealm.getInstance(config);
     }
 
+    @After
+    public void tearDown() {
+        if (sharedRealm != null)  {
+            sharedRealm.close();
+        }
+    }
+
     @Test
     public void tableToString() {
         Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
@@ -307,10 +315,6 @@ public void execute(Table t) {
     @Test
     public void getName() {
         String TABLE_NAME = "tableName";
-        RealmConfiguration configuration = configFactory.createConfiguration();
-        Realm.deleteRealm(configuration);
-
-        SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
         //noinspection TryFinallyCanBeTryWithResources
         try {
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
new file mode 100644
index 0000000000..cb9e620b1b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import io.realm.RealmConfiguration;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+// Tests for OsObjectStore
+@RunWith(AndroidJUnit4.class)
+public class OsObjectStoreTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @Test
+    public void callWithLock() {
+        RealmConfiguration config = configFactory.createConfiguration();
+
+        // Return false if there are opened SharedRealm instance
+        SharedRealm sharedRealm = SharedRealm.getInstance(config);
+        assertFalse(OsObjectStore.callWithLock(config, new Runnable() {
+            @Override
+            public void run() {
+                fail();
+            }
+        }));
+        sharedRealm.close();
+
+        final AtomicBoolean callbackCalled = new AtomicBoolean(false);
+        assertTrue(OsObjectStore.callWithLock(config, new Runnable() {
+            @Override
+            public void run() {
+                callbackCalled.set(true);
+            }
+        }));
+        assertTrue(callbackCalled.get());
+    }
+
+    // Test if a java exception can be thrown from the callback.
+    @Test
+    public void callWithLock_throwInCallback() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        final RuntimeException exception = new RuntimeException();
+
+        try {
+            OsObjectStore.callWithLock(config, new Runnable() {
+                @Override
+                public void run() {
+                    throw exception;
+                }
+            });
+            fail();
+        } catch (RuntimeException e) {
+            assertEquals(exception, e);
+        }
+
+        // The lock should be released after exception thrown
+        final AtomicBoolean callbackCalled = new AtomicBoolean(false);
+        assertTrue(OsObjectStore.callWithLock(config, new Runnable() {
+            @Override
+            public void run() {
+                callbackCalled.set(true);
+            }
+        }));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
index 44ac4bcdb6..87ba794501 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -110,15 +110,11 @@ public void onChange(SharedRealm sharedRealm) {
     }
 
     private void makeRemoteChanges(final RealmConfiguration config) {
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                SharedRealm sharedRealm = getSharedRealm(config);
-                sharedRealm.beginTransaction();
-                sharedRealm.commitTransaction();
-                sharedRealm.close();
-            }
-        }).start();
+        // We don't use cache from RealmCoordinator
+        SharedRealm sharedRealm = getSharedRealm(config);
+        sharedRealm.beginTransaction();
+        sharedRealm.commitTransaction();
+        sharedRealm.close();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 8f998e57c7..ebc149f8c5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -297,6 +297,7 @@ protected void after() {
 
     @Override
     public Statement apply(Statement base, Description description) {
+        setTestName(description);
         final RunTestInLooperThread annotation = description.getAnnotation(RunTestInLooperThread.class);
         if (annotation == null) {
             return base;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 66827fa920..74a0ec5a15 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -28,6 +28,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Collections;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -48,12 +49,15 @@
     private final Set<RealmConfiguration> configurations = Collections.newSetFromMap(map);
 
     private boolean unitTestFailed = false;
+    private String testName = "";
+    private File tempFolder = null;
 
     @Override
-    public Statement apply(final Statement base, Description description) {
+    public Statement apply(final Statement base, final Description description) {
         return new Statement() {
             @Override
             public void evaluate() throws Throwable {
+                setTestName(description);
                 before();
                 try {
                     base.evaluate();
@@ -90,6 +94,30 @@ protected void after() {
         }
     }
 
+    @Override
+    public void create() throws IOException {
+        super.create();
+        tempFolder = new File(super.getRoot(), testName);
+        tempFolder.delete();
+        tempFolder.mkdir();
+    }
+
+    @Override
+    public File getRoot() {
+        if (tempFolder == null) {
+            throw new IllegalStateException(
+                    "the temporary folder has not yet been created");
+        }
+        return tempFolder;
+    }
+
+    /**
+     * To be called in the {@link #apply(Statement, Description)}.
+     */
+    protected void setTestName(Description description) {
+        testName = description.getDisplayName();
+    }
+
     public synchronized void setUnitTestFailed() {
         this.unitTestFailed = true;
     }
@@ -163,8 +191,9 @@ public void copyRealmFromAssets(Context context, String realmPath, String newNam
     }
 
     public void copyRealmFromAssets(Context context, String realmPath, RealmConfiguration config) throws IOException {
-        // Deletes the existing file before copy
-        Realm.deleteRealm(config);
+        if (new File(config.getPath()).exists()) {
+            throw new IllegalStateException(String.format(Locale.ENGLISH, "%s exists!", config.getPath()));
+        }
 
         File outFile = new File(config.getRealmDirectory(), config.getRealmFileName());
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
index f63b7f937d..a3018f02d8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
@@ -20,6 +20,7 @@
 #include <shared_realm.hpp>
 
 #include "util.hpp"
+#include "jni_util/java_method.hpp"
 #include "jni_util/java_exception_thrower.hpp"
 #include "jni_util/java_exception_thrower.hpp"
 
@@ -140,3 +141,24 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsObjectStore_nativeDeleteTabl
     CATCH_STD()
     return JNI_FALSE;
 }
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsObjectStore_nativeCallWithLock(JNIEnv* env, jclass,
+                                                                                   jstring j_realm_path,
+                                                                                   jobject j_runnable)
+{
+    TR_ENTER();
+    try {
+        JStringAccessor path_accessor(env, j_realm_path);
+        std::string realm_path(path_accessor);
+        static JavaClass runnable_class(env, "java/lang/Runnable");
+        static JavaMethod run_method(env, runnable_class, "run", "()V");
+        bool result = SharedGroup::call_with_lock(realm_path, [&](std::string path) {
+            REALM_ASSERT_RELEASE_EX(realm_path.compare(path) == 0, realm_path.c_str(), path.c_str());
+            env->CallVoidMethod(j_runnable, run_method);
+            TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
+        });
+        return result;
+    }
+    CATCH_STD()
+    return false;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index 9a891e070e..b07e992dc8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -154,7 +154,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSchemaConfi
                                               reinterpret_cast<jlong>(new_shared_realm_ptr), config_global.get(), obj,
                                               old_realm->schema_version());
                 });
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
+                // Close the SharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
+                // that will be too late.
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
+                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
             };
         }
         else {
@@ -185,7 +188,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetCompactOnLa
                     result = env->CallBooleanMethod(obj, should_compact, static_cast<jlong>(totalBytes),
                                                     static_cast<jlong>(usedBytes));
                 });
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
                 return result;
             };
         }
@@ -226,7 +229,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInitializat
                                               reinterpret_cast<jlong>(new_shared_realm_ptr), config_global_ref.get(),
                                               obj);
                 });
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
+                // Close the SharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
+                // that will be too late.
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
+                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
             };
         }
         else {
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
index a867145b08..6278fd7fb8 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
@@ -52,10 +52,14 @@ void JavaExceptionThrower::throw_java_exception(JNIEnv* env)
     env->ThrowNew(m_exception_class, message.c_str());
 }
 
-void JavaExceptionThrower::terminate_jni_if_java_exception_occurred(JNIEnv* env, const char* file_path, int line_num)
+void JavaExceptionThrower::terminate_jni_if_java_exception_occurred(JNIEnv* env, CleanUpFunction clean_up_func,
+                                                                    const char* file_path, int line_num)
 {
     if (!env->ExceptionCheck()) {
         return;
     }
+    if (clean_up_func) {
+        clean_up_func();
+    }
     throw JavaExceptionThrower(file_path, line_num);
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
index e35bcc8a6d..488c5399b0 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
@@ -19,6 +19,7 @@
 
 #include <jni.h>
 
+#include <functional>
 #include <stdexcept>
 
 #include "java_class.hpp"
@@ -29,13 +30,15 @@ namespace jni_util {
 #define THROW_JAVA_EXCEPTION(env, class_name, message)                                                               \
     throw realm::jni_util::JavaExceptionThrower(env, class_name, message, __FILE__, __LINE__)
 
-#define TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env)                                                                  \
-    JavaExceptionThrower::terminate_jni_if_java_exception_occurred(env, __FILE__, __LINE__);
+#define TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, clean_up_func)                                                 \
+    JavaExceptionThrower::terminate_jni_if_java_exception_occurred(env, clean_up_func, __FILE__, __LINE__);
 
 // Class to help throw a Java exception from JNI code.
 // This exception will be called from CATCH_STD and throw a Java exception there.
 class JavaExceptionThrower : public std::runtime_error {
 public:
+    using CleanUpFunction = std::function<void()>;
+
     JavaExceptionThrower(const char* file_path, int line_num);
     JavaExceptionThrower(JNIEnv* env, const char* class_name, std::string message, const char* file_path,
                          int line_num);
@@ -44,7 +47,9 @@ class JavaExceptionThrower : public std::runtime_error {
 
     // This method will throw a JavaExceptionThrower to terminate JNI then return to java if there is an Java
     // exception has been thrown before.
-    static void terminate_jni_if_java_exception_occurred(JNIEnv* env, const char* file_path, int line_num);
+    // clean_up_fucn will be called before throwing the c++ exception if there is a pending java exception.
+    static void terminate_jni_if_java_exception_occurred(JNIEnv* env, CleanUpFunction clean_up_func,
+                                                         const char* file_path, int line_num);
 
 private:
     JavaClass m_exception_class;
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 6ba0f39a8b..aad610199f 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -609,20 +609,20 @@ public void deleteAll() {
      */
     static boolean deleteRealm(final RealmConfiguration configuration) {
         final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
+        boolean callbackExecuted = OsObjectStore.callWithLock(configuration, new Runnable() {
             @Override
-            public void onResult(int count) {
-                if (count != 0) {
-                    throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
-                            "Remember to close() all the instances of the Realm before deleting its file: " + configuration.getPath());
-                }
-
+            public void run() {
                 String canonicalPath = configuration.getPath();
                 File realmFolder = configuration.getRealmDirectory();
                 String realmFileName = configuration.getRealmFileName();
                 realmDeleted.set(Util.deleteRealm(canonicalPath, realmFolder, realmFileName));
             }
         });
+        if (!callbackExecuted) {
+            throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
+                    "Remember to close() all the instances of the Realm before deleting its file: "
+                    + configuration.getPath());
+        }
         return realmDeleted.get();
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 65681c1767..6e5428adfd 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -1657,11 +1657,18 @@ public static void migrateRealm(RealmConfiguration configuration, @Nullable Real
     }
 
     /**
-     * Deletes the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
+     * Deletes the Realm file along with the related temporary files specified by the given {@link RealmConfiguration}
+     * from the filesystem. Temporary file with ".lock" extension won't be deleted.
+     * <p>
      * All Realm instances must be closed before calling this method.
+     * <p>
+     * WARNING: For synchronized Realm, there is a chance that an internal Realm instance on the background thread is
+     * not closed even all the user controlled Realm instances are closed. This will result an
+     * {@code IllegalStateException}. See issue https://github.com/realm/realm-java/issues/5416 .
      *
      * @param configuration a {@link RealmConfiguration}.
-     * @return {@code false} if a file could not be deleted. The failing file will be logged.
+     * @return {@code false} if the Realm file could not be deleted. Temporary files deletion failure won't impact
+     * the return value. All of the failing file deletions will be logged.
      * @throws IllegalStateException if not all realm instances are closed.
      */
     public static boolean deleteRealm(RealmConfiguration configuration) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 7adc914661..a7544f5da6 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -35,6 +35,7 @@
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.Capabilities;
 import io.realm.internal.ObjectServerFacade;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
@@ -303,11 +304,12 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
                         } catch (Throwable t) {
                             // If an error happened while downloading initial data, we need to reset the file so we can
                             // download it again on the next attempt.
-                            // Realm.deleteRealm() is under the same lock as this method and globalCount is still 0, so
-                            // this should be safe.
                             sharedRealm.close();
                             sharedRealm = null;
-                            Realm.deleteRealm(configuration);
+                            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been
+                            //        closed for now.
+                            // https://github.com/realm/realm-java/issues/5416
+                            BaseRealm.deleteRealm(configuration);
                             throw t;
                         }
                     }
@@ -492,20 +494,32 @@ synchronized void invokeWithLock(Callback0 callback) {
      * @param configuration configuration object for Realm instance.
      * @throws RealmFileException if copying the file fails.
      */
-    private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
-        if (configuration.hasAssetFile()) {
-            File realmFile = new File(configuration.getRealmDirectory(), configuration.getRealmFileName());
-
-            copyFileIfNeeded(configuration.getAssetFilePath(), realmFile);
-        }
+    private static void copyAssetFileIfNeeded(final RealmConfiguration configuration) {
+        final File realmFileFromAsset = configuration.hasAssetFile() ?
+                new File(configuration.getRealmDirectory(), configuration.getRealmFileName())
+                : null;
+        final String syncServerCertificateAssetName = ObjectServerFacade.getFacade(
+                configuration.isSyncConfiguration()).getSyncServerCertificateAssetName(configuration);
+        final boolean certFileExists = !Util.isEmptyString(syncServerCertificateAssetName);
+
+        if (realmFileFromAsset!= null || certFileExists) {
+            OsObjectStore.callWithLock(configuration, new Runnable() {
+                @Override
+                public void run() {
+                    if (realmFileFromAsset != null) {
+                        copyFileIfNeeded(configuration.getAssetFilePath(), realmFileFromAsset);
+                    }
 
-        // Copy Sync Server certificate path if available
-        String syncServerCertificateAssetName = ObjectServerFacade.getFacade(configuration.isSyncConfiguration()).getSyncServerCertificateAssetName(configuration);
-        if (!Util.isEmptyString(syncServerCertificateAssetName)) {
-            String syncServerCertificateFilePath = ObjectServerFacade.getFacade(configuration.isSyncConfiguration()).getSyncServerCertificateFilePath(configuration);
+                    // Copy Sync Server certificate path if available
+                    if (certFileExists) {
+                        String syncServerCertificateFilePath = ObjectServerFacade.getFacade(
+                                configuration.isSyncConfiguration()).getSyncServerCertificateFilePath(configuration);
 
-            File certificateFile = new File(syncServerCertificateFilePath);
-            copyFileIfNeeded(syncServerCertificateAssetName, certificateFile);
+                        File certificateFile = new File(syncServerCertificateFilePath);
+                        copyFileIfNeeded(syncServerCertificateAssetName, certificateFile);
+                    }
+                }
+            });
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
index 5e05a43310..aa2b9f8192 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
@@ -18,6 +18,8 @@
 
 import javax.annotation.Nullable;
 
+import io.realm.RealmConfiguration;
+
 /**
  * Java wrapper for methods in object_store.hpp.
  */
@@ -71,6 +73,19 @@ public static boolean deleteTableForObject(SharedRealm sharedRealm, String class
         return nativeDeleteTableForObject(sharedRealm.getNativePtr(), className);
     }
 
+    /**
+     * Try to grab an exclusive lock on the given Realm file. If the lock can be acquired, the {@code runnable} will be
+     * executed while the lock is held. The lock will ensure no one else can read from or write to the Realm file at the
+     * same time.
+     *
+     * @param configuration to specify the realm path.
+     * @param runnable to run with lock.
+     * @return {@code true} if the lock can be acquired and the {@code runnable} has been executed.
+     */
+    public static boolean callWithLock(RealmConfiguration configuration, Runnable runnable) {
+        return nativeCallWithLock(configuration.getPath(), runnable);
+    }
+
     private native static void nativeSetPrimaryKeyForObject(long sharedRealmPtr, String className,
                                                              @Nullable String primaryKeyFieldName);
 
@@ -81,4 +96,6 @@ private native static void nativeSetPrimaryKeyForObject(long sharedRealmPtr, Str
     private native static long nativeGetSchemaVersion(long sharedRealmPtr);
 
     private native static boolean nativeDeleteTableForObject(long sharedRealmPtr, String className);
+
+    private native static boolean nativeCallWithLock(String realmPath, Runnable runnable);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index ce505b603f..6dc7389628 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -23,10 +23,12 @@
 import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.annotation.Nullable;
 
+import io.realm.RealmConfiguration;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.log.RealmLog;
@@ -96,46 +98,45 @@ public static boolean isEmptyString(@Nullable String str) {
         return str == null || str.length() == 0;
     }
 
+    /**
+     * To delete Realm and related temporary files. This must be called in
+     * {@link OsObjectStore#callWithLock(RealmConfiguration, Runnable)}'s callback.
+     *
+     * @return {@code true} if the realm file is deleted. Temporary file deletion failure will not impact the return
+     * value, instead, a warning will be logged.
+     */
     public static boolean deleteRealm(String canonicalPath, File realmFolder, String realmFileName) {
-        boolean realmDeleted = true;
         final String management = ".management";
         File managementFolder = new File(realmFolder, realmFileName + management);
+        File realmFile = new File(canonicalPath);
 
         // Deletes files in management directory and the directory.
         // There is no subfolders in the management directory.
         File[] files = managementFolder.listFiles();
         if (files != null) {
             for (File file : files) {
-                realmDeleted = realmDeleted && file.delete();
+                boolean deleteResult = file.delete();
+                if (!deleteResult) {
+                    RealmLog.warn( String.format(Locale.ENGLISH,"Realm temporary file at %s cannot be deleted",
+                            file.getAbsolutePath()));
+                }
             }
         }
-        realmDeleted = realmDeleted && managementFolder.delete();
-
-        // Deletes specific files in root directory.
-        return realmDeleted && deletes(canonicalPath, realmFolder, realmFileName);
-    }
+        if (managementFolder.exists() && !managementFolder.delete()) {
+            RealmLog.warn( String.format(Locale.ENGLISH,"Realm temporary folder at %s cannot be deleted",
+                    managementFolder.getAbsolutePath()));
+        }
 
-    private static boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
-        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-
-        List<File> filesToDelete = Arrays.asList(
-                new File(rootFolder, realmFileName),
-                new File(rootFolder, realmFileName + ".lock"),
-                // Old core log file naming styles
-                new File(rootFolder, realmFileName + ".log_a"),
-                new File(rootFolder, realmFileName + ".log_b"),
-                new File(rootFolder, realmFileName + ".log"),
-                new File(canonicalPath));
-        for (File fileToDelete : filesToDelete) {
-            if (fileToDelete.exists()) {
-                boolean deleteResult = fileToDelete.delete();
-                if (!deleteResult) {
-                    realmDeleted.set(false);
-                    RealmLog.warn("Could not delete the file %s", fileToDelete);
-                }
+        boolean realmDeleted;
+        if (realmFile.exists()) {
+            realmDeleted = realmFile.delete();
+            if (!realmDeleted) {
+                RealmLog.warn(String.format(Locale.ENGLISH,"Realm file at %s cannot be deleted",
+                        realmFile.getAbsolutePath()));
             }
+        } else {
+            realmDeleted = true;
         }
-        return realmDeleted.get();
+        return realmDeleted;
     }
-
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index ba321beb9f..7e581f6a6f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -20,6 +20,7 @@
 import android.support.test.annotation.UiThreadTest;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,12 +32,14 @@
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsRealmConfig;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 
 
@@ -58,7 +61,9 @@ public void waitForInitialRemoteData_mainThreadThrows() {
         try {
             realm = Realm.getInstance(config);
             fail();
-        } catch (IllegalStateException ignored) {
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "downloadAllServerChanges() cannot be called from the main thread."));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -75,6 +80,7 @@ public void waitForInitialRemoteData() throws InterruptedException {
         // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
         final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .schema(StringOnly.class)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .build();
         Realm realm = Realm.getInstance(configOld);
         realm.executeTransaction(new Realm.Transaction() {
@@ -88,12 +94,12 @@ public void execute(Realm realm) {
         SyncManager.getSession(configOld).uploadAllLocalChanges();
         realm.close();
         user.logout();
-        Realm.deleteRealm(configOld);
 
-        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
-        // download the uploaded changes (pray it managed to do so within the time frame).
+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with
+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .name("newRealm")
                 .schema(StringOnly.class)
                 .waitForInitialRemoteData()
                 .build();
@@ -204,12 +210,12 @@ public void execute(Realm realm) {
         SyncManager.getSession(configOld).uploadAllLocalChanges();
         realm.close();
         user.logout();
-        Realm.deleteRealm(configOld);
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes (pray it managed to do so within the time frame).
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
         final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .name("newRealm")
                 .waitForInitialRemoteData()
                 .readOnly()
                 .schema(StringOnly.class)
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index d51f3520f0..ded87c8ca1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -70,11 +70,12 @@ public void onError(SyncSession session, ObjectServerError error) {
         SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
         realm.close();
         user.logout();
-        Realm.deleteRealm(configWithEncryption);
 
-        // STEP 3: try to open again the Realm without the encryption key should not fail
+        // STEP 3: try to open again the same sync Realm but different local name without the encryption key should not
+        // fail
         user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
         SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .name("newName")
                 .modules(new StringOnlyModule())
                 .waitForInitialRemoteData()
                 .errorHandler(new SyncSession.ErrorHandler() {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
index 4bc73892f1..15d3f2ae49 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
@@ -49,6 +49,7 @@ public void partialSync() throws InterruptedException {
 
         final SyncConfiguration partialSyncConfig = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .name("partialSync")
                 .modules(new PartialSyncModule())
                 .partialRealm()
                 .build();
@@ -93,7 +94,6 @@ public void partialSync() throws InterruptedException {
 
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
-        Realm.deleteRealm(syncConfig);
 
         final CountDownLatch latch = new CountDownLatch(2);
 
