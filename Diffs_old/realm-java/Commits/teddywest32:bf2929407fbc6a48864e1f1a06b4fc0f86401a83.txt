diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8937e5d1e5..922c13a348 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,70 @@
+## 0.89.0
+
+### Breaking changes
+
+* RealmResults.clear() now throws UnsupportedOperationException. Use RealmResults.deleteAllFromRealm() instead.
+* RealmResults.remove(int) now throws UnsupportedOperationException. Use RealmResults.deleteFromRealm() instead.
+* Removed deprecated methods Realm.getTable() from public API.
+
+### Deprecated
+
+* RealmObject.removeFromRealm() in place of RealmObject.deleteFromRealm()
+* Realm.clear(Class) in favour of Realm.delete(Class).
+* DynamicRealm.clear(Class) in place of DynamicRealm.delete(Class).
+
+### Enhancements
+
+* RealmCollection and OrderedRealmCollection have been added. RealmList and RealmResults both implement these interfaces.
+* RealmBaseAdapter now accept an OrderedRealmCollection instead of only RealmResults.
+* RealmObjectSchema.isPrimaryKey(String) (#2440)
+* RealmConfiguration.initialData() can now be used to populate a Realm file before it is used for the first time.
+
+### Bug fixes
+
+* RealmObjectSchema.isRequired() and RealmObjectSchema.isNullable() don't throw when the given field name doesn't exist.
+
+### Credits
+
+* Thanks to @thesurix for adding RealmConfiguration.initialData().
+
+## 0.88.3
+
+* Updated Realm Core to 0.97.3.
+
+### Enhancements
+
+* Throws an IllegalArgumentException when calling Realm.copyToRealm()/Realm.copyToRealmOrUpdate() with a RealmObject which belongs to another Realm instance in a different thread.
+* Improved speed of cleaning up native resources (#2496).
+
+### Bug fixes
+
+* Field annotated with @Ignored should not have accessors generated by the bytecode transformer (#2478).
+* RealmResults and RealmObjects can no longer accidentially be GC'ed if using `asObservable()`. Previously this caused the observable to stop emitting. (#2485).
+* Fixed an build issue when using Realm in library projects on Windows (#2484).
+* Custom equals(), toString() and hashCode() are no longer incorrectly overwritten by the proxy class (#2545).
+
+## 0.88.2
+
+* Updated Realm Core to 0.97.2.
+
+### Enhancements
+
+* Outputs additional information when incompatible lock file error occurs.
+
+### Bug fixes
+
+* Race condition causing BadVersionException when running multiple async writes and queries at the same time (#2021/#2391/#2417).
+
+## 0.88.1
+
+### Bug fixes
+
+* Prevent throwing NullPointerException in RealmConfiguration.equals(RealmConfiguration) when RxJava is not in the classpath (#2416).
+* RealmTransformer fails because of missing annotation classes in user's project (#2413).
+* Added SONAME header to shared libraries (#2432).
+* now DynamicRealmObject.toString() correctly shows null value as "null" and the format is aligned to the String from typed RealmObject (#2439).
+* Fixed an issue occurring while resolving ReLinker in apps using a library based on Realm (#2415).
+
 ## 0.88.0
 
 * Updated Realm Core to 0.97.0.
@@ -22,8 +89,8 @@
 
 ### Enhancements
 
-* Support for custom methods, custom logic in accessors, custom accessor names, interface implementation and public fields in Realm objects. (#909)
-* Support to project Lombok. (#502)
+* Support for custom methods, custom logic in accessors, custom accessor names, interface implementation and public fields in Realm objects (#909).
+* Support to project Lombok (#502).
 * RealmQuery.isNotEmpty() (#2025).
 * Realm.deleteAll() and RealmList.deleteAllFromRealm() (#1560).
 * RealmQuery.distinct() and RealmResults.distinct() (#1568).
diff --git a/README.md b/README.md
index b870db5df7..db14a975d1 100644
--- a/README.md
+++ b/README.md
@@ -61,17 +61,18 @@ Prerequisites:
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
  * Download & install the Android SDK, **Android 4.4.2 (API 19)**, **Android 4.4W (API 20)** and **Android 5.0 (API 21)** (for example through Android Studio’s **Android SDK Manager**)
  * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
- * Or you can use [Hombrew](https://github.com/Homebrew/homebrew) to install Android NDK for Mac:
+ * Or you can use [Hombrew-versions](https://github.com/Homebrew/homebrew-versions) to install Android NDK for Mac:
 
     ```
-    brew install android-ndk
+    brew tap homebrew/versions
+    brew install android-ndk-r10e
     ```
 
  * Add two environment variables to your profile:
 
     ```
     export ANDROID_HOME=~/Library/Android/sdk
-    export NDK_HOME=/usr/local/Cellar/android-ndk/r10e
+    export NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
     ```
 
  * If you are using OS X, you'd be better to add following lines to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see those environment variables.
@@ -113,6 +114,7 @@ That command will generate:
  * `./gradlew monkeyExamples` will run the monkey tests on all the examples
  * `./gradlew installRealmJava` will install the Realm library and plugin to mavenLocal()
  * `./gradlew clean -PdontCleanJniFiles` will remove all generated files except for JNI related files. This saves recompilation time a lot.
+ * `./gradlew connectedCheck -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.
 
 Generating the Javadoc using the command above will report a large number of warnings. The Javadoc is generated, and we will fix the issue in the near future.
 
diff --git a/build.gradle b/build.gradle
index 654c3174c0..8f2e675aba 100644
--- a/build.gradle
+++ b/build.gradle
@@ -54,6 +54,9 @@ task assembleRealm(type:GradleBuild) {
     dependsOn installTransformer
     buildFile = file('realm/build.gradle')
     tasks = ['assemble', 'javadocJar', 'sourcesJar']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task check(type:GradleBuild) {
@@ -61,6 +64,9 @@ task check(type:GradleBuild) {
     description = 'Run the JVM tests and checks Realm project'
     buildFile = file('realm/build.gradle')
     tasks = ['check']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task connectedCheck(type:GradleBuild) {
@@ -69,6 +75,9 @@ task connectedCheck(type:GradleBuild) {
     dependsOn installTransformer
     buildFile = file('realm/build.gradle')
     tasks = ['connectedCheck']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task installRealm(type:GradleBuild) {
@@ -77,6 +86,9 @@ task installRealm(type:GradleBuild) {
     dependsOn installTransformer
     buildFile = file('realm/build.gradle')
     tasks = ['install']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task assembleGradlePlugin(type:GradleBuild) {
@@ -127,6 +139,9 @@ task javadoc(type:GradleBuild) {
     group = 'Docs'
     buildFile = file('realm/build.gradle')
     tasks = ['javadocJar']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task sourcesJar(type:GradleBuild) {
@@ -134,6 +149,9 @@ task sourcesJar(type:GradleBuild) {
     group = 'Docs'
     buildFile = file('realm/build.gradle')
     tasks = ['sourcesJar']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task assemble {
@@ -179,8 +197,11 @@ task cleanRealm(type:GradleBuild) {
     group = 'Clean'
     buildFile = file('realm/build.gradle')
     tasks = ['clean']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
     if (project.hasProperty('dontCleanJniFiles')) {
-        startParameter.projectProperties = [dontCleanJniFiles: ""]
+        startParameter.projectProperties += [dontCleanJniFiles: project.getProperty('dontCleanJniFiles')]
     }
 }
 
@@ -256,6 +277,9 @@ task bintrayRealm(type: GradleBuild) {
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
     tasks = ['bintrayUpload']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task bintrayAnnotations(type: GradleBuild) {
@@ -293,6 +317,9 @@ task ojoRealm(type: GradleBuild) {
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
     tasks = ['artifactoryPublish']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
 }
 
 task ojoAnnotations(type: GradleBuild) {
diff --git a/examples/adapterExample/build.gradle b/examples/adapterExample/build.gradle
index d9a210bc64..707733ce88 100644
--- a/examples/adapterExample/build.gradle
+++ b/examples/adapterExample/build.gradle
@@ -4,11 +4,14 @@ apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
+    //noinspection GroovyAssignabilityCheck
     compileSdkVersion rootProject.sdkVersion
+    //noinspection GroovyAssignabilityCheck
     buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId "io.realm.examples.realmadapters"
+        //noinspection GroovyAssignabilityCheck
         targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
         versionCode 1
diff --git a/examples/adapterExample/lint.xml b/examples/adapterExample/lint.xml
new file mode 100644
index 0000000000..829e13eda8
--- /dev/null
+++ b/examples/adapterExample/lint.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+</lint>
diff --git a/examples/adapterExample/src/main/AndroidManifest.xml b/examples/adapterExample/src/main/AndroidManifest.xml
index 06c055c5e6..5958789fd6 100644
--- a/examples/adapterExample/src/main/AndroidManifest.xml
+++ b/examples/adapterExample/src/main/AndroidManifest.xml
@@ -1,9 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.examples.realmadapters">
+<manifest package="io.realm.examples.realmadapters"
+          xmlns:android="http://schemas.android.com/apk/res/android">
 
     <application
-        android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
@@ -13,8 +12,8 @@
             android:configChanges="keyboardHidden|orientation|screenSize"
             android:label="@string/app_name">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
 
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
index 69915fc341..df09a02d9d 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
@@ -48,13 +48,13 @@ protected void onCreate(Bundle savedInstanceState) {
         realm = Realm.getDefaultInstance();
 
         RealmResults<TimeStamp> timeStamps = realm.where(TimeStamp.class).findAll();
-        final MyAdapter adapter = new MyAdapter(this, R.id.listView, timeStamps, true);
+        final MyAdapter adapter = new MyAdapter(this, timeStamps);
         ListView listView = (ListView) findViewById(R.id.listView);
         listView.setAdapter(adapter);
         listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
             @Override
             public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
-                TimeStamp timeStamp = adapter.getRealmResults().get(i);
+                TimeStamp timeStamp = adapter.getAdapterData().get(i);
                 Message message = buildMessage(WorkerHandler.REMOVE_TIMESTAMP, timeStamp.getTimeStamp());
 
                 workerThread.workerHandler.sendMessage(message);
@@ -66,7 +66,7 @@ public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, lon
     @Override
     protected void onPause() {
         super.onPause();
-        workerThread.workerHandler.getLooper().quit();
+        workerThread.quit();
     }
 
     @Override
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
index 1dfc7e3cb2..48ab829baf 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
@@ -22,18 +22,18 @@
 import android.widget.ListAdapter;
 import android.widget.TextView;
 
+import io.realm.OrderedRealmCollection;
 import io.realm.RealmBaseAdapter;
-import io.realm.RealmResults;
 import io.realm.examples.realmadapters.models.TimeStamp;
 
-public class MyAdapter extends RealmBaseAdapter<TimeStamp> implements ListAdapter {
+class MyAdapter extends RealmBaseAdapter<TimeStamp> implements ListAdapter {
 
     private static class ViewHolder {
         TextView timestamp;
     }
 
-    public MyAdapter(Context context, int resId, RealmResults<TimeStamp> realmResults, boolean automaticUpdate) {
-        super(context, realmResults, automaticUpdate);
+    public MyAdapter(Context context, OrderedRealmCollection<TimeStamp> realmResults) {
+        super(context, realmResults, true);
     }
 
     @Override
@@ -48,12 +48,12 @@ public View getView(int position, View convertView, ViewGroup parent) {
             viewHolder = (ViewHolder) convertView.getTag();
         }
 
-        TimeStamp item = realmResults.get(position);
+        TimeStamp item = adapterData.get(position);
         viewHolder.timestamp.setText(item.getTimeStamp());
         return convertView;
     }
 
-    public RealmResults<TimeStamp> getRealmResults() {
-        return realmResults;
+    public OrderedRealmCollection<TimeStamp> getAdapterData() {
+        return adapterData;
     }
 }
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java
index c0de659020..062da433f3 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerHandler.java
@@ -22,7 +22,7 @@
 import io.realm.Realm;
 import io.realm.examples.realmadapters.models.TimeStamp;
 
-public class WorkerHandler extends Handler {
+class WorkerHandler extends Handler {
 
     public static final int ADD_TIMESTAMP = 1;
     public static final int REMOVE_TIMESTAMP = 2;
@@ -30,7 +30,7 @@
     public static final String ACTION = "action";
     public static final String TIMESTAMP = "timestamp";
 
-    private Realm realm;
+    private final Realm realm;
 
     public WorkerHandler(Realm realm) {
         this.realm = realm;
@@ -51,7 +51,7 @@ public void handleMessage(Message msg) {
                 break;
             case REMOVE_TIMESTAMP:
                 realm.beginTransaction();
-                realm.where(TimeStamp.class).equalTo("timeStamp", timestamp).findAll().clear();
+                realm.where(TimeStamp.class).equalTo("timeStamp", timestamp).findAll().deleteAllFromRealm();
                 realm.commitTransaction();
                 break;
         }
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
index 847ffd4bf1..00f7551eea 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
@@ -18,11 +18,14 @@
 import android.os.Handler;
 import android.os.Looper;
 
+import java.util.concurrent.CountDownLatch;
+
 import io.realm.Realm;
 
-public class WorkerThread extends Thread {
+class WorkerThread extends Thread {
 
     public Handler workerHandler;
+    private CountDownLatch realmOpen;
 
     @Override
     public void run() {
@@ -30,12 +33,23 @@ public void run() {
         try {
             Looper.prepare();
             realm = Realm.getDefaultInstance();
+            realmOpen = new CountDownLatch(1);
             workerHandler = new WorkerHandler(realm);
             Looper.loop();
         } finally {
             if (realm != null) {
                 realm.close();
+                realmOpen.countDown();
             }
         }
     }
+
+    public void quit() {
+        workerHandler.getLooper().quit();
+        try {
+            realmOpen.await();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/examples/adapterExample/src/main/res/layout/activity_my.xml b/examples/adapterExample/src/main/res/layout/activity_my.xml
index 99c0048a9f..375a00e263 100644
--- a/examples/adapterExample/src/main/res/layout/activity_my.xml
+++ b/examples/adapterExample/src/main/res/layout/activity_my.xml
@@ -6,7 +6,7 @@
     android:paddingRight="@dimen/activity_horizontal_margin"
     android:paddingTop="@dimen/activity_vertical_margin"
     android:paddingBottom="@dimen/activity_vertical_margin"
-    tools:context=".MyActivity">
+    tools:context=".AdapterExampleActivity">
 
 
     <ListView
diff --git a/examples/adapterExample/src/main/res/values/strings.xml b/examples/adapterExample/src/main/res/values/strings.xml
index d5d49bd286..11de42b091 100644
--- a/examples/adapterExample/src/main/res/values/strings.xml
+++ b/examples/adapterExample/src/main/res/values/strings.xml
@@ -2,7 +2,6 @@
 <resources>
 
     <string name="app_name">Adapter example</string>
-    <string name="action_settings">Settings</string>
     <string name="add">Add</string>
 
-</resources>
\ No newline at end of file
+</resources>
diff --git a/examples/encryptionExample/lint.xml b/examples/encryptionExample/lint.xml
new file mode 100644
index 0000000000..3e72f2f79a
--- /dev/null
+++ b/examples/encryptionExample/lint.xml
@@ -0,0 +1,8 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="TrulyRandom" severity="ignore" />
+    <issue id="PrngFix" severity="ignore" />
+</lint>
diff --git a/examples/encryptionExample/src/main/AndroidManifest.xml b/examples/encryptionExample/src/main/AndroidManifest.xml
index 74ee60e88c..28d1c607d0 100644
--- a/examples/encryptionExample/src/main/AndroidManifest.xml
+++ b/examples/encryptionExample/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <application
         android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
-        android:label="Realm Encryption Example"
+        android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
             android:name=".EncryptionExampleActivity"
diff --git a/examples/encryptionExample/src/main/res/layout/activity_realm_example.xml b/examples/encryptionExample/src/main/res/layout/activity_realm_example.xml
deleted file mode 100644
index 8f998c487e..0000000000
--- a/examples/encryptionExample/src/main/res/layout/activity_realm_example.xml
+++ /dev/null
@@ -1,106 +0,0 @@
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:background="#ff797979"
-    android:orientation="vertical"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin">
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical">
-
-        <TextView
-            android:id="@+id/update_message"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_margin="25dp"
-            android:gravity="center"
-            android:text="In the background there is a loop creating records."
-            android:textSize="24sp" />
-
-        <View
-            android:layout_width="match_parent"
-            android:layout_height="1dp"
-            android:layout_margin="12dp"
-            android:background="#ffcfcfcf" />
-
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:background="#ff1144aa"
-            android:orientation="vertical"
-            android:padding="20dp">
-
-            <TextView
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:layout_margin="7dp"
-                android:gravity="center"
-                android:text="You can also create records manually..."
-                android:textSize="22sp" />
-
-            <TextView
-                android:id="@+id/message_timestamp"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:gravity="center_horizontal"
-                android:text="Create a Record:"
-                android:textColor="#ffafafaf"
-                android:textSize="22sp" />
-
-            <View
-                android:layout_width="match_parent"
-                android:layout_height="1dp"
-                android:layout_margin="12dp"
-                android:background="#ffcfcfcf" />
-
-            <EditText
-                android:id="@+id/name"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Person's Name" />
-
-            <EditText
-                android:id="@+id/age"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Person's Age" />
-
-            <RadioGroup
-                android:id="@+id/petType"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-                <RadioButton
-                    android:id="@+id/hasCat"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:text="Cat" />
-
-                <RadioButton
-                    android:id="@+id/hasDog"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:text="Dog" />
-            </RadioGroup>
-
-            <EditText
-                android:id="@+id/pets_name"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Pets Name" />
-
-            <Button
-                android:id="@+id/add_record_button"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:text="Create Record" />
-
-        </LinearLayout>
-    </LinearLayout>
-</ScrollView>
diff --git a/examples/encryptionExample/src/main/res/menu/options_menu.xml b/examples/encryptionExample/src/main/res/menu/options_menu.xml
deleted file mode 100644
index 14c91e5706..0000000000
--- a/examples/encryptionExample/src/main/res/menu/options_menu.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    tools:context=".RealmGridLayoutActivity">
-    <item
-        android:id="@+id/action_reload"
-        android:orderInCategory="100"
-        android:showAsAction="never"
-        android:title="@string/action_reset" />
-</menu>
diff --git a/examples/encryptionExample/src/main/res/values-w820dp/dimens.xml b/examples/encryptionExample/src/main/res/values-w820dp/dimens.xml
deleted file mode 100644
index 63fc816444..0000000000
--- a/examples/encryptionExample/src/main/res/values-w820dp/dimens.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
-         (such as screen margins) for screens with more than 820dp of available width. This
-         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
-    <dimen name="activity_horizontal_margin">64dp</dimen>
-</resources>
diff --git a/examples/encryptionExample/src/main/res/values/dimens.xml b/examples/encryptionExample/src/main/res/values/dimens.xml
deleted file mode 100644
index 47c8224673..0000000000
--- a/examples/encryptionExample/src/main/res/values/dimens.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
-</resources>
diff --git a/examples/encryptionExample/src/main/res/values/strings.xml b/examples/encryptionExample/src/main/res/values/strings.xml
index 723d453a3a..7dd0864959 100644
--- a/examples/encryptionExample/src/main/res/values/strings.xml
+++ b/examples/encryptionExample/src/main/res/values/strings.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
 
-    <string name="app_name">Encryption example</string>
-    <string name="action_reset">Restart</string>
+    <string name="app_name">Realm Encryption Example</string>
 
 </resources>
diff --git a/examples/gridViewExample/lint.xml b/examples/gridViewExample/lint.xml
new file mode 100644
index 0000000000..58a8015fe4
--- /dev/null
+++ b/examples/gridViewExample/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
index 2c61e50694..147b8ac328 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
@@ -24,6 +24,7 @@
 import android.widget.TextView;
 
 import java.util.List;
+import java.util.Locale;
 
 // This adapter is strictly to interface with the GridView and doesn't
 // particular show much interesting Realm functionality.
@@ -76,7 +77,7 @@ public View getView(int position, View currentView, ViewGroup parent) {
 
         if (city != null) {
             ((TextView) currentView.findViewById(R.id.name)).setText(city.getName());
-            ((TextView) currentView.findViewById(R.id.votes)).setText(Long.toString(city.getVotes()));
+            ((TextView) currentView.findViewById(R.id.votes)).setText(String.format(Locale.US, "%d",city.getVotes()));
         }
 
         return currentView;
diff --git a/examples/gridViewExample/src/main/res/layout/activity_realm_example.xml b/examples/gridViewExample/src/main/res/layout/activity_realm_example.xml
index 52903c4165..a76c48167f 100644
--- a/examples/gridViewExample/src/main/res/layout/activity_realm_example.xml
+++ b/examples/gridViewExample/src/main/res/layout/activity_realm_example.xml
@@ -13,7 +13,7 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:gravity="center_horizontal"
-        android:text="My Favorite City"
+        android:text="@string/my_favortie_city"
         android:textSize="18sp" />
 
     <TextView
@@ -21,7 +21,7 @@
         android:layout_height="wrap_content"
         android:layout_marginBottom="15dp"
         android:gravity="center_horizontal"
-        android:text="Click to Add A Vote"
+        android:text="@string/add_vote"
         android:textStyle="bold" />
 
     <GridView
diff --git a/examples/gridViewExample/src/main/res/menu/options_menu.xml b/examples/gridViewExample/src/main/res/menu/options_menu.xml
deleted file mode 100644
index c713700d24..0000000000
--- a/examples/gridViewExample/src/main/res/menu/options_menu.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    tools:context=".RealmGridLayoutActivity">
-
-    <item
-        android:id="@+id/action_reload"
-        android:orderInCategory="100"
-        android:showAsAction="never"
-        android:title="@string/action_reset" />
-
-</menu>
diff --git a/examples/gridViewExample/src/main/res/values/strings.xml b/examples/gridViewExample/src/main/res/values/strings.xml
index 9249df0959..9f14c47ace 100644
--- a/examples/gridViewExample/src/main/res/values/strings.xml
+++ b/examples/gridViewExample/src/main/res/values/strings.xml
@@ -2,6 +2,7 @@
 <resources>
 
     <string name="app_name">Gridview example</string>
-    <string name="action_reset">Reset</string>
+    <string name="my_favortie_city">My Favorite City</string>
+    <string name="add_vote">Click to Add A Vote</string>
 
 </resources>
diff --git a/examples/introExample/lint.xml b/examples/introExample/lint.xml
new file mode 100644
index 0000000000..3b74cb97d0
--- /dev/null
+++ b/examples/introExample/lint.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    
+</lint>
diff --git a/examples/introExample/src/main/AndroidManifest.xml b/examples/introExample/src/main/AndroidManifest.xml
index 5fe05c80e0..9263488282 100644
--- a/examples/introExample/src/main/AndroidManifest.xml
+++ b/examples/introExample/src/main/AndroidManifest.xml
@@ -3,7 +3,6 @@
     package="io.realm.examples.intro" >
 
     <application
-        android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index fa46564f83..13f6b1be4c 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -116,7 +116,7 @@ private void basicCRUD(Realm realm) {
 
         // Delete all persons
         realm.beginTransaction();
-        realm.allObjects(Person.class).clear();
+        realm.allObjects(Person.class).deleteAllFromRealm();
         realm.commitTransaction();
     }
 
diff --git a/examples/introExample/src/main/res/layout/activity_realm_basic_example.xml b/examples/introExample/src/main/res/layout/activity_realm_basic_example.xml
index f7891e6991..38d19031c7 100644
--- a/examples/introExample/src/main/res/layout/activity_realm_basic_example.xml
+++ b/examples/introExample/src/main/res/layout/activity_realm_basic_example.xml
@@ -13,7 +13,7 @@
         android:layout_height="wrap_content">
         <TextView
             android:gravity="center_horizontal"
-            android:text="Status Output..."
+            android:text="@string/status_output"
             android:textStyle="bold"
             android:textSize="18sp"
             android:layout_width="match_parent"
diff --git a/examples/introExample/src/main/res/values/strings.xml b/examples/introExample/src/main/res/values/strings.xml
index 52c9760ba4..72cb717893 100644
--- a/examples/introExample/src/main/res/values/strings.xml
+++ b/examples/introExample/src/main/res/values/strings.xml
@@ -2,7 +2,6 @@
 <resources>
 
     <string name="app_name">Intro example</string>
-    <string name="hello_world">Hello world!</string>
-    <string name="action_settings">Settings</string>
+    <string name="status_output">Status Output…</string>
 
 </resources>
diff --git a/examples/jsonExample/lint.xml b/examples/jsonExample/lint.xml
new file mode 100644
index 0000000000..9a4f122c70
--- /dev/null
+++ b/examples/jsonExample/lint.xml
@@ -0,0 +1,7 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="PrngFix" severity="ignore" />
+</lint>
diff --git a/examples/jsonExample/src/main/res/layout/activity_realm_example.xml b/examples/jsonExample/src/main/res/layout/activity_realm_example.xml
index a1a15a17a3..c0934adf72 100644
--- a/examples/jsonExample/src/main/res/layout/activity_realm_example.xml
+++ b/examples/jsonExample/src/main/res/layout/activity_realm_example.xml
@@ -7,13 +7,13 @@
     android:paddingLeft="@dimen/activity_horizontal_margin"
     android:paddingRight="@dimen/activity_horizontal_margin"
     android:paddingTop="@dimen/activity_vertical_margin"
-    tools:context=".RealmGridLayoutActivity">
+    tools:context=".JsonExampleActivity">
 
     <TextView
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:gravity="center_horizontal"
-        android:text="My Favorite City"
+        android:text="@string/label"
         android:textSize="18sp" />
 
     <GridView
diff --git a/examples/jsonExample/src/main/res/values/strings.xml b/examples/jsonExample/src/main/res/values/strings.xml
index ba6b396ac7..6e0f08ab41 100644
--- a/examples/jsonExample/src/main/res/values/strings.xml
+++ b/examples/jsonExample/src/main/res/values/strings.xml
@@ -1,4 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
     <string name="app_name">JSON Example</string>
+    <string name="label">My Favorite City</string>
 </resources>
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 5c64f700a9..3e35bbf2e9 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.0.0-rc-1036'
+    ext.kotlin_version = '1.0.1-2'
     repositories {
         jcenter()
     }
@@ -15,11 +15,14 @@ apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
+    //noinspection GroovyAssignabilityCheck
     compileSdkVersion rootProject.sdkVersion
+    //noinspection GroovyAssignabilityCheck
     buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId 'io.realm.examples.kotlin'
+        //noinspection GroovyAssignabilityCheck
         targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
         versionCode 1
diff --git a/examples/kotlinExample/lint.xml b/examples/kotlinExample/lint.xml
new file mode 100644
index 0000000000..829e13eda8
--- /dev/null
+++ b/examples/kotlinExample/lint.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+</lint>
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 2efaab1b9b..37c16e37c0 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -32,10 +32,10 @@ import org.jetbrains.anko.uiThread
 import kotlin.properties.Delegates
 
 
-public class KotlinExampleActivity : Activity() {
+class KotlinExampleActivity : Activity() {
 
     companion object {
-        public val TAG: String = KotlinExampleActivity::class.qualifiedName as String
+        val TAG: String = KotlinExampleActivity::class.qualifiedName as String
     }
 
     private var rootLayout: LinearLayout by Delegates.notNull()
@@ -66,7 +66,7 @@ public class KotlinExampleActivity : Activity() {
         // Using executeTransaction with a lambda reduces code size and makes it impossible
         // to forget to commit the transaction.
         realm.executeTransaction {
-            realm.allObjects(Person::class.java).clear()
+            realm.allObjects(Person::class.java).deleteAllFromRealm()
         }
 
         // More complex operations can be executed on another thread, for example using
@@ -90,7 +90,7 @@ public class KotlinExampleActivity : Activity() {
     private fun showStatus(txt: String) {
         Log.i(TAG, txt)
         val tv = TextView(this)
-        tv.setText(txt)
+        tv.text = txt
         rootLayout.addView(tv)
     }
 
@@ -175,15 +175,15 @@ public class KotlinExampleActivity : Activity() {
         status += "\nNumber of persons: ${realm.allObjects(Person::class.java).size}"
 
         // Iterate over all objects
-        for (pers in realm.allObjects(Person::class.java)) {
-            val dogName: String = pers?.dog?.name ?: "None"
+        for (person in realm.allObjects(Person::class.java)) {
+            val dogName: String = person?.dog?.name ?: "None"
 
-            status += "\n${pers.name}: ${pers.age} : $dogName : ${pers.cats.size}"
+            status += "\n${person.name}: ${person.age} : $dogName : ${person.cats.size}"
 
             // The field tempReference is annotated with @Ignore
             // Though we initially set its value to 42, it has
             // not been saved as part of the Person RealmObject:
-            check(pers.tempReference == 0)
+            check(person.tempReference == 0)
         }
 
         // Sorting
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
index 85cd17aac3..803eb7fcef 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
@@ -17,8 +17,7 @@
 package io.realm.examples.kotlin.model
 
 import io.realm.RealmObject
-import io.realm.annotations.RealmClass
 
-public open class Cat : RealmObject() {
-    public open var name: String? = null
+open class Cat : RealmObject() {
+    open var name: String? = null
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
index 7fb0c4c235..dd4b8452e8 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
@@ -17,8 +17,7 @@
 package io.realm.examples.kotlin.model
 
 import io.realm.RealmObject
-import io.realm.annotations.RealmClass
 
-public open class Dog : RealmObject() {
-    public open var name: String? = null
+open class Dog : RealmObject() {
+    open var name: String? = null
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
index 8ad11e1650..36deb5c3dc 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
@@ -20,31 +20,30 @@ import io.realm.RealmList
 import io.realm.RealmObject
 import io.realm.annotations.Ignore
 import io.realm.annotations.PrimaryKey
-import io.realm.annotations.RealmClass
 
 // Your model has to extend RealmObject. Furthermore, the class and all of the
 // properties must be annotated with open (Kotlin classes and methods are final
 // by default).
-public open class Person(
+open class Person(
         // You can put properties in the constructor as long as all of them are initialized with
         // default values. This ensures that an empty constructor is generated.
         // All properties are by default persisted.
         // Properties can be annotated with PrimaryKey or Index.
         // If you use non-nullable types, properties must be initialized with non-null values.
-        @PrimaryKey public open var name: String = "",
+        @PrimaryKey open var name: String = "",
 
-        public open var age: Int = 0,
+        open var age: Int = 0,
 
         // Other objects in a one-to-one relation must also subclass RealmObject
-        public open var dog: Dog? = null,
+        open var dog: Dog? = null,
 
         // One-to-many relations is simply a RealmList of the objects which also subclass RealmObject
-        public open var cats: RealmList<Cat> = RealmList(),
+        open var cats: RealmList<Cat> = RealmList(),
 
         // You can instruct Realm to ignore a field and not persist it.
-        @Ignore public open var tempReference: Int = 0,
+        @Ignore open var tempReference: Int = 0,
 
-        public open var id: Long = 0
+        open var id: Long = 0
 ) : RealmObject() {
     // The Kotlin compiler generates standard getters and setters.
     // Realm will overload them and code inside them is ignored.
diff --git a/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml b/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
index f7891e6991..8c5a06512e 100644
--- a/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
+++ b/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
@@ -6,14 +6,15 @@
     android:paddingTop="@dimen/activity_vertical_margin"
     android:paddingBottom="@dimen/activity_vertical_margin"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    tools:keep="@layout/activity_realm_basic_example">
     <LinearLayout
         android:orientation="vertical"
         android:layout_width="match_parent"
         android:layout_height="wrap_content">
         <TextView
             android:gravity="center_horizontal"
-            android:text="Status Output..."
+            android:text="@string/status_output"
             android:textStyle="bold"
             android:textSize="18sp"
             android:layout_width="match_parent"
diff --git a/examples/kotlinExample/src/main/res/values/strings.xml b/examples/kotlinExample/src/main/res/values/strings.xml
index 963831fd43..53e83c29d6 100644
--- a/examples/kotlinExample/src/main/res/values/strings.xml
+++ b/examples/kotlinExample/src/main/res/values/strings.xml
@@ -1,8 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-
     <string name="app_name">Kotlin example</string>
-    <string name="hello_world">Hello world!</string>
-    <string name="action_settings">Settings</string>
-
+    <string name="status_output">Status Output…</string>
 </resources>
diff --git a/examples/migrationExample/lint.xml b/examples/migrationExample/lint.xml
new file mode 100644
index 0000000000..a1b63af0fd
--- /dev/null
+++ b/examples/migrationExample/lint.xml
@@ -0,0 +1,6 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
index 74c798bbd3..32d9eb77f9 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
@@ -32,7 +32,6 @@
 import io.realm.RealmConfiguration;
 import io.realm.examples.realmmigrationexample.model.Migration;
 import io.realm.examples.realmmigrationexample.model.Person;
-import io.realm.exceptions.RealmMigrationNeededException;
 
 /*
 ** This example demonstrates how you can migrate your data through different updates
@@ -48,7 +47,7 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_realm_basic_example);
+        setContentView(R.layout.activity_realm_migration_example);
 
         rootLayout = ((LinearLayout) findViewById(R.id.container));
         rootLayout.removeAllViews();
diff --git a/examples/migrationExample/src/main/res/layout/activity_realm_basic_example.xml b/examples/migrationExample/src/main/res/layout/activity_realm_migration_example.xml
similarity index 89%
rename from examples/migrationExample/src/main/res/layout/activity_realm_basic_example.xml
rename to examples/migrationExample/src/main/res/layout/activity_realm_migration_example.xml
index f7891e6991..b96e2ed2b1 100644
--- a/examples/migrationExample/src/main/res/layout/activity_realm_basic_example.xml
+++ b/examples/migrationExample/src/main/res/layout/activity_realm_migration_example.xml
@@ -6,14 +6,15 @@
     android:paddingTop="@dimen/activity_vertical_margin"
     android:paddingBottom="@dimen/activity_vertical_margin"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    tools:context=".MigrationExampleActivity">
     <LinearLayout
         android:orientation="vertical"
         android:layout_width="match_parent"
         android:layout_height="wrap_content">
         <TextView
             android:gravity="center_horizontal"
-            android:text="Status Output..."
+            android:text="@string/label"
             android:textStyle="bold"
             android:textSize="18sp"
             android:layout_width="match_parent"
diff --git a/examples/migrationExample/src/main/res/values/strings.xml b/examples/migrationExample/src/main/res/values/strings.xml
index ffd51cc9d2..ee1f6a2f5e 100644
--- a/examples/migrationExample/src/main/res/values/strings.xml
+++ b/examples/migrationExample/src/main/res/values/strings.xml
@@ -1,8 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
-<resources>
+<resources xmlns:tools="http://schemas.android.com/tools">
 
     <string name="app_name">Migration example</string>
-    <string name="hello_world">Hello world!</string>
-    <string name="action_settings">Settings</string>
+    <string name="label" tools:ignore="TypographyEllipsis">Status Output...</string>
 
 </resources>
diff --git a/examples/moduleExample/app/src/main/AndroidManifest.xml b/examples/moduleExample/app/src/main/AndroidManifest.xml
index 9d2160c44e..97549cad37 100644
--- a/examples/moduleExample/app/src/main/AndroidManifest.xml
+++ b/examples/moduleExample/app/src/main/AndroidManifest.xml
@@ -3,7 +3,6 @@
     package="io.realm.examples.appmodules" >
 
     <application
-        android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
diff --git a/examples/moduleExample/library/lint.xml b/examples/moduleExample/library/lint.xml
new file mode 100644
index 0000000000..58a8015fe4
--- /dev/null
+++ b/examples/moduleExample/library/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/moduleExample/library/src/main/AndroidManifest.xml b/examples/moduleExample/library/src/main/AndroidManifest.xml
index 9c9b59f7e0..1f47b981e6 100644
--- a/examples/moduleExample/library/src/main/AndroidManifest.xml
+++ b/examples/moduleExample/library/src/main/AndroidManifest.xml
@@ -3,7 +3,6 @@
     package="io.realm.examples.librarymodules" >
 
     <application
-        android:allowBackup="true"
         android:label="@string/app_name" >
     </application>
 
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index 021e3dd644..f90596c1ed 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -34,7 +34,9 @@ android {
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
+    //noinspection GradleDependency
     compile 'com.android.support:appcompat-v7:23.1.1'
+    //noinspection GradleDependency
     compile 'com.android.support:design:23.1.1'
     compile 'io.reactivex:rxjava:1.1.0'
     compile 'io.reactivex:rxandroid:1.1.0'
diff --git a/examples/newsreaderExample/lint.xml b/examples/newsreaderExample/lint.xml
new file mode 100644
index 0000000000..a1b63af0fd
--- /dev/null
+++ b/examples/newsreaderExample/lint.xml
@@ -0,0 +1,6 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
index f93ce531cc..ab86adcbac 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
@@ -113,7 +113,7 @@ public void execute(Realm realm) {
                 if (persistedStory != null) {
                     persistedStory.setRead(read);
                 } else {
-                    Timber.e("Trying to update a story that no longer exists: " + storyId);
+                    Timber.e("Trying to update a story that no longer exists: %1$s", storyId);
                 }
             }
         }, new Realm.Transaction.OnError() {
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
index 03bfeb1f96..9db49e3b1f 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
@@ -17,7 +17,6 @@
 package io.realm.examples.newsreader.model.network;
 
 import com.fasterxml.jackson.core.JsonParser;
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.core.TreeNode;
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.JsonDeserializer;
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
index 530590661e..2356f04a76 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
@@ -104,7 +104,7 @@ public void showStory(NYTimesStory story) {
 
     public void setRead(boolean read) {
         if (read) {
-            readView.setText("READ");
+            readView.setText(R.string.read);
             readView.animate().alpha(1.0f);
         } else {
             readView.setText("");
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
index 26a293006f..b7c81a6c88 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
@@ -60,6 +60,7 @@ protected void onCreate(Bundle savedInstanceState) {
         ButterKnife.bind(this);
         Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
+        //noinspection ConstantConditions
         getSupportActionBar().setDisplayShowTitleEnabled(false);
 
         adapter = null;
@@ -69,7 +70,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
                 presenter.listItemSelected(position);
             }
         });
-        listView.setEmptyView(getLayoutInflater().inflate(R.layout.common_emptylist, null, false));
+        listView.setEmptyView(getLayoutInflater().inflate(R.layout.common_emptylist, listView, false));
 
         refreshView.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
             @Override
diff --git a/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml b/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml
index aeb5bee755..b1eb1e80ef 100644
--- a/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml
+++ b/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <TextView xmlns:android="http://schemas.android.com/apk/res/android"
-          android:text="No news"
+          android:text="@string/no_news"
           android:textColor="@android:color/darker_gray"
           android:layout_width="match_parent"
           android:layout_height="match_parent">
diff --git a/examples/newsreaderExample/src/main/res/layout/content_details.xml b/examples/newsreaderExample/src/main/res/layout/content_details.xml
index f0b9f39a3b..a0d9769652 100644
--- a/examples/newsreaderExample/src/main/res/layout/content_details.xml
+++ b/examples/newsreaderExample/src/main/res/layout/content_details.xml
@@ -18,6 +18,7 @@
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
         android:layout_alignParentTop="true"
         android:textColor="@android:color/darker_gray"/>
 
@@ -26,8 +27,10 @@
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_alignParentRight="true"
+        android:layout_alignParentEnd="true"
         android:layout_alignParentTop="true"
-        android:textColor="@android:color/holo_green_dark"/>
+        android:textColor="@android:color/holo_green_dark"
+        tools:ignore="RelativeOverlap"/>
 
     <TextView
         android:id="@+id/details_text"
diff --git a/examples/newsreaderExample/src/main/res/layout/spinner_dropdown_item.xml b/examples/newsreaderExample/src/main/res/layout/spinner_dropdown_item.xml
deleted file mode 100644
index 814c75045a..0000000000
--- a/examples/newsreaderExample/src/main/res/layout/spinner_dropdown_item.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<CheckedTextView xmlns:android="http://schemas.android.com/apk/res/android"
-                 android:id="@android:id/text1"
-                 style="?android:attr/spinnerDropDownItemStyle"
-                 android:singleLine="true"
-                 android:layout_width="match_parent"
-                 android:layout_height="?android:attr/listPreferredItemHeight"
-                 android:ellipsize="marquee"
-                 android:textColor="?android:attr/textColorSecondary"/>
diff --git a/examples/newsreaderExample/src/main/res/values/colors.xml b/examples/newsreaderExample/src/main/res/values/colors.xml
index 90781a8edd..3ab3e9cbce 100644
--- a/examples/newsreaderExample/src/main/res/values/colors.xml
+++ b/examples/newsreaderExample/src/main/res/values/colors.xml
@@ -3,5 +3,4 @@
     <color name="colorPrimary">#3F51B5</color>
     <color name="colorPrimaryDark">#303F9F</color>
     <color name="colorAccent">#FF4081</color>
-    <color name="white">#ffffff</color>
 </resources>
diff --git a/examples/newsreaderExample/src/main/res/values/dimens.xml b/examples/newsreaderExample/src/main/res/values/dimens.xml
index 812cb7be0a..47c8224673 100644
--- a/examples/newsreaderExample/src/main/res/values/dimens.xml
+++ b/examples/newsreaderExample/src/main/res/values/dimens.xml
@@ -2,5 +2,4 @@
     <!-- Default screen margins, per the Android Design guidelines. -->
     <dimen name="activity_horizontal_margin">16dp</dimen>
     <dimen name="activity_vertical_margin">16dp</dimen>
-    <dimen name="fab_margin">16dp</dimen>
 </resources>
diff --git a/examples/newsreaderExample/src/main/res/values/strings.xml b/examples/newsreaderExample/src/main/res/values/strings.xml
index 72c43bc69d..bd3c07f797 100644
--- a/examples/newsreaderExample/src/main/res/values/strings.xml
+++ b/examples/newsreaderExample/src/main/res/values/strings.xml
@@ -2,5 +2,6 @@
     <string name="app_name">NewsReader</string>
     <!-- API Keys : Note they are throttled, so consider requesting your own: http://developer.nytimes.com/apps/register -->
     <string name="nyc_top_stories_api_key">6fd358f33363137b6b5e0b5758bd9052:18:73641711</string>
-    <string name="action_toggle_read">Toggle read</string>
+    <string name="read">READ</string>
+    <string name="no_news">No news</string>
 </resources>
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index be05c0a6b0..e91c2e7875 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -4,11 +4,14 @@ apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
+    //noinspection GroovyAssignabilityCheck
     compileSdkVersion rootProject.sdkVersion
+    //noinspection GroovyAssignabilityCheck
     buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId 'io.realm.examples.rxjava'
+        //noinspection GroovyAssignabilityCheck
         targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
         versionCode 1
diff --git a/examples/rxJavaExample/lint.xml b/examples/rxJavaExample/lint.xml
new file mode 100644
index 0000000000..829e13eda8
--- /dev/null
+++ b/examples/rxJavaExample/lint.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+</lint>
diff --git a/examples/rxJavaExample/src/main/AndroidManifest.xml b/examples/rxJavaExample/src/main/AndroidManifest.xml
index 5029512a3e..8283fb31e6 100644
--- a/examples/rxJavaExample/src/main/AndroidManifest.xml
+++ b/examples/rxJavaExample/src/main/AndroidManifest.xml
@@ -5,7 +5,6 @@
     <uses-permission android:name="android.permission.INTERNET" />
 
     <application
-        android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:name=".MyApplication"
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
index dfcdb984cf..91bd8f5d2c 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
@@ -34,7 +34,7 @@
 public class MainActivity extends Activity {
 
     private ViewGroup container;
-    private TreeMap<String, Class<? extends Activity>> buttons = new TreeMap<String, Class<? extends Activity>>() {{
+    private final TreeMap<String, Class<? extends Activity>> buttons = new TreeMap<String, Class<? extends Activity>>() {{
         put("Animation", AnimationActivity.class);
         put("Throttle search", ThrottleSearchActivity.class);
         put("Network", RetrofitExample.class);
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
index f7223cacc5..22e5e2b6db 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
@@ -29,7 +29,7 @@
 public class MyApplication extends Application {
 
     private static MyApplication context;
-    private static TreeMap<String, String> testPersons = new TreeMap<>();
+    private static final TreeMap<String, String> testPersons = new TreeMap<>();
     static {
         testPersons.put("Chris", null);
         testPersons.put("Christian", "cmelchior");
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java
index a8644f69ec..b952ea28d3 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java
@@ -20,18 +20,11 @@
 
 public class Person extends RealmObject {
 
-    private long id;
-
     // All fields are by default persisted.
     private String name;
     private int age;
     private String githubUserName;
 
-
-    // The standard getters and setters your IDE generates are fine.
-    // Realm will overload them and code inside them is ignored.
-    // So if you prefer you can also just have empty abstract methods.
-
     public String getName() {
         return name;
     }
@@ -48,14 +41,6 @@ public void setAge(int age) {
         this.age = age;
     }
 
-    public long getId() {
-        return id;
-    }
-
-    public void setId(long id) {
-        this.id = id;
-    }
-
     public String getGithubUserName() {
         return githubUserName;
     }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
index 973d2604f1..a659b752c8 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
@@ -19,9 +19,9 @@
 /**
  * Model class for GitHub users: https://developer.github.com/v3/users/#get-a-single-user
  */
-public class GitHubUser {
+@SuppressWarnings("unused")
+class GitHubUser {
     public String name;
-    public String email;
     public int public_repos;
     public int public_gists;
 }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
index 3edf46e7bc..f28d8ab6f8 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
@@ -23,7 +23,7 @@
 /**
  * GitHub API definition
  */
-public interface GithubApi {
+interface GithubApi {
     /**
      * See https://developer.github.com/v3/users/
      */
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
index 380d111005..2412dfb88b 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
@@ -21,6 +21,8 @@
 import android.view.ViewGroup;
 import android.widget.TextView;
 
+import java.util.Locale;
+
 import io.realm.Realm;
 import io.realm.RealmResults;
 import io.realm.examples.rxjava.R;
@@ -92,7 +94,7 @@ public UserViewModel call(GitHubUser gitHubUser) {
                     public void call(UserViewModel user) {
                         // Print user info.
                         TextView userView = new TextView(RetrofitExample.this);
-                        userView.setText(String.format("%s : %d/%d",
+                        userView.setText(String.format(Locale.US, "%s : %d/%d",
                                 user.getUsername(), user.getPublicRepos(), user.getPublicGists()));
                         container.addView(userView);
                     }
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml b/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml
index 5dc9a970bd..e8146bd8e4 100644
--- a/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml
+++ b/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml
@@ -20,7 +20,7 @@
             android:gravity="center_horizontal"
             android:textStyle="italic"
             android:paddingBottom="16dp"
-            android:text="Use the Source, Luke!"
+            android:text="@string/default_message"
             android:textAppearance="?android:attr/textAppearanceMedium"/>
     </LinearLayout>
 </ScrollView>
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml b/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml
index ccb12d2139..6e7b262843 100644
--- a/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml
+++ b/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml
@@ -1,13 +1,14 @@
 <?xml version="1.0" encoding="utf-8"?>
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              android:orientation="vertical"
               android:layout_width="match_parent"
-              android:layout_height="match_parent">
+              android:layout_height="match_parent"
+              android:orientation="vertical">
 
     <EditText
         android:id="@+id/search"
         android:layout_width="match_parent"
-        android:layout_height="48dp"/>
+        android:layout_height="48dp"
+        android:hint="@string/search"/>
 
     <LinearLayout
         android:id="@+id/search_results"
diff --git a/examples/rxJavaExample/src/main/res/values/strings.xml b/examples/rxJavaExample/src/main/res/values/strings.xml
index c7d68f36c4..0bd84a1e47 100644
--- a/examples/rxJavaExample/src/main/res/values/strings.xml
+++ b/examples/rxJavaExample/src/main/res/values/strings.xml
@@ -1,4 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
     <string name="app_name">RxJava examples</string>
+    <string name="default_message">Use the Source, Luke!</string>
+    <string name="search">Search</string>
 </resources>
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index c915b69447..cc74e3a549 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -25,5 +25,6 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:appcompat-v7:21.0.+'
+    //noinspection GradleDependency
+    compile 'com.android.support:appcompat-v7:23.2.1'
 }
diff --git a/examples/threadExample/lint.xml b/examples/threadExample/lint.xml
new file mode 100644
index 0000000000..58a8015fe4
--- /dev/null
+++ b/examples/threadExample/lint.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
index de41b08fca..48a821225b 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -178,8 +178,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                 view.setTag(viewHolder);
             }
             ViewHolder vh = (ViewHolder) view.getTag();
-            vh.text.setText("[X= " + getItem(i).getX() + " Y= " + getItem(i).getY() + "]");
-
+            vh.text.setText(view.getResources().getString(R.string.coordinate, getItem(i).getX(),getItem(i).getY()));
             return view;
         }
 
diff --git a/examples/threadExample/src/main/res/layout/activity_receiving.xml b/examples/threadExample/src/main/res/layout/activity_receiving.xml
index 17e6a13ea7..2f8384a6fe 100644
--- a/examples/threadExample/src/main/res/layout/activity_receiving.xml
+++ b/examples/threadExample/src/main/res/layout/activity_receiving.xml
@@ -4,7 +4,6 @@
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:background="@color/screen_background"
     android:paddingBottom="@dimen/activity_vertical_margin"
     android:paddingLeft="@dimen/activity_horizontal_margin"
     android:paddingRight="@dimen/activity_horizontal_margin"
diff --git a/examples/threadExample/src/main/res/layout/fragment_async_query.xml b/examples/threadExample/src/main/res/layout/fragment_async_query.xml
index f695941fca..80f243e582 100644
--- a/examples/threadExample/src/main/res/layout/fragment_async_query.xml
+++ b/examples/threadExample/src/main/res/layout/fragment_async_query.xml
@@ -2,7 +2,6 @@
                 xmlns:tools="http://schemas.android.com/tools"
                 android:layout_width="match_parent"
                 android:layout_height="match_parent"
-                android:background="@color/screen_background"
                 android:orientation="vertical"
                 android:paddingBottom="@dimen/activity_vertical_margin"
                 android:paddingLeft="@dimen/activity_horizontal_margin"
diff --git a/examples/threadExample/src/main/res/layout/fragment_asynctask.xml b/examples/threadExample/src/main/res/layout/fragment_asynctask.xml
index 7e8ef2078b..b4dc2bcc25 100644
--- a/examples/threadExample/src/main/res/layout/fragment_asynctask.xml
+++ b/examples/threadExample/src/main/res/layout/fragment_asynctask.xml
@@ -2,7 +2,6 @@
                 xmlns:tools="http://schemas.android.com/tools"
                 android:layout_width="match_parent"
                 android:layout_height="match_parent"
-                android:background="@color/screen_background"
                 android:orientation="vertical"
                 android:paddingBottom="@dimen/activity_vertical_margin"
                 android:paddingLeft="@dimen/activity_horizontal_margin"
@@ -15,7 +14,7 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:layout_alignParentTop="true"
-        android:text="Start"/>
+        android:text="@string/start"/>
 
     <LinearLayout
         android:id="@+id/logs"
diff --git a/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml b/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml
index b92612d6a5..bb81035713 100644
--- a/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml
+++ b/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml
@@ -3,7 +3,6 @@
               android:layout_width="match_parent"
               android:layout_height="match_parent"
               android:layout_margin="@dimen/activity_horizontal_margin"
-              android:background="@color/screen_background"
               android:orientation="vertical">
 
     <TextView
diff --git a/examples/threadExample/src/main/res/layout/fragment_thread.xml b/examples/threadExample/src/main/res/layout/fragment_thread.xml
index b065c2f12e..11449ec318 100644
--- a/examples/threadExample/src/main/res/layout/fragment_thread.xml
+++ b/examples/threadExample/src/main/res/layout/fragment_thread.xml
@@ -2,7 +2,6 @@
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:background="@color/screen_background"
     tools:context=".MainActivity$PlaceholderFragment">
 
     <io.realm.examples.threads.widget.DotsView
diff --git a/examples/threadExample/src/main/res/menu/menu_backgroundthread.xml b/examples/threadExample/src/main/res/menu/menu_backgroundthread.xml
index e3708ee7e0..b4c01df510 100644
--- a/examples/threadExample/src/main/res/menu/menu_backgroundthread.xml
+++ b/examples/threadExample/src/main/res/menu/menu_backgroundthread.xml
@@ -21,12 +21,12 @@
         android:id="@+id/action_add_dot"
         android:title="@string/add_dot"
         android:icon="@android:drawable/ic_menu_add"
-        app:showAsAction="always" />
+        app:showAsAction="ifRoom" />
 
     <item
         android:id="@+id/action_clear"
         android:title="@string/clear_dots"
         android:icon="@android:drawable/ic_menu_delete"
-        app:showAsAction="always" />
+        app:showAsAction="ifRoom" />
 
 </menu>
\ No newline at end of file
diff --git a/examples/threadExample/src/main/res/values/dimens.xml b/examples/threadExample/src/main/res/values/dimens.xml
index 812cb7be0a..47c8224673 100644
--- a/examples/threadExample/src/main/res/values/dimens.xml
+++ b/examples/threadExample/src/main/res/values/dimens.xml
@@ -2,5 +2,4 @@
     <!-- Default screen margins, per the Android Design guidelines. -->
     <dimen name="activity_horizontal_margin">16dp</dimen>
     <dimen name="activity_vertical_margin">16dp</dimen>
-    <dimen name="fab_margin">16dp</dimen>
 </resources>
diff --git a/examples/threadExample/src/main/res/values/strings.xml b/examples/threadExample/src/main/res/values/strings.xml
index bf547346f6..b1480bd6cc 100644
--- a/examples/threadExample/src/main/res/values/strings.xml
+++ b/examples/threadExample/src/main/res/values/strings.xml
@@ -2,7 +2,6 @@
 <resources>
 
     <string name="app_name">Thread example</string>
-    <string name="action_settings">Settings</string>
     <string name="title_section1">Threads</string>
     <string name="title_section2">AsyncTask</string>
     <string name="title_section3">Async Query</string>
@@ -14,5 +13,7 @@
     <string name="title_section4">Object Passing</string>
     <string name="start_intent_service">Passing to Intent Service</string>
     <string name="start_receiver">Passing To Receiver</string>
+    <string name="coordinate">[X= %1$s Y= %2$s]</string>
+    <string name="start">Start</string>
 
 </resources>
diff --git a/examples/threadExample/src/main/res/values/styles.xml b/examples/threadExample/src/main/res/values/styles.xml
index 766ab99304..b2d92e5b62 100644
--- a/examples/threadExample/src/main/res/values/styles.xml
+++ b/examples/threadExample/src/main/res/values/styles.xml
@@ -3,6 +3,7 @@
     <!-- Base application theme. -->
     <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
         <!-- Customize your theme here. -->
+        <item name="android:windowBackground">@color/screen_background</item>
     </style>
 
 </resources>
diff --git a/examples/unitTestExample/lint.xml b/examples/unitTestExample/lint.xml
new file mode 100644
index 0000000000..a1b63af0fd
--- /dev/null
+++ b/examples/unitTestExample/lint.xml
@@ -0,0 +1,6 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
index ff85292aa6..f605f1e1ea 100644
--- a/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
+++ b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
@@ -33,7 +33,7 @@
 public class jUnit4ExampleTest {
 
     @Rule
-    public ActivityTestRule<ExampleActivity> mActivityRule = new ActivityTestRule(ExampleActivity.class);
+    public ActivityTestRule<ExampleActivity> mActivityRule = new ActivityTestRule<ExampleActivity>(ExampleActivity.class);
 
     @Test
     public void testShouldBeAbleToLaunchActivityAndSeeRealmResults() {
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
index 4743a84b1e..757f0f5422 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
@@ -86,7 +86,7 @@ public void onClick(View v) {
     private void cleanUp() {
         // Delete all persons
         realm.beginTransaction();
-        realm.allObjects(Person.class).clear();
+        realm.allObjects(Person.class).deleteAllFromRealm();
         realm.commitTransaction();
     }
 
diff --git a/examples/unitTestExample/src/main/res/layout/activity_example.xml b/examples/unitTestExample/src/main/res/layout/activity_example.xml
index f82b79be96..c9206f4c83 100644
--- a/examples/unitTestExample/src/main/res/layout/activity_example.xml
+++ b/examples/unitTestExample/src/main/res/layout/activity_example.xml
@@ -19,7 +19,7 @@
             />
         <TextView
             android:gravity="center_horizontal"
-            android:text="Status Output..."
+            android:text="@string/label"
             android:textStyle="bold"
             android:textSize="18sp"
             android:layout_width="match_parent"
diff --git a/examples/unitTestExample/src/main/res/values/strings.xml b/examples/unitTestExample/src/main/res/values/strings.xml
index fc3035ca36..c563737360 100644
--- a/examples/unitTestExample/src/main/res/values/strings.xml
+++ b/examples/unitTestExample/src/main/res/values/strings.xml
@@ -2,8 +2,7 @@
 <resources>
 
     <string name="app_name">Unit Test Example</string>
-    <string name="hello_world">Hello world!</string>
-    <string name="action_settings">Settings</string>
     <string name="clean_up">Clean Up</string>
+    <string name="label">Status Output…</string>
 
 </resources>
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 83c5e3c4b2..58e5be1490 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -39,7 +39,6 @@
 import io.realm.RealmObject;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
-import io.realm.examples.unittesting.ExampleActivity;
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
 
@@ -197,7 +196,7 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
 
         // Verify that the clear method was called. Clear is also called in the start of the
         // activity to ensure we start with a clean db.
-        verify(people, times(2)).clear();
+        verify(people, times(2)).deleteAllFromRealm();
 
         // Call the destroy method so we can verify that the .close() method was called (below)
         controller.destroy();
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index f5f9419e05..0536847d77 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -49,7 +49,6 @@ class Realm implements Plugin<Project> {
 
         project.android.registerTransform(new RealmTransformer())
         project.repositories.add(project.getRepositories().jcenter())
-        project.repositories.add(project.repositories.maven { url "https://jitpack.io" })
         project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
         project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
         if (isKotlinProject) {
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index 0871dca467..c9ee011571 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -9,6 +9,7 @@ buildscript {
 }
 
 apply plugin: 'groovy'
+apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
@@ -30,9 +31,13 @@ configurations {
     compile.extendsFrom provided
 }
 
+// Include the generated Version file
 sourceSets {
     main {
         compileClasspath += configurations.provided
+        java {
+            srcDir 'build/generated-src/main/java'
+        }
     }
 }
 
@@ -48,6 +53,18 @@ dependencies {
     }
 }
 
+// for Ant filter
+import org.apache.tools.ant.filters.ReplaceTokens
+
+task generateVersionClass(type: Copy) {
+    from 'src/main/templates/Version.java'
+    into 'build/generated-src/main/java/io/realm/transformer'
+    filter(ReplaceTokens, tokens: [version: version])
+    outputs.upToDateWhen { false }
+}
+
+compileJava.dependsOn generateVersionClass
+
 def commonPom = {
     licenses {
         license {
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index 595384997c..b927ef5b38 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -15,6 +15,8 @@
  */
 
 package io.realm.transformer
+
+import io.realm.annotations.Ignore
 import javassist.*
 import javassist.expr.ExprEditor
 import javassist.expr.FieldAccess
@@ -38,7 +40,7 @@ class BytecodeModifier {
         logger.info "  Realm: Adding accessors to ${clazz.simpleName}"
         def methods = clazz.getDeclaredMethods()*.name
         clazz.declaredFields.each { CtField field ->
-            if (!Modifier.isStatic(field.getModifiers())) {
+            if (!Modifier.isStatic(field.getModifiers()) && !field.hasAnnotation(Ignore.class)) {
                 if (!methods.contains("realmGet\$${field.name}")) {
                     clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
                 }
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index 566924de68..1e9ec46830 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -24,6 +24,7 @@ import com.google.common.io.Files
 import groovy.io.FileType
 import io.realm.annotations.Ignore
 import javassist.ClassPool
+import javassist.CtClass
 import javassist.LoaderClassPath
 import org.slf4j.Logger
 import org.slf4j.LoggerFactory
@@ -112,8 +113,7 @@ class RealmTransformer extends Transform {
         def allManagedFields = []
         allModelClasses.each {
             allManagedFields.addAll(it.declaredFields.findAll {
-                it.getAnnotations()
-                it.getAnnotation(Ignore.class) == null && !Modifier.isStatic(it.getModifiers())
+                !it.hasAnnotation(Ignore.class) && !Modifier.isStatic(it.getModifiers())
             })
         }
         logger.info "Managed Fields: ${allManagedFields*.name}"
@@ -136,6 +136,41 @@ class RealmTransformer extends Transform {
 
         def toc = System.currentTimeMillis()
         logger.info "Realm Transform time: ${toc-tic} milliseconds"
+
+        sendAnalytics(inputs, inputModelClasses)
+    }
+
+    /**
+     * Sends the analytics
+     * @param inputs the inputs provided by the Transform API
+     * @param inputModelClasses a list of ctClasses describing the Realm models
+     */
+    private static sendAnalytics(Collection<TransformInput> inputs, List<CtClass> inputModelClasses) {
+        def containsKotlin = false
+        inputs.each {
+            it.directoryInputs.each {
+                def path = it.file.absolutePath
+                def index = path.indexOf('build' + File.separator + 'intermediates' + File.separator + 'classes')
+                if (index != -1) {
+                    def projectPath = path.substring(0, index)
+                    def buildFile = new File(projectPath + 'build.gradle')
+                    if (buildFile.exists() && buildFile.text.contains('kotlin')) {
+                        containsKotlin = true
+                    }
+                }
+            }
+        }
+
+        def packages = inputModelClasses.collect {
+            it.getPackageName()
+        }
+
+        def env = System.getenv()
+        def disableAnalytics = env["REALM_DISABLE_ANALYTICS"]
+        if (disableAnalytics == null || disableAnalytics != "true") {
+            def analytics = RealmAnalytics.getInstance(packages as Set, containsKotlin)
+            analytics.execute()
+        }
     }
 
     /**
@@ -199,8 +234,12 @@ class RealmTransformer extends Transform {
                     !it.directory && it.name.endsWith(SdkConstants.DOT_CLASS)
                 }.each {
                     def path = it.name
+                    // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
+                    // `/`. It depends on how the jar file was created.
+                    // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
                     def className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
-                            .replace(File.separatorChar, '.' as char)
+                            .replace('/' as char , '.' as char)
+                            .replace('\\' as char , '.' as char)
                     classNames.add(className)
                 }
             }
@@ -238,4 +277,5 @@ class RealmTransformer extends Transform {
         merged.addAll(set2)
         return merged;
     }
+
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
similarity index 92%
rename from realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java
rename to realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
index 866495ab02..a791be28e4 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.processor;
+package io.realm.transformer;
 
 import java.io.UnsupportedEncodingException;
 import java.net.HttpURLConnection;
@@ -68,6 +68,7 @@
             + "      \"Anonymized MAC Address\": \"%USER_ID%\",\n"
             + "      \"Anonymized Bundle ID\": \"%APP_ID%\",\n"
             + "      \"Binding\": \"java\",\n"
+            + "      \"Language\": \"%LANGUAGE%\",\n"
             + "      \"Realm Version\": \"%REALM_VERSION%\",\n"
             + "      \"Host OS Type\": \"%OS_TYPE%\",\n"
             + "      \"Host OS Version\": \"%OS_VERSION%\",\n"
@@ -78,13 +79,16 @@
     // The list of packages the model classes reside in
     private Set<String> packages;
 
-    private RealmAnalytics(Set<String> packages) {
+    private boolean usesKotlin;
+
+    private RealmAnalytics(Set<String> packages, boolean usesKotlin) {
         this.packages = packages;
+        this.usesKotlin = usesKotlin;
     }
 
-    public static RealmAnalytics getInstance(Set<String> packages) {
+    public static RealmAnalytics getInstance(Set<String> packages, boolean usesKotlin) {
         if (instance == null) {
-            instance = new RealmAnalytics(packages);
+            instance = new RealmAnalytics(packages, usesKotlin);
         }
         return instance;
     }
@@ -131,13 +135,14 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
                 .replaceAll("%TOKEN%", TOKEN)
                 .replaceAll("%USER_ID%", getAnonymousUserId())
                 .replaceAll("%APP_ID%", getAnonymousAppId())
+                .replaceAll("%LANGUAGE%", usesKotlin?"kotlin":"java")
                 .replaceAll("%REALM_VERSION%", Version.VERSION)
                 .replaceAll("%OS_TYPE%", System.getProperty("os.name"))
                 .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
     }
 
     /**
-     * Compute an anonymous user id from the hashed MAC address of the first network interface
+     * Computes an anonymous user id from the hashed MAC address of the first network interface
      * @return the anonymous user id
      * @throws NoSuchAlgorithmException
      * @throws SocketException
@@ -156,7 +161,7 @@ public static String getAnonymousUserId() throws NoSuchAlgorithmException, Socke
     }
 
     /**
-     * Compute an anonymous app/library id from the packages containing RealmObject classes
+     * Computes an anonymous app/library id from the packages containing RealmObject classes
      * @return the anonymous app/library id
      * @throws NoSuchAlgorithmException
      */
diff --git a/realm-transformer/src/main/java/io/realm/transformer/Utils.java b/realm-transformer/src/main/java/io/realm/transformer/Utils.java
new file mode 100644
index 0000000000..a6647b9ac9
--- /dev/null
+++ b/realm-transformer/src/main/java/io/realm/transformer/Utils.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer;
+
+import javax.xml.bind.DatatypeConverter;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+public class Utils {
+
+    /**
+     * Encode the given string with Base64
+     * @param data the string to encode
+     * @return the encoded string
+     * @throws UnsupportedEncodingException
+     */
+    public static String base64Encode(String data) throws UnsupportedEncodingException {
+        return DatatypeConverter.printBase64Binary(data.getBytes("UTF-8"));
+    }
+
+    /**
+     * Compute the SHA-256 hash of the given byte array
+     * @param data the byte array to hash
+     * @return the hashed byte array
+     * @throws NoSuchAlgorithmException
+     */
+    public static byte[] sha256Hash(byte[] data) throws NoSuchAlgorithmException {
+        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+        return messageDigest.digest(data);
+    }
+
+    /**
+     * Convert a byte array to its hex-string
+     * @param data the byte array to convert
+     * @return the hex-string of the byte array
+     */
+    public static String hexStringify(byte[] data) {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (byte singleByte : data) {
+            stringBuilder.append(Integer.toString((singleByte & 0xff) + 0x100, 16).substring(1));
+        }
+
+        return stringBuilder.toString();
+    }
+}
diff --git a/realm-transformer/src/main/templates/Version.java b/realm-transformer/src/main/templates/Version.java
new file mode 100644
index 0000000000..e1d6208e55
--- /dev/null
+++ b/realm-transformer/src/main/templates/Version.java
@@ -0,0 +1,5 @@
+package io.realm.transformer;
+
+public class Version {
+    public static final String VERSION = "@version@";
+}
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
index db9508ca4b..65609cd5df 100644
--- a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
+++ b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
@@ -16,12 +16,13 @@
 
 package io.realm.transformer
 
-import javassist.ClassPool
-import javassist.CtClass
-import javassist.CtField
-import javassist.CtNewMethod
+import io.realm.annotations.Ignore
+import javassist.*
+import javassist.bytecode.AnnotationsAttribute
 import javassist.bytecode.CodeIterator
+import javassist.bytecode.ConstPool
 import javassist.bytecode.Opcode
+import javassist.bytecode.annotation.Annotation
 import spock.lang.Specification
 
 import java.lang.reflect.Modifier
@@ -51,6 +52,30 @@ class BytecodeModifierTest extends Specification {
         }
     }
 
+    def "AddRealmAccessors_IgnoreAnnotation"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('TestClass')
+        def constPool = new ConstPool('TestClass')
+
+        and: 'add a field with @Ignore'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+        def attr = new AnnotationsAttribute(constPool, AnnotationsAttribute.visibleTag)
+        def ignoreAnnotation = new Annotation(Ignore.class.name, constPool)
+        attr.addAnnotation(ignoreAnnotation)
+        ctField.fieldInfo.addAttribute(attr)
+
+        when: 'Try to add the accessor'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        then: 'the accessor should not be generated'
+        def ctMethods = ctClass.getDeclaredMethods()
+        def methodNames = ctMethods.name
+        !methodNames.contains('realmGet$age')
+        !methodNames.contains('realmSet$age')
+    }
+
     def "UseRealmAccessors"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
@@ -83,4 +108,41 @@ class BytecodeModifierTest extends Specification {
         }
         !fieldIsUsed
     }
+
+    def "UseRealmAccessorsInNonDefaultConstructor"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('TestClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        and: 'add a method that sets such field'
+        def ctMethod = CtNewMethod.make('private void setupAge(int age) { this.age = age; }', ctClass)
+        ctClass.addMethod(ctMethod)
+
+        and: 'add a constructor that uses the method'
+        def ctConstructor = CtNewConstructor.make('public TestClass(int age) { setupAge(age); }', ctClass)
+        ctClass.addConstructor(ctConstructor)
+
+        and: 'realm accessors are added'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        when: 'the field use is replaced by the accessor'
+        BytecodeModifier.useRealmAccessors(ctClass, [ctField], [])
+
+        then: 'the field is not used in the method anymore'
+        def methodInfo = ctMethod.getMethodInfo()
+        def codeAttribute = methodInfo.getCodeAttribute()
+        def fieldIsUsed = false
+        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
+            int index = ci.next();
+            int op = ci.byteAt(index);
+            if (op == Opcode.PUTFIELD) {
+                fieldIsUsed = true
+            }
+        }
+        !fieldIsUsed
+    }
 }
diff --git a/realm/build.gradle b/realm/build.gradle
index 7426dc5df9..589eb622a1 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -12,6 +12,7 @@ buildscript {
         classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
+        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.0.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 89820817c0..98f20d4777 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -88,7 +88,7 @@ public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
     }
 
     /**
-     * Build the meta data structures for this class. Any errors or messages will be
+     * Builds the meta data structures for this class. Any errors or messages will be
      * posted on the provided Messager.
      *
      * @return True if meta data was correctly created and processing can continue, false otherwise.
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index 2433fc7b8d..be87d9004c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -44,7 +44,7 @@ public ModuleMetaData(RoundEnvironment env, Set<ClassMetaData> availableClasses)
     }
 
     /**
-     * Build the meta data structures for this class. Any errors or messages will be posted on the provided Messager.
+     * Builds the meta data structures for this class. Any errors or messages will be posted on the provided Messager.
      *
      * @return True if meta data was correctly created and processing can continue, false otherwise.
      */
@@ -125,7 +125,7 @@ public boolean generate(ProcessingEnvironment processingEnv) {
         return classes;
     }
 
-    // Work around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
+    // Work-around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
     // https://community.oracle.com/thread/1184190
     private boolean hasCustomClassList(Element classElement) {
         AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index d23c164192..ffacfe4c23 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -157,12 +157,6 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             }
         }
 
-        String environmentVariable = System.getenv("REALM_DISABLE_ANALYTICS");
-        if (environmentVariable == null || !environmentVariable.equals("true")) {
-            RealmAnalytics analytics = RealmAnalytics.getInstance(packages);
-            analytics.execute();
-        }
-
         hasProcessedModules = true;
         return processModules(roundEnv);
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 1d4b10d937..46d853401c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -563,6 +563,12 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 "Realm", "realm", className, "object", "boolean", "update", "Map<RealmObject,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
+        writer
+            .beginControlFlow("if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId)")
+                .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
+                        " threads cannot be copied into this Realm instance.\")")
+            .endControlFlow();
+
         // If object is already in the Realm there is nothing to update
         writer
             .beginControlFlow("if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath()))")
@@ -825,6 +831,9 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
     }
 
     private void emitToStringMethod(JavaWriter writer) throws IOException {
+        if (metadata.containsToString()) {
+            return;
+        }
         writer.emitAnnotation("Override");
         writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
         writer.beginControlFlow("if (!isValid())");
@@ -873,6 +882,9 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
     }
 
     private void emitHashcodeMethod(JavaWriter writer) throws IOException {
+        if (metadata.containsHashCode()) {
+            return;
+        }
         writer.emitAnnotation("Override");
         writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
         writer.emitStatement("String realmName = ((RealmObject) this).realm.getPath()");
@@ -889,6 +901,9 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
     }
 
     private void emitEqualsMethod(JavaWriter writer) throws IOException {
+        if (metadata.containsEquals()) {
+            return;
+        }
         String proxyClassName = className + Constants.PROXY_SUFFIX;
         writer.emitAnnotation("Override");
         writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index ace661befe..8eccdafb94 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -211,41 +211,6 @@ public static Element getSuperClass(TypeElement classType) {
         return typeUtils.asElement(classType.getSuperclass());
     }
 
-    /**
-     * Encode the given string with Base64
-     * @param data the string to encode
-     * @return the encoded string
-     * @throws UnsupportedEncodingException
-     */
-    public static String base64Encode(String data) throws UnsupportedEncodingException {
-        return DatatypeConverter.printBase64Binary(data.getBytes("UTF-8"));
-    }
-
-    /**
-     * Compute the SHA-256 hash of the given byte array
-     * @param data the byte array to hash
-     * @return the hashed byte array
-     * @throws NoSuchAlgorithmException
-     */
-    public static byte[] sha256Hash(byte[] data) throws NoSuchAlgorithmException {
-        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-        return messageDigest.digest(data);
-    }
-
-    /**
-     * Convert a byte array to its hex-string
-     * @param data the byte array to convert
-     * @return the hex-string of the byte array
-     */
-    public static String hexStringify(byte[] data) {
-        StringBuilder stringBuilder = new StringBuilder();
-        for (byte singleByte : data) {
-            stringBuilder.append(Integer.toString((singleByte & 0xff) + 0x100, 16).substring(1));
-        }
-
-        return stringBuilder.toString();
-    }
-
     public static String getProxyInterfaceName(String className) {
         return className + Constants.INTERFACE_SUFFIX;
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index a0f31d9152..2bc6e1a3bc 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -573,6 +573,10 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
     }
 
     public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
+            throw new IllegalArgumentException(
+                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+        }
         if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
             return object;
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index c87b718a67..d9ed8c1fb3 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -266,6 +266,10 @@ public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
     }
 
     public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
+            throw new IllegalArgumentException(
+                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+        }
         if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
             return object;
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index a096482d3a..f33f78d817 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -1081,6 +1081,10 @@ public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
     }
 
     public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
+            throw new IllegalArgumentException(
+                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+        }
         if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
             return object;
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 99354900a0..216af4e164 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -190,6 +190,10 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
     }
 
     public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.threadId != realm.threadId) {
+            throw new IllegalArgumentException(
+                    "Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+        }
         if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
             return object;
         }
@@ -226,54 +230,4 @@ public static Simple createDetachedCopy(Simple realmObject, int currentDepth, in
         ((SimpleRealmProxyInterface) standaloneObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
         return standaloneObject;
     }
-
-    @Override
-    public String toString() {
-        if (!isValid()) {
-            return "Invalid object";
-        }
-        StringBuilder stringBuilder = new StringBuilder("Simple = [");
-        stringBuilder.append("{name:");
-        stringBuilder.append(realmGet$name() != null ? realmGet$name() : "null");
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{age:");
-        stringBuilder.append(realmGet$age());
-        stringBuilder.append("}");
-        stringBuilder.append("]");
-        return stringBuilder.toString();
-    }
-
-    @Override
-    public int hashCode() {
-        String realmName = ((RealmObject) this).realm.getPath();
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        long rowIndex = ((RealmObject) this).row.getIndex();
-
-        int result = 17;
-        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
-        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
-        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        SimpleRealmProxy aSimple = (SimpleRealmProxy)o;
-
-        String path = ((RealmObject) this).realm.getPath();
-        String otherPath = ((RealmObject) aSimple).realm.getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
-
-        String tableName = ((RealmObject) this).row.getTable().getName();
-        String otherTableName = ((RealmObject) aSimple).row.getTable().getName();
-        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
-
-        if (((RealmObject) this).row.getIndex() != ((RealmObject) aSimple).row.getIndex()) return false;
-
-        return true;
-    }
-
 }
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
index ad3bd38b18..3f0c28f814 100644
--- a/realm/realm-jni/build.gradle
+++ b/realm/realm-jni/build.gradle
@@ -1,8 +1,8 @@
 import java.security.MessageDigest
 
-ext.coreVersion = '0.97.0'
+ext.coreVersion = '0.97.3'
 // empty or comment out this to disable hash checking
-ext.coreSha256Hash = 'b864547b6dea65cb36818d9ae52e72bb5b912759675ab2707cb956f73137424c'
+ext.coreSha256Hash = '2835ae5c51ec83c38fb3f968af6cacd5fce6393b3602ddad4a8f48aaa9e62781'
 ext.forceDownloadCore =
         project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
 // gcc is default for the NDK. It also produces smaller binaries
@@ -16,6 +16,9 @@ ext.stripSymbols = project.hasProperty('stripSymbols') ? project.getProperty('st
 ext.coreSourcePath = project.hasProperty('coreSourcePath') ? project.getProperty('coreSourcePath') : null
 // The location of core archive.
 ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
+// target ABIs to build(null means all).
+// To obtain the ABI of the connected device, execute "adb shell getprop ro.product.cpu.abi"
+ext.buildTargetAbis = project.hasProperty('buildTargetABIs') ? project.getProperty('buildTargetABIs').split(',').collect {it.trim()} : null
 
 def commonCflags = [ '-Os', '-std=c++11' ]
 // LTO and debugging don't play well together
@@ -51,8 +54,9 @@ class Target {
     // The name of the target. This is used for the task names
     String name
 
-    // The name of the folder the Android Gradle plugin expects to find the shared library
-    String jniFolder
+    // The name of the abi. It is also the name of the folder where the Android Gradle plugin
+    // expects to find the shared library
+    String abi
 
     // The toolchain associated to this target
     Toolchain toolchain
@@ -70,15 +74,30 @@ def toolchains = [
     new Toolchain( name:'x86_64', fullName:'x86_64', commandPrefix:'x86_64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 )
 ]
 
-def targets = [
-    new Target( name:'arm', jniFolder:'armeabi', toolchain:toolchains.find{it.name == 'arm'}, cflags:[ '-mthumb' ] ),
-    new Target( name:'arm-v7a', jniFolder:'armeabi-v7a', toolchain:toolchains.find{it.name == 'arm'}, cflags:[ '-mthumb', '-march=armv7-a', '-mfloat-abi=softfp', '-mfpu=vfpv3-d16' ] ),
-    new Target( name:'arm64', jniFolder:'arm64-v8a', toolchain:toolchains.find{it.name == 'arm64'}, cflags:[] ),
-    new Target( name:'mips', jniFolder:'mips', toolchain:toolchains.find{it.name == 'mips'}, cflags:[] ),
-    new Target( name:'x86', jniFolder:'x86', toolchain:toolchains.find{it.name == 'x86'}, cflags:[] ),
-    new Target( name:'x86_64', jniFolder:'x86_64', toolchain:toolchains.find{it.name == 'x86_64'}, cflags:[] )
+def allTargets = [
+    new Target( name:'arm',     abi:'armeabi',     toolchain:toolchains.find {it.name == 'arm'},    cflags:[ '-mthumb' ] ),
+    new Target( name:'arm-v7a', abi:'armeabi-v7a', toolchain:toolchains.find {it.name == 'arm'},    cflags:[ '-mthumb', '-march=armv7-a', '-mfloat-abi=softfp', '-mfpu=vfpv3-d16' ] ),
+    new Target( name:'arm64',   abi:'arm64-v8a',   toolchain:toolchains.find {it.name == 'arm64'},  cflags:[] ),
+    new Target( name:'mips',    abi:'mips',        toolchain:toolchains.find {it.name == 'mips'},   cflags:[] ),
+    new Target( name:'x86',     abi:'x86',         toolchain:toolchains.find {it.name == 'x86'},    cflags:[] ),
+    new Target( name:'x86_64',  abi:'x86_64',      toolchain:toolchains.find {it.name == 'x86_64'}, cflags:[] )
 ]
 
+def targets
+if (ext.buildTargetAbis == null) {
+    targets = allTargets;
+} else {
+    targets = ext.buildTargetAbis.collect { targetAbi ->
+        def target = allTargets.find {it.abi == targetAbi}
+        if (!target) {
+            throw new GradleException("Warning: no target ABIs found for '${targetAbi}'." +
+                    " Please check 'buildTargetABIs' property." +
+                    " Supprted ABIs are ${allTargets.collect {it.abi}. join(', ')}.")
+        }
+        return target
+    }
+}
+
 buildscript {
     repositories {
         jcenter()
@@ -292,7 +311,7 @@ targets.each { target ->
             "REALM_CFLAGS_COMMON=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${project.coreDir}/include",
             "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
             "BASE_DENOM=${target.name}",
-            "REALM_LDFLAGS_COMMON=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${project.coreDir} -Wl,--gc-sections",
+            "REALM_LDFLAGS_COMMON=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${project.coreDir} -Wl,--gc-sections -Wl,-soname,librealm-jni.so",
             'LIB_SUFFIX_SHARED=.so',
             "librealm-jni-${target.name}${getDebugExt()}.so"
         ]
@@ -301,14 +320,14 @@ targets.each { target ->
     task "copyAndroidJni${target.name.capitalize()}"(dependsOn: "buildAndroidJni${target.name.capitalize()}") << {
         copy {
             from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so"
-            into "${projectDir}/../realm-library/src/main/jniLibs/${target.jniFolder}"
+            into "${projectDir}/../realm-library/src/main/jniLibs/${target.abi}"
             rename "librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so", 'librealm-jni.so'
         }
 
         // Store the unstripped version
         copy {
             from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
-            into "${projectDir}/../build/output/jniLibs-unstripped/${target.jniFolder}"
+            into "${projectDir}/../build/output/jniLibs-unstripped/${target.abi}"
             rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
         }
     }
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.cpp b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
index 82776f3e4b..b10a6c8523 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -214,3 +214,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
     return reinterpret_cast<jlong>(pTable);
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
+  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
+{
+    TR_ENTER_PTR(nativeLinkViewPtr)
+    LinkView *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, lv, pos)) {
+        return;
+    }
+    try {
+        return lv->remove_target_row( S(pos) );
+    } CATCH_STD()
+}
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.h b/realm/realm-jni/src/io_realm_internal_LinkView.h
index 173fa010cf..61aa14cedc 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.h
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.h
@@ -119,6 +119,14 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
   (JNIEnv *, jobject, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_LinkView
+ * Method:    nativeRemoveTargetRow
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_LinkView
  * Method:    nativeRemoveAllTargetRows
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
index a1e0550271..debe1ce72c 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -1037,24 +1037,29 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
     return -1;
 }
 
-std::unique_ptr<Query> getHandoverQuery (jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
+// Returns a pointer to query on the worker SharedGroup or throw a BadVersion if the SharedGroup version required
+// for the handover is no longer available.
+std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
 {
     SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, queryPtr);
     std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
 
-    SG(bgSharedGroupPtr)->end_read();
-
-    SharedGroup::VersionID currentVersion = SG(bgSharedGroupPtr)->get_version_of_current_transaction();
-    bool isDifferentVersions = (currentVersion != handoverQuery->version);
-    if (isDifferentVersions) {
-        SG(bgSharedGroupPtr)->begin_read(handoverQuery->version);
-    } else {
-        SG(bgSharedGroupPtr)->begin_read();
+    // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
+    // cases this means that the version in the Handover object is invalid and Realm Core will throw a
+    // BadVersion as result.
+    realm::SharedGroup* sg = SG(bgSharedGroupPtr);
+    if (sg->get_transact_stage() != SharedGroup::transact_Reading) {
+        // if the SharedGroup is not in Read Transaction, we position it at the same version as the handover
+        sg->begin_read(handoverQuery->version);
+    } else if (sg->get_version_of_current_transaction() != handoverQuery->version) {
+        sg->end_read();
+        sg->begin_read(handoverQuery->version);
     }
 
-    std::unique_ptr<Query> query = SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery));
-    if (advanceToLatestVersion && isDifferentVersions) {
-        LangBindHelper::advance_read(*SG(bgSharedGroupPtr));
+    std::unique_ptr<Query> query = sg->import_from_handover(std::move(handoverQuery));
+
+    if (advanceToLatestVersion) {
+        LangBindHelper::advance_read(*sg);
     }
 
     return query;
@@ -1066,7 +1071,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
 {
     TR_ENTER()
     try {
-        std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, false);
+        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, false); // throws
         TableRef table = query->get_table();
 
         if (!QUERY_VALID(env, query.get())) {
@@ -1118,7 +1123,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHando
   {
       TR_ENTER()
       try {
-          std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
           return findAllWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit);
       } CATCH_STD()
       return 0;
@@ -1146,26 +1151,35 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
         std::vector<jlong> exported_handover_tableview_array(number_of_queries);
 
         // Step1: Position the shared group at the handover query version so we can import all queries
-
         // read the first query to determine the version we should use
         SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, handover_queries_pointer_array[0]);
         std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
-        // position this shared group at the specified version
-        SG(bgSharedGroupPtr)->begin_read(handoverQuery->version);
+
+        // if the SharedGroup is not in Read Transaction, we position it at the same version as the handover
+        // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
+        // cases this means that the version in the Handover object is invalid and Realm Core will throw a
+        // BadVersion as result.
+        realm::SharedGroup* sg = SG(bgSharedGroupPtr);
+        if (sg->get_transact_stage() != SharedGroup::transact_Reading) {
+            sg->begin_read(handoverQuery->version);
+        } else if (sg->get_version_of_current_transaction() != handoverQuery->version) {
+            sg->end_read();
+            sg->begin_read(handoverQuery->version);
+        }
 
         std::vector<std::unique_ptr<Query>> queries(number_of_queries);
 
         // import the first query
-        queries[0] = std::move(SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery)));
+        queries[0] = std::move(sg->import_from_handover(std::move(handoverQuery)));
 
         // import the rest of the queries
         for (size_t i = 1; i < number_of_queries; ++i) {
             std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(HO(Query, handover_queries_pointer_array[i]));
-            queries[i] = std::move(SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery)));
+            queries[i] = std::move(sg->import_from_handover(std::move(handoverQuery)));
         }
 
         // Step2: Bring the queries into the latest shared group version
-        LangBindHelper::advance_read(*SG(bgSharedGroupPtr));
+        LangBindHelper::advance_read(*sg);
 
         // Step3: Run & export the queries against the latest shared group
         for (size_t i = 0; i < number_of_queries; ++i) {
@@ -1246,7 +1260,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewW
 {
     TR_ENTER()
     try {
-        std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
         return getDistinctViewWithHandover(env, bgSharedGroupPtr, std::move(query), columnIndex);
     } CATCH_STD()
     return 0;
@@ -1257,7 +1271,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWit
   {
       TR_ENTER()
       try {
-          std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
           return findAllSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit, columnIndex, ascending);
       } CATCH_STD()
       return 0;
@@ -1269,7 +1283,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSort
       TR_ENTER()
       try {
           // import the handover query pointer using the background SharedGroup
-          std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
           return findAllMultiSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit,columnIndices, ascending);
       } CATCH_STD()
       return 0;
@@ -1668,8 +1682,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTa
   {
     TR_ENTER_PTR(handoverPtr)
     SharedGroup::Handover<TableView> *handoverTableViewPtr = HO(TableView, handoverPtr);
-    std::unique_ptr<SharedGroup::Handover<TableView> > handoverTableView(handoverTableViewPtr);
-
+    std::unique_ptr<SharedGroup::Handover<TableView>> handoverTableView(handoverTableViewPtr);
     try {
         // import_from_handover will free (delete) the handover
         if (SG(callerSharedGrpPtr)->is_attached()) {
diff --git a/realm/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-jni/src/io_realm_internal_table.cpp
index f04541417d..5ce8ba3869 100644
--- a/realm/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-jni/src/io_realm_internal_table.cpp
@@ -1594,7 +1594,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
     try {
         Table* table = TBL(nativeTablePtr);
         Table* pk_table = TBL(nativePrivateKeyTablePtr);
-        const std::string table_name(table->get_name().substr(6)); // Remove "class_" prefix
+        const std::string table_name(table->get_name().substr(strlen(TABLE_PREFIX))); // Remove "class_" prefix
         size_t row_index = pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
 
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
@@ -1681,9 +1681,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
     size_t number_of_rows = pk_table->size();
     for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
         StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
-        if (table_name.begins_with("class_")) {
+        if (table_name.begins_with(TABLE_PREFIX)) {
             // New string copy is needed, since the original memory will be changed.
-            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, std::string(table_name.substr(6)));
+            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, std::string(table_name.substr(strlen(TABLE_PREFIX))));
         }
     }
 }
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index e99a451927..dca876a290 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -8,6 +8,7 @@ apply plugin: 'com.jfrog.bintray'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
 apply plugin: 'checkstyle'
+apply plugin: 'com.github.kt3k.coveralls'
 
 android {
     compileSdkVersion 23
@@ -32,6 +33,9 @@ android {
     }
 }
 
+
+coveralls.jacocoReportPath = "${buildDir}/reports/coverage/debug/report.xml"
+
 import io.realm.transformer.RealmTransformer
 
 android.registerTransform(new RealmTransformer())
@@ -43,7 +47,7 @@ repositories {
 dependencies {
     provided 'io.reactivex:rxjava:1.1.0'
     compile "io.realm:realm-annotations:${version}"
-    compile 'com.github.KeepSafe:ReLinker:1.1'
+    compile 'com.getkeepsafe.relinker:relinker:1.2.1'
 
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
     androidTestCompile 'com.android.support:support-annotations:23.1.1'
@@ -78,7 +82,7 @@ task javadoc(type: Javadoc) {
     exclude '**/R.java'
     doLast {
         copy {
-            from "src/realm-overview.png"
+            from "src/realm-java-overview.png"
             into "$buildDir/docs/javadoc"
         }
     }
diff --git a/realm/realm-library/src/androidTest/assets/all_types_invalid.json b/realm/realm-library/src/androidTest/assets/all_types_invalid.json
new file mode 100644
index 0000000000..ca70bcb7f6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/all_types_invalid.json
@@ -0,0 +1,2 @@
+{
+  "columnString" : null,
\ No newline at end of file
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
new file mode 100644
index 0000000000..10df299323
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Date;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.CyclicType;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.NullTypes;
+
+/**
+ * Super class for all RealmCollection related tests.
+ * This class only contains configuration and helper methods.
+ */
+public abstract class CollectionTests {
+
+    protected final static long YEAR_MILLIS = TimeUnit.DAYS.toMillis(365);
+
+    // Enumerate all known collection classes from the Realm API.
+    protected enum CollectionClass {
+        MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS
+    }
+
+    // Enumerate all current supported collections that can be in un-managed mode.
+    protected enum UnManagedCollection {
+        UNMANAGED_REALMLIST
+    }
+
+    // Enumerate all current supported collections that can be managed by Realm.
+    protected enum ManagedCollection {
+        MANAGED_REALMLIST, REALMRESULTS
+    }
+
+    // Enumerate all methods from the RealmCollection interface that depend on Realm API's.
+    protected enum RealmCollectionMethod {
+        WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID
+    }
+
+    // Enumerate all methods from the Collection interface
+    protected enum CollectionMethod {
+        ADD_OBJECT, ADD_ALL_OBJECTS, CLEAR, CONTAINS, CONTAINS_ALL, EQUALS, HASHCODE, IS_EMPTY, ITERATOR, REMOVE_OBJECT,
+        REMOVE_ALL, RETAIN_ALL, SIZE, TO_ARRAY, TO_ARRAY_INPUT
+    }
+
+    // Enumerate all methods on the List interface and OrderedRealmCollection interface that doesn't depend on Realm
+    // API's.
+    protected enum ListMethod {
+        FIRST, LAST, ADD_INDEX, ADD_ALL_INDEX, GET_INDEX, INDEX_OF, LAST_INDEX_OF, LIST_ITERATOR, LIST_ITERATOR_INDEX, REMOVE_INDEX,
+        SET, SUBLIST
+    }
+
+    // Enumerate all methods from the OrderedRealmCollection interface that depend on Realm API's.
+    protected enum OrderedRealmCollectionMethod {
+        DELETE_INDEX, DELETE_FIRST, DELETE_LAST, SORT, SORT_FIELD, SORT_2FIELDS, SORT_MULTI
+    }
+
+    // Enumerate all methods that can mutate a RealmCollection
+    protected enum CollectionMutatorMethod {
+        DELETE_ALL, ADD_OBJECT, ADD_ALL_OBJECTS, CLEAR, REMOVE_OBJECT, REMOVE_ALL, RETAIN_ALL
+    }
+
+    // Enumerate all methods that can mutate a RealmOrderedCollection
+    protected enum OrderedCollectionMutatorMethod {
+        DELETE_INDEX, DELETE_FIRST, DELETE_LAST, ADD_INDEX, ADD_ALL_INDEX, SET, REMOVE_INDEX
+    }
+
+    protected void populateRealm(Realm realm, int objects) {
+        realm.beginTransaction();
+        realm.delete(AllJavaTypes.class);
+        realm.delete(NonLatinFieldNames.class);
+        for (int i = 0; i < objects; i++) {
+            AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
+            fillObject(i, objects, obj);
+            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+        }
+
+        // Add all items to the RealmList on the first object
+        AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst();
+        RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+        RealmList<AllJavaTypes> list = firstObj.getFieldList();
+        for (int i = 0; i < listData.size(); i++) {
+            list.add(listData.get(i));
+        }
+        realm.commitTransaction();
+    }
+
+    protected RealmList<AllJavaTypes> populateInMemoryList(int objects) {
+        RealmList<AllJavaTypes> list = new RealmList<AllJavaTypes>();
+        for (int i = 0; i < objects; i++) {
+            AllJavaTypes obj = new AllJavaTypes();
+            fillObject(i, objects, obj);
+            list.add(obj);
+        }
+        return list;
+    }
+
+    private void fillObject(int index, int totalObjects, AllJavaTypes obj) {
+        obj.setFieldLong(index);
+        obj.setFieldInt(index);
+        obj.setFieldBoolean(((index % 2) == 0));
+        obj.setFieldBinary(new byte[]{1, 2, 3});
+        obj.setFieldDate(new Date(YEAR_MILLIS * 20 * (index - totalObjects / 2)));
+        obj.setFieldDouble(3.1415 + index);
+        obj.setFieldFloat(1.234567f + index);
+        obj.setFieldString("test data " + index);
+    }
+
+    // Creates a collection that is based on a RealmList that was deleted.
+    protected OrderedRealmCollection<CyclicType> populateCollectionOnDeletedLinkView(Realm realm, ManagedCollection collectionClass) {
+        realm.beginTransaction();
+        CyclicType parent = realm.createObject(CyclicType.class);
+        for (int i = 0; i < 10; i++) {
+            CyclicType child = new CyclicType();
+            child.setName("name_" + i);
+            child.setObject(parent);
+            parent.getObjects().add(child);
+        }
+        realm.commitTransaction();
+
+        OrderedRealmCollection<CyclicType> result;
+        switch(collectionClass) {
+            case MANAGED_REALMLIST:
+                result = parent.getObjects();
+                break;
+            case REALMRESULTS:
+                result = parent.getObjects().where().equalTo(CyclicType.FIELD_NAME, "name_0").findAll();
+                break;
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
+        }
+
+        realm.beginTransaction();
+        parent.deleteFromRealm();
+        realm.commitTransaction();
+        return result;
+    }
+
+    // Create a number of objects that mix null and real values for number type fields.
+    protected void populatePartialNullRowsForNumericTesting(Realm realm) {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(1);
+        nullTypes1.setFieldFloatNull(2F);
+        nullTypes1.setFieldDoubleNull(3D);
+        nullTypes1.setFieldBooleanNull(true);
+        nullTypes1.setFieldStringNull("4");
+        nullTypes1.setFieldDateNull(new Date(12345));
+
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+
+        NullTypes nullTypes3 = new NullTypes();
+        nullTypes3.setId(3);
+        nullTypes3.setFieldIntegerNull(0);
+        nullTypes3.setFieldFloatNull(0F);
+        nullTypes3.setFieldDoubleNull(0D);
+        nullTypes3.setFieldBooleanNull(false);
+        nullTypes3.setFieldStringNull("0");
+        nullTypes3.setFieldDateNull(new Date(0));
+
+        realm.beginTransaction();
+        realm.copyToRealm(nullTypes1);
+        realm.copyToRealm(nullTypes2);
+        realm.copyToRealm(nullTypes3);
+        realm.commitTransaction();
+    }
+
+    // Create a list of AllJavaTypes with its `fieldString` field set to a given value.
+    protected OrderedRealmCollection<AllJavaTypes> createStringCollection(Realm realm, ManagedCollection collectionClass, String... args) {
+        realm.beginTransaction();
+        realm.deleteAll();
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                int id = 0;
+                for (String arg : args) {
+                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class, id++);
+                    obj.setFieldString(arg);
+                }
+                realm.commitTransaction();
+                return realm.allObjects(AllJavaTypes.class);
+
+            case REALMRESULTS:
+                AllJavaTypes first = realm.createObject(AllJavaTypes.class);
+                first.setFieldString(args[0]);
+                first.getFieldList().add(first);
+                for (int i = 1; i < args.length; i++) {
+                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
+                    obj.setFieldString(args[i]);
+                    first.getFieldList().add(obj);
+                }
+                realm.commitTransaction();
+                return first.getFieldList();
+
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 6d84b78e2c..f0b3cbec91 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -116,7 +116,7 @@ public void constructor_dynamicObjectThrows () {
     @Test
     public void constructor_deletedObjectThrows() {
         realm.beginTransaction();
-        typedObj.removeFromRealm();
+        typedObj.deleteFromRealm();
         realm.commitTransaction();
         thrown.expect(IllegalArgumentException.class);
         new DynamicRealmObject(typedObj);
@@ -871,10 +871,31 @@ public void toString_test() {
         // Check that toString() doesn't crash. And do simple formatting checks. We cannot compare to a set String as
         // eg. the byte array will be allocated each time it is accessed.
         String str = dObjTyped.toString();
-        assertTrue(str.startsWith("class_AllJavaTypes = ["));
+        assertTrue(str.startsWith("AllJavaTypes = ["));
         assertTrue(str.endsWith("}]"));
     }
 
+    @Test
+    public void toString_nullValues() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject obj = dynamicRealm.createObject(NullTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+
+        String str = obj.toString();
+        assertTrue(str.contains(NullTypes.FIELD_STRING_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_BYTES_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_BOOLEAN_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_BYTE_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_SHORT_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_INTEGER_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_LONG_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_FLOAT_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_DOUBLE_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_DATE_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_OBJECT_NULL + ":null"));
+        assertTrue(str.contains(NullTypes.FIELD_LIST_NULL + ":RealmList<NullTypes>[0]"));
+    }
+
     public void testExceptionMessage() {
         // test for https://github.com/realm/realm-java/issues/2141
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 62fccaf864..395aae9c24 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -85,7 +85,7 @@ private void populateTestRealm(DynamicRealm realm, int objects) {
             realm.setAutoRefresh(false);
         }
         realm.beginTransaction();
-        realm.allObjects(AllTypes.CLASS_NAME).clear();
+        realm.deleteAll();
         for (int i = 0; i < objects; ++i) {
             DynamicRealmObject allTypes = realm.createObject(AllTypes.CLASS_NAME);
             allTypes.setBoolean(AllTypes.FIELD_BOOLEAN, (i % 3) == 0);
@@ -200,25 +200,25 @@ public void where() {
     }
 
     @Test(expected = IllegalArgumentException.class)
-    public void clear_invalidName() {
+    public void delete_type_invalidName() {
         realm.beginTransaction();
-        realm.clear("I don't exist");
+        realm.delete("I don't exist");
     }
 
     @Test(expected = IllegalStateException.class)
-    public void clear_outsideTransactionClearOutsideTransactionThrows() {
-        realm.clear(AllTypes.CLASS_NAME);
+    public void delete_type_outsideTransactionClearOutsideTransactionThrows() {
+        realm.delete(AllTypes.CLASS_NAME);
     }
 
     @Test
-    public void clear() {
+    public void delete_type() {
         realm.beginTransaction();
         realm.createObject(AllTypes.CLASS_NAME);
         realm.commitTransaction();
 
         assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());
         realm.beginTransaction();
-        realm.clear(AllTypes.CLASS_NAME);
+        realm.delete(AllTypes.CLASS_NAME);
         realm.commitTransaction();
         assertEquals(0, realm.where(AllTypes.CLASS_NAME).count());
     }
@@ -757,7 +757,7 @@ public void findAllSortedAsync_usingMultipleFields() {
 
         dynamicRealm.setAutoRefresh(false);
         dynamicRealm.beginTransaction();
-        dynamicRealm.clear(AllTypes.CLASS_NAME);
+        dynamicRealm.delete(AllTypes.CLASS_NAME);
         for (int i = 0; i < 5; ) {
             DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
             allTypes.set(AllTypes.FIELD_LONG, i);
@@ -957,7 +957,7 @@ public void run() {
     }
 
     @Test
-    public void clear_all() {
+    public void deleteAll() {
         realm.beginTransaction();
         realm.createObject(AllTypes.CLASS_NAME);
         DynamicRealmObject cat = realm.createObject(Cat.CLASS_NAME);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
new file mode 100644
index 0000000000..97c81a5ced
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -0,0 +1,762 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.entities.NullTypes;
+import io.realm.entities.Owner;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test class for all methods specific to OrderedRealmCollections that are not implementation specific.
+ *
+ * Methods tested in this class:
+ *
+ * # OrderedRealmCollection
+ *
+ * - E first()
+ * - E last()
+ * + void sort(String field)
+ * + void sort(String field, Sort sortOrder)
+ * + void sort(String field1, Sort sortOrder1, String field2, Sort sortOrder2)
+ * + void sort(String[] fields, Sort[] sortOrders)
+ * + void deleteFromRealm(int location)
+ * + void deleteFirstFromRealm()
+ * + void deleteLastFromRealm();
+ *
+ * # List
+ *
+ *  - void add(int location, E object);
+ *  - boolean addAll(int location, Collection<? extends E> collection);
+ *  - E get(int location);
+ *  - int indexOf(Object object);
+ *  - int lastIndexOf(Object object);
+ *  - ListIterator<E> listIterator();
+ *  - ListIterator<E> listIterator(int location);
+ *  - E remove(int location);
+ *  - E set(int location, E object);
+ *  - List<E> subList(int start, int end);
+ *
+ * # RealmCollection
+ *
+ * - RealmQuery<E> where();
+ * - Number min(String fieldName);
+ * - Number max(String fieldName);
+ * - Number sum(String fieldName);
+ * - double average(String fieldName);
+ * - Date maxDate(String fieldName);
+ * - Date minDate(String fieldName);
+ * - void deleteAllFromRealm();
+ * - boolean isLoaded();
+ * - boolean load();
+ * - boolean isValid();
+ * - BaseRealm getRealm();
+ *
+ * # Collection
+ *
+ * - public boolean add(E object);
+ * - public boolean addAll(Collection<? extends E> collection);
+ * - public void deleteAll();
+ * - public boolean contains(Object object);
+ * - public boolean containsAll(Collection<?> collection);
+ * - public boolean equals(Object object);
+ * - public int hashCode();
+ * - public boolean isEmpty();
+ * - public Iterator<E> iterator();
+ * - public boolean remove(Object object);
+ * - public boolean removeAll(Collection<?> collection);
+ * - public boolean retainAll(Collection<?> collection);
+ * - public int size();
+ * - public Object[] toArray();
+ * - public <T> T[] toArray(T[] array);
+ *
+ * @see RealmCollectionTests
+ * @see ManagedRealmCollectionTests
+ * @see UnManagedRealmCollectionTests
+ */
+
+@RunWith(Parameterized.class)
+public class ManagedOrderedRealmCollectionTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+    private final static int TEST_DATA_FIRST_HALF = (int) ((TEST_SIZE / 2.0D) - 1);
+    private final static int TEST_DATA_LAST_HALF = (int) ((TEST_SIZE / 2.0D) + 1);
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private final ManagedCollection collectionClass;
+    private Realm realm;
+    private OrderedRealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<ManagedCollection> data() {
+        return Arrays.asList(ManagedCollection.values());
+    }
+
+    public ManagedOrderedRealmCollectionTests(ManagedCollection collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        populateRealm(realm, TEST_SIZE);
+        collection = createCollection(collectionClass);
+    }
+
+    OrderedRealmCollection<AllJavaTypes> createCollection(ManagedCollection collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                return realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, 0)
+                        .findFirst()
+                        .getFieldList();
+
+            case REALMRESULTS:
+                return realm.allObjects(AllJavaTypes.class);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, ManagedCollection collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                realm.beginTransaction();
+                NullTypes obj = realm.createObject(NullTypes.class);
+                realm.commitTransaction();
+                return obj.getFieldListNull();
+
+            case REALMRESULTS:
+                return realm.where(NullTypes.class).findAll();
+        }
+
+        throw new AssertionError("Unknown collection: " + collectionClass);
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    @Test
+    public void sort_twoFields() {
+        OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        AllJavaTypes obj = sortedList.first();
+        assertFalse(obj.isFieldBoolean());
+        assertEquals(TEST_SIZE - 1, obj.getFieldLong());
+    }
+
+    @Test
+    public void sort_boolean() {
+        OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals(false, sortedList.last().isFieldBoolean());
+        assertEquals(true, sortedList.first().isFieldBoolean());
+        assertEquals(true, sortedList.get(TEST_DATA_FIRST_HALF).isFieldBoolean());
+        assertEquals(false, sortedList.get(TEST_DATA_LAST_HALF).isFieldBoolean());
+
+        RealmResults<AllJavaTypes> reverseList = sortedList.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, reverseList.size());
+        assertEquals(true, reverseList.last().isFieldBoolean());
+        assertEquals(false, reverseList.first().isFieldBoolean());
+        assertEquals(false, reverseList.get(TEST_DATA_FIRST_HALF).isFieldBoolean());
+        assertEquals(true, reverseList.get(TEST_DATA_LAST_HALF).isFieldBoolean());
+
+        RealmResults<AllJavaTypes> reserveSortedList = reverseList.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, reserveSortedList.size());
+        assertEquals(reserveSortedList.first(), sortedList.first());
+    }
+
+    @Test
+    public void sort_string() {
+        OrderedRealmCollection<AllJavaTypes> resultList = collection;
+        OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
+
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals(resultList.first().getFieldString(), sortedList.last().getFieldString());
+
+        RealmResults<AllJavaTypes> reverseList = sortedList.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, reverseList.size());
+        assertEquals(resultList.first().getFieldString(), reverseList.first().getFieldString());
+
+        int numberOfDigits = 1 + ((int) Math.log10(TEST_SIZE));
+        int largestNumber = 1;
+        largestNumber = (int) (largestNumber * Math.pow(10, numberOfDigits - 1));
+        largestNumber = largestNumber - 1;
+        assertEquals(resultList.get(largestNumber).getFieldString(), reverseList.last().getFieldString());
+        RealmResults<AllJavaTypes> reverseSortedList = reverseList.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, reverseSortedList.size());
+    }
+
+    @Test
+    public void sort_double() {
+        OrderedRealmCollection<AllJavaTypes> resultList = collection;
+        OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_DOUBLE, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_SIZE, sortedList.size());
+            assertEquals(resultList.first().getFieldDouble(), sortedList.last().getFieldDouble(), 0D);
+
+        RealmResults<AllJavaTypes> reverseList = sortedList.sort(AllJavaTypes.FIELD_DOUBLE, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, reverseList.size());
+        assertEquals(resultList.first().getFieldDouble(), reverseList.first().getFieldDouble(), 0D);
+        assertEquals(resultList.last().getFieldDouble(), reverseList.last().getFieldDouble(), 0D);
+
+        RealmResults<AllJavaTypes> reverseSortedList = reverseList.sort(AllJavaTypes.FIELD_DOUBLE, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, reverseSortedList.size());
+    }
+
+    @Test
+    public void sort_float() {
+        OrderedRealmCollection<AllJavaTypes> resultList = collection;
+        OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_FLOAT, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals(resultList.first().getFieldFloat(), sortedList.last().getFieldFloat(), 0D);
+
+        RealmResults<AllJavaTypes> reverseList = sortedList.sort(AllJavaTypes.FIELD_FLOAT, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, reverseList.size());
+        assertEquals(resultList.first().getFieldFloat(), reverseList.first().getFieldFloat(), 0D);
+        assertEquals(resultList.last().getFieldFloat(), reverseList.last().getFieldFloat(), 0D);
+
+        RealmResults<AllJavaTypes> reverseSortedList = reverseList.sort(AllJavaTypes.FIELD_FLOAT, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, reverseSortedList.size());
+    }
+
+    private void doTestSortOnColumnWithPartialNullValues(String fieldName,
+                                                         OrderedRealmCollection<NullTypes> original,
+                                                         OrderedRealmCollection<NullTypes> copy) {
+
+        RealmResults<NullTypes> sortedList = copy.sort(fieldName, Sort.ASCENDING);
+        assertEquals("Should have same size", original.size(), sortedList.size());
+        // Null should always be the first one in the ascending sorted list
+        assertEquals(2, sortedList.first().getId());
+        assertEquals(1, sortedList.last().getId());
+
+        // Descending
+        sortedList = sortedList.sort(fieldName, Sort.DESCENDING);
+        assertEquals("Should have same size", original.size(), sortedList.size());
+        assertEquals(1, sortedList.first().getId());
+        // Null should always be the last one in the descending sorted list
+        assertEquals(2, sortedList.last().getId());
+    }
+
+    // Test sort on nullable fields with null values partially
+    @Test
+    public void sort_rowsWithPartialNullValues() {
+        populatePartialNullRowsForNumericTesting(realm);
+        OrderedRealmCollection<NullTypes> original;
+        OrderedRealmCollection<NullTypes> copy;
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                realm.beginTransaction();
+                RealmResults<NullTypes> objects = realm.allObjects(NullTypes.class);
+                NullTypes parent = realm.createObject(NullTypes.class, 0);
+                for (int i = 0; i < objects.size(); i++) {
+                    NullTypes object = objects.get(i);
+                    if (object.getId() != 0) {
+                        parent.getFieldListNull().add(object);
+                    }
+                }
+                realm.commitTransaction();
+                original = parent.getFieldListNull().where().findAll();
+                copy = parent.getFieldListNull();
+                break;
+
+            case REALMRESULTS:
+                original = realm.allObjects(NullTypes.class);
+                copy = realm.allObjects(NullTypes.class);
+                break;
+
+            default:
+                throw new AssertionError("Unknown collection class: " + collectionClass);
+        }
+
+        // 1 String
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_STRING_NULL, original, copy);
+
+        // 3 Boolean
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_BOOLEAN_NULL, original, copy);
+
+        // 6 Integer
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_INTEGER_NULL, original, copy);
+
+        // 7 Float
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_FLOAT_NULL, original, copy);
+
+        // 8 Double
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_DOUBLE_NULL, original, copy);
+
+        // 10 Date
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_DATE_NULL, original, copy);
+    }
+
+    @Test
+    public void sort_nonExistingColumn() {
+        RealmResults<AllJavaTypes> resultList = realm.where(AllJavaTypes.class).findAll();
+        thrown.expect(IllegalArgumentException.class);
+        resultList.sort("Non-existing");
+    }
+
+    @Test
+    public void sort_danishCharacters() {
+        OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
+                "Æble",
+                "Øl",
+                "Århus"
+        );
+
+        collection = collection.sort(AllJavaTypes.FIELD_STRING);
+
+        assertEquals(3, collection.size());
+        assertEquals("Æble", collection.get(0).getFieldString());
+        assertEquals("Øl", collection.get(1).getFieldString());
+        assertEquals("Århus", collection.get(2).getFieldString());
+
+        collection = collection.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(3, collection.size());
+        assertEquals("Århus", collection.get(0).getFieldString());
+        assertEquals("Øl", collection.get(1).getFieldString());
+        assertEquals("Æble", collection.get(2).getFieldString());
+    }
+
+    @Test
+    public void sort_russianCharacters() {
+        OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
+                "Санкт-Петербург",
+                "Москва",
+                "Новороссийск"
+        );
+
+        collection = collection.sort(AllJavaTypes.FIELD_STRING);
+
+        assertEquals(3, collection.size());
+        assertEquals("Москва", collection.get(0).getFieldString());
+        assertEquals("Новороссийск", collection.get(1).getFieldString());
+        assertEquals("Санкт-Петербург", collection.get(2).getFieldString());
+
+        collection = collection.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(3, collection.size());
+        assertEquals("Санкт-Петербург", collection.get(0).getFieldString());
+        assertEquals("Новороссийск", collection.get(1).getFieldString());
+        assertEquals("Москва", collection.get(2).getFieldString());
+    }
+
+    @Test
+    public void sort_greekCharacters() {
+        OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
+                "αύριο",
+                "ημέρες",
+                "δοκιμές"
+        );
+
+        collection = collection.sort(AllJavaTypes.FIELD_STRING);
+
+        assertEquals(3, collection.size());
+        assertEquals("αύριο", collection.get(0).getFieldString());
+        assertEquals("δοκιμές", collection.get(1).getFieldString());
+        assertEquals("ημέρες", collection.get(2).getFieldString());
+
+        collection = collection.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(3, collection.size());
+        assertEquals("ημέρες", collection.get(0).getFieldString());
+        assertEquals("δοκιμές", collection.get(1).getFieldString());
+        assertEquals("αύριο", collection.get(2).getFieldString());
+    }
+
+    //No sorting order defined. There are Korean, Arabic and Chinese characters.
+    @Test
+    public void sort_manyDifferentCharacters() {
+        OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
+                "단위",
+                "테스트",
+                "وحدة",
+                "اختبار",
+                "单位",
+                "试验",
+                "單位",
+                "測試"
+        );
+
+        collection.sort(AllJavaTypes.FIELD_STRING);
+        assertEquals(8, collection.size());
+
+        collection.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(8, collection.size());
+    }
+
+    @Test
+    public void sort_twoLanguages() {
+        OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
+                "test",
+                "αύριο",
+                "work"
+        );
+
+        try {
+            collection.sort(AllJavaTypes.FIELD_STRING);
+        } catch (IllegalArgumentException e) {
+            fail("Failed to sort with two kinds of alphabets");
+        }
+    }
+
+    @Test
+    public void sort_usingChildObject() {
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
+        owner.setName("owner");
+        Cat cat = realm.createObject(Cat.class);
+        cat.setName("cat");
+        owner.setCat(cat);
+        realm.commitTransaction();
+
+        RealmQuery<Owner> query = realm.where(Owner.class);
+        RealmResults<Owner> owners = query.findAll();
+
+        try {
+            owners.sort("cat.name");
+            fail("Sorting by child object properties should result in a IllegalArgumentException");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void sort_nullArguments() {
+        OrderedRealmCollection<AllJavaTypes> result = collection;
+        try {
+            result.sort(null);
+            fail("Sorting with a null field name should throw an IllegalArgumentException");
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            result.sort((String) null, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void sort_emptyResults() {
+        OrderedRealmCollection<NullTypes> collection = createEmptyCollection(realm, collectionClass);
+        assertEquals(0, collection.size());
+        collection.sort(NullTypes.FIELD_STRING_NULL);
+        assertEquals(0, collection.size());
+    }
+
+    @Test
+    public void sort_singleField() {
+        RealmResults<AllJavaTypes> sortedList = collection.sort(new String[]{AllJavaTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals(TEST_SIZE - 1, sortedList.first().getFieldLong());
+        assertEquals(0, sortedList.last().getFieldLong());
+    }
+
+    @Test
+    public void sort_date() {
+        OrderedRealmCollection<AllJavaTypes> resultList = collection;
+        OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals(resultList.first().getFieldDate(), sortedList.last().getFieldDate());
+
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_DATE, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals(resultList.first().getFieldDate(), sortedList.first().getFieldDate());
+        assertEquals(resultList.last().getFieldDate(), sortedList.last().getFieldDate());
+
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
+    }
+
+    @Test
+    public void sort_long() {
+        OrderedRealmCollection<AllJavaTypes> resultList = collection;
+        OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getFieldLong(), sortedList.last().getFieldLong());
+
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals("First excepted to be first", resultList.first().getFieldLong(), sortedList.first().getFieldLong());
+        assertEquals("Last excepted to be last", resultList.last().getFieldLong(), sortedList.last().getFieldLong());
+
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
+    }
+
+    @Test
+    public void deleteFromRealm() {
+        OrderedRealmCollection<Dog> collection = createNonCyclicCollection(realm, collectionClass);
+        assertEquals(1, collection.get(1).getAge());
+        realm.beginTransaction();
+        collection.deleteFromRealm(0);
+        realm.commitTransaction();
+        assertEquals(TEST_SIZE - 1, collection.size());
+        assertEquals(2, collection.get(1).getAge());
+    }
+
+    @Test
+    public void deleteFromRealm_invalidIndex() {
+        Integer[] indexes = new Integer[] { Integer.MIN_VALUE, -1, TEST_SIZE, Integer.MAX_VALUE };
+        for (Integer index : indexes) {
+            try {
+                realm.beginTransaction();
+                collection.deleteFromRealm(index);
+                fail("Index should have thrown exception: " + index);
+            } catch (ArrayIndexOutOfBoundsException ignored) {
+            } finally {
+                realm.cancelTransaction();
+            }
+        }
+    }
+
+    @Test
+    public void deleteFirstFromRealm() {
+        OrderedRealmCollection<Dog> collection = createNonCyclicCollection(realm, collectionClass);
+        assertEquals(0, collection.get(0).getAge());
+
+        realm.beginTransaction();
+        assertTrue(collection.deleteFirstFromRealm());
+        realm.commitTransaction();
+        assertEquals(TEST_SIZE - 1, collection.size());
+        assertEquals(1, collection.get(0).getAge());
+    }
+
+    private OrderedRealmCollection<Dog> createNonCyclicCollection(Realm realm, ManagedCollection collectionClass) {
+        realm.beginTransaction();
+        realm.deleteAll();
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                Owner owner = realm.createObject(Owner.class);
+                RealmList<Dog> dogs = owner.getDogs();
+                for (int i = 0; i < TEST_SIZE; i++) {
+                    Dog dog = realm.createObject(Dog.class);
+                    dog.setName("Dog " + i);
+                    dog.setAge(i);
+                    dogs.add(dog);
+                }
+                realm.commitTransaction();
+                return dogs;
+
+            case REALMRESULTS:
+                for (int i = 0; i < TEST_SIZE; i++) {
+                    Dog dog = realm.createObject(Dog.class);
+                    dog.setAge(i);
+                    dog.setName("Dog " + i);
+                }
+                realm.commitTransaction();
+                return realm.allObjects(Dog.class);
+
+            default:
+                throw new AssertionError("Unknown collection class: " + collectionClass);
+        }
+
+    }
+
+    @Test
+    public void deleteFirstFromRealm_emptyCollection() {
+        OrderedRealmCollection<NullTypes> collection = createEmptyCollection(realm, collectionClass);
+        realm.beginTransaction();
+        assertFalse(collection.deleteFirstFromRealm());
+        realm.commitTransaction();
+        assertEquals(0, collection.size());
+    }
+
+    @Test
+    public void deleteLastFromRealm() {
+        assertEquals(TEST_SIZE - 1, collection.last().getFieldLong());
+        realm.beginTransaction();
+        assertTrue(collection.deleteLastFromRealm());
+        realm.commitTransaction();
+        assertEquals(TEST_SIZE - 1, collection.size());
+        assertEquals(TEST_SIZE - 2, collection.last().getFieldLong());
+    }
+
+    @Test
+    public void deleteLastFromRealm_emptyCollection() {
+        OrderedRealmCollection<NullTypes> collection = createEmptyCollection(realm, collectionClass);
+        realm.beginTransaction();
+        assertFalse(collection.deleteLastFromRealm());
+        realm.commitTransaction();
+        assertEquals(0, collection.size());
+    }
+
+    // Test all methods that mutate data throw correctly if not inside an transaction.
+    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level
+    @Test
+    public void mutableMethodsOutsideTransactions() {
+
+        for (OrderedCollectionMutatorMethod method : OrderedCollectionMutatorMethod.values()) {
+
+            // Define expected exception
+            Class<? extends Throwable> expected = IllegalStateException.class;
+            if (collectionClass == ManagedCollection.REALMRESULTS) {
+                switch (method) {
+                    case ADD_INDEX:
+                    case ADD_ALL_INDEX:
+                    case SET:
+                    case REMOVE_INDEX:
+                        expected = UnsupportedOperationException.class;
+                        break;
+                    default:
+                        // Use default exception
+                }
+            }
+
+            try {
+                switch (method) {
+                    case DELETE_INDEX: collection.deleteFromRealm(0); break;
+                    case DELETE_FIRST: collection.deleteFirstFromRealm(); break;
+                    case DELETE_LAST: collection.deleteLastFromRealm(); break;
+                    case ADD_INDEX: collection.add(0, new AllJavaTypes()); break;
+                    case ADD_ALL_INDEX: collection.addAll(0, Collections.singletonList(new AllJavaTypes())); break;
+                    case SET: collection.set(0, new AllJavaTypes()); break;
+                    case REMOVE_INDEX: collection.remove(0); break;
+                }
+                fail("Unknown method or it failed to throw: " + method);
+            } catch (Throwable t) {
+                if (!t.getClass().equals(expected)) {
+                    fail(method + " didn't throw the expected exception. Was: " + t + ", expected: " + expected);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
+        for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
+            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+        }
+
+        for (ListMethod method : ListMethod.values()) {
+            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+        }
+    }
+
+    private boolean runMethodOnWrongThread(final OrderedRealmCollectionMethod method) throws ExecutionException, InterruptedException {
+        realm.beginTransaction();
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                try {
+                    switch (method) {
+                        case DELETE_INDEX: collection.deleteFromRealm(0); break;
+                        case DELETE_FIRST: collection.deleteFirstFromRealm(); break;
+                        case DELETE_LAST: collection.deleteLastFromRealm(); break;
+                        case SORT: collection.sort(AllJavaTypes.FIELD_STRING); break;
+                        case SORT_FIELD: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING); break;
+                        case SORT_2FIELDS: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING); break;
+                        case SORT_MULTI: collection.sort(new String[] { AllJavaTypes.FIELD_STRING }, new Sort[] { Sort.ASCENDING }); break;
+                    }
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                }
+            }
+        });
+        Boolean result = future.get();
+        realm.cancelTransaction();
+        return result;
+    }
+
+    private boolean runMethodOnWrongThread(final ListMethod method) throws ExecutionException, InterruptedException {
+        realm.beginTransaction();
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                // Define expected exception
+                Class<? extends Throwable> expected = IllegalStateException.class;
+                if (collectionClass == ManagedCollection.REALMRESULTS) {
+                    switch (method) {
+                        case ADD_INDEX:
+                        case ADD_ALL_INDEX:
+                        case SET:
+                        case REMOVE_INDEX:
+                            expected = UnsupportedOperationException.class;
+                            break;
+                        default:
+                            // Use default exception
+                    }
+                }
+
+                try {
+                    switch (method) {
+                        case FIRST: collection.first(); break;
+                        case LAST: collection.last(); break;
+                        case ADD_INDEX: collection.add(0, new AllJavaTypes()); break;
+                        case ADD_ALL_INDEX: collection.addAll(0, Collections.singletonList(new AllJavaTypes())); break;
+                        case GET_INDEX: collection.get(0); break;
+                        case INDEX_OF: collection.indexOf(new AllJavaTypes()); break;
+                        case LAST_INDEX_OF: collection.lastIndexOf(new AllJavaTypes()); break;
+                        case LIST_ITERATOR: collection.listIterator(); break;
+                        case LIST_ITERATOR_INDEX: collection.listIterator(0); break;
+                        case REMOVE_INDEX: collection.remove(0); break;
+                        case SET: collection.set(0, new AllJavaTypes()); break;
+                        case SUBLIST: collection.subList(0, 1); break;
+                    }
+                    return false;
+                } catch (Throwable t) {
+                    if (!t.getClass().equals(expected)) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        });
+        Boolean result = future.get();
+        realm.cancelTransaction();
+        return result;
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
new file mode 100644
index 0000000000..fa18344d51
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -0,0 +1,785 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.NullTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test class for all methods part of the the {@link RealmCollection} interface.
+ * This class only tests collections that are managed by Realm. See {@link UnManagedRealmCollectionTests} for
+ * all tests targeting un-managed collections.
+ *
+ * Methods tested in this class:
+ *
+ * # RealmCollection
+ *
+ * + RealmQuery<E> where();
+ * + Number min(String fieldName);
+ * + Number max(String fieldName);
+ * + Number sum(String fieldName);
+ * + double average(String fieldName);
+ * + Date maxDate(String fieldName);
+ * + Date minDate(String fieldName);
+ * + void deleteAllFromRealm();
+ * + boolean isLoaded();
+ * + boolean load();
+ * + boolean isValid();
+ * + BaseRealm getRealm();
+ *
+ * # Collection
+ *
+ * - public boolean add(E object);
+ * - public boolean addAll(Collection<? extends E> collection);
+ * - public void deleteAll();
+ * - public boolean contains(Object object);
+ * - public boolean containsAll(Collection<?> collection);
+ * - public boolean equals(Object object);
+ * - public int hashCode();
+ * - public boolean isEmpty();
+ * - public Iterator<E> iterator();
+ * - public boolean remove(Object object);
+ * - public boolean removeAll(Collection<?> collection);
+ * - public boolean retainAll(Collection<?> collection);
+ * - public int size();
+ * - public Object[] toArray();
+ * - public <T> T[] toArray(T[] array);
+ */
+@RunWith(Parameterized.class)
+public class ManagedRealmCollectionTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private final ManagedCollection collectionClass;
+    private Realm realm;
+
+    // Collections used for testing
+    private RealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<ManagedCollection> data() {
+        return Arrays.asList(ManagedCollection.values());
+    }
+
+    public ManagedRealmCollectionTests(ManagedCollection collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        populateRealm(realm, TEST_SIZE);
+        collection = createCollection(collectionClass);
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    private OrderedRealmCollection<AllJavaTypes> createCollection(ManagedCollection collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                return realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, 0)
+                        .findFirst()
+                        .getFieldList();
+
+            case REALMRESULTS:
+                return realm.allObjects(AllJavaTypes.class);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, ManagedCollection collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                realm.beginTransaction();
+                NullTypes obj = realm.createObject(NullTypes.class);
+                realm.commitTransaction();
+                return obj.getFieldListNull();
+
+            case REALMRESULTS:
+                return realm.where(NullTypes.class).findAll();
+        }
+
+        throw new AssertionError("Unknown collection: " + collectionClass);
+    }
+
+    private OrderedRealmCollection<NullTypes> createAllNullRowsForNumericTesting(Realm realm, ManagedCollection collectionClass) {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+        switch(collectionClass) {
+            case MANAGED_REALMLIST:
+                RealmResults<NullTypes> results = realm.allObjects(NullTypes.class);
+                RealmList<NullTypes> list = results.get(0).getFieldListNull();
+                realm.beginTransaction();
+                for (int i = 0; i < results.size(); i++) {
+                    list.add(results.get(i));
+                }
+                realm.commitTransaction();
+                return list;
+
+            case REALMRESULTS:
+                return realm.where(NullTypes.class).findAll();
+        }
+        throw new AssertionError("Unknown collection: " + collectionClass);
+    }
+
+    private OrderedRealmCollection<NullTypes> createPartialNullRowsForNumericTesting(Realm realm, ManagedCollection collectionClass) {
+        populatePartialNullRowsForNumericTesting(realm);
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                RealmResults<NullTypes> results = realm.allObjects(NullTypes.class);
+                RealmList<NullTypes> list = results.get(0).getFieldListNull();
+                realm.beginTransaction();
+                int size = results.size();
+                for (int i = 0; i < size; i++) {
+                    list.add(results.get(i));
+                }
+                realm.commitTransaction();
+                return list;
+
+            case REALMRESULTS:
+                return realm.where(NullTypes.class).findAll();
+        }
+        throw new AssertionError("Unknown collection: " + collectionClass);
+    }
+
+    // PRE-CONDITION: populateRealm() was called as part of setUp()
+    private OrderedRealmCollection<NonLatinFieldNames> createNonLatinCollection(Realm realm, ManagedCollection collectionClass) {
+        switch (collectionClass) {
+
+            case MANAGED_REALMLIST:
+                realm.beginTransaction();
+                RealmResults<NonLatinFieldNames> results = realm.allObjects(NonLatinFieldNames.class);
+                RealmList<NonLatinFieldNames> list = results.get(0).getChildren();
+                for (int i = 0; i < results.size(); i++) {
+                    list.add(results.get(i));
+                }
+                realm.commitTransaction();
+                return list;
+
+            case REALMRESULTS:
+                return realm.allObjects(NonLatinFieldNames.class);
+
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
+        }
+    }
+
+    @Test
+    public void where() {
+        RealmResults<AllJavaTypes> results = collection.where().findAll();
+        assertEquals(TEST_SIZE, results.size());
+    }
+
+    @Test
+    public void where_contains() {
+        RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class).findAll().where();
+        AllJavaTypes item = query.findFirst();
+        assertTrue("Item should exist in results.", query.findAll().contains(item));
+    }
+
+    @Test
+    public void where_contains_null() {
+        RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class).findAll().where();
+        assertFalse("Should not contain a null item.", query.findAll().contains(null));
+    }
+
+    @Test
+    public void where_shouldNotContainRemovedItem() {
+        RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class).findAll().where();
+        AllJavaTypes item = realm.where(AllJavaTypes.class).findFirst();
+        realm.beginTransaction();
+        item.deleteFromRealm();
+        realm.commitTransaction();
+        assertFalse("Should not contain a removed item.", query.findAll().contains(item));
+    }
+
+    /**
+     * Test to see if a particular item that does exist in the same Realm does not
+     * exist in the result set of another query.
+     */
+    @Test
+    public void where_lessThanGreaterThan() {
+        RealmResults<AllJavaTypes> items = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, 1000).findAll();
+        AllJavaTypes anotherType = realm.where(AllJavaTypes.class).greaterThan(AllJavaTypes.FIELD_LONG, 1000).findFirst();
+        assertFalse("Should not be able to find item in another result list.", items.contains(anotherType));
+    }
+
+    @Test
+    public void where_equalTo_manyConditions() {
+        RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
+        query.equalTo(AllJavaTypes.FIELD_LONG, 0);
+        for (int i = 1; i < TEST_SIZE; i++) {
+            query.or().equalTo(AllJavaTypes.FIELD_LONG, i);
+        }
+        RealmResults<AllJavaTypes> allTypesRealmResults = query.findAll();
+        assertEquals(TEST_SIZE, allTypesRealmResults.size());
+    }
+
+    @Test
+    public void where_findAll_size() {
+        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).findAll();
+        assertEquals(TEST_SIZE, results.size());
+
+        // querying a RealmResults should find objects that fulfill the condition
+        RealmResults<AllJavaTypes> onedigits = results.where().lessThan(AllJavaTypes.FIELD_LONG, 10).findAll();
+        assertEquals(Math.min(10, TEST_SIZE), onedigits.size());
+
+        // if no objects fulfill conditions, the result has zero objects
+        RealmResults<AllJavaTypes> none = results.where().greaterThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(0, none.size());
+
+        // querying a result with zero objects must give zero objects
+        RealmResults<AllJavaTypes> stillNone = none.where().greaterThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
+        assertEquals(0, stillNone.size());
+    }
+
+    @Test
+    public void where_findAllSorted() {
+        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, results.size());
+        //noinspection ConstantConditions
+        assertEquals(0, results.first().getFieldLong());
+        //noinspection ConstantConditions
+        assertEquals(TEST_SIZE - 1, results.last().getFieldLong());
+
+        RealmResults<AllJavaTypes> reverseList = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, reverseList.size());
+        //noinspection ConstantConditions
+        assertEquals(0, reverseList.last().getFieldLong());
+        //noinspection ConstantConditions
+        assertEquals(TEST_SIZE - 1, reverseList.first().getFieldLong());
+
+        try {
+            realm.where(AllJavaTypes.class).findAllSorted("invalid",
+                    Sort.DESCENDING);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void where_queryDateField() {
+        RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_DATE, new Date(YEAR_MILLIS * 20));
+        RealmResults<AllJavaTypes> all = query.findAll();
+        assertEquals(1, query.count());
+        assertEquals(1, all.size());
+
+        // before 1901
+        query = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_DATE, new Date(YEAR_MILLIS * -100));
+        all = query.findAll();
+        assertEquals(1, query.count());
+        assertEquals(1, all.size());
+
+        // after 2038
+        query = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_DATE, new Date(YEAR_MILLIS * 80));
+        all = query.findAll();
+        assertEquals(1, query.count());
+        assertEquals(1, all.size());
+    }
+
+    @Test
+    public void min() {
+        Number minimum = collection.min(AllJavaTypes.FIELD_LONG);
+        assertEquals(0, minimum.intValue());
+    }
+
+    // Test min on empty columns
+    @Test
+    public void min_emptyNonNullFields() {
+        OrderedRealmCollection<NullTypes> results = createEmptyCollection(realm, collectionClass);
+        assertNull(results.min(NullTypes.FIELD_INTEGER_NOT_NULL));
+        assertNull(results.min(NullTypes.FIELD_FLOAT_NOT_NULL));
+        assertNull(results.min(NullTypes.FIELD_DOUBLE_NOT_NULL));
+        assertNull(results.minDate(NullTypes.FIELD_DATE_NOT_NULL));
+    }
+
+    // Test min on nullable rows with all null values
+    @Test
+    public void min_emptyNullFields() {
+        OrderedRealmCollection<NullTypes> results = createAllNullRowsForNumericTesting(realm, collectionClass);
+        assertNull(results.max(NullTypes.FIELD_INTEGER_NULL));
+        assertNull(results.max(NullTypes.FIELD_FLOAT_NULL));
+        assertNull(results.max(NullTypes.FIELD_DOUBLE_NULL));
+        assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
+    }
+
+    // Test min on nullable rows with partial null values
+    @Test
+    public void min_partialNullRows() {
+        OrderedRealmCollection<NullTypes> results = createPartialNullRowsForNumericTesting(realm, collectionClass);
+        assertEquals(0, results.min(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(0f, results.min(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(0d, results.min(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    @Test
+    public void max() {
+        Number maximum = collection.max(AllJavaTypes.FIELD_LONG);
+        assertEquals(TEST_SIZE - 1, maximum.intValue());
+    }
+
+    // Test max on empty columns
+    @Test
+    public void max_emptyNonNullFields() {
+        OrderedRealmCollection<NullTypes> results = createEmptyCollection(realm, collectionClass);
+        assertNull(results.max(NullTypes.FIELD_INTEGER_NOT_NULL));
+        assertNull(results.max(NullTypes.FIELD_FLOAT_NOT_NULL));
+        assertNull(results.max(NullTypes.FIELD_DOUBLE_NOT_NULL));
+        assertNull(results.maxDate(NullTypes.FIELD_DATE_NOT_NULL));
+    }
+
+    // Test max on nullable rows with all null values
+    @Test
+    public void max_emptyNullFields() {
+        OrderedRealmCollection<NullTypes> results = createAllNullRowsForNumericTesting(realm, collectionClass);
+        assertNull(results.max(NullTypes.FIELD_INTEGER_NULL));
+        assertNull(results.max(NullTypes.FIELD_FLOAT_NULL));
+        assertNull(results.max(NullTypes.FIELD_DOUBLE_NULL));
+        assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
+    }
+
+    // Test max on nullable rows with partial null values
+    @Test
+    public void max_partialNullRows() {
+        OrderedRealmCollection<NullTypes> results = createPartialNullRowsForNumericTesting(realm, collectionClass);
+        assertEquals(1, results.max(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(2f, results.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(3d, results.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    @Test
+    public void sum() {
+        Number sum = collection.sum(AllJavaTypes.FIELD_LONG);
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((TEST_SIZE - 1) * TEST_SIZE/ 2, sum.intValue());
+    }
+
+    // Test sum on nullable rows with all null values
+    @Test
+    public void sum_nullRows() {
+        OrderedRealmCollection<NullTypes> resultList = createAllNullRowsForNumericTesting(realm, collectionClass);
+        assertEquals(0, resultList.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(0f, resultList.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(0d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test sum on nullable rows with partial null values
+    @Test
+    public void sum_partialNullRows() {
+        OrderedRealmCollection<NullTypes> resultList = createPartialNullRowsForNumericTesting(realm, collectionClass);
+
+        assertEquals(1, resultList.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(2f, resultList.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(3d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    @Test
+    public void sum_nonLatinColumnNames() {
+        OrderedRealmCollection<NonLatinFieldNames> resultList = createNonLatinCollection(realm, collectionClass);
+
+        Number sum = resultList.sum(NonLatinFieldNames.FIELD_LONG_KOREAN_CHAR);
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((TEST_SIZE - 1) * TEST_SIZE / 2, sum.intValue());
+
+        sum = resultList.sum(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR);
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((TEST_SIZE - 1) * TEST_SIZE / 2, sum.intValue());
+    }
+
+    @Test
+    public void avg() {
+        double N = (double) TEST_SIZE;
+
+        // Sum of numbers 1 to M: M*(M+1)/2
+        // See setUp() for values of fields
+        // N = TEST_DATA_SIZE
+
+        // Type: double; a = 3.1415
+        // a, a+1, ..., a+i, ..., a+N-1
+        // sum = 3.1415*N + N*(N-1)/2
+        // average = sum/N = 3.1415+(N-1)/2
+        double average = 3.1415 + (N - 1.0) * 0.5;
+        assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);
+
+        // Type: long
+        // 0, 1, ..., N-1
+        // sum = N*(N-1)/2
+        // average = sum/N = (N-1)/2
+        assertEquals(0.5 * (N - 1), collection.average(AllJavaTypes.FIELD_LONG), 0.0001);
+
+        // Type: float; b = 1.234567
+        // b, b+1, ..., b+i, ..., b+N-1
+        // sum = b*N + N*(N-1)/2
+        // average = sum/N = b + (N-1)/2
+        assertEquals(1.234567 + 0.5 * (N - 1.0), collection.average(AllJavaTypes.FIELD_FLOAT), 0.0001);
+    }
+
+    // Test average on empty columns
+    @Test
+    public void avg_emptyNonNullFields() {
+        OrderedRealmCollection<NullTypes> resultList = createEmptyCollection(realm, collectionClass);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_INTEGER_NOT_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_FLOAT_NOT_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NOT_NULL), 0d);
+    }
+
+    // Test average on nullable rows with all null values
+    @Test
+    public void avg_emptyNullFields() {
+        OrderedRealmCollection<NullTypes> resultList = createEmptyCollection(realm, collectionClass);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    // Test average on nullable rows with partial null values
+    @Test
+    public void avg_partialNullRows() {
+        OrderedRealmCollection<NullTypes> resultList = createPartialNullRowsForNumericTesting(realm, collectionClass);
+        assertEquals(0.5d, resultList.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(1.0d, resultList.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(1.5d, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    @Test
+    public void maxDate() {
+        assertEquals(new Date(YEAR_MILLIS * 20 * 4), collection.maxDate(AllJavaTypes.FIELD_DATE));
+    }
+
+    @Test
+    public void minDate() {
+        assertEquals(new Date(YEAR_MILLIS * 20 * -5), collection.minDate(AllJavaTypes.FIELD_DATE));
+    }
+
+    @Test
+    public void realmMethods_invalidFieldNames() {
+        String[] fieldNames = new String[] {
+                null, "", "foo", AllJavaTypes.FIELD_STRING + ".foo", TestHelper.getRandomString(65)
+        };
+
+        for (RealmCollectionMethod realmMethod : RealmCollectionMethod.values()) {
+            for (String fieldName : fieldNames) {
+                try {
+                    switch (realmMethod) {
+                        case MIN: collection.min(fieldName); break;
+                        case MAX: collection.max(fieldName); break;
+                        case SUM: collection.sum(fieldName); break;
+                        case AVERAGE: collection.average(fieldName); break;
+                        case MIN_DATE: collection.minDate(fieldName); break;
+                        case MAX_DATE: collection.maxDate(fieldName); break;
+
+                        // These methods doesn't take any arguments.
+                        // Just skip them.
+                        case WHERE:
+                        case DELETE_ALL_FROM_REALM:
+                        case IS_VALID:
+                            continue;
+
+                        default:
+                            fail("Unknown method: " + realmMethod);
+
+                    }
+                    fail(realmMethod + " did not throw an exception for input: " + fieldName);
+                } catch (IllegalArgumentException ignored) {
+                }
+            }
+        }
+    }
+
+    @Test
+    public void realmMethods_invalidFieldType() {
+        String fieldName = AllJavaTypes.FIELD_STRING;
+        for (RealmCollectionMethod realmMethod : RealmCollectionMethod.values()) {
+            try {
+                switch (realmMethod) {
+                    case MIN: collection.min(fieldName); break;
+                    case MAX: collection.max(fieldName); break;
+                    case SUM: collection.sum(fieldName); break;
+                    case AVERAGE: collection.average(fieldName); break;
+                    case MIN_DATE: collection.minDate(fieldName); break;
+                    case MAX_DATE: collection.maxDate(fieldName); break;
+
+                    // These methods doesn't take any arguments.
+                    // Just skip them.
+                    case WHERE:
+                    case DELETE_ALL_FROM_REALM:
+                    case IS_VALID:
+                        continue;
+
+                    default:
+                        fail("Unknown method: " + realmMethod);
+
+                }
+                fail(realmMethod + " did not throw an exception for input: " + fieldName);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void deleteAllFromRealm() {
+        // If we have a self-referencing collection, removing all objects will crash
+        // any following method. To avoid that scenario we make sure to use a collection
+        // without cycles.
+        int size = TEST_SIZE;
+        if (collectionClass == ManagedCollection.MANAGED_REALMLIST) {
+            RealmList list = (RealmList) collection;
+            realm.beginTransaction();
+            list.remove(0); // Break the cycle
+            realm.commitTransaction();
+            size = TEST_SIZE - 1;
+        }
+
+        assertEquals(size, collection.size());
+        realm.beginTransaction();
+        assertTrue(collection.deleteAllFromRealm());
+        realm.commitTransaction();
+        assertEquals(0, collection.size());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void deleteAllFromRealm_outsideTransaction() {
+        collection.deleteAllFromRealm();
+    }
+
+    @Test
+    public void deleteAllFromRealm_emptyList() {
+        OrderedRealmCollection<NullTypes> collection = createEmptyCollection(realm, collectionClass);
+
+        realm.beginTransaction();
+        assertFalse(collection.deleteAllFromRealm());
+        realm.commitTransaction();
+        assertEquals(0, collection.size());
+    }
+
+    @Test
+    public void deleteAllFromRealm_invalidList() {
+        realm.close();
+        try {
+            collection.deleteAllFromRealm();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void isLoaded() {
+        // RealmCollections are currently always loaded. Only exception is RealmResults.
+        // See RealmResultsTests for extended tests on this.
+        assertTrue(collection.isLoaded());
+    }
+
+    @Test
+    public void load() {
+        // RealmCollections are currently always loaded, so this just returns true. Only exception is RealmResults.
+        // See RealmResultsTests for extended tests on this.
+        assertTrue(collection.load());
+    }
+
+    @Test
+    public void isValid() {
+        assertTrue(collection.isValid());
+    }
+
+    @Test
+    public void isValid_realmClosed() {
+        realm.close();
+        assertFalse(collection.isValid());
+    }
+
+    @Test
+    public void contains_deletedRealmObject() {
+        AllJavaTypes obj = collection.iterator().next();
+        realm.beginTransaction();
+        obj.deleteFromRealm();
+        realm.commitTransaction();
+
+        assertFalse(collection.contains(obj));
+    }
+
+    @Test
+    public void equals_sameRealmObjectsDifferentCollection() {
+        assertTrue(collection.equals(createCollection(collectionClass)));
+    }
+
+    // Test all methods that mutate data throw correctly if not inside an transaction.
+    // Due to implementation details both UnsupportedOperation and IllegalState is accepted at this level
+    @Test
+    public void mutableMethodsOutsideTransactions() {
+        for (CollectionMutatorMethod method : CollectionMutatorMethod.values()) {
+
+            // Define expected exception
+            Class<? extends Throwable> expected = IllegalStateException.class;
+            if (collectionClass == ManagedCollection.REALMRESULTS) {
+                switch (method) {
+                    case ADD_OBJECT:
+                    case ADD_ALL_OBJECTS:
+                    case CLEAR:
+                    case REMOVE_OBJECT:
+                    case REMOVE_ALL:
+                    case RETAIN_ALL:
+                        expected = UnsupportedOperationException.class;
+                }
+            }
+
+            try {
+                switch (method) {
+                    case DELETE_ALL: collection.deleteAllFromRealm(); break;
+                    case ADD_OBJECT: collection.add(new AllJavaTypes());
+                    case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes())); break;
+                    case CLEAR: collection.clear(); break;
+                    case REMOVE_OBJECT: collection.remove(new AllJavaTypes()); break;
+                    case REMOVE_ALL: collection.removeAll(Collections.singletonList(new AllJavaTypes())); break;
+                    case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllJavaTypes())); break;
+                }
+                fail("Unknown method or it failed to throw: " + method);
+            } catch (Throwable t) {
+                if (!t.getClass().equals(expected)) {
+                    fail(method + " didn't throw the expected exception. Was: " + t + ", expected: " + expected);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
+        for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
+            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+        }
+        for (CollectionMethod method : CollectionMethod.values()) {
+            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+        }
+    }
+
+    private boolean runMethodOnWrongThread(final RealmCollectionMethod method) throws ExecutionException, InterruptedException {
+        realm.beginTransaction();
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                try {
+                    switch (method) {
+                        case WHERE: collection.where(); break;
+                        case MIN: collection.min(AllJavaTypes.FIELD_LONG); break;
+                        case MAX: collection.min(AllJavaTypes.FIELD_LONG); break;
+                        case SUM: collection.sum(AllJavaTypes.FIELD_LONG); break;
+                        case AVERAGE: collection.average(AllJavaTypes.FIELD_LONG); break;
+                        case MIN_DATE: collection.minDate(AllJavaTypes.FIELD_DATE); break;
+                        case MAX_DATE: collection.maxDate(AllJavaTypes.FIELD_DATE); break;
+                        case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
+                        case IS_VALID: collection.isValid(); break;
+                    }
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                }
+            }
+        });
+        Boolean result = future.get();
+        realm.cancelTransaction();
+        return result;
+    }
+
+    private boolean runMethodOnWrongThread(final CollectionMethod method) throws ExecutionException, InterruptedException {
+        realm.beginTransaction();
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+
+                // Define expected exception
+                Class<? extends Throwable> expected = IllegalStateException.class;
+                if (collectionClass == ManagedCollection.REALMRESULTS) {
+                    switch (method) {
+                        case ADD_OBJECT:
+                        case ADD_ALL_OBJECTS:
+                        case CLEAR:
+                        case REMOVE_OBJECT:
+                        case REMOVE_ALL:
+                        case RETAIN_ALL:
+                            expected = UnsupportedOperationException.class;
+                    }
+                }
+
+                try {
+                    switch (method) {
+                        case ADD_OBJECT: collection.add(new AllJavaTypes()); break;
+                        case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes())); break;
+                        case CLEAR: collection.clear(); case CONTAINS:
+                        case CONTAINS_ALL: collection.containsAll(Collections.singletonList(new AllJavaTypes())); break;
+                        case EQUALS: collection.equals(createCollection(collectionClass)); break;
+                        case HASHCODE:
+                            //noinspection ResultOfMethodCallIgnored
+                            collection.hashCode();
+                            break;
+                        case IS_EMPTY: collection.isEmpty(); break;
+                        case ITERATOR: return true; // Creating an iterator should be safe. Accessing it will fail, but tested elsewhere.
+                        case REMOVE_OBJECT: collection.remove(new AllJavaTypes()); break;
+                        case REMOVE_ALL: collection.removeAll(Collections.singletonList(new AllJavaTypes())); break;
+                        case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllJavaTypes())); break;
+                        case SIZE: collection.size(); break;
+                        case TO_ARRAY: collection.toArray(); break;
+                        case TO_ARRAY_INPUT: collection.toArray(new Object[collection.size()]); break;
+                    }
+                    return false;
+                } catch (Throwable t) {
+                    if (!t.getClass().equals(expected)) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        });
+        Boolean result = future.get();
+        realm.cancelTransaction();
+        return result;
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
new file mode 100644
index 0000000000..778d6b76c2
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.util.Pair;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or un-managed.
+ *
+ * Methods tested in this class:
+ *
+ * # RealmOrderedCollection
+ *
+ * + E first()
+ * + E last()
+ * - void sort(String field)
+ * - void sort(String field, Sort sortOrder)
+ * - void sort(String field1, Sort sortOrder1, String field2, Sort sortOrder2)
+ * - void sort(String[] fields, Sort[] sortOrders)
+ * - void deleteFromRealm(int location)
+ * - void deleteFirstFromRealm()
+ * - void deleteLastFromRealm();
+ *
+ * # List
+ *
+ *  - void add(int location, E object);
+ *  - boolean addAll(int location, Collection<? extends E> collection);
+ *  + E get(int location);
+ *  + int indexOf(Object object);
+ *  + int lastIndexOf(Object object);
+ *  - ListIterator<E> listIterator();
+ *  - ListIterator<E> listIterator(int location);
+ *  - E remove(int location);
+ *  - E set(int location, E object);
+ *  + List<E> subList(int start, int end);
+ *
+ * # RealmCollection
+ *
+ * - RealmQuery<E> where();
+ * - Number min(String fieldName);
+ * - Number max(String fieldName);
+ * - Number sum(String fieldName);
+ * - double average(String fieldName);
+ * - Date maxDate(String fieldName);
+ * - Date minDate(String fieldName);
+ * - void deleteAllFromRealm();
+ * - boolean isLoaded();
+ * - boolean load();
+ * - boolean isValid();
+ * - BaseRealm getRealm();
+ *
+ * # Collection
+ *
+ * - public boolean add(E object);
+ * - public boolean addAll(Collection<? extends E> collection);
+ * - public void deleteAll();
+ * - public boolean contains(Object object);
+ * - public boolean containsAll(Collection<?> collection);
+ * - public boolean equals(Object object);
+ * - public int hashCode();
+ * - public boolean isEmpty();
+ * - public Iterator<E> iterator();
+ * - public boolean remove(Object object);
+ * - public boolean removeAll(Collection<?> collection);
+ * - public boolean retainAll(Collection<?> collection);
+ * - public int size();
+ * - public Object[] toArray();
+ * - public <T> T[] toArray(T[] array);
+ *
+ * @see RealmCollectionTests
+ * @see ManagedRealmCollectionTests
+ * @see UnManagedRealmCollectionTests
+ */
+@RunWith(Parameterized.class)
+public class OrderedRealmCollectionTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private final CollectionClass collectionClass;
+    private Realm realm;
+    private OrderedRealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<CollectionClass> data() {
+        return Arrays.asList(CollectionClass.values());
+    }
+
+    public OrderedRealmCollectionTests(CollectionClass collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        collection = createCollection(realm, collectionClass);
+    }
+
+    private OrderedRealmCollection<AllJavaTypes> createCollection(Realm realm, CollectionClass collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                populateRealm(realm, TEST_SIZE);
+                return realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, 0)
+                        .findFirst()
+                        .getFieldList();
+
+            case UNMANAGED_REALMLIST:
+                return populateInMemoryList(TEST_SIZE);
+
+            case REALMRESULTS:
+                populateRealm(realm, TEST_SIZE);
+                return realm.allObjects(AllJavaTypes.class);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    private OrderedRealmCollection<AllJavaTypes> createEmptyCollection(Realm realm, CollectionClass collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                return realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, 1)
+                        .findFirst()
+                        .getFieldList();
+
+            case UNMANAGED_REALMLIST:
+                return new RealmList<AllJavaTypes>();
+
+            case REALMRESULTS:
+                return realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, -1).findAll();
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    private Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>> createCollectionWithMultipleCopies(Realm realm, CollectionClass collectionClass) {
+
+        AllJavaTypes obj;
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                obj = realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, 1)
+                        .findFirst();
+                RealmList<AllJavaTypes> list = obj.getFieldList();
+                realm.beginTransaction();
+                list.add(obj);
+                realm.commitTransaction();
+                return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, list);
+
+            case UNMANAGED_REALMLIST:
+                obj = new AllJavaTypes(1);
+                return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, new RealmList<AllJavaTypes>(obj, obj));
+
+            case REALMRESULTS:
+                RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 1).findAll();
+                obj = result.first();
+                return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, result);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    @Test
+    public void first() {
+        assertEquals(collection.get(0), collection.first());
+    }
+
+    @Test
+    public void first_emptyCollection() {
+        collection = createEmptyCollection(realm, collectionClass);
+        try {
+            collection.first();
+            fail();
+        } catch (IndexOutOfBoundsException ignored) {
+        }
+    }
+
+    @Test
+    public void last() {
+        assertEquals(collection.get(TEST_SIZE - 1), collection.last());
+    }
+
+    @Test
+    public void last_emptyCollection() {
+        collection = createEmptyCollection(realm, collectionClass);
+        try {
+            collection.last();
+            fail();
+        } catch (IndexOutOfBoundsException ignored) {
+        }
+    }
+
+    @Test
+    public void get_validIndex() {
+        AllJavaTypes first = collection.get(0);
+        assertEquals(0, first.getFieldInt());
+
+        AllJavaTypes last = collection.get(TEST_SIZE - 1);
+        assertEquals(TEST_SIZE - 1, last.getFieldInt());
+    }
+
+    @Test
+    public void get_indexOutOfBounds() {
+        List<Integer> indexes = Arrays.asList(-1, TEST_SIZE, Integer.MAX_VALUE, Integer.MIN_VALUE);
+        for (Integer index : indexes) {
+            try {
+                collection.get(index);
+                fail(index +  " did not throw the expected Exception.");
+            } catch (IndexOutOfBoundsException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void indexOf() {
+        AllJavaTypes obj = collection.get(1);
+        assertEquals(1, collection.indexOf(obj));
+    }
+
+    @Test
+    public void indexOf_null() {
+        assertEquals(-1, collection.indexOf(null));
+    }
+
+    @Test
+    public void indexOf_objectNotInRealm() {
+        assertEquals(-1, collection.indexOf(new AllJavaTypes()));
+    }
+
+    @Test
+    public void lastIndexOf() {
+        Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>> data = createCollectionWithMultipleCopies(realm, collectionClass);
+        AllJavaTypes obj = data.first;
+        collection = data.second;
+        int lastIndex = collection.lastIndexOf(obj);
+        assertEquals(collection.size() - 1, lastIndex);
+    }
+
+    @Test
+    public void lastIndexOf_null() {
+        assertEquals(-1, collection.lastIndexOf(null));
+    }
+
+    @Test
+    public void lastIndexOf_objectNotInRealm() {
+        assertEquals(-1, collection.lastIndexOf(new AllJavaTypes()));
+    }
+
+    @Test
+    public void subList() {
+        List<AllJavaTypes> list = collection.subList(0, 5);
+        assertEquals(5, list.size());
+        assertEquals(list.get(0), collection.get(0));
+        assertEquals(list.get(4), collection.get(4));
+    }
+
+    @Test(expected = IndexOutOfBoundsException.class)
+    public void subList_invalidStartIndex() {
+        collection.subList(-1, TEST_SIZE);
+    }
+
+    @Test(expected = IndexOutOfBoundsException.class)
+    public void subList_invalidEnd() {
+        collection.subList(0, TEST_SIZE + 1);
+    }
+
+    // Check that all releveant methods throw a correct IndexOutOfBounds
+    @Test
+    public void methods_indexOutOfBounds() {
+        collection = createEmptyCollection(realm, collectionClass);
+
+        for (ListMethod method : ListMethod.values()) {
+            realm.beginTransaction();
+            try {
+                switch (method) {
+                    case ADD_INDEX: collection.add(1, new AllJavaTypes()); break;
+                    case ADD_ALL_INDEX: collection.addAll(1, Collections.singleton(new AllJavaTypes())); break;
+                    case GET_INDEX: collection.get(1); break;
+                    case LIST_ITERATOR_INDEX: collection.listIterator(1); break;
+                    case REMOVE_INDEX: collection.remove(1);
+                    case SET: collection.set(1, new AllJavaTypes());
+                    case SUBLIST: collection.subList(1, 2);
+
+                    // Cannot fail with IndexOutOfBounds
+                    case FIRST:
+                    case LAST:
+                    case INDEX_OF:
+                    case LAST_INDEX_OF:
+                    case LIST_ITERATOR:
+                        continue;
+                }
+                fail(method + " did not throw an exception");
+            } catch (IndexOutOfBoundsException ignored) {
+            } catch (UnsupportedOperationException ignored) {
+            } finally {
+                realm.cancelTransaction();
+            }
+        }
+
+        for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
+            realm.beginTransaction();
+            try {
+                switch (method) {
+                    case DELETE_INDEX: collection.deleteFromRealm(1); break;
+
+                    // Cannot fail with IndexOutOfBounds
+                    case DELETE_FIRST:
+                    case DELETE_LAST:
+                    case SORT:
+                    case SORT_FIELD:
+                    case SORT_2FIELDS:
+                    case SORT_MULTI:
+                        continue;
+                }
+                fail(method + " did not throw an exception");
+            } catch (IndexOutOfBoundsException ignored) {
+            } catch (UnsupportedOperationException ignored) {
+            } finally {
+                realm.cancelTransaction();
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
index 140eb49e29..f42ca7a48f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
@@ -109,7 +109,7 @@ public void testClearFromAdapter() {
         RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
 
         testRealm.beginTransaction();
-        realmAdapter.getRealmResults().clear();
+        realmAdapter.getRealmResults().deleteAllFromRealm();
         testRealm.commitTransaction();
 
         assertEquals(0, realmAdapter.getCount());
@@ -123,7 +123,7 @@ public void testRemoveFromAdapter() {
         RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
 
         testRealm.beginTransaction();
-        realmAdapter.getRealmResults().remove(0);
+        realmAdapter.getRealmResults().deleteFromRealm(0);
         testRealm.commitTransaction();
         assertEquals(TEST_DATA_SIZE - 1, realmAdapter.getCount());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index a76ebf06b7..f3d627702b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -232,7 +232,7 @@ public void primaryKey_isIndexed() {
     @Test
     public void namingConvention() {
         realm.beginTransaction();
-        realm.clear(AnnotationNameConventions.class);
+        realm.delete(AnnotationNameConventions.class);
         AnnotationNameConventions anc1 = realm.createObject(AnnotationNameConventions.class);
         anc1.setHasObject(true);
         anc1.setId_object(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index f6c1790534..9d4a2b3726 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -18,6 +18,8 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Rule;
@@ -32,12 +34,14 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.instrumentation.MockActivityManager;
+import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.internal.log.RealmLog;
 import io.realm.proxy.HandlerProxy;
 import io.realm.rule.RunInLooperThread;
@@ -59,6 +63,9 @@
     public final RunInLooperThread looperThread = new RunInLooperThread();
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
 
     // ****************************
     // ****  Async transaction  ***
@@ -455,7 +462,7 @@ public boolean onInterceptInMessage(int what) {
                         if (intercepts == 1) {
                             // We advance the Realm so we can simulate a retry
                             realm.beginTransaction();
-                            realm.clear(AllTypes.class);
+                            realm.delete(AllTypes.class);
                             realm.commitTransaction();
                         }
                 }
@@ -911,7 +918,7 @@ public boolean onInterceptInMessage(int what) {
                         if (intercepts == 1) {
                             // we advance the Realm so we can simulate a retry
                             realm.beginTransaction();
-                            realm.clear(AllTypes.class);
+                            realm.delete(AllTypes.class);
                             AllTypes object = realm.createObject(AllTypes.class);
                             object.setColumnString("The Endless River");
                             object.setColumnLong(5);
@@ -1008,7 +1015,7 @@ public boolean onInterceptInMessage(int what) {
                             // We advance the Realm so we can simulate a retry before listeners are
                             // called.
                             realm.beginTransaction();
-                            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 8).findFirst().removeFromRealm();
+                            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 8).findFirst().deleteFromRealm();
                             realm.commitTransaction();
                         }
                         break;
@@ -1809,14 +1816,143 @@ public void run() {
         }.start();
     }
 
+    // Test case for https://github.com/realm/realm-java/issues/2417
+    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    @Test
+    @UiThreadTest
+    public void badVersion_findAll() throws NoSuchFieldException, IllegalAccessException {
+        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        RealmConfiguration config  = configFactory.createConfiguration();
+        Realm realm = Realm.getInstance(config);
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        boolean result = realm.where(AllTypes.class).findAllAsync().load();
+        try {
+            assertFalse(result);
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Test case for https://github.com/realm/realm-java/issues/2417
+    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    @Test
+    @UiThreadTest
+    public void badVersion_findAllSortedAsync() throws NoSuchFieldException, IllegalAccessException {
+        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        RealmConfiguration config = configFactory.createConfiguration();
+        Realm realm = Realm.getInstance(config);
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.where(AllTypes.class)
+                .findAllSortedAsync(AllTypes.FIELD_STRING, Sort.ASCENDING, AllTypes.FIELD_LONG, Sort.DESCENDING)
+                .load();
+        realm.close();
+    }
+
+    // Test case for https://github.com/realm/realm-java/issues/2417
+    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    @Test
+    @UiThreadTest
+    public void badVersion_distinct() throws NoSuchFieldException, IllegalAccessException {
+        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        RealmConfiguration config = configFactory.createConfiguration();
+        Realm realm = Realm.getInstance(config);
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.deleteAll();
+            }
+        });
+        realm.where(AllJavaTypes.class)
+                .distinctAsync(AllJavaTypes.FIELD_STRING)
+                .load();
+
+        realm.close();
+    }
+
+    // Test case for https://github.com/realm/realm-java/issues/2417
+    // Ensure that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    @Test
+    @RunTestInLooperThread
+    public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAccessException {
+        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        Realm realm = looperThread.realm;
+
+        // 1. Make sure that async query is not started
+        final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
+        result.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // 4. The commit in #2, should result in a refresh being triggered, which means this callback will
+                // be notified once the updated async queries has run.
+                // with the correct
+                assertTrue(result.isValid());
+                assertTrue(result.isLoaded());
+                assertEquals(1, result.size());
+                looperThread.testComplete();
+            }
+        });
+
+        // 2. Advance the calle Realm, invalidating the version in the handover object
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        // 3. The async query should now (hopefully) fail with a BadVersion
+        result.load();
+    }
 
     // *** Helper methods ***
 
     private void populateTestRealm(final Realm testRealm, int objects) {
         testRealm.setAutoRefresh(false);
         testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        testRealm.deleteAll();
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
new file mode 100644
index 0000000000..7669919f01
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -0,0 +1,232 @@
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.Dog;
+import io.realm.entities.NullTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test class for all methods part of the the {@link RealmCollection} interface.
+ * This class only tests methods that have the same behavior no matter if the collection is managed or not.
+ *
+ * Methods tested in this class:
+ *
+ * # RealmCollection
+ *
+ * - RealmQuery<E> where();
+ * - Number min(String fieldName);
+ * - Number max(String fieldName);
+ * - Number sum(String fieldName);
+ * - double average(String fieldName);
+ * - Date maxDate(String fieldName);
+ * - Date minDate(String fieldName);
+ * - void deleteAllFromRealm();
+ * - boolean isLoaded();
+ * - boolean load();
+ * - boolean isValid();
+ * - BaseRealm getRealm();
+ *
+ * # Collection
+ *
+ * - public boolean add(E object);
+ * - public boolean addAll(Collection<? extends E> collection);
+ * - public void deleteAll();
+ * + public boolean contains(Object object);
+ * + public boolean containsAll(Collection<?> collection);
+ * + public boolean equals(Object object);
+ * + public int hashCode();
+ * + public boolean isEmpty();
+ * - public Iterator<E> iterator();
+ * + public boolean remove(Object object);
+ * + public boolean removeAll(Collection<?> collection);
+ * + public boolean retainAll(Collection<?> collection);
+ * + public int size();
+ * + public Object[] toArray();
+ * + public <T> T[] toArray(T[] array);
+ **
+ * @see ManagedRealmCollectionTests
+ * @see UnManagedRealmCollectionTests
+ */
+@RunWith(Parameterized.class)
+public class RealmCollectionTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private final CollectionClass collectionClass;
+    private Realm realm;
+    private RealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<CollectionClass> data() {
+        return Arrays.asList(CollectionClass.values());
+    }
+
+    public RealmCollectionTests(CollectionClass collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        collection = createCollection(collectionClass);
+    }
+
+    private RealmCollection<AllJavaTypes> createCollection(CollectionClass collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                populateRealm(realm, TEST_SIZE);
+                return realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, 0)
+                        .findFirst()
+                        .getFieldList();
+
+            case UNMANAGED_REALMLIST:
+                return populateInMemoryList(TEST_SIZE);
+
+            case REALMRESULTS:
+                populateRealm(realm, TEST_SIZE);
+                return realm.allObjects(AllJavaTypes.class);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, CollectionClass collectionClass) {
+        switch (collectionClass) {
+            case MANAGED_REALMLIST:
+                realm.beginTransaction();
+                NullTypes obj = realm.createObject(NullTypes.class);
+                realm.commitTransaction();
+                return obj.getFieldListNull();
+
+            case UNMANAGED_REALMLIST:
+                return new RealmList<NullTypes>();
+
+            case REALMRESULTS:
+                return realm.where(NullTypes.class).findAll();
+        }
+
+        throw new AssertionError("Unknown collection: " + collectionClass);
+    }
+
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    @Test
+    public void contains() {
+        AllJavaTypes obj = collection.iterator().next();
+        assertTrue(collection.contains(obj));
+    }
+
+    @Test
+    public void contains_realmObjectFromOtherRealm() {
+        Realm realm2 = Realm.getInstance(configFactory.createConfiguration("other_realm.realm"));
+        populateRealm(realm2, TEST_SIZE);
+        AllJavaTypes otherRealmObj = realm2.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst();
+
+        try {
+            assertFalse(collection.contains(otherRealmObj));
+        } finally {
+            realm2.close();
+        }
+    }
+
+    @Test
+    public void contains_wrongType() {
+        //noinspection SuspiciousMethodCalls
+        assertFalse(collection.contains(new Dog()));
+    }
+
+    @Test
+    public void contains_null() {
+        assertFalse(collection.contains(null));
+    }
+
+    @Test
+    public void containsAll() {
+        Iterator<AllJavaTypes> it = collection.iterator();
+        List<AllJavaTypes> list = Arrays.asList(it.next(), it.next());
+        assertTrue(collection.containsAll(list));
+    }
+
+    @Test
+    public void containsAll_emptyInput() {
+        assertTrue(collection.containsAll(Collections.emptyList()));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void containsAll_nullInput() {
+        collection.containsAll(null);
+    }
+
+    @Test
+    public void equals() {
+        ArrayList<AllJavaTypes> newList = new ArrayList<AllJavaTypes>();
+        newList.addAll(collection);
+
+        assertTrue(collection.equals(collection));
+        assertTrue(collection.equals(newList));
+        assertFalse(collection.equals(Collections.emptyList()));
+        assertFalse(collection.equals(null));
+    }
+
+    @Test
+    public void hashCode_allObjects() {
+        ArrayList<AllJavaTypes> newList = new ArrayList<AllJavaTypes>();
+        newList.addAll(collection);
+
+        assertTrue(collection.hashCode() == newList.hashCode());
+        assertFalse(collection.hashCode() == Collections.emptyList().hashCode());
+    }
+
+    @Test
+    public void isEmpty() {
+        assertFalse(collection.isEmpty());
+        RealmCollection<NullTypes> collection = createEmptyCollection(realm, collectionClass);
+        assertTrue(collection.isEmpty());
+    }
+
+    @Test
+    public void size() {
+        assertEquals(TEST_SIZE, collection.size());
+    }
+
+    @Test
+    public void toArray() {
+        Object[] array = collection.toArray();
+        assertEquals(TEST_SIZE, array.length);
+        assertEquals(collection.iterator().next(), array[0]);
+    }
+
+    @Test
+    public void toArray_inputArray() {
+        AllJavaTypes[] array = new AllJavaTypes[collection.size()];
+        collection.toArray(array);
+        assertEquals(TEST_SIZE, array.length);
+        assertEquals(collection.iterator().next(), array[0]);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 4d93694fb6..87e4106c42 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 import android.test.MoreAsserts;
 
@@ -43,15 +45,22 @@
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
 import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rx.RealmObservableFactory;
 import io.realm.rx.RxObservableFactory;
 import rx.Observable;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.mock;
 
 @RunWith(AndroidJUnit4.class)
 public class RealmConfigurationTests {
@@ -352,6 +361,16 @@ public void equals() {
         assertTrue(config1.equals(config2));
     }
 
+    @Test
+    public void equalsWhenRxJavaUnavailable() {
+        // test for https://github.com/realm/realm-java/issues/2416
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        TestHelper.emulateRxJavaUnavailable(config1);
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        TestHelper.emulateRxJavaUnavailable(config2);
+        assertTrue(config1.equals(config2));
+    }
+
     @Test
     public void hashCode_Test() {
         RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
@@ -384,6 +403,23 @@ public void hashCode_withCustomModules() {
         assertEquals(config1.hashCode(), config2.hashCode());
     }
 
+    @Test
+    public void hashCode_withDifferentRxObservableFactory() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .rxFactory(new RealmObservableFactory())
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .rxFactory(new RealmObservableFactory() {
+                    @Override
+                    public int hashCode() {
+                        return super.hashCode() + 1;
+                    }
+                })
+                .build();
+
+        assertNotEquals(config1.hashCode(), config2.hashCode());
+    }
+
     @Test
     public void equals_configurationsReturnCachedRealm() {
         Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
@@ -644,4 +680,103 @@ public void rxFactory() {
         assertNotNull(configuration2.getRxFactory());
         assertFalse(configuration2.getRxFactory() == dummyFactory);
     }
+
+    @Test
+    public void initialDataTransactionEqual() {
+        final Realm.Transaction transaction = new Realm.Transaction() {
+            @Override
+            public void execute(final Realm realm) {
+            }
+        };
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .initialData(transaction)
+                .build();
+
+        assertEquals(transaction, configuration.getInitialDataTransaction());
+    }
+
+    @Test
+    public void initialDataTransactionNull() {
+        assertNull(defaultConfig.getInitialDataTransaction());
+
+        realm = Realm.getInstance(defaultConfig);
+        assertTrue(realm.isEmpty());
+    }
+
+    @Test
+    public void initialDataTransactionNotNull() {
+        // Remove default instance
+        Realm.deleteRealm(defaultConfig);
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(final Realm realm) {
+                        realm.createObject(AllTypes.class);
+                        realm.createObject(Owner.class).setCat(realm.createObject(Cat.class));
+                    }
+                }).build();
+
+        realm = Realm.getInstance(configuration);
+
+        // First time check for initial data
+        assertEquals(1, realm.where(AllTypes.class).count());
+        assertEquals(1, realm.where(Owner.class).count());
+        assertEquals(1, realm.where(Cat.class).count());
+
+        realm.beginTransaction();
+        realm.delete(AllTypes.class);
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(AllTypes.class).count());
+
+        realm.close();
+        realm = Realm.getInstance(configuration);
+        // Check if there is still the same data
+        assertEquals(0, realm.where(AllTypes.class).count());
+        assertEquals(1, realm.where(Owner.class).count());
+        assertEquals(1, realm.where(Cat.class).count());
+    }
+
+    @Test
+    public void initialDataTransactionExecutionCount() {
+        // Remove default instance
+        Realm.deleteRealm(defaultConfig);
+
+        Realm.Transaction transaction = mock(Realm.Transaction.class);
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .initialData(transaction)
+                .build();
+
+        realm = Realm.getInstance(configuration);
+        realm.close();
+        verify(transaction, times(1)).execute(realm);
+
+        realm = Realm.getInstance(configuration);
+        realm.close();
+        verify(transaction, never()).execute(realm);
+    }
+
+    @Test
+    public void initialDataTransactionAssetFile() throws IOException {
+        // Remove default instance
+        Realm.deleteRealm(defaultConfig);
+
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+        configFactory.copyRealmFromAssets(context, "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        assertTrue(new File(configFactory.getRoot(), Realm.DEFAULT_REALM_NAME).exists());
+
+        Realm.Transaction transaction = mock(Realm.Transaction.class);
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                // Just reuse existing file and set right schema
+                .schemaVersion(0)
+                .schema(AllTypes.class)
+                .initialData(transaction)
+                .build();
+
+        realm = Realm.getInstance(configuration);
+        realm.close();
+        verify(transaction, never()).execute(realm);
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index fb03e29c8f..1d44baa256 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -452,6 +452,24 @@ public void createAllFromJson_stringArrayNull() {
         assertEquals(0, realm.allObjects(Dog.class).size());
     }
 
+    @Test
+    public void createAllFromJson_stringEmptyArray() {
+        realm.beginTransaction();
+        realm.createAllFromJson(Dog.class, "");
+        realm.commitTransaction();
+        assertEquals(0, realm.allObjects(Dog.class).size());
+    }
+
+    @Test
+    public void createAllFromJson_stringNullClass() {
+        realm.beginTransaction();
+        realm.createAllFromJson(null, "[{ name: \"Foo\" }]");
+        realm.commitTransaction();
+
+        assertEquals(0, realm.allObjects(Dog.class).size());
+    }
+
+
     @Test
     public void createAllFromJson_streamNull() throws IOException {
         realm.createAllFromJson(AllTypes.class, (InputStream) null);
@@ -592,6 +610,36 @@ public void createObjectFromJson_streamNoValues() throws IOException {
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
+    @Test
+    public void createObjectFromJson_streamNullClass() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "array.json");
+        realm.beginTransaction();
+        assertNull(realm.createObjectFromJson(null, in));
+        realm.commitTransaction();
+        in.close();
+    }
+
+    @Test
+    public void createObjectFromJson_streamNullJson() throws IOException  {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_invalid.json");
+        realm.beginTransaction();
+        try {
+            realm.createObjectFromJson(AnnotationTypes.class, in);
+            fail();
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+            in.close();
+        }
+    }
+
+    @Test
+    public void createObjectFromJson_streamNullInputStream() throws IOException  {
+        realm.beginTransaction();
+        assertNull(realm.createObjectFromJson(AnnotationTypes.class, (InputStream) null));
+        realm.commitTransaction();
+    }
+
     /**
      * Test update a existing object with JSON stream. Only primary key in JSON.
      * No value should be changed.
@@ -631,6 +679,102 @@ public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
+    @Test
+    public void createOrUpdateObjectFromJson_streamNullClass() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_primary_key_field_only.json");
+        realm.beginTransaction();
+        assertNull(realm.createOrUpdateObjectFromJson(null, in));
+        realm.commitTransaction();
+        in.close();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_streamInvalidJson() throws IOException {
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        realm.beginTransaction();
+        realm.copyToRealm(obj);
+        realm.commitTransaction();
+
+        InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_invalid.json");
+        realm.beginTransaction();
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
+            fail();
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+            in.close();
+        }
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_streamNoPrimaryKeyThrows() throws IOException {
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypes.class, new TestHelper.StubInputStream());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_streamInvalidJSonCurlyBracketThrows() throws IOException {
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{"));
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_streamIgnoreUnsetProperties() throws IOException {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+        realm.commitTransaction();
+
+        // No-op as no properties should be updated
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{ \"columnLong\":1 }"));
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_inputStream() throws IOException {
+        realm.beginTransaction();
+
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        obj.setColumnString("Foo");
+        realm.copyToRealm(obj);
+
+        InputStream in = TestHelper.stringToStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
+        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals("bar", newObj.getColumnString());
+    }
+
+    /**
+     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail)
+     */
+    @Test
+    public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
+        InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
+        realm.beginTransaction();
+        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, stream);
+        realm.commitTransaction();
+
+        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
+        assertEquals(2, owners.size());
+        assertEquals(1, owners.get(1).getId());
+        assertEquals("bar", owners.get(1).getName());
+    }
+
     // Test update a existing object with JSON object with only primary key.
     // No value should be changed.
     @Test
@@ -668,36 +812,87 @@ public void createOrUpdateObjectFromJson_objectNullValues() throws IOException {
     }
 
     @Test
-    public void createOrUpdateObject_noPrimaryKeyThrows() {
+    public void createOrUpdateObjectFromJson_stringNoPrimaryKeyThrows() throws IOException {
         try {
-            realm.createOrUpdateObjectFromJson(AllTypes.class, new JSONObject());
+            realm.createOrUpdateObjectFromJson(AllTypes.class, "{}");
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
-    public void createOrUpdateObjectFromJson_streamNoPrimaryKeyThrows() throws IOException {
-        try {
-            realm.createOrUpdateObjectFromJson(AllTypes.class, new TestHelper.StubInputStream());
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+    public void createOrUpdateObjectFromJson_objectIgnoreUnsetProperties() throws IOException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
+        realm.commitTransaction();
+
+        // No-op as no properties should be updated
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1 }");
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
     }
 
     @Test
-    public void createOrUpdateAllFromJson_streamInvalidJSonCurlyBracketThrows() throws IOException {
+    public void createOrUpdateObjectFromJson_inputString() throws IOException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
+
+        realm.beginTransaction();
+        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals("bar", newObj.getColumnString());
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_inputStringNullClass() throws IOException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
+
+        realm.beginTransaction();
+        assertNull(realm.createOrUpdateObjectFromJson(null, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }"));
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_nullInputString() throws IOException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
+
+        realm.beginTransaction();
+        assertNull(realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, (String) null));
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_emptyInputString() throws IOException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
+
+        realm.beginTransaction();
+        assertNull(realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, ""));
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_invalidInputString() throws IOException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
+
+        realm.beginTransaction();
         try {
-            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{"));
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1,");
             fail();
         } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
         }
     }
 
     @Test
-    public void createOrUpdateObjectFromJson_stringNoPrimaryKeyThrows() throws IOException {
+    public void createOrUpdateObjectFromJson_noPrimaryKeyThrows() {
         try {
-            realm.createOrUpdateObjectFromJson(AllTypes.class, "{}");
+            realm.createOrUpdateObjectFromJson(AllTypes.class, new JSONObject());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -705,13 +900,9 @@ public void createOrUpdateObjectFromJson_stringNoPrimaryKeyThrows() throws IOExc
 
     @Test
     public void createOrUpdateObjectFromJson_withJsonObject() throws JSONException {
-        realm.beginTransaction();
-
-        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-        obj.setColumnLong(1);
-        obj.setColumnString("Foo");
-        realm.copyToRealm(obj);
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
 
+        realm.beginTransaction();
         JSONObject json = new JSONObject();
         json.put("columnLong", 1);
         json.put("columnString", "bar");
@@ -724,66 +915,62 @@ public void createOrUpdateObjectFromJson_withJsonObject() throws JSONException {
     }
 
     @Test
-    public void createOrUpdateObjectFromJson_objectIgnoreUnsetProperties() throws IOException {
-        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
-
-        realm.beginTransaction();
-        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
-        realm.commitTransaction();
+    public void createOrUpdateObjectFromJson_jsonObjectNullClass() throws JSONException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
 
-        // No-op as no properties should be updated
         realm.beginTransaction();
-        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1 }");
+        JSONObject json = new JSONObject();
+        json.put("columnLong", 1);
+        json.put("columnString", "bar");
+        assertNull(realm.createOrUpdateObjectFromJson(null, json));
         realm.commitTransaction();
 
-        assertAllTypesPrimaryKeyUpdated();
+        AllTypesPrimaryKey obj2 = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals("Foo", obj2.getColumnString());
     }
 
     @Test
-    public void createOrUpdateObjectFromJson_streamIgnoreUnsetProperties() throws IOException {
-        realm.beginTransaction();
-        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
-        realm.commitTransaction();
-
-        // No-op as no properties should be updated
+    public void createOrUpdateObjectFromJson_nullJsonObject() throws JSONException {
         realm.beginTransaction();
-        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{ \"columnLong\":1 }"));
+        assertNull(realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, (JSONObject) null));
         realm.commitTransaction();
-
-        assertAllTypesPrimaryKeyUpdated();
+        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
     }
 
     @Test
-    public void createOrUpdateObjectFromJson_inputStream() throws IOException {
-        realm.beginTransaction();
-
-        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-        obj.setColumnLong(1);
-        obj.setColumnString("Foo");
-        realm.copyToRealm(obj);
-
-        InputStream in = TestHelper.stringToStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
-        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
-        realm.commitTransaction();
+    public void createOrUpdateObjectFromJson_invalidJsonObject() throws JSONException {
+        TestHelper.populateSimpleAllTypesPrimaryKey(realm);
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals("bar", newObj.getColumnString());
+        realm.beginTransaction();
+        JSONObject json = new JSONObject();
+        json.put("columnLong", "A");
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
+            fail();
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+        }
+        AllTypesPrimaryKey obj2 = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals("Foo", obj2.getColumnString());
     }
 
+    /**
+     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail)
+     */
     @Test
-    public void createOrUpdateObjectFromJson_inputString() throws IOException {
+    public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
+        JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-
-        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-        obj.setColumnLong(1);
-        obj.setColumnString("Foo");
-        realm.copyToRealm(obj);
-
-        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
+        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, newObject);
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals("bar", newObj.getColumnString());
+        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
+        assertEquals(2, owners.size());
+        assertEquals(1, owners.get(1).getId());
+        assertEquals("bar", owners.get(1).getName());
     }
 
     @Test
@@ -795,6 +982,18 @@ public void createOrUpdateAllFromJson_jsonArrayNoPrimaryKeyThrows() {
         }
     }
 
+    @Test
+    public void createOrUpdateAllFromJson_jsonNullClass() {
+        realm.createOrUpdateAllFromJson(null, new JSONArray());
+        assertEquals(0, realm.allObjects(AllTypes.class).size());
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_jsonNullJson() {
+        realm.createOrUpdateAllFromJson(AllTypes.class, (JSONArray) null);
+        assertEquals(0, realm.allObjects(AllTypes.class).size());
+    }
+
     @Test
     public void createOrUpdateAllFromJson_streamNoPrimaryKeyThrows() throws IOException {
         try {
@@ -822,6 +1021,42 @@ public void createOrUpdateAllFromJson_stringNoPrimaryKeyThrows() throws IOExcept
         }
     }
 
+    @Test
+    public void createOrUpdateAllFromJson_inputStringNullClass() {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson((Class<AllTypesPrimaryKey>) null, "{ \"columnLong\" : 1 }");
+        realm.commitTransaction();
+        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_inputStringNullJson() {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, (String) null);
+        realm.commitTransaction();
+        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_inputStringEmptyJson() {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "");
+        realm.commitTransaction();
+        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_inputStringInvalidJson() {
+        realm.beginTransaction();
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1");
+            fail();
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+        }
+    }
+
     @Test
     public void createOrUpdateAllFromJson_jsonArray() throws JSONException, IOException {
         String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
@@ -1107,24 +1342,6 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
         }
     }
 
-    /**
-     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
-     * it to the default value (which can fail)
-     */
-    @Test
-    public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
-        JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
-        realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
-        realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, newObject);
-        realm.commitTransaction();
-
-        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
-        assertEquals(2, owners.size());
-        assertEquals(1, owners.get(1).getId());
-        assertEquals("bar", owners.get(1).getName());
-    }
-
     /**
      * Check that using createOrUpdateObject will set the primary key directly instead of first setting
      * it to the default value (which can fail)
@@ -1143,22 +1360,12 @@ public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObj
         assertEquals("bar", owners.get(1).getName());
     }
 
-    /**
-     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
-     * it to the default value (which can fail)
-     */
     @Test
-    public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
-        InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
+    public void createObjectFromJson_objectNullClass() throws JSONException {
+        JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
-        realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, stream);
+        assertNull(realm.createObjectFromJson(null, newObject));
         realm.commitTransaction();
-
-        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
-        assertEquals(2, owners.size());
-        assertEquals(1, owners.get(1).getId());
-        assertEquals("bar", owners.get(1).getName());
     }
 
     /**
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index f5d0e79933..1f8a17870f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -35,9 +35,9 @@ protected void setUp() {
         testRealm = Realm.getInstance(realmConfig);
 
         testRealm.beginTransaction();
-        testRealm.clear(Dog.class);
-        testRealm.clear(Cat.class);
-        testRealm.clear(Owner.class);
+        testRealm.delete(Dog.class);
+        testRealm.delete(Cat.class);
+        testRealm.delete(Owner.class);
 
         Dog dog1 = testRealm.createObject(Dog.class);
         dog1.setName("Pluto");
@@ -496,7 +496,7 @@ public void testLinkIsNull() {
         assertEquals(0, owners1.size());
 
         testRealm.beginTransaction();
-        testRealm.clear(Cat.class);
+        testRealm.delete(Cat.class);
         testRealm.commitTransaction();
 
         RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("cat").findAll();
@@ -508,7 +508,7 @@ public void testLinkIsNotNull() {
         assertEquals(1, owners1.size());
 
         testRealm.beginTransaction();
-        testRealm.clear(Cat.class);
+        testRealm.delete(Cat.class);
         testRealm.commitTransaction();
 
         RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("cat").findAll();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 5f9942429b..355468db5c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -25,13 +25,10 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.util.Arrays;
 import java.util.Collections;
-import java.util.concurrent.Callable;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Cat;
@@ -39,97 +36,85 @@
 import io.realm.entities.CyclicTypePrimaryKey;
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
-import io.realm.exceptions.RealmException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+/**
+ * Unit tests specific for RealmList that cannot be covered by {@link OrderedRealmCollectionTests},
+ * {@link ManagedRealmCollectionTests}, {@link UnManagedRealmCollectionTests} or {@link RealmCollectionTests}.
+ */
 @RunWith(AndroidJUnit4.class)
-public class RealmListTests {
+public class RealmListTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
 
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
     public ExpectedException thrown = ExpectedException.none();
 
-    private static final int TEST_OBJECTS = 10;
-    private Realm testRealm;
+    private Realm realm;
+    private RealmList<Dog> collection;
 
     @Before
     public void setUp() throws Exception {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
-        testRealm = Realm.getInstance(realmConfig);
+        realm = Realm.getInstance(realmConfig);
 
-        testRealm.beginTransaction();
-        Owner owner = testRealm.createObject(Owner.class);
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
         owner.setName("Owner");
-        for (int i = 0; i < TEST_OBJECTS; i++) {
-            Dog dog = testRealm.createObject(Dog.class);
+        for (int i = 0; i < TEST_SIZE; i++) {
+            Dog dog = realm.createObject(Dog.class);
             dog.setName("Dog " + i);
             owner.getDogs().add(dog);
         }
-        testRealm.commitTransaction();
+        realm.commitTransaction();
+        collection = owner.getDogs();
     }
 
     @After
     public void tearDown() throws Exception {
-        if (testRealm != null) {
-            testRealm.close();
+        if (realm != null) {
+            realm.close();
         }
     }
 
     private RealmList<Dog> createNonManagedDogList() {
         RealmList<Dog> list = new RealmList<Dog>();
-        for (int i = 0; i < TEST_OBJECTS; i++) {
+        for (int i = 0; i < TEST_SIZE; i++) {
             list.add(new Dog("Dog " + i));
         }
         return list;
     }
 
     private RealmList<Dog> createDeletedRealmList() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
 
-        testRealm.beginTransaction();
-        owner.removeFromRealm();
-        testRealm.commitTransaction();
+        realm.beginTransaction();
+        owner.deleteFromRealm();
+        realm.commitTransaction();
         return dogs;
     }
 
-    // Check that all methods work correctly on a empty RealmList
-    private void checkMethodsOnEmptyList(Realm realm, RealmList<Dog> list) {
-        realm.beginTransaction();
-        for (int i = 0; i < 4; i++) {
             //noinspection TryWithIdenticalCatches
-            try {
-                switch (i) {
-                    case 0: list.get(0); break;
-                    case 1: list.remove(0); break;
-                    case 2: list.set(0, new Dog()); break;
-                    case 3: list.move(0, 0); break;
-                    default: break;
-                }
-                fail();
-            } catch (IndexOutOfBoundsException ignored) {
-            } catch (RealmException ignored) {
-            }
-        }
-        realm.cancelTransaction();
-
-        assertEquals(0, list.size());
-        assertNull(list.first());
-        assertNull(list.last());
-    }
-
     /*********************************************************
-     * Non-Managed mode tests                                *
+     * Un-managed mode tests                                *
      *********************************************************/
 
+    @Test(expected = IllegalArgumentException.class)
+    public void constructor_nonManaged_null() {
+        AllTypes[] args = null;
+        //noinspection ConstantConditions
+        new RealmList<AllTypes>(args);
+    }
+
     @Test
     public void isValid_nonManagedMode() {
         //noinspection MismatchedQueryAndUpdateOfCollection
@@ -137,11 +122,6 @@ public void isValid_nonManagedMode() {
         assertFalse(list.isValid());
     }
 
-    @Test (expected = RealmException.class)
-    public void where_nonManagedMode() {
-        new RealmList<AllTypes>().where();
-    }
-
     @Test
     public void add_nonManagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
@@ -160,9 +140,9 @@ public void add_nullInNonManagedMode() {
     @Test
     public void add_managedObjectInNonManagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
-        testRealm.beginTransaction();
-        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
-        testRealm.commitTransaction();
+        realm.beginTransaction();
+        AllTypes managedAllTypes = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
         list.add(managedAllTypes);
 
         assertEquals(managedAllTypes, list.get(0));
@@ -179,17 +159,27 @@ public void add_standaloneObjectAtIndexInNonManagedMode() {
     }
 
     @Test
-    public void add_ManagedObjectAtIndexInNonManagedMode() {
+    public void add_managedObjectAtIndexInNonManagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
-        testRealm.beginTransaction();
-        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
-        testRealm.commitTransaction();
+        realm.beginTransaction();
+        AllTypes managedAllTypes = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
         list.add(0, managedAllTypes);
 
         assertEquals(managedAllTypes, list.get(0));
     }
 
+    @Test
+    public void add_objectAtIndexInManagedMode() {
+        realm.beginTransaction();
+        Dog obj = collection.get(0);
+        collection.add(0, new Dog("Dog 42"));
+        realm.commitTransaction();
+        assertEquals(obj.getName(), collection.get(1).getName());
+        assertEquals("Dog 42", collection.get(0).getName());
+    }
+
     @Test (expected = IllegalArgumentException.class)
     public void add_nullAtIndexInNonManagedMode() {
         new RealmList<AllTypes>().add(0, null);
@@ -207,18 +197,18 @@ public void set_nonManagedMode() {
 
     @Test
     public void set_managedMode() {
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         try {
-            RealmList<Dog> list = testRealm.createObject(Owner.class).getDogs();
-            Dog dog1 = testRealm.createObject(Dog.class);
+            RealmList<Dog> list = realm.createObject(Owner.class).getDogs();
+            Dog dog1 = realm.createObject(Dog.class);
             dog1.setName("dog1");
-            Dog dog2 = testRealm.createObject(Dog.class);
+            Dog dog2 = realm.createObject(Dog.class);
             dog2.setName("dog2");
             list.add(dog1);
             assertEquals(dog1, list.set(0, dog2));
             assertEquals(1, list.size());
         } finally {
-            testRealm.cancelTransaction();
+            realm.cancelTransaction();
         }
     }
 
@@ -235,9 +225,9 @@ public void set_nullInNonManagedMode() {
     public void set_managedObjectInNonManagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
-        testRealm.beginTransaction();
-        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
-        testRealm.commitTransaction();
+        realm.beginTransaction();
+        AllTypes managedAllTypes = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
         list.set(0, managedAllTypes);
 
         assertEquals(managedAllTypes, list.get(0));
@@ -261,30 +251,14 @@ public void remove_nonManagedMode() {
         assertEquals(object1, object2);
     }
 
-    @Test
-    public void get_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object1 = new AllTypes();
-        list.add(object1);
-        AllTypes object2 = list.get(0);
-        assertEquals(object1, object2);
-    }
-
-    @Test
-    public void size_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        assertEquals(1, list.size());
-    }
-
     // Test move where oldPosition > newPosition
     @Test
     public void move_down() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         Dog dog1 = owner.getDogs().get(1);
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         owner.getDogs().move(1, 0);
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
         assertEquals(0, owner.getDogs().indexOf(dog1));
     }
@@ -292,46 +266,18 @@ public void move_down() {
     // Test move where oldPosition < newPosition
     @Test
     public void move_up() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        int oldIndex = TEST_OBJECTS / 2;
+        Owner owner = realm.where(Owner.class).findFirst();
+        int oldIndex = TEST_SIZE / 2;
         int newIndex = oldIndex + 1;
         Dog dog = owner.getDogs().get(oldIndex);
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         owner.getDogs().move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
-        assertEquals(TEST_OBJECTS, owner.getDogs().size());
+        assertEquals(TEST_SIZE, owner.getDogs().size());
         assertEquals(newIndex, owner.getDogs().indexOf(dog));
     }
 
-    @Test
-    public void first_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object1 = new AllTypes();
-        AllTypes object2 = new AllTypes();
-        list.add(object1);
-        list.add(object2);
-
-        assertEquals(object1, list.first());
-    }
-
-    @Test
-    public void last_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object1 = new AllTypes();
-        AllTypes object2 = new AllTypes();
-        list.add(object1);
-        list.add(object2);
-
-        assertEquals(object2, list.last());
-    }
-
-    @Test
-    public void allMethods_emptyListInNonManagedMode() {
-        RealmList<Dog> list = new RealmList<Dog>();
-        checkMethodsOnEmptyList(testRealm, list);
-    }
-
     // Test move where oldPosition > newPosition
     @Test
     public void move_downInNonManagedMode() {
@@ -346,12 +292,12 @@ public void move_downInNonManagedMode() {
     @Test
     public void move_upInNonManagedMode() {
         RealmList<Dog> dogs = createNonManagedDogList();
-        int oldIndex = TEST_OBJECTS / 2;
+        int oldIndex = TEST_SIZE / 2;
         int newIndex = oldIndex + 1;
         Dog dog = dogs.get(oldIndex);
         dogs.move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
 
-        assertEquals(TEST_OBJECTS, dogs.size());
+        assertEquals(TEST_SIZE, dogs.size());
         assertEquals(oldIndex, dogs.indexOf(dog));
     }
 
@@ -361,23 +307,23 @@ public void move_upInNonManagedMode() {
 
     @Test
     public void isValid() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
 
         assertTrue(dogs.isValid());
 
-        testRealm.close();
+        realm.close();
         assertFalse(dogs.isValid());
     }
 
     @Test
     public void isValid_whenParentRemoved() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
 
-        testRealm.beginTransaction();
-        owner.removeFromRealm();
-        testRealm.commitTransaction();
+        realm.beginTransaction();
+        owner.deleteFromRealm();
+        realm.commitTransaction();
 
         // RealmList contained in removed object is invalid.
         assertFalse(dogs.isValid());
@@ -385,175 +331,159 @@ public void isValid_whenParentRemoved() {
 
     @Test
     public void move_outOfBoundsLowerThrows() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
+        Owner owner = realm.where(Owner.class).findFirst();
+        realm.beginTransaction();
         try {
             owner.getDogs().move(0, -1);
             fail("Indexes < 0 should throw an exception");
         } catch (IndexOutOfBoundsException ignored) {
         } finally {
-            testRealm.cancelTransaction();
+            realm.cancelTransaction();
         }
     }
 
     @Test
     public void move_outOfBoundsHigherThrows() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
+        Owner owner = realm.where(Owner.class).findFirst();
+        realm.beginTransaction();
         try {
-            int lastIndex = TEST_OBJECTS - 1;
-            int outOfBoundsIndex = TEST_OBJECTS;
+            int lastIndex = TEST_SIZE - 1;
+            int outOfBoundsIndex = TEST_SIZE;
             owner.getDogs().move(lastIndex, outOfBoundsIndex);
             fail("Indexes >= size() should throw an exception");
         } catch (IndexOutOfBoundsException ignored) {
             ignored.printStackTrace();
         } finally {
-            testRealm.cancelTransaction();
+            realm.cancelTransaction();
         }
     }
 
     @Test
     public void add_managedObjectToManagedList() {
-        testRealm.beginTransaction();
-        testRealm.clear(Owner.class);
-        Owner owner = testRealm.createObject(Owner.class);
-        Dog dog = testRealm.createObject(Dog.class);
+        realm.beginTransaction();
+        realm.delete(Owner.class);
+        Owner owner = realm.createObject(Owner.class);
+        Dog dog = realm.createObject(Dog.class);
         owner.getDogs().add(dog);
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
-        assertEquals(1, testRealm.where(Owner.class).findFirst().getDogs().size());
+        assertEquals(1, realm.where(Owner.class).findFirst().getDogs().size());
     }
 
     // Test that add correctly uses Realm.copyToRealm() on standalone objects.
     @Test
     public void add_nonManagedObjectToManagedList() {
-        testRealm.beginTransaction();
-        CyclicType parent = testRealm.createObject(CyclicType.class);
+        realm.beginTransaction();
+        CyclicType parent = realm.createObject(CyclicType.class);
         RealmList<CyclicType> children = parent.getObjects();
         children.add(new CyclicType());
-        testRealm.commitTransaction();
-        assertEquals(1, testRealm.where(CyclicType.class).findFirst().getObjects().size());
+        realm.commitTransaction();
+        assertEquals(1, realm.where(CyclicType.class).findFirst().getObjects().size());
     }
 
     // Make sure that standalone objects with a primary key are added using copyToRealmOrUpdate
     @Test
     public void add_nonManagedPrimaryKeyObjectToManagedList() {
-        testRealm.beginTransaction();
-        testRealm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
-        RealmList<CyclicTypePrimaryKey> children = testRealm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
+        realm.beginTransaction();
+        realm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
+        RealmList<CyclicTypePrimaryKey> children = realm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
         children.add(new CyclicTypePrimaryKey(2, "new"));
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
-        assertEquals(1, testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getObjects().size());
-        assertEquals("new", testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
+        assertEquals(1, realm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getObjects().size());
+        assertEquals("new", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
     }
 
     // Test that set correctly uses Realm.copyToRealm() on standalone objects.
     @Test
     public void set_nonManagedObjectToManagedList() {
-        testRealm.beginTransaction();
-        CyclicType parent = testRealm.copyToRealm(new CyclicType("Parent"));
+        realm.beginTransaction();
+        CyclicType parent = realm.copyToRealm(new CyclicType("Parent"));
         RealmList<CyclicType> children = parent.getObjects();
         children.add(new CyclicType());
         children.add(new CyclicType("original"));
         children.add(new CyclicType());
         children.set(1, new CyclicType("updated"));
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
-        RealmList<CyclicType> list = testRealm.where(CyclicType.class).findFirst().getObjects();
+        RealmList<CyclicType> list = realm.where(CyclicType.class).findFirst().getObjects();
         assertEquals(3, list.size());
         assertEquals("updated", list.get(1).getName());
-        assertEquals(5, testRealm.where(CyclicType.class).count());
+        assertEquals(5, realm.where(CyclicType.class).count());
     }
 
     // Test that set correctly uses Realm.copyToRealmOrUpdate() on standalone objects with a primary key.
     @Test
     public void  set_nonManagedPrimaryKeyObjectToManagedList() {
-        testRealm.beginTransaction();
-        CyclicTypePrimaryKey parent = testRealm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
+        realm.beginTransaction();
+        CyclicTypePrimaryKey parent = realm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
         RealmList<CyclicTypePrimaryKey> children = parent.getObjects();
         children.add(new CyclicTypePrimaryKey(2));
         children.add(new CyclicTypePrimaryKey(3, "original"));
         children.add(new CyclicTypePrimaryKey(4));
         children.set(1, new CyclicTypePrimaryKey(3, "updated"));
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
-        RealmList<CyclicTypePrimaryKey> list = testRealm.where(CyclicTypePrimaryKey.class).findFirst().getObjects();
+        RealmList<CyclicTypePrimaryKey> list = realm.where(CyclicTypePrimaryKey.class).findFirst().getObjects();
         assertEquals(3, list.size());
         assertEquals("updated", list.get(1).getName());
     }
 
     @Test
     public void add_nullToManagedListThrows() {
-        testRealm.beginTransaction();
-        Owner owner = testRealm.createObject(Owner.class);
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
         thrown.expect(IllegalArgumentException.class);
         owner.getDogs().add(null);
     }
 
     @Test
     public void size() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        assertEquals(TEST_OBJECTS, owner.getDogs().size());
+        Owner owner = realm.where(Owner.class).findFirst();
+        assertEquals(TEST_SIZE, owner.getDogs().size());
     }
 
     @Test
     public void getObjects() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
 
         assertNotNull(dogs);
         assertEquals("Dog 1", dogs.get(1).getName());
     }
 
-    @Test
-    public void first() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-
-        assertEquals("Dog 0", dogs.first().getName());
-    }
-
-    @Test
-    public void last() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-
-        assertEquals("Dog " + (TEST_OBJECTS - 1), dogs.last().getName());
-    }
-
     @Test
     public void remove_byIndex() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
         Dog dog5 = dogs.get(5);
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         Dog removedDog = dogs.remove(5);
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
         assertEquals(dog5, removedDog);
-        assertEquals(TEST_OBJECTS - 1, dogs.size());
+        assertEquals(TEST_SIZE - 1, dogs.size());
     }
 
     @Test
     public void remove_last() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
 
-        testRealm.beginTransaction();
-        dogs.remove(TEST_OBJECTS - 1);
-        testRealm.commitTransaction();
+        realm.beginTransaction();
+        dogs.remove(TEST_SIZE - 1);
+        realm.commitTransaction();
 
-        assertEquals(TEST_OBJECTS - 1, dogs.size());
+        assertEquals(TEST_SIZE - 1, dogs.size());
     }
 
     @Test
     public void remove_fromEmptyListThrows() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         dogs.clear();
         thrown.expect(IndexOutOfBoundsException.class);
         dogs.remove(0);
@@ -561,24 +491,24 @@ public void remove_fromEmptyListThrows() {
 
     @Test
     public void remove_byObject() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
         Dog dog = dogs.get(0);
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         boolean result = dogs.remove(dog);
-        testRealm.commitTransaction();
+        realm.commitTransaction();
 
         assertTrue(result);
-        assertEquals(TEST_OBJECTS - 1, dogs.size());
+        assertEquals(TEST_SIZE - 1, dogs.size());
     }
 
     @Test
     public void add_atAfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
         dog.setName("Dog");
         thrown.expect(IllegalStateException.class);
         dogs.add(0, dog);
@@ -588,8 +518,8 @@ public void add_atAfterContainerObjectRemoved() {
     public void add_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
         dog.setName("Dog");
         thrown.expect(IllegalStateException.class);
         dogs.add(dog);
@@ -599,8 +529,8 @@ public void add_afterContainerObjectRemoved() {
     public void set_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
         dog.setName("Dog");
         thrown.expect(IllegalStateException.class);
         dogs.set(0, dog);
@@ -610,7 +540,7 @@ public void set_afterContainerObjectRemoved() {
     public void move_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         thrown.expect(IllegalStateException.class);
         dogs.move(0, 1);
     }
@@ -619,7 +549,7 @@ public void move_afterContainerObjectRemoved() {
     public void clear_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         thrown.expect(IllegalStateException.class);
         dogs.clear();
     }
@@ -628,29 +558,51 @@ public void clear_afterContainerObjectRemoved() {
     public void remove_atAfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
         dog.setName("Dog");
         thrown.expect(IllegalStateException.class);
         dogs.remove(0);
     }
 
     @Test
-    public void remove_bbjectAfterContainerObjectRemoved() {
+    public void remove_objectAfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
         dog.setName("Dog");
         thrown.expect(IllegalStateException.class);
         dogs.remove(dog);
     }
 
+    @Test
+    public void removeAll_managedMode() {
+        realm.beginTransaction();
+        List<Dog> objectsToRemove = Arrays.asList(collection.get(0));
+        assertTrue(collection.removeAll(objectsToRemove));
+        assertFalse(collection.contains(objectsToRemove.get(0)));
+    }
+
+    @Test
+    public void removeAll_managedMode_wrongClass() {
+        realm.beginTransaction();
+        //noinspection SuspiciousMethodCalls
+        assertFalse(collection.removeAll(Collections.singletonList(new Cat())));
+    }
+
+    @Test
+    public void removeAll_unmanaged_wrongClass() {
+        RealmList<Dog> list = createNonManagedDogList();
+        //noinspection SuspiciousMethodCalls
+        assertFalse(list.removeAll(Collections.singletonList(new Cat())));
+    }
+
     @Test
     public void remove_allAfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         thrown.expect(IllegalStateException.class);
         dogs.removeAll(Collections.<Dog>emptyList());
     }
@@ -697,323 +649,157 @@ public void where_afterContainerObjectRemoved() {
     @Test
     public void toString_AfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
-
         assertEquals("Dog@[invalid]", dogs.toString());
     }
 
     @Test
-    public void query() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        Dog firstDog = dogs.where().equalTo("name", "Dog 0").findFirst();
+    public void toString_managedMode() {
+        StringBuilder sb = new StringBuilder("Dog@[");
+        for (int i = 0; i < collection.size() - 1; i++) {
+            sb.append(collection.get(i).row.getIndex());
+            sb.append(",");
+        }
+        sb.append(collection.get(TEST_SIZE - 1).row.getIndex());
+        sb.append("]");
 
-        assertNotNull(firstDog);
+        assertEquals(sb.toString(), collection.toString());
     }
 
     @Test
-    public void allMethods_emptyListInManagedMode() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        owner.getDogs().clear();
-        testRealm.commitTransaction();
+    public void query() {
+        Owner owner = realm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        Dog firstDog = dogs.where().equalTo("name", "Dog 0").findFirst();
 
-        checkMethodsOnEmptyList(testRealm, owner.getDogs());
+        assertNotNull(firstDog);
     }
 
     @Test
     public void clear() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        assertEquals(TEST_OBJECTS, owner.getDogs().size());
+        Owner owner = realm.where(Owner.class).findFirst();
+        realm.beginTransaction();
+        assertEquals(TEST_SIZE, owner.getDogs().size());
         owner.getDogs().clear();
         assertEquals(0, owner.getDogs().size());
-        testRealm.commitTransaction();
+        realm.commitTransaction();
     }
 
     @Test
-    public void clear_NotDeleting() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
+    public void clear_notDeleting() {
+        Owner owner = realm.where(Owner.class).findFirst();
+        realm.beginTransaction();
+        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
         owner.getDogs().clear();
-        assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
-        testRealm.commitTransaction();
-    }
-
-    @Test
-    public void contains() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        Dog dog = owner.getDogs().get(0);
-        assertTrue("Should contain a particular dog.", owner.getDogs().contains(dog));
+        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        realm.commitTransaction();
     }
 
-    /**
-     * Test to see if a particular item that does exist in the same Realm does not
-     * exist in a query that excludes said item.
-     */
     @Test
-    public void contains_sameRealmNotContained() {
-        RealmResults<Dog> dogs = testRealm.where(Dog.class)
-                .equalTo("name", "Dog 1").or().equalTo("name", "Dog 2").findAll();
-        Dog thirdDog = testRealm.where(Dog.class)
-                .equalTo("name", "Dog 3").findFirst();
-        assertFalse("Should not contain a particular dog.", dogs.contains(thirdDog));
-    }
-
-    @Test
-    public void contains_inNonManagedList() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> managedDogs = owner.getDogs();
-        // Create a non-managed RealmList
-        RealmList<Dog> nonManagedDogs
-                = new RealmList<Dog>(managedDogs.toArray(new Dog[managedDogs.size()]));
-        Dog dog = managedDogs.get(0);
-        assertTrue("Should contain a particular dog", nonManagedDogs.contains(dog));
-    }
+    public void setList_clearsOldItems() {
+        realm.beginTransaction();
+        CyclicType one = realm.copyToRealm(new CyclicType());
+        CyclicType two = realm.copyToRealm(new CyclicType());
 
-    @Test
-    public void contains_null() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        assertFalse("Should not contain a null item.", owner.getDogs().contains(null));
+        assertEquals(0, two.getObjects().size());
+        two.setObjects(new RealmList<CyclicType>(one));
+        assertEquals(1, two.getObjects().size());
+        two.setObjects(new RealmList<CyclicType>(one, two));
+        assertEquals(2, two.getObjects().size());
     }
 
-    /**
-     * Test that the {@link Realm#contains(Class)} method of one Realm will not contain a
-     * {@link RealmObject} from another Realm.
-     */
     @Test
-    public void contains_doesNotContainAnItem() {
-        RealmConfiguration realmConfig = configFactory.createConfiguration("contains_test.realm");
-        Realm testRealmTwo = Realm.getInstance(realmConfig);
-        try {
-            // Set up the test realm
-            testRealmTwo.beginTransaction();
-            Owner owner2 = testRealmTwo.createObject(Owner.class);
-            owner2.setName("Owner");
-            for (int i = 0; i < TEST_OBJECTS; i++) {
-                Dog dog = testRealmTwo.createObject(Dog.class);
-                dog.setName("Dog " + i);
-                owner2.getDogs().add(dog);
-            }
-            testRealmTwo.commitTransaction();
-
-            // Get a dog from the test realm.
-            Dog dog2 = testRealmTwo.where(Owner.class).findFirst().getDogs().get(0);
+    public void realmMethods_onDeletedLinkView() {
+        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.MANAGED_REALMLIST);
 
-            // Access the original Realm. Then see if the above dog object is contained. (It shouldn't).
-            Owner owner1 = testRealm.where(Owner.class).findFirst();
-
-            assertFalse("Should not be able to find one object in another Realm via contains",
-                    owner1.getDogs().contains(dog2));
-        } finally {
-            if (testRealmTwo != null && !testRealmTwo.isClosed()) {
-                testRealmTwo.close();
+        for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
+            try {
+                switch (method) {
+                    case WHERE: results.where(); break;
+                    case MIN: results.min(CyclicType.FIELD_ID); break;
+                    case MAX: results.max(CyclicType.FIELD_ID); break;
+                    case SUM: results.sum(CyclicType.FIELD_ID); break;
+                    case AVERAGE: results.average(CyclicType.FIELD_ID); break;
+                    case MIN_DATE: results.minDate(CyclicType.FIELD_DATE); break;
+                    case MAX_DATE: results.maxDate(CyclicType.FIELD_DATE); break;
+                    case DELETE_ALL_FROM_REALM: results.deleteAllFromRealm(); break;
+                    case IS_VALID: continue; // Does not throw
+                }
+                fail(method + " should have thrown an Exception.");
+            } catch (IllegalStateException ignored) {
             }
         }
-    }
 
-    @Test
-    public void contains_shouldNotContainDeletedRealmObject() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        Dog dog1 = dogs.get(0);
-        testRealm.beginTransaction();
-        dog1.removeFromRealm();
-        testRealm.commitTransaction();
-        assertFalse("Should not contain a deleted RealmObject", dogs.contains(dog1));
-    }
-
-    // Test that all methods that require a transaction (ie. any function that mutates Realm data)
-    @Test
-    public void mutableMethods_OutsideTransactions() {
-        testRealm.beginTransaction();
-        RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
-        Dog dog = testRealm.createObject(Dog.class);
-        list.add(dog);
-        testRealm.commitTransaction();
-
-        try { list.add(dog);    fail(); } catch (IllegalStateException ignored) {}
-        try { list.add(0, dog); fail(); } catch (IllegalStateException ignored) {}
-        try { list.clear();     fail(); } catch (IllegalStateException ignored) {}
-        try { list.move(0, 1);  fail(); } catch (IllegalStateException ignored) {}
-        try { list.remove(0);   fail(); } catch (IllegalStateException ignored) {}
-        try { list.set(0, dog); fail(); } catch (IllegalStateException ignored) {}
-    }
-
-    private enum Method {
-        METHOD_ADD,
-        METHOD_ADD_AT,
-        METHOD_CLEAR,
-        METHOD_MOVE,
-        METHOD_REMOVE,
-        METHOD_SET
-    }
-
-    // Calling methods from the wrong thread should fail
-    private boolean methodWrongThread(final Method method) throws InterruptedException, ExecutionException {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        testRealm.clear(Dog.class);
-        final RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
-        Dog dog = testRealm.createObject(Dog.class);
-        list.add(dog);
-        testRealm.commitTransaction();
-
-        testRealm.beginTransaction(); // Make sure that a valid transaction has begun on the correct thread
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                try {
-                    switch (method) {
-                        case METHOD_ADD:
-                            list.add(new Dog());
-                            break;
-                        case METHOD_ADD_AT:
-                            list.add(1, new Dog());
-                            break;
-                        case METHOD_CLEAR:
-                            list.clear();
-                            break;
-                        case METHOD_MOVE:
-                            list.add(new Dog());
-                            list.move(0, 1);
-                            break;
-                        case METHOD_REMOVE:
-                            list.remove(0);
-                            break;
-                        case METHOD_SET:
-                            list.set(0, new Dog());
-                            break;
-                    }
-                    return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
+        for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
+            realm.beginTransaction();
+            try {
+                switch (method) {
+                    case DELETE_INDEX: results.deleteFromRealm(0); break;
+                    case DELETE_FIRST: results.deleteFirstFromRealm(); break;
+                    case DELETE_LAST: results.deleteLastFromRealm(); break;
+                    case SORT: results.sort(CyclicType.FIELD_NAME); break;
+                    case SORT_FIELD: results.sort(CyclicType.FIELD_NAME, Sort.ASCENDING); break;
+                    case SORT_2FIELDS: results.sort(CyclicType.FIELD_NAME, Sort.ASCENDING, CyclicType.FIELD_DATE, Sort.DESCENDING); break;
+                    case SORT_MULTI: results.sort(new String[] { CyclicType.FIELD_NAME, CyclicType.FIELD_DATE }, new Sort[] { Sort.ASCENDING, Sort.DESCENDING});
                 }
+                fail(method + " should have thrown an Exception");
+            } catch (IllegalStateException ignored) {
+            } finally {
+                realm.cancelTransaction();
             }
-        });
-
-        boolean result = future.get();
-        testRealm.cancelTransaction();
-        return result;
-    }
-
-    @Test
-    public void methods_ThrowOnWrongThread() throws ExecutionException, InterruptedException {
-        for (Method method : Method.values()) {
-            assertTrue(method.toString(), methodWrongThread(method));
         }
     }
 
-    @Test
-    public void setList_ClearsOldItems() {
-        testRealm.beginTransaction();
-        CyclicType one = testRealm.copyToRealm(new CyclicType());
-        CyclicType two = testRealm.copyToRealm(new CyclicType());
-        two.setObjects(new RealmList<CyclicType>(one));
-        two.setObjects(new RealmList<CyclicType>(one));
-        testRealm.commitTransaction();
-
-        assertEquals(1, two.getObjects().size());
-    }
-
     @Test
     public void removeAllFromRealm() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
-        assertEquals(TEST_OBJECTS, dogs.size());
+        assertEquals(TEST_SIZE, dogs.size());
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         dogs.deleteAllFromRealm();
-        testRealm.commitTransaction();
+        realm.commitTransaction();
         assertEquals(0, dogs.size());
-        assertEquals(0, testRealm.where(Dog.class).count());
-    }
-
-    @Test
-    public void removeAllFromRealm_notManagedList() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        assertEquals(TEST_OBJECTS, dogs.size());
-
-        RealmList<Dog> notManagedDogs = new RealmList<Dog>();
-        for (Dog dog : dogs) {
-            notManagedDogs.add(dog);
-        }
-
-        testRealm.beginTransaction();
-        notManagedDogs.deleteAllFromRealm();
-        testRealm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, notManagedDogs.size());
-        assertEquals(0, testRealm.where(Dog.class).count());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
     public void removeAllFromRealm_outsideTransaction() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
+        Owner owner = realm.where(Owner.class).findFirst();
         RealmList<Dog> dogs = owner.getDogs();
         try {
             dogs.deleteAllFromRealm();
             fail("removeAllFromRealm should be called in a transaction.");
         } catch (IllegalStateException e) {
-            assertEquals("Changing Realm data can only be done from inside a transaction.", e.getMessage());
+            assertEquals("Changing Realm data can only be done from inside a write transaction.", e.getMessage());
         }
     }
 
-    @Test
-    public void removeAllFromRealm_listWithStandaloneObjectShouldThrow() {
-        final RealmList<Dog> list = new RealmList<Dog>();
-
-        testRealm.beginTransaction();
-        Dog dog1 = testRealm.where(Dog.class).findFirst();
-        testRealm.commitTransaction();
-        Dog dog2 = new Dog();
-
-        list.add(dog1);
-        list.add(dog2);
-
-        testRealm.beginTransaction();
-        try {
-            list.deleteAllFromRealm();
-            fail("Cannot remove a list with a standalone object in it!");
-        } catch (IllegalStateException e) {
-            assertEquals("Object malformed: missing object in Realm. Make sure to instantiate RealmObjects with" +
-                    " Realm.createObject()", e.getMessage());
-        } finally {
-            testRealm.cancelTransaction();
-        }
-
-        assertEquals(TEST_OBJECTS, testRealm.where(Dog.class).count());
-        assertEquals(2, list.size());
-    }
-
     @Test
     public void removeAllFromRealm_emptyList() {
-        RealmList<Dog> dogs = testRealm.where(Owner.class).findFirst().getDogs();
-        assertEquals(TEST_OBJECTS, dogs.size());
+        RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
+        assertEquals(TEST_SIZE, dogs.size());
 
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         dogs.deleteAllFromRealm();
-        testRealm.commitTransaction();
+        realm.commitTransaction();
         assertEquals(0, dogs.size());
-        assertEquals(0, testRealm.where(Dog.class).count());
+        assertEquals(0, realm.where(Dog.class).count());
 
         // The dogs is empty now.
-        testRealm.beginTransaction();
+        realm.beginTransaction();
         dogs.deleteAllFromRealm();
-        testRealm.commitTransaction();
+        realm.commitTransaction();
         assertEquals(0, dogs.size());
-        assertEquals(0, testRealm.where(Dog.class).count());
+        assertEquals(0, realm.where(Dog.class).count());
 
     }
 
     @Test
     public void removeAllFromRealm_invalidListShouldThrow() {
-        RealmList<Dog> dogs = testRealm.where(Owner.class).findFirst().getDogs();
-        assertEquals(TEST_OBJECTS, dogs.size());
-        testRealm.close();
-        testRealm = null;
+        RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
+        assertEquals(TEST_SIZE, dogs.size());
+        realm.close();
+        realm = null;
 
         try {
             dogs.deleteAllFromRealm();
@@ -1026,13 +812,13 @@ public void removeAllFromRealm_invalidListShouldThrow() {
     @Test
     public void add_set_objectFromOtherThread() {
         final CountDownLatch finishedLatch = new CountDownLatch(1);
-        final Dog dog = testRealm.where(Dog.class).findFirst();
+        final Dog dog = realm.where(Dog.class).findFirst();
         final String expectedMsg = "Cannot copy an object from another Realm instance.";
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                Realm realm = Realm.getInstance(testRealm.getConfiguration());
+                Realm realm = Realm.getInstance(RealmListTests.this.realm.getConfiguration());
                 realm.beginTransaction();
                 RealmList<Dog> list = realm.createObject(Owner.class).getDogs();
                 list.add(realm.createObject(Dog.class));
@@ -1068,14 +854,14 @@ public void run() {
     @Test
     public void add_set_dynamicObjectFromOtherThread() {
         final CountDownLatch finishedLatch = new CountDownLatch(1);
-        DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final DynamicRealmObject dynDog = dynamicRealm.where(Dog.CLASS_NAME).findFirst();
         final String expectedMsg = "Cannot copy an object to a Realm instance created in another thread.";
 
         new Thread(new Runnable() {
             @Override
             public void run() {
-                DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+                DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
                 dynamicRealm.beginTransaction();
                 RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
                         .getList(Owner.FIELD_DOGS);
@@ -1115,7 +901,7 @@ public void run() {
     public void add_set_withWrongDynamicObjectType() {
         final String expectedMsg = "The object has a different type from list's. Type of the list is 'Dog'," +
                         " type of object is 'Cat'.";
-        DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
         dynamicRealm.beginTransaction();
         RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
@@ -1153,8 +939,8 @@ public void add_set_withWrongDynamicObjectType() {
     @Test
     public void add_set_dynamicObjectCreatedFromTypedRealm() {
         final String expectedMsg = "Cannot copy DynamicRealmObject between Realm instances.";
-        DynamicRealmObject dynDog = new DynamicRealmObject(testRealm.where(Dog.class).findFirst());
-        DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+        DynamicRealmObject dynDog = new DynamicRealmObject(realm.where(Dog.class).findFirst());
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
         dynamicRealm.beginTransaction();
         RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 5ac41a5c25..500b7261fb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -16,25 +16,42 @@
 
 package io.realm;
 
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 import java.util.Set;
 
 import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmObjectSchemaTests {
 
-public class RealmObjectSchemaTests extends AndroidTestCase {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
 
     private RealmObjectSchema DOG_SCHEMA;
     private DynamicRealm realm;
     private RealmObjectSchema schema;
     private RealmSchema realmSchema;
 
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).build();
-        Realm.deleteRealm(realmConfig);
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
         Realm.getInstance(realmConfig).close(); // Create Schema
         realm = DynamicRealm.getInstance(realmConfig);
         realmSchema = realm.getSchema();
@@ -43,9 +60,8 @@ protected void setUp() throws Exception {
         schema = realmSchema.create("NewClass");
     }
 
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
+    @After
+    public void tearDown() {
         realm.cancelTransaction();
         realm.close();
     }
@@ -162,7 +178,8 @@ public boolean isNullable() {
         }
     }
 
-    public void testAddRemoveField() {
+    @Test
+    public void addRemoveField() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
             switch(fieldType) {
@@ -189,7 +206,8 @@ private void checkAddedAndRemovable(String fieldName) {
         assertFalse(schema.hasField(fieldName));
     }
 
-    public void testAddField_nameAlreadyExistsThrows() {
+    @Test
+    public void addField_nameAlreadyExistsThrows() {
         for (SchemaFieldType schemaFieldType : SchemaFieldType.values()) {
             switch (schemaFieldType) {
                 case SIMPLE:
@@ -232,7 +250,8 @@ private void checkAddFieldTwice(String fieldName, FieldRunnable runnable) {
     }
 
 
-    public void testAddField_illegalFieldNameThrows() {
+    @Test
+    public void addField_illegalFieldNameThrows() {
         String[] fieldNames = new String[] { null, "", "foo.bar", TestHelper.getRandomString(65) };
         for (SchemaFieldType schemaFieldType : SchemaFieldType.values()) {
             for (String fieldName : fieldNames) {
@@ -251,7 +270,8 @@ public void testAddField_illegalFieldNameThrows() {
         }
     }
 
-    public void testRequiredFieldAttribute() {
+    @Test
+    public void requiredFieldAttribute() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
             switch (fieldType) {
@@ -266,7 +286,8 @@ public void testRequiredFieldAttribute() {
         }
     }
 
-    public void testIndexedFieldAttribute() {
+    @Test
+    public void indexedFieldAttribute() {
         for (IndexFieldType fieldType : IndexFieldType.values()) {
             String fieldName = "foo";
             switch (fieldType) {
@@ -278,7 +299,8 @@ public void testIndexedFieldAttribute() {
         }
     }
 
-    public void testInvalidIndexedFieldAttributeThrows() {
+    @Test
+    public void invalidIndexedFieldAttributeThrows() {
         for (InvalidIndexFieldType fieldType : InvalidIndexFieldType.values()) {
             String fieldName = "foo";
             try {
@@ -289,17 +311,20 @@ public void testInvalidIndexedFieldAttributeThrows() {
         }
     }
 
-    public void testPrimaryKeyFieldAttribute() {
+    @Test
+    public void primaryKeyFieldAttribute() {
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
             assertTrue(schema.hasPrimaryKey());
+            assertTrue(schema.isPrimaryKey(fieldName));
             assertFalse(schema.isNullable(fieldName));
             schema.removeField(fieldName);
         }
     }
 
-    public void testInvalidPrimaryKeyFieldAttributeThrows() {
+    @Test
+    public void invalidPrimaryKeyFieldAttributeThrows() {
         for (InvalidPrimaryKeyFieldType fieldType : InvalidPrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             try {
@@ -310,7 +335,8 @@ public void testInvalidPrimaryKeyFieldAttributeThrows() {
         }
     }
 
-    public void testAddPrimaryKeyFieldModifier_alreadyExistsThrows() {
+    @Test
+    public void addPrimaryKeyFieldModifier_alreadyExistsThrows() {
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
@@ -325,7 +351,8 @@ public void testAddPrimaryKeyFieldModifier_alreadyExistsThrows() {
         }
     }
 
-    public void testAddPrimaryKeyFieldModifier_illegalFieldTypeThrows() {
+    @Test
+    public void addPrimaryKeyFieldModifier_illegalFieldTypeThrows() {
         String fieldName = "foo";
         for (InvalidPrimaryKeyFieldType fieldType : InvalidPrimaryKeyFieldType.values()) {
             switch (fieldType) {
@@ -342,7 +369,8 @@ public void testAddPrimaryKeyFieldModifier_illegalFieldTypeThrows() {
         }
     }
 
-    public void testAddPrimaryKeyFieldModifier_duplicateValues() {
+    @Test
+    public void addPrimaryKeyFieldModifier_duplicateValues() {
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             final String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
@@ -362,7 +390,8 @@ public void testAddPrimaryKeyFieldModifier_duplicateValues() {
         }
     }
 
-    public void testAddIndexFieldModifier_illegalFieldTypeThrows() {
+    @Test
+    public void addIndexFieldModifier_illegalFieldTypeThrows() {
         String fieldName = "foo";
         for (InvalidIndexFieldType fieldType : InvalidIndexFieldType.values()) {
             switch (fieldType) {
@@ -379,7 +408,8 @@ public void testAddIndexFieldModifier_illegalFieldTypeThrows() {
         }
     }
 
-    public void testAddIndexFieldModifier_alreadyIndexedThrows() {
+    @Test
+    public void addIndexFieldModifier_alreadyIndexedThrows() {
         for (IndexFieldType fieldType : IndexFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
@@ -393,7 +423,8 @@ public void testAddIndexFieldModifier_alreadyIndexedThrows() {
         }
     }
 
-    public void testSetRemoveNullable() {
+    @Test
+    public void setRemoveNullable() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
             switch (fieldType) {
@@ -428,7 +459,8 @@ public void testSetRemoveNullable() {
         }
     }
 
-    public void testSetRemoveRequired() {
+    @Test
+    public void setRemoveRequired() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
             switch (fieldType) {
@@ -463,29 +495,32 @@ public void testSetRemoveRequired() {
         }
     }
 
-    public void testSetRemovePrimaryKey() {
+    @Test
+    public void setRemovePrimaryKey() {
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
             schema.addPrimaryKey(fieldName);
             assertTrue(schema.hasPrimaryKey());
+            assertTrue(schema.isPrimaryKey(fieldName));
             schema.removePrimaryKey();
             assertFalse(schema.hasPrimaryKey());
+            assertFalse(schema.isPrimaryKey(fieldName));
             schema.removeField(fieldName);
         }
     }
 
-    public void testRemoveNonExistingPrimaryKeyThrows() {
+    @Test
+    public void removeNonExistingPrimaryKeyThrows() {
         String fieldName = "foo";
         schema.addField(fieldName, String.class);
-        try {
-            schema.removePrimaryKey();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
+
+        thrown.expect(IllegalStateException.class);
+        schema.removePrimaryKey();
     }
 
-    public void testSetRemoveIndex() {
+    @Test
+    public void setRemoveIndex() {
         for (IndexFieldType fieldType : IndexFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED);
@@ -496,17 +531,17 @@ public void testSetRemoveIndex() {
         }
     }
 
-    public void testRemoveNonExistingIndexThrows() {
+    @Test
+    public void removeNonExistingIndexThrows() {
         String fieldName = "foo";
         schema.addField(fieldName, String.class);
-        try {
-            schema.removeIndex(fieldName);
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
+
+        thrown.expect(IllegalStateException.class);
+        schema.removeIndex(fieldName);
     }
 
-    public void testRemoveField() {
+    @Test
+    public void removeField() {
         String fieldName = "foo";
         schema.addField(fieldName, String.class);
         assertTrue(schema.hasField(fieldName));
@@ -514,25 +549,27 @@ public void testRemoveField() {
         assertFalse(schema.hasField(fieldName));
     }
 
-    public void testRemoveFieldWithPrimaryKey() {
+    @Test
+    public void removeField_withPrimaryKey() {
         String fieldName = "foo";
         schema.addField(fieldName, String.class, FieldAttribute.PRIMARY_KEY);
         assertTrue(schema.hasField(fieldName));
         assertTrue(schema.hasPrimaryKey());
+        assertTrue(schema.isPrimaryKey(fieldName));
         schema.removeField(fieldName);
         assertFalse(schema.hasPrimaryKey());
     }
 
-    public void testRemoveNonExistingFieldThrows() {
+    @Test
+    public void removeField_nonExistingFieldThrows() {
         String fieldName = "foo";
-        try {
-            schema.removeField(fieldName);
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
+
+        thrown.expect(IllegalStateException.class);
+        schema.removeField(fieldName);
     }
 
-    public void testRenameField() {
+    @Test
+    public void renameField() {
         String oldFieldName = "old";
         String newFieldName = "new";
         schema.addField(oldFieldName, String.class);
@@ -543,28 +580,27 @@ public void testRenameField() {
         assertTrue(schema.hasField(newFieldName));
     }
 
-    public void testRenameNonExistingFieldThrows() {
+    @Test
+    public void renameField_nonExistingFieldThrows() {
         String oldFieldName = "old";
         String newFieldName = "new";
-        try {
-            schema.renameField(oldFieldName, newFieldName);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+
+        thrown.expect(IllegalArgumentException.class);
+        schema.renameField(oldFieldName, newFieldName);
     }
 
-    public void testRenameFieldToIllegalNameThrows() {
+    @Test
+    public void renameField_toIllegalNameThrows() {
         String oldFieldName = "old";
         String newFieldName = "";
         schema.addField(oldFieldName, String.class);
-        try {
-            schema.renameField(oldFieldName, newFieldName);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+
+        thrown.expect(IllegalArgumentException.class);
+        schema.renameField(oldFieldName, newFieldName);
     }
 
-    public void testSetGetClassName() {
+    @Test
+    public void setGetClassName() {
         assertEquals("Dog", DOG_SCHEMA.getClassName());
         String newClassName = "Darby";
         DOG_SCHEMA.setClassName(newClassName);
@@ -572,7 +608,8 @@ public void testSetGetClassName() {
         assertTrue(realmSchema.contains(newClassName));
     }
 
-    public void testTransform() {
+    @Test
+    public void transform() {
         String className = DOG_SCHEMA.getClassName();
         DynamicRealmObject dog1 = realm.createObject(className);
         dog1.setInt("age", 1);
@@ -588,7 +625,8 @@ public void apply(DynamicRealmObject obj) {
         assertEquals(5, realm.where("Dog").sum("age").intValue());
     }
 
-    public void testTransformObjectReferences() {
+    @Test
+    public void transformObjectReferences() {
         String className = DOG_SCHEMA.getClassName();
         DynamicRealmObject dog1 = realm.createObject(className);
         dog1.setInt("age", 1);
@@ -601,10 +639,12 @@ public void apply(DynamicRealmObject dog) {
                 dog.setObject("owner", owner);
             }
         });
+        //noinspection ConstantConditions
         assertEquals("John", realm.where("Dog").findFirst().getObject("owner").getString("name"));
     }
 
-    public void testGetFieldNames() {
+    @Test
+    public void getFieldNames() {
         Set<String> fieldNames = DOG_SCHEMA.getFieldNames();
         assertEquals(7, fieldNames.size());
         assertTrue(fieldNames.contains("name"));
@@ -616,7 +656,8 @@ public void testGetFieldNames() {
         assertTrue(fieldNames.contains("owner"));
     }
 
-    public void testGetFieldType() {
+    @Test
+    public void getFieldType() {
         schema = realmSchema.getSchemaForClass("AllJavaTypes");
         assertEquals(RealmFieldType.STRING, schema.getFieldType(AllJavaTypes.FIELD_STRING));
         assertEquals(RealmFieldType.BINARY, schema.getFieldType(AllJavaTypes.FIELD_BINARY));
@@ -632,12 +673,29 @@ public void testGetFieldType() {
         assertEquals(RealmFieldType.INTEGER, schema.getFieldType(AllJavaTypes.FIELD_LONG));
     }
 
-    public void testGetFieldTypeThrows() {
-        try {
-            schema.getFieldType("I don't exists");
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+    @Test(expected = IllegalArgumentException.class)
+    public void getFieldType_Throws() {
+        schema.getFieldType("I don't exist");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void hasIndex_nonExistFieldThrows() {
+        schema.hasIndex("I don't exist");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void isRequired_nonExistFieldThrows() {
+        schema.isRequired("I don't exist");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void isNullable_nonExistFieldThrows() {
+        schema.isNullable("I don't exist");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void isPrimaryKey_nonExistFieldThrows() {
+        schema.isPrimaryKey("I don't exist");
     }
 
     private interface FieldRunnable {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index b75f458c71..5ee084bc5d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -25,7 +25,6 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Calendar;
 import java.util.Date;
@@ -41,6 +40,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.ConflictingFieldName;
+import io.realm.entities.CustomMethods;
 import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
@@ -48,6 +48,8 @@
 import io.realm.entities.Thread;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
@@ -70,10 +72,19 @@
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
 
     private Realm realm;
     private RealmConfiguration realmConfig;
 
+    private Dog createManagedDogObjectFromRealmInstance(Realm testRealm) {
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        testRealm.commitTransaction();
+        return dog;
+    }
+
     @Before
     public void setUp() {
         realmConfig = configFactory.createConfiguration();
@@ -104,7 +115,7 @@ public void stringEncoding() {
         String[] strings = {"ABCD", "ÆØÅ", "Ö∫Ë", "ΠΑΟΚ", "Здравей"};
 
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
 
         for (String str : strings) {
             AllTypes obj1 = realm.createObject(AllTypes.class);
@@ -130,7 +141,7 @@ public void invalidSurrogates() {
         String low  = "Invalid low surrogate \uD83C\uDF51\uDF51";
 
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         realm.commitTransaction();
 
         realm.beginTransaction();
@@ -152,7 +163,7 @@ public void invalidSurrogates() {
 
     // removing original object and see if has been removed
     @Test
-    public void removeFromRealm() {
+    public void deleteFromRealm() {
         realm.beginTransaction();
         Dog rex = realm.createObject(Dog.class);
         rex.setName("Rex");
@@ -164,7 +175,7 @@ public void removeFromRealm() {
         assertEquals(1, allDogsBefore.size());
 
         realm.beginTransaction();
-        rex.removeFromRealm();
+        rex.deleteFromRealm();
         realm.commitTransaction();
 
         RealmResults<Dog> allDogsAfter = realm.where(Dog.class).equalTo("name", "Rex").findAll();
@@ -180,7 +191,7 @@ public void removeFromRealm() {
         // deleting rex twice should fail
         realm.beginTransaction();
         try {
-            rex.removeFromRealm();
+            rex.deleteFromRealm();
             realm.close();
             fail();
         } catch (IllegalStateException ignored) {}
@@ -189,7 +200,7 @@ public void removeFromRealm() {
     }
 
     @Test
-    public void removeFromRealm_twiceThrows() {
+    public void deleteFromRealm_twiceThrows() {
         realm.beginTransaction();
         Dog dog = realm.createObject(Dog.class);
         dog.setAge(42);
@@ -197,21 +208,32 @@ public void removeFromRealm_twiceThrows() {
 
         realm.beginTransaction();
         assertTrue(dog.isValid());
-        dog.removeFromRealm();
+        dog.deleteFromRealm();
         assertFalse(dog.isValid());
 
         try {
-            dog.removeFromRealm();
+            dog.deleteFromRealm();
             fail();
         } catch (IllegalStateException ignored) {
         }
     }
 
+    @Test
+    public void deleteFromRealm_throwOnUnmanagedObject() {
+        Dog dog = new Dog();
+
+        try {
+            dog.deleteFromRealm();
+            fail("Failed on deleting a RealmObject from null Row.");
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
     // query for an object, remove it and see it has been removed from realm
     @Test
-    public void removeFromRealm_removedFromResults() {
+    public void deleteFromRealm_removedFromResults() {
         realm.beginTransaction();
-        realm.clear(Dog.class);
+        realm.delete(Dog.class);
         Dog dogToAdd = realm.createObject(Dog.class);
         dogToAdd.setName("Rex");
         realm.commitTransaction();
@@ -221,7 +243,7 @@ public void removeFromRealm_removedFromResults() {
         Dog dogToRemove = realm.where(Dog.class).findFirst();
         assertNotNull(dogToRemove);
         realm.beginTransaction();
-        dogToRemove.removeFromRealm();
+        dogToRemove.deleteFromRealm();
         realm.commitTransaction();
 
         assertEquals(0, realm.allObjects(Dog.class).size());
@@ -243,7 +265,7 @@ public void removeFromRealm_removedFromResults() {
     private void removeOneByOne(boolean atFirst) {
         Set<Long> ages = new HashSet<Long>();
         realm.beginTransaction();
-        realm.clear(Dog.class);
+        realm.delete(Dog.class);
         for (int i = 0; i < TEST_SIZE; i++) {
             Dog dog = realm.createObject(Dog.class);
             dog.setAge(i);
@@ -263,7 +285,7 @@ private void removeOneByOne(boolean atFirst) {
                 dogToRemove = dogs.last();
             }
             ages.remove(dogToRemove.getAge());
-            dogToRemove.removeFromRealm();
+            dogToRemove.deleteFromRealm();
 
             // object is no longer valid
             try {
@@ -284,7 +306,7 @@ private void removeOneByOne(boolean atFirst) {
     }
 
     @Test
-    public void removeFromRealm_atPosition() {
+    public void deleteFromRealm_atPosition() {
         removeOneByOne(REMOVE_FIRST);
         removeOneByOne(REMOVE_LAST);
     }
@@ -292,7 +314,7 @@ public void removeFromRealm_atPosition() {
     private enum Method {
         METHOD_GETTER,
         METHOD_SETTER,
-        METHOD_REMOVE_FROM_REALM
+        METHOD_DELETE_FROM_REALM
     }
 
     private boolean runMethodOnWrongThread(final Method method) throws ExecutionException, InterruptedException {
@@ -309,8 +331,8 @@ public Boolean call() throws Exception {
                         case METHOD_SETTER:
                             allTypes.setColumnFloat(1.0f);
                             break;
-                        case METHOD_REMOVE_FROM_REALM:
-                            allTypes.removeFromRealm();
+                        case METHOD_DELETE_FROM_REALM:
+                            allTypes.deleteFromRealm();
                             break;
                     }
                     return false;
@@ -403,15 +425,80 @@ public void equals_cyclicObject() {
         assertEquals(foo, realm.where(CyclicType.class).equalTo("name", "Foo").findFirst());
     }
 
+    @Test
+    public void equals_plainCustomMethod() {
+        realm.beginTransaction();
+        CustomMethods cm = realm.createObject(CustomMethods.class);
+        cm.setName("Foo");
+        realm.commitTransaction();
+
+        CustomMethods cm1 = realm.where(CustomMethods.class).findFirst();
+        CustomMethods cm2 = realm.where(CustomMethods.class).findFirst();
+        assertTrue(cm1.equals(cm2));
+    }
+
+    @Test
+    public void equals_reverseCustomMethod() {
+        realm.beginTransaction();
+        CustomMethods cm = realm.createObject(CustomMethods.class);
+        cm.setName("Foo");
+        realm.commitTransaction();
+
+        CustomMethods cm1 = realm.where(CustomMethods.class).findFirst();
+        CustomMethods cm2 = realm.where(CustomMethods.class).findFirst();
+
+        realm.beginTransaction();
+        cm1.reverseEquals = true;
+        realm.commitTransaction();
+
+        assertFalse(cm1.equals(cm2));
+    }
+
+    @Test
+    public void equals_unmanagedCustomMethod() {
+        CustomMethods cm1 = new CustomMethods();
+        cm1.setName("Bar");
+        CustomMethods cm2 = new CustomMethods();
+        cm2.setName("Bar");
+        assertTrue(cm1.equals(cm2));
+    }
+
+    @Test
+    public void equals_mixedCustomMethod() {
+        CustomMethods cm1 = new CustomMethods();
+        cm1.setName("Bar");
+        CustomMethods cm2 = new CustomMethods();
+        cm2.setName("Bar");
+
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.copyToRealm(cm1);
+        realm.commitTransaction();
+
+        CustomMethods cm3 = realm.where(CustomMethods.class).findFirst();
+        assertFalse(cm3.equals(cm2));
+        assertTrue(cm3.getName().equals(cm2.getName()));
+    }
+
     @Test
     public void toString_cyclicObject() {
         realm.beginTransaction();
         CyclicType foo = createCyclicData();
         realm.commitTransaction();
-        String expected = "CyclicType = [{name:Foo},{object:CyclicType},{otherObject:null},{objects:RealmList<CyclicType>[0]}]";
+        String expected = "CyclicType = [{id:0},{name:Foo},{date:null},{object:CyclicType},{otherObject:null},{objects:RealmList<CyclicType>[0]}]";
         assertEquals(expected, foo.toString());
     }
 
+    @Test
+    public void toString_customMethod() {
+        realm.beginTransaction();
+        CustomMethods cm = realm.createObject(CustomMethods.class);
+        cm.setName("Foo");
+        realm.commitTransaction();
+        String expected = CustomMethods.CUSTOM_TO_STRING;
+        assertEquals(expected, cm.toString());
+    }
+
     @Test
     public void hashCode_cyclicObject() {
         realm.beginTransaction();
@@ -466,6 +553,15 @@ public void execute(Realm realm) {
         }
     }
 
+    @Test
+    public void hashCode_customMethod() {
+        realm.beginTransaction();
+        CustomMethods cm = realm.createObject(CustomMethods.class);
+        cm.setName("Foo");
+        realm.commitTransaction();
+        assertEquals(CustomMethods.HASHCODE, cm.hashCode());
+    }
+
     private CyclicType createCyclicData(Realm realm) {
         CyclicType foo = realm.createObject(CyclicType.class);
         foo.setName("Foo");
@@ -503,7 +599,7 @@ public void dateType() {
 
         // test valid dates but with precision lost
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         for (long value : testDatesLoosePrecision) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnDate(new Date(value));
@@ -585,7 +681,7 @@ public void setter_link_deletedObject() {
             CyclicType target = realm.createObject(CyclicType.class);
 
             CyclicType removed = realm.createObject(CyclicType.class);
-            removed.removeFromRealm();
+            removed.deleteFromRealm();
 
             try {
                 target.setObject(removed);
@@ -725,7 +821,7 @@ public void setter_list_withDeletedObject() {
             CyclicType target = realm.createObject(CyclicType.class);
 
             CyclicType removed = realm.createObject(CyclicType.class);
-            removed.removeFromRealm();
+            removed.deleteFromRealm();
 
             RealmList<CyclicType> list = new RealmList<>();
             list.add(realm.createObject(CyclicType.class));
@@ -889,7 +985,7 @@ public void IsValid_deletedObject() {
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
         assertTrue(allTypes.isValid());
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         realm.commitTransaction();
         assertFalse(allTypes.isValid());
     }
@@ -1130,7 +1226,7 @@ public void getter_afterDeleteFromOtherThreadThrows() {
             public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 realm.beginTransaction();
-                realm.clear(AllTypes.class);
+                realm.delete(AllTypes.class);
                 realm.commitTransaction();
                 realm.close();
                 objectDeletedInBackground.countDown();
@@ -1155,7 +1251,7 @@ public void isValid() {
         assertTrue(dog.isValid());
 
         realm.beginTransaction();
-        dog.removeFromRealm();
+        dog.deleteFromRealm();
         realm.commitTransaction();
 
         assertFalse(dog.isValid());
@@ -1359,4 +1455,237 @@ public void execute(Realm realm) {
         assertEquals("pendingQuery_updated", managed.getPendingQuery());
         assertEquals("currentTableVersion_updated", managed.getCurrentTableVersion());
     }
+
+    // Setting a not-nullable field to null is an error
+    // TODO Move this to RealmObjectTests?
+    @Test
+    public void setter_nullValueInRequiredField() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+
+        // 1 String
+        try {
+            realm.beginTransaction();
+            list.first().setFieldStringNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 2 Bytes
+        try {
+            realm.beginTransaction();
+            list.first().setFieldBytesNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 3 Boolean
+        try {
+            realm.beginTransaction();
+            list.first().setFieldBooleanNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 4 Byte
+        try {
+            realm.beginTransaction();
+            list.first().setFieldBytesNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 5 Short 6 Integer 7 Long are skipped for this case, same with Bytes
+
+        // 8 Float
+        try {
+            realm.beginTransaction();
+            list.first().setFieldFloatNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 9 Double
+        try {
+            realm.beginTransaction();
+            list.first().setFieldDoubleNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 10 Date
+        try {
+            realm.beginTransaction();
+            list.first().setFieldDateNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    // Setting a nullable field to null is not an error
+    // TODO Move this to RealmObjectsTest?
+    @Test
+    public void setter_nullValueInNullableField() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+
+        // 1 String
+        realm.beginTransaction();
+        list.first().setFieldStringNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldStringNull());
+
+        // 2 Bytes
+        realm.beginTransaction();
+        list.first().setFieldBytesNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldBytesNull());
+
+        // 3 Boolean
+        realm.beginTransaction();
+        list.first().setFieldBooleanNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldBooleanNull());
+
+        // 4 Byte
+        // 5 Short 6 Integer 7 Long are skipped
+        realm.beginTransaction();
+        list.first().setFieldByteNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldByteNull());
+
+        // 8 Float
+        realm.beginTransaction();
+        list.first().setFieldFloatNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldFloatNull());
+
+        // 9 Double
+        realm.beginTransaction();
+        list.first().setFieldDoubleNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldDoubleNull());
+
+        // 10 Date
+        realm.beginTransaction();
+        list.first().setFieldDateNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldDateNull());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwOnAddingNullListener() {
+        final Realm realm = looperThread.realm;
+        Dog dog = createManagedDogObjectFromRealmInstance(realm);
+
+        try {
+            dog.addChangeListener((RealmChangeListener) null);
+            fail("Failed on adding null change listener.");
+        } catch (IllegalArgumentException ignore) {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwOnUnmanagedObject() {
+        Dog dog = new Dog();
+
+        try {
+            dog.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                }
+            });
+            fail("Failed on adding listener on null realm.");
+        } catch (IllegalArgumentException ignore) {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_throwOnRemovingNullListener() {
+        final Realm realm = looperThread.realm;
+        Dog dog = createManagedDogObjectFromRealmInstance(realm);
+
+        try {
+            dog.removeChangeListener((RealmChangeListener) null);
+            fail("Failed on adding null change listener.");
+        } catch (IllegalArgumentException ignore) {
+            looperThread.testComplete();
+        }
+    }
+
+    /**
+     * This test is to see if RealmObject.removeChangeListeners() works as it is intended.
+     */
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListeners() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setAge(13);
+        realm.commitTransaction();
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(false);
+            }
+        });
+        dog.removeChangeListeners();
+
+        realm.beginTransaction();
+        Dog sameDog = realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 13).findFirst();
+        sameDog.setName("Jesper");
+        realm.commitTransaction();
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_throwOnUnmanagedObject() {
+        Dog dog = new Dog();
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+            }
+        };
+
+        try {
+            dog.removeChangeListener(listener);
+            fail("Failed to remove a listener from null Realm.");
+        } catch (IllegalArgumentException ignore) {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListeners_throwOnUnmanagedObject() {
+        Dog dog = new Dog();
+
+        try {
+            dog.removeChangeListeners();
+            fail("Failed to remove null listener.");
+        } catch (IllegalArgumentException ignore) {
+            looperThread.testComplete();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 34d2905794..771e8a1cdf 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -86,8 +86,7 @@ public void tearDown() throws Exception {
 
     private void populateTestRealm(Realm testRealm, int objects) {
         testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        testRealm.deleteAll();
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
@@ -460,7 +459,7 @@ public void contains_caseSensitiveWithNonLatinCharacters() {
         populateTestRealm();
 
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         AllTypes at1 = realm.createObject(AllTypes.class);
         at1.setColumnString("Αλφα");
         AllTypes at2 = realm.createObject(AllTypes.class);
@@ -620,11 +619,12 @@ public void findFirst() {
     public void georgian() {
         String words[] = {"მონაცემთა ბაზა", "მიწისქვეშა გადასასვლელი", "რუსთაველის გამზირი",
                 "მთავარი ქუჩა", "სადგურის მოედანი", "ველოცირაპტორების ჯოგი"};
+
         String sorted[] = {"ველოცირაპტორების ჯოგი", "მთავარი ქუჩა", "მიწისქვეშა გადასასვლელი",
                 "მონაცემთა ბაზა", "რუსთაველის გამზირი", "სადგურის მოედანი"};
 
         realm.beginTransaction();
-        realm.clear(StringOnly.class);
+        realm.delete(StringOnly.class);
         for (String word : words) {
             StringOnly stringOnly = realm.createObject(StringOnly.class);
             stringOnly.setChars(word);
@@ -635,7 +635,7 @@ public void georgian() {
         assertEquals(1, stringOnlies1.size());
 
         RealmResults<StringOnly> stringOnlies2 = realm.allObjects(StringOnly.class);
-        stringOnlies2.sort("chars");
+        stringOnlies2 = stringOnlies2.sort("chars");
         for (int i = 0; i < stringOnlies2.size(); i++) {
             assertEquals(sorted[i], stringOnlies2.get(i).getChars());
         }
@@ -1218,6 +1218,12 @@ public void sum_partialNullRows() {
         assertEquals(11d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
     }
 
+    @Test
+    public void count() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
+    }
+
     // Test isNull on link's nullable field.
     @Test
     public void isNull_linkField() {
@@ -1512,7 +1518,7 @@ public void largeRealmMultipleThreads() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(nThreads);
 
         realm.beginTransaction();
-        realm.clear(StringOnly.class);
+        realm.delete(StringOnly.class);
         for (int i = 0; i < nObjects; i++) {
             StringOnly stringOnly = realm.createObject(StringOnly.class);
             stringOnly.setChars(String.format("string %d", i));
@@ -1613,7 +1619,7 @@ public void isValid_removedParent() {
         assertTrue(query.isValid());
 
         realm.beginTransaction();
-        obj.removeFromRealm();
+        obj.deleteFromRealm();
         realm.commitTransaction();
 
         // invalid if parent has been removed
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
index 1643aa73c8..b67a23b06c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
@@ -149,7 +149,7 @@ public void testRemovingObjectsInsideLoop() {
         testRealm.beginTransaction();
         try {
             for (AllTypes obj : result) {
-                obj.removeFromRealm();
+                obj.deleteFromRealm();
             }
         } catch (ConcurrentModificationException ignored) {
             return;
@@ -255,7 +255,7 @@ public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws In
         final RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "test");
         Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         AllTypes o1 = realm.createObject(AllTypes.class);
         o1.setColumnLong(1);
         AllTypes o2 = realm.createObject(AllTypes.class);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 8cc93758be..f2a5322446 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import android.support.test.annotation.UiThreadTest;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -26,23 +27,18 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 
+import java.util.Collections;
 import java.util.Date;
 import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
-import io.realm.entities.Cat;
+import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
-import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
 import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
@@ -51,17 +47,14 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class RealmResultsTests {
+public class RealmResultsTests extends CollectionTests {
 
     private final static int TEST_DATA_SIZE = 2516;
-    private final static int TEST_DATA_FIRST_HALF = 2 * (TEST_DATA_SIZE / 4) - 1;
-    private final static int TEST_DATA_LAST_HALF = 2 * (TEST_DATA_SIZE / 4) + 1;
     private final static long YEAR_MILLIS = TimeUnit.DAYS.toMillis(365);
     private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
 
@@ -73,12 +66,14 @@
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
     private Realm realm;
+    private RealmResults<AllTypes> collection;
 
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         populateTestRealm();
+        collection = realm.allObjects(AllTypes.class);
     }
 
     @After
@@ -90,8 +85,7 @@ public void tearDown() {
 
     private void populateTestRealm(int objects) {
         realm.beginTransaction();
-        realm.allObjects(AllTypes.class).clear();
-        realm.allObjects(NonLatinFieldNames.class).clear();
+        realm.deleteAll();
 
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -117,773 +111,6 @@ private void populateTestRealm() {
         populateTestRealm(TEST_DATA_SIZE);
     }
 
-    private void populatePartialNullRowsForNumericTesting() {
-        NullTypes nullTypes1 = new NullTypes();
-        nullTypes1.setId(1);
-        nullTypes1.setFieldIntegerNull(1);
-        nullTypes1.setFieldFloatNull(2F);
-        nullTypes1.setFieldDoubleNull(3D);
-        nullTypes1.setFieldBooleanNull(true);
-        nullTypes1.setFieldStringNull("4");
-        nullTypes1.setFieldDateNull(new Date(12345));
-
-        NullTypes nullTypes2 = new NullTypes();
-        nullTypes2.setId(2);
-
-        NullTypes nullTypes3 = new NullTypes();
-        nullTypes3.setId(3);
-        nullTypes3.setFieldIntegerNull(0);
-        nullTypes3.setFieldFloatNull(0F);
-        nullTypes3.setFieldDoubleNull(0D);
-        nullTypes3.setFieldBooleanNull(false);
-        nullTypes3.setFieldStringNull("0");
-        nullTypes3.setFieldDateNull(new Date(0));
-
-        realm.beginTransaction();
-        realm.copyToRealm(nullTypes1);
-        realm.copyToRealm(nullTypes2);
-        realm.copyToRealm(nullTypes3);
-        realm.commitTransaction();
-    }
-
-    private enum Method {
-        METHOD_MIN,
-        METHOD_MAX,
-        METHOD_SUM,
-        METHOD_AVG,
-        METHOD_SORT,
-        METHOD_WHERE,
-        METHOD_REMOVE,
-        METHOD_REMOVE_LAST,
-        METHOD_CLEAR
-    }
-
-    @Test
-    public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
-        for (Method method : Method.values()) {
-            assertTrue(runMethodOnWrongThread(method));
-        }
-    }
-
-    private boolean runMethodOnWrongThread(final Method method) throws ExecutionException, InterruptedException {
-        final RealmResults<AllTypes> allTypeses = realm.where(AllTypes.class).findAll();
-        realm.beginTransaction();
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                try {
-                    switch (method) {
-                        case METHOD_MIN:
-                            allTypeses.min(AllTypes.FIELD_FLOAT);
-                            break;
-                        case METHOD_MAX:
-                            allTypeses.max(AllTypes.FIELD_FLOAT);
-                            break;
-                        case METHOD_SUM:
-                            allTypeses.sum(AllTypes.FIELD_FLOAT);
-                            break;
-                        case METHOD_AVG:
-                            allTypeses.average(AllTypes.FIELD_FLOAT);
-                            break;
-                        case METHOD_SORT:
-                            allTypeses.sort(AllTypes.FIELD_FLOAT);
-                            break;
-                        case METHOD_WHERE:
-                            allTypeses.where();
-                            break;
-                        case METHOD_REMOVE:
-                            allTypeses.remove(0);
-                            break;
-                        case METHOD_REMOVE_LAST:
-                            allTypeses.removeLast();
-                            break;
-                        case METHOD_CLEAR:
-                            allTypeses.clear();
-                            break;
-                    }
-                    return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
-                }
-            }
-        });
-        Boolean result = future.get();
-        realm.cancelTransaction();
-        return result;
-    }
-
-    @Test
-    public void clear() {
-        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE, results.size());
-
-        realm.beginTransaction();
-        results.clear();
-        realm.commitTransaction();
-
-        assertEquals(0, results.size());
-    }
-
-    @Test
-    public void removeLast_emptyList() {
-        RealmResults<AllTypes> resultsList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "Not there").findAll();
-        assertEquals(0, resultsList.size());
-        realm.beginTransaction();
-        resultsList.removeLast();
-        assertEquals(0, resultsList.size());
-    }
-
-    @Test
-    public void get() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-
-        AllTypes allTypes = resultList.get(0);
-        assertTrue(allTypes.getColumnString().startsWith("test data"));
-    }
-
-    @Test
-    public void first() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-
-        AllTypes allTypes = resultList.first();
-        assertTrue(allTypes.getColumnString().startsWith("test data 0"));
-    }
-
-    // first() and last() will throw an exception when no element exist
-    @Test
-    public void firstAndLast_throwsIfEmpty() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> allTypes = realm.allObjects(AllTypes.class);
-        assertEquals(0, allTypes.size());
-        try {
-            allTypes.first();
-            fail();
-        } catch (ArrayIndexOutOfBoundsException ignored) {
-        }
-
-        try {
-            allTypes.last();
-            fail();
-        } catch (ArrayIndexOutOfBoundsException ignored) {
-        }
-    }
-
-    @Test
-    public void last() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-
-        AllTypes allTypes = resultList.last();
-        assertEquals((TEST_DATA_SIZE - 1), allTypes.getColumnLong());
-    }
-
-    @Test
-    public void min() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-
-        Number minimum = resultList.min(AllTypes.FIELD_LONG);
-        assertEquals(0, minimum.intValue());
-    }
-
-    // Test min on empty columns
-    @Test
-    public void min_emptyNonNullFields() {
-        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
-        assertNull(results.min(NullTypes.FIELD_INTEGER_NOT_NULL));
-        assertNull(results.min(NullTypes.FIELD_FLOAT_NOT_NULL));
-        assertNull(results.min(NullTypes.FIELD_DOUBLE_NOT_NULL));
-        assertNull(results.minDate(NullTypes.FIELD_DATE_NOT_NULL));
-    }
-
-    // Test min on nullable rows with all null values
-    @Test
-    public void min_emptyNullFields() {
-        TestHelper.populateAllNullRowsForNumericTesting(realm);
-
-        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
-        assertNull(results.max(NullTypes.FIELD_INTEGER_NULL));
-        assertNull(results.max(NullTypes.FIELD_FLOAT_NULL));
-        assertNull(results.max(NullTypes.FIELD_DOUBLE_NULL));
-        assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
-    }
-
-    // Test min on nullable rows with partial null values
-    @Test
-    public void min_partialNullRows() {
-        populatePartialNullRowsForNumericTesting();
-
-        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
-        assertEquals(0, results.min(NullTypes.FIELD_INTEGER_NULL).intValue());
-        assertEquals(0f, results.min(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
-        assertEquals(0d, results.min(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-    }
-
-    @Test
-    public void max() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-
-        Number maximum = resultList.max(AllTypes.FIELD_LONG);
-        assertEquals(TEST_DATA_SIZE - 1, maximum.intValue());
-    }
-
-    // Test max on empty columns
-    @Test
-    public void max_emptyNonNullFields() {
-        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
-        assertNull(results.max(NullTypes.FIELD_INTEGER_NOT_NULL));
-        assertNull(results.max(NullTypes.FIELD_FLOAT_NOT_NULL));
-        assertNull(results.max(NullTypes.FIELD_DOUBLE_NOT_NULL));
-        assertNull(results.maxDate(NullTypes.FIELD_DATE_NOT_NULL));
-    }
-
-    // Test max on nullable rows with all null values
-    @Test
-    public void max_emptyNullFields() {
-        TestHelper.populateAllNullRowsForNumericTesting(realm);
-
-        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
-        assertNull(results.max(NullTypes.FIELD_INTEGER_NULL));
-        assertNull(results.max(NullTypes.FIELD_FLOAT_NULL));
-        assertNull(results.max(NullTypes.FIELD_DOUBLE_NULL));
-        assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
-    }
-
-    // Test max on nullable rows with partial null values
-    @Test
-    public void max_partialNullRows() {
-        populatePartialNullRowsForNumericTesting();
-
-        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
-        assertEquals(1, results.max(NullTypes.FIELD_INTEGER_NULL).intValue());
-        assertEquals(2f, results.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
-        assertEquals(3d, results.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-    }
-
-    @Test
-    public void sum() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-
-        Number sum = resultList.sum(AllTypes.FIELD_LONG);
-        // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
-    }
-
-    // Test sum on nullable rows with all null values
-    @Test
-    public void sum_nullRows() {
-        TestHelper.populateAllNullRowsForNumericTesting(realm);
-
-        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
-        assertEquals(0, resultList.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
-        assertEquals(0f, resultList.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
-        assertEquals(0d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-    }
-
-    // Test sum on nullable rows with partial null values
-    @Test
-    public void sum_partialNullRows() {
-        populatePartialNullRowsForNumericTesting();
-        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
-
-        assertEquals(1, resultList.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
-        assertEquals(2f, resultList.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
-        assertEquals(3d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-    }
-
-    @Test
-    public void sum_nonLatinColumnNames() {
-        RealmResults<NonLatinFieldNames> resultList = realm.where(NonLatinFieldNames.class).findAll();
-
-        Number sum = resultList.sum(NonLatinFieldNames.FIELD_LONG_KOREAN_CHAR);
-        // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
-
-        sum = resultList.sum(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR);
-        // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
-    }
-
-    @Test
-    public void avg() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        double N = (double) TEST_DATA_SIZE;
-
-        // Sum of numbers 1 to M: M*(M+1)/2
-        // See setUp() for values of fields
-        // N = TEST_DATA_SIZE
-
-        // Type: double; a = 3.1415
-        // a, a+1, ..., a+i, ..., a+N-1
-        // sum = 3.1415*N + N*(N-1)/2
-        // average = sum/N = 3.1415+(N-1)/2
-        double average = 3.1415 + (N - 1.0) * 0.5;
-        assertEquals(average, resultList.average(AllTypes.FIELD_DOUBLE), 0.0001);
-
-        // Type: long
-        // 0, 1, ..., N-1
-        // sum = N*(N-1)/2
-        // average = sum/N = (N-1)/2
-        assertEquals(0.5 * (N - 1), resultList.average(AllTypes.FIELD_LONG), 0.0001);
-
-        // Type: float; b = 1.234567
-        // b, b+1, ..., b+i, ..., b+N-1
-        // sum = b*N + N*(N-1)/2
-        // average = sum/N = b + (N-1)/2
-        assertEquals(1.234567 + 0.5 * (N - 1.0), resultList.average(AllTypes.FIELD_FLOAT), 0.0001);
-    }
-
-    // Test average on empty columns
-    @Test
-    public void avg_emptyNonNullFields() {
-        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
-
-        assertEquals(0d, resultList.average(NullTypes.FIELD_INTEGER_NOT_NULL), 0d);
-        assertEquals(0d, resultList.average(NullTypes.FIELD_FLOAT_NOT_NULL), 0d);
-        assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NOT_NULL), 0d);
-    }
-
-    // Test average on nullable rows with all null values
-    @Test
-    public void avg_emptyNullFields() {
-        TestHelper.populateAllNullRowsForNumericTesting(realm);
-
-        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
-        assertEquals(0d, resultList.average(NullTypes.FIELD_INTEGER_NULL), 0d);
-        assertEquals(0d, resultList.average(NullTypes.FIELD_FLOAT_NULL), 0d);
-        assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
-    }
-
-    // Test average on nullable rows with partial null values
-    @Test
-    public void avg_partialNullRows() {
-        populatePartialNullRowsForNumericTesting();
-        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
-
-        assertEquals(0.5, resultList.average(NullTypes.FIELD_INTEGER_NULL), 0d);
-        assertEquals(1.0, resultList.average(NullTypes.FIELD_FLOAT_NULL), 0d);
-        assertEquals(1.5, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
-    }
-
-    @Test
-    public void remove() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        realm.beginTransaction();
-        resultList.remove(0);
-        realm.commitTransaction();
-
-        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
-
-        AllTypes allTypes = resultList.get(0);
-        assertEquals(1, allTypes.getColumnLong());
-    }
-
-    @Test
-    public void removeLast() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        realm.beginTransaction();
-        resultList.removeLast();
-        realm.commitTransaction();
-
-        assertEquals("ResultList.removeLast did not remove record", TEST_DATA_SIZE - 1, resultList.size());
-
-        AllTypes allTypes = resultList.get(resultList.size() - 1);
-        assertEquals("ResultList.removeLast unexpected last record", TEST_DATA_SIZE - 2, allTypes.getColumnLong());
-
-        RealmResults<AllTypes> resultListCheck = realm.where(AllTypes.class).findAll();
-        assertEquals("ResultList.removeLast not committed", TEST_DATA_SIZE - 1, resultListCheck.size());
-    }
-
-    @Test
-    public void sort_long() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = realm.allObjects(AllTypes.class);
-        sortedList.sort(AllTypes.FIELD_LONG, Sort.DESCENDING);
-        assertEquals("Should have same size", resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("First excepted to be last", resultList.first().getColumnLong(), sortedList.last().getColumnLong());
-
-        sortedList.sort(AllTypes.FIELD_LONG, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("First excepted to be first", resultList.first().getColumnLong(), sortedList.first().getColumnLong());
-        assertEquals("Last excepted to be last", resultList.last().getColumnLong(), sortedList.last().getColumnLong());
-
-        sortedList.sort(AllTypes.FIELD_LONG, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-    }
-
-    @Test
-    public void sort_date() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(AllTypes.FIELD_DATE, Sort.DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnDate(), sortedList.last().getColumnDate());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(AllTypes.FIELD_DATE, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnDate(), reverseList.first().getColumnDate());
-        assertEquals(resultList.last().getColumnDate(), reverseList.last().getColumnDate());
-
-        RealmResults<AllTypes> reserveSortedList = reverseList.where().findAll();
-        reserveSortedList.sort(AllTypes.FIELD_DATE, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
-    }
-
-    @Test
-    public void sort_boolean() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(AllTypes.FIELD_BOOLEAN, Sort.DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(false, sortedList.last().isColumnBoolean());
-        assertEquals(true, sortedList.first().isColumnBoolean());
-        assertEquals(true, sortedList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
-        assertEquals(false, sortedList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(AllTypes.FIELD_BOOLEAN, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(true, reverseList.last().isColumnBoolean());
-        assertEquals(false, reverseList.first().isColumnBoolean());
-        assertEquals(false, reverseList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
-        assertEquals(true, reverseList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
-
-        RealmResults<AllTypes> reserveSortedList = reverseList.where().findAll();
-        reserveSortedList.sort(AllTypes.FIELD_BOOLEAN, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
-        assertEquals(reserveSortedList.first(), sortedList.first());
-    }
-
-    @Test
-    public void sort_string() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
-
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnString(), sortedList.last().getColumnString());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(AllTypes.FIELD_STRING, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnString(), reverseList.first().getColumnString());
-
-        int numberOfDigits = 1 + ((int) Math.log10(TEST_DATA_SIZE));
-        int largestNumber = 1;
-        for (int i = 1; i < numberOfDigits; i++)
-            largestNumber *= 10;  // 10*10* ... *10
-        largestNumber = largestNumber - 1;
-        assertEquals(resultList.get(largestNumber).getColumnString(), reverseList.last().getColumnString());
-        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
-        reverseList.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
-    }
-
-    @Test
-    public void sort_double() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(AllTypes.FIELD_DOUBLE, Sort.DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnDouble(), sortedList.last().getColumnDouble(), 0D);
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(AllTypes.FIELD_DOUBLE, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnDouble(), reverseList.first().getColumnDouble(), 0D);
-        assertEquals(resultList.last().getColumnDouble(), reverseList.last().getColumnDouble(), 0D);
-
-        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
-        reverseSortedList.sort(AllTypes.FIELD_DOUBLE, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
-    }
-
-    @Test
-    public void sort_float() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(AllTypes.FIELD_FLOAT, Sort.DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnFloat(), sortedList.last().getColumnFloat(), 0D);
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(AllTypes.FIELD_FLOAT, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnFloat(), reverseList.first().getColumnFloat(), 0D);
-        assertEquals(resultList.last().getColumnFloat(), reverseList.last().getColumnFloat(), 0D);
-
-        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
-        reverseSortedList.sort(AllTypes.FIELD_FLOAT, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
-    }
-
-    private void doTestSortOnColumnWithPartialNullValues(String fieldName) {
-        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
-        // Ascending
-        RealmResults<NullTypes> sortedList = realm.allObjects(NullTypes.class);
-        sortedList.sort(fieldName, Sort.ASCENDING);
-        assertEquals("Should have same size", resultList.size(), sortedList.size());
-        // Null should always be the first one in the ascending sorted list
-        assertEquals(2, sortedList.first().getId());
-        assertEquals(1, sortedList.last().getId());
-
-        // Descending
-        sortedList = realm.allObjects(NullTypes.class);
-        sortedList.sort(fieldName, Sort.DESCENDING);
-        assertEquals("Should have same size", resultList.size(), sortedList.size());
-        assertEquals(1, sortedList.first().getId());
-        // Null should always be the last one in the descending sorted list
-        assertEquals(2, sortedList.last().getId());
-    }
-
-    // Test sort on nullable fields with null values partially
-    @Test
-    public void sort_rowsWithPartialNullValues() {
-        populatePartialNullRowsForNumericTesting();
-
-        // 1 String
-        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_STRING_NULL);
-
-        // 3 Boolean
-        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_BOOLEAN_NULL);
-
-        // 6 Integer
-        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_INTEGER_NULL);
-
-        // 7 Float
-        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_FLOAT_NULL);
-
-        // 8 Double
-        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_DOUBLE_NULL);
-
-        // 10 Date
-        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_DATE_NULL);
-    }
-
-    @Test
-    public void sort_nonExistingColumn() {
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        thrown.expect(IllegalArgumentException.class);
-        resultList.sort("Non-existing");
-    }
-
-    @Test
-    public void sort_danishCharacters() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        AllTypes at1 = realm.createObject(AllTypes.class);
-        at1.setColumnString("Æble");
-        AllTypes at2 = realm.createObject(AllTypes.class);
-        at2.setColumnString("Øl");
-        AllTypes at3 = realm.createObject(AllTypes.class);
-        at3.setColumnString("Århus");
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(AllTypes.FIELD_STRING);
-
-        assertEquals(3, sortedResult.size());
-        assertEquals("Æble", sortedResult.first().getColumnString());
-        assertEquals("Æble", sortedResult.get(0).getColumnString());
-        assertEquals("Øl", sortedResult.get(1).getColumnString());
-        assertEquals("Århus", sortedResult.get(2).getColumnString());
-
-        RealmResults<AllTypes> reverseResult = result.where().findAll();
-        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(3, reverseResult.size());
-        assertEquals("Æble", reverseResult.last().getColumnString());
-        assertEquals("Århus", reverseResult.get(0).getColumnString());
-        assertEquals("Øl", reverseResult.get(1).getColumnString());
-        assertEquals("Æble", reverseResult.get(2).getColumnString());
-    }
-
-    @Test
-    public void sort_russianCharacters() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        AllTypes at1 = realm.createObject(AllTypes.class);
-        at1.setColumnString("Санкт-Петербург");
-        AllTypes at2 = realm.createObject(AllTypes.class);
-        at2.setColumnString("Москва");
-        AllTypes at3 = realm.createObject(AllTypes.class);
-        at3.setColumnString("Новороссийск");
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(AllTypes.FIELD_STRING);
-
-        assertEquals(3, sortedResult.size());
-        assertEquals("Москва", sortedResult.first().getColumnString());
-        assertEquals("Москва", sortedResult.get(0).getColumnString());
-        assertEquals("Новороссийск", sortedResult.get(1).getColumnString());
-        assertEquals("Санкт-Петербург", sortedResult.get(2).getColumnString());
-
-        RealmResults<AllTypes> reverseResult = result.where().findAll();
-        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(3, reverseResult.size());
-        assertEquals("Москва", reverseResult.last().getColumnString());
-        assertEquals("Санкт-Петербург", reverseResult.get(0).getColumnString());
-        assertEquals("Новороссийск", reverseResult.get(1).getColumnString());
-        assertEquals("Москва", reverseResult.get(2).getColumnString());
-    }
-
-    @Test
-    public void sort_greekCharacters() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        AllTypes at1 = realm.createObject(AllTypes.class);
-        at1.setColumnString("αύριο");
-        AllTypes at2 = realm.createObject(AllTypes.class);
-        at2.setColumnString("ημέρες");
-        AllTypes at3 = realm.createObject(AllTypes.class);
-        at3.setColumnString("δοκιμές");
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(AllTypes.FIELD_STRING);
-
-        assertEquals(3, sortedResult.size());
-        assertEquals("αύριο", sortedResult.first().getColumnString());
-        assertEquals("αύριο", sortedResult.get(0).getColumnString());
-        assertEquals("δοκιμές", sortedResult.get(1).getColumnString());
-        assertEquals("ημέρες", sortedResult.get(2).getColumnString());
-
-        RealmResults<AllTypes> reverseResult = result.where().findAll();
-        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(3, reverseResult.size());
-        assertEquals("αύριο", reverseResult.last().getColumnString());
-        assertEquals("ημέρες", reverseResult.get(0).getColumnString());
-        assertEquals("δοκιμές", reverseResult.get(1).getColumnString());
-        assertEquals("αύριο", reverseResult.get(2).getColumnString());
-    }
-
-    //No sorting order defined. There are Korean, Arabic and Chinese characters.
-    @Test
-    public void sort_manyDifferentCharacters() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        AllTypes at1 = realm.createObject(AllTypes.class);
-        at1.setColumnString("단위");
-        AllTypes at2 = realm.createObject(AllTypes.class);
-        at2.setColumnString("테스트");
-        AllTypes at3 = realm.createObject(AllTypes.class);
-        at3.setColumnString("وحدة");
-        AllTypes at4 = realm.createObject(AllTypes.class);
-        at4.setColumnString("اختبار");
-        AllTypes at5 = realm.createObject(AllTypes.class);
-        at5.setColumnString("单位");
-        AllTypes at6 = realm.createObject(AllTypes.class);
-        at6.setColumnString("试验");
-        AllTypes at7 = realm.createObject(AllTypes.class);
-        at7.setColumnString("單位");
-        AllTypes at8 = realm.createObject(AllTypes.class);
-        at8.setColumnString("測試");
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(AllTypes.FIELD_STRING);
-
-        assertEquals(8, sortedResult.size());
-
-        @SuppressWarnings("UnnecessaryLocalVariable")
-        RealmResults<AllTypes> reverseResult = result;
-        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
-        assertEquals(8, reverseResult.size());
-    }
-
-    @Test
-    public void sort_twoLanguages() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        AllTypes allTypes1 = realm.createObject(AllTypes.class);
-        allTypes1.setColumnString("test");
-        AllTypes allTypes2 = realm.createObject(AllTypes.class);
-        allTypes2.setColumnString("αύριο");
-        AllTypes allTypes3 = realm.createObject(AllTypes.class);
-        allTypes3.setColumnString("work");
-        realm.commitTransaction();
-
-        try {
-            RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-            result.sort(AllTypes.FIELD_STRING);
-        } catch (IllegalArgumentException e) {
-            fail("Failed to sort with two kinds of alphabets");
-        }
-    }
-
-    @Test
-    public void sort_usingChildObject() {
-        realm.beginTransaction();
-        Owner owner = realm.createObject(Owner.class);
-        owner.setName("owner");
-        Cat cat = realm.createObject(Cat.class);
-        cat.setName("cat");
-        owner.setCat(cat);
-        realm.commitTransaction();
-
-        RealmQuery<Owner> query = realm.where(Owner.class);
-        RealmResults<Owner> owners = query.findAll();
-
-        try {
-            owners.sort("cat.name");
-            fail("Sorting by child object properties should result in a IllegalArgumentException");
-        } catch (IllegalArgumentException ignore) {
-        }
-    }
-
-    @Test
-    public void sort_nullArguments() {
-        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
-        try {
-            result.sort(null);
-            fail("Sorting with a null field name should throw an IllegalArgumentException");
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            result.sort((String) null, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void sort_emptyResults() {
-        realm.beginTransaction();
-        realm.clear(AllTypes.class);
-        realm.commitTransaction();
-        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        assertEquals(0, results.size());
-        results.sort(AllTypes.FIELD_STRING);
-        assertEquals(0, results.size());
-    }
-
-    @Test
-    public void sort_singleField() {
-        RealmResults<AllTypes> sortedList = realm.allObjects(AllTypes.class);
-        sortedList.sort(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
-        assertEquals(0, sortedList.last().getColumnLong());
-    }
-
-    @Test
-    public void count() {
-        assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
-    }
-
     @Test
     public void findFirst() {
         AllTypes result = realm.where(AllTypes.class).findFirst();
@@ -894,117 +121,6 @@ public void findFirst() {
         assertNull(none);
     }
 
-    @Test
-    public void where_equalTo_manyConditions() {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
-        query.equalTo(AllTypes.FIELD_LONG, 0);
-        for (int i = 1; i < TEST_DATA_SIZE; i++) {
-            query.or().equalTo(AllTypes.FIELD_LONG, i);
-        }
-        RealmResults<AllTypes> allTypesRealmResults = query.findAll();
-        assertEquals(TEST_DATA_SIZE, allTypesRealmResults.size());
-    }
-
-    @Test
-    public void where() {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
-        assertNotNull(query);
-    }
-
-    @Test
-    public void where_contains() {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
-        AllTypes item = query.findFirst();
-        assertTrue("Item should exist in results.", query.findAll().contains(item));
-    }
-
-    @Test
-    public void where_contains_null() {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
-        assertFalse("Should not contain a null item.", query.findAll().contains(null));
-    }
-
-    @Test
-    public void where_shouldNotContainRemovedItem() {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
-        AllTypes item = realm.where(AllTypes.class).findFirst();
-        realm.beginTransaction();
-        item.removeFromRealm();
-        realm.commitTransaction();
-        assertFalse("Should not contain a removed item.", query.findAll().contains(item));
-    }
-
-    /**
-     * Test to see if a particular item that does exist in the same Realm does not
-     * exist in the result set of another query.
-     */
-    @Test
-    public void where_lessThanGreaterThan() {
-        RealmResults<AllTypes> items = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 1000).findAll();
-        AllTypes anotherType = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_LONG, 1000).findFirst();
-        assertFalse("Should not be able to find item in another result list.", items.contains(anotherType));
-    }
-
-    // Tests that `contains()` correctly doesn't find RealmObjects that belongs to another Realm file.
-    @Test
-    public void contains_realmObjectFromOtherRealm() {
-        RealmConfiguration realmConfig = configFactory.createConfiguration("contains_test.realm");
-        Realm realmTwo = Realm.getInstance(realmConfig);
-        try {
-
-            realmTwo.beginTransaction();
-            realmTwo.allObjects(AllTypes.class).clear();
-            realmTwo.allObjects(NonLatinFieldNames.class).clear();
-
-            for (int i = 0; i < TEST_DATA_SIZE; ++i) {
-                AllTypes allTypes = realmTwo.createObject(AllTypes.class);
-                allTypes.setColumnBoolean((i % 2) == 0);
-                allTypes.setColumnBinary(new byte[]{1, 2, 3});
-                allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - TEST_DATA_SIZE / 2)));
-                allTypes.setColumnDouble(3.1415 + i);
-                allTypes.setColumnFloat(1.234567f + i);
-                allTypes.setColumnString("test data " + i);
-                allTypes.setColumnLong(i);
-                Dog d = realmTwo.createObject(Dog.class);
-                d.setName("Foo " + i);
-                allTypes.setColumnRealmObject(d);
-                allTypes.getColumnRealmList().add(d);
-                NonLatinFieldNames nonLatinFieldNames = realmTwo.createObject(NonLatinFieldNames.class);
-                nonLatinFieldNames.set델타(i);
-                nonLatinFieldNames.setΔέλτα(i);
-            }
-            realmTwo.commitTransaction();
-
-            final AllTypes item = realmTwo.where(AllTypes.class).findFirst();
-
-            assertFalse("Should not be able to find one object in another Realm via RealmResults#contains",
-                    realm.where(AllTypes.class).findAll().contains(item));
-
-        } finally {
-            if (realmTwo != null && !realmTwo.isClosed()) {
-                realmTwo.close();
-            }
-        }
-    }
-
-    @Test
-    public void where_findAll_size() {
-        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE, allTypes.size());
-
-        // querying a RealmResults should find objects that fulfill the condition
-        RealmResults<AllTypes> onedigits = allTypes.where().lessThan(AllTypes.FIELD_LONG, 10).findAll();
-        assertEquals(Math.min(10, TEST_DATA_SIZE), onedigits.size());
-
-        // if no objects fulfill conditions, the result has zero objects
-        RealmResults<AllTypes> none = allTypes.where().greaterThan(AllTypes.FIELD_LONG, TEST_DATA_SIZE).findAll();
-        assertEquals(0, none.size());
-
-        // querying a result with zero objects must give zero objects
-        RealmResults<AllTypes> stillNone = none.where().greaterThan(AllTypes.FIELD_LONG, TEST_DATA_SIZE).findAll();
-        assertEquals(0, stillNone.size());
-    }
-
     @Test
     public void size_returns_Integer_MAX_VALUE_for_huge_results() {
         final Table table = Mockito.mock(Table.class);
@@ -1018,56 +134,6 @@ public void size_returns_Integer_MAX_VALUE_for_huge_results() {
         assertEquals(Integer.MAX_VALUE, targetResult.size());
     }
 
-    @Test
-    public void where_findAllSorted() {
-        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.ASCENDING);
-        assertEquals(TEST_DATA_SIZE, allTypes.size());
-        assertEquals(0, allTypes.first().getColumnLong());
-        assertEquals(TEST_DATA_SIZE - 1, allTypes.last().getColumnLong());
-
-        RealmResults<AllTypes> reverseList = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(0, reverseList.last().getColumnLong());
-        assertEquals(TEST_DATA_SIZE - 1, reverseList.first().getColumnLong());
-
-        try {
-            realm.where(AllTypes.class).findAllSorted("invalid",
-                    Sort.DESCENDING);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void where_queryDateField() {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(YEAR_MILLIS * 5));
-        RealmResults<AllTypes> all = query.findAll();
-        assertEquals(1, query.count());
-        assertEquals(1, all.size());
-
-        // before 1901
-        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(YEAR_MILLIS * -100));
-        all = query.findAll();
-        assertEquals(1, query.count());
-        assertEquals(1, all.size());
-
-        // after 2038
-        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(YEAR_MILLIS * 100));
-        all = query.findAll();
-        assertEquals(1, query.count());
-        assertEquals(1, all.size());
-    }
-
-    @Test
-    public void indexOf() {
-        try {
-            RealmResults<AllTypes> all = realm.allObjects(AllTypes.class);
-            all.indexOf(all.first());
-            fail();
-        } catch (NoSuchMethodError ignored) {
-        }
-    }
-
     @Test
     public void subList() {
         RealmResults<AllTypes> list = realm.allObjects(AllTypes.class);
@@ -1076,196 +142,53 @@ public void subList() {
         assertEquals(TEST_DATA_SIZE - 1, sublist.get(sublist.size() - 1).getColumnLong());
     }
 
-    // Setting a not-nullable field to null is an error
-    // TODO Move this to RealmObjectTests?
-    @Test
-    public void setter_nullValueInRequiredField() {
-        TestHelper.populateTestRealmForNullTests(realm);
-        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
-
-        // 1 String
-        try {
-            realm.beginTransaction();
-            list.first().setFieldStringNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-
-        // 2 Bytes
-        try {
-            realm.beginTransaction();
-            list.first().setFieldBytesNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-
-        // 3 Boolean
-        try {
-            realm.beginTransaction();
-            list.first().setFieldBooleanNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-
-        // 4 Byte
-        try {
-            realm.beginTransaction();
-            list.first().setFieldBytesNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-
-        // 5 Short 6 Integer 7 Long are skipped for this case, same with Bytes
-
-        // 8 Float
-        try {
-            realm.beginTransaction();
-            list.first().setFieldFloatNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-
-        // 9 Double
-        try {
-            realm.beginTransaction();
-            list.first().setFieldDoubleNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-
-        // 10 Date
-        try {
-            realm.beginTransaction();
-            list.first().setFieldDateNotNull(null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            realm.cancelTransaction();
-        }
-    }
-
-    // Setting a nullable field to null is not an error
-    // TODO Move this to RealmObjectsTest?
-    @Test
-    public void setter_nullValueInNullableField() {
-        TestHelper.populateTestRealmForNullTests(realm);
-        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
-
-        // 1 String
-        realm.beginTransaction();
-        list.first().setFieldStringNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldStringNull());
-
-        // 2 Bytes
-        realm.beginTransaction();
-        list.first().setFieldBytesNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldBytesNull());
-
-        // 3 Boolean
-        realm.beginTransaction();
-        list.first().setFieldBooleanNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldBooleanNull());
-
-        // 4 Byte
-        // 5 Short 6 Integer 7 Long are skipped
-        realm.beginTransaction();
-        list.first().setFieldByteNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldByteNull());
-
-        // 8 Float
-        realm.beginTransaction();
-        list.first().setFieldFloatNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldFloatNull());
-
-        // 9 Double
-        realm.beginTransaction();
-        list.first().setFieldDoubleNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldDoubleNull());
-
-        // 10 Date
-        realm.beginTransaction();
-        list.first().setFieldDateNull(null);
-        realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldDateNull());
-    }
-
+    @SuppressWarnings("deprecation")
     @Test
     public void unsupportedMethods() {
-        RealmResults<AllTypes> result = realm.where(AllTypes.class).findAll();
-
-        try { //noinspection deprecation
-            result.add(null);
-            fail();
-        } catch (UnsupportedOperationException ignored) {
-        }
-        try {
-            result.set(0, null);
-            fail();
-        } catch (UnsupportedOperationException ignored) {
+        for (CollectionMutatorMethod method : CollectionMutatorMethod.values()) {
+            try {
+                switch (method) {
+                    case ADD_OBJECT: collection.add(new AllTypes());
+                    case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllTypes())); break;
+                    case CLEAR: collection.clear(); break;
+                    case REMOVE_OBJECT: collection.remove(new AllTypes());
+                    case REMOVE_ALL: collection.removeAll(Collections.singletonList(new AllTypes())); break;
+                    case RETAIN_ALL: collection.retainAll(Collections.singletonList(new AllTypes())); break;
+
+                    // Supported methods
+                    case DELETE_ALL:
+                        continue;
+                }
+                fail("Unknown method or failed to throw:" + method);
+            } catch (UnsupportedOperationException ignored) {
+            }
         }
-    }
 
-
-    // Test that all methods that require a transaction (ie. any function that mutates Realm data)
-    @Test
-    public void mutableMethodsOutsideTransactions() {
-        RealmResults<AllTypes> result = realm.where(AllTypes.class).findAll();
-
-        try {
-            result.clear();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-        try {
-            result.remove(0);
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-        try {
-            result.removeLast();
-            fail();
-        } catch (IllegalStateException ignored) {
+        for (OrderedCollectionMutatorMethod method : OrderedCollectionMutatorMethod.values()) {
+            try {
+                switch (method) {
+                    case ADD_INDEX: collection.add(0, new AllTypes()); break;
+                    case ADD_ALL_INDEX: collection.addAll(0, Collections.singletonList(new AllTypes())); break;
+                    case SET: collection.set(0, new AllTypes()); break;
+                    case REMOVE_INDEX: collection.remove(0); break;
+
+                    // Supported methods
+                    case DELETE_INDEX:
+                    case DELETE_FIRST:
+                    case DELETE_LAST:
+                        continue;
+                }
+                fail("Unknown method or failed to throw:" + method);
+            } catch (UnsupportedOperationException ignored) {
+            }
         }
     }
 
-    // TODO: More extended tests of querying all types must be done.
-
-    @Test
-    public void isValid() {
-        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-
-        assertTrue(results.isValid());
-        populateTestRealm(1);
-        // still valid if result changed
-        assertTrue(results.isValid());
-
-        realm.close();
-        assertFalse(results.isValid());
-    }
-
     // Triggered an ARM bug
     @Test
     public void verifyArmComparisons() {
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         long id = -1;
         for (int i = 0; i < 10; i++) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -1343,7 +266,6 @@ public void distinct_restrictedByPreviousDistinct() {
         // all three results are the same object
         assertTrue(allResults == distinctDates);
         assertTrue(allResults == distinctBooleans);
-        assertTrue(distinctDates == distinctBooleans);
     }
 
     @Test
@@ -1441,16 +363,9 @@ public void distinct_invalidTypesLinkedFields() {
     }
 
     // distinctAsync
-    private Realm openRealmInstance(String name) {
-        RealmConfiguration config = configFactory.createConfiguration(name);
-        Realm.deleteRealm(config);
-        return Realm.getInstance(config);
-    }
-
     private void populateTestRealm(Realm testRealm, int objects) {
         testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        testRealm.deleteAll();
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
@@ -1695,12 +610,12 @@ public void distinctMultiArgs_emptyField() {
         }
         // a null string field in the middle
         try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, null, AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
         // a null string field at the end
         try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, null);
         } catch (IllegalArgumentException ignored) {
         }
         // (String)null makes varargs a null array.
@@ -1710,17 +625,17 @@ public void distinctMultiArgs_emptyField() {
         }
         // Two (String)null for first and varargs fields
         try {
-            results.distinct((String)null, (String)null);
+            results.distinct(null, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String)null combination
         try {
-            results.distinct("", (String)null);
+            results.distinct("", (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String)null combination
         try {
-            results.distinct((String)null, "");
+            results.distinct(null, "");
         } catch (IllegalArgumentException ignored) {
         }
         // Two empty fields tests
@@ -1828,10 +743,9 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
 
 
         RealmResults<Dog> dogs = owner.getDogs().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
-        //dogs = dogs.where().findFirst().getOwner().getDogs().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
 
         realm.beginTransaction();
-        owner.removeFromRealm();
+        owner.deleteFromRealm();
         realm.commitTransaction();
         return dogs;
     }
@@ -1851,7 +765,7 @@ public void size_resultsBuiltOnDeletedLinkView() {
     public void first_resultsBuiltOnDeletedLinkView() {
         try {
             populateRealmResultsOnDeletedLinkView().first();
-        } catch (ArrayIndexOutOfBoundsException ignored) {
+        } catch (IndexOutOfBoundsException ignored) {
         }
     }
 
@@ -1859,7 +773,7 @@ public void first_resultsBuiltOnDeletedLinkView() {
     public void last_resultsBuiltOnDeletedLinkView() {
         try {
             populateRealmResultsOnDeletedLinkView().last();
-        } catch (ArrayIndexOutOfBoundsException ignored) {
+        } catch (IndexOutOfBoundsException ignored) {
         }
     }
 
@@ -1880,42 +794,186 @@ public void average_resultsBuiltOnDeletedLinkView() {
     }
 
     @Test
-    public void clear_resultsBuiltOnDeletedLinkView() {
-        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
+    public void where_resultsBuiltOnDeletedLinkView() {
+        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
+        assertEquals(0, results.where().findAll().size());
+    }
+
+    @Test
+    public void min_resultsBuiltOnDeletedLinkView() {
+        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
+        assertNull(results.min(CyclicType.FIELD_ID));
+    }
+
+    @Test
+    public void min_dateResultsBuiltOnDeletedLinkView() {
+        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
+        assertEquals(null, results.minDate(CyclicType.FIELD_DATE));
+    }
+
+    @Test
+    public void max_dateResultsBuiltOnDeletedLinkView() {
+        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
+        assertEquals(null, results.maxDate(CyclicType.FIELD_DATE));
+    }
+
+    @Test
+    public void max_resultsBuiltOnDeletedLinkView() {
+        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
+        assertNull(results.max(CyclicType.FIELD_ID));
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener() {
+        Realm realm = looperThread.realm;
+        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+
+        collection.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                looperThread.testComplete();
+            }
+        });
+
         realm.beginTransaction();
-        dogs.clear();
-        assertEquals(0, dogs.size());
+        realm.createObject(AllTypes.class);
         realm.commitTransaction();
     }
 
     @Test
-    public void max_resultsBuiltOnDeletedLinkView() {
-        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
-        assertNull(dogs.max(Dog.FIELD_AGE));
-        assertNull(dogs.max(Dog.FIELD_HEIGHT));
-        assertNull(dogs.max(Dog.FIELD_WEIGHT));
+    @RunTestInLooperThread
+    public void addChangeListener_twice() {
+        final AtomicInteger listenersTriggered = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenersTriggered.incrementAndGet();
+            }
+        };
+
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenersTriggered.incrementAndGet();
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (listenersTriggered.get() == 1) {
+                            looperThread.testComplete();
+                        } else {
+                            fail("Only global listener should be triggered");
+                        }
+                    }
+                });
+            }
+        });
+
+        // Adding it twice will be ignored, so removing it will not cause the listener to be triggered.
+        collection.addChangeListener(listener);
+        collection.addChangeListener(listener);
+        collection.removeChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
     }
 
     @Test
-    public void max_dateResultsBuiltOnDeletedLinkView() {
-        assertEquals(null, populateRealmResultsOnDeletedLinkView().maxDate(Dog.FIELD_BIRTHDAY));
+    @UiThreadTest
+    public void addChangeListener_null() {
+        try {
+            collection.addChangeListener(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     @Test
-    public void min_resultsBuiltOnDeletedLinkView() {
-        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
-        assertNull(dogs.min(Dog.FIELD_AGE));
-        assertNull(dogs.min(Dog.FIELD_HEIGHT));
-        assertNull(dogs.min(Dog.FIELD_WEIGHT));
+    @RunTestInLooperThread
+    public void removeChangeListener() {
+        final AtomicInteger listenersTriggered = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenersTriggered.incrementAndGet();
+            }
+        };
+
+        collection.addChangeListener(listener);
+        collection.removeChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        // The above commit should have put a REALM_CHANGED event on the Looper queue before this runnable.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                if (listenersTriggered.get() == 0) {
+                    looperThread.testComplete();
+                } else {
+                    fail("Listener wasn't removed");
+                }
+            }
+        });
     }
 
     @Test
-    public void minDateResultsBuiltOnDeletedLinkView() {
-        assertEquals(null, populateRealmResultsOnDeletedLinkView().minDate(Dog.FIELD_BIRTHDAY));
+    @UiThreadTest
+    public void removeChangeListener_null() {
+        try {
+            collection.removeChangeListener(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     @Test
-    public void whereResultsBuiltOnDeletedLinkView() {
-        assertEquals(0, populateRealmResultsOnDeletedLinkView().where().findAll().size());
+    @RunTestInLooperThread
+    public void removeAllChangeListeners() {
+        final AtomicInteger listenersTriggered = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+
+        RealmChangeListener listenerA = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenersTriggered.incrementAndGet();
+            }
+        };
+        RealmChangeListener listenerB = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenersTriggered.incrementAndGet();
+            }
+        };
+
+        collection.addChangeListener(listenerA);
+        collection.addChangeListener(listenerB);
+        collection.removeChangeListeners();
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        // The above commit should have put a REALM_CHANGED event on the Looper queue before this runnable.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                if (listenersTriggered.get() == 0) {
+                    looperThread.testComplete();
+                } else {
+                    fail("Listeners wasn't removed");
+                }
+            }
+        });
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 2f42aaeb33..e9969b0fb2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -136,8 +136,7 @@ public void tearDown() {
 
     private void populateTestRealm(Realm realm, int objects) {
         realm.beginTransaction();
-        realm.allObjects(AllTypes.class).clear();
-        realm.allObjects(NonLatinFieldNames.class).clear();
+        realm.deleteAll();
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
@@ -145,6 +144,7 @@ private void populateTestRealm(Realm realm, int objects) {
             allTypes.setColumnDate(new Date());
             allTypes.setColumnDouble(3.1415);
             allTypes.setColumnFloat(1.234567f + i);
+
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
             NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
@@ -185,6 +185,26 @@ public void getInstance_writeProtectedFile() throws IOException {
         Realm.getInstance(new RealmConfiguration.Builder(folder).name(REALM_FILE).build());
     }
 
+    @Test
+    public void getInstance_twiceWhenRxJavaUnavailable() {
+        // test for https://github.com/realm/realm-java/issues/2416
+
+        // Though it's not a recommended way to create multiple configuration instance with the same parameter, it's legal.
+        final RealmConfiguration configuration1 = configFactory.createConfiguration("no_RxJava.realm");
+        TestHelper.emulateRxJavaUnavailable(configuration1);
+        final RealmConfiguration configuration2 = configFactory.createConfiguration("no_RxJava.realm");
+        TestHelper.emulateRxJavaUnavailable(configuration2);
+
+        final Realm realm1 = Realm.getInstance(configuration1);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            final Realm realm2 = Realm.getInstance(configuration2);
+            realm2.close();
+        } finally {
+            realm1.close();
+        }
+    }
+
     @Test
     public void checkIfValid() {
         // checkIfValid() must not throw any Exception against valid Realm instance.
@@ -626,8 +646,8 @@ public void nestedTransaction() {
         METHOD_BEGIN,
         METHOD_COMMIT,
         METHOD_CANCEL,
-        METHOD_CLEAR,
-        METHOD_CLEAR_ALL,
+        METHOD_DELETE_TYPE,
+        METHOD_DELETE_ALL,
         METHOD_DISTINCT,
         METHOD_CREATE_OBJECT,
         METHOD_COPY_TO_REALM,
@@ -659,10 +679,10 @@ public Boolean call() throws Exception {
                         case METHOD_CANCEL:
                             realm.cancelTransaction();
                             break;
-                        case METHOD_CLEAR:
-                            realm.clear(AllTypes.class);
+                        case METHOD_DELETE_TYPE:
+                            realm.delete(AllTypes.class);
                             break;
-                        case METHOD_CLEAR_ALL:
+                        case METHOD_DELETE_ALL:
                             realm.deleteAll();
                             break;
                         case METHOD_DISTINCT:
@@ -828,14 +848,13 @@ public void execute(Realm realm) {
     }
 
     @Test
-    public void clear_type() {
-        // ** clear non existing table should succeed
-
+    public void delete_type() {
+        // ** delete non existing table should succeed
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         realm.commitTransaction();
 
-        // ** clear existing class, but leave other classes classes
+        // ** delete existing class, but leave other classes classes
 
         // Add two classes
         populateTestRealm();
@@ -845,7 +864,7 @@ public void clear_type() {
         realm.commitTransaction();
         // Clear
         realm.beginTransaction();
-        realm.clear(Dog.class);
+        realm.delete(Dog.class);
         realm.commitTransaction();
         // Check one class is cleared but other class is still there
         RealmResults<AllTypes> resultListTypes = realm.where(AllTypes.class).findAll();
@@ -853,9 +872,9 @@ public void clear_type() {
         RealmResults<Dog> resultListDogs = realm.where(Dog.class).findAll();
         assertEquals(0, resultListDogs.size());
 
-        // ** clear() must throw outside a transaction
+        // ** delete() must throw outside a transaction
         try {
-            realm.clear(AllTypes.class);
+            realm.delete(AllTypes.class);
             fail("Expected exception");
         } catch (IllegalStateException ignored) {
         }
@@ -896,7 +915,7 @@ public void realmConfiguration_fileName() {
     @Test
     public void utf8Tests() {
         realm.beginTransaction();
-        realm.clear(AllTypes.class);
+        realm.delete(AllTypes.class);
         realm.commitTransaction();
 
         String file = "assets/unicode_codepoints.csv";
@@ -977,7 +996,7 @@ public void unicodeStrings() {
             realm.allObjects(StringOnly.class).get(0).getChars();
 
             realm.beginTransaction();
-            realm.clear(StringOnly.class);
+            realm.delete(StringOnly.class);
             realm.commitTransaction();
         }
     }
@@ -1343,6 +1362,36 @@ public void copyToRealm_list() {
         assertEquals(dog2.getName(), copiedList.get(1).getName());
     }
 
+    @Test
+    public void copyToRealm_objectInOtherThreadThrows() {
+        final CountDownLatch bgThreadDoneLatch = new CountDownLatch(1);
+
+        realm.beginTransaction();
+        final Dog dog = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                final Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                try {
+                    bgRealm.copyToRealm(dog);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals("Objects which belong to Realm instances in other threads cannot be copied into this" +
+                                    " Realm instance.",
+                            expected.getMessage());
+                }
+                bgRealm.cancelTransaction();
+                bgRealm.close();
+                bgThreadDoneLatch.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgThreadDoneLatch);
+    }
+
     @Test
     public void copyToRealmOrUpdate_null() {
         realm.beginTransaction();
@@ -1597,6 +1646,68 @@ public void copyToRealmOrUpdate_iterableChildObjects() {
         assertEquals(1, realm.allObjects(DogPrimaryKey.class).size());
     }
 
+    @Test
+    public void copyToRealmOrUpdate_objectInOtherThreadThrows() {
+        final CountDownLatch bgThreadDoneLatch = new CountDownLatch(1);
+
+        realm.beginTransaction();
+        final OwnerPrimaryKey ownerPrimaryKey = realm.createObject(OwnerPrimaryKey.class);
+        realm.commitTransaction();
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                final Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                try {
+                    bgRealm.copyToRealm(ownerPrimaryKey);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals("Objects which belong to Realm instances in other threads cannot be copied into this" +
+                                    " Realm instance.",
+                            expected.getMessage());
+                }
+                bgRealm.cancelTransaction();
+                bgRealm.close();
+                bgThreadDoneLatch.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgThreadDoneLatch);
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_listHasObjectInOtherThreadThrows() {
+        final CountDownLatch bgThreadDoneLatch = new CountDownLatch(1);
+        final OwnerPrimaryKey ownerPrimaryKey = new OwnerPrimaryKey();
+
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        realm.commitTransaction();
+        ownerPrimaryKey.setDogs(new RealmList<Dog>(dog));
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                final Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                try {
+                    bgRealm.copyToRealm(ownerPrimaryKey);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals("Objects which belong to Realm instances in other threads cannot be copied into this" +
+                                    " Realm instance.",
+                            expected.getMessage());
+                }
+                bgRealm.cancelTransaction();
+                bgRealm.close();
+                bgThreadDoneLatch.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgThreadDoneLatch);
+    }
+
     @Test
     public void getInstance_differentEncryptionKeys() {
         byte[] key1 = TestHelper.getRandomKey(42);
@@ -1855,8 +1966,8 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         try { realm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
         try { realm.remove(AllTypes.class, 0);      fail(); } catch (IllegalStateException expected) {}
-        try { realm.clear(AllTypes.class);          fail(); } catch (IllegalStateException expected) {}
-        try { realm.deleteAll();                        fail(); } catch (IllegalStateException expected) {}
+        try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
+        try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
 
         try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (RealmException expected) {}
         try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (RealmException expected) {}
@@ -2528,7 +2639,7 @@ public void isEmpty() {
     public void copyFromRealm_invalidObjectThrows() {
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
-        obj.removeFromRealm();
+        obj.deleteFromRealm();
         realm.commitTransaction();
 
         try {
@@ -2671,7 +2782,7 @@ public void copyFromRealm_list_invalidListThrows() {
         realm.beginTransaction();
         AllTypes object = realm.createObject(AllTypes.class);
         List<AllTypes> list = new RealmList<AllTypes>(object);
-        object.removeFromRealm();
+        object.deleteFromRealm();
         realm.commitTransaction();
 
         thrown.expect(IllegalArgumentException.class);
@@ -2957,7 +3068,7 @@ public void run() {
     }
 
     @Test
-    public void clear_all() {
+    public void deleteAll() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.createObject(Owner.class).setCat(realm.createObject(Cat.class));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index 9a352fc60d..ac2122a32d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -29,6 +29,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.CyclicType;
@@ -39,6 +40,7 @@
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.functions.Action1;
+import rx.functions.Func1;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -197,6 +199,23 @@ public void call(RealmResults<AllTypes> rxResults) {
         subscription.unsubscribe();
     }
 
+    @Test
+    @UiThreadTest
+    public void dynamicRealmResults_emittedOnSubscribe() {
+        final DynamicRealm dynamicRealm = DynamicRealm.createInstance(realm.getConfiguration());
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<DynamicRealmObject> results = dynamicRealm.allObjects(AllTypes.CLASS_NAME);
+        results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+            @Override
+            public void call(RealmResults<DynamicRealmObject> rxResults) {
+                assertTrue(rxResults == results);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        dynamicRealm.close();
+    }
+
     @Test
     @RunTestInLooperThread
     public void realmResults_emittedOnUpdate() {
@@ -220,6 +239,30 @@ public void call(RealmResults<AllTypes> allTypes) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmResults_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        final DynamicRealm dynamicRealm = DynamicRealm.createInstance(looperThread.realmConfiguration);
+        dynamicRealm.beginTransaction();
+        RealmResults<DynamicRealmObject> results = dynamicRealm.allObjects(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+
+        results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+            @Override
+            public void call(RealmResults<DynamicRealmObject> allTypes) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    dynamicRealm.close();
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        dynamicRealm.beginTransaction();
+        dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+    }
+
     @Test
     @UiThreadTest
     public void findAllAsync_emittedOnSubscribe() {
@@ -540,4 +583,178 @@ public void call(DynamicRealmObject obj) {
         assertTrue(dynamicRealm.isClosed());
     }
 
+    // Tests that Observables keep strong references to their parent, so they are not accidentally GC'ed while
+    // waiting for results from the async API's.
+    @Test
+    @RunTestInLooperThread
+    public void realmResults_gcStressTest() {
+        final int TEST_SIZE = 50;
+        final AtomicLong innerCounter = new AtomicLong();
+        final Realm realm = looperThread.realm;
+
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.createObject(AllTypes.class).setColumnLong(i);
+        }
+        realm.commitTransaction();
+
+        for (int i = 0; i < TEST_SIZE; i++) {
+            // Don't keep a reference to the Observable
+            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
+                    .filter(new Func1<RealmResults<AllTypes>, Boolean>() {
+                        @Override
+                        public Boolean call(RealmResults<AllTypes> results) {
+                            return results.isLoaded();
+                        }
+                    })
+                    .take(1) // Unsubscribes from Realm
+                    .subscribe(new Action1<RealmResults<AllTypes>>() {
+                        @Override
+                        public void call(RealmResults<AllTypes> result) {
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            Runtime.getRuntime().gc();
+                            if (innerCounter.incrementAndGet() == TEST_SIZE) {
+                                looperThread.testComplete();
+                            }
+                        }
+                    }, new Action1<Throwable>() {
+                        @Override
+                        public void call(Throwable throwable) {
+                            fail(throwable.toString());
+                        }
+                    });
+        }
+    }
+
+    // Tests that Observables keep strong references to their parent, so they are not accidentally GC'ed while
+    // waiting for results from the async API's.
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmResults_gcStressTest() {
+        final int TEST_SIZE = 50;
+        final AtomicLong innerCounter = new AtomicLong();
+        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.createObject(AllTypes.CLASS_NAME).set(AllTypes.FIELD_LONG, i);
+        }
+        realm.commitTransaction();
+
+        for (int i = 0; i < TEST_SIZE; i++) {
+            // Don't keep a reference to the Observable
+            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
+                    .filter(new Func1<RealmResults<DynamicRealmObject>, Boolean>() {
+                        @Override
+                        public Boolean call(RealmResults<DynamicRealmObject> results) {
+                            return results.isLoaded();
+                        }
+                    })
+                    .take(1) // Unsubscribes from Realm
+                    .subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+                        @Override
+                        public void call(RealmResults<DynamicRealmObject> result) {
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            Runtime.getRuntime().gc();
+                            if (innerCounter.incrementAndGet() == TEST_SIZE) {
+                                realm.close();
+                                looperThread.testComplete();
+                            }
+                        }
+                    }, new Action1<Throwable>() {
+                        @Override
+                        public void call(Throwable throwable) {
+                            fail(throwable.toString());
+                        }
+                    });
+        }
+    }
+
+    // Tests that Observables keep strong references to their parent, so they are not accidentally GC'ed while
+    // waiting for results from the async API's.
+    @Test
+    @RunTestInLooperThread
+    public void realmObject_gcStressTest() {
+        final int TEST_SIZE = 50;
+        final AtomicLong innerCounter = new AtomicLong();
+        final Realm realm = looperThread.realm;
+
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.createObject(AllTypes.class).setColumnLong(i);
+        }
+        realm.commitTransaction();
+
+        for (int i = 0; i < TEST_SIZE; i++) {
+            // Don't keep a reference to the Observable
+            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<AllTypes>asObservable()
+                    .filter(new Func1<AllTypes, Boolean>() {
+                        @Override
+                        public Boolean call(AllTypes obj) {
+                            return obj.isLoaded();
+                        }
+                    })
+                    .take(1) // Unsubscribes from Realm
+                    .subscribe(new Action1<AllTypes>() {
+                        @Override
+                        public void call(AllTypes result) {
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            Runtime.getRuntime().gc();
+                            if (innerCounter.incrementAndGet() == TEST_SIZE) {
+                                looperThread.testComplete();
+                            }
+                        }
+                    }, new Action1<Throwable>() {
+                        @Override
+                        public void call(Throwable throwable) {
+                            fail(throwable.toString());
+                        }
+                    });
+        }
+    }
+
+    // Tests that Observables keep strong references to their parent, so they are not accidentally GC'ed while
+    // waiting for results from the async API's.
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmObject_gcStressTest() {
+        final int TEST_SIZE = 50;
+        final AtomicLong innerCounter = new AtomicLong();
+        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.createObject(AllTypes.CLASS_NAME).set(AllTypes.FIELD_LONG, i);
+        }
+        realm.commitTransaction();
+
+        for (int i = 0; i < TEST_SIZE; i++) {
+            // Don't keep a reference to the Observable
+            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<DynamicRealmObject>asObservable()
+                    .filter(new Func1<DynamicRealmObject, Boolean>() {
+                        @Override
+                        public Boolean call(DynamicRealmObject obj) {
+                            return obj.isLoaded();
+                        }
+                    })
+                    .take(1) // Unsubscribes from Realm
+                    .subscribe(new Action1<DynamicRealmObject>() {
+                        @Override
+                        public void call(DynamicRealmObject result) {
+                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result
+                            Runtime.getRuntime().gc();
+                            if (innerCounter.incrementAndGet() == TEST_SIZE) {
+                                realm.close();
+                                looperThread.testComplete();
+                            }
+                        }
+                    }, new Action1<Throwable>() {
+                        @Override
+                        public void call(Throwable throwable) {
+                            fail(throwable.toString());
+                        }
+                    });
+        }
+    }
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 7f116eb2d7..5835953c0e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -45,7 +45,7 @@ public void setUp() {
         testRealm = Realm.getInstance(config);
 
         testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
+        testRealm.delete(AllTypes.class);
         AllTypes object1 = testRealm.createObject(AllTypes.class);
         object1.setColumnLong(5);
         object1.setColumnString("Adam");
@@ -211,20 +211,16 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
     }
 
     public void testSortRealmResultsTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.allObjects(AllTypes.class);
-        results1.sort(ORDER_STRING_INT, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results1 = testRealm.allObjects(AllTypes.class).sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.allObjects(AllTypes.class);
-        results2.sort(ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = testRealm.allObjects(AllTypes.class).sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.allObjects(AllTypes.class);
-        results3.sort(ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = testRealm.allObjects(AllTypes.class).sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.allObjects(AllTypes.class);
-        results4.sort(ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = testRealm.allObjects(AllTypes.class).sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
    }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index c07a560e32..17b3d20362 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -31,6 +31,7 @@
 import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
@@ -41,12 +42,14 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 
-import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
+import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.internal.log.Logger;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -496,6 +499,10 @@ public static void populateAllNonNullRowsForNumericTesting (Realm realm) {
     }
 
     public static void populatePartialNullRowsForNumericTesting (Realm realm) {
+        // Id values are [1, 2, 3]
+        // IntegerNull values are [3, null, 4]
+        // FloatNull values are [4F, null, 5F]
+        // DoubleNull values are [5D, null, 6F]
         NullTypes nullTypes1 = new NullTypes();
         nullTypes1.setId(1);
         nullTypes1.setFieldIntegerNull(3);
@@ -624,7 +631,7 @@ public static void populateForMultiSort(Realm typedRealm) {
 
     public static void populateForMultiSort(DynamicRealm realm) {
         realm.beginTransaction();
-        realm.clear(AllTypes.CLASS_NAME);
+        realm.delete(AllTypes.CLASS_NAME);
         DynamicRealmObject object1 = realm.createObject(AllTypes.CLASS_NAME);
         object1.setLong(AllTypes.FIELD_LONG, 5);
         object1.setString(AllTypes.FIELD_STRING, "Adam");
@@ -639,6 +646,15 @@ public static void populateForMultiSort(DynamicRealm realm) {
         realm.commitTransaction();
     }
 
+    public static void populateSimpleAllTypesPrimaryKey(Realm realm) {
+        realm.beginTransaction();
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        obj.setColumnString("Foo");
+        realm.copyToRealm(obj);
+        realm.commitTransaction();
+    }
+
 
     /*
      * Fields order test for Chained or Multi-Arguments Distinct()
@@ -757,4 +773,37 @@ public static void quitLooperOrFail() {
             throw new RuntimeException(e);
         }
     }
+
+    /**
+     * Replaces the current thread executor with a another one for testing.
+     * WARNING: This method should only be called before any async tasks have been started.
+     *
+     * @param executor {@link RealmThreadPoolExecutor} that should replace the current one
+     */
+    public static RealmThreadPoolExecutor replaceRealmThreadExectutor(RealmThreadPoolExecutor executor) throws NoSuchFieldException, IllegalAccessException {
+        Field field = BaseRealm.class.getDeclaredField("asyncQueryExecutor");
+        field.setAccessible(true);
+        RealmThreadPoolExecutor oldExecutor = (RealmThreadPoolExecutor) field.get(null);
+        field.set(field, executor);
+        return oldExecutor;
+    }
+
+    /**
+     * Emulates an environment where RxJava is not available.
+     *
+     * @param config {@link RealmConfiguration} instance to be modified.
+     */
+    public static void emulateRxJavaUnavailable(RealmConfiguration config) {
+        //noinspection TryWithIdenticalCatches
+        try {
+            final Field field = config.getClass().getDeclaredField("rxObservableFactory");
+            field.setAccessible(true);
+            field.set(config, null);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException(e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index 5b6b5a8c32..d6a53a17db 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -1786,7 +1786,7 @@ public void onChange() {
 
         // Trigger the listener at the first time.
         realm.beginTransaction();
-        allTypes.removeFromRealm();
+        allTypes.deleteFromRealm();
         realm.commitTransaction();
 
         // Try to trigger the listener second time.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
new file mode 100644
index 0000000000..d2d2bc41f9
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test class for all methods part of the the {@link OrderedRealmCollection} interface, that have a different behavior
+ * than managed RealmCollection classes.
+ *
+ * Methods tested in this class:
+ *
+ * # OrderedRealmCollection
+ *
+ * - E first()
+ * - E last()
+ * - void sort(String field)
+ * - void sort(String field, Sort sortOrder)
+ * - void sort(String field1, Sort sortOrder1, String field2, Sort sortOrder2)
+ * - void sort(String[] fields, Sort[] sortOrders)
+ * - void deleteFromRealm(int location)
+ * - void deleteFirstFromRealm()
+ * - void deleteLastFromRealm();
+ *
+ * # List
+ *
+ *  - void add(int location, E object);
+ *  - boolean addAll(int location, Collection<? extends E> collection);
+ *  - E get(int location);
+ *  - int indexOf(Object object);
+ *  - int lastIndexOf(Object object);
+ *  - ListIterator<E> listIterator();
+ *  - ListIterator<E> listIterator(int location);
+ *  - E remove(int location);
+ *  - E set(int location, E object);
+ *  - List<E> subList(int start, int end);
+ *
+ * # RealmCollection
+ *
+ * - RealmQuery<E> where();
+ * - Number min(String fieldName);
+ * - Number max(String fieldName);
+ * - Number sum(String fieldName);
+ * - double average(String fieldName);
+ * - Date maxDate(String fieldName);
+ * - Date minDate(String fieldName);
+ * - void deleteAllFromRealm();
+ * + boolean isLoaded();
+ * + boolean load();
+ * + boolean isValid();
+ * + BaseRealm getRealm();
+ *
+ * # Collection
+ *
+ * - public boolean add(E object);
+ * - public boolean addAll(Collection<? extends E> collection);
+ * - public void deleteAll();
+ * - public boolean contains(Object object);
+ * - public boolean containsAll(Collection<?> collection);
+ * - public boolean equals(Object object);
+ * - public int hashCode();
+ * - public boolean isEmpty();
+ * - public Iterator<E> iterator();
+ * - public boolean remove(Object object);
+ * - public boolean removeAll(Collection<?> collection);
+ * - public boolean retainAll(Collection<?> collection);
+ * - public int size();
+ * - public Object[] toArray();
+ * - public <T> T[] toArray(T[] array);
+ **
+ * See {@link ManagedOrderedRealmCollectionTests} for similar tests for the managed behavior.
+ */
+@RunWith(Parameterized.class)
+public class UnManagedOrderedRealmCollectionTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private final UnManagedCollection collectionClass;
+    private Realm realm;
+    private OrderedRealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<UnManagedCollection> data() {
+        return Arrays.asList(UnManagedCollection.values());
+    }
+
+    public UnManagedOrderedRealmCollectionTests(UnManagedCollection collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        collection = createCollection(collectionClass);
+    }
+
+    private OrderedRealmCollection<AllJavaTypes> createCollection(UnManagedCollection collectionClass) {
+        switch (collectionClass) {
+            case UNMANAGED_REALMLIST:
+                return populateInMemoryList(TEST_SIZE);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    @Test
+    public void unsupportedMethods_unManagedCollections() {
+        // RealmCollection methods
+        for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
+            try {
+                switch (method) {
+                    case DELETE_INDEX: collection.deleteFromRealm(0); break;
+                    case DELETE_FIRST: collection.deleteFirstFromRealm(); break;
+                    case DELETE_LAST: collection.deleteLastFromRealm(); break;
+                    case SORT: collection.sort(AllJavaTypes.FIELD_STRING); break;
+                    case SORT_FIELD: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING); break;
+                    case SORT_2FIELDS: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING); break;
+                    case SORT_MULTI: collection.sort(new String[] { AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_LONG }, new Sort[] { Sort.ASCENDING, Sort.DESCENDING }); break;
+                }
+                fail(method + " should have thrown an exception.");
+            } catch (UnsupportedOperationException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void isLoaded() {
+        assertTrue(collection.isLoaded());
+    }
+
+    @Test
+    public void load() {
+        assertTrue(collection.load());
+    }
+
+    @Test
+    public void isValid() {
+        assertFalse(collection.isValid());
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
new file mode 100644
index 0000000000..70f6aab05d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Test class for all methods part of the the {@link RealmCollection} interface, that have a different behavior
+ * than managed RealmCollection classes.
+ *
+ * See {@link ManagedRealmCollectionTests} for similar tests for the managed behavior.
+ */
+@RunWith(Parameterized.class)
+public class UnManagedRealmCollectionTests extends CollectionTests {
+
+    private static final int TEST_SIZE = 10;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private final UnManagedCollection collectionClass;
+    private Realm realm;
+    private RealmCollection<AllJavaTypes> collection;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<UnManagedCollection> data() {
+        return Arrays.asList(UnManagedCollection.values());
+    }
+
+    public UnManagedRealmCollectionTests(UnManagedCollection collectionType) {
+        this.collectionClass = collectionType;
+    }
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        collection = createCollection(collectionClass);
+    }
+
+    private RealmCollection<AllJavaTypes> createCollection(UnManagedCollection collectionClass) {
+        switch (collectionClass) {
+            case UNMANAGED_REALMLIST:
+                return populateInMemoryList(TEST_SIZE);
+
+            default:
+                throw new AssertionError("Unsupported class: " + collectionClass);
+        }
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    @Test
+    public void unsupportedMethods_unManagedCollections() {
+        // RealmCollection methods
+        for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
+            try {
+                switch (method) {
+                    // Unsupported methods
+                    case WHERE: collection.where(); break;
+                    case MIN: collection.min(AllJavaTypes.FIELD_LONG); break;
+                    case MAX: collection.max(AllJavaTypes.FIELD_LONG); break;
+                    case SUM: collection.sum(AllJavaTypes.FIELD_LONG); break;
+                    case AVERAGE: collection.average(AllJavaTypes.FIELD_LONG); break;
+                    case MIN_DATE: collection.minDate(AllJavaTypes.FIELD_DATE); break;
+                    case MAX_DATE: collection.maxDate(AllJavaTypes.FIELD_DATE); break;
+                    case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
+
+                    // Supported methods
+                    case IS_VALID: assertFalse(collection.isValid()); continue;
+                }
+                fail(method + " should have thrown an exception.");
+            } catch (UnsupportedOperationException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void isLoaded() {
+        assertTrue(collection.isLoaded());
+    }
+
+    @Test
+    public void load() {
+        assertTrue(collection.load());
+    }
+
+    @Test
+    public void isValid() {
+        assertFalse(collection.isValid());
+    }
+
+    @Test
+    public void contains() {
+        AllJavaTypes obj = collection.iterator().next();
+        assertTrue(collection.contains(obj));
+    }
+
+    @Test
+    public void equals_sameRealmObjectsDifferentCollection() {
+        List<AllJavaTypes> list = new ArrayList<AllJavaTypes>();
+        list.addAll(collection);
+        assertTrue(collection.equals(list));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 79ef9063ff..cf0da4bd50 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -58,6 +58,14 @@
     private AllJavaTypes fieldObject;
     private RealmList<AllJavaTypes> fieldList;
 
+    public AllJavaTypes() {
+
+    }
+
+    public AllJavaTypes(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
     public String getFieldIgnored() {
         return fieldIgnored;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
index 478c47cf00..8592877b95 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
@@ -16,9 +16,6 @@
 
 package io.realm.entities;
 
-import io.realm.RealmObject;
-
-
 import io.realm.RealmObject;
 
 public class ConflictingFieldName extends RealmObject {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
new file mode 100644
index 0000000000..a81d653aad
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+
+public class CustomMethods extends RealmObject {
+    public static final String CUSTOM_TO_STRING = "custom toString";
+    public static final int HASHCODE = 1;
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @Ignore
+    public boolean reverseEquals;
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof CustomMethods)) {
+            return reverseEquals;
+        }
+        CustomMethods other = (CustomMethods) o;
+        if (isValid() == other.isValid() && other.name.equals(name)) {
+            return !reverseEquals;
+        } else {
+            return reverseEquals;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return CUSTOM_TO_STRING;
+    }
+
+    @Override
+    public int hashCode() {
+        return HASHCODE;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java
index e29160615a..1f71d52835 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java
@@ -16,12 +16,20 @@
 
 package io.realm.entities;
 
+import java.util.Date;
+
 import io.realm.RealmList;
 import io.realm.RealmObject;
 
 public class CyclicType extends RealmObject {
 
+    public static final String FIELD_NAME = "name";
+    public static final String FIELD_ID = "id";
+    public static final String FIELD_DATE = "date";
+
+    private long id;
     private String name;
+    private Date date;
     private CyclicType object;
     private CyclicType otherObject;
     private RealmList<CyclicType> objects;
@@ -33,6 +41,15 @@ public CyclicType(String name) {
         this.name = name;
     }
 
+
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
     public String getName() {
         return name;
     }
@@ -64,4 +81,12 @@ public CyclicType getOtherObject() {
     public void setOtherObject(CyclicType otherObject) {
         this.otherObject = otherObject;
     }
+
+    public Date getDate() {
+        return date;
+    }
+
+    public void setDate(Date date) {
+        this.date = date;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
index ee51ea91f7..5328afe314 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
@@ -16,6 +16,7 @@
 
 package io.realm.entities;
 
+import io.realm.RealmList;
 import io.realm.RealmObject;
 
 public class NonLatinFieldNames extends RealmObject{
@@ -24,6 +25,7 @@
     public final static String FIELD_LONG_GREEK_CHAR = "Δέλτα";
     public final static String FIELD_FLOAT_KOREAN_CHAR = "베타";
     public final static String FIELD_FLOAT_GREEK_CHAR = "βήτα";
+    public final static String FIELD_CHILDREN = "children";
 
     private long 델타;
     private long Δέλτα;
@@ -31,6 +33,8 @@
     private float 베타;
     private float βήτα;
 
+    private RealmList<NonLatinFieldNames> children;
+
     public float get베타() { return 베타; }
 
     public void set베타(float 베타) { this.베타 = 베타; }
@@ -46,4 +50,12 @@
     public long getΔέλτα() { return Δέλτα; }
 
     public void setΔέλτα(long δέλτα) { this.Δέλτα = δέλτα; }
+
+    public RealmList<NonLatinFieldNames> getChildren() {
+        return children;
+    }
+
+    public void setChildren(RealmList<NonLatinFieldNames> children) {
+        this.children = children;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java b/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
index 1a492a7bab..35bc61ca1a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
@@ -22,6 +22,7 @@
 import android.widget.ListAdapter;
 import android.widget.TextView;
 
+import io.realm.OrderedRealmCollection;
 import io.realm.RealmBaseAdapter;
 import io.realm.RealmResults;
 
@@ -47,12 +48,12 @@ public View getView(int position, View convertView, ViewGroup parent) {
             viewHolder = (ViewHolder) convertView.getTag();
         }
 
-        AllTypes item = realmResults.get(position);
+        AllTypes item = adapterData.get(position);
         viewHolder.textView.setText(item.getColumnString());
         return convertView;
     }
 
-    public RealmResults<AllTypes> getRealmResults() {
-        return realmResults;
+    public OrderedRealmCollection<AllTypes> getRealmResults() {
+        return adapterData;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 6faf09ed5e..7012e50c45 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -56,9 +56,9 @@
     protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
 
     // Thread pool for all async operations (Query & transaction)
-    static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor.getInstance();
+    static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
-    protected long threadId;
+    final long threadId;
     protected RealmConfiguration configuration;
     protected SharedGroupManager sharedGroupManager;
     protected boolean autoRefresh;
@@ -553,9 +553,9 @@ public RealmSchema getSchema() {
     }
 
     /**
-     * Removes all objects from this Realm.
+     * Deletes all objects from this Realm.
      *
-     * @throws IllegalStateException if the corresponding Realm is closed or on an incorrect thread.
+     * @throws IllegalStateException if the corresponding Realm is closed or called from an incorrect thread.
      */
     public void deleteAll() {
         checkIfValid();
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 3b2acdea34..85401c8183 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -22,8 +22,8 @@
 import io.realm.exceptions.RealmIOException;
 import io.realm.internal.Table;
 import io.realm.internal.TableView;
-import rx.Observable;
 import io.realm.internal.log.RealmLog;
+import rx.Observable;
 
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
@@ -120,9 +120,21 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     /**
      * Removes all objects of the specified class.
      *
+     * DEPRECATED: Use {@link #delete(String)} instead.
+     *
      * @param className the class for which all objects should be removed.
      */
+    @Deprecated
     public void clear(String className) {
+        delete(className);
+    }
+
+    /**
+     * Deletes all objects of the specified class from the Realm.
+     *
+     * @param className the class for which all objects should be removed.
+     */
+    public void delete(String className) {
         checkIfValid();
         schema.getTable(className).clear();
     }
@@ -155,7 +167,7 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Get all objects of a specific class name.
+     * Gets all objects of a specific class name.
      *
      * @param className the Class to get objects of.
      * @return a {@link RealmResults} list containing the objects. If no results where found, an empty list
@@ -167,8 +179,9 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Get all objects of a specific class name sorted by a field. If no objects exist, the returned
-     * {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of objects instead.
+     * Gets all objects of a specific class name sorted by a field. If no objects exist, the returned
+     * {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of objects
+     * instead.
      *
      * @param className the class to get all objects from.
      * @param fieldName the field name to sort by.
@@ -190,9 +203,9 @@ public void executeTransaction(Transaction transaction) {
 
 
     /**
-     * Get all objects of a specific class name sorted by two specific field names.  If no objects exist,
-     * the returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of
-     * objects instead.
+     * Gets all objects of a specific class name sorted by two specific field names.  If no objects exist,
+     * the returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number
+     * of objects instead.
      *
      * @param className the class to get all objects from.
      * @param fieldName1 the first field name to sort by.
@@ -211,12 +224,12 @@ public void executeTransaction(Transaction transaction) {
     }
 
     /**
-     * Get all objects of a specific class name sorted by multiple fields.  If no objects exist, the
+     * Gets all objects of a specific class name sorted by multiple fields.  If no objects exist, the
      * returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of
      * objects instead.
      *
      * @param className the class to get all objects from.
-     * @param sortOrders sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
+     * @param sortOrders sort ascending if Sort.ASCENDING, sort descending if Sort.DESCENDING.
      * @param fieldNames an array of field names to sort objects by.
      *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.
      * @return A sorted {@link RealmResults} containing the objects.
@@ -242,7 +255,7 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     }
 
     /**
-     * Return a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
+     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
      * returned in case of multiple occurrences.
      *
      * @param className the Class to get objects of.
@@ -260,7 +273,7 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     }
 
     /**
-     * Return a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
+     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
      * returned in case of multiple occurrences.
      * This method is only available from a Looper thread.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index a506deb5fc..fc32816dd8 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -683,35 +683,52 @@ public String toString() {
         if (row == null || !row.isAttached()) {
             return "Invalid object";
         }
-        StringBuilder sb = new StringBuilder(row.getTable().getName() + " = [");
+
+        final String className = Table.tableNameToClassName(row.getTable().getName());
+        StringBuilder sb = new StringBuilder(className + " = [");
         String[] fields = getFieldNames();
         for (String field : fields) {
             long columnIndex = row.getColumnIndex(field);
             RealmFieldType type = row.getColumnType(columnIndex);
             sb.append("{");
+            sb.append(field).append(":");
             switch (type) {
-                case BOOLEAN: sb.append(field).append(": ").append(row.getBoolean(columnIndex)); break;
-                case INTEGER: sb.append(field).append(": ").append(row.getLong(columnIndex)); break;
-                case FLOAT: sb.append(field).append(": ").append(row.getFloat(columnIndex)); break;
-                case DOUBLE: sb.append(field).append(": ").append(row.getDouble(columnIndex)); break;
-                case STRING: sb.append(field).append(": ").append(row.getString(columnIndex)); break;
-                case BINARY: sb.append(field).append(": ").append(Arrays.toString(row.getBinaryByteArray(columnIndex))); break;
-                case DATE: sb.append(field).append(": ").append(row.getDate(columnIndex)); break;
+                case BOOLEAN:
+                    sb.append(row.isNull(columnIndex) ? "null" : row.getBoolean(columnIndex));
+                    break;
+                case INTEGER:
+                    sb.append(row.isNull(columnIndex) ? "null" : row.getLong(columnIndex));
+                    break;
+                case FLOAT:
+                    sb.append(row.isNull(columnIndex) ? "null" : row.getFloat(columnIndex));
+                    break;
+                case DOUBLE:
+                    sb.append(row.isNull(columnIndex) ? "null" : row.getDouble(columnIndex));
+                    break;
+                case STRING:
+                    sb.append(row.getString(columnIndex));
+                    break;
+                case BINARY:
+                    sb.append(Arrays.toString(row.getBinaryByteArray(columnIndex)));
+                    break;
+                case DATE:
+                    sb.append(row.isNull(columnIndex) ? "null" : row.getDate(columnIndex));
+                    break;
                 case OBJECT:
-                    if (row.isNullLink(columnIndex)) {
-                        sb.append("null");
-                    } else {
-                        sb.append(field).append(": ").append(row.getTable().getLinkTarget(columnIndex).getName());
-                    }
+                    sb.append(row.isNullLink(columnIndex)
+                            ? "null"
+                            : Table.tableNameToClassName(row.getTable().getLinkTarget(columnIndex).getName()));
                     break;
                 case LIST:
-                    String targetType = row.getTable().getLinkTarget(columnIndex).getName();
-                    sb.append(String.format("%s: RealmList<%s>[%s]", field, targetType, row.getLinkList(columnIndex).size()));
+                    final String tableName = row.getTable().getLinkTarget(columnIndex).getName();
+                    String targetType = Table.tableNameToClassName(tableName);
+                    sb.append(String.format("RealmList<%s>[%s]", targetType, row.getLinkList(columnIndex).size()));
                     break;
                 case UNSUPPORTED_TABLE:
                 case UNSUPPORTED_MIXED:
                 default:
-                    sb.append(field).append(": ?");
+                    sb.append("?");
+                    break;
             }
             sb.append("}, ");
         }
diff --git a/realm/realm-library/src/main/java/io/realm/FieldAttribute.java b/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
index d8c9c46870..42000915dc 100644
--- a/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
+++ b/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
@@ -23,21 +23,21 @@
  */
 public enum FieldAttribute {
     /**
-     * Mark a field as indexed.
+     * Marks a field as indexed.
      *
      * @see io.realm.annotations.Index
      */
     INDEXED,
 
     /**
-     * Mark a field as a primary key. This also implicitly mark it as {@link #INDEXED} and {@link #REQUIRED}.
+     * Marks a field as a primary key. This also implicitly mark it as {@link #INDEXED} and {@link #REQUIRED}.
      *
      * @see io.realm.annotations.PrimaryKey
      */
     PRIMARY_KEY,
 
     /**
-     * Mark a field as explicitly not allowing null values. The default behavior for allowing {@code
+     * Marks a field as explicitly not allowing null values. The default behavior for allowing {@code
      * null} depends on the type of the field.
      *
      * @see io.realm.annotations.Required
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 0f1d4875d0..8713584e04 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -34,6 +34,7 @@
 import io.realm.internal.IdentitySet;
 import io.realm.internal.Row;
 import io.realm.internal.SharedGroup;
+import io.realm.internal.async.BadVersionException;
 import io.realm.internal.async.QueryUpdateTask;
 import io.realm.internal.log.RealmLog;
 
@@ -95,31 +96,35 @@ public boolean handleMessage(Message message) {
         // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
         // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
         if (realm.sharedGroupManager != null) {
+            QueryUpdateTask.Result result;
             switch (message.what) {
-                case REALM_CHANGED: {
+
+                case REALM_CHANGED:
                     realmChanged();
                     break;
-                }
-                case COMPLETED_ASYNC_REALM_RESULTS: {
-                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
+
+                case COMPLETED_ASYNC_REALM_RESULTS:
+                    result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncRealmResults(result);
                     break;
-                }
-                case COMPLETED_ASYNC_REALM_OBJECT: {
-                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
+
+                case COMPLETED_ASYNC_REALM_OBJECT:
+                    result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncRealmObject(result);
                     break;
-                }
-                case COMPLETED_UPDATE_ASYNC_QUERIES: {
+
+                case COMPLETED_UPDATE_ASYNC_QUERIES:
                     // this is called once the background thread completed the update of the async queries
-                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
+                    result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncQueriesUpdate(result);
                     break;
-                }
-                case REALM_ASYNC_BACKGROUND_EXCEPTION: {
+
+                case REALM_ASYNC_BACKGROUND_EXCEPTION:
                     // Don't fail silently in the background in case of Core exception
                     throw (Error) message.obj;
-                }
+
+                default:
+                    throw new IllegalArgumentException("Unknown message: " + message.what);
             }
         }
         return true;
@@ -165,6 +170,24 @@ void addChangeListenerAsWeakReference(RealmChangeListener listener) {
         }
     }
 
+    void removeWeakChangeListener(RealmChangeListener listener) {
+        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+        for (int i = 0; i < weakChangeListeners.size(); i++) {
+            WeakReference<RealmChangeListener> weakRef = weakChangeListeners.get(i);
+            RealmChangeListener weakListener = weakRef.get();
+
+            // Collect all listeners that are GC'ed or we need to remove
+            if (weakListener == null || weakListener == listener) {
+                if (toRemoveList == null) {
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                }
+                toRemoveList.add(weakRef);
+            }
+        }
+
+        weakChangeListeners.removeAll(toRemoveList);
+    }
+
     void removeChangeListener(RealmChangeListener listener) {
         changeListeners.remove(listener);
     }
@@ -437,7 +460,13 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 // refresh the Realm to the version provided by the worker thread
                 // (advanceRead to the latest version may cause a version mismatch error) preventing us
                 // from importing correctly the handover table view
-                realm.sharedGroupManager.advanceRead(result.versionID);
+                try {
+                    realm.sharedGroupManager.advanceRead(result.versionID);
+                } catch (BadVersionException e) {
+                    // The version comparison above should have ensured that that the Caller version is less than the
+                    // Worker version. In that case it should always be safe to advance_read.
+                    throw new IllegalStateException("Failed to advance Caller Realm to Worker Realm version", e);
+                }
             }
 
             ArrayList<RealmResults<? extends RealmObject>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmObject>>(result.updatedTableViews.size());
@@ -450,15 +479,15 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                     asyncRealmResults.remove(weakRealmResults);
 
                 } else {
+                    // update the instance with the new pointer
+                    realmResults.swapTableViewPointer(query.getValue());
+
                     // it's dangerous to notify the callback about new results before updating
                     // the pointers, because the callback may use another RealmResults not updated yet
                     // this is why we defer the notification until we're done updating all pointers
                     callbacksToNotify.add(realmResults);
 
                     RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
-
-                    // update the instance with the new pointer
-                    realmResults.swapTableViewPointer(query.getValue());
                 }
             }
 
@@ -501,8 +530,13 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                     // the caller has advanced we need to
                     // retry against the current version of the caller if it's still empty
                     if (realmObject.isValid()) { // already completed & has a valid pointer no need to re-run
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ realmObject + "] , realm:" + HandlerController.this
+                                + " RealmObject is already loaded, just notify it.");
                         realmObject.notifyChangeListeners();
+
                     } else {
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ realmObject + "] , realm:" + HandlerController.this
+                                + " RealmObject is not loaded yet. Rerun the query.");
                         RealmQuery<?> realmQuery = realmObjects.get(realmObjectWeakReference);
                         if (realmQuery == null) { // this is a retry of an empty RealmObject
                             realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);
@@ -521,7 +555,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                 } else {
                     // should not happen, since the the background thread position itself against the provided version
                     // and the caller thread can only go forward (advance_read)
-                    throw new IllegalStateException("Caller thread behind the worker thread");
+                    throw new IllegalStateException("Caller thread behind the Worker thread");
                 }
             } // else: element GC'd in the meanwhile
         }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
new file mode 100644
index 0000000000..c0f11e1e47
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.List;
+
+/**
+ * An {@code OrderedRealmCollection} is a collection which maintains an ordering for its elements. Every
+ * element in the {@code OrderedRealmCollection} has an index. Each element can thus be accessed by its
+ * index, with the first index being zero. Normally, {@code OrderedRealmCollection}s allow duplicate
+ * elements, as compared to Sets, where elements have to be unique.
+ */
+public interface OrderedRealmCollection<E extends RealmObject> extends List<E>, RealmCollection<E> {
+
+    /**
+     * Gets the first object from the collection.
+     *
+     * @return the first object.
+     * @throws IndexOutOfBoundsException if the collection is empty.
+     */
+    E first();
+
+    /**
+     * Gets the last object from the collection.
+     *
+     * @return the last object.
+     * @throws IndexOutOfBoundsException if the collection is empty.
+     */
+    E last();
+
+    /**
+     * Sorts a collection based on the provided field in ascending order.
+     *
+     * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
+     *                  and String are supported.
+     * @return a sorted view of the collection.
+     * @throws java.lang.IllegalArgumentException if field name does not exist or it has an invalid type.
+     * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
+     *                                         an un-managed collection.
+     */
+    RealmResults<E> sort(String fieldName);
+
+    /**
+     * Sorts a collection based on the provided field and sort order.
+     *
+     * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
+     *                  and String are supported.
+     * @param sortOrder the direction to sort by.
+     * @return a sorted view of the collection.
+     * @throws java.lang.IllegalArgumentException if field name does not exist or has an invalid type.
+     * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
+     *                                         an un-managed collection.
+     */
+    RealmResults<E> sort(String fieldName, Sort sortOrder);
+
+    /**
+     * Sorts a collection based on the provided fields and sort orders.
+     *
+     * @param fieldName1 first field name. Only fields of type boolean, short, int, long, float,
+     *                   double, Date, and String are supported.
+     * @param sortOrder1 sort order for first field.
+     * @param fieldName2 second field name. Only fields of type boolean, short, int, long, float,
+     *                   double, Date, and String are supported.
+     * @param sortOrder2 sort order for second field.
+     * @return a sorted view of the collection.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
+     * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
+     *                                         an un-managed collection.
+     */
+    RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2);
+
+    /**
+     * Sorts a collection based on the provided fields and sort orders.
+     *
+     * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int, long, float,
+     *                   double, Date, and String are supported.
+     * @param sortOrders the directions to sort by.
+     * @return a sorted view of the collection.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
+     * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
+     *                                         an un-managed collection.
+     */
+    RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders);
+
+    /**
+     * Deletes the object at the given index from the Realm. This also removes it from the collection.
+     *
+     * @param location the array index identifying the object to be removed.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
+     * @throws UnsupportedOperationException if the collection is un-managed.
+     */
+    void deleteFromRealm(int location);
+
+    /**
+     * Deletes the first object from the Realm. This also removes it from this collection.
+     *
+     * @return {@code true} if an object was deleted, {@code false} otherwise.
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called on the wrong thread.
+     * @throws UnsupportedOperationException if the collection is un-managed.
+     */
+    boolean deleteFirstFromRealm();
+
+    /**
+     * Deletes the last object from the Realm. This also removes it from this collection.
+     *
+     * @return {@code true} if an object was deleted, {@code false} otherwise.
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
+     * @throws UnsupportedOperationException if the collection is un-managed.
+     */
+    boolean deleteLastFromRealm();
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 1cf7940efc..c79abe99ae 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -167,8 +167,8 @@ protected void finalize() throws Throwable {
      * @param context a non-null Android {@link android.content.Context}
      * @return an instance of the Realm class.
      * @throws java.lang.IllegalArgumentException if no {@link Context} is provided.
-     * @throws RealmMigrationNeededException if the RealmObject classes no longer match the underlying Realm and it must be
-     * migrated.
+     * @throws RealmMigrationNeededException if the RealmObject classes no longer match the underlying Realm and it must
+     *         be migrated.
      * @throws RealmIOException if an error happened when accessing the underlying Realm file.
      * @deprecated use {@link #getDefaultInstance()} or {@link #getInstance(RealmConfiguration)} instead.
      */
@@ -185,7 +185,7 @@ public static Realm getInstance(Context context) {
      * @return an instance of the Realm class.
      * @throws java.lang.NullPointerException if no default configuration has been defined.
      * @throws RealmMigrationNeededException if no migration has been provided by the default configuration and the
-     * RealmObject classes or version has has changed so a migration is required.
+     *         RealmObject classes or version has has changed so a migration is required.
      * @throws RealmIOException if an error happened when accessing the underlying Realm file.
      */
     public static Realm getDefaultInstance() {
@@ -201,7 +201,7 @@ public static Realm getDefaultInstance() {
      * @param configuration {@link RealmConfiguration} used to open the Realm
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException if no migration has been provided by the configuration and the RealmObject
-     * classes or version has has changed so a migration is required.
+     *         classes or version has has changed so a migration is required.
      * @throws RealmIOException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
      * @see RealmConfiguration for details on how to configure a Realm.
@@ -239,8 +239,9 @@ public static void removeDefaultConfiguration() {
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
      * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param columnIndices if this is not  {@code null} value, the {@link BaseRealm#schema#columnIndices} will be initialized
-     *                      to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from the Realm file.
+     * @param columnIndices if this is not  {@code null} value, the {@link BaseRealm#schema#columnIndices} will be
+     *                      initialized to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from
+     *                      the Realm file.
      * @return a {@link Realm} instance.
      */
     static Realm createInstance(RealmConfiguration configuration, ColumnIndices columnIndices) {
@@ -315,6 +316,13 @@ private static void initializeRealm(Realm realm) {
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedGroupManager.getTransaction()));
             }
             realm.schema.columnIndices = new ColumnIndices(columnInfoMap);
+
+            if (version == UNVERSIONED) {
+                final Transaction transaction = realm.getConfiguration().getInitialDataTransaction();
+                if (transaction != null) {
+                    transaction.execute(realm);
+                }
+            }
         } finally {
             if (commitNeeded) {
                 realm.commitTransaction(false, null);
@@ -351,14 +359,14 @@ private static void initializeRealm(Realm realm) {
     /**
      * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
      * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
-     * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If a
-     * new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the default
-     * value for the field type.
+     * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If
+     * a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
+     * default value for the field type.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json array with object data.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
+     *         {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if unable to map JSON.
      * @see #createAllFromJson(Class, org.json.JSONArray)
      */
@@ -379,7 +387,8 @@ private static void initializeRealm(Realm realm) {
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
      * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will be set to the default value for that type.
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
+     * will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
      * @param json the JSON array as a String where each object can map to the specified class.
@@ -410,7 +419,7 @@ private static void initializeRealm(Realm realm) {
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with an array of JSON objects.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
+     *         {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if unable to create a JSON array from the json string.
      * @see #createAllFromJson(Class, String)
      */
@@ -469,7 +478,7 @@ private static void initializeRealm(Realm realm) {
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the InputStream with a list of object data in JSON format.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
+     *         {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if unable to read JSON.
      * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
      */
@@ -532,7 +541,7 @@ private static void initializeRealm(Realm realm) {
      * @param json {@link org.json.JSONObject} with object data.
      * @return created or updated {@link io.realm.RealmObject}.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
+     *         {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if JSON data cannot be mapped.
      * @see #createObjectFromJson(Class, org.json.JSONObject)
      */
@@ -580,15 +589,16 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
-     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a {@link RealmObject}
-     * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
-     * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
+     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a
+     * {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If a new
+     * {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
+     * default value for the field type.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
+     *         {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if JSON object cannot be mapped from the string parameter.
      * @see #createObjectFromJson(Class, String)
      */
@@ -656,15 +666,16 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
-     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a {@link RealmObject}
-     * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
-     * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
+     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a
+     * {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If a new
+     * {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
+     * default value for the field type.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the {@link InputStream} with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
+     *         {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if failure to read JSON.
      * @see #createObjectFromJson(Class, java.io.InputStream)
      */
@@ -739,7 +750,8 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      *
      * @param object the {@link io.realm.RealmObject} to copy to the Realm.
      * @return a managed RealmObject with its properties backed by the Realm.
-     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null}.
+     * @throws java.lang.IllegalArgumentException if the object is {@code null} or it belongs to a Realm instance
+     * in a different thread.
      */
     public <E extends RealmObject> E copyToRealm(E object) {
         checkNotNullObject(object);
@@ -756,7 +768,8 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      *
      * @param object {@link io.realm.RealmObject} to copy or update.
      * @return the new or updated RealmObject with all its properties backed by the Realm.
-     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
+     * @throws java.lang.IllegalArgumentException if the object is {@code null} or it belongs to a Realm instance
+     *         in a different thread.
      * @see #copyToRealm(RealmObject)
      */
     public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
@@ -851,7 +864,8 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * changes made by other threads.
      *
      * @param realmObjects RealmObjects to copy.
-     * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is {@code 0}.
+     * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
+     *                 {@code 0}.
      * @param <E> type of object.
      * @return an in-memory detached copy of the RealmObjects.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
@@ -881,9 +895,9 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      *
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmObject)},
-     * but all fields will be overridden, not just those that were changed. This includes references to other objects,
-     * and can potentially override changes made by other threads.
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
+     * {@link #copyToRealmOrUpdate(RealmObject)}, but all fields will be overridden, not just those that were changed.
+     * This includes references to other objects, and can potentially override changes made by other threads.
      *
      * @param realmObject {@link RealmObject} to copy
      * @param <E> type of object.
@@ -902,13 +916,14 @@ void remove(Class<? extends RealmObject> clazz, long objectIndex) {
      * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      *
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmObject)},
-     * but all fields will be overridden, not just those that were changed. This includes references to other objects
-     * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
-     * changes made by other threads.
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
+     * {@link #copyToRealmOrUpdate(RealmObject)}, but all fields will be overridden, not just those that were changed.
+     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
+     * reached. This can also potentially override changes made by other threads.
      *
      * @param realmObject {@link RealmObject} to copy
-     * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is {@code 0}.
+     * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
+     * {@code 0}.
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
@@ -1019,7 +1034,7 @@ boolean contains(Class<? extends RealmObject> clazz) {
      * {@link RealmResults} will not be null. The RealmResults.size() to check the number of objects instead.
      *
      * @param clazz the Class to get objects of.
-     * @param sortOrders sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
+     * @param sortOrders sort ascending if Sort.ASCENDING, sort descending if Sort.DESCENDING.
      * @param fieldNames an array of field names to sort objects by. The objects are first sorted by fieldNames[0], then
      *                   by fieldNames[1] and so forth.
      * @return a sorted RealmResults containing the objects.
@@ -1061,10 +1076,10 @@ boolean contains(Class<? extends RealmObject> clazz) {
      * @param clazz the Class to get objects of.
      * @param fieldName the field name.
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     * query completes.
+     *         {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
+     *         query completes.
      * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     *         is not indexed, or points to linked fields.
      */
     public <E extends RealmObject> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
         checkIfValid();
@@ -1082,7 +1097,7 @@ boolean contains(Class<? extends RealmObject> clazz) {
      * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
      * @return a non-null {@link RealmResults} containing the distinct objects.
      * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     * is an unsupported type, or points to a linked field.
+     *         is an unsupported type, or points to a linked field.
      */
     public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String firstFieldName, String... remainingFieldNames) {
         checkIfValid();
@@ -1122,8 +1137,12 @@ public void executeTransaction(Transaction transaction) {
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @param callback optional, to receive the result of this query.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
-     * @deprecated replaced by {@link #executeTransactionAsync(Transaction)}, {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess)}, {@link #executeTransactionAsync(Transaction, io.realm.Realm.Transaction.OnError)} and {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess, Transaction.OnError)}.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     *         another thread.
+     * @deprecated replaced by {@link #executeTransactionAsync(Transaction)},
+     * {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess)},
+     * {@link #executeTransactionAsync(Transaction, io.realm.Realm.Transaction.OnError)} and
+     * {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess, Transaction.OnError)}.
      */
     @Deprecated
     public RealmAsyncTask executeTransaction(final Transaction transaction, final Transaction.Callback callback) {
@@ -1215,7 +1234,8 @@ public void run() {
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     *                                  another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction) {
         return executeTransactionAsync(transaction, null, null);
@@ -1227,7 +1247,8 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction) {
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @param onSuccess callback invoked when the transaction succeeds.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     *                                  another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess) {
         if (onSuccess == null) {
@@ -1243,7 +1264,8 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @param onError callback invoked when the transaction failed.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     *                                  another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnError onError) {
         if (onError == null) {
@@ -1260,7 +1282,8 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * @param onSuccess callback invoked when the transaction succeeds.
      * @param onError callback invoked when the transaction failed.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     *                                  another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess, final Realm.Transaction.OnError onError) {
         checkIfValid();
@@ -1381,14 +1404,28 @@ public void run() {
     /**
      * Removes all objects of the specified class.
      *
+     * DEPRECATED: Use {@link #delete(Class)} instead.
+     *
      * @param clazz the class which objects should be removed.
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      */
+    @Deprecated
     public void clear(Class<? extends RealmObject> clazz) {
+        delete(clazz);
+    }
+
+    /**
+     * Deletes all objects of the specified class from the Realm.
+     *
+     * @param clazz the class which objects should be removed.
+     * @throws IllegalStateException if the corresponding Realm is closed or called from an incorrect thread.
+     */
+    public void delete(Class<? extends RealmObject> clazz) {
         checkIfValid();
         getTable(clazz).clear();
     }
 
+
     @SuppressWarnings("unchecked")
     private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
         checkIfValid();
@@ -1431,7 +1468,7 @@ private void checkMaxDepth(int maxDepth) {
     }
 
     /**
-     * Manually trigger the migration associated with a given RealmConfiguration. If Realm is already at the latest
+     * Manually triggers the migration associated with a given RealmConfiguration. If Realm is already at the latest
      * version, nothing will happen.
      *
      * @param configuration {@link RealmConfiguration}
@@ -1442,7 +1479,7 @@ public static void migrateRealm(RealmConfiguration configuration) throws FileNot
     }
 
     /**
-     * Manually trigger a migration on a RealmMigration.
+     * Manually triggers a migration on a RealmMigration.
      *
      * @param configuration the{@link RealmConfiguration}.
      * @param migration the {@link RealmMigration} to run on the Realm. This will override any migration set on the
@@ -1481,7 +1518,7 @@ public static boolean deleteRealm(RealmConfiguration configuration) {
      * @param configuration a {@link RealmConfiguration} pointing to a Realm file.
      * @return {@code true} if successful, {@code false} if any file operation failed.
      * @throws IllegalArgumentException if the realm file is encrypted. Compacting an encrypted Realm file is not
-     * supported yet.
+     *                                  supported yet.
      */
     public static boolean compactRealm(RealmConfiguration configuration) {
         return BaseRealm.compactRealm(configuration);
@@ -1496,8 +1533,7 @@ static String getCanonicalPath(File realmFile) {
         }
     }
 
-    @Deprecated
-    public Table getTable(Class<? extends RealmObject> clazz) {
+    Table getTable(Class<? extends RealmObject> clazz) {
         Table table = classToTable.get(clazz);
         if (table == null) {
             clazz = Util.getOriginalModelClass(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java b/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
index 0d579c84d3..151b875ece 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
@@ -34,16 +34,16 @@
 public abstract class RealmBaseAdapter<T extends RealmObject> extends BaseAdapter {
 
     protected LayoutInflater inflater;
-    protected RealmResults<T> realmResults;
+    protected OrderedRealmCollection<T> adapterData;
     protected Context context;
     private final RealmChangeListener listener;
 
-    public RealmBaseAdapter(Context context, RealmResults<T> realmResults, boolean automaticUpdate) {
+    public RealmBaseAdapter(Context context, OrderedRealmCollection<T> data, boolean automaticUpdate) {
         if (context == null) {
             throw new IllegalArgumentException("Context cannot be null");
         }
         this.context = context;
-        this.realmResults = realmResults;
+        this.adapterData = data;
         this.inflater = LayoutInflater.from(context);
         this.listener = (!automaticUpdate) ? null : new RealmChangeListener() {
             @Override
@@ -52,8 +52,32 @@ public void onChange() {
             }
         };
 
-        if (listener != null && realmResults != null) {
+        if (listener != null && data != null) {
+            addListener(data);
+        }
+    }
+
+    private void addListener(OrderedRealmCollection<T> data) {
+        if (data instanceof RealmResults) {
+            RealmResults realmResults = (RealmResults) data;
             realmResults.realm.handlerController.addChangeListenerAsWeakReference(listener);
+        } else if (data instanceof RealmList) {
+            RealmList realmList = (RealmList) data;
+            realmList.realm.handlerController.addChangeListenerAsWeakReference(listener);
+        } else {
+            throw new IllegalArgumentException("RealmCollection not supported: " + data.getClass());
+        }
+    }
+
+    private void removeListener(OrderedRealmCollection<T> data) {
+        if (data instanceof RealmResults) {
+            RealmResults realmResults = (RealmResults) data;
+            realmResults.realm.handlerController.removeWeakChangeListener(listener);
+        } else if (data instanceof RealmList) {
+            RealmList realmList = (RealmList) data;
+            realmList.realm.handlerController.removeWeakChangeListener(listener);
+        } else {
+            throw new IllegalArgumentException("RealmCollection not supported: " + data.getClass());
         }
     }
 
@@ -64,10 +88,10 @@ public void onChange() {
      */
     @Override
     public int getCount() {
-        if (realmResults == null) {
+        if (adapterData == null) {
             return 0;
         }
-        return realmResults.size();
+        return adapterData.size();
     }
 
     /**
@@ -78,10 +102,10 @@ public int getCount() {
      */
     @Override
     public T getItem(int i) {
-        if (realmResults == null) {
+        if (adapterData == null) {
             return null;
         }
-        return realmResults.get(i);
+        return adapterData.get(i);
     }
 
     /**
@@ -98,23 +122,35 @@ public long getItemId(int i) {
     }
 
     /**
-     * Updates the RealmResults associated to the Adapter. Useful when the query has been changed.
-     * If the query does not change you might consider using the automaticUpdate feature.
-     *
-     * @param queryResults the new RealmResults coming from the new query.
+     * DEPRECATED: Use {@link #updateData(OrderedRealmCollection)} instead.
      */
+    @Deprecated
     public void updateRealmResults(RealmResults<T> queryResults) {
+        updateData(queryResults);
+    }
+
+    /**
+     * Updates the data associated with the Adapter.
+     *
+     * Note that RealmResults and RealmLists are "live" views, so they will automatically be updated to reflect the
+     * latest changes. This will also trigger {@code notifyDataSetChanged()} to be called on the adapter.
+     *
+     * This method is therefor only useful if you want to display data based on a new query without replacing the
+     * adapter.
+     *
+     * @param data the new {@link OrderedRealmCollection} to display.
+     */
+    public void updateData(OrderedRealmCollection<T> data) {
         if (listener != null) {
-            // Making sure that Adapter is refreshed correctly if new RealmResults come from another Realm
-            if (this.realmResults != null) {
-                this.realmResults.realm.removeChangeListener(listener);
+            if (adapterData != null) {
+                removeListener(adapterData);
             }
-            if (queryResults != null) {
-                queryResults.realm.addChangeListener(listener);
+            if (data != null) {
+                addListener(data);
             }
         }
 
-        this.realmResults = queryResults;
+        this.adapterData = data;
         notifyDataSetChanged();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 5283cb590c..991f596000 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -208,7 +208,7 @@ static synchronized void release(BaseRealm realm) {
     }
 
     /**
-     * Make sure that the new configuration doesn't clash with any cached configurations for the
+     * Makes sure that the new configuration doesn't clash with any cached configurations for the
      * Realm.
      *
      * @throws IllegalArgumentException if the new configuration isn't valid.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
new file mode 100644
index 0000000000..4995ecf21b
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+
+/**
+ * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
+ * collections and the behavior that they will have in all implementations of {@code RealmCollection}s.
+ *
+ * Realm collections are "live" views to the underlying data. This means that they automatically will be kept up to
+ * date. As a consequence, using methods like {@link Collections#unmodifiableCollection(Collection)} will not prevent
+ * a collection from being modified.
+ *
+ * @param <E> type of {@link RealmObject} stored in the collection.
+ */
+public interface RealmCollection<E extends RealmObject> extends Collection<E> {
+
+    /**
+     * Returns a {@link RealmQuery}, which can be used to query for specific objects from this collection.
+     *
+     * @return a RealmQuery object.
+     * @throws IllegalStateException if the Realm instance has been closed or queries are not otherwise available.
+     * @see io.realm.RealmQuery
+     */
+    RealmQuery<E> where();
+
+    /**
+     * Finds the minimum value of a field.
+     *
+     * @param fieldName the field to look for a minimum on. Only number fields are supported.
+     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
+     * returned. Otherwise the minimum value is returned. When determining the minimum value, objects with {@code null}
+     * values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    Number min(String fieldName);
+
+    /**
+     * Finds the maximum value of a field.
+     *
+     * @param fieldName the field to look for a maximum on. Only number fields are supported.
+     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
+     * returned. Otherwise the maximum value is returned. When determining the maximum value, objects with {@code null}
+     * values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    Number max(String fieldName);
+
+    /**
+     * Calculates the sum of a given field.
+     *
+     * @param fieldName the field to sum. Only number fields are supported.
+     * @return the sum. If no objects exist or they all have {@code null} as the value for the given field, {@code 0}
+     * will be returned. When computing the sum, objects with {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    Number sum(String fieldName);
+
+    /**
+     * Returns the average of a given field.
+     *
+     * @param fieldName the field to calculate average on. Only number fields are supported.
+     * @return the average for the given field amongst objects in query results. This will be of type double for all
+     * types of number fields. If no objects exist or they all have {@code null} as the value for the given field,
+     * {@code 0} will be returned. When computing the average, objects with {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    double average(String fieldName);
+
+    /**
+     * Finds the maximum date.
+     *
+     * @param fieldName the field to look for the maximum date. If fieldName is not of Date type, an exception is
+     *                  thrown.
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with
+     * {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    Date maxDate(String fieldName);
+
+    /**
+     * Finds the minimum date.
+     *
+     * @param fieldName the field to look for the minimum date. If fieldName is not of Date type, an exception is
+     *                  thrown.
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with
+     * {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    Date minDate(String fieldName);
+
+    /**
+     * This deletes all objects in the collection from the underlying Realm as well as from the collection.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * @return {@code true} if objects was deleted, {@code false} otherwise.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    boolean deleteAllFromRealm();
+
+    /**
+     * Checks if a collection has finished loading its data yet.
+     *
+     * @return {@code true} if data has been loaded and is available, {@code false} if data is still being loaded.
+     */
+    boolean isLoaded();
+
+    /**
+     * Blocks the collection until all data are available.
+     *
+     * @return {@code true} if the data could be successfully loaded, {@code false} otherwise.
+     */
+    boolean load();
+
+    /**
+     * Checks if the collection is still valid to use e.g. the {@link io.realm.Realm} instance hasn't
+     * been closed.
+     *
+     * @return {@code true} if still valid to use, {@code false} otherwise.
+     */
+    boolean isValid();
+
+    /**
+     * Tests whether this {@code Collection} contains the specified object. Returns
+     * {@code true} if and only if at least one element {@code elem} in this
+     * {@code Collection} meets following requirement:
+     * {@code (object==null ? elem==null : object.equals(elem))}.
+     *
+     * @param object the object to search for.
+     * @return {@code true} if object is an element of this {@code Collection}, {@code false} otherwise.
+     * @throws NullPointerException if the object to look for is {@code null} and this {@code Collection} doesn't
+     *                              support {@code null} elements.
+     */
+    boolean contains(Object object);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 46a77d2535..a0789eee76 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -88,6 +88,7 @@
     private final SharedGroup.Durability durability;
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
+    private final Realm.Transaction initialDataTransaction;
 
     private RealmConfiguration(Builder builder) {
         this.realmFolder = builder.folder;
@@ -100,6 +101,7 @@ private RealmConfiguration(Builder builder) {
         this.durability = builder.durability;
         this.schemaMediator = createSchemaMediator(builder);
         this.rxObservableFactory = builder.rxFactory;
+        this.initialDataTransaction = builder.initialDataTransaction;
     }
 
     public File getRealmFolder() {
@@ -139,6 +141,15 @@ RealmProxyMediator getSchemaMediator() {
         return schemaMediator;
     }
 
+    /**
+     * Returns the transaction instance with initial data.
+     *
+     * @return the initial data transaction.
+     */
+    Realm.Transaction getInitialDataTransaction() {
+        return initialDataTransaction;
+    }
+
     /**
      * Returns the unmodifiable {@link Set} of model classes that make up the schema for this Realm.
      *
@@ -183,7 +194,9 @@ public boolean equals(Object obj) {
         if (!Arrays.equals(key, that.key)) return false;
         if (!durability.equals(that.durability)) return false;
         if (migration != null ? !migration.equals(that.migration) : that.migration != null) return false;
-        if (!rxObservableFactory.equals(that.rxObservableFactory)) return false;
+        //noinspection SimplifiableIfStatement
+        if (rxObservableFactory != null ? !rxObservableFactory.equals(that.rxObservableFactory) : that.rxObservableFactory != null) return false;
+        if (initialDataTransaction != null ? !initialDataTransaction.equals(that.initialDataTransaction) : that.initialDataTransaction != null) return false;
         return schemaMediator.equals(that.schemaMediator);
     }
 
@@ -198,6 +211,8 @@ public int hashCode() {
         result = 31 * result + (deleteRealmIfMigrationNeeded ? 1 : 0);
         result = 31 * result + schemaMediator.hashCode();
         result = 31 * result + durability.hashCode();
+        result = 31 * result + (rxObservableFactory != null ? rxObservableFactory.hashCode() : 0);
+        result = 31 * result + (initialDataTransaction != null ? initialDataTransaction.hashCode() : 0);
 
         return result;
     }
@@ -277,7 +292,7 @@ public String toString() {
     }
 
     /**
-     * Check if RxJava is can be loaded.
+     * Checks if RxJava is can be loaded.
      *
      * @return true if RxJava dependency exist.
      */
@@ -307,6 +322,7 @@ private static synchronized boolean isRxJavaAvailable() {
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmObject>> debugSchema = new HashSet<Class<? extends RealmObject>>();
         private RxObservableFactory rxFactory;
+        private Realm.Transaction initialDataTransaction;
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
@@ -479,6 +495,17 @@ public Builder rxFactory(RxObservableFactory factory) {
             return this;
         }
 
+        /**
+         * Sets the initial data in {@link io.realm.Realm}. This transaction will be executed only for the first time
+         * when database file is created or while migrating the data when {@link Builder#deleteRealmIfMigrationNeeded()} is set.
+         *
+         * @param transaction transaction to execute.
+         */
+        public Builder initialData(Realm.Transaction transaction) {
+            initialDataTransaction = transaction;
+            return this;
+        }
+
         private void addModule(Object module) {
             if (module != null) {
                 checkModule(module);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 5cdd3e4e82..d2edb9917a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -18,13 +18,13 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 
-import io.realm.exceptions.RealmException;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.LinkView;
-import io.realm.internal.Table;
 
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
@@ -44,10 +44,11 @@
  * @param <E> the class of objects in list.
  */
 
-public class RealmList<E extends RealmObject> extends AbstractList<E> {
+public class RealmList<E extends RealmObject> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
     private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
     private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
+    public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction";
 
     private final boolean managedMode;
     protected Class<E> clazz;
@@ -108,17 +109,16 @@ public RealmList(E... objects) {
     }
 
     /**
-     * Checks if {@link io.realm.RealmResults} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't
-     * been closed.
+     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e. the {@link io.realm.Realm}
+     * instance hasn't been closed.
      *
-     * @return {@code true} if still valid to use, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an un-managed list.
      */
     public boolean isValid() {
         //noinspection SimplifiableIfStatement
-        if (!managedMode) {
+        if (realm == null || realm.isClosed()) {
             return false;
         }
-
         return isAttached();
     }
 
@@ -150,6 +150,9 @@ public void add(int location, E object) {
         checkValidObject(object);
         if (managedMode) {
             checkValidView();
+            if (location < 0 || location > size()) {
+                throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size());
+            }
             object = copyToRealmIfNeeded(object);
             view.insert(location, object.row.getIndex());
         } else {
@@ -323,22 +326,85 @@ public E remove(int location) {
     }
 
     /**
-     * Removes all elements from this list and delete them from the corresponding Realm. This method can be called on a
-     * non-managed {@link RealmList} if all of the RealmObjects in the list are managed by Realm.
+     * Removes one instance of the specified object from this {@code Collection} if one
+     * is contained . This implementation iterates over this
+     * {@code Collection} and tests for each element {@code e} returned by the iterator,
+     * whether {@code e} is equal to the given object. If {@code object != null}
+     * then this test is performed using {@code object.equals(e)}, otherwise
+     * using {@code object == null}. If an element equal to the given object is
+     * found, then the {@code remove} method is called on the iterator and
+     * {@code true} is returned, {@code false} otherwise. If the iterator does
+     * not support removing elements, an {@code UnsupportedOperationException}
+     * is thrown.
      *
-     * @throws IllegalStateException if the Realm instance has been closed, the parent object has been removed, the
-     * method is called in a wrong thread or any RealmObject in the list is not managed by Realm.
-     * @see #clear()
+     * @param object the object to remove.
+     * @return {@code true} if this {@code Collection} is modified, {@code false} otherwise.
+     * @throws ClassCastException if the object passed is not of the correct type.
+     * @throws NullPointerException  if {@code object} is {@code null}.
      */
-    public void deleteAllFromRealm() {
+    @Override
+    public boolean remove(Object object) {
+        if (managedMode && !realm.isInTransaction()) {
+            throw new IllegalStateException(REMOVE_OUTSIDE_TRANSACTION_ERROR);
+        }
+        return super.remove(object);
+    }
+
+    /**
+     * Removes all occurrences in this {@code Collection} of each object in the
+     * specified {@code Collection}. After this method returns none of the
+     * elements in the passed {@code Collection} can be found in this {@code Collection}
+     * anymore.
+     * <p>
+     * This implementation iterates over this {@code Collection} and tests for each
+     * element {@code e} returned by the iterator, whether it is contained in
+     * the specified {@code Collection}. If this test is positive, then the {@code
+     * remove} method is called on the iterator.
+     *
+     * @param collection the collection of objects to remove.
+     * @return {@code true} if this {@code Collection} is modified, {@code false} otherwise.
+     * @throws ClassCastException if one or more elements of {@code collection} isn't of the correct type.
+     * @throws NullPointerException if {@code collection} is {@code null}.
+     */
+    @Override
+    public boolean removeAll(Collection<?> collection) {
+        if (managedMode && !realm.isInTransaction()) {
+            throw new IllegalStateException(REMOVE_OUTSIDE_TRANSACTION_ERROR);
+        }
+        return super.removeAll(collection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean deleteFirstFromRealm() {
         if (managedMode) {
-            checkValidView();
-            view.removeAllTargetRows();
+            if (size() > 0) {
+                deleteFromRealm(0);
+                return true;
+            } else {
+                return false;
+            }
         } else {
-            for (RealmObject object : nonManagedList) {
-                object.removeFromRealm();
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean deleteLastFromRealm() {
+        if (managedMode) {
+            if (size() > 0) {
+                deleteFromRealm(size() - 1);
+                return true;
+            } else {
+                return false;
             }
-            nonManagedList.clear();
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
     }
 
@@ -370,11 +436,13 @@ public E get(int location) {
     public E first() {
         if (managedMode) {
             checkValidView();
-            return view.isEmpty() ? null : get(0);
+            if (!view.isEmpty()) {
+                return get(0);
+            }
         } else if (nonManagedList != null && nonManagedList.size() > 0) {
             return nonManagedList.get(0);
         }
-        return null;
+        throw new IndexOutOfBoundsException("The list is empty.");
     }
 
     /**
@@ -386,11 +454,66 @@ public E first() {
     public E last() {
         if (managedMode) {
             checkValidView();
-            return view.isEmpty() ? null : get((int) view.size() - 1);
+            if (!view.isEmpty()) {
+                return get((int) view.size() - 1);
+            }
         } else if (nonManagedList != null && nonManagedList.size() > 0) {
             return nonManagedList.get(nonManagedList.size() - 1);
         }
-        return null;
+        throw new IndexOutOfBoundsException("The list is empty.");
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName) {
+        return this.sort(fieldName, Sort.ASCENDING);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName, Sort sortOrder) {
+        if (managedMode) {
+            return this.where().findAllSorted(fieldName, sortOrder);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        return sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders) {
+        if (managedMode) {
+            return where().findAllSorted(fieldNames, sortOrders);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void deleteFromRealm(int location) {
+        if (managedMode) {
+            checkValidView();
+            view.removeTargetRow(location);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
     }
 
     /**
@@ -422,10 +545,116 @@ public int size() {
             checkValidView();
             return RealmQuery.createQueryFromList(this);
         } else {
-            throw new RealmException(ONLY_IN_MANAGED_MODE_MESSAGE);
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Number min(String fieldName) {
+        if (managedMode) {
+            return this.where().min(fieldName);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Number max(String fieldName) {
+        if (managedMode) {
+            return this.where().max(fieldName);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Number sum(String fieldName) {
+        if (managedMode) {
+            return this.where().sum(fieldName);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public double average(String fieldName) {
+        if (managedMode) {
+            return this.where().average(fieldName);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Date maxDate(String fieldName) {
+        if (managedMode) {
+            return this.where().maximumDate(fieldName);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Date minDate(String fieldName) {
+        if (managedMode) {
+            return this.where().minimumDate(fieldName);
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean deleteAllFromRealm() {
+        if (managedMode) {
+            checkValidView();
+            if (size() > 0) {
+                view.removeAllTargetRows();
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isLoaded() {
+        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean load() {
+        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+    }
+
     /**
      * Returns true if the list contains the specified element when attached to a Realm. This
      * method will query the native Realm underlying storage engine to quickly find the specified element.
@@ -440,6 +669,7 @@ public int size() {
     public boolean contains(Object object) {
         boolean contains = false;
         if (managedMode) {
+            realm.checkIfValid();
             if (object instanceof RealmObject) {
                 RealmObject realmObject = (RealmObject) object;
                 if (realmObject.row != null && realm.getPath().equals(realmObject.realm.getPath()) && realmObject.row != InvalidRow.INSTANCE) {
@@ -468,7 +698,7 @@ private void checkIndex(int location) {
     private void checkValidView() {
         realm.checkIfValid();
         if (view == null || !view.isAttached()) {
-            throw new IllegalStateException("Realm instance has been closed or parent object has been removed.");
+            throw new IllegalStateException("Realm instance has been closed or this object or its parent has been deleted.");
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 03827e330e..3d711f6d7f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -79,6 +79,8 @@
     private long currentTableVersion = -1;
 
     /**
+     * DEPRECATED: Use {@link #deleteFromRealm()} instead.
+     *
      * Removes the object from the Realm it is currently associated to.
      * <p>
      * After this method is called the object will be invalid and any operation (read or write) performed on it will
@@ -86,7 +88,21 @@
      *
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      */
+    @Deprecated
     public void removeFromRealm() {
+        deleteFromRealm();
+    }
+
+    /**
+     * Deletes the object from the Realm it is currently associated to.
+     * <p>
+     * After this method is called the object will be invalid and any operation (read or write) performed on it will
+     * fail with an IllegalStateException.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * @see #isValid()
+     */
+    public void deleteFromRealm() {
         if (row == null) {
             throw new IllegalStateException("Object malformed: missing object in Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 47966ecc27..fad1bd5483 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -132,7 +132,7 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
         FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
         if (metadata == null) {
             if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
-                throw new IllegalArgumentException("Use addLinkField() instead to add fields that link to other RealmObjects: " + fieldName);
+                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
             } else {
                 throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
                         fieldName, fieldType));
@@ -260,6 +260,7 @@ public RealmObjectSchema addIndex(String fieldName) {
      *
      * @param fieldName existing field name to check.
      * @return {@code true} if field is indexed, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
      * @see io.realm.annotations.Index
      */
     public boolean hasIndex(String fieldName) {
@@ -376,12 +377,12 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
      * Checks if a given field is required, i.e. is not allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
-     * @return {@code true} if it is requied, {@code false} otherwise.
+     * @return {@code true} if it is required, {@code false} otherwise.
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setRequired(String, boolean)
      */
     public boolean isRequired(String fieldName) {
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
         return !table.isColumnNullable(columnIndex);
     }
 
@@ -389,15 +390,28 @@ public boolean isRequired(String fieldName) {
      * Checks if a given field is nullable, i.e. is allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
-     * @return {@code true} if it is requied, {@code false} otherwise.
+     * @return {@code true} if it is required, {@code false} otherwise.
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setNullable(String, boolean)
      */
     public boolean isNullable(String fieldName) {
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
         return table.isColumnNullable(columnIndex);
     }
 
+    /**
+     * Checks if a given field is the primary key field.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is the primary key field, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #addPrimaryKey(String)
+     */
+    public boolean isPrimaryKey(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return columnIndex == table.getPrimaryKey();
+    }
+
     /**
      * Checks if the class has a primary key defined.
      *
@@ -409,7 +423,7 @@ public boolean hasPrimaryKey() {
     }
 
     /**
-     * Return all fields in this class.
+     * Returns all fields in this class.
      *
      * @return a list of all the fields in this class.
      */
@@ -593,15 +607,29 @@ private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validCol
 
     /**
      * Returns the column index in the underlying table for the given field name.
-     * INVARIANT: fieldName should be present.
      *
      * @param fieldName field name to find index for.
-     * @return column index
+     * @return column index or null if it doesn't exists.
      */
     Long getFieldIndex(String fieldName) {
         return columnIndices.get(fieldName);
     }
 
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     *
+     * @param fieldName field name to find index for.
+     * @return column index.
+     * @throws IllegalArgumentException if the field does not exists.
+     */
+    long getAndCheckFieldIndex(String fieldName) {
+        Long index = columnIndices.get(fieldName);
+        if (index == null) {
+            throw new IllegalArgumentException("Field does not exist: " + fieldName);
+        }
+        return index;
+    }
+
     /**
      * Returns the type used by the underlying storage engine to represent this field.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 11a461ad68..eb539b1cc9 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -36,6 +36,7 @@
 import io.realm.internal.TableQuery;
 import io.realm.internal.TableView;
 import io.realm.internal.async.ArgumentsHolder;
+import io.realm.internal.async.BadVersionException;
 import io.realm.internal.async.QueryUpdateTask;
 import io.realm.internal.log.RealmLog;
 
@@ -1286,7 +1287,7 @@ static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
     public Number sum(String fieldName) {
-        long columnIndex = schema.getFieldIndex(fieldName);
+        long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return query.sumInt(columnIndex);
@@ -1311,7 +1312,7 @@ public Number sum(String fieldName) {
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
     public double average(String fieldName) {
-        long columnIndex = schema.getFieldIndex(fieldName);
+        long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return query.averageInt(columnIndex);
@@ -1337,7 +1338,7 @@ public double average(String fieldName) {
      */
     public Number min(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return this.query.minimumInt(columnIndex);
@@ -1360,7 +1361,7 @@ public Number min(String fieldName) {
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
     public Date minimumDate(String fieldName) {
-        long columnIndex = schema.getFieldIndex(fieldName);
+        long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         return this.query.minimumDate(columnIndex);
     }
 
@@ -1377,7 +1378,7 @@ public Date minimumDate(String fieldName) {
      */
     public Number max(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return this.query.maximumInt(columnIndex);
@@ -1400,7 +1401,7 @@ public Number max(String fieldName) {
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
     public Date maximumDate(String fieldName) {
-        long columnIndex = schema.getFieldIndex(fieldName);
+        long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         return this.query.maximumDate(columnIndex);
     }
 
@@ -1492,6 +1493,11 @@ public Long call() throws Exception {
 
                         return handoverTableViewPointer;
 
+                    } catch (BadVersionException e) {
+                        // In some rare race conditions, this can happen. In that case, just ignore the error.
+                        RealmLog.d("findAllAsync handover could not complete due to a BadVersionException. " +
+                                "Retry is scheduled by a REALM_CHANGED event.");
+
                     } catch (Exception e) {
                         RealmLog.e(e.getMessage(), e);
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
@@ -1605,6 +1611,11 @@ public Long call() throws Exception {
                                 weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
 
                         return handoverTableViewPointer;
+                    } catch (BadVersionException e) {
+                        // In some rare race conditions, this can happen. In that case, just ignore the error.
+                        RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
+                                "Retry is scheduled by a REALM_CHANGED event.");
+
                     } catch (Exception e) {
                         RealmLog.e(e.getMessage(), e);
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
@@ -1771,6 +1782,11 @@ public Long call() throws Exception {
                                     weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
 
                             return handoverTableViewPointer;
+                        } catch (BadVersionException e) {
+                            // In some rare race conditions, this can happen. In that case, just ignore the error.
+                            RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
+                                    "Retry is scheduled by a REALM_CHANGED event.");
+
                         } catch (Exception e) {
                             RealmLog.e(e.getMessage(), e);
                             closeSharedGroupAndSendMessageToHandler(sharedGroup,
@@ -2036,6 +2052,9 @@ private long getSourceRowIndexForFirstObject() {
     // Get the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
     // or it belongs to the child object.
     private long getColumnIndexForSort(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Non-empty fieldname required.");
+        }
         if (fieldName.contains(".")) {
             throw new IllegalArgumentException("Sorting using child object fields is not supported: " + fieldName);
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 017a1e0013..b2c3543d50 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -18,22 +18,24 @@
 
 
 import java.util.AbstractList;
-import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.ConcurrentModificationException;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.NoSuchElementException;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
 import io.realm.exceptions.RealmException;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.TableQuery;
 import io.realm.internal.TableView;
-import io.realm.internal.Table;
+import io.realm.internal.async.BadVersionException;
 import io.realm.internal.log.RealmLog;
 import rx.Observable;
 
@@ -65,7 +67,9 @@
  * @see Realm#allObjects(Class)
  * @see io.realm.Realm#beginTransaction()
  */
-public final class RealmResults<E extends RealmObject> extends AbstractList<E> {
+public final class RealmResults<E extends RealmObject> extends AbstractList<E> implements OrderedRealmCollection<E> {
+
+    private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by RealmResults.";
 
     BaseRealm realm;
     Class<E> classSpec;   // Return type
@@ -81,6 +85,7 @@
     private Future<Long> pendingQuery;
     private boolean isCompleted = false;
 
+
     static <E extends RealmObject> RealmResults<E> createFromTableQuery(BaseRealm realm, TableQuery query, Class<E> clazz) {
         return new RealmResults<E>(realm, query, clazz);
     }
@@ -149,22 +154,16 @@ TableOrView getTable() {
     }
 
     /**
-     * Checks if {@link io.realm.RealmResults} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't
-     * been closed.
-     *
-     * @return {@code true} if still valid to use, {@code false} otherwise.
+     * {@inheritDoc}
      */
     public boolean isValid() {
         return realm != null && !realm.isClosed();
     }
 
     /**
-     * Returns a typed {@link io.realm.RealmQuery}, which can be used to query for specific objects of this type.
-     *
-     * @return a typed RealmQuery.
-     * @see io.realm.RealmQuery
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * {@inheritDoc}
      */
+    @Override
     public RealmQuery<E> where() {
         realm.checkIfValid();
 
@@ -212,33 +211,53 @@ public E get(int location) {
     }
 
     /**
-     * This method is not supported.
-     *
-     * @throws NoSuchMethodError always.
+     * {@inheritDoc}
      */
     @Override
-    public int indexOf(Object o) {
-        throw new NoSuchMethodError("indexOf is not supported on RealmResults");
+    public E first() {
+        if (size() > 0) {
+            return get(0);
+        } else {
+            throw new IndexOutOfBoundsException("No results was found.");
+        }
     }
 
     /**
-     * Gets the first object from the list.
-     *
-     * @return the first object.
-     * @throws ArrayIndexOutOfBoundsException if RealmResults is empty.
+     * {@inheritDoc}
      */
-    public E first() {
-        return get(0);
+    @Override
+    public E last() {
+        int size = size();
+        if (size > 0) {
+            return get(size - 1);
+        } else {
+            throw new IndexOutOfBoundsException("No results was found.");
+        }
     }
 
     /**
-     * Gets the last object from the list.
-     *
-     * @return the last object.
-     * @throws ArrayIndexOutOfBoundsException if RealmResults is empty.
+     * {@inheritDoc}
      */
-    public E last() {
-        return get(size()-1);
+    @Override
+    public void deleteFromRealm(int location) {
+        realm.checkIfValid();
+        TableOrView table = getTable();
+        table.remove(location);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean deleteAllFromRealm() {
+        realm.checkIfValid();
+        if (size() > 0) {
+            TableOrView table = getTable();
+            table.clear();
+            return true;
+        } else {
+            return false;
+        }
     }
 
     /**
@@ -294,7 +313,10 @@ public E last() {
     // Sorting
 
     // aux. method used by sort methods
-    private long getColumnIndex(String fieldName) {
+    private long getColumnIndexForSort(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Non-empty field name required.");
+        }
         if (fieldName.contains(".")) {
             throw new IllegalArgumentException("Sorting using child object fields is not supported: " + fieldName);
         }
@@ -306,87 +328,42 @@ private long getColumnIndex(String fieldName) {
     }
 
     /**
-     * Sorts (ascending) an existing {@link io.realm.RealmResults}.
-     *
-     * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
-     *                  and String are supported.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * {@inheritDoc}
      */
-    public void sort(String fieldName) {
-        this.sort(fieldName, Sort.ASCENDING);
+    @Override
+    public RealmResults<E> sort(String fieldName) {
+        return this.sort(fieldName, Sort.ASCENDING);
     }
 
     /**
-     * Sorts existing {@link io.realm.RealmResults}.
-     *
-     * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
-     *                  and String are supported.
-     * @param sortOrder the direction to sort by.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * {@inheritDoc}
      */
-    public void sort(String fieldName, Sort sortOrder) {
-        if (fieldName == null) {
-            throw new IllegalArgumentException("fieldName must be provided");
-        }
-        realm.checkIfValid();
-        TableOrView table = getTable();
-
-        if (table instanceof TableView) {
-            long columnIndex = getColumnIndex(fieldName);
-            ((TableView) table).sort(columnIndex, sortOrder);
-        } else {
-            throw new IllegalArgumentException("Only RealmResults can be sorted - please use allObject() to create a RealmResults.");
-        }
+    @Override
+    public RealmResults<E> sort(String fieldName, Sort sortOrder) {
+        return where().findAllSorted(fieldName, sortOrder);
     }
 
     /**
-     * Sorts existing {@link io.realm.RealmResults}.
-     *
-     * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int, long, float,
-     *                   double, Date, and String are supported.
-     * @param sortOrders the directions to sort by.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * {@inheritDoc}
      */
-    public void sort(String fieldNames[], Sort sortOrders[]) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames must be provided.");
-        } else if (sortOrders == null) {
-            throw new IllegalArgumentException("sortOrder must be provided.");
-        }
-
-        if (fieldNames.length == 1 && sortOrders.length == 1) {
-            sort(fieldNames[0], sortOrders[0]);
-        } else {
-            realm.checkIfValid();
-            TableOrView table = getTable();
-            if (table instanceof TableView) {
-                List<Long> columnIndices = new ArrayList<Long>();
-                for (int i = 0; i < fieldNames.length; i++) {
-                    String fieldName = fieldNames[i];
-                    long columnIndex = getColumnIndex(fieldName);
-                    columnIndices.add(columnIndex);
-                }
-                ((TableView) table).sort(columnIndices, sortOrders);
-            }
-        }
+    @Override
+    public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
+        return where().findAllSorted(fieldNames, sortOrders);
     }
 
     /**
-     * Sorts existing {@link io.realm.RealmResults} using two fields.
-     *
-     * @param fieldName1 first field name.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name.
-     * @param sortOrder2 sort order for second field.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * {@inheritDoc}
      */
-    public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
-        sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
+    @Override
+    public RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        return sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
     /**
      * Sorts existing {@link io.realm.RealmResults} using three fields.
      *
+     * DEPRECATED: Use {@link #sort(String[], Sort[])} instead.
+     *
      * @param fieldName1 first field name.
      * @param sortOrder1 sort order for first field.
      * @param fieldName2 second field name.
@@ -395,6 +372,7 @@ public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sor
      * @param sortOrder3 sort order for third field.
      * @throws java.lang.IllegalArgumentException if a field name does not exist.
      */
+    @Deprecated
     public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2, String fieldName3, Sort sortOrder3) {
         sort(new String[]{fieldName1, fieldName2, fieldName3}, new Sort[]{sortOrder1, sortOrder2, sortOrder3});
     }
@@ -417,17 +395,11 @@ public int size() {
     }
 
     /**
-     * Finds the minimum value of a field.
-     *
-     * @param fieldName the field to look for a minimum on. Only number fields are supported.
-     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
-     * returned. Otherwise the minimum value is returned. When determining the minimum value, objects with {@code null}
-     * values are ignored.
-     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * {@inheritDoc}
      */
     public Number min(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndexForSort(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return table.minimumLong(columnIndex);
@@ -441,18 +413,11 @@ public Number min(String fieldName) {
     }
 
     /**
-     * Finds the minimum date.
-     *
-     * @param fieldName the field to look for the minimum date. If fieldName is not of Date type, an exception is
-     *                  thrown.
-     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
-     * will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with
-     * {@code null} values are ignored.
-     * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
+     * {@inheritDoc}
      */
     public Date minDate(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndexForSort(fieldName);
         if (table.getColumnType(columnIndex) == RealmFieldType.DATE) {
             return table.minimumDate(columnIndex);
         }
@@ -462,17 +427,11 @@ public Date minDate(String fieldName) {
     }
 
     /**
-     * Finds the maximum value of a field.
-     *
-     * @param fieldName the field to look for a maximum on. Only number fields are supported.
-     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
-     * returned. Otherwise the maximum value is returned. When determining the maximum value, objects with {@code null}
-     * values are ignored.
-     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * {@inheritDoc}
      */
     public Number max(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndexForSort(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return table.maximumLong(columnIndex);
@@ -497,7 +456,7 @@ public Number max(String fieldName) {
      */
     public Date maxDate(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndexForSort(fieldName);
         if (table.getColumnType(columnIndex) == RealmFieldType.DATE) {
             return table.maximumDate(columnIndex);
         }
@@ -508,16 +467,11 @@ public Date maxDate(String fieldName) {
 
 
     /**
-     * Calculates the sum of a given field.
-     *
-     * @param fieldName the field to sum. Only number fields are supported.
-     * @return the sum. If no objects exist or they all have {@code null} as the value for the given field, {@code 0}
-     * will be returned. When computing the sum, objects with {@code null} values are ignored.
-     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * {@inheritDoc}
      */
     public Number sum(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndexForSort(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return table.sumLong(columnIndex);
@@ -530,19 +484,12 @@ public Number sum(String fieldName) {
         }
     }
 
-
     /**
-     * Returns the average of a given field.
-     *
-     * @param fieldName the field to calculate average on. Only number fields are supported.
-     * @return the average for the given field amongst objects in query results. This will be of type double for all
-     * types of number fields. If no objects exist or they all have {@code null} as the value for the given field,
-     * {@code 0} will be returned. When computing the average, objects with {@code null} values are ignored.
-     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     * {@inheritDoc}
      */
     public double average(String fieldName) {
         realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
+        long columnIndex = getColumnIndexForSort(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
                 return table.averageLong(columnIndex);
@@ -613,73 +560,162 @@ public double average(String fieldName) {
     // Deleting
 
     /**
-     * Removes an object at a given index. This also deletes the object from the underlying Realm.
-     *
-     * Using this method while iterating the list can result in a undefined behavior. Use
-     * {@link io.realm.RealmResults.RealmResultsIterator#remove()} instead.
+     * Not supported by RealmResults.
      *
-     * @param index the array index identifying the object to be removed.
-     * @return always return {@code null}.
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * @throws UnsupportedOperationException always.
      */
+    @Deprecated
     @Override
     public E remove(int index) {
-        realm.checkIfValid();
-        TableOrView table = getTable();
-        table.remove(index);
-        return null; // Returning the object doesn't make sense, since it could no longer access any data.
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Deprecated
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Deprecated
+    @Override
+    public boolean removeAll(Collection<?> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Deprecated
+    @Override
+    public E set(int location, E object) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+
+
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Deprecated
+    @Override
+    public boolean retainAll(Collection<?> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
     }
 
     /**
      * Removes the last object in the list. This also deletes the object from the underlying Realm.
      *
-     * Using this method while iterating the list can result in a undefined behavior. Use
-     * {@link io.realm.RealmResults.RealmResultsListIterator#removeLast()} instead.
+     * DEPRECATED: Use {@link #deleteLastFromRealm()} instead.
      *
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      */
+    @Deprecated
     public void removeLast() {
+        deleteLastFromRealm();
+    }
+
+    /**
+     * Removes the last object in the list. This also deletes the object from the underlying Realm.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    @Override
+    public boolean deleteLastFromRealm() {
         realm.checkIfValid();
-        TableOrView table = getTable();
-        table.removeLast();
+        if (size() > 0) {
+            TableOrView table = getTable();
+            table.removeLast();
+            return true;
+        } else {
+            return false;
+        }
     }
 
     /**
-     * Removes all objects from the list. This also deletes the objects from the underlying Realm.
+     * Removes the first object in the list. This also deletes the object from the underlying Realm.
      *
      * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
      */
-    public void clear() {
+    @Override
+    public boolean deleteFirstFromRealm() {
         realm.checkIfValid();
-        TableOrView table = getTable();
-        table.clear();
+        if (size() > 0) {
+            TableOrView table = getTable();
+            table.removeFirst();
+            return true;
+        } else {
+            return false;
+        }
     }
 
-    // Adding objects
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    @Deprecated
+    public void clear() {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
 
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
     @Override
     @Deprecated
     public boolean add(E element) {
-        throw new UnsupportedOperationException();
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
     }
 
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
     @Override
     @Deprecated
     public void add(int index, E element) {
-        throw new UnsupportedOperationException();
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
     }
-//
-//    /**
-//     * Replaces an object at the given index with a new object.
-//     *
-//     * @param index the array index of the object to be replaced.
-//     * @param element an object.
-//     */
-//    public void replace(int index, E element) {
-//        throw new NoSuchMethodError();
-//    }
 
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    @Deprecated
+    public boolean addAll(int location, Collection<? extends E> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
 
+    /**
+     * Not supported by RealmResults.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Deprecated
+    @Override
+    public boolean addAll(Collection<? extends E> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
 
     // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
     private class RealmResultsIterator implements Iterator<E> {
@@ -705,10 +741,9 @@ public E next() {
         }
 
         /**
-         * Removes the RealmObject at the current position from both the list and the underlying Realm.
+         * Not supported by RealmResults.
          *
-         * WARNING: This method is currently disabled and will always throw an
-         * {@link io.realm.exceptions.RealmException}
+         * @throws UnsupportedOperationException always.
          */
         public void remove() {
             throw new RealmException("Removing is not supported.");
@@ -754,7 +789,7 @@ public void add(E object) {
         @Override
         public boolean hasPrevious() {
             assertRealmIsStable();
-            return pos > 0;
+            return pos >= 0;
         }
 
         @Override
@@ -766,11 +801,13 @@ public int nextIndex() {
         @Override
         public E previous() {
             assertRealmIsStable();
-            pos--;
-            if (pos < 0) {
-                throw new IndexOutOfBoundsException("Cannot access index less than zero. This was " + pos + ". Remember to check hasPrevious() before using previous().");
+            try {
+                E obj = get(pos);
+                pos--;
+                return obj;
+            } catch (IndexOutOfBoundsException e) {
+                throw new NoSuchElementException("Cannot access index less than zero. This was " + pos + ". Remember to check hasPrevious() before using previous().");
             }
-            return get(pos);
         }
 
         @Override
@@ -784,7 +821,6 @@ public void set(E object) {
             throw new RealmException("Replacing elements not supported.");
         }
 
-
         /**
          * Removes the RealmObject at the current position from both the list and the underlying Realm.
          *
@@ -800,10 +836,15 @@ public void set(E object) {
      * thread.
      *
      * @param handoverTableViewPointer handover pointer to the new table_view.
+     * @throws IllegalStateException if caller and worker are not at the same version.
      */
     void swapTableViewPointer(long handoverTableViewPointer) {
-        table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedGroupManager.getNativePointer());
-        isCompleted = true;
+        try {
+            table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedGroupManager.getNativePointer());
+            isCompleted = true;
+        } catch (BadVersionException e) {
+            throw new IllegalStateException("Caller and Worker Realm should have been at the same version");
+        }
     }
 
     /**
@@ -956,7 +997,7 @@ public void removeChangeListeners() {
      * Notifies all registered listeners.
      */
     void notifyChangeListeners() {
-        if (listeners != null && !listeners.isEmpty()) {
+        if (!listeners.isEmpty()) {
             // table might be null (if the async query didn't complete
             // but we have already registered listeners for it)
             if (pendingQuery != null && !isCompleted) return;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index ae0b460365..570ec29a54 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -52,8 +52,7 @@ private CheckedRow(UncheckedRow row) {
     public static CheckedRow get(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
         CheckedRow row = new CheckedRow(context, table, nativeRowPointer);
-        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
-                Context.NATIVE_REFERENCES_VALUE);
+        context.addReference(NativeObjectReference.TYPE_ROW, row);
         return row;
     }
 
@@ -69,8 +68,7 @@ public static CheckedRow get(Context context, LinkView linkView, long index) {
         long nativeRowPointer = linkView.nativeGetRow(linkView.nativePointer, index);
         CheckedRow row = new CheckedRow(context, linkView.getTargetTable(),
                 nativeRowPointer);
-        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
-                Context.NATIVE_REFERENCES_VALUE);
+        context.addReference(NativeObjectReference.TYPE_ROW, row);
         return row;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Context.java b/realm/realm-library/src/main/java/io/realm/internal/Context.java
index f2f5f5215b..8d241d0043 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Context.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Context.java
@@ -16,61 +16,92 @@
 
 package io.realm.internal;
 
-import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 
 public class Context {
 
+    // Pool to hold the phantom references.
+    // The size of array for storing phantom references will never decrease. Instead, we use another array to hold the
+    // index of the free slot. When adding the reference, pick the last index from freeIndexList and put the reference
+    // to the corresponding slot. When removing the reference, simply add the index to the end of freeIndexList without
+    // setting the corresponding slot to null for efficiency reasons. The reference will be freed finally when the slot
+    // gets overwritten or the whole context gets freed.
+    private static class ReferencesPool {
+        ArrayList<NativeObjectReference> pool = new ArrayList<NativeObjectReference>();
+        ArrayList<Integer> freeIndexList = new ArrayList<Integer>();
+
+        void add(NativeObjectReference ref) {
+            if (pool.size() <= ref.refIndex) {
+                pool.add(ref);
+            } else {
+                pool.set(ref.refIndex, ref);
+            }
+        }
+
+        Integer getFreeIndex() {
+            Integer index;
+            int freeIndexListSize = freeIndexList.size();
+            if (freeIndexListSize == 0) {
+                index = pool.size();
+            } else {
+                index = freeIndexList.remove(freeIndexListSize - 1);
+            }
+            return index;
+        }
+    }
+
     // Each group of related Realm objects will have a Context object in the root.
     // The root can be a table, a group, or a shared group.
     // The Context object is used to store a list of native pointers 
     // whose disposal need to be handed over from the garbage 
     // collection thread to the users thread.
 
-    // Reserved to be used only as a placeholder by native references Map to avoid autoboxing allocations
-    static final Integer NATIVE_REFERENCES_VALUE = 0;
-
     private List<Long> abandonedTables = new ArrayList<Long>();
     private List<Long> abandonedTableViews = new ArrayList<Long>();
     private List<Long> abandonedQueries = new ArrayList<Long>();
 
-    HashMap<Reference<?>, Integer> rowReferences = new HashMap<Reference<?>, Integer>();
-    ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
+    private ReferencesPool referencesPool = new ReferencesPool();
+    private ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
 
     private boolean isFinalized = false;
 
-    public void executeDelayedDisposal() {
-        synchronized (this) {
-            for (int i = 0; i < abandonedTables.size(); i++) {
-                long nativePointer = abandonedTables.get(i);
-                Table.nativeClose(nativePointer);
-            }
-            abandonedTables.clear();
+    public synchronized void addReference(int type, NativeObject referent) {
+        referencesPool.add(new NativeObjectReference(type, referent, referenceQueue, referencesPool.getFreeIndex()));
+    }
 
-            for (int i = 0; i < abandonedTableViews.size(); i++) {
-                long nativePointer = abandonedTableViews.get(i);
-                TableView.nativeClose(nativePointer);
-            }
-            abandonedTableViews.clear();
+    public synchronized void executeDelayedDisposal() {
+        for (int i = 0; i < abandonedTables.size(); i++) {
+            long nativePointer = abandonedTables.get(i);
+            Table.nativeClose(nativePointer);
+        }
+        abandonedTables.clear();
 
-            for (int i = 0; i < abandonedQueries.size(); i++) {
-                long nativePointer = abandonedQueries.get(i);
-                TableQuery.nativeClose(nativePointer);
-            }
-            abandonedQueries.clear();
+        for (int i = 0; i < abandonedTableViews.size(); i++) {
+            long nativePointer = abandonedTableViews.get(i);
+            TableView.nativeClose(nativePointer);
+        }
+        abandonedTableViews.clear();
 
-            cleanNativeReferences();
+        for (int i = 0; i < abandonedQueries.size(); i++) {
+            long nativePointer = abandonedQueries.get(i);
+            TableQuery.nativeClose(nativePointer);
         }
+        abandonedQueries.clear();
+
+        cleanNativeReferences();
     }
 
-    public void cleanNativeReferences() {
+    private void cleanNativeReferences() {
         NativeObjectReference reference = (NativeObjectReference) referenceQueue.poll();
         while (reference != null) {
-            reference.clear();
-            rowReferences.remove(reference);
+            // Dealloc the native resources
+            reference.cleanup();
+            // Inline referencesPool.remove() to make it faster.
+            // referencesPool.pool.set(index, null); is not really needed. Make it faster by not
+            // setting the slot to null.
+            referencesPool.freeIndexList.add(reference.refIndex);
             reference = (NativeObjectReference) referenceQueue.poll();
         }
     }
@@ -110,10 +141,11 @@ public void asyncDisposeSharedGroup(long nativePointer) {
         SharedGroup.nativeClose(nativePointer);
     }
 
-    protected void finalize() {
+    protected void finalize() throws Throwable {
         synchronized (this) {
             isFinalized = true;
         }
         executeDelayedDisposal();
+        super.finalize();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Group.java b/realm/realm-library/src/main/java/io/realm/internal/Group.java
index be068092b2..3b5cc85ef2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Group.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Group.java
@@ -237,7 +237,7 @@ public void writeToFile(File file, byte[] key) throws IOException {
     }
 
     /*
-     * Check if the Group contains any objects. It only checks for "class_" tables or non-metadata tables, e.g. this
+     * Checks if the Group contains any objects. It only checks for "class_" tables or non-metadata tables, e.g. this
      * return true if the "pk" table contained information.
      *
      * @return {@code true} if empty, @{code false} otherwise.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
index 55d55c4ad0..cd6a3c62eb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
@@ -16,6 +16,8 @@
 
 package io.realm.internal;
 
+import io.realm.internal.async.BadVersionException;
+
 public class ImplicitTransaction extends Group {
 
     private final SharedGroup parent;
@@ -38,7 +40,7 @@ public void advanceRead() {
      *
      * @param versionID version of the shared group.
      */
-    public void advanceRead(SharedGroup.VersionID versionID) {
+    public void advanceRead(SharedGroup.VersionID versionID) throws BadVersionException {
         assertNotClosed();
         parent.advanceRead(versionID);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index 98887cdcde..3e6869ffeb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -17,25 +17,12 @@
 package io.realm.internal;
 
 import io.realm.RealmFieldType;
-import java.lang.ref.ReferenceQueue;
 
 /**
  * The LinkView class represents a core {@link RealmFieldType#LIST}.
  */
 public class LinkView extends NativeObject {
 
-    private static class LinkViewReference extends NativeObjectReference {
-
-        public LinkViewReference(NativeObject referent, ReferenceQueue<? super NativeObject> referenceQueue) {
-            super(referent, referenceQueue);
-        }
-
-        @Override
-        protected void cleanup() {
-            nativeClose(nativePointer);
-        }
-    }
-
     private final Context context;
     final Table parent;
     final long columnIndexInParent;
@@ -46,8 +33,8 @@ public LinkView(Context context, Table parent, long columnIndexInParent, long na
         this.columnIndexInParent = columnIndexInParent;
         this.nativePointer = nativeLinkViewPtr;
 
-        context.cleanNativeReferences();
-        context.rowReferences.put(new LinkViewReference(this, context.referenceQueue), Context.NATIVE_REFERENCES_VALUE);
+        context.executeDelayedDisposal();
+        context.addReference(NativeObjectReference.TYPE_LINK_VIEW, this);
     }
 
     /**
@@ -153,6 +140,14 @@ public void removeAllTargetRows() {
         nativeRemoveAllTargetRows(nativePointer);
     }
 
+    /**
+     * Removes target row from both the Realm and the LinkView.
+     */
+    public void removeTargetRow(int index) {
+        checkImmutable();
+        nativeRemoveTargetRow(nativePointer, index);
+    }
+
     public Table getTargetTable() {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
@@ -168,11 +163,11 @@ public Table getTargetTable() {
 
     private void checkImmutable() {
         if (parent.isImmutable()) {
-            throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
+            throw new IllegalStateException("Changing Realm data can only be done from inside a write transaction.");
         }
     }
 
-    private static native void nativeClose(long nativeLinkViewPtr);
+    static native void nativeClose(long nativeLinkViewPtr);
     native long nativeGetRow(long nativeLinkViewPtr, long pos);
     private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
     private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
@@ -186,6 +181,7 @@ private void checkImmutable() {
     protected native long nativeWhere(long nativeLinkViewPtr);
     private native boolean nativeIsAttached(long nativeLinkViewPtr);
     private native long nativeFind(long nativeLinkViewPtr, long targetRowIndex);
+    private native void nativeRemoveTargetRow(long nativeLinkViewPtr, long rowIndex);
     private native void nativeRemoveAllTargetRows(long nativeLinkViewPtr);
     private native long nativeGetTargetTable(long nativeLinkViewPtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
index 5989fbf60b..2427e0a020 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
@@ -23,25 +23,43 @@
  * This class is used for holding the reference to the native pointers present in NativeObjects.
  * This is required as phantom references cannot access the original objects for this value.
  */
-public abstract class NativeObjectReference extends PhantomReference<NativeObject> {
+public final class NativeObjectReference extends PhantomReference<NativeObject> {
+
+    // Using int here instead of enum to make it faster since the cleanup needs to be called
+    // in a loop to dealloc every native reference.
+    public static final int TYPE_LINK_VIEW = 0;
+    public static final int TYPE_ROW = 1;
 
     // The pointer to the native object to be handled
-    protected final long nativePointer;
+    final long nativePointer;
+    final int type;
+    // Use boxed type to avoid box/un-box when access the freeIndexList
+    final Integer refIndex;
 
-    public NativeObjectReference(NativeObject referent, ReferenceQueue<? super NativeObject> referenceQueue) {
+    NativeObjectReference(int type,
+                          NativeObject referent,
+                          ReferenceQueue<? super NativeObject> referenceQueue,
+                          Integer index) {
         super(referent, referenceQueue);
-        nativePointer = referent.nativePointer;
+        this.type = type;
+        this.nativePointer = referent.nativePointer;
+        refIndex = index;
     }
 
     /**
-     * This method is called when this reference gets cleared.
-     * Subclasses should implement this method to dealloc the native pointer.
+     * To dealloc native resources.
      */
-    protected abstract void cleanup();
-
-    @Override
-    public void clear() {
-        cleanup();
-        super.clear();
+    void cleanup() {
+        switch (type) {
+            case TYPE_LINK_VIEW:
+                LinkView.nativeClose(nativePointer);
+                break;
+            case TYPE_ROW:
+                UncheckedRow.nativeClose(nativePointer);
+                break;
+            default:
+                // Cannot get here.
+                throw new IllegalStateException("Unknown native reference type " + type + ".");
+        }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 636d45e3c0..4681c8b21d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -92,8 +92,8 @@
     public abstract Set<Class<? extends RealmObject>> getModelClasses();
 
     /**
-     * Copy a non-managed {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied any
-     * changes to the original object will not be persisted.
+     * Copies a non-managed {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
+     * any changes to the original object will not be persisted.
      *
      * @param object the object to copy properties from.
      * @param update {@code true} if object has a primary key and should try to update already existing data,
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
index 8868f43d31..2f42292b51 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
@@ -20,6 +20,7 @@
 import java.io.IOError;
 
 import io.realm.exceptions.RealmIOException;
+import io.realm.internal.async.BadVersionException;
 
 public class SharedGroup implements Closeable {
 
@@ -82,7 +83,7 @@ void advanceRead() {
         nativeAdvanceRead(nativePtr);
     }
 
-    void advanceRead(VersionID versionID) {
+    void advanceRead(VersionID versionID) throws BadVersionException {
         nativeAdvanceReadToVersion(nativePtr, versionID.version, versionID.index);
     }
 
@@ -317,6 +318,6 @@ private native long nativeCreate(String databaseFile,
     private native void nativeRollbackAndContinueAsRead(long nativePtr);
     private native long[] nativeGetVersionID (long nativePtr);
     private native void nativeAdvanceRead(long nativePtr);
-    private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index);
+    private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index) throws BadVersionException;
     private native void nativePromoteToWrite(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
index 49e285b0b6..7eac1c3ef1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 
 import io.realm.RealmConfiguration;
+import io.realm.internal.async.BadVersionException;
 import io.realm.internal.log.RealmLog;
 
 /**
@@ -78,7 +79,7 @@ public void advanceRead() {
     /**
      * Advances the Realm file to the given version.
      */
-    public void advanceRead(SharedGroup.VersionID version) {
+    public void advanceRead(SharedGroup.VersionID version) throws BadVersionException {
         transaction.advanceRead(version);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 7987364a2b..f720361122 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -338,6 +338,12 @@ public void remove(long rowIndex) {
         nativeRemove(nativePtr, rowIndex);
     }
 
+    @Override
+    public void removeFirst() {
+        checkImmutable();
+        remove(0);
+    }
+
     @Override
     public void removeLast() {
         checkImmutable();
@@ -579,11 +585,8 @@ public long getPrimaryKey() {
                 return NO_PRIMARY_KEY; // Free table = No primary key
             }
 
-            String tableName = getName();
-            if (tableName.startsWith(TABLE_PREFIX)) {
-                tableName = tableName.substring(TABLE_PREFIX.length());
-            }
-            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, tableName);
+            String className = tableNameToClassName(getName());
+            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
             if (rowIndex != NO_MATCH) {
                 String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
                 cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
@@ -929,7 +932,7 @@ public void removeSearchIndex(long columnIndex) {
     }
 
     /**
-     * Define a primary key for this table. This needs to be called manually before inserting data into the table.
+     * Defines a primary key for this table. This needs to be called manually before inserting data into the table.
      *
      * @param columnName the name of the field that will function primary key. "" or {@code null} will remove any
      *                   previous set magic key.
@@ -1301,7 +1304,7 @@ public TableView getDistinctView(long columnIndex) {
     }
 
     /**
-     * Return the table name as it is in the associated group.
+     * Returns the table name as it is in the associated group.
      *
      * @return Name of the the table or null if it not part of a group.
      */
@@ -1366,7 +1369,7 @@ public static boolean isMetaTable(String tableName) {
     }
 
     /**
-     * Report the current versioning counter for the table. The versioning counter is guaranteed to
+     * Reports the current versioning counter for the table. The versioning counter is guaranteed to
      * change when the contents of the table changes after advance_read() or promote_to_write(), or
      * immediately after calls to methods which change the table.
      *
@@ -1376,6 +1379,13 @@ public long version() {
         return nativeVersion(nativePtr);
     }
 
+    public static String tableNameToClassName(String tableName) {
+        if (!tableName.startsWith(Table.TABLE_PREFIX)) {
+            return tableName;
+        }
+        return tableName.substring(Table.TABLE_PREFIX.length());
+    }
+
     protected native long createNative();
     static native void nativeClose(long nativeTablePtr);
     private native boolean nativeIsValid(long nativeTablePtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 2dc6ce7c08..956afb695e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -342,7 +342,7 @@
     TableQuery where();
 
     /**
-     * Find a row with in the table or view with the given index.
+     * Finds a row with in the table or view with the given index.
      *
      * @param rowIndex the index of the row.
      * @return the index if found, or -1 for not found.
@@ -353,6 +353,8 @@
 
     long count(long columnIndex, String value);
 
+    void removeFirst();
+
     enum PivotType {
         COUNT(0),
         SUM(1),
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 56c6e502a7..b76d41f269 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -21,6 +21,7 @@
 
 import io.realm.Case;
 import io.realm.Sort;
+import io.realm.internal.async.BadVersionException;
 
 public class TableQuery implements Closeable {
     protected boolean DEBUG = false;
@@ -473,28 +474,28 @@ public TableView findAll() {
     // handover find* methods
     // this will use a background SharedGroup to import the query (using the handover object)
     // run the query, and return the table view to the caller SharedGroup using the handover object.
-    public long findAllWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery) {
+    public long findAllWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery) throws BadVersionException {
         validateQuery();
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         return nativeFindAllWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    public long findDistinctWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery, long columnIndex) {
+    public long findDistinctWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery, long columnIndex) throws BadVersionException {
         validateQuery();
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         return nativeGetDistinctViewWithHandover(bgSharedGroupPtr, ptrQuery, columnIndex);
     }
 
-    public long findAllSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long columnIndex, Sort sortOrder) {
+    public long findAllSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long columnIndex, Sort sortOrder) throws BadVersionException {
         validateQuery();
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         return nativeFindAllSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
     }
 
-    public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long[] columnIndices, Sort[] sortOrders) {
+    public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long[] columnIndices, Sort[] sortOrders) throws BadVersionException {
         validateQuery();
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
@@ -502,8 +503,15 @@ public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeRep
         return nativeFindAllMultiSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
     }
 
-    // Suppose to be called from the caller SharedGroup thread
-    public TableView importHandoverTableView(long handoverPtr, long callerSharedGroupPtr) {
+    /**
+     * Imports a TableView from a worker thread to the caller thread.
+     *
+     * @param handoverPtr pointer to the handover object
+     * @param callerSharedGroupPtr pointer to the SharedGroup on the caller thread.
+     * @return the TableView on the caller thread.
+     * @throws BadVersionException if the worker thread and caller thread are not at the same version.
+     */
+    public TableView importHandoverTableView(long handoverPtr, long callerSharedGroupPtr) throws BadVersionException {
         long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, callerSharedGroupPtr);
         try {
             return new TableView(this.context, this.table, nativeTvPtr);
@@ -797,14 +805,14 @@ private void throwImmutable() {
     private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
     private native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
-    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedGroupPtr);
+    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedGroupPtr) throws BadVersionException;
     private native long nativeHandoverQuery(long callerSharedGroupPtr, long nativeQueryPtr);
-    public static native long nativeFindAllSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending);
-    public static native long nativeFindAllWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit);
-    public static native long nativeGetDistinctViewWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long columnIndex);
+    public static native long nativeFindAllSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending) throws BadVersionException;
+    public static native long nativeFindAllWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit) throws BadVersionException;
+    public static native long nativeGetDistinctViewWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long columnIndex) throws BadVersionException;
     public static native long nativeFindWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long fromTableRow);
-    public static native long nativeFindAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending);
+    public static native long nativeFindAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending) throws BadVersionException;
     public static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedGroupPtr);
     public static native void nativeCloseQueryHandover(long nativePtr);
-    public static native long[] nativeBatchUpdateQueries(long bgSharedGroupPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder);
+    public static native long[] nativeBatchUpdateQueries(long bgSharedGroupPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder) throws BadVersionException;
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index 1c0aed2c02..e7d30d4ad1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -453,6 +453,14 @@ public void remove(long rowIndex){
         nativeRemoveRow(nativePtr, rowIndex);
     }
 
+    @Override
+    public void removeFirst() {
+        if (parent.isImmutable()) throwImmutable();
+        if (!isEmpty()) {
+            nativeRemoveRow(nativePtr, 0);
+        }
+    }
+
     @Override
     public void removeLast() {
         if (parent.isImmutable()) throwImmutable();
@@ -589,7 +597,7 @@ public TableView findAllString(long columnIndex, String value){
     //
 
     /**
-     * Calculate the sum of the values in a particular column of this tableview.
+     * Calculates the sum of the values in a particular column of this tableview.
      *
      * Note: the type of the column marked by the columnIndex has to be of type RealmFieldType.INTEGER.
      *
@@ -765,7 +773,7 @@ public long sourceRowIndex(long rowIndex) {
 
 
     private void throwImmutable() {
-        throw new IllegalStateException("Mutable method call during read transaction.");
+        throw new IllegalStateException("Realm data can only be changed inside a write transaction.");
     }
 
     protected long nativePtr;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index 3f591b2130..d12ef09395 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -16,7 +16,6 @@
 
 package io.realm.internal;
 
-import java.lang.ref.ReferenceQueue;
 import java.util.Date;
 
 import io.realm.RealmFieldType;
@@ -32,18 +31,6 @@
  */
 public class UncheckedRow extends NativeObject implements Row {
 
-    protected static class UncheckedRowNativeObjectReference extends NativeObjectReference {
-        public UncheckedRowNativeObjectReference(NativeObject referent,
-                                                 ReferenceQueue<? super NativeObject> referenceQueue) {
-            super(referent, referenceQueue);
-        }
-
-        @Override
-        protected void cleanup() {
-            nativeClose(nativePointer);
-        }
-    }
-
     final Context context; // This is only kept because for now it's needed by the constructor of LinkView
     final Table parent;
 
@@ -52,7 +39,7 @@ protected UncheckedRow(Context context, Table parent, long nativePtr) {
         this.parent = parent;
         this.nativePointer = nativePtr;
 
-        context.cleanNativeReferences();
+        context.executeDelayedDisposal();
     }
 
     /**
@@ -66,8 +53,7 @@ protected UncheckedRow(Context context, Table parent, long nativePtr) {
     public static UncheckedRow getByRowIndex(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
         UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
-        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
-                Context.NATIVE_REFERENCES_VALUE);
+        context.addReference(NativeObjectReference.TYPE_ROW, row);
         return row;
     }
 
@@ -81,8 +67,7 @@ public static UncheckedRow getByRowIndex(Context context, Table table, long inde
      */
     public static UncheckedRow getByRowPointer(Context context, Table table, long nativeRowPointer) {
         UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
-        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
-                Context.NATIVE_REFERENCES_VALUE);
+        context.addReference(NativeObjectReference.TYPE_ROW, row);
         return row;
     }
 
@@ -98,8 +83,7 @@ public static UncheckedRow getByRowIndex(Context context, LinkView linkView, lon
         long nativeRowPointer = linkView.nativeGetRow(linkView.nativePointer, index);
         UncheckedRow row = new UncheckedRow(context, linkView.getTargetTable(),
                 nativeRowPointer);
-        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
-                Context.NATIVE_REFERENCES_VALUE);
+        context.addReference(NativeObjectReference.TYPE_ROW, row);
         return row;
     }
 
@@ -327,7 +311,7 @@ public boolean hasColumn(String fieldName) {
     protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
-    private static native void nativeClose(long nativeRowPtr);
+    static native void nativeClose(long nativeRowPtr);
     protected native boolean nativeIsAttached(long nativeRowPtr);
     protected native boolean nativeHasColumn(long nativeRowPtr, String columnName);
     protected native boolean nativeIsNull(long nativeRowPtr, long columnIndex);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
index 4509b04237..bfdd9bb032 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
@@ -19,7 +19,10 @@
 
 import java.text.ParseException;
 import java.text.ParsePosition;
-import java.util.*;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
 
 /**
  * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so
@@ -53,7 +56,7 @@
     private static final TimeZone TIMEZONE_Z = TIMEZONE_UTC;
 
     /**
-     * Parse a date from ISO-8601 formatted string. It expects a format
+     * Parses a date from ISO-8601 formatted string. It expects a format
      * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
      *
      * @param date ISO string to parse in the appropriate format.
@@ -216,7 +219,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
 
 
     /**
-     * Check if the expected character exist at the given offset in the value.
+     * Checks if the expected character exist at the given offset in the value.
      *
      * @param value the string to check at the specified offset
      * @param offset the offset to look for the expected character
@@ -228,7 +231,7 @@ private static boolean checkOffset(String value, int offset, char expected) {
     }
 
     /**
-     * Parse an integer located between 2 given offsets in a string
+     * Parses an integer located between 2 given offsets in a string
      *
      * @param value the string to parse
      * @param beginIndex the start index for the integer in the string
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java b/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java
index 2a0569c41f..294d309e90 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java
@@ -16,7 +16,6 @@
 
 package io.realm.internal.async;
 
-import io.realm.exceptions.RealmException;
 import io.realm.internal.Keep;
 
 /**
@@ -24,7 +23,7 @@
  * state of the Realm which might be more up-to-date than the provided results or vice versa.
  */
 @Keep
-public class BadVersionException extends RealmException {
+public class BadVersionException extends Exception {
 
     public BadVersionException(String detailMessage) {
         super(detailMessage);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
index 63d8948c52..525456635e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -32,7 +32,7 @@
 import io.realm.internal.log.RealmLog;
 
 /**
- * Manage the update of async queries.
+ * Manages the update of async queries.
  */
 public class QueryUpdateTask implements Runnable {
     // true if updating RealmResults, false if updating RealmObject, can't mix both
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 523410ec24..24246f1526 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -39,21 +39,22 @@
     private ReentrantLock pauseLock = new ReentrantLock();
     private Condition unpaused = pauseLock.newCondition();
 
-    private static volatile RealmThreadPoolExecutor instance;
+    /**
+     * Creates a default RealmThreadPool that is bounded by the number of available cores.
+     */
+    public static RealmThreadPoolExecutor newDefaultExecutor() {
+        return new RealmThreadPoolExecutor(CORE_POOL_SIZE, CORE_POOL_SIZE);
+    }
 
-    public static RealmThreadPoolExecutor getInstance() {
-           if (instance == null) {
-               synchronized (RealmThreadPoolExecutor.class) {
-                   if (instance == null) {
-                       instance = new RealmThreadPoolExecutor();
-                   }
-               }
-           }
-        return instance;
+    /**
+     * Creates a RealmThreadPool with only 1 thread. This is primarily useful for testing.
+     */
+    public static RealmThreadPoolExecutor newSingleThreadExecutor() {
+        return new RealmThreadPoolExecutor(1, 1);
     }
 
-    private RealmThreadPoolExecutor() {
-        super(CORE_POOL_SIZE, CORE_POOL_SIZE,
+    private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
+        super(corePoolSize, maxPoolSize,
                 0L, TimeUnit.MILLISECONDS, //terminated idle thread
                 new ArrayBlockingQueue<Runnable>(QUEUE_SIZE));
     }
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 65933f7487..952f24d468 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -16,6 +16,9 @@
 
 package io.realm.rx;
 
+import java.util.IdentityHashMap;
+import java.util.Map;
+
 import io.realm.DynamicRealm;
 import io.realm.DynamicRealmObject;
 import io.realm.Realm;
@@ -41,6 +44,22 @@
  */
 public class RealmObservableFactory implements RxObservableFactory {
 
+    // Maps for storing strong references to RealmResults while they are subscribed to.
+    // This is needed if users create Observables without manually maintaining a reference to them.
+    // In that case RealmObjects/RealmResults might be GC'ed too early.
+    ThreadLocal<StrongReferenceCounter<RealmResults>> resultsRefs = new ThreadLocal<StrongReferenceCounter<RealmResults>>() {
+        @Override
+        protected StrongReferenceCounter<RealmResults> initialValue() {
+            return new StrongReferenceCounter<RealmResults>();
+        }
+    };
+    ThreadLocal<StrongReferenceCounter<RealmObject>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmObject>>() {
+        @Override
+        protected StrongReferenceCounter<RealmObject> initialValue() {
+            return new StrongReferenceCounter<RealmObject>();
+        }
+    };
+
     @Override
     public Observable<Realm> from(Realm realm) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
@@ -107,12 +126,15 @@ public void call() {
     @Override
     public <E extends RealmObject> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
+
         return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
             @Override
             public void call(final Subscriber<? super RealmResults<E>> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
+                resultsRefs.get().acquireReference(results);
+
                 final RealmChangeListener listener = new RealmChangeListener() {
                     @Override
                     public void onChange() {
@@ -127,6 +149,7 @@ public void onChange() {
                     public void call() {
                         results.removeChangeListener(listener);
                         observableRealm.close();
+                        resultsRefs.get().releaseReference(results);
                     }
                 }));
 
@@ -146,6 +169,8 @@ public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subs
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                resultsRefs.get().acquireReference(results);
+
                 final RealmChangeListener listener = new RealmChangeListener() {
                     @Override
                     public void onChange() {
@@ -160,6 +185,7 @@ public void onChange() {
                     public void call() {
                         results.removeChangeListener(listener);
                         observableRealm.close();
+                        resultsRefs.get().releaseReference(results);
                     }
                 }));
 
@@ -193,6 +219,8 @@ public void call(final Subscriber<? super E> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
+                objectRefs.get().acquireReference(object);
+
                 final RealmChangeListener listener = new RealmChangeListener() {
                     @Override
                     public void onChange() {
@@ -207,6 +235,8 @@ public void onChange() {
                     public void call() {
                         object.removeChangeListener(listener);
                         observableRealm.close();
+                        objectRefs.get().releaseReference(object);
+
                     }
                 }));
 
@@ -226,6 +256,8 @@ public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                objectRefs.get().acquireReference(object);
+
                 final RealmChangeListener listener = new RealmChangeListener() {
                     @Override
                     public void onChange() {
@@ -240,6 +272,7 @@ public void onChange() {
                     public void call() {
                         object.removeChangeListener(listener);
                         observableRealm.close();
+                        objectRefs.get().releaseReference(object);
                     }
                 }));
 
@@ -270,4 +303,30 @@ public int hashCode() {
         return 37;
     }
 
+
+    // Helper class for keeping track of strong references to objects.
+    private static class StrongReferenceCounter<K> {
+
+        private final Map<K, Integer> references = new IdentityHashMap<K, Integer>();
+
+        public void acquireReference(K object) {
+            Integer count = references.get(object);
+            if (count == null) {
+                references.put(object, 1);
+            } else {
+                references.put(object, count + 1);
+            }
+        }
+
+        public void releaseReference(K object) {
+            Integer count = references.get(object);
+            if (count == null) {
+                throw new IllegalStateException("Object does not have any references: " + object);
+            } else if (count > 0) {
+                references.put(object, count - 1);
+            } else {
+                references.remove(object);
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/overview.html b/realm/realm-library/src/overview.html
index 9d0915de4c..d0cd27f435 100644
--- a/realm/realm-library/src/overview.html
+++ b/realm/realm-library/src/overview.html
@@ -1,7 +1,7 @@
 <body>
 <h2>Quick start</h2>
 
-<img src="./realm-overview.png" alt="Overview of Realm" style="display: block; margin: 0 auto;" width="35%"/>
+<img src="./realm-java-overview.png" alt="Overview of Realm" style="display: block; margin: 0 auto;" width="35%"/>
 
 <ul>
     <li><b>{@link io.realm.Realm}</b><br/> The Realm database. The storage and transactional manager of your object
diff --git a/realm/realm-library/src/realm-java-overview.png b/realm/realm-library/src/realm-java-overview.png
new file mode 100644
index 0000000000..5db09e6fad
Binary files /dev/null and b/realm/realm-library/src/realm-java-overview.png differ
diff --git a/realm/realm-library/src/realm-overview.png b/realm/realm-library/src/realm-overview.png
deleted file mode 100644
index b4f49dc902..0000000000
Binary files a/realm/realm-library/src/realm-overview.png and /dev/null differ
