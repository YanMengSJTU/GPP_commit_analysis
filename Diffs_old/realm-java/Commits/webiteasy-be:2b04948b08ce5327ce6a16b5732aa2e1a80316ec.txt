diff --git a/CHANGELOG.md b/CHANGELOG.md
index 966045e390..db453459fc 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -21,6 +21,7 @@
 * `Realm.migrateRealm(RealmConfiguration)` now fails correctly with an `IllegalArgumentException` if a `SyncConfiguration` is provided (#4075).
 * Fixed a potential cause for Realm file corruptions (never reported).
 * Add `@Override` annotation to proxy class accessors and stop using raw type in proxy classes in order to remove warnings from javac (#4329).
+* `findFirstAsync()` now returns an invalid object if there is no object matches the query condition instead of running the query repeatedly until it can find one (#4352).
 
 ### Deprecated
 
diff --git a/realm/build.gradle b/realm/build.gradle
index 120340d00c..53a4573382 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -3,6 +3,7 @@ buildscript {
         mavenLocal()
         jcenter()
         maven { url 'https://jitpack.io' }
+        maven { url "https://plugins.gradle.org/m2/" }
     }
 
     dependencies {
@@ -15,6 +16,7 @@ buildscript {
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
+        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.9'
     }
 }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index b10d5faf2a..328426dc3a 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -566,6 +566,7 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
             String realmResultsType = "RealmResults<" + backlink.getSourceClass() + ">";
 
             // Getter, no setter
+            writer.emitAnnotation("Override");
             writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
                 .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
                 .emitStatement("realm.checkIfValid()")
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 18aa93ce89..f8cb971a58 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -393,6 +393,7 @@ public final AllTypesColumnInfo clone() {
         }
     }
 
+    @Override
     public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
         BaseRealm realm = proxyState.getRealm$realm();
         realm.checkIfValid();
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 6d22e5dda3..7041fd0919 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -9,6 +9,7 @@ apply plugin: 'pmd'
 apply plugin: 'checkstyle'
 apply plugin: 'com.github.kt3k.coveralls'
 apply plugin: 'de.undercouch.download'
+apply plugin: 'net.ltgt.errorprone'
 
 def properties = new Properties()
 properties.load(new FileInputStream("${projectDir}/../../dependencies.list"))
@@ -113,6 +114,12 @@ android {
     }
 }
 
+project.afterEvaluate {
+    tasks.withType(JavaCompile) {
+        options.compilerArgs << '-Werror'
+    }
+}
+
 coveralls.jacocoReportPath = "${buildDir}/reports/coverage/debug/report.xml"
 
 import io.realm.transformer.RealmTransformer
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index e0208b45b5..fac6bd2193 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -128,7 +128,7 @@ public void tearDown() {
         HASH_CODE, EQUALS, TO_STRING,
     }
 
-    @SuppressWarnings({"ResultOfMethodCallIgnored", "EqualsWithItself"})
+    @SuppressWarnings({"ResultOfMethodCallIgnored", "EqualsWithItself", "SelfEquals"})
     private static void callThreadConfinedMethod(DynamicRealmObject obj, ThreadConfinedMethods method) {
         switch (method) {
             case GET_BOOLEAN: obj.getBoolean(AllJavaTypes.FIELD_BOOLEAN); break;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 2278bf240d..1ea36519e9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -146,6 +146,7 @@ public void iOSDataTypesNullValues() throws IOException {
     }
 
     @Test
+    @SuppressWarnings("ConstantOverflow")
     public void iOSDataTypesMinimumValues() throws IOException {
         for (String iosVersion : IOS_VERSIONS) {
             configFactory.copyRealmFromAssets(context,
@@ -167,6 +168,7 @@ public void iOSDataTypesMinimumValues() throws IOException {
     }
 
     @Test
+    @SuppressWarnings("ConstantOverflow")
     public void iOSDataTypesMaximumValues() throws IOException {
         for (String iosVersion : IOS_VERSIONS) {
             configFactory.copyRealmFromAssets(context,
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index 729a6b3d71..302c3952e8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -178,6 +178,7 @@ public void onChange(AllJavaTypes object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                     assertEquals(1, counter.get());
@@ -215,6 +216,7 @@ public void onChange(AllJavaTypes object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                 }
@@ -250,6 +252,7 @@ public void onChange(AllJavaTypes object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                     assertEquals(1, counter.get());
@@ -287,6 +290,7 @@ public void onChange(AllJavaTypes object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                     assertEquals(1, counter.get());
@@ -322,6 +326,7 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                     assertEquals(1, counter.get());
@@ -358,6 +363,7 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                 }
@@ -393,6 +399,7 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                     assertEquals(1, counter.get());
@@ -427,6 +434,7 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
                 }
@@ -531,6 +539,7 @@ public void onChange(AllJavaTypes object) {
         verifyPostConditions(
             looperThreadRealm,
             new PostConditions() {
+                @Override
                 public void run(Realm realm) {
                     RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
                     assertNotNull(results);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index ee1c90b67d..a9608250db 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -551,34 +551,26 @@ public void onChange(AllTypes object) {
         });
     }
 
+    // When there is no object match the query condition, findFirstAsync should return with an invalid row.
     @Test
     @RunTestInLooperThread
-    public void findFirstAsync_initalEmptyRow() throws Throwable {
+    public void findFirstAsync_initialEmptyRow() throws Throwable {
         Realm realm = looperThread.realm;
         final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();
         looperThread.keepStrongReference.add(firstAsync);
         firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
-                assertTrue(firstAsync.load());
                 assertTrue(firstAsync.isLoaded());
-                assertTrue(firstAsync.isValid());
-                assertEquals(0, firstAsync.getColumnLong());
+                assertFalse(firstAsync.isValid());
                 looperThread.testComplete();
             }
         });
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class).setColumnLong(0);
-        realm.commitTransaction();
-
-        assertTrue(firstAsync.load());
-        assertTrue(firstAsync.isLoaded());
     }
 
     @Test
     @RunTestInLooperThread
-    public void findFirstAsync_updatedIfsyncRealmObjectIsUpdated() throws Throwable {
+    public void findFirstAsync_updatedIfSyncRealmObjectIsUpdated() throws Throwable {
         populateTestRealm(looperThread.realm, 1);
         AllTypes firstSync = looperThread.realm.where(AllTypes.class).findFirst();
         assertEquals(0, firstSync.getColumnLong());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index f72137c2c2..7e3c7a9590 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -235,6 +235,7 @@ public void contains_realmObjectFromOtherRealm() {
     }
 
     @Test
+    @SuppressWarnings("CollectionIncompatibleType")
     public void contains_wrongType() {
         //noinspection SuspiciousMethodCalls
         assertFalse(collection.contains(new Dog()));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index cd4e057f84..78fdc0e8df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -591,6 +591,7 @@ public void removeAll_managedMode() {
     }
 
     @Test
+    @SuppressWarnings("CollectionIncompatibleType")
     public void removeAll_managedMode_wrongClass() {
         realm.beginTransaction();
         //noinspection SuspiciousMethodCalls
@@ -598,6 +599,7 @@ public void removeAll_managedMode_wrongClass() {
     }
 
     @Test
+    @SuppressWarnings("CollectionIncompatibleType")
     public void removeAll_unmanaged_wrongClass() {
         RealmList<Dog> list = createUnmanagedDogList();
         //noinspection SuspiciousMethodCalls
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index b10f607f14..27f6cae43e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -2606,6 +2606,7 @@ public void largeRealmMultipleThreads() throws InterruptedException {
             Thread thread = new Thread(
                     new Runnable() {
                         @Override
+                        @SuppressWarnings("ElementsCountedInLoop")
                         public void run() {
                             RealmConfiguration realmConfig = configFactory.createConfiguration();
                             Realm realm = Realm.getInstance(realmConfig);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index b9030ae3e8..e2ebc99b39 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -229,6 +229,7 @@ public void distinct() {
     }
 
     @Test
+    @SuppressWarnings("ReferenceEquality")
     public void distinct_restrictedByPreviousDistinct() {
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index f2a3e78586..e306343516 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -230,6 +230,7 @@ public void realmResults_emittedOnSubscribe() {
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
             @Override
+            @SuppressWarnings("ReferenceEquality")
             public void call(RealmResults<AllTypes> rxResults) {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
@@ -248,6 +249,7 @@ public void realmList_emittedOnSubscribe() {
         realm.commitTransaction();
         subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
             @Override
+            @SuppressWarnings("ReferenceEquality")
             public void call(RealmList<Dog> rxList) {
                 assertTrue(rxList == list);
                 subscribedNotified.set(true);
@@ -265,6 +267,7 @@ public void dynamicRealmResults_emittedOnSubscribe() {
         final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
             @Override
+            @SuppressWarnings("ReferenceEquality")
             public void call(RealmResults<DynamicRealmObject> rxResults) {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
@@ -353,6 +356,7 @@ public void findAllAsync_emittedOnSubscribe() {
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
         subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
             @Override
+            @SuppressWarnings("ReferenceEquality")
             public void call(RealmResults<AllTypes> rxResults) {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 548515114f..064af91f02 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -796,6 +796,7 @@ public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
     }
 
     // Cleans resource, shutdowns the executor service and throws any background exception.
+    @SuppressWarnings("Finally")
     public static void exitOrThrow(final ExecutorService executorService,
                                    final CountDownLatch signalTestFinished,
                                    final CountDownLatch signalClosedRealm,
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
index c06aa13900..a36ec5b8df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
@@ -123,7 +123,7 @@ public void onCalled(TestObserverPair pair, Object observer) {
         assertTrue(foreachCalled.get());
     }
 
-    @SuppressLint("UseValueOf")
+    @SuppressLint({"UseValueOf", "BoxedPrimitiveConstructor"})
     @Test
     public void remove() {
         TestObserverPair pair = new TestObserverPair(ONE, testListener);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 704deb9485..186040bdec 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -92,6 +92,7 @@ public Statement apply(final Statement base, Description description) {
             private Throwable testException;
 
             @Override
+            @SuppressWarnings({"ClassNewInstance", "Finally"})
             public void evaluate() throws Throwable {
                 before();
                 final String threadName = annotation.threadName();
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 2728e043a8..862255f0b5 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -83,7 +83,7 @@ public DynamicRealmObject(RealmModel obj) {
      * @return the field value.
      * @throws ClassCastException if the field doesn't contain a field of the defined return type.
      */
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
     public <E> E get(String fieldName) {
         proxyState.getRealm$realm().checkIfValid();
 
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 4a5e7dafc9..74b72fb127 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -136,7 +136,7 @@ public void setConstructionFinished() {
     }
 
     private void registerToRealmNotifier() {
-        if (realm.sharedRealm == null || realm.sharedRealm.isClosed()) {
+        if (realm.sharedRealm == null || realm.sharedRealm.isClosed() || !row.isAttached()) {
             return;
         }
 
@@ -173,9 +173,11 @@ public void load() {
     @Override
     public void onQueryFinished(Row row) {
         this.row = row;
-        // getTable should return a non-null table since the row should always be valid here.
-        currentTableVersion = row.getTable().getVersion();
         notifyChangeListeners();
-        registerToRealmNotifier();
+        if (row.isAttached()) {
+            // getTable should return a non-null table since the row should always be valid here.
+            currentTableVersion = row.getTable().getVersion();
+            registerToRealmNotifier();
+        }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 29ef417eb7..fd8312fde2 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -341,6 +341,7 @@ public String toString() {
      *
      * @return {@code true} if RxJava dependency exist, {@code false} otherwise.
      */
+    @SuppressWarnings("LiteralClassName")
     static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
             try {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 891f052eff..549908bb4f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -152,7 +152,6 @@ private boolean isAttached() {
      * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
      * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
-     * <p>
      * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
@@ -185,7 +184,6 @@ public void add(int location, E object) {
      * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
      * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
-     * <p>
      * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
@@ -215,7 +213,6 @@ public boolean add(E object) {
      * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
      * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
-     * <p>
      * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed.
      * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
      * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 0ce999707a..7493da59d9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -36,6 +36,7 @@
     static {
         //noinspection TryWithIdenticalCatches
         try {
+            @SuppressWarnings("LiteralClassName")
             Class syncFacadeClass = Class.forName("io.realm.internal.SyncObjectServerFacade");
             //noinspection unchecked
             syncFacade = (ObjectServerFacade) syncFacadeClass.getDeclaredConstructor().newInstance();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index ece3a697ed..90c1dbc74e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -54,17 +54,17 @@ public void onChange(PendingRow pendingRow) {
                 if (pendingCollection.isValid()) {
                     // PendingRow will always get the first Row of the query since we only support findFirst.
                     UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
-                    // If no rows returned by the query, just wait for the query updates until it returns a valid row.
+                    // If no rows returned by the query, notify the frontend with an invalid row.
                     if (uncheckedRow != null) {
                         Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
                         // Ask the front end to reset the row and stop async query.
                         frontEnd.onQueryFinished(row);
-                        clearPendingCollection();
+                    } else {
+                        frontEnd.onQueryFinished(InvalidRow.INSTANCE);
                     }
-                } else {
-                    // The Realm is closed. Do nothing then.
-                    clearPendingCollection();
                 }
+
+                clearPendingCollection();
             }
         };
         pendingCollection.addListener(this, listener);
