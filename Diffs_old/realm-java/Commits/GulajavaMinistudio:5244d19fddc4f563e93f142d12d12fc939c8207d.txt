diff --git a/CHANGELOG.md b/CHANGELOG.md
index abbd226473..a0f18f81d7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,4 @@
-## 5.?.? (2018-MM-DD)
+## X.Y.Z (YYYY-MM-DD)
 
 ### Enhancements
 * None
@@ -17,14 +17,44 @@
 
 ## 5.8.0 (YYYY-MM-DD)
 
+This release also contains all changes in 5.8.0-BETA1 and 5.8.0-BETA2.
+
 ### Enhancements
 * [ObjectServer] Added Subscription class available to Query-based Realms. This exposes a Subscription more directly. This class is in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
 * [ObjectServer] Added `Realm.getSubscriptions()`, `Realm.getSubscriptions(String pattern)` and `Realm.getSubscription` to make it easier to find existing subscriptions. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
 * [ObjectServer] Added `RealmQuery.subscribe()` and `RealmQuery.subscribe(String name)` to subscribe immediately inside a transaction. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
 * [ObjectServer] Added support for subscribing directly inside `SyncConfiguration.initialData()`. This can be coupled with `SyncConfiguration.waitForInitialRemoteData()` in order to block a Realm from opening until the initial subscriptions are ready and have downloaded data. This API are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
+* [ObjectServer] Improved performance when merging changes from the server.
+* [ObjectServer] Added support for timeouts when uploading or downloading data manually using `SyncSession.downloadAllServerChanges(long timeout, TimeUnit unit)` and `SyncSession.uploadAllLocalChanges(long timeout, TimeUnit unit)`. [#6073](https://github.com/realm/realm-java/pull/6073)
+* [ObjectServer] Added support for timing out when downloading initial data for synchronized Realms using `SyncConfiguration.waitForInitialRemoteData(long timeout, TimeUnit unit)`. [#6247](https://github.com/realm/realm-java/issues/6247)
+* Added support for `ImportFlag`s to `Realm.copyToRealm()` and `Realm.copyToRealmOrUpdate()`. This makes it possible to choose a mode so only fields that actually changed are written to disk. This improves notifications and Object Server performance. [#6224](https://github.com/realm/realm-java/pull/6224).
 
 ### Fixed
-* ?? (Issue [#??](https://github.com/realm/realm-java/issues/??), since ??).
+* All known bugs introduced in 5.8.0-BETA1 and 5.8.0-BETA2. See the release notes for these releases.
+
+### Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* Updated to Object Store commit: f0dfe6c03be49194bc40777901059eaf55e7bff6
+* Updated Realm Sync to 3.13.1
+* Updated Realm Core to 5.12.0
+
+
+## 5.8.0-BETA2 (2018-10-19)
+
+### Enhancements
+* None
+
+### Fixed
+* `RealmResults` listeners not triggering the initial callback for Query-based Realm when the device is offline [#6235](https://github.com/realm/realm-java/issues/6235). 
+
+### Known Bugs
+* `Realm.copyToRealm()` and `Realm.copyToRealmOrUpdate` has been rewritten to support import flags. It is currently ~30% slower than in 5.7.0.
+* IllegalStateException thrown when trying to create an object with a primary key that already exists when using `Realm.copyToRealm`, will always report "null" instead of the correct primary key value.
+* When using `ImportFlag.DO_NOT_SET_SAME_VALUES`, lists will still be written and reported as changed, even if they didn't change.
 
 ### Compatibility
 * Realm Object Server: 3.11.0 or later.
@@ -35,13 +65,34 @@
 * None
 
 
+## 5.8.0-BETA1 (2018-10-11)
+
+### Enhancements
+* Added new `ImportFlag` class that is used to specify additional behaviour when importing
+  data into Realm [#6224](https://github.com/realm/realm-java/pull/6224).
+* Added support for `ImportFlag` to `Realm.copyToRealm()` and `Realm.copyToRealmOrUpdate()` [#6224](https://github.com/realm/realm-java/pull/6224).
+
+### Fixed
+* None
+
+### Known Bugs
+* `Realm.copyToRealm()` and `Realm.copyToRealmOrUpdate` has been rewritten to support import flags. It is currently ~30% slower than in 5.7.0.
+* IllegalStateException thrown when trying to create an object with a primary key that already exists when using `Realm.copyToRealm`, will always report "null" instead of the correct primary key value.
+* When using `ImportFlag.DO_NOT_SET_SAME_VALUES`, lists will still be written and reported as changed, even if they didn't change.
+
+### Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+
 ## 5.7.1 (2018-10-22)
 
 ### Enhancements
 * None
 
 ### Fixed
-* `RealmResults` listeners not triggering the initial callback for Query-based Realm when the device is offline. (Issue [#6235](https://github.com/realm/realm-java/issues/6235), since 5.0.0).
+* [ObjectServer] `RealmResults` listeners not triggering the initial callback for Query-based Realm when the device is offline. (Issue [#6235](https://github.com/realm/realm-java/issues/6235), since 5.0.0).
 
 ### Compatibility
 * Realm Object Server: 3.11.0 or later.
diff --git a/Jenkinsfile b/Jenkinsfile
index 444e84db5f..e65e707d01 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -62,7 +62,7 @@ try {
                 stage('JVM tests') {
                   try {
                     withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
-                      sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG} ${abiFilter}"
+                      sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG} ${abiFilter} --stacktrace"
                     }
                   } finally {
                     storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
diff --git a/dependencies.list b/dependencies.list
index d3e23b5bd8..fe31846029 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,11 +1,11 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=3.10.1
-REALM_SYNC_SHA256=df8fb8506a318faf83e027a442e5ad0a38f458ec44567146e64d5a1c60b424ae
+REALM_SYNC_VERSION=3.13.1
+REALM_SYNC_SHA256=4d21d7eb3cff254261da835dd88ab8dd8c2c376d7e81e111206f27225a55cf07
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_VERSION=3.11.1
+REALM_OBJECT_SERVER_VERSION=3.12.4
 
 # Common Android settings across projects
 GRADLE_BUILD_TOOLS=3.1.4
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
index e4511eeb78..417fd9d9f5 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
@@ -27,7 +27,7 @@
     @Override
     public void onCreate() {
         super.onCreate();
-        Realm.init(this);
+        Realm.init(this, "ObjectServerExample/" + BuildConfig.VERSION_NAME);
 
         // Enable full log output when debugging
         if (BuildConfig.DEBUG) {
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index ad9010c919..9b6bb2c11d 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -46,7 +46,7 @@ dependencies {
 
     // Testing
     testImplementation 'junit:junit:4.12'
-    testImplementation "org.robolectric:robolectric:3.3.2"
+    testImplementation "org.robolectric:robolectric:3.8"
     testImplementation "org.mockito:mockito-core:1.10.19"
     testImplementation 'org.robolectric:shadows-support-v4:3.0'
 
@@ -56,9 +56,9 @@ dependencies {
     testImplementation "org.powermock:powermock-classloading-xstream:1.6.5"
 
 
-    androidTestImplementation 'com.android.support.test:runner:1.0.2'
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
     // Set this dependency to use JUnit 4 rules
-    androidTestImplementation 'com.android.support.test:rules:1.0.2'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
     // Set this dependency to build and run Espresso tests
-    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'
 }
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
new file mode 100644
index 0000000000..13586e83bc
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmList;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.benchmarks.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypesPrimaryKey;
+
+
+@RunWith(SpannerRunner.class)
+public class CopyToRealmBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private static final int COLLECTION_SIZE = 100;
+    private List<AllTypes> noPkObjects = new ArrayList<>(COLLECTION_SIZE);
+    private List<AllTypesPrimaryKey> pkObjects = new ArrayList<>(COLLECTION_SIZE);
+    private ArrayList<AllTypesPrimaryKey> complextTestObjects;
+    private ArrayList<AllTypes> simpleTestObjects;
+
+    @BeforeExperiment
+    public void before() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
+        Realm.deleteRealm(config);
+
+        // Create test data
+        complextTestObjects = new ArrayList<>();
+        for (int i = 0; i < COLLECTION_SIZE; i++) {
+            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+            obj.setColumnString("obj" + i);
+            obj.setColumnLong(i);
+            obj.setColumnFloat(1.23F);
+            obj.setColumnDouble(1.234);
+            obj.setColumnBoolean(true);
+            obj.setColumnDate(new Date(1000));
+            obj.setColumnBinary(new byte[] {1,2,3});
+            obj.setColumnRealmObject(obj);
+            obj.setColumnRealmList(new RealmList<>(obj, obj, obj));
+            obj.setColumnBooleanList(new RealmList<>(true, false, true));
+            obj.setColumnStringList(new RealmList<>("foo", "bar", "baz"));
+            obj.setColumnBinaryList(new RealmList<>(new byte[]{0,1,2},new byte[]{2,3,4},new byte[]{4,5,6}));
+            obj.setColumnByteList(new RealmList<>((byte)1,(byte)2,(byte)3));
+            obj.setColumnShortList(new RealmList<>((short)1,(short)2,(short)3));
+            obj.setColumnIntegerList(new RealmList<>(1,2,3));
+            obj.setColumnLongList(new RealmList<>(1L,2L,3L));
+            obj.setColumnFloatList(new RealmList<>(1.1F, 1.2F, 1.3F));
+            obj.setColumnDoubleList(new RealmList<>(1.111, 1.222, 1.333));
+            obj.setColumnDateList(new RealmList<>(new Date(1000), new Date(2000), new Date(3000)));
+            complextTestObjects.add(obj);
+        }
+
+        simpleTestObjects = new ArrayList<>();
+        for (int i = 0; i < COLLECTION_SIZE; i++) {
+            AllTypes obj = new AllTypes();
+            obj.setColumnString("obj" + i);
+            obj.setColumnLong(i);
+            obj.setColumnFloat(1.23F);
+            obj.setColumnDouble(1.234);
+            obj.setColumnBoolean(true);
+            obj.setColumnDate(new Date(1000));
+            obj.setColumnBinary(new byte[] {1,2,3});
+            simpleTestObjects.add(obj);
+        }
+
+        // Setup Realm before test
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Benchmark
+    public void copyToRealm_complexObjects(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.copyToRealmOrUpdate(complextTestObjects);
+        }
+    }
+
+    @Benchmark
+    public void copyToRealm_simpleObjects(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.copyToRealm(simpleTestObjects);
+        }
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
new file mode 100644
index 0000000000..45c3baf373
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.ImportFlag;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmList;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.benchmarks.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypesPrimaryKey;
+
+
+@RunWith(SpannerRunner.class)
+public class CopyToRealmOrUpdateBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private static final int COLLECTION_SIZE = 100;
+    private List<AllTypes> noPkObjects = new ArrayList<>(COLLECTION_SIZE);
+    private List<AllTypesPrimaryKey> pkObjects = new ArrayList<>(COLLECTION_SIZE);
+    private ArrayList<AllTypesPrimaryKey> complextTestObjects;
+    private ArrayList<AllTypes> simpleTestObjects;
+
+    @BeforeExperiment
+    public void before() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
+        Realm.deleteRealm(config);
+
+        // Setup Realm before test
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+
+        // Create test data
+        complextTestObjects = new ArrayList<>();
+        for (int i = 0; i < COLLECTION_SIZE; i++) {
+            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+            obj.setColumnString("obj" + i);
+            obj.setColumnLong(i);
+            obj.setColumnFloat(1.23F);
+            obj.setColumnDouble(1.234);
+            obj.setColumnBoolean(true);
+            obj.setColumnDate(new Date(1000));
+            obj.setColumnBinary(new byte[] {1,2,3});
+            obj.setColumnRealmObject(obj);
+            obj.setColumnRealmList(new RealmList<>(obj, obj, obj));
+            obj.setColumnBooleanList(new RealmList<>(true, false, true));
+            obj.setColumnStringList(new RealmList<>("foo", "bar", "baz"));
+            obj.setColumnBinaryList(new RealmList<>(new byte[]{0,1,2},new byte[]{2,3,4},new byte[]{4,5,6}));
+            obj.setColumnByteList(new RealmList<>((byte)1,(byte)2,(byte)3));
+            obj.setColumnShortList(new RealmList<>((short)1,(short)2,(short)3));
+            obj.setColumnIntegerList(new RealmList<>(1,2,3));
+            obj.setColumnLongList(new RealmList<>(1L,2L,3L));
+            obj.setColumnFloatList(new RealmList<>(1.1F, 1.2F, 1.3F));
+            obj.setColumnDoubleList(new RealmList<>(1.111, 1.222, 1.333));
+            obj.setColumnDateList(new RealmList<>(new Date(1000), new Date(2000), new Date(3000)));
+            complextTestObjects.add(obj);
+        }
+
+        simpleTestObjects = new ArrayList<>();
+        for (int i = 0; i < COLLECTION_SIZE; i++) {
+            AllTypes obj = new AllTypes();
+            obj.setColumnString("obj" + i);
+            obj.setColumnLong(i);
+            obj.setColumnFloat(1.23F);
+            obj.setColumnDouble(1.234);
+            obj.setColumnBoolean(true);
+            obj.setColumnDate(new Date(1000));
+            obj.setColumnBinary(new byte[] {1,2,3});
+            simpleTestObjects.add(obj);
+        }
+
+        realm.copyToRealmOrUpdate(complextTestObjects);
+        realm.copyToRealmOrUpdate(simpleTestObjects);
+        realm.commitTransaction();
+        realm.beginTransaction();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Benchmark
+    public void copyToRealmOrDiffedUpdate_complexObjects(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.copyToRealmOrUpdate(complextTestObjects, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET);
+        }
+    }
+
+    @Benchmark
+    public void copyToRealmOrFullUpdate_complexObjects(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.copyToRealmOrUpdate(complextTestObjects);
+        }
+    }
+
+    @Benchmark
+    public void copyToRealmOrDiffedUpdate_simpleObjects(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.copyToRealm(simpleTestObjects, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET);
+        }
+    }
+
+    @Benchmark
+    public void copyToRealmOrFullUpdate_simpleObjects(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.copyToRealm(simpleTestObjects);
+        }
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
index f1e3571c5d..ef9b9160e0 100644
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
@@ -87,7 +87,7 @@ public void findAll(long reps) {
     @Benchmark
     public void findAllSortedOneField(long reps) {
         for (long i = 0; i < reps; i++) {
-            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_STRING, Sort.ASCENDING);
+            RealmResults<AllTypes> results = realm.where(AllTypes.class).sort(AllTypes.FIELD_STRING, Sort.ASCENDING).findAll();
         }
     }
 }
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java
index 71dc3d88ae..7f46e8f2e5 100644
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java
@@ -35,6 +35,16 @@
     private AllTypesPrimaryKey columnRealmObject;
     private RealmList<AllTypesPrimaryKey> columnRealmList;
     private Boolean columnBoxedBoolean;
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Integer> columnIntegerList;
+    private RealmList<Short> columnShortList;
+    private RealmList<Byte> columnByteList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
 
     public String getColumnString() {
         return columnString;
@@ -115,4 +125,84 @@ public Boolean getColumnBoxedBoolean() {
     public void setColumnBoxedBoolean(Boolean columnBoxedBoolean) {
         this.columnBoxedBoolean = columnBoxedBoolean;
     }
+
+    public RealmList<String> getColumnStringList() {
+        return columnStringList;
+    }
+
+    public void setColumnStringList(RealmList<String> columnStringList) {
+        this.columnStringList = columnStringList;
+    }
+
+    public RealmList<byte[]> getColumnBinaryList() {
+        return columnBinaryList;
+    }
+
+    public void setColumnBinaryList(RealmList<byte[]> columnBinaryList) {
+        this.columnBinaryList = columnBinaryList;
+    }
+
+    public RealmList<Boolean> getColumnBooleanList() {
+        return columnBooleanList;
+    }
+
+    public void setColumnBooleanList(RealmList<Boolean> columnBooleanList) {
+        this.columnBooleanList = columnBooleanList;
+    }
+
+    public RealmList<Long> getColumnLongList() {
+        return columnLongList;
+    }
+
+    public void setColumnLongList(RealmList<Long> columnLongList) {
+        this.columnLongList = columnLongList;
+    }
+
+    public RealmList<Integer> getColumnIntegerList() {
+        return columnIntegerList;
+    }
+
+    public void setColumnIntegerList(RealmList<Integer> columnIntegerList) {
+        this.columnIntegerList = columnIntegerList;
+    }
+
+    public RealmList<Short> getColumnShortList() {
+        return columnShortList;
+    }
+
+    public void setColumnShortList(RealmList<Short> columnShortList) {
+        this.columnShortList = columnShortList;
+    }
+
+    public RealmList<Byte> getColumnByteList() {
+        return columnByteList;
+    }
+
+    public void setColumnByteList(RealmList<Byte> columnByteList) {
+        this.columnByteList = columnByteList;
+    }
+
+    public RealmList<Double> getColumnDoubleList() {
+        return columnDoubleList;
+    }
+
+    public void setColumnDoubleList(RealmList<Double> columnDoubleList) {
+        this.columnDoubleList = columnDoubleList;
+    }
+
+    public RealmList<Float> getColumnFloatList() {
+        return columnFloatList;
+    }
+
+    public void setColumnFloatList(RealmList<Float> columnFloatList) {
+        this.columnFloatList = columnFloatList;
+    }
+
+    public RealmList<Date> getColumnDateList() {
+        return columnDateList;
+    }
+
+    public void setColumnDateList(RealmList<Date> columnDateList) {
+        this.columnDateList = columnDateList;
+    }
 }
diff --git a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt
index a33f38acb2..0892d82cba 100644
--- a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt
+++ b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotatedCodeStripVisitor.kt
@@ -68,10 +68,10 @@ class AnnotatedCodeStripVisitor(private val annotationDescriptor: String,
     }
 
     override fun visitMethod(access: Int, name: ByteCodeMethodName?, descriptor: String?, signature: String?, exceptions: Array<out String>?): MethodVisitor? {
-        return if (!markedMethodsInClass.contains(name)) {
+        return if (!markedMethodsInClass.contains(name + descriptor)) {
             super.visitMethod(access, name, descriptor, signature, exceptions)
         } else {
-            logger.debug("Removing method: $name")
+            logger.debug("Removing method: $name $descriptor")
             null
         }
     }
diff --git a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt
index b572090148..a34825b972 100644
--- a/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt
+++ b/library-build-transformer/src/main/kotlin/io/realm/buildtransformer/asm/visitors/AnnotationVisitor.kt
@@ -53,10 +53,12 @@ class AnnotationVisitor(private val annotationDescriptor: String) : ClassVisitor
 
     override fun visitMethod(access: Int, name: String?, descriptor: String?, signature: String?, exceptions: Array<out String>?): MethodVisitor {
         val parentVisitor = super.visitMethod(access, name, descriptor, signature, exceptions)
+        val methodDescriptor: String = descriptor!!
+        val methodName: String = name!!;
         return object: MethodVisitor(api, parentVisitor) {
             override fun visitAnnotation(descriptor: String?, visible: Boolean): AnnotationVisitor? {
                 if (descriptor == annotationDescriptor) {
-                    annotatedMethodsInClass.add(name!!)
+                    annotatedMethodsInClass.add(methodName + methodDescriptor) // Use name + return type + parameters to uniquely identify method
                 }
                 return super.visitAnnotation(descriptor, visible)
             }
diff --git a/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestMethods.java b/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestMethods.java
index 45c3377faf..308aed3335 100644
--- a/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestMethods.java
+++ b/library-build-transformer/src/test/java/io/realm/buildtransformer/testclasses/SimpleTestMethods.java
@@ -29,6 +29,10 @@ public String foo1(String input) {
         return "foo1";
     }
 
+    public String foo1(String input, String donRemoveThis) {
+        return "foo1"; // Only methods matching the exact signature should be removed
+    }
+
     public String bar() {
         return "bar";
     }
diff --git a/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt b/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt
index e0f8d25278..fffc249779 100644
--- a/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt
+++ b/library-build-transformer/src/test/kotlin/io/realm/buildtransformer/VisitorTests.kt
@@ -24,6 +24,7 @@ import org.junit.Assert.*
 import org.junit.Before
 import org.junit.Test
 import java.io.File
+import java.lang.reflect.Method
 import kotlin.reflect.KClass
 
 class VisitorTests {
@@ -49,8 +50,10 @@ class VisitorTests {
     fun removeMethods() {
         val c: Class<SimpleTestMethods> = modifyClass(SimpleTestMethods::class)
         assetDefaultConstructorExists(c)
-        assertMethodExists("bar", c)
-        assertMethodRemoved("foo", c)
+        assertMethodExists(c, "bar", emptyArray());
+        assertMethodExists(c, "foo1", arrayOf(String::class.java, String::class.java))
+        assertMethodRemoved(c, "foo", emptyArray());
+        assertMethodRemoved(c, "foo1", arrayOf(String::class.java))
     }
 
     @Test
@@ -108,16 +111,17 @@ class VisitorTests {
         clazz.getField(fieldName)
     }
 
-    private fun assertMethodRemoved(methodName: String, clazz: Class<*>) {
+    private fun assertMethodRemoved(clazz: Class<*>, methodName: String, parameterTypes: Array<Class<*>>) {
         try {
-            clazz.getMethod(methodName)
+            clazz.getMethod(methodName, *parameterTypes);
             fail("Method $methodName has not been removed");
         } catch (e: NoSuchMethodException) {
         }
     }
 
-    private fun assertMethodExists(methodName: String, clazz: Class<*>) {
-        clazz.getMethod(methodName) // Will throw exception if it doesn't
+    private fun assertMethodExists(clazz: Class<*>, methodName: String, parameterTypes: Array<Class<*>>) {
+        val method: Method = clazz.getMethod(methodName, *parameterTypes) // Will throw exception if it doesn't exists
+        assertNotNull(method)
     }
 
     private fun <T: Any> modifyClass(clazz: KClass<T>): Class<T> {
diff --git a/realm/kotlin-extensions/build.gradle b/realm/kotlin-extensions/build.gradle
index ec0e31fdf4..80430f385b 100644
--- a/realm/kotlin-extensions/build.gradle
+++ b/realm/kotlin-extensions/build.gradle
@@ -61,10 +61,6 @@ android {
                 '../realm-library/src/syncTestUtils/java',
         ]
     }
-    compileOptions {
-        targetCompatibility 1.8
-        sourceCompatibility 1.8
-    }
 }
 
 dependencies {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 03f3fa523f..4eba7a258d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -63,6 +63,8 @@
     private final String javaClassName; // Model class simple name as defined in Java.
     private final List<RealmFieldElement> fields = new ArrayList<>(); // List of all fields in the class except those @Ignored.
     private final List<RealmFieldElement> indexedFields = new ArrayList<>(); // list of all fields marked @Index.
+    private final List<RealmFieldElement> objectReferenceFields = new ArrayList<>(); // List of all fields that reference a Realm Object either directly or in a List
+    private final List<RealmFieldElement> basicTypeFields = new ArrayList<>(); // List of all fields that reference basic types, i.e. no references to other Realm Objects
     private final Set<Backlink> backlinks = new LinkedHashSet<>();
     private final Set<RealmFieldElement> nullableFields = new LinkedHashSet<>(); // Set of fields which can be nullable
     private final Set<RealmFieldElement> nullableValueListFields = new LinkedHashSet<>(); // Set of fields whose elements can be nullable
@@ -164,10 +166,27 @@ public String getFullyQualifiedClassName() {
         return packageName + "." + javaClassName;
     }
 
+    /**
+     * Returns all persistable fields in this model class
+     */
     public List<RealmFieldElement> getFields() {
         return Collections.unmodifiableList(fields);
     }
 
+    /**
+     * Returns all persistable fields that reference other Realm objects.
+     */
+    public List<RealmFieldElement> getObjectReferenceFields() {
+        return Collections.unmodifiableList(objectReferenceFields);
+    }
+
+    /**
+     * Returns all persistable fields that contain a basic type, this include lists of primitives.
+     */
+    public List<RealmFieldElement> getBasicTypeFields() {
+        return Collections.unmodifiableList(basicTypeFields);
+    }
+
     public Set<Backlink> getBacklinkFields() {
         return Collections.unmodifiableSet(backlinks);
     }
@@ -576,6 +595,11 @@ private boolean categorizeField(Element element) {
 
         // Standard field that appears to be valid (more fine grained checks might fail later).
         fields.add(field);
+        if (Utils.isRealmModel(field) || Utils.isRealmModelList(field)) {
+            objectReferenceFields.add(field);
+        } else {
+            basicTypeFields.add(field);
+        }
 
         return true;
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.java
new file mode 100644
index 0000000000..f4190e2c63
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Helper class for creating the correct method calls to the OsObjectBuilder class.
+ */
+public class OsObjectBuilderTypeHelper {
+
+    private static final Map<String, String> QUALIFIED_TYPE_TO_BUILDER;
+    private static final Map<String, String> QUALIFIED_LIST_TYPE_TO_BUILDER;
+
+    static {
+        // Map of qualified types to their OsObjectBuilder Type
+        Map<String, String> fieldTypes = new HashMap<>();
+        fieldTypes.put("byte", "Integer");
+        fieldTypes.put("short", "Integer");
+        fieldTypes.put("int", "Integer");
+        fieldTypes.put("long", "Integer");
+        fieldTypes.put("float", "Float");
+        fieldTypes.put("double", "Double");
+        fieldTypes.put("boolean", "Boolean");
+        fieldTypes.put("byte[]", "ByteArray");
+        fieldTypes.put("java.lang.Byte", "Integer");
+        fieldTypes.put("java.lang.Short", "Integer");
+        fieldTypes.put("java.lang.Integer", "Integer");
+        fieldTypes.put("java.lang.Long", "Integer");
+        fieldTypes.put("java.lang.Float", "Float");
+        fieldTypes.put("java.lang.Double", "Double");
+        fieldTypes.put("java.lang.Boolean", "Boolean");
+        fieldTypes.put("java.lang.String", "String");
+        fieldTypes.put("java.util.Date", "Date");
+        fieldTypes.put("io.realm.MutableRealmInteger", "MutableRealmInteger");
+        QUALIFIED_TYPE_TO_BUILDER = Collections.unmodifiableMap(fieldTypes);
+
+        // Map of qualified types to their OsObjectBuilder Type
+        Map<String, String> listTypes = new HashMap<>();
+        listTypes.put("byte[]", "ByteArrayList");
+        listTypes.put("java.lang.Byte", "ByteList");
+        listTypes.put("java.lang.Short", "ShortList");
+        listTypes.put("java.lang.Integer", "IntegerList");
+        listTypes.put("java.lang.Long", "LongList");
+        listTypes.put("java.lang.Float", "FloatList");
+        listTypes.put("java.lang.Double", "DoubleList");
+        listTypes.put("java.lang.Boolean", "BooleanList");
+        listTypes.put("java.lang.String", "StringList");
+        listTypes.put("java.util.Date", "DateList");
+        listTypes.put("io.realm.MutableRealmInteger", "MutableRealmIntegerList");
+        QUALIFIED_LIST_TYPE_TO_BUILDER = Collections.unmodifiableMap(listTypes);
+    }
+
+    /**
+     * Returns the method name used by the OsObjectBuilder for the given type, e.g. `addInteger`
+     * or `addIntegerList`.
+     */
+    public static String getOsObjectBuilderName(VariableElement field) {
+        if (Utils.isRealmModel(field)) {
+            return "addObject";
+        } else if (Utils.isRealmModelList(field)) {
+            return "addObjectList";
+        } else if (Utils.isRealmValueList(field)) {
+            return "add" + getListTypeName(Utils.getRealmListType(field));
+        } else if (Utils.isRealmResults(field)) {
+            throw new IllegalStateException("RealmResults are not supported by OsObjectBuilder: " + field);
+        } else {
+            return "add" + getBasicTypeName(Utils.getFieldTypeQualifiedName(field));
+        }
+    }
+
+    private static String getBasicTypeName(String qualifiedType) {
+        String type = QUALIFIED_TYPE_TO_BUILDER.get(qualifiedType);
+        if (type != null) {
+            return type;
+        }
+        throw new IllegalArgumentException("Unsupported type: " + qualifiedType);
+    }
+
+    private static String getListTypeName(String qualifiedType) {
+        String type = QUALIFIED_LIST_TYPE_TO_BUILDER.get(qualifiedType);
+        if (type != null) {
+            return type;
+        }
+        throw new IllegalArgumentException("Unsupported list type: " + qualifiedType);
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index ef1e771df3..9e3aca471e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -48,6 +48,7 @@
             "android.os.Build",
             "android.util.JsonReader",
             "android.util.JsonToken",
+            "io.realm.ImportFlag",
             "io.realm.exceptions.RealmMigrationNeededException",
             "io.realm.internal.ColumnInfo",
             "io.realm.internal.OsList",
@@ -55,6 +56,7 @@
             "io.realm.internal.OsSchemaInfo",
             "io.realm.internal.OsObjectSchemaInfo",
             "io.realm.internal.Property",
+            "io.realm.internal.objectstore.OsObjectBuilder",
             "io.realm.ProxyUtils",
             "io.realm.internal.RealmObjectProxy",
             "io.realm.internal.Row",
@@ -69,6 +71,7 @@
             "java.util.Date",
             "java.util.Map",
             "java.util.HashMap",
+            "java.util.Set",
             "org.json.JSONObject",
             "org.json.JSONException",
             "org.json.JSONArray");
@@ -150,6 +153,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitGetSimpleClassNameMethod(writer);
         emitCreateOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
+        emitNewProxyInstance(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
         emitInsertMethod(writer);
@@ -176,6 +180,7 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
                 "ColumnInfo");                               // base class
 
         // fields
+        writer.emitField("long", "maxColumnIndexValue"); // Must not end with Index as it otherwise could conflict regular fields.
         for (VariableElement variableElement : metadata.getFields()) {
             writer.emitField("long", columnIndexVarName(variableElement));
         }
@@ -201,8 +206,10 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
                     classCollection.getClassFromQualifiedName(backlink.getSourceClass()).getInternalClassName(),
                     backlink.getSourceField());
         }
-        writer.endConstructor()
-                .emitEmptyLine();
+        writer
+            .emitStatement("this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex()")
+            .endConstructor()
+            .emitEmptyLine();
 
         // constructor #2
         writer.beginConstructor(
@@ -236,6 +243,7 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
         for (VariableElement variableElement : metadata.getFields()) {
             writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
         }
+        writer.emitStatement("dst.maxColumnIndexValue = src.maxColumnIndexValue");
         writer.endMethod();
 
         writer.endType();
@@ -854,13 +862,37 @@ private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException
     }
     //@formatter:on
 
+    //@formatter:off
+    private void emitNewProxyInstance(JavaWriter writer) throws IOException {
+        writer
+            .beginMethod(qualifiedGeneratedClassName,
+            "newProxyInstance",
+            EnumSet.of(Modifier.PRIVATE, Modifier.STATIC),
+            "BaseRealm", "realm",
+            "Row", "row")
+                .emitSingleLineComment("Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields")
+                .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                .emitStatement("objectContext.set(realm, row, realm.getSchema().getColumnInfo(%s.class), false, Collections.<String>emptyList())", qualifiedJavaClassName)
+                .emitStatement("%1$s obj = new %1$s()", qualifiedGeneratedClassName)
+                .emitStatement("objectContext.clear()")
+                .emitStatement("return obj")
+            .endMethod()
+            .emitEmptyLine();
+    }
+    //@formatter:on
+
     //@formatter:off
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 qualifiedJavaClassName, // Return type
                 "copyOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedJavaClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
+                "Realm", "realm", // Argument type & argument name
+                columnInfoClassName(), "columnInfo",
+                qualifiedJavaClassName, "object",
+                "boolean", "update",
+                "Map<RealmModel,RealmObjectProxy>", "cache",
+                "Set<ImportFlag>", "flags"
         );
 
         writer
@@ -886,15 +918,13 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .emitEmptyLine();
 
         if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("return copy(realm, object, update, cache)");
+            writer.emitStatement("return copy(realm, columnInfo, object, update, cache, flags)");
         } else {
             writer
                     .emitStatement("%s realmObject = null", qualifiedJavaClassName)
                     .emitStatement("boolean canUpdate = update")
                     .beginControlFlow("if (canUpdate)")
                     .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
-                    .emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                        columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
                     .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
 
             String primaryKeyGetter = metadata.getPrimaryKeyGetter();
@@ -930,9 +960,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                         .emitStatement("canUpdate = false")
                     .nextControlFlow("else")
                         .beginControlFlow("try")
-                            .emitStatement(
-                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
-                                    qualifiedJavaClassName)
+                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex), columnInfo, false, Collections.<String> emptyList())")
                             .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
                             .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                         .nextControlFlow("finally")
@@ -944,7 +972,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
 
             writer
                     .emitEmptyLine()
-                       .emitStatement("return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache)");
+                       .emitStatement("return (canUpdate) ? update(realm, columnInfo, realmObject, object, cache, flags) : copy(realm, columnInfo, object, update, cache, flags)");
         }
 
         writer.endMethod()
@@ -1541,97 +1569,111 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
     }
 
     private void emitCopyMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                qualifiedJavaClassName, // Return type
-                "copy", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedJavaClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
+        writer
+            .beginMethod(
+            qualifiedJavaClassName, // Return type
+            "copy", // Method name
+            EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+            "Realm", "realm",
+                    columnInfoClassName(), "columnInfo",
+                    qualifiedJavaClassName, "newObject",
+                    "boolean", "update",
+                    "Map<RealmModel,RealmObjectProxy>", "cache",
+                    "Set<ImportFlag>", "flags"
+
+            ); // Argument type & argument name
 
-        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
-        writer.beginControlFlow("if (cachedRealmObject != null)")
+        writer
+            .emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)")
+            .beginControlFlow("if (cachedRealmObject != null)")
                 .emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
-                .endControlFlow();
+            .endControlFlow()
+            .emitEmptyLine();
 
+        writer
+            .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
+            .emitEmptyLine()
+            .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+            .emitStatement("OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags)");
 
-        writer.emitEmptyLine()
-                .emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
-        if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
-                    qualifiedJavaClassName, qualifiedJavaClassName, interfaceName, metadata.getPrimaryKeyGetter());
-        } else {
-            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
-                    qualifiedJavaClassName, qualifiedJavaClassName);
+        // Copy basic types
+        writer
+            .emitEmptyLine()
+            .emitSingleLineComment("Add all non-\"object reference\" fields");
+        for (RealmFieldElement field : metadata.getBasicTypeFields()) {
+            String fieldIndex = fieldIndexVariableReference(field);
+            String fieldName = field.getSimpleName().toString();
+            String getter = metadata.getInternalGetter(fieldName);
+            writer.emitStatement("builder.%s(%s, realmObjectSource.%s())", OsObjectBuilderTypeHelper.getOsObjectBuilderName(field), fieldIndex, getter);
         }
-        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
-
-        writer.emitEmptyLine()
-                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
-                .emitStatement("%1$s realmObjectCopy = (%1$s) realmObject", interfaceName);
 
+        // Create the underlying object
+        writer
+            .emitEmptyLine()
+            .emitSingleLineComment("Create the underlying object and cache it before setting any object/objectlist references")
+            .emitSingleLineComment("This will allow us to break any circular dependencies by using the object cache.")
+            .emitStatement("Row row = builder.createNewObject()")
+            .emitStatement("%s realmObjectCopy = newProxyInstance(realm, row)", qualifiedGeneratedClassName)
+            .emitStatement("cache.put(newObject, realmObjectCopy)");
+
+        // Copy all object references or lists-of-objects
         writer.emitEmptyLine();
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
+        if (!metadata.getObjectReferenceFields().isEmpty()) {
+            writer.emitSingleLineComment("Finally add all fields that reference other Realm Objects, either directly or through a list");
+        }
+        for (RealmFieldElement field : metadata.getObjectReferenceFields()) {
             String fieldType = field.asType().toString();
-            String setter = metadata.getInternalSetter(fieldName);
+            String fieldName = field.getSimpleName().toString();
             String getter = metadata.getInternalGetter(fieldName);
+            String setter = metadata.getInternalSetter(fieldName);
 
-            if (metadata.isPrimaryKey(field)) {
-                // PK has been set when creating object.
-                continue;
-            }
-
-            //@formatter:off
             if (Utils.isRealmModel(field)) {
-                writer.emitEmptyLine()
-                        .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
-                        .beginControlFlow("if (%sObj == null)", fieldName)
-                            .emitStatement("realmObjectCopy.%s(null)", setter)
+                writer
+                    .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
+                    .beginControlFlow("if (%sObj == null)", fieldName)
+                        .emitStatement("realmObjectCopy.%s(null)", setter)
+                    .nextControlFlow("else")
+                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
+                        .beginControlFlow("if (cache%s != null)", fieldName)
+                            .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
-                            .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
-                            .nextControlFlow("else")
-                                .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                    setter, Utils.getProxyClassSimpleName(field), fieldName)
-                            .endControlFlow()
-                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .endControlFlow();
+                            .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, (%s) realm.getSchema().getColumnInfo(%s.class), %sObj, update, cache, flags))",
+                                setter, Utils.getProxyClassSimpleName(field),  columnInfoClassName(field), Utils.getFieldTypeQualifiedName(field), fieldName)
+                        .endControlFlow()
+                    // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                    .endControlFlow()
+                    .emitEmptyLine();
+
             } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer.emitEmptyLine()
-                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
-                                genericType, fieldName, getter)
-                             // Clear is needed. See bug https://github.com/realm/realm-java/issues/4957
-                            .emitStatement("%sRealmList.clear()", fieldName)
-                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
-                                .beginControlFlow("if (cache%s != null)", fieldName)
-                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
-                                .nextControlFlow("else")
-                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, update, cache))",
-                                        fieldName, Utils.getProxyClassSimpleName(field))
-                                .endControlFlow()
+                writer
+                    .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
+                    .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
+                            genericType, fieldName, getter)
+                         // Clear is needed. See bug https://github.com/realm/realm-java/issues/4957
+                        .emitStatement("%sRealmList.clear()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
+                            .beginControlFlow("if (cache%s != null)", fieldName)
+                                .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
+                            .nextControlFlow("else")
+                                .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, (%3$s) realm.getSchema().getColumnInfo(%4$s.class), %1$sItem, update, cache, flags))",
+                                    fieldName, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getGenericTypeQualifiedName(field))
                             .endControlFlow()
                         .endControlFlow()
-                        .emitEmptyLine();
-
-            } else if (Utils.isRealmValueList(field)) {
-                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
-            } else if (Utils.isMutableRealmInteger(field)) {
-                writer.emitEmptyLine()
-                        .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
+                    .endControlFlow()
+                    .emitEmptyLine();
             } else {
-                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
+                throw new IllegalStateException("Unsupported field: " + field);
             }
-            //@formatter:on
         }
 
-        writer.emitStatement("return realmObject");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer
+            .emitStatement("return realmObjectCopy")
+            .endMethod()
+            .emitEmptyLine();
     }
 
     //@formatter:off
@@ -1722,80 +1764,78 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                 qualifiedJavaClassName, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedJavaClassName, "realmObject", qualifiedJavaClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", // Argument type & argument name
+                columnInfoClassName(), "columnInfo",
+                qualifiedJavaClassName, "realmObject",
+                qualifiedJavaClassName, "newObject",
+                "Map<RealmModel, RealmObjectProxy>", "cache",
+                "Set<ImportFlag>", "flags"
+        );
 
         writer
                 .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
-                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName);
+                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
+                .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                .emitStatement("OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags)");
 
-        for (VariableElement field : metadata.getFields()) {
+
+        for (RealmFieldElement field : metadata.getFields()) {
+            String fieldType = field.asType().toString();
             String fieldName = field.getSimpleName().toString();
-            String setter = metadata.getInternalSetter(fieldName);
             String getter = metadata.getInternalGetter(fieldName);
-            //@formatter:off
+            String fieldIndex = fieldIndexVariableReference(field);
+
             if (Utils.isRealmModel(field)) {
                 writer
-                        .emitStatement("%s %sObj = realmObjectSource.%s()",
-                                Utils.getFieldTypeQualifiedName(field), fieldName, getter)
-                        .beginControlFlow("if (%sObj == null)", fieldName)
-                        .emitStatement("realmObjectTarget.%s(null)", setter)
-                        .nextControlFlow("else")
-                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sObj)",
-                                Utils.getFieldTypeQualifiedName(field), fieldName)
+                    .emitEmptyLine()
+                    .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
+                    .beginControlFlow("if (%sObj == null)", fieldName)
+                        .emitStatement("builder.addNull(%s)", fieldIndexVariableReference(field))
+                    .nextControlFlow("else")
+                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                        .emitStatement("realmObjectTarget.%s(cache%s)", setter, fieldName)
+                            .emitStatement("builder.addObject(%s, cache%s)", fieldIndex, fieldName)
                         .nextControlFlow("else")
-                        .emitStatement("realmObjectTarget.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
-                                setter, Utils.getProxyClassSimpleName(field), fieldName)
+                            .emitStatement("builder.addObject(%s, %s.copyOrUpdate(realm, (%s) realm.getSchema().getColumnInfo(%s.class), %sObj, true, cache, flags))",
+                                    fieldIndex, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getFieldTypeQualifiedName(field), fieldName)
                         .endControlFlow()
-                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .endControlFlow();
+                    // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                    .endControlFlow();
             } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
+                    .emitEmptyLine()
                     .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
-                    .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()", genericType, fieldName, getter)
-                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sRealmList.size())", fieldName)
-                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
-                        .emitStatement("int objects = %sList.size()", fieldName)
-                        .beginControlFlow("for (int i = 0; i < objects; i++)")
+                    .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("RealmList<%s> %sManagedCopy = new RealmList<%s>()", genericType, fieldName, genericType)
+                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                             .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                             .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                             .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("%1$sRealmList.set(i, cache%1$s)", fieldName)
+                                .emitStatement("%1$sManagedCopy.add(cache%1$s)", fieldName)
                             .nextControlFlow("else")
-                                .emitStatement("%1$sRealmList.set(i, %2$s.copyOrUpdate(realm, %1$sItem, true, cache))", fieldName, Utils.getProxyClassSimpleName(field))
+                                .emitStatement("%1$sManagedCopy.add(%2$s.copyOrUpdate(realm, (%3$s) realm.getSchema().getColumnInfo(%4$s.class), %1$sItem, true, cache, flags))",
+                                        fieldName, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getGenericTypeQualifiedName(field))
                             .endControlFlow()
                         .endControlFlow()
+                        .emitStatement("builder.addObjectList(%s, %sManagedCopy)", fieldIndex, fieldName)
                     .nextControlFlow("else")
-                        .emitStatement("%sRealmList.clear()", fieldName)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
-                                .beginControlFlow("if (cache%s != null)", fieldName)
-                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
-                                .nextControlFlow("else")
-                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))", fieldName, Utils.getProxyClassSimpleName(field))
-                                .endControlFlow()
-                            .endControlFlow()
-                        .endControlFlow()
+                        .emitStatement("builder.addObjectList(%s, new RealmList<%s>())", fieldIndex, genericType)
                     .endControlFlow();
-            } else if (Utils.isRealmValueList(field)) {
-                writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
-            } else if (Utils.isMutableRealmInteger(field)) {
-                writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
             } else {
-                if (field != metadata.getPrimaryKey()) {
-                    writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
-                }
+                writer
+                    .emitStatement("builder.%s(%s, realmObjectSource.%s())", OsObjectBuilderTypeHelper.getOsObjectBuilderName(field), fieldIndex, getter);
             }
-            //@formatter:on
         }
 
-        writer.emitStatement("return realmObject");
-        writer.endMethod();
-        writer.emitEmptyLine();
+        writer
+            .emitEmptyLine()
+            .emitStatement("builder.updateExistingObject()")
+            .emitStatement("return realmObject");
+
+        writer
+            .endMethod()
+            .emitEmptyLine();
     }
 
     private void emitToStringMethod(JavaWriter writer) throws IOException {
@@ -2141,6 +2181,15 @@ private String columnInfoClassName() {
         return simpleJavaClassName + "ColumnInfo";
     }
 
+    /**
+     * Returns the name of the ColumnInfo class for the model class referenced in the field.
+     * I.e. for `com.test.Person`, it returns `Person.PersonColumnInfo`
+     */
+    private String columnInfoClassName(VariableElement field) {
+        String qualfiedModelClassName = Utils.getModelClassQualifiedName(field);
+        return Utils.getSimpleColumnInfoClassName(qualfiedModelClassName);
+    }
+
     private String columnIndexVarName(VariableElement variableElement) {
         return variableElement.getSimpleName().toString() + "Index";
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index d058617c1e..b67ac2bea8 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -42,6 +42,7 @@
     private final ProcessingEnvironment processingEnvironment;
     private final List<String> qualifiedModelClasses = new ArrayList<>();
     private final List<String> qualifiedProxyClasses = new ArrayList<>();
+    private final List<String> simpleModelClassNames = new ArrayList<>();
     private final List<String> internalClassNames = new ArrayList<>();
 
 
@@ -52,7 +53,9 @@ public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
 
         for (ClassMetaData metadata : classesToValidate) {
             qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
-            qualifiedProxyClasses.add(REALM_PACKAGE_NAME + "." + Utils.getProxyClassName(metadata.getFullyQualifiedClassName()));
+            String qualifiedProxyClassName = REALM_PACKAGE_NAME + "." + Utils.getProxyClassName(metadata.getFullyQualifiedClassName());
+            qualifiedProxyClasses.add(qualifiedProxyClassName);
+            simpleModelClassNames.add(metadata.getSimpleJavaClassName());
             internalClassNames.add(metadata.getInternalClassName());
         }
     }
@@ -66,8 +69,7 @@ public void generate() throws IOException {
         writer.emitPackage(REALM_PACKAGE_NAME);
         writer.emitEmptyLine();
 
-        writer.emitImports(
-                "android.util.JsonReader",
+        List<String> imports  = new ArrayList<>(Arrays.asList("android.util.JsonReader",
                 "java.io.IOException",
                 "java.util.Collections",
                 "java.util.HashSet",
@@ -77,6 +79,7 @@ public void generate() throws IOException {
                 "java.util.Set",
                 "java.util.Iterator",
                 "java.util.Collection",
+                "io.realm.ImportFlag",
                 "io.realm.internal.ColumnInfo",
                 "io.realm.internal.RealmObjectProxy",
                 "io.realm.internal.RealmProxyMediator",
@@ -84,9 +87,9 @@ public void generate() throws IOException {
                 "io.realm.internal.OsSchemaInfo",
                 "io.realm.internal.OsObjectSchemaInfo",
                 "org.json.JSONException",
-                "org.json.JSONObject"
-        );
+                "org.json.JSONObject"));
 
+        writer.emitImports(imports);
         writer.emitEmptyLine();
 
         writer.emitAnnotation(RealmModule.class);
@@ -103,7 +106,7 @@ public void generate() throws IOException {
         emitGetSimpleClassNameMethod(writer);
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
-        emitCopyToRealmMethod(writer);
+        emitCopyOrUpdateMethod(writer);
         emitInsertObjectToRealmMethod(writer);
         emitInsertListToRealmMethod(writer);
         emitInsertOrUpdateObjectToRealmMethod(writer);
@@ -223,13 +226,17 @@ private void emitGetClassModelList(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
+    private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
                 "<E extends RealmModel> E",
                 "copyOrUpdate",
                 EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmModel, RealmObjectProxy>", "cache"
+                "Realm", "realm",
+                "E", "obj",
+                "boolean", "update",
+                "Map<RealmModel, RealmObjectProxy>", "cache",
+                "Set<ImportFlag>", "flags"
         );
         writer.emitSingleLineComment("This cast is correct because obj is either");
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
@@ -238,7 +245,8 @@ private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+                writer.emitStatement("%1$s columnInfo = (%1$s) realm.getSchema().getColumnInfo(%2$s.class)", Utils.getSimpleColumnInfoClassName(qualifiedModelClasses.get(i)), qualifiedModelClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, columnInfo, (%s) obj, update, cache, flags))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
             }
         }, writer, false);
         writer.endMethod();
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
index 8757727a14..8182828853 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
@@ -17,6 +17,7 @@
 package io.realm.processor;
 
 import java.util.Date;
+import java.util.List;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.VariableElement;
@@ -75,6 +76,7 @@ public static TypeMirror getRealmListElementTypeMirror(VariableElement field) {
         if (!Utils.isRealmList(field)) {
             return null;
         }
-        return ((DeclaredType) field.asType()).getTypeArguments().get(0);
+        List<? extends TypeMirror> typeArguments = ((DeclaredType) field.asType()).getTypeArguments();
+        return (!typeArguments.isEmpty()) ? typeArguments.get(0) : null;
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 88d3a47abd..d091f6b797 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -71,6 +71,14 @@ public static String getProxyClassSimpleName(VariableElement field) {
         }
     }
 
+    public static String getModelClassQualifiedName(VariableElement field) {
+        if (typeUtils.isAssignable(field.asType(), realmList)) {
+            return getGenericTypeQualifiedName(field);
+        } else {
+            return getFieldTypeQualifiedName(field);
+        }
+    }
+
     /**
      * @return the proxy class name for a given clazz
      */
@@ -403,4 +411,13 @@ public static String getReferencedTypeInternalClassNameStatement(String qualifie
         // proxy class, even for files in other jar files.
         return "io.realm." + Utils.getProxyClassName(qualifiedClassName) + ".ClassNameHelper.INTERNAL_CLASS_NAME";
     }
+
+    /**
+     * Returns a simple reference to the ColumnInfo class inside this model class, i.e. the package
+     * name is not prefixed.
+     */
+    public static String getSimpleColumnInfoClassName(String qualifiedModelClassName) {
+        String simpleModelClassName = Utils.stripPackage(qualifiedModelClassName);
+        return Utils.getProxyClassName(qualifiedModelClassName) + "." + simpleModelClassName + "ColumnInfo";
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 0983dd6b14..9c5b47c9da 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -2,6 +2,7 @@
 
 
 import android.util.JsonReader;
+import io.realm.ImportFlag;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.OsSchemaInfo;
@@ -79,13 +80,14 @@ public String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {
         // This cast is correct because obj is either
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return clazz.cast(io.realm.some_test_AllTypesRealmProxy.copyOrUpdate(realm, (some.test.AllTypes) obj, update, cache));
+            some_test_AllTypesRealmProxy.AllTypesColumnInfo columnInfo = (some_test_AllTypesRealmProxy.AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+            return clazz.cast(io.realm.some_test_AllTypesRealmProxy.copyOrUpdate(realm, columnInfo, (some.test.AllTypes) obj, update, cache, flags));
         }
         throw getMissingProxyClassException(clazz);
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java
index ee1fccac5a..a9899a51d0 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_AllTypesRealmProxy.java
@@ -5,6 +5,7 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.ImportFlag;
 import io.realm.ProxyUtils;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
@@ -18,6 +19,7 @@
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
 import io.realm.internal.android.JsonUtils;
+import io.realm.internal.objectstore.OsObjectBuilder;
 import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -27,6 +29,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -36,6 +39,7 @@
         implements RealmObjectProxy, some_test_AllTypesRealmProxyInterface {
 
     static final class AllTypesColumnInfo extends ColumnInfo {
+        long maxColumnIndexValue;
         long columnStringIndex;
         long columnLongIndex;
         long columnFloatIndex;
@@ -81,6 +85,7 @@
             this.columnFloatListIndex = addColumnDetails("columnFloatList", "columnFloatList", objectSchemaInfo);
             this.columnDateListIndex = addColumnDetails("columnDateList", "columnDateList", objectSchemaInfo);
             addBacklinkDetails(schemaInfo, "parentObjects", "AllTypes", "columnObject");
+            this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex();
         }
 
         AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
@@ -117,6 +122,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             dst.columnDoubleListIndex = src.columnDoubleListIndex;
             dst.columnFloatListIndex = src.columnFloatListIndex;
             dst.columnDateListIndex = src.columnDateListIndex;
+            dst.maxColumnIndexValue = src.maxColumnIndexValue;
         }
     }
 
@@ -1155,7 +1161,16 @@ public static String getSimpleClassName() {
         return realm.copyToRealm(obj);
     }
 
-    public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    private static some_test_AllTypesRealmProxy newProxyInstance(BaseRealm realm, Row row) {
+        // Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        objectContext.set(realm, row, realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String>emptyList());
+        io.realm.some_test_AllTypesRealmProxy obj = new io.realm.some_test_AllTypesRealmProxy();
+        objectContext.clear();
+        return obj;
+    }
+
+    public static some.test.AllTypes copyOrUpdate(Realm realm, AllTypesColumnInfo columnInfo, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
             final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
             if (otherRealm.threadId != realm.threadId) {
@@ -1175,7 +1190,6 @@ public static String getSimpleClassName() {
         boolean canUpdate = update;
         if (canUpdate) {
             Table table = realm.getTable(some.test.AllTypes.class);
-            AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
             long pkColumnIndex = columnInfo.columnStringIndex;
             String value = ((some_test_AllTypesRealmProxyInterface) object).realmGet$columnString();
             long rowIndex = Table.NO_MATCH;
@@ -1188,7 +1202,7 @@ public static String getSimpleClassName() {
                 canUpdate = false;
             } else {
                 try {
-                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                    objectContext.set(realm, table.getUncheckedRow(rowIndex), columnInfo, false, Collections.<String> emptyList());
                     realmObject = new io.realm.some_test_AllTypesRealmProxy();
                     cache.put(object, (RealmObjectProxy) realmObject);
                 } finally {
@@ -1197,31 +1211,47 @@ public static String getSimpleClassName() {
             }
         }
 
-        return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache);
+        return (canUpdate) ? update(realm, columnInfo, realmObject, object, cache, flags) : copy(realm, columnInfo, object, update, cache, flags);
     }
 
-    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.AllTypes copy(Realm realm, AllTypesColumnInfo columnInfo, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.AllTypes) cachedRealmObject;
         }
 
-        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-        some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((some_test_AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-
         some_test_AllTypesRealmProxyInterface realmObjectSource = (some_test_AllTypesRealmProxyInterface) newObject;
-        some_test_AllTypesRealmProxyInterface realmObjectCopy = (some_test_AllTypesRealmProxyInterface) realmObject;
-
-        realmObjectCopy.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
-        realmObjectCopy.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
-        realmObjectCopy.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
-        realmObjectCopy.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
-        realmObjectCopy.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
-        realmObjectCopy.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
-
-        realmObjectCopy.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
 
+        Table table = realm.getTable(some.test.AllTypes.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+
+        // Add all non-"object reference" fields
+        builder.addString(columnInfo.columnStringIndex, realmObjectSource.realmGet$columnString());
+        builder.addInteger(columnInfo.columnLongIndex, realmObjectSource.realmGet$columnLong());
+        builder.addFloat(columnInfo.columnFloatIndex, realmObjectSource.realmGet$columnFloat());
+        builder.addDouble(columnInfo.columnDoubleIndex, realmObjectSource.realmGet$columnDouble());
+        builder.addBoolean(columnInfo.columnBooleanIndex, realmObjectSource.realmGet$columnBoolean());
+        builder.addDate(columnInfo.columnDateIndex, realmObjectSource.realmGet$columnDate());
+        builder.addByteArray(columnInfo.columnBinaryIndex, realmObjectSource.realmGet$columnBinary());
+        builder.addMutableRealmInteger(columnInfo.columnMutableRealmIntegerIndex, realmObjectSource.realmGet$columnMutableRealmInteger());
+        builder.addStringList(columnInfo.columnStringListIndex, realmObjectSource.realmGet$columnStringList());
+        builder.addByteArrayList(columnInfo.columnBinaryListIndex, realmObjectSource.realmGet$columnBinaryList());
+        builder.addBooleanList(columnInfo.columnBooleanListIndex, realmObjectSource.realmGet$columnBooleanList());
+        builder.addLongList(columnInfo.columnLongListIndex, realmObjectSource.realmGet$columnLongList());
+        builder.addIntegerList(columnInfo.columnIntegerListIndex, realmObjectSource.realmGet$columnIntegerList());
+        builder.addShortList(columnInfo.columnShortListIndex, realmObjectSource.realmGet$columnShortList());
+        builder.addByteList(columnInfo.columnByteListIndex, realmObjectSource.realmGet$columnByteList());
+        builder.addDoubleList(columnInfo.columnDoubleListIndex, realmObjectSource.realmGet$columnDoubleList());
+        builder.addFloatList(columnInfo.columnFloatListIndex, realmObjectSource.realmGet$columnFloatList());
+        builder.addDateList(columnInfo.columnDateListIndex, realmObjectSource.realmGet$columnDateList());
+
+        // Create the underlying object and cache it before setting any object/objectlist references
+        // This will allow us to break any circular dependencies by using the object cache.
+        Row row = builder.createNewObject();
+        io.realm.some_test_AllTypesRealmProxy realmObjectCopy = newProxyInstance(realm, row);
+        cache.put(newObject, realmObjectCopy);
+
+        // Finally add all fields that reference other Realm Objects, either directly or through a list
         some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
         if (columnObjectObj == null) {
             realmObjectCopy.realmSet$columnObject(null);
@@ -1230,7 +1260,7 @@ public static String getSimpleClassName() {
             if (cachecolumnObject != null) {
                 realmObjectCopy.realmSet$columnObject(cachecolumnObject);
             } else {
-                realmObjectCopy.realmSet$columnObject(some_test_AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
+                realmObjectCopy.realmSet$columnObject(some_test_AllTypesRealmProxy.copyOrUpdate(realm, (some_test_AllTypesRealmProxy.AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class), columnObjectObj, update, cache, flags));
             }
         }
 
@@ -1244,22 +1274,12 @@ public static String getSimpleClassName() {
                 if (cachecolumnRealmList != null) {
                     columnRealmListRealmList.add(cachecolumnRealmList);
                 } else {
-                    columnRealmListRealmList.add(some_test_AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, update, cache));
+                    columnRealmListRealmList.add(some_test_AllTypesRealmProxy.copyOrUpdate(realm, (some_test_AllTypesRealmProxy.AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class), columnRealmListItem, update, cache, flags));
                 }
             }
         }
 
-        realmObjectCopy.realmSet$columnStringList(realmObjectSource.realmGet$columnStringList());
-        realmObjectCopy.realmSet$columnBinaryList(realmObjectSource.realmGet$columnBinaryList());
-        realmObjectCopy.realmSet$columnBooleanList(realmObjectSource.realmGet$columnBooleanList());
-        realmObjectCopy.realmSet$columnLongList(realmObjectSource.realmGet$columnLongList());
-        realmObjectCopy.realmSet$columnIntegerList(realmObjectSource.realmGet$columnIntegerList());
-        realmObjectCopy.realmSet$columnShortList(realmObjectSource.realmGet$columnShortList());
-        realmObjectCopy.realmSet$columnByteList(realmObjectSource.realmGet$columnByteList());
-        realmObjectCopy.realmSet$columnDoubleList(realmObjectSource.realmGet$columnDoubleList());
-        realmObjectCopy.realmSet$columnFloatList(realmObjectSource.realmGet$columnFloatList());
-        realmObjectCopy.realmSet$columnDateList(realmObjectSource.realmGet$columnDateList());
-        return realmObject;
+        return realmObjectCopy;
     }
 
     public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
@@ -2161,65 +2181,60 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         return unmanagedObject;
     }
 
-    static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
+    static some.test.AllTypes update(Realm realm, AllTypesColumnInfo columnInfo, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {
         some_test_AllTypesRealmProxyInterface realmObjectTarget = (some_test_AllTypesRealmProxyInterface) realmObject;
         some_test_AllTypesRealmProxyInterface realmObjectSource = (some_test_AllTypesRealmProxyInterface) newObject;
-        realmObjectTarget.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
-        realmObjectTarget.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
-        realmObjectTarget.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
-        realmObjectTarget.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
-        realmObjectTarget.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
-        realmObjectTarget.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
-        realmObjectTarget.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
+        Table table = realm.getTable(some.test.AllTypes.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+        builder.addString(columnInfo.columnStringIndex, realmObjectSource.realmGet$columnString());
+        builder.addInteger(columnInfo.columnLongIndex, realmObjectSource.realmGet$columnLong());
+        builder.addFloat(columnInfo.columnFloatIndex, realmObjectSource.realmGet$columnFloat());
+        builder.addDouble(columnInfo.columnDoubleIndex, realmObjectSource.realmGet$columnDouble());
+        builder.addBoolean(columnInfo.columnBooleanIndex, realmObjectSource.realmGet$columnBoolean());
+        builder.addDate(columnInfo.columnDateIndex, realmObjectSource.realmGet$columnDate());
+        builder.addByteArray(columnInfo.columnBinaryIndex, realmObjectSource.realmGet$columnBinary());
+        builder.addMutableRealmInteger(columnInfo.columnMutableRealmIntegerIndex, realmObjectSource.realmGet$columnMutableRealmInteger());
+
         some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
         if (columnObjectObj == null) {
-            realmObjectTarget.realmSet$columnObject(null);
+            builder.addNull(columnInfo.columnObjectIndex);
         } else {
             some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
             if (cachecolumnObject != null) {
-                realmObjectTarget.realmSet$columnObject(cachecolumnObject);
+                builder.addObject(columnInfo.columnObjectIndex, cachecolumnObject);
             } else {
-                realmObjectTarget.realmSet$columnObject(some_test_AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
+                builder.addObject(columnInfo.columnObjectIndex, some_test_AllTypesRealmProxy.copyOrUpdate(realm, (some_test_AllTypesRealmProxy.AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class), columnObjectObj, true, cache, flags));
             }
         }
+
         RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
-        RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectTarget.realmGet$columnRealmList();
-        if (columnRealmListList != null && columnRealmListList.size() == columnRealmListRealmList.size()) {
-            // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
-            int objects = columnRealmListList.size();
-            for (int i = 0; i < objects; i++) {
+        if (columnRealmListList != null) {
+            RealmList<some.test.AllTypes> columnRealmListManagedCopy = new RealmList<some.test.AllTypes>();
+            for (int i = 0; i < columnRealmListList.size(); i++) {
                 some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                 some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                 if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.set(i, cachecolumnRealmList);
+                    columnRealmListManagedCopy.add(cachecolumnRealmList);
                 } else {
-                    columnRealmListRealmList.set(i, some_test_AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
+                    columnRealmListManagedCopy.add(some_test_AllTypesRealmProxy.copyOrUpdate(realm, (some_test_AllTypesRealmProxy.AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class), columnRealmListItem, true, cache, flags));
                 }
             }
+            builder.addObjectList(columnInfo.columnRealmListIndex, columnRealmListManagedCopy);
         } else {
-            columnRealmListRealmList.clear();
-            if (columnRealmListList != null) {
-                for (int i = 0; i < columnRealmListList.size(); i++) {
-                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
-                    some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
-                    if (cachecolumnRealmList != null) {
-                        columnRealmListRealmList.add(cachecolumnRealmList);
-                    } else {
-                        columnRealmListRealmList.add(some_test_AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
-                    }
-                }
-            }
-        }
-        realmObjectTarget.realmSet$columnStringList(realmObjectSource.realmGet$columnStringList());
-        realmObjectTarget.realmSet$columnBinaryList(realmObjectSource.realmGet$columnBinaryList());
-        realmObjectTarget.realmSet$columnBooleanList(realmObjectSource.realmGet$columnBooleanList());
-        realmObjectTarget.realmSet$columnLongList(realmObjectSource.realmGet$columnLongList());
-        realmObjectTarget.realmSet$columnIntegerList(realmObjectSource.realmGet$columnIntegerList());
-        realmObjectTarget.realmSet$columnShortList(realmObjectSource.realmGet$columnShortList());
-        realmObjectTarget.realmSet$columnByteList(realmObjectSource.realmGet$columnByteList());
-        realmObjectTarget.realmSet$columnDoubleList(realmObjectSource.realmGet$columnDoubleList());
-        realmObjectTarget.realmSet$columnFloatList(realmObjectSource.realmGet$columnFloatList());
-        realmObjectTarget.realmSet$columnDateList(realmObjectSource.realmGet$columnDateList());
+            builder.addObjectList(columnInfo.columnRealmListIndex, new RealmList<some.test.AllTypes>());
+        }
+        builder.addStringList(columnInfo.columnStringListIndex, realmObjectSource.realmGet$columnStringList());
+        builder.addByteArrayList(columnInfo.columnBinaryListIndex, realmObjectSource.realmGet$columnBinaryList());
+        builder.addBooleanList(columnInfo.columnBooleanListIndex, realmObjectSource.realmGet$columnBooleanList());
+        builder.addLongList(columnInfo.columnLongListIndex, realmObjectSource.realmGet$columnLongList());
+        builder.addIntegerList(columnInfo.columnIntegerListIndex, realmObjectSource.realmGet$columnIntegerList());
+        builder.addShortList(columnInfo.columnShortListIndex, realmObjectSource.realmGet$columnShortList());
+        builder.addByteList(columnInfo.columnByteListIndex, realmObjectSource.realmGet$columnByteList());
+        builder.addDoubleList(columnInfo.columnDoubleListIndex, realmObjectSource.realmGet$columnDoubleList());
+        builder.addFloatList(columnInfo.columnFloatListIndex, realmObjectSource.realmGet$columnFloatList());
+        builder.addDateList(columnInfo.columnDateListIndex, realmObjectSource.realmGet$columnDateList());
+
+        builder.updateExistingObject();
         return realmObject;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java
index ac32ff2b20..770ec514e8 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_BooleansRealmProxy.java
@@ -5,6 +5,7 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.ImportFlag;
 import io.realm.ProxyUtils;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
@@ -17,6 +18,7 @@
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.android.JsonUtils;
+import io.realm.internal.objectstore.OsObjectBuilder;
 import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -26,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,6 +38,7 @@
         implements RealmObjectProxy, some_test_BooleansRealmProxyInterface {
 
     static final class BooleansColumnInfo extends ColumnInfo {
+        long maxColumnIndexValue;
         long doneIndex;
         long isReadyIndex;
         long mCompletedIndex;
@@ -47,6 +51,7 @@
             this.isReadyIndex = addColumnDetails("isReady", "isReady", objectSchemaInfo);
             this.mCompletedIndex = addColumnDetails("mCompleted", "mCompleted", objectSchemaInfo);
             this.anotherBooleanIndex = addColumnDetails("anotherBoolean", "anotherBoolean", objectSchemaInfo);
+            this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex();
         }
 
         BooleansColumnInfo(ColumnInfo src, boolean mutable) {
@@ -67,6 +72,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             dst.isReadyIndex = src.isReadyIndex;
             dst.mCompletedIndex = src.mCompletedIndex;
             dst.anotherBooleanIndex = src.anotherBooleanIndex;
+            dst.maxColumnIndexValue = src.maxColumnIndexValue;
         }
     }
 
@@ -290,7 +296,16 @@ public static String getSimpleClassName() {
         return realm.copyToRealm(obj);
     }
 
-    public static some.test.Booleans copyOrUpdate(Realm realm, some.test.Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    private static some_test_BooleansRealmProxy newProxyInstance(BaseRealm realm, Row row) {
+        // Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        objectContext.set(realm, row, realm.getSchema().getColumnInfo(some.test.Booleans.class), false, Collections.<String>emptyList());
+        io.realm.some_test_BooleansRealmProxy obj = new io.realm.some_test_BooleansRealmProxy();
+        objectContext.clear();
+        return obj;
+    }
+
+    public static some.test.Booleans copyOrUpdate(Realm realm, BooleansColumnInfo columnInfo, some.test.Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
             final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
             if (otherRealm.threadId != realm.threadId) {
@@ -306,27 +321,33 @@ public static String getSimpleClassName() {
             return (some.test.Booleans) cachedRealmObject;
         }
 
-        return copy(realm, object, update, cache);
+        return copy(realm, columnInfo, object, update, cache, flags);
     }
 
-    public static some.test.Booleans copy(Realm realm, some.test.Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.Booleans copy(Realm realm, BooleansColumnInfo columnInfo, some.test.Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.Booleans) cachedRealmObject;
         }
 
-        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-        some.test.Booleans realmObject = realm.createObjectInternal(some.test.Booleans.class, false, Collections.<String>emptyList());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-
         some_test_BooleansRealmProxyInterface realmObjectSource = (some_test_BooleansRealmProxyInterface) newObject;
-        some_test_BooleansRealmProxyInterface realmObjectCopy = (some_test_BooleansRealmProxyInterface) realmObject;
 
-        realmObjectCopy.realmSet$done(realmObjectSource.realmGet$done());
-        realmObjectCopy.realmSet$isReady(realmObjectSource.realmGet$isReady());
-        realmObjectCopy.realmSet$mCompleted(realmObjectSource.realmGet$mCompleted());
-        realmObjectCopy.realmSet$anotherBoolean(realmObjectSource.realmGet$anotherBoolean());
-        return realmObject;
+        Table table = realm.getTable(some.test.Booleans.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+
+        // Add all non-"object reference" fields
+        builder.addBoolean(columnInfo.doneIndex, realmObjectSource.realmGet$done());
+        builder.addBoolean(columnInfo.isReadyIndex, realmObjectSource.realmGet$isReady());
+        builder.addBoolean(columnInfo.mCompletedIndex, realmObjectSource.realmGet$mCompleted());
+        builder.addBoolean(columnInfo.anotherBooleanIndex, realmObjectSource.realmGet$anotherBoolean());
+
+        // Create the underlying object and cache it before setting any object/objectlist references
+        // This will allow us to break any circular dependencies by using the object cache.
+        Row row = builder.createNewObject();
+        io.realm.some_test_BooleansRealmProxy realmObjectCopy = newProxyInstance(realm, row);
+        cache.put(newObject, realmObjectCopy);
+
+        return realmObjectCopy;
     }
 
     public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java
index b33b615633..31e9a3b3fe 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyMixedClassSettingsRealmProxy.java
@@ -5,6 +5,7 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.ImportFlag;
 import io.realm.ProxyUtils;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
@@ -17,6 +18,7 @@
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.android.JsonUtils;
+import io.realm.internal.objectstore.OsObjectBuilder;
 import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -26,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,6 +38,7 @@
         implements RealmObjectProxy, some_test_NamePolicyMixedClassSettingsRealmProxyInterface {
 
     static final class NamePolicyMixedClassSettingsColumnInfo extends ColumnInfo {
+        long maxColumnIndexValue;
         long firstNameIndex;
         long lastNameIndex;
 
@@ -43,6 +47,7 @@
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("customName");
             this.firstNameIndex = addColumnDetails("firstName", "first_name", objectSchemaInfo);
             this.lastNameIndex = addColumnDetails("lastName", "LastName", objectSchemaInfo);
+            this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex();
         }
 
         NamePolicyMixedClassSettingsColumnInfo(ColumnInfo src, boolean mutable) {
@@ -61,6 +66,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             final NamePolicyMixedClassSettingsColumnInfo dst = (NamePolicyMixedClassSettingsColumnInfo) rawDst;
             dst.firstNameIndex = src.firstNameIndex;
             dst.lastNameIndex = src.lastNameIndex;
+            dst.maxColumnIndexValue = src.maxColumnIndexValue;
         }
     }
 
@@ -226,7 +232,16 @@ public static String getSimpleClassName() {
         return realm.copyToRealm(obj);
     }
 
-    public static some.test.NamePolicyMixedClassSettings copyOrUpdate(Realm realm, some.test.NamePolicyMixedClassSettings object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    private static some_test_NamePolicyMixedClassSettingsRealmProxy newProxyInstance(BaseRealm realm, Row row) {
+        // Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        objectContext.set(realm, row, realm.getSchema().getColumnInfo(some.test.NamePolicyMixedClassSettings.class), false, Collections.<String>emptyList());
+        io.realm.some_test_NamePolicyMixedClassSettingsRealmProxy obj = new io.realm.some_test_NamePolicyMixedClassSettingsRealmProxy();
+        objectContext.clear();
+        return obj;
+    }
+
+    public static some.test.NamePolicyMixedClassSettings copyOrUpdate(Realm realm, NamePolicyMixedClassSettingsColumnInfo columnInfo, some.test.NamePolicyMixedClassSettings object, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
             final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
             if (otherRealm.threadId != realm.threadId) {
@@ -242,25 +257,31 @@ public static String getSimpleClassName() {
             return (some.test.NamePolicyMixedClassSettings) cachedRealmObject;
         }
 
-        return copy(realm, object, update, cache);
+        return copy(realm, columnInfo, object, update, cache, flags);
     }
 
-    public static some.test.NamePolicyMixedClassSettings copy(Realm realm, some.test.NamePolicyMixedClassSettings newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.NamePolicyMixedClassSettings copy(Realm realm, NamePolicyMixedClassSettingsColumnInfo columnInfo, some.test.NamePolicyMixedClassSettings newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.NamePolicyMixedClassSettings) cachedRealmObject;
         }
 
-        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-        some.test.NamePolicyMixedClassSettings realmObject = realm.createObjectInternal(some.test.NamePolicyMixedClassSettings.class, false, Collections.<String>emptyList());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-
         some_test_NamePolicyMixedClassSettingsRealmProxyInterface realmObjectSource = (some_test_NamePolicyMixedClassSettingsRealmProxyInterface) newObject;
-        some_test_NamePolicyMixedClassSettingsRealmProxyInterface realmObjectCopy = (some_test_NamePolicyMixedClassSettingsRealmProxyInterface) realmObject;
 
-        realmObjectCopy.realmSet$firstName(realmObjectSource.realmGet$firstName());
-        realmObjectCopy.realmSet$lastName(realmObjectSource.realmGet$lastName());
-        return realmObject;
+        Table table = realm.getTable(some.test.NamePolicyMixedClassSettings.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+
+        // Add all non-"object reference" fields
+        builder.addString(columnInfo.firstNameIndex, realmObjectSource.realmGet$firstName());
+        builder.addString(columnInfo.lastNameIndex, realmObjectSource.realmGet$lastName());
+
+        // Create the underlying object and cache it before setting any object/objectlist references
+        // This will allow us to break any circular dependencies by using the object cache.
+        Row row = builder.createNewObject();
+        io.realm.some_test_NamePolicyMixedClassSettingsRealmProxy realmObjectCopy = newProxyInstance(realm, row);
+        cache.put(newObject, realmObjectCopy);
+
+        return realmObjectCopy;
     }
 
     public static long insert(Realm realm, some.test.NamePolicyMixedClassSettings object, Map<RealmModel,Long> cache) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java
index 29a6d97b08..e65a432ff1 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NamePolicyModuleDefaultsRealmProxy.java
@@ -5,6 +5,7 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.ImportFlag;
 import io.realm.ProxyUtils;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
@@ -17,6 +18,7 @@
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.android.JsonUtils;
+import io.realm.internal.objectstore.OsObjectBuilder;
 import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -26,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,6 +38,7 @@
         implements RealmObjectProxy, some_test_NamePolicyModuleDefaultsRealmProxyInterface {
 
     static final class NamePolicyModuleDefaultsColumnInfo extends ColumnInfo {
+        long maxColumnIndexValue;
         long firstNameIndex;
         long lastNameIndex;
 
@@ -43,6 +47,7 @@
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("NamePolicyModuleDefaults");
             this.firstNameIndex = addColumnDetails("firstName", "FirstName", objectSchemaInfo);
             this.lastNameIndex = addColumnDetails("lastName", "LastName", objectSchemaInfo);
+            this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex();
         }
 
         NamePolicyModuleDefaultsColumnInfo(ColumnInfo src, boolean mutable) {
@@ -61,6 +66,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             final NamePolicyModuleDefaultsColumnInfo dst = (NamePolicyModuleDefaultsColumnInfo) rawDst;
             dst.firstNameIndex = src.firstNameIndex;
             dst.lastNameIndex = src.lastNameIndex;
+            dst.maxColumnIndexValue = src.maxColumnIndexValue;
         }
     }
 
@@ -226,7 +232,16 @@ public static String getSimpleClassName() {
         return realm.copyToRealm(obj);
     }
 
-    public static some.test.NamePolicyModuleDefaults copyOrUpdate(Realm realm, some.test.NamePolicyModuleDefaults object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    private static some_test_NamePolicyModuleDefaultsRealmProxy newProxyInstance(BaseRealm realm, Row row) {
+        // Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        objectContext.set(realm, row, realm.getSchema().getColumnInfo(some.test.NamePolicyModuleDefaults.class), false, Collections.<String>emptyList());
+        io.realm.some_test_NamePolicyModuleDefaultsRealmProxy obj = new io.realm.some_test_NamePolicyModuleDefaultsRealmProxy();
+        objectContext.clear();
+        return obj;
+    }
+
+    public static some.test.NamePolicyModuleDefaults copyOrUpdate(Realm realm, NamePolicyModuleDefaultsColumnInfo columnInfo, some.test.NamePolicyModuleDefaults object, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
             final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
             if (otherRealm.threadId != realm.threadId) {
@@ -242,25 +257,31 @@ public static String getSimpleClassName() {
             return (some.test.NamePolicyModuleDefaults) cachedRealmObject;
         }
 
-        return copy(realm, object, update, cache);
+        return copy(realm, columnInfo, object, update, cache, flags);
     }
 
-    public static some.test.NamePolicyModuleDefaults copy(Realm realm, some.test.NamePolicyModuleDefaults newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.NamePolicyModuleDefaults copy(Realm realm, NamePolicyModuleDefaultsColumnInfo columnInfo, some.test.NamePolicyModuleDefaults newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.NamePolicyModuleDefaults) cachedRealmObject;
         }
 
-        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-        some.test.NamePolicyModuleDefaults realmObject = realm.createObjectInternal(some.test.NamePolicyModuleDefaults.class, false, Collections.<String>emptyList());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-
         some_test_NamePolicyModuleDefaultsRealmProxyInterface realmObjectSource = (some_test_NamePolicyModuleDefaultsRealmProxyInterface) newObject;
-        some_test_NamePolicyModuleDefaultsRealmProxyInterface realmObjectCopy = (some_test_NamePolicyModuleDefaultsRealmProxyInterface) realmObject;
 
-        realmObjectCopy.realmSet$firstName(realmObjectSource.realmGet$firstName());
-        realmObjectCopy.realmSet$lastName(realmObjectSource.realmGet$lastName());
-        return realmObject;
+        Table table = realm.getTable(some.test.NamePolicyModuleDefaults.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+
+        // Add all non-"object reference" fields
+        builder.addString(columnInfo.firstNameIndex, realmObjectSource.realmGet$firstName());
+        builder.addString(columnInfo.lastNameIndex, realmObjectSource.realmGet$lastName());
+
+        // Create the underlying object and cache it before setting any object/objectlist references
+        // This will allow us to break any circular dependencies by using the object cache.
+        Row row = builder.createNewObject();
+        io.realm.some_test_NamePolicyModuleDefaultsRealmProxy realmObjectCopy = newProxyInstance(realm, row);
+        cache.put(newObject, realmObjectCopy);
+
+        return realmObjectCopy;
     }
 
     public static long insert(Realm realm, some.test.NamePolicyModuleDefaults object, Map<RealmModel,Long> cache) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java
index 1e5c65b4a4..5d37725d00 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_NullTypesRealmProxy.java
@@ -5,6 +5,7 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.ImportFlag;
 import io.realm.ProxyUtils;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
@@ -17,6 +18,7 @@
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.android.JsonUtils;
+import io.realm.internal.objectstore.OsObjectBuilder;
 import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -26,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,6 +38,7 @@
         implements RealmObjectProxy, some_test_NullTypesRealmProxyInterface {
 
     static final class NullTypesColumnInfo extends ColumnInfo {
+        long maxColumnIndexValue;
         long fieldStringNotNullIndex;
         long fieldStringNullIndex;
         long fieldBooleanNotNullIndex;
@@ -121,6 +125,7 @@
             this.fieldFloatListNullIndex = addColumnDetails("fieldFloatListNull", "fieldFloatListNull", objectSchemaInfo);
             this.fieldDateListNotNullIndex = addColumnDetails("fieldDateListNotNull", "fieldDateListNotNull", objectSchemaInfo);
             this.fieldDateListNullIndex = addColumnDetails("fieldDateListNull", "fieldDateListNull", objectSchemaInfo);
+            this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex();
         }
 
         NullTypesColumnInfo(ColumnInfo src, boolean mutable) {
@@ -178,6 +183,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             dst.fieldFloatListNullIndex = src.fieldFloatListNullIndex;
             dst.fieldDateListNotNullIndex = src.fieldDateListNotNullIndex;
             dst.fieldDateListNullIndex = src.fieldDateListNullIndex;
+            dst.maxColumnIndexValue = src.maxColumnIndexValue;
         }
     }
 
@@ -2178,7 +2184,16 @@ public static String getSimpleClassName() {
         return realm.copyToRealm(obj);
     }
 
-    public static some.test.NullTypes copyOrUpdate(Realm realm, some.test.NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    private static some_test_NullTypesRealmProxy newProxyInstance(BaseRealm realm, Row row) {
+        // Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        objectContext.set(realm, row, realm.getSchema().getColumnInfo(some.test.NullTypes.class), false, Collections.<String>emptyList());
+        io.realm.some_test_NullTypesRealmProxy obj = new io.realm.some_test_NullTypesRealmProxy();
+        objectContext.clear();
+        return obj;
+    }
+
+    public static some.test.NullTypes copyOrUpdate(Realm realm, NullTypesColumnInfo columnInfo, some.test.NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
             final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
             if (otherRealm.threadId != realm.threadId) {
@@ -2194,43 +2209,69 @@ public static String getSimpleClassName() {
             return (some.test.NullTypes) cachedRealmObject;
         }
 
-        return copy(realm, object, update, cache);
+        return copy(realm, columnInfo, object, update, cache, flags);
     }
 
-    public static some.test.NullTypes copy(Realm realm, some.test.NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.NullTypes copy(Realm realm, NullTypesColumnInfo columnInfo, some.test.NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.NullTypes) cachedRealmObject;
         }
 
-        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-        some.test.NullTypes realmObject = realm.createObjectInternal(some.test.NullTypes.class, false, Collections.<String>emptyList());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-
         some_test_NullTypesRealmProxyInterface realmObjectSource = (some_test_NullTypesRealmProxyInterface) newObject;
-        some_test_NullTypesRealmProxyInterface realmObjectCopy = (some_test_NullTypesRealmProxyInterface) realmObject;
-
-        realmObjectCopy.realmSet$fieldStringNotNull(realmObjectSource.realmGet$fieldStringNotNull());
-        realmObjectCopy.realmSet$fieldStringNull(realmObjectSource.realmGet$fieldStringNull());
-        realmObjectCopy.realmSet$fieldBooleanNotNull(realmObjectSource.realmGet$fieldBooleanNotNull());
-        realmObjectCopy.realmSet$fieldBooleanNull(realmObjectSource.realmGet$fieldBooleanNull());
-        realmObjectCopy.realmSet$fieldBytesNotNull(realmObjectSource.realmGet$fieldBytesNotNull());
-        realmObjectCopy.realmSet$fieldBytesNull(realmObjectSource.realmGet$fieldBytesNull());
-        realmObjectCopy.realmSet$fieldByteNotNull(realmObjectSource.realmGet$fieldByteNotNull());
-        realmObjectCopy.realmSet$fieldByteNull(realmObjectSource.realmGet$fieldByteNull());
-        realmObjectCopy.realmSet$fieldShortNotNull(realmObjectSource.realmGet$fieldShortNotNull());
-        realmObjectCopy.realmSet$fieldShortNull(realmObjectSource.realmGet$fieldShortNull());
-        realmObjectCopy.realmSet$fieldIntegerNotNull(realmObjectSource.realmGet$fieldIntegerNotNull());
-        realmObjectCopy.realmSet$fieldIntegerNull(realmObjectSource.realmGet$fieldIntegerNull());
-        realmObjectCopy.realmSet$fieldLongNotNull(realmObjectSource.realmGet$fieldLongNotNull());
-        realmObjectCopy.realmSet$fieldLongNull(realmObjectSource.realmGet$fieldLongNull());
-        realmObjectCopy.realmSet$fieldFloatNotNull(realmObjectSource.realmGet$fieldFloatNotNull());
-        realmObjectCopy.realmSet$fieldFloatNull(realmObjectSource.realmGet$fieldFloatNull());
-        realmObjectCopy.realmSet$fieldDoubleNotNull(realmObjectSource.realmGet$fieldDoubleNotNull());
-        realmObjectCopy.realmSet$fieldDoubleNull(realmObjectSource.realmGet$fieldDoubleNull());
-        realmObjectCopy.realmSet$fieldDateNotNull(realmObjectSource.realmGet$fieldDateNotNull());
-        realmObjectCopy.realmSet$fieldDateNull(realmObjectSource.realmGet$fieldDateNull());
 
+        Table table = realm.getTable(some.test.NullTypes.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+
+        // Add all non-"object reference" fields
+        builder.addString(columnInfo.fieldStringNotNullIndex, realmObjectSource.realmGet$fieldStringNotNull());
+        builder.addString(columnInfo.fieldStringNullIndex, realmObjectSource.realmGet$fieldStringNull());
+        builder.addBoolean(columnInfo.fieldBooleanNotNullIndex, realmObjectSource.realmGet$fieldBooleanNotNull());
+        builder.addBoolean(columnInfo.fieldBooleanNullIndex, realmObjectSource.realmGet$fieldBooleanNull());
+        builder.addByteArray(columnInfo.fieldBytesNotNullIndex, realmObjectSource.realmGet$fieldBytesNotNull());
+        builder.addByteArray(columnInfo.fieldBytesNullIndex, realmObjectSource.realmGet$fieldBytesNull());
+        builder.addInteger(columnInfo.fieldByteNotNullIndex, realmObjectSource.realmGet$fieldByteNotNull());
+        builder.addInteger(columnInfo.fieldByteNullIndex, realmObjectSource.realmGet$fieldByteNull());
+        builder.addInteger(columnInfo.fieldShortNotNullIndex, realmObjectSource.realmGet$fieldShortNotNull());
+        builder.addInteger(columnInfo.fieldShortNullIndex, realmObjectSource.realmGet$fieldShortNull());
+        builder.addInteger(columnInfo.fieldIntegerNotNullIndex, realmObjectSource.realmGet$fieldIntegerNotNull());
+        builder.addInteger(columnInfo.fieldIntegerNullIndex, realmObjectSource.realmGet$fieldIntegerNull());
+        builder.addInteger(columnInfo.fieldLongNotNullIndex, realmObjectSource.realmGet$fieldLongNotNull());
+        builder.addInteger(columnInfo.fieldLongNullIndex, realmObjectSource.realmGet$fieldLongNull());
+        builder.addFloat(columnInfo.fieldFloatNotNullIndex, realmObjectSource.realmGet$fieldFloatNotNull());
+        builder.addFloat(columnInfo.fieldFloatNullIndex, realmObjectSource.realmGet$fieldFloatNull());
+        builder.addDouble(columnInfo.fieldDoubleNotNullIndex, realmObjectSource.realmGet$fieldDoubleNotNull());
+        builder.addDouble(columnInfo.fieldDoubleNullIndex, realmObjectSource.realmGet$fieldDoubleNull());
+        builder.addDate(columnInfo.fieldDateNotNullIndex, realmObjectSource.realmGet$fieldDateNotNull());
+        builder.addDate(columnInfo.fieldDateNullIndex, realmObjectSource.realmGet$fieldDateNull());
+        builder.addStringList(columnInfo.fieldStringListNotNullIndex, realmObjectSource.realmGet$fieldStringListNotNull());
+        builder.addStringList(columnInfo.fieldStringListNullIndex, realmObjectSource.realmGet$fieldStringListNull());
+        builder.addByteArrayList(columnInfo.fieldBinaryListNotNullIndex, realmObjectSource.realmGet$fieldBinaryListNotNull());
+        builder.addByteArrayList(columnInfo.fieldBinaryListNullIndex, realmObjectSource.realmGet$fieldBinaryListNull());
+        builder.addBooleanList(columnInfo.fieldBooleanListNotNullIndex, realmObjectSource.realmGet$fieldBooleanListNotNull());
+        builder.addBooleanList(columnInfo.fieldBooleanListNullIndex, realmObjectSource.realmGet$fieldBooleanListNull());
+        builder.addLongList(columnInfo.fieldLongListNotNullIndex, realmObjectSource.realmGet$fieldLongListNotNull());
+        builder.addLongList(columnInfo.fieldLongListNullIndex, realmObjectSource.realmGet$fieldLongListNull());
+        builder.addIntegerList(columnInfo.fieldIntegerListNotNullIndex, realmObjectSource.realmGet$fieldIntegerListNotNull());
+        builder.addIntegerList(columnInfo.fieldIntegerListNullIndex, realmObjectSource.realmGet$fieldIntegerListNull());
+        builder.addShortList(columnInfo.fieldShortListNotNullIndex, realmObjectSource.realmGet$fieldShortListNotNull());
+        builder.addShortList(columnInfo.fieldShortListNullIndex, realmObjectSource.realmGet$fieldShortListNull());
+        builder.addByteList(columnInfo.fieldByteListNotNullIndex, realmObjectSource.realmGet$fieldByteListNotNull());
+        builder.addByteList(columnInfo.fieldByteListNullIndex, realmObjectSource.realmGet$fieldByteListNull());
+        builder.addDoubleList(columnInfo.fieldDoubleListNotNullIndex, realmObjectSource.realmGet$fieldDoubleListNotNull());
+        builder.addDoubleList(columnInfo.fieldDoubleListNullIndex, realmObjectSource.realmGet$fieldDoubleListNull());
+        builder.addFloatList(columnInfo.fieldFloatListNotNullIndex, realmObjectSource.realmGet$fieldFloatListNotNull());
+        builder.addFloatList(columnInfo.fieldFloatListNullIndex, realmObjectSource.realmGet$fieldFloatListNull());
+        builder.addDateList(columnInfo.fieldDateListNotNullIndex, realmObjectSource.realmGet$fieldDateListNotNull());
+        builder.addDateList(columnInfo.fieldDateListNullIndex, realmObjectSource.realmGet$fieldDateListNull());
+
+        // Create the underlying object and cache it before setting any object/objectlist references
+        // This will allow us to break any circular dependencies by using the object cache.
+        Row row = builder.createNewObject();
+        io.realm.some_test_NullTypesRealmProxy realmObjectCopy = newProxyInstance(realm, row);
+        cache.put(newObject, realmObjectCopy);
+
+        // Finally add all fields that reference other Realm Objects, either directly or through a list
         some.test.NullTypes fieldObjectNullObj = realmObjectSource.realmGet$fieldObjectNull();
         if (fieldObjectNullObj == null) {
             realmObjectCopy.realmSet$fieldObjectNull(null);
@@ -2239,30 +2280,11 @@ public static String getSimpleClassName() {
             if (cachefieldObjectNull != null) {
                 realmObjectCopy.realmSet$fieldObjectNull(cachefieldObjectNull);
             } else {
-                realmObjectCopy.realmSet$fieldObjectNull(some_test_NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
-            }
-        }
-        realmObjectCopy.realmSet$fieldStringListNotNull(realmObjectSource.realmGet$fieldStringListNotNull());
-        realmObjectCopy.realmSet$fieldStringListNull(realmObjectSource.realmGet$fieldStringListNull());
-        realmObjectCopy.realmSet$fieldBinaryListNotNull(realmObjectSource.realmGet$fieldBinaryListNotNull());
-        realmObjectCopy.realmSet$fieldBinaryListNull(realmObjectSource.realmGet$fieldBinaryListNull());
-        realmObjectCopy.realmSet$fieldBooleanListNotNull(realmObjectSource.realmGet$fieldBooleanListNotNull());
-        realmObjectCopy.realmSet$fieldBooleanListNull(realmObjectSource.realmGet$fieldBooleanListNull());
-        realmObjectCopy.realmSet$fieldLongListNotNull(realmObjectSource.realmGet$fieldLongListNotNull());
-        realmObjectCopy.realmSet$fieldLongListNull(realmObjectSource.realmGet$fieldLongListNull());
-        realmObjectCopy.realmSet$fieldIntegerListNotNull(realmObjectSource.realmGet$fieldIntegerListNotNull());
-        realmObjectCopy.realmSet$fieldIntegerListNull(realmObjectSource.realmGet$fieldIntegerListNull());
-        realmObjectCopy.realmSet$fieldShortListNotNull(realmObjectSource.realmGet$fieldShortListNotNull());
-        realmObjectCopy.realmSet$fieldShortListNull(realmObjectSource.realmGet$fieldShortListNull());
-        realmObjectCopy.realmSet$fieldByteListNotNull(realmObjectSource.realmGet$fieldByteListNotNull());
-        realmObjectCopy.realmSet$fieldByteListNull(realmObjectSource.realmGet$fieldByteListNull());
-        realmObjectCopy.realmSet$fieldDoubleListNotNull(realmObjectSource.realmGet$fieldDoubleListNotNull());
-        realmObjectCopy.realmSet$fieldDoubleListNull(realmObjectSource.realmGet$fieldDoubleListNull());
-        realmObjectCopy.realmSet$fieldFloatListNotNull(realmObjectSource.realmGet$fieldFloatListNotNull());
-        realmObjectCopy.realmSet$fieldFloatListNull(realmObjectSource.realmGet$fieldFloatListNull());
-        realmObjectCopy.realmSet$fieldDateListNotNull(realmObjectSource.realmGet$fieldDateListNotNull());
-        realmObjectCopy.realmSet$fieldDateListNull(realmObjectSource.realmGet$fieldDateListNull());
-        return realmObject;
+                realmObjectCopy.realmSet$fieldObjectNull(some_test_NullTypesRealmProxy.copyOrUpdate(realm, (some_test_NullTypesRealmProxy.NullTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.NullTypes.class), fieldObjectNullObj, update, cache, flags));
+            }
+        }
+
+        return realmObjectCopy;
     }
 
     public static long insert(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java
index c072b532cb..e7e2e91a29 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/some_test_SimpleRealmProxy.java
@@ -5,6 +5,7 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
+import io.realm.ImportFlag;
 import io.realm.ProxyUtils;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
@@ -17,6 +18,7 @@
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.android.JsonUtils;
+import io.realm.internal.objectstore.OsObjectBuilder;
 import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -26,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -35,6 +38,7 @@
         implements RealmObjectProxy, some_test_SimpleRealmProxyInterface {
 
     static final class SimpleColumnInfo extends ColumnInfo {
+        long maxColumnIndexValue;
         long nameIndex;
         long ageIndex;
 
@@ -43,6 +47,7 @@
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Simple");
             this.nameIndex = addColumnDetails("name", "name", objectSchemaInfo);
             this.ageIndex = addColumnDetails("age", "age", objectSchemaInfo);
+            this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex();
         }
 
         SimpleColumnInfo(ColumnInfo src, boolean mutable) {
@@ -61,6 +66,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             final SimpleColumnInfo dst = (SimpleColumnInfo) rawDst;
             dst.nameIndex = src.nameIndex;
             dst.ageIndex = src.ageIndex;
+            dst.maxColumnIndexValue = src.maxColumnIndexValue;
         }
     }
 
@@ -218,7 +224,16 @@ public static String getSimpleClassName() {
         return realm.copyToRealm(obj);
     }
 
-    public static some.test.Simple copyOrUpdate(Realm realm, some.test.Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    private static some_test_SimpleRealmProxy newProxyInstance(BaseRealm realm, Row row) {
+        // Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        objectContext.set(realm, row, realm.getSchema().getColumnInfo(some.test.Simple.class), false, Collections.<String>emptyList());
+        io.realm.some_test_SimpleRealmProxy obj = new io.realm.some_test_SimpleRealmProxy();
+        objectContext.clear();
+        return obj;
+    }
+
+    public static some.test.Simple copyOrUpdate(Realm realm, SimpleColumnInfo columnInfo, some.test.Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
             final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
             if (otherRealm.threadId != realm.threadId) {
@@ -234,25 +249,31 @@ public static String getSimpleClassName() {
             return (some.test.Simple) cachedRealmObject;
         }
 
-        return copy(realm, object, update, cache);
+        return copy(realm, columnInfo, object, update, cache, flags);
     }
 
-    public static some.test.Simple copy(Realm realm, some.test.Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.Simple copy(Realm realm, SimpleColumnInfo columnInfo, some.test.Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.Simple) cachedRealmObject;
         }
 
-        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-        some.test.Simple realmObject = realm.createObjectInternal(some.test.Simple.class, false, Collections.<String>emptyList());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-
         some_test_SimpleRealmProxyInterface realmObjectSource = (some_test_SimpleRealmProxyInterface) newObject;
-        some_test_SimpleRealmProxyInterface realmObjectCopy = (some_test_SimpleRealmProxyInterface) realmObject;
 
-        realmObjectCopy.realmSet$name(realmObjectSource.realmGet$name());
-        realmObjectCopy.realmSet$age(realmObjectSource.realmGet$age());
-        return realmObject;
+        Table table = realm.getTable(some.test.Simple.class);
+        OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags);
+
+        // Add all non-"object reference" fields
+        builder.addString(columnInfo.nameIndex, realmObjectSource.realmGet$name());
+        builder.addInteger(columnInfo.ageIndex, realmObjectSource.realmGet$age());
+
+        // Create the underlying object and cache it before setting any object/objectlist references
+        // This will allow us to break any circular dependencies by using the object cache.
+        Row row = builder.createNewObject();
+        io.realm.some_test_SimpleRealmProxy realmObjectCopy = newProxyInstance(realm, row);
+        cache.put(newObject, realmObjectCopy);
+
+        return realmObjectCopy;
     }
 
     public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java b/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
index ae1c0c78f0..ffb65eb4da 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
@@ -189,7 +189,7 @@ public void required() {
             MutableRealmIntegerTypes c2 = realm.copyToRealm(c1);
             fail("should not be able to copy a null value to a @Required MutableRealmInteger");
         } catch(IllegalArgumentException ignore) {
-            checkException(ignore, "is not nullable");
+            checkException(ignore, "Missing value for property");
         }
         realm.commitTransaction();
     }
@@ -429,7 +429,7 @@ public void testStream() throws IOException {
             obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
             fail("Attempt to set @Required Mutable Realm Integer null, from JSON, should fail");
         } catch (IllegalArgumentException ignore) {
-            checkException(ignore, "is not nullable");
+            checkException(ignore, "Missing value for property");
         }
         realm.commitTransaction();
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index fe5e347d47..27ef50903e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -33,6 +33,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -44,6 +46,9 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import javax.annotation.Nullable;
+
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
 import io.realm.log.LogLevel;
@@ -52,6 +57,7 @@
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
+import kotlin.reflect.jvm.internal.impl.descriptors.deserialization.PlatformDependentDeclarationFilter;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -1098,4 +1104,31 @@ public void execute(Realm realm) {
             }
         });
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void diffedUpdates_ignoredFieldsAreNotListedAsChanged() {
+        realm = looperThread.getRealm();
+        AllJavaTypes obj;
+        realm.beginTransaction();
+        AllJavaTypes childObject = realm.copyToRealm(new AllJavaTypes(1));
+        obj = realm.copyToRealmOrUpdate(new AllJavaTypes(42));
+        obj.setFieldObject(childObject);
+        obj.setFieldList(new RealmList<>(childObject));
+        looperThread.keepStrongReference(obj);
+        realm.commitTransaction();
+        obj.addChangeListener((RealmObjectChangeListener<AllJavaTypes>) (object, changeSet) -> {
+            assertEquals(1, changeSet.getChangedFields().length);
+            assertEquals("fieldString", changeSet.getChangedFields()[0]);
+            looperThread.testComplete();
+        });
+
+        realm.beginTransaction();
+        AllJavaTypes updatedObj = new AllJavaTypes(42);
+        updatedObj.setFieldString("updated");
+        updatedObj.setFieldObject(childObject);
+        updatedObj.setFieldList(new RealmList<>(childObject));
+        realm.copyToRealmOrUpdate(updatedObj, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET);
+        realm.commitTransaction();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 453cadea35..c6065d7da8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -33,6 +33,7 @@
 import org.junit.After;
 import org.junit.Assume;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -1499,6 +1500,46 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
         }
     }
 
+    @Test
+    public void copyToRealm_duplicatedPrimaryKeyThrows() {
+        final String[] PRIMARY_KEY_TYPES = { "String", "BoxedLong", "long" };
+        for (String className : PRIMARY_KEY_TYPES) {
+            String expectedKey = null;
+            try {
+                realm.beginTransaction();
+                switch (className) {
+                    case "String": {
+                        expectedKey = "foo";
+                        PrimaryKeyAsString obj = new PrimaryKeyAsString("foo");
+                        realm.copyToRealm(obj);
+                        realm.copyToRealm(obj);
+                        break;
+                    }
+                    case "BoxedLong": {
+                        expectedKey = Long.toString(Long.MIN_VALUE);
+                        PrimaryKeyAsBoxedLong obj = new PrimaryKeyAsBoxedLong(Long.MIN_VALUE, "boxedlong");
+                        realm.copyToRealm(obj);
+                        realm.copyToRealm(obj);
+                        break;
+                    }
+                    case "long":
+                        expectedKey = Long.toString(Long.MAX_VALUE);
+                        PrimaryKeyAsLong obj = new PrimaryKeyAsLong(Long.MAX_VALUE);
+                        realm.copyToRealm(obj);
+                        realm.copyToRealm(obj);
+                        break;
+                    default:
+                }
+                fail("Null value as primary key already exists, but wasn't detected correctly");
+            } catch (RealmPrimaryKeyConstraintException expected) {
+                assertTrue("Exception message is: " + expected.getMessage(),
+                        expected.getMessage().contains("with an existing primary key value '"+ expectedKey +"'"));
+            } finally {
+                realm.cancelTransaction();
+            }
+        }
+    }
+
     @Test
     public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
         final String[] PRIMARY_KEY_TYPES = {"String", "BoxedByte", "BoxedShort", "BoxedInteger", "BoxedLong"};
@@ -1530,10 +1571,10 @@ public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
                         break;
                     default:
                 }
-                fail("Null value as primary key already exists.");
+                fail("Null value as primary key already exists, but wasn't detected correctly");
             } catch (RealmPrimaryKeyConstraintException expected) {
                 assertTrue("Exception message is: " + expected.getMessage(),
-                        expected.getMessage().contains("Primary key value already exists: 'null' ."));
+                        expected.getMessage().contains("with an existing primary key value 'null'"));
             } finally {
                 realm.cancelTransaction();
             }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 472c26a581..e86333d6cf 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.entities.StringOnly;
@@ -400,6 +401,52 @@ public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException
         }
     }
 
+    @Test
+    @UiThreadTest
+    public void uploadAllLocalChanges_withTimeout_throwsOnUiThread() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        try {
+            SyncManager.getOrCreateSession(configuration, null).uploadAllLocalChanges(30, TimeUnit.SECONDS);
+            fail("Should throw an IllegalStateException on Ui Thread");
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void uploadAllLocalChanges_withTimeout_invalidParametersThrows() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
+        try {
+            try {
+                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                //noinspection ConstantConditions
+                session.uploadAllLocalChanges(1, null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void uploadAllLocalChanges_returnFalseWhenTimedOut() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
+        try {
+            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS));
+        } finally {
+            realm.close();
+        }
+    }
+
     @Test
     @UiThreadTest
     public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {
@@ -413,6 +460,53 @@ public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedExcept
         }
     }
 
+    @Test
+    @UiThreadTest
+    public void downloadAllServerChanges_withTimeout_throwsOnUiThread() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        try {
+            SyncManager.getOrCreateSession(configuration, null).downloadAllServerChanges(30, TimeUnit.SECONDS);
+            fail("Should throw an IllegalStateException on Ui Thread");
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
+
+
+    @Test
+    public void downloadAllServerChanges_withTimeout_invalidParametersThrows() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
+        try {
+            try {
+                session.downloadAllServerChanges(-1, TimeUnit.SECONDS);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                //noinspection ConstantConditions
+                session.downloadAllServerChanges(1, null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void downloadAllServerChanges_returnFalseWhenTimedOut() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
+        try {
+            assertFalse(session.downloadAllServerChanges(100, TimeUnit.MILLISECONDS));
+        } finally {
+            realm.close();
+        }
+    }
+
     @Test
     @UiThreadTest
     public void unrecognizedErrorCode_errorHandler() {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 101423ac7b..70426004ae 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -42,6 +42,7 @@
 import static io.realm.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
 public class SyncManagerTests {
@@ -188,6 +189,7 @@ public void session() throws IOException {
     private void tryCase(Runnable runnable) {
         try {
             runnable.run();
+            fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -243,7 +245,6 @@ public void addCustomRequestHeader_illegalArgumentThrows() {
 
     @Test
     public void addCustomRequestHeaders_illegalArgumentThrows() {
-        tryCase(() -> SyncManager.addCustomRequestHeaders(null));
         tryCase(() -> SyncManager.addCustomRequestHeaders(Collections.emptyMap(), null));
         tryCase(() -> SyncManager.addCustomRequestHeaders(Collections.emptyMap(), ""));
     }
@@ -283,6 +284,7 @@ public void addCustomHeaders() throws URISyntaxException {
         Map<String, String> inputHeaders = new LinkedHashMap<>();
         inputHeaders.put("header1", "value1");
         inputHeaders.put("header2", "value2");
+        SyncManager.addCustomRequestHeaders(null);
         SyncManager.addCustomRequestHeaders(inputHeaders);
         Map<String, String> outputHeaders = SyncManager.getCustomRequestHeaders(new URI("http://localhost"));
         assertEquals(2, outputHeaders.size());
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 5672cdb318..d1bd38ee21 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -66,6 +66,7 @@ set(classes_LIST
     io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
     io.realm.internal.OsObjectStore io.realm.internal.sync.OsSubscription
     io.realm.internal.core.DescriptorOrdering
+    io.realm.internal.objectstore.OsObjectBuilder
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index d34e026d87..ea9aedeba9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -92,12 +92,13 @@ JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeReset(JNIEnv* env, jclass
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncManager(JNIEnv* env, jclass, jstring sync_base_dir)
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncManager(JNIEnv* env, jclass, jstring j_sync_base_dir, jstring j_user_agent_info)
 {
     TR_ENTER()
     try {
-        JStringAccessor base_file_path(env, sync_base_dir); // throws
-        SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
+        JStringAccessor base_file_path(env, j_sync_base_dir); // throws
+        JStringAccessor user_agent_info(env, j_user_agent_info); // throws
+        SyncManager::shared().configure(base_file_path, SyncManager::MetadataMode::NoEncryption, user_agent_info);
 
         static AndroidClientListener client_thread_listener(env);
         // Register Sync Client thread start/stop callback
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
index b291ea3c28..7653455602 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
@@ -137,3 +137,26 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetPrima
     CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetMaxColumnIndex(JNIEnv* env, jclass,
+                                                                                         jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        if (object_schema.persisted_properties.empty()) {
+            return static_cast<jlong>(-1);
+        } else {
+            size_t maxIndex = 0;
+            for (Property p : object_schema.persisted_properties) {
+                if (p.table_column > maxIndex) {
+                    maxIndex = p.table_column;
+                }
+            }
+            return static_cast<jlong>(maxIndex);
+        }
+    }
+    CATCH_STD()
+    return static_cast<jlong>(-1);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsObjectBuilder.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsObjectBuilder.cpp
new file mode 100644
index 0000000000..d23bb0bc59
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_objectstore_OsObjectBuilder.cpp
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_objectstore_OsObjectBuilder.h"
+
+#include "java_object_accessor.hpp"
+#include "util.hpp"
+
+#include <realm/util/any.hpp>
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::_impl;
+
+typedef std::vector<JavaValue> OsObjectData;
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeDestroyBuilder(JNIEnv*, jclass, jlong data_ptr)
+{
+    TR_ENTER()
+    delete reinterpret_cast<OsObjectData*>(data_ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeCreateBuilder(JNIEnv* env, jclass, jlong size)
+{
+    TR_ENTER()
+    try {
+        auto list = new std::vector<JavaValue>(size);
+        return reinterpret_cast<jlong>(list);
+    }
+    CATCH_STD()
+    return -1;
+}
+
+static inline void add_property(jlong data_ptr, jlong column_index, JavaValue const& value)
+{
+    OsObjectData* data = reinterpret_cast<OsObjectData*>(data_ptr);
+    data->at(column_index) = std::move(value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddNull
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index)
+{
+    try {
+        const JavaValue value = JavaValue();
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddString
+    (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jstring j_value)
+{
+    try {
+        JStringAccessor value(env, j_value);
+        std::string string_value(value);
+        const JavaValue wrapped_value(string_value);
+        add_property(data_ptr, column_index, wrapped_value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddInteger
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jlong j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddFloat
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jfloat j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddDouble
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jdouble j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddBoolean
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jboolean j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddByteArray
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jbyteArray j_value)
+{
+    try {
+        auto data = OwnedBinaryData(JByteArrayAccessor(env, j_value).transform<BinaryData>());
+        const JavaValue value(data);
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddDate
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jlong j_value)
+{
+    try {
+        const JavaValue value(from_milliseconds(j_value));
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddObject
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jlong row_ptr)
+{
+    try {
+        const JavaValue value(reinterpret_cast<RowExpr*>(row_ptr));
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+static inline const ObjectSchema& get_schema(const Schema& schema, Table* table)
+{
+    std::string table_name(table->get_name());
+    std::string class_name = std::string(table_name.substr(TABLE_PREFIX.length()));
+    auto it = schema.find(class_name);
+    if (it == schema.end()) {
+        throw std::runtime_error(format("Class '%1' cannot be found in the schema.", class_name.data()));
+    }
+    return *it;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeCreateOrUpdate
+        (JNIEnv* env, jclass, jlong shared_realm_ptr, jlong table_ptr, jlong builder_ptr, jboolean update_existing, jboolean ignore_same_values)
+{
+    try {
+        SharedRealm shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        Table* table = reinterpret_cast<realm::Table*>(table_ptr);
+        const auto& schema = shared_realm->schema();
+        const ObjectSchema& object_schema = get_schema(schema, table);
+        JavaContext ctx(env, shared_realm, object_schema);
+        auto list = *reinterpret_cast<OsObjectData*>(builder_ptr);
+        JavaValue values = JavaValue(list);
+        Object obj = Object::create(ctx, shared_realm, object_schema, values, update_existing, ignore_same_values);
+        return reinterpret_cast<jlong>(new Row(obj.row()));
+    }
+    CATCH_STD()
+    return realm::npos;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeStartList
+        (JNIEnv* env, jclass, jlong list_size)
+{
+    try {
+        auto list = new std::vector<JavaValue>();
+        list->reserve(list_size);
+        return reinterpret_cast<jlong>(list);
+    }
+    CATCH_STD()
+    return realm::npos;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeStopList
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jlong list_ptr)
+{
+    try {
+        auto list = reinterpret_cast<std::vector<JavaValue>*>(list_ptr);
+        const JavaValue value((*list));
+        add_property(data_ptr, column_index, value);
+        delete list;
+    }
+    CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddObjectList
+        (JNIEnv* env, jclass, jlong data_ptr, jlong column_index, jlongArray row_ptrs)
+{
+    try {
+        auto rows = JLongArrayAccessor(env, row_ptrs);
+        auto list = std::vector<JavaValue>();
+        list.reserve(rows.size());
+        for (jsize i = 0; i < rows.size(); ++i) {
+            auto item = JavaValue(reinterpret_cast<RowExpr*>(rows[i]));
+            list.push_back(item);
+        }
+        JavaValue value(list);
+        add_property(data_ptr, column_index, value);
+    }
+    CATCH_STD()
+}
+
+static inline void add_list_element(jlong list_ptr, JavaValue const& value)
+{
+    auto list = reinterpret_cast<std::vector<JavaValue>*>(list_ptr);
+    list->push_back(std::move(value));
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddNullListItem
+        (JNIEnv* env, jclass, jlong list_ptr)
+{
+    try {
+        const JavaValue value = JavaValue();
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddIntegerListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jlong j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddStringListItem
+    (JNIEnv* env, jclass, jlong list_ptr, jstring j_value)
+{
+    try {
+        JStringAccessor value(env, j_value);
+        std::string string_value(value);
+        const JavaValue wrapped_value(string_value);
+        add_list_element(list_ptr, wrapped_value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddFloatListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jfloat j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddDoubleListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jdouble j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddBooleanListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jboolean j_value)
+{
+    try {
+        const JavaValue value(j_value);
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddByteArrayListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jbyteArray j_value)
+{
+    try {
+        auto data = OwnedBinaryData(JByteArrayAccessor(env, j_value).transform<BinaryData>());
+        const JavaValue value(data);
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddDateListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jlong j_value)
+{
+    try {
+        const JavaValue value(from_milliseconds(j_value));
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectstore_OsObjectBuilder_nativeAddObjectListItem
+        (JNIEnv* env, jclass, jlong list_ptr, jlong row_ptr)
+{
+    try {
+        const JavaValue value(reinterpret_cast<RowExpr*>(row_ptr));
+        add_list_element(list_ptr, value);
+    }
+    CATCH_STD()
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/cpp/java_object_accessor.hpp b/realm/realm-library/src/main/cpp/java_object_accessor.hpp
new file mode 100644
index 0000000000..5054ec5dc3
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_object_accessor.hpp
@@ -0,0 +1,533 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2018 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_JAVA_OBJECT_ACCESSOR
+#define REALM_JAVA_OBJECT_ACCESSOR
+
+#include <algorithm>
+#include <cstddef>
+#include <type_traits>
+
+#include "java_accessor.hpp"
+#include "java_class_global_def.hpp"
+#include "object_accessor.hpp"
+#include "object-store/src/property.hpp"
+
+#include <realm/row.hpp>
+#include <realm/util/any.hpp>
+
+using namespace realm::_impl;
+
+#define REALM_FOR_EACH_JAVA_VALUE_TYPE(X) \
+    X(Integer) \
+    X(String) \
+    X(Boolean) \
+    X(Float) \
+    X(Double) \
+    X(Date) \
+    X(Binary) \
+    X(Object) \
+    X(List) \
+
+
+namespace realm {
+
+struct JavaValue;
+
+enum class JavaValueType {
+    Empty,
+#define REALM_DEFINE_JAVA_VALUE_TYPE(x) x,
+    REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_DEFINE_JAVA_VALUE_TYPE)
+#undef REALM_DEFINE_JAVA_VALUE_TYPE
+    NumValueTypes
+};
+
+// Ugly work-around for initializer lists having problems on GCC 4.9
+template <class T> constexpr T realm_max(T a) {
+    return a;
+}
+
+template <class T, class... Rest> constexpr T realm_max(T a, T b, Rest... rest) {
+    return a > realm_max(b, rest...) ? a : realm_max(b, rest...);
+}
+
+template <JavaValueType> struct JavaValueTypeRepr;
+template <> struct JavaValueTypeRepr<JavaValueType::Integer> { using Type = jlong; };
+template <> struct JavaValueTypeRepr<JavaValueType::String>  { using Type = std::string; };
+template <> struct JavaValueTypeRepr<JavaValueType::Boolean> { using Type = jboolean; };
+template <> struct JavaValueTypeRepr<JavaValueType::Float>   { using Type = jfloat; };
+template <> struct JavaValueTypeRepr<JavaValueType::Double>  { using Type = jdouble; };
+template <> struct JavaValueTypeRepr<JavaValueType::Date>    { using Type = Timestamp; };
+template <> struct JavaValueTypeRepr<JavaValueType::Binary>  { using Type = OwnedBinaryData; };
+template <> struct JavaValueTypeRepr<JavaValueType::Object>  { using Type = RowExpr*; };
+template <> struct JavaValueTypeRepr<JavaValueType::List>    { using Type = std::vector<JavaValue>; };
+
+// Tagged union class representing all the values Java can send to Object Store
+struct JavaValue {
+    using Storage = std::aligned_storage_t<realm_max(
+#define REALM_GET_SIZE_OF_JAVA_VALUE_TYPE_REPR(x) \
+        sizeof(JavaValueTypeRepr<JavaValueType::x>::Type),
+        REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_GET_SIZE_OF_JAVA_VALUE_TYPE_REPR)
+        size_t(0)
+#undef REALM_GET_SIZE_OF_JAVA_VALUE_TYPE_REPR
+        ), realm_max(
+#define REALM_GET_ALIGN_OF_JAVA_VALUE_TYPE_REPR(x) \
+        alignof(JavaValueTypeRepr<JavaValueType::x>::Type),
+        REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_GET_ALIGN_OF_JAVA_VALUE_TYPE_REPR)
+        size_t(0)
+#undef REALM_GET_ALIGN_OF_JAVA_VALUE_TYPE_REPR
+        )>;
+
+    Storage m_storage;
+    JavaValueType m_type;
+
+    // Initializer constructors
+    JavaValue() : m_type(JavaValueType::Empty) {}
+
+#define REALM_DEFINE_JAVA_VALUE_TYPE_CONSTRUCTOR(x) \
+    explicit JavaValue(JavaValueTypeRepr<JavaValueType::x>::Type value) : m_type(JavaValueType::x) \
+    { \
+        new(&m_storage) JavaValueTypeRepr<JavaValueType::x>::Type{std::move(value)}; \
+    }
+    REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_DEFINE_JAVA_VALUE_TYPE_CONSTRUCTOR)
+#undef REALM_DEFINE_JAVA_VALUE_TYPE_CONSTRUCTOR
+
+    // Copy constructors
+    JavaValue(const JavaValue& jvt) : m_type(JavaValueType::Empty) {
+        *this = jvt;
+    }
+
+    // Move constructor
+    JavaValue(JavaValue&& jvt) : m_type(JavaValueType::Empty) {
+        *this = std::move(jvt);
+    }
+
+    ~JavaValue()
+    {
+        clear();
+    }
+
+    JavaValue& operator=(const JavaValue& rhs)
+    {
+       clear();
+       switch (rhs.m_type) {
+#define REALM_DEFINE_JAVA_VALUE_COPY_ASSIGNMENT(x) \
+           case JavaValueType::x: { \
+               using T = JavaValueTypeRepr<JavaValueType::x>::Type; \
+               new(&m_storage) T{*reinterpret_cast<const T*>(&rhs.m_storage)}; \
+               break; \
+           }
+        REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_DEFINE_JAVA_VALUE_COPY_ASSIGNMENT)
+#undef REALM_DEFINE_JAVA_VALUE_COPY_ASSIGNMENT
+           default: REALM_ASSERT(rhs.m_type == JavaValueType::Empty);
+        }
+        m_type = rhs.m_type;
+        return *this;
+    }
+
+    JavaValue& operator=(JavaValue&& rhs)
+    {
+       clear();
+       switch (rhs.m_type) {
+           case JavaValueType::Empty: break; // Do nothing
+#define REALM_DEFINE_JAVA_VALUE_COPY_ASSIGNMENT(x) \
+           case JavaValueType::x: { \
+               using T = JavaValueTypeRepr<JavaValueType::x>::Type; \
+               new(&m_storage) T{std::move(*reinterpret_cast<T*>(&rhs.m_storage))}; \
+               break; \
+           }
+        REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_DEFINE_JAVA_VALUE_COPY_ASSIGNMENT)
+#undef REALM_DEFINE_JAVA_VALUE_COPY_ASSIGNMENT
+           default: REALM_TERMINATE("Invalid type");
+        }
+        m_type = rhs.m_type;
+        return *this;
+    }
+
+    bool has_value() const noexcept
+    {
+        return m_type != JavaValueType::Empty;
+    }
+
+    JavaValueType get_type() const noexcept
+    {
+        return m_type;
+    }
+
+    template <JavaValueType type>
+    const typename JavaValueTypeRepr<type>::Type& get_as() const noexcept
+    {
+        REALM_ASSERT(m_type == type);
+        return *reinterpret_cast<const typename JavaValueTypeRepr<type>::Type*>(&m_storage);
+    }
+
+    auto& get_int() const noexcept
+    {
+        return get_as<JavaValueType::Integer>();
+    }
+
+    auto& get_boolean() const noexcept
+    {
+        return get_as<JavaValueType::Boolean>();
+    }
+
+    auto& get_string() const noexcept
+    {
+        return get_as<JavaValueType::String>();
+    }
+
+    auto& get_float() const noexcept
+    {
+        return get_as<JavaValueType::Float>();
+    }
+
+    auto& get_double() const noexcept
+    {
+        return get_as<JavaValueType::Double>();
+    }
+
+    auto& get_list() const noexcept
+    {
+        return get_as<JavaValueType::List>();
+    }
+
+    auto& get_date() const noexcept
+    {
+        return get_as<JavaValueType::Date>();
+    }
+
+    auto& get_binary() const noexcept
+    {
+        return get_as<JavaValueType::Binary>();
+    }
+
+    auto& get_object() const noexcept
+    {
+        return get_as<JavaValueType::Object>();
+    }
+
+    void clear() noexcept
+    {
+        switch (m_type) {
+            case JavaValueType::Empty: break; // Do nothing
+#define REALM_DEFINE_JAVA_VALUE_DESTROY(x) \
+            case JavaValueType::x: { \
+                using T = JavaValueTypeRepr<JavaValueType::x>::Type; \
+                reinterpret_cast<T*>(&m_storage)->~T(); \
+                break; \
+            }
+            REALM_FOR_EACH_JAVA_VALUE_TYPE(REALM_DEFINE_JAVA_VALUE_DESTROY)
+#undef REALM_DEFINE_JAVA_VALUE_DESTROY
+            default: REALM_TERMINATE("Invalid type.");
+        }
+        m_type = JavaValueType::Empty;
+    }
+
+    // Returns a string representation of the value contained in this object.
+    std::string to_string() const {
+        std::ostringstream ss;
+        switch(m_type) {
+            case JavaValueType::Empty:
+                return "null";
+            case JavaValueType::Integer:
+                ss << static_cast<int64_t>(get_int());
+                return std::string(ss.str());
+            case JavaValueType::String:
+                return get_string();
+            case JavaValueType::Boolean:
+                return (get_boolean() == JNI_TRUE) ? "true" : "false";
+            case JavaValueType::Float:
+                ss << static_cast<float>(get_float());
+                return std::string(ss.str());
+            case JavaValueType::Double:
+                ss << static_cast<double>(get_double());
+                return std::string(ss.str());
+            case JavaValueType::Date:
+                ss << get_date();
+                return std::string(ss.str());
+            case JavaValueType::Binary:
+                ss << "Blob[";
+                ss << get_binary().size();
+                ss << "]";
+                return std::string(ss.str());
+            case JavaValueType::Object:
+                ss << "Object[Type: ";
+                ss << get_object()->get_table()->get_name();
+                ss << ", rowIndex: ";
+                ss << get_object()->get_index();
+                ss << "]";
+                return std::string(ss.str());
+            case JavaValueType::List:
+                ss << "List[size: ";
+                ss << get_list().size();
+                ss << "]";
+                return std::string(ss.str());
+            default: REALM_TERMINATE("Invalid type.");
+        }
+    }
+};
+
+
+struct RequiredFieldValueNotProvidedException : public std::logic_error {
+    const std::string object_type;
+    RequiredFieldValueNotProvidedException(const std::string& object_type)
+            : std::logic_error("This field is required. A non-null '" + object_type + "' type value is expected.")
+    {
+    }
+};
+
+// This is the Java implementation of the `CppContext` class found in `object_accessor_impl.hpp`
+// It is an object accessor context which can be used to create and access objects.
+// It will map between JNI types and Cores data types.
+class JavaContext {
+public:
+    JavaContext(JNIEnv* env, std::shared_ptr<Realm> realm, const ObjectSchema& os)
+    : m_env(env),
+      realm(std::move(realm)),
+      object_schema(&os) { }
+
+    // This constructor is the only one used by the object accessor code, and is
+    // used when recurring into a link or array property during object creation
+    // (i.e. prop.type will always be Object or Array).
+    JavaContext(JavaContext& c, Property const& prop)
+            : m_env(c.m_env),
+              realm(c.realm)
+            , object_schema(prop.type == PropertyType::Object ? &*realm->schema().find(prop.object_type) : c.object_schema)
+    { }
+
+    // The use of util::Optional for the following two functions is not a hard
+    // requirement; only that it be some type which can be evaluated in a
+    // boolean context to determine if it contains a value, and if it does
+    // contain a value it must be dereferencable to obtain that value.
+
+    // Get the value for a property in an input object, or `util::none` if no
+    // value present. The property is identified both by the name of the
+    // property and its index within the ObjectScehma's persisted_properties
+    // array.
+    util::Optional<JavaValue> value_for_property(JavaValue& dict,
+                                                 Property const& prop,
+                                                 size_t /*property_index*/) const
+    {
+        const std::vector<JavaValue>& list = dict.get_list();
+        auto property_value = list.at(prop.table_column);
+        return util::make_optional(property_value);
+    }
+
+    // Get the default value for the given property in the given object schema,
+    // or `util::none` if there is none (which is distinct from the default
+    // being `null`).
+    //
+    // This implementation does not support default values; see the default
+    // value tests for an example of one which does.
+    util::Optional<JavaValue>
+    default_value_for_property(ObjectSchema const&, Property const&) const
+    {
+        return util::none;
+    }
+
+    // Invoke `fn` with each of the values from an enumerable type
+    template<typename Func>
+    void enumerate_list(JavaValue& value, Func&& fn) {
+        if (value.get_type() == JavaValueType::List) {
+            for (const auto& v : value.get_list()) {
+                fn(v);
+            }
+        } else {
+            throw std::logic_error("Type is not a list");
+        }
+    }
+
+    // Determine if `value` boxes the same List as `list`
+    bool is_same_list(List const& /*list*/, JavaValue const& /*value*/)
+    {
+        // Lists from Java are currently never the same as the ones found in Object Store.
+        return false;
+    }
+
+    // Convert from core types to the boxed type. These are currently not used as Proxy objects read
+    // directly from the Row objects. This implementation is thus only here as a reminder of which
+    // method signatures to add if needed.
+    // JavaValueType box(BinaryData v) const { return reinterpret_cast<jobject>(JavaClassGlobalDef::new_byte_array(m_env, v)); }
+    // JavaValueType box(List /*v*/) const { REALM_TERMINATE("'List' not implemented"); }
+    // JavaValueType box(Object /*v*/) const { REALM_TERMINATE("'Object' not implemented"); }
+    // JavaValueType box(Results /*v*/) const { REALM_TERMINATE("'Results' not implemented"); }
+    // JavaValueType box(StringData v) const { return reinterpret_cast<jobject>(to_jstring(m_env, v)); }
+    // JavaValueType box(Timestamp v) const { return JavaClassGlobalDef::new_date(m_env, v); }
+    // JavaValueType box(bool v) const { return _impl::JavaClassGlobalDef::new_boolean(m_env, v); }
+    // JavaValueType box(double v) const { return _impl::JavaClassGlobalDef::new_double(m_env, v); }
+    // JavaValueType box(float v) const { return _impl::JavaClassGlobalDef::new_float(m_env, v); }
+    // JavaValueType box(int64_t v) const { return _impl::JavaClassGlobalDef::new_long(m_env, v); }
+    // JavaValueType box(util::Optional<bool> v) const { return v ? _impl::JavaClassGlobalDef::new_boolean(m_env, v.value()) : nullptr; }
+    // JavaValueType box(util::Optional<double> v) const { return v ? _impl::JavaClassGlobalDef::new_double(m_env, v.value()) : nullptr; }
+    // JavaValueType box(util::Optional<float> v) const { return v ? _impl::JavaClassGlobalDef::new_float(m_env, v.value()) : nullptr; }
+    // JavaValueType box(util::Optional<int64_t> v) const { return v ? _impl::JavaClassGlobalDef::new_long(m_env, v.value()) : nullptr; }
+    // JavaValueType box(RowExpr) const { REALM_TERMINATE("'RowExpr' not implemented"); }
+
+    // Mixed type is only supported by the Cocoa binding to enable reading
+    // old Realm files that may have used them. All other bindings can ignore it.
+//    JavaValueType box(Mixed) const { REALM_TERMINATE("'Mixed' not supported"); }
+
+    // Convert from the boxed type to core types. This needs to be implemented
+    // for all of the types which `box()` can take, plus `RowExpr` and optional
+    // versions of the numeric types, minus `List` and `Results`.
+    //
+    // `create` and `update` are only applicable to `unbox<RowExpr>`. If
+    // `create` is false then when given something which is not a managed Realm
+    // object `unbox()` should simply return a detached row expr, while if it's
+    // true then `unbox()` should create a new object in the context's Realm
+    // using the provided value. If `update` is true then upsert semantics
+    // should be used for this.
+    template<typename T>
+    T unbox(JavaValue const& /*v*/, bool /*create*/= false, bool /*update*/= false, bool /*diff_on_update*/= false, size_t /*current_row*/ = realm::npos) const {
+        throw std::logic_error("Missing template specialization"); // All types should have specialized templates
+    }
+
+    bool is_null(JavaValue const& v) const noexcept { return !v.has_value(); }
+    JavaValue null_value() const noexcept { return {}; }
+    util::Optional<JavaValue> no_value() const noexcept { return {}; }
+
+    // Hooks which will be called before and after modifying a property from
+    // within Object::create(). These are not currently used.
+    void will_change(Object const&, Property const&) {}
+    void did_change() {}
+
+    // Get a string representation of the given value for use in error messages.
+    // This method is currently only used when printing warnings about primary keys
+    // which means the output only need to be valid for the primary key types:
+    // StringData, int64_t and Optional<int64_t>
+    std::string print(JavaValue const& val) const {
+        return val.to_string();
+    }
+
+    // Cocoa allows supplying fewer values than there are properties when
+    // creating objects using an array of values. Other bindings should not
+    // mimick this behavior so just return false here.
+    bool allow_missing(JavaValue const&) const { return false; }
+
+private:
+    JNIEnv* m_env;
+    std::shared_ptr<Realm> realm;
+    const ObjectSchema* object_schema = nullptr;
+
+    inline void check_value_not_null(JavaValue const& v, const char* expected_type) const
+    {
+        if (!v.has_value()) {
+            throw RequiredFieldValueNotProvidedException(std::string(expected_type));
+        }
+    }
+};
+
+template <>
+inline bool JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    check_value_not_null(v, "Boolean");
+    return v.get_boolean() == JNI_TRUE;
+}
+
+template <>
+inline int64_t JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    check_value_not_null(v, "Long");
+    return static_cast<int64_t>(v.get_int());
+}
+
+template <>
+inline double JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    check_value_not_null(v, "Double");
+    return static_cast<double>(v.get_double());
+}
+
+template <>
+inline float JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    check_value_not_null(v, "Float");
+    return static_cast<float>(v.get_float());
+}
+
+template <>
+inline StringData JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    if (!v.has_value()) {
+        return StringData();
+    }
+
+    return StringData(v.get_string());
+}
+
+template <>
+inline BinaryData JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    if (!v.has_value()) {
+        return BinaryData();
+    } else {
+        return v.get_binary().get();
+    }
+}
+
+template <>
+inline Timestamp JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    return v.has_value() ? v.get_date() : Timestamp();
+}
+
+template <>
+inline RowExpr JavaContext::unbox(JavaValue const& v, bool create, bool update, bool diff_on_update, size_t current_row) const
+{
+    if (v.get_type() == JavaValueType::Object) {
+        return *v.get_object();
+    } else if (!create) {
+        return RowExpr();
+    }
+    REALM_ASSERT(object_schema);
+    return Object::create(const_cast<JavaContext&>(*this), realm, *object_schema, v, update, diff_on_update, current_row).row();
+}
+
+template <>
+inline util::Optional<bool> JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    return v.has_value() ? util::make_optional(v.get_boolean() == JNI_TRUE) : util::none;
+}
+
+template <>
+inline util::Optional<int64_t> JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    return v.has_value() ? util::make_optional(static_cast<int64_t>(v.get_int())) : util::none;
+}
+
+template <>
+inline util::Optional<double> JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    return v.has_value() ? util::make_optional(v.get_double()) : util::none;
+}
+
+template <>
+inline util::Optional<float> JavaContext::unbox(JavaValue const& v, bool, bool, bool, size_t) const
+{
+    return v.has_value() ? util::make_optional(v.get_float()) : util::none;
+}
+
+template <>
+inline Mixed JavaContext::unbox(JavaValue const&, bool, bool, bool, size_t) const
+{
+    REALM_TERMINATE("'Mixed' not supported");
+}
+
+}
+
+#endif // REALM_JAVA_OBJECT_ACCESSOR_HPP
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 1f91c82eb3..f0dfe6c03b 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 1f91c82eb34cf4eaa2900794a9268390876f19f1
+Subproject commit f0dfe6c03be49194bc40777901059eaf55e7bff6
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 23371bb901..4aa3a5474d 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -30,14 +30,14 @@
 #include "results.hpp"
 #include "list.hpp"
 #include "java_exception_def.hpp"
+#include "java_object_accessor.hpp"
+#include "object.hpp"
 #if REALM_ENABLE_SYNC
 #include "sync/partial_sync.hpp"
 #endif
 
 #include "jni_util/java_exception_thrower.hpp"
 
-
-
 using namespace std;
 using namespace realm;
 using namespace realm::util;
@@ -125,6 +125,12 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         }
         ThrowException(env, kind, e.what());
     }
+    catch(realm::MissingPropertyValueException e) {
+        ThrowException(env, IllegalArgument, e.what());
+    }
+    catch(realm::RequiredFieldValueNotProvidedException e) {
+        ThrowException(env, IllegalArgument, e.what());
+    }
 #if REALM_ENABLE_SYNC
     catch (partial_sync::InvalidRealmStateException& e) {
         ThrowException(env, IllegalState, e.what());
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 42071658f0..6b9c2d2a3f 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -455,6 +455,10 @@ class JStringAccessor {
         return m_is_null || m_size == 0;
     }
 
+    bool is_null() {
+        return m_is_null;
+    }
+
     operator realm::StringData() const
     {
         // To solve the link issue by directly using Table::max_string_size
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 67f6caf905..1c94cc6413 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -525,6 +525,8 @@ public RealmPrivileges getPrivileges() {
      * @return the privileges granted the current user for the object.
      * @throws IllegalArgumentException if the object is either null, unmanaged or not part of this Realm.
      */
+    @Beta
+    @ObjectServer
     public ObjectPrivileges getPrivileges(RealmModel object) {
         checkIfValid();
         //noinspection ConstantConditions
@@ -844,7 +846,12 @@ public void clear() {
         }
     }
 
-    // FIXME: This stuff doesn't appear to be used.  It should either be explained or deleted.
+    /**
+     * CM: This is used when creating new proxy classes directly from the generated proxy code.
+     * It is a bit unclear exactly how it works, but it seems to be some work-around for some
+     * constructor shenanigans, i.e. values are set in this object just before the Proxy object
+     * is created (see `RealmDefaultModuleMediator.newInstance)`).
+     */
     static final class ThreadLocalRealmObjectContext extends ThreadLocal<RealmObjectContext> {
         @Override
         protected RealmObjectContext initialValue() {
diff --git a/realm/realm-library/src/main/java/io/realm/ImportFlag.java b/realm/realm-library/src/main/java/io/realm/ImportFlag.java
new file mode 100644
index 0000000000..0b482262f8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/ImportFlag.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import io.realm.annotations.Beta;
+
+/**
+ * This class describe how data is saved to Realm when saving whole objects.
+ *
+ * @see Realm#copyToRealm(RealmModel, ImportFlag...)
+ */
+@Beta
+public enum ImportFlag {
+
+    /**
+     * With this flag enabled, fields will not be written to the Realm file if they contain the same
+     * value as the value already present in the Realm.
+     * <p>
+     * For local Realms this only has an impact on change listeners which will not report changes to
+     * those fields that was not written.
+     * <p>
+     * For synchronized Realms this also impacts the server, which will see improved performance as
+     * there is less changes to upload and merge into the server Realm.
+     * <p>
+     * It also impact how the server merges changes from different devices. Realm uses a
+     * last-write-wins approach when merging individual fields in an object, so if a field is not
+     * written it will be considered "older" than other fields modified.
+     * <p>
+     * E.g:
+     * <ol>
+     *     <li>
+     *         Server starts out with (Field A = 1, Field B = 1)
+     *     </li>
+     *     <li>
+     *         Device 1 writes (Field A = 2, Field B = 2).
+     *     </li>
+     *     <li>
+     *         Device 2 writes (Field A = 3, Field B = 1) but ignores (Field B = 1), because that is
+     *         the value in the Realm file at this point.
+     *     </li>
+     *     <li>
+     *         Device 1 uploads its changes to the server making the server (Field A = 2, Field B = 2).
+     *         Then Device 2 uploads its changes. Due to last-write-wins, the server version now
+     *         becomes (Field A = 3, Field B = 2).
+     *     </li>
+     * </ol>
+     * This is normally the desired behaviour as the final object is the merged result of the latest
+     * changes from both devices, however if all the fields in an object are considered an atomic
+     * unit, then this flag should not be set as it will ensure that all fields are set and thus have
+     * the same "age" when data are sent to the server.
+     *
+     * @see <a href="https://docs.realm.io/platform/self-hosted/customize/conflict-resolution">Docs on conflict resolution</a>
+     */
+    CHECK_SAME_VALUES_BEFORE_SET,
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 8a4b8b2ff3..1dd7a7315b 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -53,6 +53,7 @@
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.NativeObject;
 import io.realm.internal.ObjectServerFacade;
@@ -261,6 +262,57 @@ public RealmSchema getSchema() {
      * @see #getDefaultInstance()
      */
     public static synchronized void init(Context context) {
+        initializeRealm(context, "");
+    }
+
+
+    /**
+     * Initializes the Realm library and creates a default configuration that is ready to use. It is required to call
+     * this method before interacting with any other of the Realm API's.
+     * <p>
+     * A good place is in an {@link android.app.Application} subclass:
+     * <pre>
+     * {@code
+     * public class MyApplication extends Application {
+     *   \@Override
+     *   public void onCreate() {
+     *     super.onCreate();
+     *     Realm.init(this, "MyApp/" + BuildConfig.VERSION_NAME);
+     *   }
+     * }
+     * }
+     * </pre>
+     * <p>
+     * Remember to register it in the {@code AndroidManifest.xml} file:
+     * <pre>
+     * {@code
+     * <?xml version="1.0" encoding="utf-8"?>
+     * <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="io.realm.example">
+     * <application android:name=".MyApplication">
+     *   // ...
+     * </application>
+     * </manifest>
+     * }
+     * </pre>
+     *
+     * @param context the Application Context.
+     * @param userAgent optional user defined string that will be sent to the Realm Object Server
+     * as part of a {@code User-Agent} header when a session is established. This setting will not be
+     * used by non-synchronized Realms.
+     * @throws IllegalArgumentException if a {@code null} context or userAgent is provided.
+     * @throws IllegalStateException if {@link Context#getFilesDir()} could not be found.
+     * @see #getDefaultInstance()
+     */
+    @ObjectServer
+    public static synchronized void init(Context context, String userAgent) {
+        //noinspection ConstantConditions
+        if (userAgent == null) {
+            throw new IllegalArgumentException("Non-null 'userAgent' required.");
+        }
+        initializeRealm(context, userAgent);
+    }
+
+    private static void initializeRealm(Context context, String userAgent) {
         if (BaseRealm.applicationContext == null) {
             //noinspection ConstantConditions
             if (context == null) {
@@ -269,7 +321,7 @@ public static synchronized void init(Context context) {
             checkFilesDirAvailable(context);
             RealmCore.loadLibrary(context);
             setDefaultConfiguration(new RealmConfiguration.Builder(context).build());
-            ObjectServerFacade.getSyncFacadeIfPossible().init(context);
+            ObjectServerFacade.getSyncFacadeIfPossible().init(context, userAgent);
             if (context.getApplicationContext() != null) {
                 BaseRealm.applicationContext = context.getApplicationContext();
             } else {
@@ -913,7 +965,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * <p>
      * This method is only available for model classes with no @PrimaryKey annotation.
      * If you like to create an object that has a primary key, use {@link #createObject(Class, Object)}
-     * or {@link #copyToRealm(RealmModel)} instead.
+     * or {@link #copyToRealm(RealmModel, ImportFlag...)} instead.
      *
      * @param clazz the Class of the object to create.
      * @return the new object.
@@ -1008,13 +1060,14 @@ private Scanner getFullStringScanner(InputStream in) {
      * set to their default value if not provided.
      *
      * @param object the {@link io.realm.RealmObject} to copy to the Realm.
+     * @param flags any flag that modifies the behaviour of inserting the data into the Realm.
      * @return a managed RealmObject with its properties backed by the Realm.
      * @throws java.lang.IllegalArgumentException if the object is {@code null} or it belongs to a Realm instance
      * in a different thread.
      */
-    public <E extends RealmModel> E copyToRealm(E object) {
+    public <E extends RealmModel> E copyToRealm(E object, ImportFlag... flags) {
         checkNotNullObject(object);
-        return copyOrUpdate(object, false, new HashMap<RealmModel, RealmObjectProxy>());
+        return copyOrUpdate(object, false, new HashMap<>(), Util.toSet(flags));
     }
 
     /**
@@ -1026,15 +1079,16 @@ private Scanner getFullStringScanner(InputStream in) {
      * set to their default value if not provided.
      *
      * @param object {@link io.realm.RealmObject} to copy or update.
+     * @param flags any flag that modifies the behaviour of inserting the data into the Realm.
      * @return the new or updated RealmObject with all its properties backed by the Realm.
      * @throws java.lang.IllegalArgumentException if the object is {@code null} or doesn't have a Primary key defined
      * or it belongs to a Realm instance in a different thread.
-     * @see #copyToRealm(RealmModel)
+     * @see #copyToRealm(RealmModel, ImportFlag...)
      */
-    public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
+    public <E extends RealmModel> E copyToRealmOrUpdate(E object, ImportFlag... flags) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object.getClass());
-        return copyOrUpdate(object, true, new HashMap<RealmModel, RealmObjectProxy>());
+        return copyOrUpdate(object, true, new HashMap<>(), Util.toSet(flags));
     }
 
     /**
@@ -1046,11 +1100,12 @@ private Scanner getFullStringScanner(InputStream in) {
      * set to their default value if not provided.
      *
      * @param objects the RealmObjects to copy to the Realm.
+     * @param flags any flag that modifies the behaviour of inserting the data into the Realm.
      * @return a list of the the converted RealmObjects that all has their properties managed by the Realm.
      * @throws io.realm.exceptions.RealmException if any of the objects has already been added to Realm.
      * @throws java.lang.IllegalArgumentException if any of the elements in the input collection is {@code null}.
      */
-    public <E extends RealmModel> List<E> copyToRealm(Iterable<E> objects) {
+    public <E extends RealmModel> List<E> copyToRealm(Iterable<E> objects, ImportFlag... flags) {
         //noinspection ConstantConditions
         if (objects == null) {
             return new ArrayList<>();
@@ -1064,14 +1119,14 @@ private Scanner getFullStringScanner(InputStream in) {
         Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
         for (E object : objects) {
             checkNotNullObject(object);
-            realmObjects.add(copyOrUpdate(object, false, cache));
+            realmObjects.add(copyOrUpdate(object, false, cache, Util.toSet(flags)));
         }
 
         return realmObjects;
     }
 
     /**
-     * Inserts a list of an unmanaged RealmObjects. This is generally faster than {@link #copyToRealm(Iterable)} since it
+     * Inserts a list of an unmanaged RealmObjects. This is generally faster than {@link #copyToRealm(Iterable, ImportFlag...)} since it
      * doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      * <p>
@@ -1085,13 +1140,13 @@ private Scanner getFullStringScanner(InputStream in) {
      * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
      * </ul>
      * <p>
-     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable)}, otherwise if
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable, ImportFlag...)}, otherwise if
      * you have a large number of object this method is generally faster.
      *
      * @param objects RealmObjects to insert.
      * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
      * transaction.
-     * @see #copyToRealm(Iterable)
+     * @see #copyToRealm(Iterable, ImportFlag...)
      */
     public void insert(Collection<? extends RealmModel> objects) {
         checkIfValidAndInTransaction();
@@ -1106,7 +1161,7 @@ public void insert(Collection<? extends RealmModel> objects) {
     }
 
     /**
-     * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyToRealm(RealmModel)} since it
+     * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyToRealm(RealmModel, ImportFlag...)} since it
      * doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      * <p>
@@ -1120,7 +1175,7 @@ public void insert(Collection<? extends RealmModel> objects) {
      * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
      * </ul>
      * <p>
-     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel)}, otherwise if
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel, ImportFlag...)}, otherwise if
      * you have a large number of object this method is generally faster.
      *
      * @param object RealmObjects to insert.
@@ -1128,7 +1183,7 @@ public void insert(Collection<? extends RealmModel> objects) {
      * transaction.
      * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
      * inserted or if a primary key value already exists in the Realm.
-     * @see #copyToRealm(RealmModel)
+     * @see #copyToRealm(RealmModel, ImportFlag...)
      */
     public void insert(RealmModel object) {
         checkIfValidAndInTransaction();
@@ -1142,7 +1197,7 @@ public void insert(RealmModel object) {
 
     /**
      * Inserts or updates a list of unmanaged RealmObjects. This is generally faster than
-     * {@link #copyToRealmOrUpdate(Iterable)} since it doesn't return the inserted elements, and performs minimum
+     * {@link #copyToRealmOrUpdate(Iterable, ImportFlag...)} since it doesn't return the inserted elements, and performs minimum
      * allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      * <p>
@@ -1156,7 +1211,7 @@ public void insert(RealmModel object) {
      * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
      * </ul>
      * <p>
-     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable)}, otherwise if
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable, ImportFlag...)}, otherwise if
      * you have a large number of object this method is generally faster.
      *
      * @param objects RealmObjects to insert.
@@ -1164,7 +1219,7 @@ public void insert(RealmModel object) {
      * transaction.
      * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
      * inserted or if a primary key value already exists in the Realm.
-     * @see #copyToRealmOrUpdate(Iterable)
+     * @see #copyToRealmOrUpdate(Iterable, ImportFlag...)
      */
     public void insertOrUpdate(Collection<? extends RealmModel> objects) {
         checkIfValidAndInTransaction();
@@ -1180,7 +1235,7 @@ public void insertOrUpdate(Collection<? extends RealmModel> objects) {
 
     /**
      * Inserts or updates an unmanaged RealmObject. This is generally faster than
-     * {@link #copyToRealmOrUpdate(RealmModel)} since it doesn't return the inserted elements, and performs minimum
+     * {@link #copyToRealmOrUpdate(RealmModel, ImportFlag...)} since it doesn't return the inserted elements, and performs minimum
      * allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      * <p>
@@ -1194,13 +1249,13 @@ public void insertOrUpdate(Collection<? extends RealmModel> objects) {
      * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
      * </ul>
      * <p>
-     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel)}, otherwise if
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel, ImportFlag...)}, otherwise if
      * you have a large number of object this method is generally faster.
      *
      * @param object RealmObjects to insert.
      * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
      * transaction.
-     * @see #copyToRealmOrUpdate(RealmModel)
+     * @see #copyToRealmOrUpdate(RealmModel, ImportFlag...)
      */
     public void insertOrUpdate(RealmModel object) {
         checkIfValidAndInTransaction();
@@ -1221,11 +1276,12 @@ public void insertOrUpdate(RealmModel object) {
      * set to their default value if not provided.
      *
      * @param objects a list of objects to update or copy into Realm.
+     * @param flags any flag that modifies the behaviour of inserting the data into the Realm.
      * @return a list of all the new or updated RealmObjects.
      * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
-     * @see #copyToRealm(Iterable)
+     * @see #copyToRealm(Iterable, ImportFlag...)
      */
-    public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
+    public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects, ImportFlag... flags) {
         //noinspection ConstantConditions
         if (objects == null) {
             return new ArrayList<>(0);
@@ -1238,9 +1294,10 @@ public void insertOrUpdate(RealmModel object) {
             realmObjects = new ArrayList<>();
         }
         Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
+        Set<ImportFlag> importFlags = Util.toSet(flags);
         for (E object : objects) {
             checkNotNullObject(object);
-            realmObjects.add(copyOrUpdate(object, true, cache));
+            realmObjects.add(copyOrUpdate(object, true, cache, importFlags));
         }
 
         return realmObjects;
@@ -1254,14 +1311,15 @@ public void insertOrUpdate(RealmModel object) {
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using
-     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
-     * This includes references to other objects, and can potentially override changes made by other threads.
+     * {@link #copyToRealmOrUpdate(RealmModel, ImportFlag...)}, but all fields will be overridden, not just those that
+     * were changed. This includes references to other objects, and can potentially override changes made by other
+     * threads. This behaviour can be modified using {@link ImportFlag}s.
      *
      * @param realmObjects RealmObjects to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of managed RealmObjects.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
-     * @see #copyToRealmOrUpdate(Iterable)
+     * @see #copyToRealmOrUpdate(Iterable, ImportFlag...)
      */
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects) {
         return copyFromRealm(realmObjects, Integer.MAX_VALUE);
@@ -1275,9 +1333,10 @@ public void insertOrUpdate(RealmModel object) {
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using
-     * {@link #copyToRealmOrUpdate(Iterable)}, but all fields will be overridden, not just those that were changed.
+     * {@link #copyToRealmOrUpdate(Iterable, ImportFlag...)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
-     * reached. This can also potentially override changes made by other threads.
+     * reached. This can also potentially override changes made by other threads. This behaviour can be modified using
+     * {@link ImportFlag}s.
      *
      * @param realmObjects RealmObjects to copy.
      * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
@@ -1286,7 +1345,7 @@ public void insertOrUpdate(RealmModel object) {
      * @return an in-memory detached copy of the RealmObjects.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
      * {@link DynamicRealmObject}.
-     * @see #copyToRealmOrUpdate(Iterable)
+     * @see #copyToRealmOrUpdate(Iterable, ImportFlag...)
      */
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
         checkMaxDepth(maxDepth);
@@ -1318,14 +1377,15 @@ public void insertOrUpdate(RealmModel object) {
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using
-     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
+     * {@link #copyToRealmOrUpdate(RealmModel, ImportFlag...)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
+     * This behaviour can be modified using {@link ImportFlag}s.
      *
      * @param realmObject {@link RealmObject} to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
-     * @see #copyToRealmOrUpdate(RealmModel)
+     * @see #copyToRealmOrUpdate(RealmModel, ImportFlag...)
      */
     public <E extends RealmModel> E copyFromRealm(E realmObject) {
         return copyFromRealm(realmObject, Integer.MAX_VALUE);
@@ -1339,9 +1399,10 @@ public void insertOrUpdate(RealmModel object) {
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using
-     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
+     * {@link #copyToRealmOrUpdate(RealmModel, ImportFlag...)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
-     * reached. This can also potentially override changes made by other threads.
+     * reached. This can also potentially override changes made by other threads. This behaviour can be modified using
+     * {@link ImportFlag}s.
      *
      * @param realmObject {@link RealmObject} to copy.
      * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
@@ -1350,7 +1411,7 @@ public void insertOrUpdate(RealmModel object) {
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
      * {@link DynamicRealmObject}.
-     * @see #copyToRealmOrUpdate(RealmModel)
+     * @see #copyToRealmOrUpdate(RealmModel, ImportFlag...)
      */
     public <E extends RealmModel> E copyFromRealm(E realmObject, int maxDepth) {
         checkMaxDepth(maxDepth);
@@ -1630,9 +1691,22 @@ public void delete(Class<? extends RealmModel> clazz) {
 
 
     @SuppressWarnings("unchecked")
-    private <E extends RealmModel> E copyOrUpdate(E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
+    private <E extends RealmModel> E copyOrUpdate(E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {
         checkIfValid();
-        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache);
+        if (!isInTransaction()) {
+            throw new IllegalStateException("`copyOrUpdate` can only be called inside a write transaction.");
+        }
+        try {
+            return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache, flags);
+        } catch (IllegalStateException e) {
+            // See https://github.com/realm/realm-java/issues/6262
+            // For now we convert the OS exception using pattern matching on the error message.
+            if (e.getMessage().startsWith("Attempting to create an object of type")) {
+                throw new RealmPrimaryKeyConstraintException(e.getMessage());
+            } else {
+                throw e;
+            }
+        }
     }
 
     private <E extends RealmModel> E createDetachedCopy(E object, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 4642356f34..dbe8476d54 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -51,7 +51,7 @@
  * <p>
  * Unmanaged RealmLists can be created by the user and can contain both managed and unmanaged RealmObjects. This is
  * useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class.
- * Unmanaged elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
+ * Unmanaged elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable, ImportFlag...)} method.
  * <p>
  * {@link RealmList} can contain more elements than {@code Integer.MAX_VALUE}.
  * In that case, you can access only first {@code Integer.MAX_VALUE} elements in it.
@@ -80,7 +80,7 @@
      * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible to query
      * the objects in this state.
      * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
+     * Use {@link io.realm.Realm#copyToRealm(Iterable, ImportFlag...)} to properly persist its elements in Realm.
      */
     public RealmList() {
         realm = null;
@@ -93,7 +93,7 @@ public RealmList() {
      * A RealmList in unmanaged mode function as a {@link java.util.ArrayList} and it is not possible to query the
      * objects in this state.
      * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all unmanaged elements in Realm.
+     * Use {@link io.realm.Realm#copyToRealm(Iterable, ImportFlag...)} to properly persist all unmanaged elements in Realm.
      *
      * @param objects initial objects in the list.
      */
@@ -165,10 +165,10 @@ private boolean isAttached() {
      * <ol>
      * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
      * objects to an unmanaged RealmList they will not be copied to the Realm again if using
-     * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
+     * {@link Realm#copyToRealm(RealmModel, ImportFlag...)} afterwards.</li>
      * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
-     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
-     * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel, ImportFlag...)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmModel, ImportFlag...)} if it has a primary key.</li>
      * </ol>
      *
      * @param location the index at which to insert.
@@ -193,10 +193,10 @@ public void add(int location, @Nullable E element) {
      * <ol>
      * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
      * objects to an unmanaged RealmList they will not be copied to the Realm again if using
-     * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
+     * {@link Realm#copyToRealm(RealmModel, ImportFlag...)} afterwards.</li>
      * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
-     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
-     * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel, ImportFlag...)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmModel, ImportFlag...)} if it has a primary key.</li>
      * </ol>
      *
      * @param object the object to add.
@@ -220,10 +220,10 @@ public boolean add(@Nullable E object) {
      * <ol>
      * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
      * objects to an unmanaged RealmList they will not be copied to the Realm again if using
-     * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
+     * {@link Realm#copyToRealm(RealmModel, ImportFlag...)} afterwards.</li>
      * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed.
-     * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
-     * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
+     * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel, ImportFlag...)} or
+     * {@link Realm#copyToRealmOrUpdate(RealmModel, ImportFlag...)} if it has a primary key.</li>
      * </ol>
      *
      * @param location the index at which to put the specified object.
@@ -1220,7 +1220,7 @@ public void set(@Nullable E e) {
 
         /**
          * Adding a new object to the RealmList. If the object is not already manage by Realm it will be transparently
-         * copied using {@link Realm#copyToRealmOrUpdate(RealmModel)}
+         * copied using {@link Realm#copyToRealmOrUpdate(RealmModel, ImportFlag...)}
          *
          * @see #add(Object)
          */
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 06b79e8dfd..6058bca55e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -65,7 +65,7 @@
  * A RealmObject cannot be passed between different threads.
  *
  * @see Realm#createObject(Class)
- * @see Realm#copyToRealm(RealmModel)
+ * @see Realm#copyToRealm(RealmModel, ImportFlag...)
  */
 
 @RealmClass
@@ -259,7 +259,7 @@ public final boolean isLoaded() {
      * <p>
      * <p>
      * It is possible to create a managed object from an unmanaged object by using
-     * {@link Realm#copyToRealm(RealmModel)}. An unmanaged object can be created from a managed object by using
+     * {@link Realm#copyToRealm(RealmModel, ImportFlag...)}. An unmanaged object can be created from a managed object by using
      * {@link Realm#copyFromRealm(RealmModel)}.
      *
      * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
@@ -283,7 +283,7 @@ public boolean isManaged() {
      * <p>
      * <p>
      * It is possible to create a managed object from an unmanaged object by using
-     * {@link Realm#copyToRealm(RealmModel)}. An unmanaged object can be created from a managed object by using
+     * {@link Realm#copyToRealm(RealmModel, ImportFlag...)}. An unmanaged object can be created from a managed object by using
      * {@link Realm#copyFromRealm(RealmModel)}.
      *
      * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index d2562ab97a..a1df724e0d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -55,10 +55,8 @@
 
     /**
      * Initializes the Object Server library
-     *
-     * @param context
      */
-    public void init(Context context) {
+    public void init(Context context, String userAgent) {
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
index cac92e21df..9f9e6f3b2a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -185,6 +185,14 @@ public Property getProperty(String propertyName) {
         return propertyPtr == 0 ? null : new Property(nativeGetPrimaryKeyProperty(nativePtr));
     }
 
+    /**
+     * Returns the maximum table index used by core for this schema.
+     * If this Object has no properties -1 is returned.
+     */
+    public long getMaxColumnIndex() {
+        return nativeGetMaxColumnIndex(nativePtr);
+    }
+
     @Override
     public long getNativePtr() {
         return nativePtr;
@@ -209,4 +217,7 @@ public long getNativeFinalizerPtr() {
 
     // Return nullptr if it doesn't have a primary key.
     private static native long nativeGetPrimaryKeyProperty(long nativePtr);
+
+    private static native long nativeGetMaxColumnIndex(long nativePtr);
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
index e9be90c80e..d05d5cfa60 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
@@ -141,7 +141,7 @@ public int hashCode() {
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     private final long nativePtr;
     private final OsRealmConfig osRealmConfig;
-    final NativeContext context;
+    public final NativeContext context;
     private final OsSchemaInfo schemaInfo;
     private static volatile File temporaryDirectory;
     // JNI will only hold a weak global ref to this.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 58db9cfe46..fc28b88e67 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -26,6 +26,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import io.realm.ImportFlag;
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
@@ -114,12 +115,13 @@ public final String getSimpleClassName(Class<? extends RealmModel> clazz) {
      * @param update {@code true} if object has a primary key and should try to update already existing data,
      * {@code false} otherwise.
      * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
+     * @param flags any special flags controlling the behaviour of the import.
      * @return the managed Realm object.
      */
-    public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
+    public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags);
 
     /**
-     * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
+     * Inserts an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map, Set)}
      * since it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      *
@@ -130,7 +132,7 @@ public final String getSimpleClassName(Class<? extends RealmModel> clazz) {
     public abstract void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
 
     /**
-     * Inserts or updates a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
+     * Inserts or updates a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map, Set)}
      * since it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original object will not be persisted.
      *
@@ -141,7 +143,7 @@ public final String getSimpleClassName(Class<? extends RealmModel> clazz) {
     public abstract void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
 
     /**
-     * Inserts or updates a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)}
+     * Inserts or updates a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map, Set)}
      * since it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      *
@@ -151,7 +153,7 @@ public final String getSimpleClassName(Class<? extends RealmModel> clazz) {
     public abstract void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects);
 
     /**
-     * Inserts a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since
+     * Inserts a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map, Set)} since
      * it doesn't return the inserted elements, and performs minimum allocations and checks.
      * After being inserted any changes to the original objects will not be persisted.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 063e580c75..499d4d201e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -354,7 +354,7 @@ public static void throwDuplicatePrimaryKeyException(Object value) {
     // Getters
     //
 
-    OsSharedRealm getSharedRealm() {
+    public OsSharedRealm getSharedRealm() {
         return sharedRealm;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index c7e035b89c..c35ef9a3bc 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -39,7 +39,7 @@
     private final Table parent;
     private final long nativePtr;
 
-    UncheckedRow(NativeContext context, Table parent, long nativePtr) {
+    public UncheckedRow(NativeContext context, Table parent, long nativePtr) {
         this.context = context;
         this.parent = parent;
         this.nativePtr = nativePtr;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 2e99d61680..e9ef4d800a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -22,12 +22,17 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
+import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.annotation.Nullable;
 
+import io.realm.ImportFlag;
 import io.realm.RealmConfiguration;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
@@ -147,4 +152,23 @@ public static boolean deleteRealm(String canonicalPath, File realmFolder, String
         }
         return realmDeleted;
     }
+
+    /**
+     * Converts a var arg argument list to a set ignoring any duplicates and null values.
+     */
+    public static <T> Set<T> toSet(T... items) {
+        //noinspection ConstantConditions
+        if (items == null) {
+            return Collections.emptySet();
+        } else {
+            Set<T> set = new LinkedHashSet<>();
+            for (int i = 0; i < items.length; i++) {
+                T item = items[i];
+                if (item != null) {
+                    set.add(item);
+                }
+            }
+            return set;
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 88fa860c3e..b95207f4d6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import io.realm.ImportFlag;
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.exceptions.RealmException;
@@ -116,9 +117,9 @@ protected String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {
         RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
-        return mediator.copyOrUpdate(realm, object, update, cache);
+        return mediator.copyOrUpdate(realm, object, update, cache, flags);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index b3ec7decb9..ceb23d7c05 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -30,6 +30,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import io.realm.ImportFlag;
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
@@ -114,9 +115,9 @@ protected String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
+    public <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache, Set<ImportFlag> flags) {
         checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
-        return originalMediator.copyOrUpdate(realm, object, update, cache);
+        return originalMediator.copyOrUpdate(realm, object, update, cache, flags);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java b/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java
new file mode 100644
index 0000000000..a5ed0f3c82
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java
@@ -0,0 +1,415 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.objectstore;
+
+import java.util.Date;
+import java.util.List;
+import java.util.Set;
+
+import io.realm.ImportFlag;
+import io.realm.MutableRealmInteger;
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.internal.NativeContext;
+import io.realm.internal.OsSharedRealm;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
+
+/**
+ * This class is a wrapper around building up object data for calling `Object::create()`
+ * <p>
+ * Fill the object data by calling the various `addX()` methods, then create a new Object or update
+ * an existing one by calling {@link #createNewObject()} or {@link #updateExistingObject()}.
+ * <p>
+ * This class assumes it is only being used from within a write transaction. Using it outside one
+ * will result in undefined behaviour.
+ * <p>
+ * The native
+ * resources are created in the constructor of this class and destroyed when calling either of the
+ * above two methods.
+ * <p>
+ * <H1>Design thoughts</H1>
+ * <p>
+ * Ideally we would have sent all properties across in one JNI call, but the only way to do that would
+ * have been using two `Object[]` arrays which would have resulted in a ton of JNI calls back
+ * again for resolving the primitive values of boxed types (since JNI do not know about boxed
+ * primitives).
+ * <p>
+ * The upside of making a JNI call for each property is that we do minimal allocations on the Java
+ * side. Also each method call is fairly lightweight as no checks are performed compared to using
+ * Proxy setters and {@link io.realm.internal.UncheckedRow}. The only downside is the current need for
+ * sending the key as well. Hopefully we can change that to schema indices at some point.
+ * <p>
+ * There is quite a few variants we can attempt to optimize this, but at this point we lack data
+ * that can guide any architectural design and the only way to really find out is to build out each
+ * solution and benchmark it.
+ */
+public class OsObjectBuilder {
+
+    private final Table table;
+    private final long sharedRealmPtr;
+    private final long builderPtr;
+    private final long tablePtr;
+    private final NativeContext context;
+
+    private static ItemCallback<? extends RealmModel> objectItemCallback = new ItemCallback<RealmModel>() {
+        @Override
+        public void handleItem(long listPtr, RealmModel item) {
+            RealmObjectProxy proxyItem = (RealmObjectProxy) item;
+            nativeAddIntegerListItem(listPtr, ((UncheckedRow) proxyItem.realmGet$proxyState().getRow$realm()).getNativePtr());
+        }
+    };
+
+    private static ItemCallback<String> stringItemCallback = new ItemCallback<String>() {
+        @Override
+        public void handleItem(long listPtr, String item) {
+            nativeAddStringListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Byte> byteItemCallback = new ItemCallback<Byte>() {
+        @Override
+        public void handleItem(long listPtr, Byte item) {
+            nativeAddIntegerListItem(listPtr, item.longValue());
+        }
+    };
+
+    private static ItemCallback<Short> shortItemCallback = new ItemCallback<Short>() {
+        @Override
+        public void handleItem(long listPtr, Short item) {
+            nativeAddIntegerListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Integer> integerItemCallback = new ItemCallback<Integer>() {
+        @Override
+        public void handleItem(long listPtr, Integer item) {
+            nativeAddIntegerListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Long> longItemCallback = new ItemCallback<Long>() {
+        @Override
+        public void handleItem(long listPtr, Long item) {
+            nativeAddIntegerListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Boolean> booleanItemCallback = new ItemCallback<Boolean>() {
+        @Override
+        public void handleItem(long listPtr, Boolean item) {
+            nativeAddBooleanListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Float> floatItemCallback = new ItemCallback<Float>() {
+        @Override
+        public void handleItem(long listPtr, Float item) {
+            nativeAddFloatListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Double> doubleItemCallback = new ItemCallback<Double>() {
+        @Override
+        public void handleItem(long listPtr, Double item) {
+            nativeAddDoubleListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<Date> dateItemCallback = new ItemCallback<Date>() {
+        @Override
+        public void handleItem(long listPtr, Date item) {
+            nativeAddDateListItem(listPtr, item.getTime());
+        }
+    };
+
+    private static ItemCallback<byte[]> byteArrayItemCallback = new ItemCallback<byte[]>() {
+        @Override
+        public void handleItem(long listPtr, byte[] item) {
+            nativeAddByteArrayListItem(listPtr, item);
+        }
+    };
+
+    private static ItemCallback<MutableRealmInteger> mutableRealmIntegerItemCallback = new ItemCallback<MutableRealmInteger>() {
+        @Override
+        public void handleItem(long listPtr, MutableRealmInteger item) {
+            Long value = item.get();
+            if (value == null) {
+                nativeAddNullListItem(listPtr);
+            } else {
+                nativeAddIntegerListItem(listPtr, value);
+            }
+        }
+    };
+
+    // If true, fields will not be updated if the same value would be written to it.
+    private final boolean ignoreFieldsWithSameValue;
+
+    public OsObjectBuilder(Table table, long maxColumnIndex, Set<ImportFlag> flags) {
+        OsSharedRealm sharedRealm = table.getSharedRealm();
+        this.sharedRealmPtr = sharedRealm.getNativePtr();
+        this.table = table;
+        this.tablePtr = table.getNativePtr();
+        this.builderPtr = nativeCreateBuilder(maxColumnIndex + 1);
+        this.context = sharedRealm.context;
+        this.ignoreFieldsWithSameValue = flags.contains(ImportFlag.CHECK_SAME_VALUES_BEFORE_SET);
+    }
+
+    public void addInteger(long columnIndex, Byte val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddInteger(builderPtr, columnIndex, val);
+        }
+                                                    }
+
+    public void addInteger(long columnIndex, Short val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddInteger(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addInteger(long columnIndex, Integer val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddInteger(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addInteger(long columnIndex, Long val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddInteger(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addMutableRealmInteger(long columnIndex, MutableRealmInteger val) {
+        if (val == null || val.get() == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddInteger(builderPtr, columnIndex, val.get());
+        }
+    }
+
+    public void addString(long columnIndex, String val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddString(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addFloat(long columnIndex, Float val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddFloat(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addDouble(long columnIndex, Double val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddDouble(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addBoolean(long columnIndex, Boolean val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddBoolean(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addDate(long columnIndex, Date val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddDate(builderPtr, columnIndex, val.getTime());
+        }
+    }
+
+    public void addByteArray(long columnIndex, byte[] val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            nativeAddByteArray(builderPtr, columnIndex, val);
+        }
+    }
+
+    public void addNull(long columnIndex) {
+        nativeAddNull(builderPtr, columnIndex);
+    }
+
+    public void addObject(long columnIndex, RealmModel val) {
+        if (val == null) {
+            nativeAddNull(builderPtr, columnIndex);
+        } else {
+            RealmObjectProxy proxy = (RealmObjectProxy) val;
+            UncheckedRow row = (UncheckedRow) proxy.realmGet$proxyState().getRow$realm();
+            nativeAddObject(builderPtr, columnIndex, row.getNativePtr());
+        }
+    }
+
+    private <T> void addListItem(long builderPtr, long columnIndex, List<T> list, ItemCallback<T> itemCallback) {
+        if (list != null) {
+            long listPtr = nativeStartList(list.size());
+            for (int i = 0; i < list.size(); i++) {
+                T item = list.get(i);
+                if (item == null) {
+                    nativeAddNullListItem(listPtr);
+                } else {
+                    itemCallback.handleItem(listPtr, item);
+                }
+            }
+            nativeStopList(builderPtr, columnIndex, listPtr);
+        } else {
+            addEmptyList(columnIndex);
+        }
+    }
+
+    public <T extends RealmModel> void addObjectList(long columnIndex, RealmList<T> list) {
+        // Null objects references are not allowed. So we can optimize the JNI boundary by
+        // sending all object references in one long[] array.
+        if (list != null) {
+            long[] rowPointers = new long[list.size()];
+            for (int i = 0; i < list.size(); i++) {
+                RealmObjectProxy item = (RealmObjectProxy) list.get(i);
+                if (item == null) {
+                    throw new IllegalArgumentException("Null values are not allowed in RealmLists containing Realm models");
+                } else {
+                    rowPointers[i] = ((UncheckedRow) item.realmGet$proxyState().getRow$realm()).getNativePtr();
+                }
+            }
+            nativeAddObjectList(builderPtr, columnIndex, rowPointers);
+        } else {
+            nativeAddObjectList(builderPtr, columnIndex, new long[0]);
+        }
+    }
+
+    public void addStringList(long columnIndex, RealmList<String> list) {
+        addListItem(builderPtr, columnIndex, list, stringItemCallback);
+    }
+
+    public void addByteList(long columnIndex, RealmList<Byte> list) {
+        addListItem(builderPtr, columnIndex, list, byteItemCallback);
+    }
+
+    public void addShortList(long columnIndex, RealmList<Short> list) {
+        addListItem(builderPtr, columnIndex, list, shortItemCallback);
+    }
+
+    public void addIntegerList(long columnIndex, RealmList<Integer> list) {
+        addListItem(builderPtr, columnIndex, list, integerItemCallback);
+    }
+
+    public void addLongList(long columnIndex, RealmList<Long> list) {
+        addListItem(builderPtr, columnIndex, list, longItemCallback);
+    }
+
+    public void addBooleanList(long columnIndex, RealmList<Boolean> list) {
+        addListItem(builderPtr, columnIndex, list, booleanItemCallback);
+    }
+
+    public void addFloatList(long columnIndex, RealmList<Float> list) {
+        addListItem(builderPtr, columnIndex, list, floatItemCallback);
+    }
+
+    public void addDoubleList(long columnIndex, RealmList<Double> list) {
+        addListItem(builderPtr, columnIndex, list, doubleItemCallback);
+    }
+
+    public void addDateList(long columnIndex, RealmList<Date> list) {
+        addListItem(builderPtr, columnIndex, list, dateItemCallback);
+    }
+
+    public void addByteArrayList(long columnIndex, RealmList<byte[]> list) {
+        addListItem(builderPtr, columnIndex, list, byteArrayItemCallback);
+    }
+
+    public void addMutableRealmIntegerList(long columnIndex, RealmList<MutableRealmInteger> list) {
+        addListItem(builderPtr, columnIndex, list, mutableRealmIntegerItemCallback);
+    }
+
+    private void addEmptyList(long columnIndex) {
+        long listPtr = nativeStartList(0);
+        nativeStopList(builderPtr, columnIndex, listPtr);
+    }
+
+    public void updateExistingObject() {
+        try {
+            nativeCreateOrUpdate(sharedRealmPtr, tablePtr, builderPtr, true, ignoreFieldsWithSameValue);
+        } finally {
+            nativeDestroyBuilder(builderPtr);
+        }
+    }
+
+    public UncheckedRow createNewObject() {
+        UncheckedRow row;
+        try {
+            long rowPtr = nativeCreateOrUpdate(sharedRealmPtr, tablePtr, builderPtr, false, false);
+            row = new UncheckedRow(context, table, rowPtr);
+        } finally {
+            nativeDestroyBuilder(builderPtr);
+        }
+        return row;
+    }
+
+    private interface ItemCallback<T>  {
+        void handleItem(long listPtr, T item);
+    }
+
+    private static native long nativeCreateBuilder(long size);
+    private static native void nativeDestroyBuilder(long builderPtr);
+    private static native long nativeCreateOrUpdate(long sharedRealmPtr,
+                                                    long tablePtr,
+                                                    long builderPtr,
+                                                    boolean updateExistingObject,
+                                                    boolean ignoreFieldsWithSameValue);
+
+    // Add simple properties
+    private static native void nativeAddNull(long builderPtr, long columnIndex);
+    private static native void nativeAddInteger(long builderPtr, long columnIndex, long val);
+    private static native void nativeAddString(long builderPtr, long columnIndex, String val);
+    private static native void nativeAddFloat(long builderPtr, long columnIndex, float val);
+    private static native void nativeAddDouble(long builderPtr, long columnIndex, double val);
+    private static native void nativeAddBoolean(long builderPtr, long columnIndex, boolean val);
+    private static native void nativeAddByteArray(long builderPtr, long columnIndex, byte[] val);
+    private static native void nativeAddDate(long builderPtr, long columnIndex, long val);
+    private static native void nativeAddObject(long builderPtr, long columnIndex, long rowPtr);
+
+    // Methods for adding lists
+    // Lists sent across JNI one element at a time
+    private static native long nativeStartList(long size);
+    private static native void nativeStopList(long builderPtr, long columnIndex, long listPtr);
+    private static native void nativeAddNullListItem(long listPtr);
+    private static native void nativeAddIntegerListItem(long listPtr, long value);
+    private static native void nativeAddStringListItem(long listPtr, String val);
+    private static native void nativeAddFloatListItem(long listPtr, float val);
+    private static native void nativeAddDoubleListItem(long listPtr, double val);
+    private static native void nativeAddBooleanListItem(long listPtr, boolean val);
+    private static native void nativeAddByteArrayListItem(long listPtr, byte[] val);
+    private static native void nativeAddDateListItem(long listPtr, long val);
+    private static native void nativeAddObjectListItem(long listPtr, long rowPtr);
+    private static native void nativeAddObjectList(long builderPtr, long columnIndex, long[] rowPtrs);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
index 401a01f9af..4249445439 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -18,12 +18,15 @@
 
 import android.content.Context;
 import android.content.pm.PackageInfo;
+import android.os.Build;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.Locale;
 
 import io.realm.internal.Keep;
+import io.realm.internal.Util;
+import io.realm.log.RealmLog;
 
 /**
  * Internal initializer class for the Object Server.
@@ -33,7 +36,7 @@
 @Keep
 class ObjectServer {
 
-    public static void init(Context context) {
+    public static void init(Context context, String appDefinedUserAgent) {
         // Setup AppID
         String appId = "unknown";
         try {
@@ -42,6 +45,31 @@ public static void init(Context context) {
         } catch (Exception ignore) {
         }
 
+        // Setup Realm part of User-Agent string
+        String userAgent = "Unknown"; // Fallback in case of anything going wrong
+        try {
+            StringBuilder sb = new StringBuilder();
+            sb.append("RealmJava/");
+            sb.append(BuildConfig.VERSION_NAME);
+            sb.append(" (");
+            sb.append(Util.isEmptyString(Build.DEVICE) ? "unknown-device" : Build.DEVICE);
+            sb.append(", ");
+            sb.append(Util.isEmptyString(Build.MODEL) ? "unknown-model" : Build.MODEL);
+            sb.append(", v");
+            sb.append(Build.VERSION.SDK_INT);
+            sb.append(")");
+
+            // Setup User part of User-Agent string
+            if (!Util.isEmptyString(appDefinedUserAgent)) {
+                sb.append(" ");
+                sb.append(appDefinedUserAgent);
+            }
+            userAgent = sb.toString();
+        } catch (Exception e) {
+            // Failures to construct the user agent should never cause the system itself to crash.
+            RealmLog.warn("Constructing User-Agent description failed.", e);
+        }
+
         // init the "sync_manager.cpp" metadata Realm, this is also needed later, when re try
         // to schedule a client reset. in realm-java#master this is already done, when initialising
         // the RealmFileUserStore (not available now on releases)
@@ -59,12 +87,12 @@ public static void init(Context context) {
                             "Directory '%s' for SyncManager cannot be created. ",
                             dir.getPath()));
                 }
-                SyncManager.nativeInitializeSyncManager(dir.getPath());
+                SyncManager.nativeInitializeSyncManager(dir.getPath(), userAgent);
             } catch (IOException e) {
                 throw new IllegalStateException(e);
             }
         } else {
-            SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath());
+            SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath(), userAgent);
         }
 
         // Configure default UserStore
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index a2ccd4363f..ed437ef308 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -27,9 +27,8 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.LinkedHashMap;
 import java.util.Locale;
-import java.util.Map;
+import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -111,6 +110,7 @@
     @Nullable private final String serverCertificateAssetName;
     @Nullable private final String serverCertificateFilePath;
     private final boolean waitForInitialData;
+    private final long initialDataTimeoutMillis;
     private final OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy;
     private final boolean isPartial;
     @Nullable private final String syncUrlPrefix;
@@ -136,6 +136,7 @@ private SyncConfiguration(File directory,
                               @Nullable String serverCertificateAssetName,
                               @Nullable String serverCertificateFilePath,
                               boolean waitForInitialData,
+                              long initialDataTimeoutMillis,
                               OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy,
                               boolean isPartial,
                               CompactOnLaunchCallback compactOnLaunch,
@@ -165,6 +166,7 @@ private SyncConfiguration(File directory,
         this.serverCertificateAssetName = serverCertificateAssetName;
         this.serverCertificateFilePath = serverCertificateFilePath;
         this.waitForInitialData = waitForInitialData;
+        this.initialDataTimeoutMillis = initialDataTimeoutMillis;
         this.sessionStopPolicy = sessionStopPolicy;
         this.isPartial = isPartial;
         this.syncUrlPrefix = syncUrlPrefix;
@@ -408,6 +410,18 @@ public boolean shouldWaitForInitialRemoteData() {
         return waitForInitialData;
     }
 
+    /**
+     * Returns the timeout defined when downloading any initial data the first time the Realm is opened.
+     * <p>
+     * This value is only applicable if {@link #shouldWaitForInitialRemoteData()} returns {@code true}.
+     *
+     * @return the time Realm will wait for all changes to be downloaded before it is aborted and an exception is thrown.
+     * @see SyncConfiguration.Builder#waitForInitialRemoteData(long, TimeUnit)
+     */
+    public long getInitialRemoteDataTimeout(TimeUnit unit) {
+        return unit.convert(initialDataTimeoutMillis, TimeUnit.MILLISECONDS);
+    }
+
     @Override
     boolean isSyncConfiguration() {
         return true;
@@ -479,6 +493,7 @@ public String getUrlPrefix() {
         private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
         private boolean readOnly = false;
         private boolean waitForServerChanges = false;
+        private long initialDataTimeoutMillis = Long.MAX_VALUE;
         // sync specific
         private boolean deleteRealmOnLogout = false;
         private URI serverUrl;
@@ -928,7 +943,7 @@ public Builder disableSSLVerification() {
             return this;
         }
 
-        /*
+        /**
          * Setting this will cause the Realm to download all known changes from the server the first time a Realm is
          * opened. The Realm will not open until all the data has been downloaded. This means that if a device is
          * offline the Realm will not open.
@@ -942,6 +957,35 @@ public Builder disableSSLVerification() {
          */
         public Builder waitForInitialRemoteData() {
             this.waitForServerChanges = true;
+            this.initialDataTimeoutMillis = Long.MAX_VALUE;
+            return this;
+        }
+
+        /**
+         * Setting this will cause the Realm to download all known changes from the server the first time a Realm is
+         * opened. The Realm will not open until all the data has been downloaded. This means that if a device is
+         * offline the Realm will not open.
+         * <p>
+         * Since downloading all changes can be an lengthy operation that might block the UI thread, Realms with this
+         * setting enabled should only be opened on background threads or with
+         * {@link Realm#getInstanceAsync(RealmConfiguration, Realm.Callback)} on the UI thread.
+         * <p>
+         * This check is only enforced the first time a Realm is created. If you otherwise want to make sure a Realm
+         * has the latest changes, use {@link SyncSession#downloadAllServerChanges()}.
+         *
+         * @param timeout how long to wait for the download to complete before an {@link io.realm.exceptions.DownloadingRealmInterruptedException} is thrown.
+         * @param unit the unit of time used to define the timeout.
+         */
+        public Builder waitForInitialRemoteData(long timeout, TimeUnit unit) {
+            if (timeout < 0) {
+                throw new IllegalArgumentException("'timeout' must be >= 0. It was: " + timeout);
+            }
+            //noinspection ConstantConditions
+            if (unit == null) {
+                throw new IllegalArgumentException("Non-null 'unit' required");
+            }
+            this.waitForServerChanges = true;
+            this.initialDataTimeoutMillis = unit.toMillis(timeout);
             return this;
         }
 
@@ -1177,6 +1221,7 @@ public SyncConfiguration build() {
                     serverCertificateAssetName,
                     serverCertificateFilePath,
                     waitForServerChanges,
+                    initialDataTimeoutMillis,
                     sessionStopPolicy,
                     isPartial,
                     compactOnLaunch,
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 2c1b4c560a..15a7adaa7e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -344,7 +344,7 @@ public static synchronized void addCustomRequestHeader(String headerName, String
      *
      * @param headerName the name of the header.
      * @param headerValue the value of header.
-     * @param host if this is provided, the this header will only be used on this particular host.
+     * @param host if this is provided, this header will only be used on this particular host.
      *             Example of valid values: "localhost", "127.0.0.1" and "myinstance.us1.cloud.realm.io".
      * @throws IllegalArgumentException If an non-empty {@code headerName}, {@code headerValue} or {@code host} is provided.
      */
@@ -414,7 +414,6 @@ public static synchronized String getAuthorizationHeaderName(URI objectServerUrl
      * Returns all the custom headers added to requests to the given url.
      *
      * @return all defined custom headers used when making http requests to the given url.
-     * f
      */
     public static synchronized Map<String, String> getCustomRequestHeaders(URI serverSyncUrl) {
         Map<String, String> headers = new LinkedHashMap<>(globalCustomHeaders);
@@ -749,7 +748,7 @@ static void simulateClientReset(SyncSession session) {
                 true);
     }
 
-    protected static native void nativeInitializeSyncManager(String syncBaseDir);
+    protected static native void nativeInitializeSyncManager(String syncBaseDir, String userAgent);
     private static native void nativeReset();
     private static native void nativeSimulateSyncError(String realmPath, int errorCode, String errorMessage, boolean isFatal);
     private static native void nativeReconnect();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 08cfd937e2..d98d49df83 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -481,7 +481,35 @@ public void downloadAllServerChanges() throws InterruptedException {
         // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
         // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
         synchronized (waitForChangesMutex) {
-            waitForChanges(DIRECTION_DOWNLOAD);
+            waitForChanges(DIRECTION_DOWNLOAD, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    /**
+     * Calling this method will block until all known remote changes have been downloaded and applied to the Realm
+     * or the specified timeout is hit. This will involve network access, so calling this method should only be done
+     * from a non-UI thread.
+     * <p>
+     * This method cannot be called before the Realm has been opened.
+     *
+     * @throws IllegalStateException if called on the Android main thread.
+     * @throws InterruptedException if the download took longer than the specified timeout or the thread was interrupted while downloading was in progress.
+     * The download will continue in the background even after this exception is thrown.
+     * @throws IllegalArgumentException if {@code timeout} is less than or equal to {@code 0} or {@code unit} is {@code null}.
+     * @return {@code true} if the data was downloaded before the timeout. {@code false} if the operation timed out or otherwise failed.
+     */
+    public boolean downloadAllServerChanges(long timeout, TimeUnit unit) throws InterruptedException {
+        checkIfNotOnMainThread("downloadAllServerChanges() cannot be called from the main thread.");
+        checkTimeout(timeout, unit);
+
+        // Blocking only happens at the Java layer. To prevent deadlocking the underlying SyncSession we register
+        // an async listener there and let it callback to the Java Session when done. This feels icky at best, but
+        // since all operations on the SyncSession operate under a shared mutex, we would prevent all other actions on the
+        // session, including trying to stop it.
+        // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
+        // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
+        synchronized (waitForChangesMutex) {
+            return waitForChanges(DIRECTION_DOWNLOAD, timeout, unit);
         }
     }
 
@@ -491,7 +519,7 @@ public void downloadAllServerChanges() throws InterruptedException {
      * <p>
      * If the device is offline, this method might never return.
      * <p>
-     * This method cannot be called before the session has been started.
+     * This method cannot be called before the Realm has been opened.
      *
      * @throws IllegalStateException if called on the Android main thread.
      * @throws InterruptedException if the thread was interrupted while downloading was in progress.
@@ -506,7 +534,35 @@ public void uploadAllLocalChanges() throws InterruptedException {
         // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
         // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
         synchronized (waitForChangesMutex) {
-            waitForChanges(DIRECTION_UPLOAD);
+            waitForChanges(DIRECTION_UPLOAD, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    /**
+     * Calling this method will block until all known local changes have been uploaded to the server or the specified
+     * timeout is hit. This will involve network access, so calling this method should only be done from a non-UI
+     * thread.
+     * <p>
+     * This method cannot be called before the Realm has been opened.
+     *
+     * @throws IllegalStateException if called on the Android main thread.
+     * @throws InterruptedException if the upload took longer than the specified timeout or the thread was interrupted while uploading was in progress.
+     * The upload will continue in the background even after this exception is thrown.
+     * @throws IllegalArgumentException if {@code timeout} is less than or equal to {@code 0} or {@code unit} is {@code null}.
+     * @return {@code true} if the data was uploaded before the timeout. {@code false} if the operation timed out or otherwise failed.
+     */
+    public boolean uploadAllLocalChanges(long timeout, TimeUnit unit) throws InterruptedException {
+        checkIfNotOnMainThread("uploadAllLocalChanges() cannot be called from the main thread.");
+        checkTimeout(timeout, unit);
+
+        // Blocking only happens at the Java layer. To prevent deadlocking the underlying SyncSession we register
+        // an async listener there and let it callback to the Java Session when done. This feels icky at best, but
+        // since all operations on the SyncSession operate under a shared mutex, we would prevent all other actions on the
+        // session, including trying to stop it.
+        // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
+        // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
+        synchronized (waitForChangesMutex) {
+            return waitForChanges(DIRECTION_UPLOAD, timeout, unit);
         }
     }
 
@@ -549,12 +605,16 @@ void setResolvedRealmURI(URI resolvedRealmURI) {
      * This method should only be called when guarded by the {@link #waitForChangesMutex}.
      * It will block into all changes have been either uploaded or downloaded depending on the chosen direction.
      *
-     * @param direction either {@link #DIRECTION_DOWNLOAD} or {@link #DIRECTION_UPLOAD}
+     * @param direction either {@link #DIRECTION_DOWNLOAD} or {@link #DIRECTION_UPLOAD}.
+     * @param timeout timeout parameter.
+     * @param unit timeout unit.
+     * @return {@code true} if the job completed before the timeout was hit, {@code false}
      */
-    private void waitForChanges(int direction) throws InterruptedException {
+    private boolean waitForChanges(int direction, long timeout, TimeUnit unit) throws InterruptedException {
         if (direction != DIRECTION_DOWNLOAD && direction != DIRECTION_UPLOAD) {
             throw new IllegalArgumentException("Unknown direction: " + direction);
         }
+        boolean result = false;
         if (!isClosed) {
             String realmPath = configuration.getPath();
             WaitForSessionWrapper wrapper = new WaitForSessionWrapper();
@@ -565,7 +625,7 @@ private void waitForChanges(int direction) throws InterruptedException {
                     : nativeWaitForUploadCompletion(callbackId, realmPath);
             if (!listenerRegistered) {
                 waitingForServerChanges.set(null);
-                String errorMsg = "";
+                String errorMsg;
                 switch (direction) {
                     case DIRECTION_DOWNLOAD: errorMsg = "It was not possible to download all remote changes."; break;
                     case DIRECTION_UPLOAD: errorMsg = "It was not possible upload all local changes."; break;
@@ -576,7 +636,7 @@ private void waitForChanges(int direction) throws InterruptedException {
                 throw new ObjectServerError(ErrorCode.UNKNOWN, errorMsg + " Has the SyncClient been started?");
             }
             try {
-                wrapper.waitForServerChanges();
+                result = wrapper.waitForServerChanges(timeout, unit);
             } catch(InterruptedException e) {
                 waitingForServerChanges.set(null); // Ignore any results being sent if the wait was interrupted.
                 throw e;
@@ -593,6 +653,7 @@ private void waitForChanges(int direction) throws InterruptedException {
                 waitingForServerChanges.set(null);
             }
         }
+        return result;
     }
 
     private void checkIfNotOnMainThread(String errorMessage) {
@@ -601,6 +662,16 @@ private void checkIfNotOnMainThread(String errorMessage) {
         }
     }
 
+    private void checkTimeout(long timeout, TimeUnit unit) {
+        if (timeout <= 0) {
+            throw new IllegalArgumentException("'timeout' must be > 0. It was: " + timeout);
+        }
+        //noinspection ConstantConditions
+        if (unit == null) {
+            throw new IllegalArgumentException("Non-null 'unit' required");
+        }
+    }
+
     private void checkNonNullListener(@Nullable Object listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Non-null 'listener' required.");
@@ -844,12 +915,14 @@ void clearScheduledAccessTokenRefresh() {
         private String errorMessage;
 
         /**
-         * Block until the wait either completes or is terminated for other reasons.
+         * Block until the wait either completes, timeouts or is terminated for other reasons.
+         * Timeouts are only applied if `timeout` >= 0.
          */
-        public void waitForServerChanges() throws InterruptedException {
+        public boolean waitForServerChanges(long timeout, TimeUnit unit) throws InterruptedException {
             if (!resultReceived) {
-                waiter.await();
+                return waiter.await(timeout, unit);
             }
+            return isSuccess();
         }
 
         /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index 0de162bcc1..c9febaefc9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -25,6 +25,7 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
@@ -50,16 +51,16 @@
     private static volatile Method removeSessionMethod;
 
     @Override
-    public void init(Context context) {
+    public void init(Context context, String userAgent) {
         // Trying to keep things out the public API is no fun :/
         // Just use reflection on init. It is a one-time method call so should be acceptable.
         //noinspection TryWithIdenticalCatches
         try {
             // FIXME: Reflection can be avoided by moving some functions of SyncManager and ObjectServer out of public
             Class<?> syncManager = Class.forName("io.realm.ObjectServer");
-            Method method = syncManager.getDeclaredMethod("init", Context.class);
+            Method method = syncManager.getDeclaredMethod("init", Context.class, String.class);
             method.setAccessible(true);
-            method.invoke(null, context);
+            method.invoke(null, context, userAgent);
         } catch (NoSuchMethodException e) {
             throw new RealmException("Could not initialize the Realm Object Server", e);
         } catch (InvocationTargetException e) {
@@ -183,14 +184,25 @@ public void downloadInitialRemoteChanges(RealmConfiguration config) {
             if (syncConfig.shouldWaitForInitialRemoteData()) {
                 SyncSession session = SyncManager.getSession(syncConfig);
                 try {
+                    long timeoutMillis = syncConfig.getInitialRemoteDataTimeout(TimeUnit.MILLISECONDS);
                     if (!syncConfig.isFullySynchronizedRealm()) {
                         // For Query-based Realms we want to upload all our local changes
                         // first since those might include subscriptions the server needs to process.
-                        // This means that once `downloadAllServerChanges` completes all
-                        // initial subscriptions will also have been downloaded.
-                        session.uploadAllLocalChanges();
+                        // This means that once `downloadAllServerChanges` completes, all initial
+                        // subscriptions will also have been downloaded.
+                        //
+                        // Note that we are reusing the same timeout for uploading and downloading.
+                        // This means that in the worst case you end up with 2x the timeout for
+                        // Query-based Realms. This is probably an acceptable trade-of as trying
+                        // to expose this would not only complicate the API surface quite a lot,
+                        // but in most (almost all?) cases the amount of data to upload will be trivial.
+                        if (!session.uploadAllLocalChanges(timeoutMillis, TimeUnit.MILLISECONDS)) {
+                            throw new DownloadingRealmInterruptedException(syncConfig, "Failed to first upload local changes in " + timeoutMillis + " milliseconds");
+                        };
+                    }
+                    if (!session.downloadAllServerChanges(timeoutMillis, TimeUnit.MILLISECONDS)) {
+                        throw new DownloadingRealmInterruptedException(syncConfig, "Failed to download remote changes in " + timeoutMillis + " milliseconds");
                     }
-                    session.downloadAllServerChanges();
                 } catch (InterruptedException e) {
                     throw new DownloadingRealmInterruptedException(syncConfig, e);
                 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 3f51da45cc..ebc5b87675 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -319,7 +319,7 @@ private UpdateAccountResponse updateAccount(URL updateAccountUrl, String request
             builder.addHeader(entry.getKey(), entry.getValue());
         }
 
-        // add custom headers used by specific host (may override g
+        // add custom headers used by specific host (may override global headers)
         Map<String, String> customHeaders = this.customHeaders.get(url.getHost());
         if (customHeaders != null) {
             for (Map.Entry<String, String> entry : customHeaders.entrySet()) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 6300954d20..f137814068 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -16,10 +16,12 @@
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
+import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.internal.OsRealmConfig;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
@@ -642,4 +644,26 @@ public void stop_multipleTimes() {
             looperThread.testComplete();
         });
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void waitForInitialRemoteData_throwsOnTimeout() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .initialData(bgRealm -> {
+                    for (int i = 0; i < 100; i++) {
+                        bgRealm.createObject(AllTypes.class);
+                    }
+                })
+                .waitForInitialRemoteData(1, TimeUnit.MILLISECONDS)
+                .build();
+
+        try {
+            Realm.getInstance(syncConfiguration);
+            fail("This should have timed out");
+        } catch (DownloadingRealmInterruptedException ignore) {
+        }
+        looperThread.testComplete();
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index 8f0e0f604d..b411ed3100 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -30,6 +30,8 @@
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.annotation.Nullable;
+
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 4c7baeece9..0469153779 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -33,12 +33,12 @@
 public class EncryptedSynchronizedRealmTests extends StandardIntegrationTest {
 
     @Rule
-    public Timeout globalTimeout = Timeout.seconds(10);
+    public Timeout globalTimeout = Timeout.seconds(30);
 
     // Make sure the encryption is local, i.e after deleting a synced Realm
     // re-open it again with no (or different) key, should be possible.
     @Test
-    public void setEncryptionKey_canReOpenRealmWithoutKey() {
+    public void setEncryptionKey_canReOpenRealmWithoutKey() throws InterruptedException {
 
         // STEP 1: open a synced Realm using a local encryption key
         String username = UUID.randomUUID().toString();
@@ -68,7 +68,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         realm.commitTransaction();
 
         // STEP 2:  make sure the changes gets to the server
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
         realm.close();
         user.logOut();
 
@@ -185,7 +185,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         realm.commitTransaction();
 
         // STEP 2: make sure the changes gets to the server
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
         realm.close();
 
         // STEP 3: prepare a synced Realm for client B (admin user)
@@ -216,14 +216,13 @@ public void onError(SyncSession session, ObjectServerError error) {
         adminRealm.beginTransaction();
         adminRealm.createObject(StringOnly.class).setChars("Hi Bob");
         adminRealm.commitTransaction();
-
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));
+        SyncManager.getSession(adminConfigWithEncryption).uploadAllLocalChanges();
         adminRealm.close();
 
         // STEP 4: client A can see changes from client B (although they're using different encryption keys)
         realm = Realm.getInstance(configWithEncryption);
         SyncManager.getSession(configWithEncryption).downloadAllServerChanges();// force download latest commits from ROS
-        realm.refresh();//FIXME not calling refresh will still point to the previous version of the Realm without the latest admin commit  "Hi Bob"
+        realm.refresh(); // Not calling refresh will still point to the previous version of the Realm without the latest admin commit  "Hi Bob"
         assertEquals(2, realm.where(StringOnly.class).count());
 
         adminRealm = Realm.getInstance(adminConfigWithEncryption);
diff --git a/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java
index dc7aa345cb..cc32b5df20 100644
--- a/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncTestUtils/java/io/realm/objectserver/utils/UserFactory.java
@@ -153,13 +153,16 @@ public static void logoutAllUsers() {
         final HandlerThread ht = new HandlerThread("LoggingOutUsersThread");
         ht.start();
         Handler handler = new Handler(ht.getLooper());
-        handler.post(() -> {
-            Map<String, SyncUser> users = SyncUser.all();
-            for (SyncUser user : users.values()) {
-                user.logOut();
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                Map<String, SyncUser> users = SyncUser.all();
+                for (SyncUser user : users.values()) {
+                    user.logOut();
+                }
+                TestHelper.waitForNetworkThreadExecutorToFinish();
+                allUsersLoggedOut.countDown();
             }
-            TestHelper.waitForNetworkThreadExecutorToFinish();
-            allUsersLoggedOut.countDown();
         });
         TestHelper.awaitOrFail(allUsersLoggedOut);
         ht.quit();
diff --git a/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsLong.java b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsLong.java
index 19fd734383..c20e60ed5e 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsLong.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/entities/PrimaryKeyAsLong.java
@@ -23,6 +23,12 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsLong";
     public static final String FIELD_ID = "id";
+    public static final String FIELD_NAME = "name";
+
+    public PrimaryKeyAsLong() { }
+    public PrimaryKeyAsLong(long id) {
+        this.id = id;
+    }
 
     @PrimaryKey
     private long id;
diff --git a/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
index c9837cb1fc..5c1b9b4107 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
@@ -227,8 +227,11 @@ public void postRunnableDelayed(Runnable runnable, long delayMillis) {
     public void testComplete() {
         // Close all resources and run any after test tasks
         // Post as runnable to ensure that this code runs on the correct thread.
-        postRunnable(() -> {
-            closeTestResources();
+        postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                closeTestResources();
+            }
         });
     }
 
