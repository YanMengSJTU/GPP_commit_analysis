diff --git a/CHANGELOG.md b/CHANGELOG.md
index d4b6abdbdc..54a845bf37 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,9 +1,48 @@
+## 5.0.0 (2018-03-15)
+
+This release is compatible with the Realm Object Server 3.0.0-beta.3 or later.
+
+### Known Bugs
+
+* API's marked @ObjectServer are shipped as part of the base binary, they should only be available when enabling synchronized Realms.
+
+### Breaking Changes
+
+* [ObjectServer] Renamed `SyncUser.currentUser()` to `SyncUser.current()`.
+* [ObjectServer] Renamed `SyncUser.login(...)` and `SyncUser.loginAsync(...)` to `SyncUser.logIn(...)` and `SyncUser.logInAsync(...)`.
+* [ObjectServer] Renamed `SyncUser.logout()` to `SyncUser.logOut()`.
+* The `OrderedCollectionChangeSet` parameter in `OrderedRealmCollectionChangeListener.onChange()` is no longer nullable. Use `changeSet.getState()` instead (#5619).
+* `realm.subscribeForObjects()` have been removed. Use `RealmQuery.findAllAsync(String subscriptionName)` and `RealmQuery.findAllAsync()` instead.
+* Removed previously deprecated `RealmQuery.findAllSorted()`, `RealmQuery.findAllSortedAsync()` `RealmQuery.distinct() and `RealmQuery.distinctAsync()`.
+* Renamed `RealmQuery.distinctValues()` to `RealmQuery.distinct()`
+
+### Enhancements
+
+* [ObjectServer] Added support for partial Realms. Read [here](https://realm.io/docs/java/latest/#partial-realms) for more information.
+* [ObjectServer] Added support for Object Level Permissions (requires partial synchronized Realms). Read [here](https://realm.io/docs/java/latest/#partial-realms) for more information.
+* [ObjectServer] Added `SyncConfiguration.automatic()` and `SyncConfiguration.automatic(SyncUser user)` (#5806).
+* Added two new methods to `OrderedCollectionChangeSet`: `getState()` and `getError()` (#5619).
+
+## Bug Fixes
+
+* Better exception message if a non model class is provided to methods only accepting those (#5779).
+
+### Internal
+
+* Upgraded to Realm Sync 3.0.0
+* Upgraded to Realm Core 5.3.0
+
+
 ## 4.4.0 (2018-03-13)
 
 ### Enhancements
 
 * Added support for mapping between a Java name and the underlying name in the Realm file using `@RealmModule`, `@RealmClass` and `@RealmField` annotations (#5280).
 
+## Bug Fixes
+
+* [ObjectServer] Fixed an issue where login after a logout will not resume Syncing (https://github.com/realm/my-first-realm-app/issues/22).
+
 
 ## 4.3.4 (2018-02-06)
 
@@ -11,7 +50,6 @@
 
 * Added missing `RealmQuery.oneOf()` for Kotlin that accepts non-nullable types (#5717).
 * [ObjectServer] Fixed an issue preventing sync to resume when the network is back (#5677).
-* [ObjectServer] Fixed an issue where login after a logout will not resume Syncing (https://github.com/realm/my-first-realm-app/issues/22).
 
 ## 4.3.3 (2018-01-19)
 
diff --git a/Jenkinsfile b/Jenkinsfile
index fec751058f..a6eeb60267 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -29,7 +29,7 @@ try {
         // on PR's for even more throughput.
         def ABIs = ""
         def instrumentationTestTarget = "connectedAndroidTest"
-        if (!['master'].contains(env.BRANCH_NAME)) {
+        if (!['master', 'next-major'].contains(env.BRANCH_NAME)) {
             ABIs = "armeabi-v7a"
             instrumentationTestTarget = "connectedObjectServerDebugAndroidTest" // Run in debug more for better error reporting
         }
@@ -118,11 +118,13 @@ try {
 
                 // TODO: add support for running monkey on the example apps
 
-                if (env.BRANCH_NAME == 'master') {
+                if (['master'].contains(env.BRANCH_NAME)) {
                   stage('Collect metrics') {
                     collectAarMetrics()
                   }
+                }   
 
+                if (['master', 'next-major'].contains(env.BRANCH_NAME)) {
                   stage('Publish to OJO') {
                     withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
                       sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
@@ -145,7 +147,7 @@ try {
   buildSuccess = false
   throw e
 } finally {
-  if (['master', 'releases'].contains(env.BRANCH_NAME) && !buildSuccess) {
+  if (['master', 'releases', 'next-major'].contains(env.BRANCH_NAME) && !buildSuccess) {
     node {
       withCredentials([[$class: 'StringBinding', credentialsId: 'slack-java-url', variable: 'SLACK_URL']]) {
         def payload = JsonOutput.toJson([
diff --git a/dependencies.list b/dependencies.list
index bd4aa3ff41..f58dbb65cb 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,9 +1,8 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=2.2.9
-REALM_SYNC_SHA256=d770d639d2b187c15e6d0bc798b909f5b424d61444f1f83f9e56f5be43e96afc
+REALM_SYNC_VERSION=3.0.0
+REALM_SYNC_SHA256=9141177ccc92d8f9282625dace61eee5c3d971d2daca7593266e175b610a24cf
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.6.0
-
+REALM_OBJECT_SERVER_DE_VERSION=3.0.0-rc.1
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index faa6b1eb78..669cd75af7 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -191,7 +191,7 @@ public void execute(Realm realm) {
         }
 
         // Sorting
-        RealmResults<Person> sortedPersons = realm.where(Person.class).findAllSorted("age", Sort.DESCENDING);
+        RealmResults<Person> sortedPersons = realm.where(Person.class).sort("age", Sort.DESCENDING).findAll();
         status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.where(Person.class).findFirst()
                 .getName();
 
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 82a2cfb8f5..25a6622827 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -176,7 +176,7 @@ class KotlinExampleActivity : Activity() {
             }
 
             // Sorting
-            val sortedPersons = realm.where<Person>().findAllSorted(Person::age.name, Sort.DESCENDING)
+            val sortedPersons = realm.where<Person>().sort(Person::age.name, Sort.DESCENDING).findAll()
             status += "\nSorting ${sortedPersons.last()?.name} == ${realm.where<Person>().findAll().first()?.name}"
 
         } finally {
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
index dc75037989..0f23bf17d5 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
@@ -86,7 +86,8 @@ public Repository() {
         // save data in Realm
         return realm.where(NYTimesStory.class)
                 .equalTo(NYTimesStory.API_SECTION, sectionKey)
-                .findAllSortedAsync(NYTimesStory.PUBLISHED_DATE, Sort.DESCENDING)
+                .sort(NYTimesStory.PUBLISHED_DATE, Sort.DESCENDING)
+                .findAllAsync()
                 .asFlowable();
     }
 
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index 1baf3a9e2f..6984f15bf9 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -146,7 +146,7 @@ public boolean onOptionsItemSelected(MenuItem item) {
         switch(item.getItemId()) {
             case R.id.action_logout:
                 closeRealm();
-                user.logout();
+                user.logOut();
                 user = getLoggedInUser();
                 return true;
 
@@ -198,7 +198,7 @@ public void execute(@Nonnull Realm realm) {
     private SyncUser getLoggedInUser() {
         SyncUser user = null;
 
-        try { user = SyncUser.currentUser(); }
+        try { user = SyncUser.current(); }
         catch (IllegalStateException ignore) { }
 
         if (user == null) {
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
index 9bf5479f15..2f87b3a0bd 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
@@ -103,7 +103,7 @@ public void onError(@Nonnull ObjectServerError error) {
             }
         };
 
-        SyncUser.loginAsync(creds, REALM_AUTH_URL, callback);
+        SyncUser.logInAsync(creds, REALM_AUTH_URL, callback);
     }
 
     @Override
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
index 4a269e0dd2..6013d6ebee 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
@@ -71,7 +71,7 @@ protected void onResume() {
 
         // Trigger updates
         realm.executeTransaction(r ->
-                r.where(Person.class).findAllSorted( "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100)));
+                r.where(Person.class).sort( "name", Sort.ASCENDING).findAll().get(0).setAge(new Random().nextInt(100)));
     }
 
     /**
@@ -79,7 +79,7 @@ protected void onResume() {
      */
     private void testSubscribeOn() {
         Disposable subscribeOnDisposable = realm.asFlowable()
-                .map(realm -> realm.where(Person.class).findAllSorted("name").get(0))
+                .map(realm -> realm.where(Person.class).sort("name").findAll().get(0))
                 // The Realm was created on the UI thread. Accessing it on `Schedulers.io()` will crash.
                 // Avoid using subscribeOn() and use Realms `findAllAsync*()` methods instead.
                 .subscribeOn(Schedulers.io()) //
@@ -90,7 +90,7 @@ private void testSubscribeOn() {
         compositeDisposable.add(subscribeOnDisposable);
 
         // Use Realms Async API instead
-        Disposable asyncSubscribeOnDisposable = realm.where(Person.class).findAllSortedAsync("name").get(0).<Person>asFlowable()
+        Disposable asyncSubscribeOnDisposable = realm.where(Person.class).sort("name").findAllAsync().get(0).<Person>asFlowable()
                 .subscribe(
                         person -> showStatus("subscribeOn/async: " + person.getName() + ":" + person.getAge()),
                         throwable -> showStatus("subscribeOn/async: " +throwable.toString())
@@ -103,7 +103,7 @@ private void testSubscribeOn() {
      */
     private void testBuffer() {
         Flowable<Person> personFlowable =
-                realm.asFlowable().map(realm -> realm.where(Person.class).findAllSorted("name").get(0));
+                realm.asFlowable().map(realm -> realm.where(Person.class).sort("name").findAll().get(0));
 
         // buffer() caches objects until the buffer is full. Due to Realms auto-update of all objects it means
         // that all objects in the cache will contain the same data.
@@ -122,7 +122,7 @@ private void testBuffer() {
      */
     private void testDistinct() {
         Flowable<Person> personFlowable =
-                realm.asFlowable().map(realm -> realm.where(Person.class).findAllSorted("name").get(0));
+                realm.asFlowable().map(realm -> realm.where(Person.class).sort("name").findAll().get(0));
 
         // distinct() and distinctUntilChanged() uses standard equals with older objects stored in a HashMap.
         // Realm objects auto-update which means the objects stored will also auto-update.
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
index 4f01dbfa11..e76e15af25 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
@@ -60,7 +60,7 @@ protected void onResume() {
         super.onResume();
 
         // Load all persons and merge them with their latest stats from GitHub (if they have any)
-        disposable = realm.where(Person.class).isNotNull("githubUserName").findAllSortedAsync("name").asFlowable()
+        disposable = realm.where(Person.class).isNotNull("githubUserName").sort("name").findAllAsync().asFlowable()
                 // We only want the list once it is loaded.
                 .filter(people -> people.isLoaded())
                 .switchMap(people -> Flowable.fromIterable(people))
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
index 5b4bdd1df8..ffab76936e 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
@@ -63,7 +63,8 @@ protected void onResume() {
                     // Realm currently doesn't support the standard Schedulers.
                     return realm.where(Person.class)
                             .beginsWith("name", textChangeEvent.text().toString())
-                            .findAllSortedAsync("name")
+                            .sort("name")
+                            .findAllAsync()
                             .asFlowable();
                 })
                 // Only continue once data is actually loaded
diff --git a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
index 6fff42f95e..ecce92c122 100644
--- a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
+++ b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
@@ -87,7 +87,7 @@ private void buildSyncConf() {
         final String urlAuth = "http://objectserver.realm.io:9080/auth";
         final String url = "realm://objectserver.realm.io/default";
 
-        SyncUser.loginAsync(credentials, urlAuth, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, urlAuth, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 SyncConfiguration secureConfig = new SyncConfiguration.Builder(user, url).build();
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
index 3fdde6744e..42aa4bb904 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -65,10 +65,11 @@ public void onStart() {
         allSortedDots = realm.where(Dot.class)
                 .between("x", 25, 75)
                 .between("y", 0, 50)
-                .findAllSortedAsync(
+                .sort(
                          "x", Sort.ASCENDING,
                          "y", Sort.DESCENDING
-                 );
+                 )
+                .findAllAsync();
         dotAdapter.updateList(allSortedDots);
         allSortedDots.addChangeListener(this);
     }
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index 279dd332d8..eb4b1c96ff 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -24,5 +24,20 @@
     <Match>
         <Class name="io.realm.io_realm_permissions_PermissionRealmProxy"/>
     </Match>
+    <Match>
+        <Class name="io.realm.io_realm_sync_permissions_ClassPermissionsRealmProxy"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.io_realm_sync_permissions_RealmPermissionsRealmProxy"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.io_realm_sync_permissions_PermissionRealmProxy"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.io_realm_sync_permissions_RoleRealmProxy"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.io_realm_sync_permissions_PermissionUserRealmProxy"/>
+    </Match>
 
 </FindBugsFilter>
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 85b92a64ac..88d3a47abd 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -390,12 +390,13 @@ public static String getReferencedTypeInternalClassNameStatement(String qualifie
         }
 
         // If we cannot find the name in the current processor round, we have to defer resolving the
-        // name to runtime. The reason being that proxy classes in libraries on the classpath
-        // might already have been obfuscated, which means we have no easy way of finding them.
-        // 
+        // name to runtime. The reason being that the annotation processor can only access the
+        // compile type class path using Elements and Types which do not allow us to read
+        // field values.
+        //
         // Doing it this way unfortunately means that if the class is not on the apps classpath
-        // a rather obscure class-not-found exception will be thrown, but since this is probably
-        // a very niche use case that is acceptable for now.
+        // a rather obscure class-not-found exception will be thrown when starting the app, but since
+        // this is probably a very niche use case that is acceptable for now.
         //
         // TODO: We could probably create an internal annotation like `@InternalName("__Permission")`
         // which should make it possible for the annotation processor to read the value from the
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 86f675551b..20fa873053 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -92,6 +92,12 @@ android {
         debug {
             // FIXME: If enabled, crashes with https://issuetracker.google.com/issues/37116868
             testCoverageEnabled = false
+            // minifyEnabled = true;
+            // proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+
+        release {
+            // minifyEnabled = true;
         }
     }
 
@@ -132,7 +138,8 @@ android {
                     arguments "-DREALM_FLAVOR=base"
                 }
             }
-            consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-base.pro'
+            consumerProguardFiles 'proguard-rules-consumer-common.pro', 'proguard-rules-consumer-base.pro'
+            proguardFiles 'proguard-rules-build-common.pro'
         }
         objectServer {
             dimension 'api'
@@ -141,7 +148,8 @@ android {
                     arguments "-DREALM_FLAVOR=objectServer"
                 }
             }
-            consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-objectServer.pro'
+            consumerProguardFiles 'proguard-rules-consumer-common.pro', 'proguard-rules-consumer-objectServer.pro'
+            proguardFiles 'proguard-rules-build-common.pro', 'proguard-rules-build-objectServer.pro'
         }
     }
 
diff --git a/realm/realm-library/proguard-rules-build-common.pro b/realm/realm-library/proguard-rules-build-common.pro
new file mode 100644
index 0000000000..b5ca18e12a
--- /dev/null
+++ b/realm/realm-library/proguard-rules-build-common.pro
@@ -0,0 +1,2 @@
+# Common proguard configuration for building the Base and ObjectServer variants
+# Note: This is for _building the Realm library, not for consuming it.
diff --git a/realm/realm-library/proguard-rules-build-objectServer.pro b/realm/realm-library/proguard-rules-build-objectServer.pro
new file mode 100644
index 0000000000..09a9d548f6
--- /dev/null
+++ b/realm/realm-library/proguard-rules-build-objectServer.pro
@@ -0,0 +1,2 @@
+# Proguard configuration specific for building the ObjectServer variant.
+# Note: This is for _building the Realm library, not for consuming it.
diff --git a/realm/realm-library/proguard-rules-base.pro b/realm/realm-library/proguard-rules-consumer-base.pro
similarity index 99%
rename from realm/realm-library/proguard-rules-base.pro
rename to realm/realm-library/proguard-rules-consumer-base.pro
index 19a3b8d3ba..5054eff929 100644
--- a/realm/realm-library/proguard-rules-base.pro
+++ b/realm/realm-library/proguard-rules-consumer-base.pro
@@ -1,2 +1,3 @@
 # It's OK not to exist SyncObjectServerFacade in base library.
 -dontnote io.realm.internal.SyncObjectServerFacade
+
diff --git a/realm/realm-library/proguard-rules-common.pro b/realm/realm-library/proguard-rules-consumer-common.pro
similarity index 100%
rename from realm/realm-library/proguard-rules-common.pro
rename to realm/realm-library/proguard-rules-consumer-common.pro
diff --git a/realm/realm-library/proguard-rules-objectServer.pro b/realm/realm-library/proguard-rules-consumer-objectServer.pro
similarity index 100%
rename from realm/realm-library/proguard-rules-objectServer.pro
rename to realm/realm-library/proguard-rules-consumer-objectServer.pro
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java b/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
index a49f7393a3..e4c23cbce0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CustomRealmNameTests.java
@@ -120,7 +120,7 @@ public void typedQueryWithJavaNames() {
                 .equalTo("camelCase", "foo") // Java name in model class
                 .equalTo("parents.PascalCase", 1) // Backlinks also uses java names
                 .sort("mHungarian") // Sorting uses Java names
-                .distinctValues("customName") // Distinct uses Java names
+                .distinct("customName") // Distinct uses Java names
                 .findAll();
         assertTrue(results.isEmpty());
     }
@@ -142,7 +142,7 @@ public void typedQueryWithInternalNamesThrows() {
 
         // Distinct
         try {
-            realm.where(ClassWithPolicy.class).distinctValues(ClassWithPolicy.FIELD_CAMEL_CASE);
+            realm.where(ClassWithPolicy.class).distinct(ClassWithPolicy.FIELD_CAMEL_CASE);
         } catch (IllegalArgumentException ignore) {
         }
 
@@ -156,7 +156,7 @@ public void dynamicQueryWithInternalNames() {
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(ClassWithPolicy.CLASS_NAME)
                 .equalTo(ClassWithPolicy.FIELD_CAMEL_CASE, "foo") // Normal queries use internal names
                 .sort(ClassWithPolicy.FIELD_M_HUNGARIAN) // Sorting uses internal names
-                .distinctValues(ClassWithPolicy.FIELD_CUSTOM_NAME) // Distinct uses internal names
+                .distinct(ClassWithPolicy.FIELD_CUSTOM_NAME) // Distinct uses internal names
                 .findAll();
         assertTrue(results.isEmpty());
     }
@@ -176,7 +176,7 @@ public void dynamicQueryWithJavaNamesThrows() {
 
         // Distinct
         try {
-            dynamicRealm.where(ClassWithPolicy.CLASS_NAME).distinctValues("camelCase");
+            dynamicRealm.where(ClassWithPolicy.CLASS_NAME).distinct("camelCase");
         } catch (IllegalArgumentException ignore) {
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index d609d7fc8e..ef0e68ffbc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -678,7 +678,7 @@ public void query_multipleReferencesWithDistinct() {
 
         assertEquals(2, child.getListParents().size());
 
-        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinctValues("fieldId").findAll();
+        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinct("fieldId").findAll();
         assertEquals(1, distinctParents.size());
         assertTrue(child.getListParents().contains(parent));
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
index a8e0b8701c..267860f80a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -36,11 +36,11 @@
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNull;
 import static junit.framework.Assert.assertSame;
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
 
 
 // Tests for the ordered collection fine grained notifications for both RealmResults and RealmList.
@@ -459,7 +459,7 @@ public void run() {
     // The change set should be empty when the async query returns at the first time.
     @Test
     @RunTestInLooperThread
-    public void emptyChangeSet_findAllAsync() {
+    public void initialChangeSet_findAllAsync() {
         if (type == ObservablesType.REALM_LIST) {
             looperThread.testComplete();
             return;
@@ -469,14 +469,42 @@ public void emptyChangeSet_findAllAsync() {
         populateData(realm, 10);
         final RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAllAsync();
         looperThread.keepStrongReference(results);
-        results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
-            @Override
-            public void onChange(RealmResults<Dog> collection, @Nullable OrderedCollectionChangeSet changeSet) {
-                assertSame(collection, results);
-                assertEquals(10, collection.size());
-                assertNull(changeSet);
-                looperThread.testComplete();
-            }
+        results.addChangeListener((collection, changeSet) -> {
+            assertSame(collection, results);
+            assertEquals(10, collection.size());
+            assertTrue(changeSet.isCompleteResult());
+            assertEquals(OrderedCollectionChangeSet.State.INITIAL, changeSet.getState());
+            assertEquals(0, changeSet.getInsertions().length);
+            assertEquals(0, changeSet.getChanges().length);
+            assertEquals(0, changeSet.getDeletions().length);
+            looperThread.testComplete();
+        });
+    }
+
+    // The change set should be empty when the async query returns at the first time.
+    @Test
+    @RunTestInLooperThread
+    public void initialChangeSet_findAll() {
+        if (type == ObservablesType.REALM_LIST) {
+            looperThread.testComplete();
+            return;
+        }
+
+        Realm realm = looperThread.getRealm();
+        populateData(realm, 10);
+        final RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAll();
+        looperThread.keepStrongReference(results);
+        results.addChangeListener((collection, changeSet) -> {
+            assertSame(collection, results);
+            assertEquals(11, collection.size());
+            assertTrue(changeSet.isCompleteResult());
+            assertEquals(OrderedCollectionChangeSet.State.UPDATE, changeSet.getState());
+            assertEquals(1, changeSet.getInsertions().length);
+            looperThread.testComplete();
+        });
+
+        realm.executeTransaction(r -> {
+            r.createObject(Dog.class);
         });
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 6d7a320cd2..34b356ae5c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -885,10 +885,10 @@ public void distinct_async() throws Throwable {
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues("indexBoolean").findAllAsync();
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctValues("indexLong").findAllAsync();
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctValues("indexDate").findAllAsync();
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctValues("indexString").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct("indexBoolean").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinct("indexLong").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinct("indexDate").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinct("indexString").findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -966,7 +966,7 @@ public void distinct_async_rememberQueryParams() {
 
         RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class)
                 .notEqualTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2)
-                .distinctValues(AllJavaTypes.FIELD_ID)
+                .distinct(AllJavaTypes.FIELD_ID)
                 .findAllAsync();
 
         results.addChangeListener(new RealmChangeListener<RealmResults<AllJavaTypes>>() {
@@ -988,16 +988,16 @@ public void distinctAsync_notIndexedFields() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
+                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
                 .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG)
+                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG)
                 .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE)
+                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE)
                 .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_STRING)
                 .findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
@@ -1072,7 +1072,7 @@ public void distinctAsync_noneExistingField() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAllAsync();
+            realm.where(AnnotationIndexTypes.class).distinct("doesNotExist").findAllAsync();
             fail();
         } catch (IllegalArgumentException ignored) {
             looperThread.testComplete();
@@ -1102,7 +1102,7 @@ public void batchUpdateDifferentTypeOfQueries() {
         RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).sort("columnString", Sort.ASCENDING).findAllAsync();
         RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).sort(new String[]{"columnString", "columnLong"},
                 new Sort[]{Sort.ASCENDING, Sort.DESCENDING}).findAllAsync();
-        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctValues("indexString").findAllAsync();
+        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinct("indexString").findAllAsync();
 
         looperThread.keepStrongReference(findAllAsync);
         looperThread.keepStrongReference(findAllSorted);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index 252dc083a6..9fd28e2e0d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -31,6 +31,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmFileException;
@@ -271,6 +272,7 @@ public void getInstance_differentConfigurationsShouldNotBlockEachOther() throws
 
         final RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .name("config1.realm")
+                .schema(AllJavaTypes.class)
                 .initialData(new Realm.Transaction() {
                     @Override
                     public void execute(Realm realm) {
@@ -282,6 +284,7 @@ public void execute(Realm realm) {
 
         RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .name("config2.realm")
+                .schema(AllJavaTypes.class)
                 .build();
 
         Thread thread = new Thread(new Runnable() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 633cbe6e64..3e9a2e32d4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -37,6 +37,7 @@
 import io.reactivex.Observable;
 import io.reactivex.Single;
 import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesModelModule;
 import io.realm.entities.AnimalModule;
 import io.realm.entities.AssetFileModule;
 import io.realm.entities.Cat;
@@ -137,7 +138,7 @@ public void getInstance_nullConfigThrows() {
     @Test
     public void constructBuilder_nullNameThrows() {
         try {
-            new RealmConfiguration.Builder(context).name(null);
+            configFactory.createConfigurationBuilder().name(null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -146,7 +147,7 @@ public void constructBuilder_nullNameThrows() {
     @Test
     public void constructBuilder_emptyNameThrows() {
         try {
-            new RealmConfiguration.Builder(context).name("");
+            configFactory.createConfigurationBuilder().name("");
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -154,14 +155,14 @@ public void constructBuilder_emptyNameThrows() {
 
     @Test(expected = IllegalArgumentException.class)
     public void directory_null() {
-        new RealmConfiguration.Builder(context).directory(null);
+        configFactory.createConfigurationBuilder().directory(null);
     }
 
     @Test
     public void directory_writeProtectedDir() {
         File dir = new File("/");
         thrown.expect(IllegalArgumentException.class);
-        new RealmConfiguration.Builder(context).directory(dir);
+        configFactory.createConfigurationBuilder().directory(dir);
     }
 
     @Test
@@ -170,7 +171,7 @@ public void directory_dirIsAFile() throws IOException {
         File file = new File(dir, "dummyfile");
         assertTrue(file.createNewFile());
         thrown.expect(IllegalArgumentException.class);
-        new RealmConfiguration.Builder(context).directory(file);
+        configFactory.createConfigurationBuilder().directory(file);
     }
 
     @Test
@@ -189,7 +190,7 @@ public void getInstance_idForHashCollision() {
     @Test
     public void constructBuilder_nullKeyThrows() {
         try {
-            new RealmConfiguration.Builder(context).encryptionKey(null);
+            configFactory.createConfigurationBuilder().encryptionKey(null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -204,7 +205,7 @@ public void constructBuilder_wrongKeyLengthThrows() {
         };
         for (byte[] key : wrongKeys) {
             try {
-                new RealmConfiguration.Builder(context).encryptionKey(key);
+                configFactory.createConfigurationBuilder().encryptionKey(key);
                 fail("Key with length " + key.length + " should throw an exception");
             } catch (IllegalArgumentException ignored) {
             }
@@ -214,7 +215,7 @@ public void constructBuilder_wrongKeyLengthThrows() {
     @Test
     public void constructBuilder_negativeVersionThrows() {
         try {
-            new RealmConfiguration.Builder(context).schemaVersion(-1);
+            configFactory.createConfigurationBuilder().schemaVersion(-1);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -222,7 +223,7 @@ public void constructBuilder_negativeVersionThrows() {
 
     @Test
     public void constructBuilder_versionLessThanDiscVersionThrows() {
-        realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+        realm = Realm.getInstance(configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schemaVersion(42)
                 .build());
@@ -231,7 +232,7 @@ public void constructBuilder_versionLessThanDiscVersionThrows() {
         int[] wrongVersions = new int[] { 0, 1, 41 };
         for (int version : wrongVersions) {
             try {
-                realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                realm = Realm.getInstance(configFactory.createConfigurationBuilder()
                         .directory(configFactory.getRoot())
                         .schemaVersion(version)
                         .build());
@@ -244,7 +245,7 @@ public void constructBuilder_versionLessThanDiscVersionThrows() {
     @Test
     public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
         // Creates initial Realm.
-        RealmConfiguration config = new RealmConfiguration.Builder(context)
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schemaVersion(42)
                 .schema(StringOnly.class)
@@ -253,7 +254,7 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
 
         // Creates new instance with a configuration containing another schema.
         try {
-            config = new RealmConfiguration.Builder(context)
+            config = configFactory.createConfigurationBuilder()
                     .directory(configFactory.getRoot())
                     .schemaVersion(42)
                     .schema(StringAndInt.class)
@@ -267,7 +268,7 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
     // Only Dog is included in the schema definition, but in order to create Dog, the Owner has to be defined as well.
     @Test
     public void schemaDoesNotContainAllDefinedObjectShouldThrow() {
-        RealmConfiguration config = new RealmConfiguration.Builder(context)
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schema(Dog.class)
                 .build();
@@ -278,7 +279,7 @@ public void schemaDoesNotContainAllDefinedObjectShouldThrow() {
     @Test
     public void migration_nullThrows() {
         try {
-            new RealmConfiguration.Builder(context).migration(null).build();
+            configFactory.createConfigurationBuilder().migration(null).build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -288,14 +289,14 @@ public void migration_nullThrows() {
     public void modules_nonRealmModulesThrows() {
         // Tests first argument.
         try {
-            new RealmConfiguration.Builder(context).modules(new Object());
+            configFactory.createConfigurationBuilder().modules(new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Tests second argument.
         try {
-            new RealmConfiguration.Builder(context).modules(Realm.getDefaultModule(), new Object());
+            configFactory.createConfigurationBuilder().modules(Realm.getDefaultModule(), new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -303,9 +304,9 @@ public void modules_nonRealmModulesThrows() {
 
     @Test
     public void modules() {
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(context)
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
-                .modules(Realm.getDefaultModule(), (Object) null)
+                .modules(new AllTypesModelModule(), (Object) null)
                 .build();
         realm = Realm.getInstance(realmConfig);
         assertNotNull(realm.getTable(AllTypes.class));
@@ -326,7 +327,7 @@ public void getInstance() {
 
     @Test
     public void standardSetup() {
-        RealmConfiguration config = new RealmConfiguration.Builder(context)
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .name("foo.realm")
                 .encryptionKey(TestHelper.getRandomKey())
@@ -349,7 +350,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void deleteRealmIfMigrationNeeded() {
         // Populates v0 of a Realm with an object.
-        RealmConfiguration config = new RealmConfiguration.Builder(context)
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schema(StringOnly.class)
                 .schemaVersion(0)
@@ -363,7 +364,7 @@ public void deleteRealmIfMigrationNeeded() {
         realm.close();
 
         // Changes schema and verifies that Realm has been cleared.
-        config = new RealmConfiguration.Builder(context)
+        config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schema(StringOnly.class, StringAndInt.class)
                 .schemaVersion(1)
@@ -378,7 +379,7 @@ public void deleteRealmIfMigrationNeeded_failsWhenAssetFileProvided() {
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
 
         // Has a builder instance to isolate codepath.
-        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
+        RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder();
         try {
             builder
                 .assetFile("asset_file.realm")
@@ -398,7 +399,7 @@ public void upgradeVersionWithNoMigration() {
 
         // Version upgrades only without any actual schema changes will just succeed, and the schema version will be
         // set to the new one.
-        realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+        realm = Realm.getInstance(configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schemaVersion(42)
                 .build());
@@ -407,43 +408,43 @@ public void upgradeVersionWithNoMigration() {
 
     @Test
     public void equals() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context).build();
+        RealmConfiguration config1 = configFactory.createConfiguration();
+        RealmConfiguration config2 = configFactory.createConfiguration();
         assertTrue(config1.equals(config2));
     }
 
     @Test
     public void equals_respectReadOnly() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context).assetFile("foo").build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context).assetFile("foo").readOnly().build();
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().assetFile("foo").build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().assetFile("foo").readOnly().build();
         assertFalse(config1.equals(config2));
     }
 
     @Test
     public void equalsWhenRxJavaUnavailable() {
         // Test for https://github.com/realm/realm-java/issues/2416
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config1);
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config2);
         assertTrue(config1.equals(config2));
     }
 
     @Test
     public void hashCode_Test() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();
         assertEquals(config1.hashCode(), config2.hashCode());
     }
 
     @Test
     public void equals_withCustomModules() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
 
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .modules(new AnimalModule(), new HumanModule())
                 .build();
@@ -453,11 +454,11 @@ public void equals_withCustomModules() {
 
     @Test
     public void hashCode_withCustomModules() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .modules(new AnimalModule(), new HumanModule())
                 .build();
@@ -467,11 +468,11 @@ public void hashCode_withCustomModules() {
 
     @Test
     public void hashCode_withDifferentRxObservableFactory() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .rxFactory(new RealmObservableFactory())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .rxFactory(new RealmObservableFactory() {
                     @Override
@@ -486,8 +487,8 @@ public int hashCode() {
 
     @Test
     public void equals_configurationsReturnCachedRealm() {
-        Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build());
-        Realm realm2 = Realm.getInstance(new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build());
+        Realm realm1 = Realm.getInstance(configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build());
+        Realm realm2 = Realm.getInstance(configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build());
         try {
             assertEquals(realm1, realm2);
         } finally {
@@ -498,8 +499,8 @@ public void equals_configurationsReturnCachedRealm() {
 
     @Test
     public void schemaVersion_differentVersionsThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).schemaVersion(1).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).schemaVersion(2).build();
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).schemaVersion(1).build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).schemaVersion(2).build();
 
         Realm realm1 = Realm.getInstance(config1);
         try {
@@ -513,11 +514,11 @@ public void schemaVersion_differentVersionsThrows() {
 
     @Test
     public void encryptionKey_differentEncryptionKeysThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .encryptionKey(TestHelper.getRandomKey())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .encryptionKey(TestHelper.getRandomKey())
                 .build();
@@ -534,11 +535,11 @@ public void encryptionKey_differentEncryptionKeysThrows() {
 
     @Test
     public void schema_differentSchemasThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schema(StringOnly.class)
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schema(StringAndInt.class).build();
 
@@ -555,11 +556,11 @@ public void schema_differentSchemasThrows() {
     // Creates Realm instances with same name but different durabilities is not allowed.
     @Test
     public void inMemory_differentDurabilityThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .inMemory()
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .build();
 
@@ -589,8 +590,8 @@ public void inMemory_differentDurabilityThrows() {
     // It is allowed to create multiple Realm with same name but in different directory.
     @Test
     public void constructBuilder_differentDirSameName() throws IOException {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.newFolder()).build();
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().directory(configFactory.newFolder()).build();
 
         Realm realm1 = Realm.getInstance(config1);
         Realm realm2 = Realm.getInstance(config2);
@@ -603,7 +604,7 @@ public void encryptionKey_keyStorage() throws Exception {
         // Generates a key and uses it in a RealmConfiguration.
         byte[] oldKey = TestHelper.getRandomKey(12345);
         byte[] key = oldKey;
-        RealmConfiguration config = new RealmConfiguration.Builder(context)
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .encryptionKey(key)
                 .build();
@@ -620,8 +621,6 @@ public void encryptionKey_keyStorage() throws Exception {
 
     @Test
     public void modelClassesForDefaultMediator() throws Exception {
-        assertTrue(defaultConfig.getSchemaMediator() instanceof DefaultRealmModuleMediator);
-
         final Set<Class<? extends RealmModel>> realmClasses = defaultConfig.getRealmObjectClasses();
 
         assertTrue(realmClasses.contains(AllTypes.class));
@@ -636,7 +635,7 @@ public void modelClassesForDefaultMediator() throws Exception {
 
     @Test
     public void modelClasses_forGeneratedMediator() throws Exception {
-        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .modules(new HumanModule())
                 .build();
@@ -658,7 +657,7 @@ public void modelClasses_forGeneratedMediator() throws Exception {
 
     @Test
     public void modelClasses_forCompositeMediator() throws Exception {
-        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
@@ -681,7 +680,7 @@ public void modelClasses_forCompositeMediator() throws Exception {
     @Test
     public void modelClasses_forFilterableMediator() throws Exception {
         //noinspection unchecked
-        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(configFactory.getRoot())
                 .schema(AllTypes.class, CatOwner.class)
                 .build();
@@ -931,13 +930,13 @@ public void execute(final Realm realm) {
     @Test
     public void assetFileNullAndEmptyFileName() {
         try {
-            new RealmConfiguration.Builder(context).assetFile(null).build();
+            configFactory.createConfigurationBuilder().assetFile(null).build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         try {
-            new RealmConfiguration.Builder(context).assetFile("").build();
+            configFactory.createConfigurationBuilder().assetFile("").build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -946,10 +945,10 @@ public void assetFileNullAndEmptyFileName() {
     @Test
     public void assetFileWithInMemoryConfig() {
         // Ensures that there is no data.
-        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+        Realm.deleteRealm(configFactory.createConfigurationBuilder().build());
 
         try {
-            new RealmConfiguration.Builder(context).assetFile("asset_file.realm").inMemory().build();
+            configFactory.createConfigurationBuilder().assetFile("asset_file.realm").inMemory().build();
             fail();
         } catch (RealmException ignored) {
         }
@@ -958,9 +957,9 @@ public void assetFileWithInMemoryConfig() {
     @Test
     public void assetFileFakeFile() {
         // Ensures that there is no data.
-        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+        Realm.deleteRealm(configFactory.createConfigurationBuilder().build());
 
-        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile("no_file").build();
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder().assetFile("no_file").build();
         try {
             Realm.getInstance(configuration);
             fail();
@@ -972,7 +971,7 @@ public void assetFileFakeFile() {
     @Test
     public void assetFileValidFile() throws IOException {
         // Ensures that there is no data.
-        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+        Realm.deleteRealm(configFactory.createConfigurationBuilder().build());
 
         RealmConfiguration configuration = new RealmConfiguration
                 .Builder(context)
@@ -1007,7 +1006,7 @@ public void assetFile_failsWhenDeleteRealmIfMigrationNeededConfigured() {
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
 
         // Has a builder instance to isolate codepath.
-        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
+        RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder();
         try {
             builder
                     .deleteRealmIfMigrationNeeded()
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index 56649a1cf1..9cb082391d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -36,6 +36,7 @@
 import java.util.concurrent.TimeUnit;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesModelModule;
 import io.realm.services.RemoteProcessService;
 
 
@@ -52,6 +53,7 @@
 //      B. Open three Realms
 //      2. assertTrue("OK, remote process win. You can open more Realms than I do in the main local process", false);
 public class RealmInterprocessTest extends AndroidTestCase {
+
     private Realm testRealm;
     private Messenger remoteMessenger;
     private Messenger localMessenger;
@@ -155,8 +157,7 @@ public void handleMessage(Message msg) {
     @Override
     protected void setUp() throws Exception {
         super.setUp();
-
-        Realm.deleteRealm(new RealmConfiguration.Builder(getContext()).build());
+        Realm.deleteRealm(getConfiguration());
 
         // Starts the testing service.
         serviceStartLatch = new CountDownLatch(1);
@@ -165,6 +166,10 @@ protected void setUp() throws Exception {
         assertTrue(serviceStartLatch.await(TestHelper.SHORT_WAIT_SECS, TimeUnit.SECONDS));
     }
 
+    private RealmConfiguration getConfiguration() {
+        return new RealmConfiguration.Builder(getContext()).modules(new AllTypesModelModule()).build();
+    }
+
     @Override
     protected void tearDown() throws Exception {
         int counter = 10;
@@ -281,7 +286,7 @@ public void testCreateInitialRealm() throws InterruptedException {
             @Override
             public void run() {
                 // Step 1
-                testRealm = Realm.getInstance(new RealmConfiguration.Builder(getContext()).build());
+                testRealm = Realm.getInstance(getConfiguration());
                 assertEquals(0, testRealm.where(AllTypes.class).count());
                 testRealm.beginTransaction();
                 testRealm.createObject(AllTypes.class);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index cbaae6111e..2f3c334857 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -201,7 +201,7 @@ public void async_query() {
         Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctValues(AllTypesRealmModel.FIELD_STRING).findAllAsync();
+        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinct(AllTypesRealmModel.FIELD_STRING).findAllAsync();
         looperThread.keepStrongReference(allTypesRealmModels);
         allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 50467274cb..68a4bc5f95 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -18,7 +18,6 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -27,7 +26,6 @@
 import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
@@ -318,8 +316,8 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
             case IS_NOT_EMPTY: query.isNotEmpty( AllJavaTypes.FIELD_STRING); break;
 
             case IS_VALID: query.isValid(); break;
-            case DISTINCT: query.distinctValues(                    AllJavaTypes.FIELD_STRING); break;
-            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinctValues( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
+            case DISTINCT: query.distinct(                    AllJavaTypes.FIELD_STRING); break;
+            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinct( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
 
             case SUM: query.sum(                  AllJavaTypes.FIELD_INT); break;
             case AVERAGE: query.average(          AllJavaTypes.FIELD_INT); break;
@@ -2982,10 +2980,10 @@ public void distinct() {
         final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAll();
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAll();
         assertEquals(2, distinctBool.size());
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field).findAll();
             assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
@@ -2997,7 +2995,7 @@ public void distinct_withNullValues() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field).findAll();
             assertEquals(field, 1, distinct.size());
         }
     }
@@ -3005,8 +3003,8 @@ public void distinct_withNullValues() {
     @Test(expected = IllegalStateException.class)
     public void distinct_failIfAppliedMultipleTimes() {
         realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE);
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_DATE)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_DATE);
     }
 
     @Test
@@ -3016,12 +3014,12 @@ public void distinct_notIndexedFields() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
+                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
                 .findAll();
         assertEquals(2, distinctBool.size());
         for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
                 AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field).findAll();
             assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
@@ -3033,7 +3031,7 @@ public void distinct_doesNotExist() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAll();
+            realm.where(AnnotationIndexTypes.class).distinct("doesNotExist").findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -3045,7 +3043,7 @@ public void distinct_invalidTypes() {
 
         for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
             try {
-                realm.where(AllTypes.class).distinctValues(field).findAll();
+                realm.where(AllTypes.class).distinct(field).findAll();
                 fail(field);
             } catch (IllegalArgumentException ignored) {
             }
@@ -3061,7 +3059,7 @@ public void distinct_indexedLinkedFields() {
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
             try {
                 realm.where(AnnotationIndexTypes.class)
-                        .distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
+                        .distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
                         .findAll();
                 fail("Unsupported Index" + field + " linked field");
             } catch (IllegalArgumentException ignored) {
@@ -3078,7 +3076,7 @@ public void distinct_notIndexedLinkedFields() {
         for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
             try {
                 realm.where(AnnotationIndexTypes.class)
-                        .distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
+                        .distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
                         .findAll();
                 fail("Unsupported notIndex" + field + " linked field");
             } catch (IllegalArgumentException ignored) {
@@ -3092,7 +3090,7 @@ public void distinct_invalidTypesLinkedFields() {
 
         try {
             realm.where(AllJavaTypes.class)
-                    .distinctValues(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY)
+                    .distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY)
                     .findAll();
         } catch (IllegalArgumentException ignored) {
         }
@@ -3107,10 +3105,10 @@ public void distinct_async() throws Throwable {
         final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAllAsync();
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_LONG).findAllAsync();
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE).findAllAsync();
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_LONG).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_DATE).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_STRING).findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -3184,10 +3182,10 @@ public void distinct_async_withNullValues() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_DATE)
                 .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_STRING)
                 .findAllAsync();
 
         final Runnable endTest = new Runnable() {
@@ -3227,7 +3225,7 @@ public void distinct_async_doesNotExist() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAllAsync();
+            realm.where(AnnotationIndexTypes.class).distinct("doesNotExist").findAllAsync();
         } catch (IllegalArgumentException ignored) {
         }
         looperThread.testComplete();
@@ -3240,7 +3238,7 @@ public void distinct_async_invalidTypes() {
 
         for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
             try {
-                realm.where(AllTypes.class).distinctValues(field).findAllAsync();
+                realm.where(AllTypes.class).distinct(field).findAllAsync();
             } catch (IllegalArgumentException ignored) {
             }
         }
@@ -3256,7 +3254,7 @@ public void distinct_async_indexedLinkedFields() {
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field).findAllAsync();
+                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field).findAllAsync();
                 fail("Unsupported " + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3270,7 +3268,7 @@ public void distinct_async_notIndexedLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
         try {
-            realm.where(AllJavaTypes.class).distinctValues(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).findAllAsync();
+            realm.where(AllJavaTypes.class).distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).findAllAsync();
         } catch (IllegalArgumentException ignored) {
         }
         looperThread.testComplete();
@@ -3283,7 +3281,7 @@ public void distinctMultiArgs() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS).findAll();
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS).findAll();
         assertEquals(numberOfBlocks, distinctMulti.size());
     }
 
@@ -3293,8 +3291,8 @@ public void distinctMultiArgs_switchedFieldsOrder() {
         TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
 
         // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
-        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG).findAll();
-        RealmResults<AnnotationIndexTypes> distinctLongString = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
+        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG).findAll();
+        RealmResults<AnnotationIndexTypes> distinctLongString = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
         assertEquals(4, distinctStringLong.size());
         assertEquals(4, distinctLongString.size());
         assertEquals(distinctStringLong.size(), distinctLongString.size());
@@ -3309,47 +3307,47 @@ public void distinctMultiArgs_emptyField() {
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         // An empty string field in the middle.
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // An empty string field at the end.
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "").findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // A null string field in the middle.
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // A null string field at the end.
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null).findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // (String) Null makes varargs a null array.
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null).findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // Two (String) null for first and varargs fields.
         try {
-            query.distinctValues((String) null, (String) null).findAll();
+            query.distinct((String) null, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String) null combination.
         try {
-            query.distinctValues("", (String) null).findAll();
+            query.distinct("", (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String) null combination.
         try {
-            query.distinctValues((String) null, "").findAll();
+            query.distinct((String) null, "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // Two empty fields tests.
         try {
-            query.distinctValues("", "").findAll();
+            query.distinct("", "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3361,7 +3359,7 @@ public void distinctMultiArgs_withNullValues() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
         assertEquals(1, distinctMulti.size());
     }
 
@@ -3373,7 +3371,7 @@ public void distinctMultiArgs_notIndexedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS).findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3386,7 +3384,7 @@ public void distinctMultiArgs_doesNotExistField() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS).findAll();
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3397,7 +3395,7 @@ public void distinctMultiArgs_invalidTypesFields() {
 
         RealmQuery<AllTypes> query = realm.where(AllTypes.class);
         try {
-            query.distinctValues(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT).findAll();
+            query.distinct(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3410,7 +3408,7 @@ public void distinctMultiArgs_indexedLinkedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinctValues(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS).findAll();
+            query.distinct(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3423,7 +3421,7 @@ public void distinctMultiArgs_notIndexedLinkedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinctValues(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS).findAll();
+            query.distinct(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3434,7 +3432,7 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
 
         RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
         try {
-            query.distinctValues(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT).findAll();
+            query.distinct(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 4f2442b72e..25f5176911 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -209,7 +209,7 @@ public void getInstance_writeProtectedFile() throws IOException {
         assertTrue(realmFile.setWritable(false));
 
         try {
-            Realm.getInstance(new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+            Realm.getInstance(configFactory.createConfigurationBuilder()
                     .directory(folder)
                     .name(REALM_FILE)
                     .build());
@@ -229,7 +229,7 @@ public void getInstance_writeProtectedFileWithContext() throws IOException {
         assertTrue(realmFile.setWritable(false));
 
         try {
-            Realm.getInstance(new RealmConfiguration.Builder(context).directory(folder).name(REALM_FILE).build());
+            Realm.getInstance(configFactory.createConfigurationBuilder().directory(folder).name(REALM_FILE).build());
             fail();
         } catch (RealmFileException expected) {
             assertEquals(RealmFileException.Kind.PERMISSION_DENIED, expected.getKind());
@@ -283,6 +283,21 @@ public void where() {
         assertEquals(TEST_DATA_SIZE, resultList.size());
     }
 
+    @Test
+    public void where_throwsIfClassArgIsNotASubtype() {
+        try {
+            realm.where(RealmObject.class);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            realm.where(RealmModel.class);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
     // Note that this test is relying on the values set while initializing the test dataset
     // TODO Move to RealmQueryTests?
     @Test
@@ -1044,7 +1059,7 @@ public void compactRealm_populatedRealm() throws IOException {
     @Test
     public void compactRealm_onExternalStorage() {
         final File externalFilesDir = context.getExternalFilesDir(null);
-        final RealmConfiguration config = new RealmConfiguration.Builder()
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(externalFilesDir)
                 .name("external.realm")
                 .build();
@@ -2261,7 +2276,7 @@ public void deleteRealm() throws InterruptedException {
         File tempDirRenamed = new File(configFactory.getRoot(), "delete_test_dir_2");
         assertTrue(tempDir.mkdir());
 
-        final RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+        final RealmConfiguration configuration = configFactory.createConfigurationBuilder()
                 .directory(tempDir)
                 .build();
 
@@ -4232,7 +4247,7 @@ public void namedPipeDirForExternalStorage() {
         namedPipeDir.mkdirs();
 
         final File externalFilesDir = context.getExternalFilesDir(null);
-        final RealmConfiguration config = new RealmConfiguration.Builder()
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .directory(externalFilesDir)
                 .name("external.realm")
                 .build();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 91d961276d..6f41a48b9b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -571,7 +571,7 @@ public void sortByLongDistinctByInt() {
 
         // After distinct:
         // (3, 1, "C")
-        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
+        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinct(AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         assertEquals(1, results2.size());
         assertEquals("C", results2.get(0).getIndexString());
         assertEquals(3, results2.get(0).getIndexLong());
@@ -590,13 +590,13 @@ public void sortAndDistinctMixed() {
         // Case 1: Selecting highest numbers
         RealmResults<AnnotationIndexTypes> results1a = realm.where(AnnotationIndexTypes.class)
                 .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_INT)
                 .findAll();
         assertEquals(1, results1a.size());
         assertEquals(3, results1a.get(0).getIndexLong());
 
         RealmResults<AnnotationIndexTypes> results1b = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_INT)
                 .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
                 .findAll();
         assertEquals(1, results1b.size());
@@ -605,13 +605,13 @@ public void sortAndDistinctMixed() {
         // Case 1: Selecting lowest number numbers
         RealmResults<AnnotationIndexTypes> results2a = realm.where(AnnotationIndexTypes.class)
                 .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.ASCENDING)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_INT)
                 .findAll();
         assertEquals(1, results2a.size());
         assertEquals(1, results2a.get(0).getIndexLong());
 
         RealmResults<AnnotationIndexTypes> results2b = realm.where(AnnotationIndexTypes.class)
-                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .distinct(AnnotationIndexTypes.FIELD_INDEX_INT)
                 .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.ASCENDING)
                 .findAll();
         assertEquals(1, results2b.size());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index b2aaa7cc5a..957a1f196a 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -78,7 +78,7 @@ public void errorsNotWrapped() {
         SyncManager.setAuthServerImpl(authServer);
 
         try {
-            SyncUser.login(SyncCredentials.facebook("foo"), "http://foo.bar/auth");
+            SyncUser.logIn(SyncCredentials.facebook("foo"), "http://foo.bar/auth");
             fail();
         } catch (ObjectServerError e) {
             assertEquals(ErrorCode.ACCESS_DENIED, e.getErrorCode());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
new file mode 100644
index 0000000000..111733af79
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
@@ -0,0 +1,535 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.annotations.RealmModule;
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.Dog;
+import io.realm.exceptions.RealmException;
+import io.realm.rule.RunInLooperThread;
+import io.realm.sync.permissions.ClassPermissions;
+import io.realm.sync.permissions.ClassPrivileges;
+import io.realm.sync.permissions.ObjectPrivileges;
+import io.realm.sync.permissions.Permission;
+import io.realm.sync.permissions.RealmPermissions;
+import io.realm.sync.permissions.RealmPrivileges;
+import io.realm.sync.permissions.Role;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ObjectLevelPermissionsTest {
+
+    private static String REALM_URI = "realm://objectserver.realm.io/~/default";
+
+    private SyncConfiguration configuration;
+    private SyncUser user;
+
+    @Rule
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+
+    @RealmModule(classes = { AllJavaTypes.class })
+    public static class TestModule {
+    }
+
+    @Before
+    public void setUp() {
+        user = createTestUser();
+        configuration = new SyncConfiguration.Builder(user, REALM_URI)
+                .partialRealm()
+                .modules(new TestModule())
+                .build();
+        realm = Realm.getInstance(configuration);
+        dynamicRealm = DynamicRealm.getInstance(configuration);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
+        if (dynamicRealm != null && !dynamicRealm.isClosed()) {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void getPrivileges_realm_localDefaults() {
+        RealmPrivileges privileges = realm.getPrivileges();
+        assertFullAccess(privileges);
+
+        privileges = dynamicRealm.getPrivileges();
+        assertFullAccess(privileges);
+    }
+
+    @Test
+    public void getPrivileges_realm_revokeLocally() {
+        realm.executeTransaction(r -> {
+           Role role = realm.getRoles().where().equalTo("name", "everyone").findFirst();
+           role.removeMember(user.getIdentity());
+        });
+
+        RealmPrivileges privileges = realm.getPrivileges();
+        assertNoAccess(privileges);
+
+        privileges = dynamicRealm.getPrivileges();
+        assertNoAccess(privileges);
+    }
+
+    @Test
+    public void getPrivileges_class_localDefaults() {
+        ClassPrivileges privileges = realm.getPrivileges(AllJavaTypes.class);
+        assertFullAccess(privileges);
+
+        privileges = dynamicRealm.getPrivileges(AllJavaTypes.CLASS_NAME);
+        assertFullAccess(privileges);
+    }
+
+    @Test
+    public void getPrivileges_class_revokeLocally() {
+        realm.executeTransaction(r -> {
+            Role role = realm.getRoles().where().equalTo("name", "everyone").findFirst();
+            role.removeMember(user.getIdentity());
+        });
+
+        ClassPrivileges privileges = realm.getPrivileges(AllJavaTypes.class);
+        assertNoAccess(privileges);
+
+        privileges = dynamicRealm.getPrivileges(AllJavaTypes.CLASS_NAME);
+        assertNoAccess(privileges);
+    }
+
+    @Test
+    public void getPrivileges_object_localDefaults() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
+        realm.commitTransaction();
+        assertFullAccess(realm.getPrivileges(obj));
+
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject dynamicObject = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1);
+        dynamicRealm.commitTransaction();
+        assertFullAccess(dynamicRealm.getPrivileges(dynamicObject));
+    }
+
+    @Test
+    public void getPrivileges_object_revokeLocally() {
+        realm.executeTransaction(r -> {
+            Role role = realm.getRoles().where().equalTo("name", "everyone").findFirst();
+            role.removeMember(user.getIdentity());
+        });
+
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
+        realm.commitTransaction();
+        assertNoAccess(realm.getPrivileges(obj));
+
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject dynamicObject = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1);
+        dynamicRealm.commitTransaction();
+        assertNoAccess(dynamicRealm.getPrivileges(dynamicObject));
+    }
+
+    @Test
+    public void getPrivileges_closedRealmThrows() {
+        realm.close();
+        try {
+            realm.getPrivileges();
+            fail();
+        } catch(IllegalStateException ignored) {
+        }
+
+        try {
+            realm.getPrivileges(AllJavaTypes.class);
+            fail();
+        } catch(IllegalStateException ignored) {
+        }
+
+        try {
+            //noinspection ConstantConditions
+            realm.getPrivileges((RealmModel) null);
+            fail();
+        } catch(IllegalStateException ignored) {
+        }
+
+        dynamicRealm.close();
+        try {
+            dynamicRealm.getPrivileges();
+            fail();
+        } catch(IllegalStateException ignored) {
+        }
+
+        try {
+            dynamicRealm.getPrivileges(AllJavaTypes.CLASS_NAME);
+            fail();
+        } catch(IllegalStateException ignored) {
+        }
+
+        try {
+            //noinspection ConstantConditions
+            dynamicRealm.getPrivileges((RealmModel) null);
+            fail();
+        } catch(IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void getPrivileges_wrongThreadThrows() throws InterruptedException {
+        Thread thread = new Thread(() -> {
+            try {
+                realm.getPrivileges();
+                fail();
+            } catch(IllegalStateException ignored) {
+            }
+
+            try {
+                realm.getPrivileges(AllJavaTypes.class);
+                fail();
+            } catch(IllegalStateException ignored) {
+            }
+
+            try {
+                //noinspection ConstantConditions
+                realm.getPrivileges((RealmModel) null);
+                fail();
+            } catch(IllegalStateException ignored) {
+            }
+
+            try {
+                dynamicRealm.getPrivileges();
+                fail();
+            } catch(IllegalStateException ignored) {
+            }
+
+            try {
+                dynamicRealm.getPrivileges(AllJavaTypes.CLASS_NAME);
+                fail();
+            } catch(IllegalStateException ignored) {
+            }
+
+            try {
+                //noinspection ConstantConditions
+                dynamicRealm.getPrivileges((RealmModel) null);
+                fail();
+            } catch(IllegalStateException ignored) {
+            }
+        });
+        thread.start();
+        thread.join(TestHelper.STANDARD_WAIT_SECS * 1000);
+    }
+
+    @Test
+    public void getPrivileges_class_notPartofSchemaThrows() {
+        try {
+            realm.getPrivileges(Dog.class);
+            fail();
+        } catch (RealmException ignore) {
+        }
+
+        try {
+            dynamicRealm.getPrivileges("Dog");
+            fail();
+        } catch (RealmException ignore) {
+        }
+    }
+
+    @Test
+    public void getPrivileges_class_nullThrows() {
+        try {
+            //noinspection ConstantConditions
+            realm.getPrivileges((Class<? extends RealmModel>) null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            //noinspection ConstantConditions
+            dynamicRealm.getPrivileges((String) null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void getPrivileges_object_nullThrows() {
+        try {
+            //noinspection ConstantConditions
+            realm.getPrivileges((RealmModel) null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            //noinspection ConstantConditions
+            dynamicRealm.getPrivileges((DynamicRealmObject) null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void getPrivileges_object_unmanagedThrows() {
+        // DynamicRealm do not support unmanaged DynamicRealmObjects
+        realm.getPrivileges(new AllJavaTypes(0));
+    }
+
+    @Test
+    public void getPrivileges_object_wrongRealmThrows() {
+        Realm otherRealm = Realm.getInstance(configFactory.createConfiguration("other"));
+        otherRealm.beginTransaction();
+        AllJavaTypes obj = otherRealm.createObject(AllJavaTypes.class, 0);
+        try {
+            realm.getPrivileges(obj);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            otherRealm.close();
+        }
+    }
+
+
+    @Test
+    public void getPermissions() {
+        // Typed RealmPermissions
+        RealmPermissions realmPermissions = realm.getPermissions();
+        RealmList<Permission> list = realmPermissions.getPermissions();
+        assertEquals(1, list.size());
+        assertEquals("everyone", list.first().getRole().getName());
+        assertFullAccess(list.first());
+
+//        // FIXME: Dynamic RealmPermissions - Until support is enabled
+//        realmPermissions = dynamicRealm.getPermissions();
+//        list = realmPermissions.getPermissions();
+//        assertEquals(1, list.size());
+//        assertEquals("everyone", list.first().getRole().getName());
+//        assertFullAccess(list.first());
+    }
+
+    @Test
+    public void getPermissions_wrongThreadThrows() throws InterruptedException {
+        Thread t = new Thread(() -> {
+            try {
+                realm.getPermissions();
+                fail();
+            } catch (IllegalStateException ignore) {
+            }
+
+// FIXME: Disabled until support is enabled
+//            try {
+//                dynamicRealm.getPermissions();
+//                fail();
+//            } catch (IllegalStateException ignore) {
+//            }
+        });
+        t.start();
+        t.join(TestHelper.STANDARD_WAIT_SECS * 1000);
+    }
+
+    @Test
+    public void getPermissions_closedRealmThrows() {
+        realm.close();
+        try {
+            realm.getPermissions();
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+
+// FIXME Disabled until support is enabled
+//        dynamicRealm.close();
+//        try {
+//            dynamicRealm.getPermissions();
+//            fail();
+//        } catch (IllegalStateException ignore) {
+//        }
+    }
+
+    @Test
+    public void getClassPermissions() {
+        // Typed RealmPermissions
+        ClassPermissions classPermissions = realm.getPermissions(AllJavaTypes.class);
+        assertEquals("AllJavaTypes", classPermissions.getName());
+        RealmList<Permission> list = classPermissions.getPermissions();
+        assertEquals(1, list.size());
+        assertEquals("everyone", list.first().getRole().getName());
+        assertFullAccess(list.first());
+
+        // FIXME: Dynamic RealmPermissions - Disabled until support is enabled
+//        classPermissions = dynamicRealm.getPermissions(AllJavaTypes.CLASS_NAME);
+//        assertEquals("AllJavaTypes", classPermissions.getName());
+//        list = classPermissions.getPermissions();
+//        assertEquals(1, list.size());
+//        assertEquals("everyone", list.first().getRole().getName());
+//        assertDefaultAccess(list.first());
+    }
+
+    @Test
+    public void getClassPermissions_wrongThreadThrows() throws InterruptedException {
+        Thread t = new Thread(() -> {
+            try {
+                realm.getPermissions(AllJavaTypes.class);
+                fail();
+            } catch (IllegalStateException ignore) {
+            }
+
+// FIXME: Disabled until support is enabled
+//            try {
+//                dynamicRealm.getPermissions(AllJavaTypes.CLASS_NAME);
+//                fail();
+//            } catch (IllegalStateException ignore) {
+//            }
+        });
+        t.start();
+        t.join(TestHelper.STANDARD_WAIT_SECS * 1000);
+    }
+
+    @Test
+    public void getClassPermissions_closedRealmThrows() {
+        realm.close();
+        try {
+            realm.getPermissions(AllJavaTypes.class);
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+
+// FIXME: Disabled until support is enabled
+//        dynamicRealm.close();
+//        try {
+//            dynamicRealm.getPermissions(AllJavaTypes.CLASS_NAME);
+//            fail();
+//        } catch (IllegalStateException ignore) {
+//        }
+    }
+
+    @Test
+    public void getRoles() {
+        RealmResults<Role> roles = realm.getRoles();
+        assertEquals(2, roles.size());
+
+        roles = roles.where().sort("name").findAll();
+        Role role = roles.get(0);
+        assertEquals("__User:" + user.getIdentity(), role.getName());
+        assertTrue(role.hasMember(user.getIdentity()));
+
+        role = roles.get(1);
+        assertEquals("everyone", role.getName());
+        assertTrue(role.hasMember(user.getIdentity()));
+
+    }
+
+    @Test
+    public void getRoles_wrongThreadThrows() throws InterruptedException {
+        Thread t = new Thread(() -> {
+            try {
+                realm.getRoles();
+                fail();
+            } catch (IllegalStateException ignore) {
+            }
+        });
+        t.start();
+        t.join(TestHelper.STANDARD_WAIT_SECS * 1000);
+
+    }
+
+    @Test
+    public void getRoles_closedRealmThrows() {
+        realm.close();
+        try {
+            realm.getRoles();
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+
+// FIXME: Until support is enabled
+//        dynamicRealm.close();
+//        try {
+//            dynamicRealm.getRoles();
+//            fail();
+//        } catch (IllegalStateException ignore) {
+//        }
+    }
+
+    private void assertFullAccess(RealmPrivileges privileges) {
+        assertTrue(privileges.canRead());
+        assertTrue(privileges.canUpdate());
+        assertTrue(privileges.canSetPermissions());
+        assertTrue(privileges.canModifySchema());
+    }
+
+    private void assertFullAccess(ClassPrivileges privileges) {
+        assertTrue(privileges.canCreate());
+        assertTrue(privileges.canRead());
+        assertTrue(privileges.canUpdate());
+        assertTrue(privileges.canQuery());
+        assertTrue(privileges.canSetPermissions());
+    }
+
+    private void assertFullAccess(ObjectPrivileges privileges) {
+        assertTrue(privileges.canRead());
+        assertTrue(privileges.canUpdate());
+        assertTrue(privileges.canDelete());
+        assertTrue(privileges.canSetPermissions());
+    }
+
+    private void assertFullAccess(Permission permission) {
+        assertTrue(permission.canCreate());
+        assertTrue(permission.canRead());
+        assertTrue(permission.canUpdate());
+        assertTrue(permission.canDelete());
+        assertTrue(permission.canQuery());
+        assertTrue(permission.canSetPermissions());
+        assertTrue(permission.canModifySchema());
+    }
+
+    private void assertNoAccess(RealmPrivileges privileges) {
+        assertFalse(privileges.canRead());
+        assertFalse(privileges.canUpdate());
+        assertFalse(privileges.canSetPermissions());
+        assertFalse(privileges.canModifySchema());
+    }
+
+    private void assertNoAccess(ClassPrivileges privileges) {
+        assertFalse(privileges.canCreate());
+        assertFalse(privileges.canRead());
+        assertFalse(privileges.canUpdate());
+        assertFalse(privileges.canQuery());
+        assertFalse(privileges.canSetPermissions());
+    }
+
+    private void assertNoAccess(ObjectPrivileges privileges) {
+        assertFalse(privileges.canRead());
+        assertFalse(privileges.canUpdate());
+        assertFalse(privileges.canDelete());
+        assertFalse(privileges.canSetPermissions());
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index e4144720b5..c9caeaedc9 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -31,6 +31,7 @@
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.sync.permissions.ObjectPermissionsModule;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
@@ -64,7 +65,7 @@
     @Before
     public void setUp() {
         user = createTestUser();
-        configuration = new SyncConfiguration.Builder(user, REALM_URI).build();
+        configuration = new SyncConfiguration.Builder(user, REALM_URI).addModule(new ObjectPermissionsModule()).build();
     }
 
     @Test
@@ -193,6 +194,7 @@ public void errorHandler_useBackupSyncConfigurationForClientReset() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .schema(StringOnly.class)
                 .errorHandler((session, error) -> {
                     if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
                         fail("Wrong error " + error.toString());
@@ -275,7 +277,7 @@ public void errorHandler_useBackupSyncConfigurationAfterClientReset() {
                     try {
                         Realm.getInstance(backupRealmConfiguration);
                         fail("Expected to throw a Migration required");
-                    } catch (RealmMigrationNeededException expected) {
+                    } catch (IllegalStateException expected) {
                     }
 
                     // opening a DynamicRealm will work though
@@ -334,6 +336,7 @@ public void errorHandler_useClientResetEncrypted() {
         final byte[] randomKey = TestHelper.getRandomKey();
         final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                 .encryptionKey(randomKey)
+                .modules(new StringOnlyModule())
                 .errorHandler((session, error) -> {
                     if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
                         fail("Wrong error " + error.toString());
@@ -372,7 +375,6 @@ public void errorHandler_useClientResetEncrypted() {
 
                     looperThread.testComplete();
                 })
-                .modules(new StringOnlyModule())
                 .build();
 
         Realm realm = Realm.getInstance(config);
@@ -416,8 +418,7 @@ public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedExcept
     @UiThreadTest
     public void unrecognizedErrorCode_errorHandler() {
         AtomicBoolean errorHandlerCalled = new AtomicBoolean(false);
-        configuration = new SyncConfiguration
-                .Builder(user, REALM_URI)
+        configuration = configFactory.createSyncConfigurationBuilder(user, REALM_URI)
                 .errorHandler((session, error) -> {
                     errorHandlerCalled.set(true);
                     assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 922044f17d..fe5195774f 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -29,11 +29,14 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.net.URI;
 import java.util.HashMap;
 import java.util.Map;
 
 import io.realm.entities.StringOnly;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
+import io.realm.util.SyncTestUtils;
 
 import static io.realm.util.SyncTestUtils.createNamedTestUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
@@ -59,7 +62,10 @@
     public final ExpectedException thrown = ExpectedException.none();
 
     @After
-    public void tearDown() throws Exception {
+    public void tearDown() {
+        for (SyncUser syncUser : SyncUser.all().values()) {
+            syncUser.logOut();
+        }
         SyncManager.reset();
     }
 
@@ -446,9 +452,9 @@ public void multipleUsersReferenceSameRealm() {
         SyncUser user1 = createNamedTestUser("user1");
         SyncUser user2 = createNamedTestUser("user2");
         String sharedUrl = "realm://ros.realm.io/42/default";
-        SyncConfiguration config1 = new SyncConfiguration.Builder(user1, sharedUrl).build();
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user1, sharedUrl).modules(new StringOnlyModule()).build();
         Realm realm1 = Realm.getInstance(config1);
-        SyncConfiguration config2 = new SyncConfiguration.Builder(user2, sharedUrl).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user2, sharedUrl).modules(new StringOnlyModule()).build();
         Realm realm2 = null;
 
         // Verify that two different configurations can be used for the same URL
@@ -465,4 +471,82 @@ public void multipleUsersReferenceSameRealm() {
         assertNotEquals(config1.getPath(), config2.getPath());
     }
 
+    @Test
+    public void automatic_throwsIfNoUserIsLoggedIn() {
+        try {
+            SyncConfiguration.automatic();
+            fail();
+        } catch (IllegalStateException e) {
+            assertTrue(e.getMessage().startsWith("No user was logged in"));
+        }
+    }
+
+    @Test
+    public void automatic_throwsIfMultipleUsersIsLoggedIn() {
+        SyncTestUtils.createTestUser();
+        SyncTestUtils.createTestUser();
+        try {
+            SyncConfiguration.automatic();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals("Current user is not valid if more that one valid, logged-in user exists.", e.getMessage());
+        }
+    }
+
+    @Test
+    public void automaticWithUser_throwsIfNullOrInvalid() {
+        try {
+            //noinspection ConstantConditions
+            SyncConfiguration.automatic(null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().startsWith("Non-null 'user' required."));
+        }
+        SyncUser user = SyncTestUtils.createTestUser();
+        user.logOut();
+        try {
+            SyncConfiguration.automatic(user);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("User is no logger valid.  Log the user in again.", e.getMessage());
+        }
+    }
+
+    @Test
+    public void automatic_isPartial() {
+        SyncUser user = SyncTestUtils.createTestUser();
+
+        SyncConfiguration config = SyncConfiguration.automatic();
+        assertTrue(config.isPartialRealm());
+
+        config = SyncConfiguration.automatic(user);
+        assertTrue(config.isPartialRealm());
+    }
+
+    @Test
+    public void automatic_convertsAuthUrl() {
+        Object[][] input = {
+                // AuthUrl -> Expected Realm URL
+                { "http://ros.realm.io/auth", "realm://ros.realm.io/default" },
+                { "http://ros.realm.io:7777", "realm://ros.realm.io/default" },
+                { "http://127.0.0.1/auth", "realm://127.0.0.1/default" },
+                { "HTTP://ros.realm.io" , "realm://ros.realm.io/default" },
+
+                { "https://ros.realm.io/auth", "realms://ros.realm.io/default" },
+                { "https://ros.realm.io:7777", "realms://ros.realm.io/default" },
+                { "https://127.0.0.1/auth", "realms://127.0.0.1/default" },
+                { "HTTPS://ros.realm.io" , "realms://ros.realm.io/default" },
+        };
+
+        for (Object[] test : input) {
+            String authUrl = (String) test[0];
+            String realmUrl = (String) test[1];
+
+            SyncUser user = SyncTestUtils.createTestUser(authUrl);
+            SyncConfiguration config = SyncConfiguration.automatic();
+            URI url = config.getServerUrl();
+            assertEquals(realmUrl, url.toString());
+            user.logOut();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 839c935b31..89c13dd672 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -29,6 +29,7 @@
 import java.util.Collection;
 import java.util.Collections;
 
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -159,6 +160,7 @@ public void session() throws IOException {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .modules(new StringOnlyModule())
                 .build();
         // This will trigger the creation of the session
         Realm realm = Realm.getInstance(config);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 6fb7dee8b5..603eae46ae 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -43,6 +43,7 @@
 import java.util.Map;
 import java.util.UUID;
 
+import io.realm.entities.AllTypesModelModule;
 import io.realm.entities.StringOnly;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
@@ -140,8 +141,8 @@ public void equals_validUser() {
     public void equals_loggedOutUser() {
         final SyncUser user1 = createFakeUser("id_value");
         final SyncUser user2 = createFakeUser("id_value");
-        user1.logout();
-        user2.logout();
+        user1.logOut();
+        user2.logOut();
         assertTrue(user1.equals(user2));
     }
 
@@ -154,7 +155,7 @@ public void hashCode_validUser() {
     @Test
     public void hashCode_loggedOutUser() {
         final SyncUser user = createFakeUser("id_value");
-        user.logout();
+        user.logOut();
         assertNotEquals(0, user.hashCode());
     }
 
@@ -173,7 +174,7 @@ public void currentUser_returnsNullIfUserExpired() {
         userStore.put(SyncTestUtils.createTestUser(Long.MIN_VALUE));
 
         // Invalid users should not be returned when asking the for the current user
-        assertNull(SyncUser.currentUser());
+        assertNull(SyncUser.current());
     }
 
     @Test
@@ -190,12 +191,12 @@ public AuthenticateResponse answer(InvocationOnMock invocationOnMock) throws Thr
                     return getNewRandomUser();
                 }
             });
-            SyncUser.login(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
-            SyncUser.login(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
+            SyncUser.logIn(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
+            SyncUser.logIn(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
 
-            // 2. Verify currentUser() now throws
+            // 2. Verify current() now throws
             try {
-                SyncUser.currentUser();
+                SyncUser.current();
                 fail();
             } catch (IllegalStateException ignore) {
             }
@@ -219,11 +220,11 @@ public void currentUser_clearedOnLogout() {
         UserStore userStore = SyncManager.getUserStore();
         userStore.put(user);
 
-        SyncUser savedUser = SyncUser.currentUser();
+        SyncUser savedUser = SyncUser.current();
         assertEquals(user, savedUser);
         assertNotNull(savedUser);
-        savedUser.logout();
-        assertNull(SyncUser.currentUser());
+        savedUser.logOut();
+        assertNull(SyncUser.current());
     }
 
     // `all()` returns an empty list if no users are logged in
@@ -274,8 +275,8 @@ public void currentUser_returnsUserAfterLogin() {
         AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
         when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
 
-        SyncUser user = SyncUser.login(SyncCredentials.facebook("foo"), "http://bar.com/auth");
-        assertEquals(user, SyncUser.currentUser());
+        SyncUser user = SyncUser.logIn(SyncCredentials.facebook("foo"), "http://bar.com/auth");
+        assertEquals(user, SyncUser.current());
     }
 
     @Test
@@ -294,7 +295,7 @@ public void login_withAccessToken() {
         SyncManager.setAuthServerImpl(authServer);
         try {
             SyncCredentials credentials = SyncCredentials.accessToken("foo", "bar");
-            SyncUser user = SyncUser.login(credentials, "http://ros.realm.io/auth");
+            SyncUser user = SyncUser.logIn(credentials, "http://ros.realm.io/auth");
             assertTrue(user.isValid());
         } finally {
             SyncManager.setAuthServerImpl(originalServer);
@@ -323,9 +324,9 @@ public void login_appendAuthSegment() {
                 String input = url[0];
                 String normalizedInput = url[1];
                 SyncCredentials credentials = SyncCredentials.accessToken("token", UUID.randomUUID().toString());
-                SyncUser user = SyncUser.login(credentials, input);
+                SyncUser user = SyncUser.logIn(credentials, input);
                 assertEquals(normalizedInput, user.getAuthenticationUrl().toString());
-                user.logout();
+                user.logOut();
             }
         } finally {
             SyncManager.setAuthServerImpl(originalServer);
@@ -445,8 +446,8 @@ public void getPermissionManger_instanceUniqueToUser() {
         } finally {
             pm1.close();
             pm2.close();
-            user1.logout();
-            user2.logout();
+            user1.logOut();
+            user2.logOut();
         }
     }
 
@@ -468,7 +469,7 @@ public void allSessions() {
         SyncUser user = createTestUser();
         assertEquals(0, user.allSessions().size());
 
-        SyncConfiguration configuration1 = new SyncConfiguration.Builder(user, url1).build();
+        SyncConfiguration configuration1 = new SyncConfiguration.Builder(user, url1).modules(new AllTypesModelModule()).build();
         Realm realm1 = Realm.getInstance(configuration1);
         List<SyncSession> allSessions = user.allSessions();
         assertEquals(1, allSessions.size());
@@ -477,7 +478,7 @@ public void allSessions() {
         assertEquals(user, session.getUser());
         assertEquals(url1, session.getServerUrl().toString());
 
-        SyncConfiguration configuration2 = new SyncConfiguration.Builder(user, url2).build();
+        SyncConfiguration configuration2 = new SyncConfiguration.Builder(user, url2).modules(new AllTypesModelModule()).build();
         Realm realm2 = Realm.getInstance(configuration2);
         allSessions = user.allSessions();
         assertEquals(2, allSessions.size());
@@ -552,7 +553,7 @@ public void execute(Realm realm) {
                 realm.createObject(StringOnly.class).setChars("1");
             }
         });
-        user.logout();
+        user.logOut();
         realm.close();
 
         final File realmPath = new File (syncConfiguration.getPath());
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
new file mode 100644
index 0000000000..6c6cab9b26
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.objectserver.model.PartialSyncObjectA;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.fail;
+
+/**
+ * Testing sync specific methods on {@link Realm}.
+ */
+@RunWith(AndroidJUnit4.class)
+public class SyncedRealmTests {
+
+    @Rule
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+
+    @After
+    public void tearDown() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
+    }
+
+    private Realm getNormalRealm() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+        return realm;
+    }
+
+    private Realm getPartialRealm() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/fullsync")
+                .partialRealm()
+                .build();
+        realm = Realm.getInstance(config);
+        return realm;
+    }
+
+    private Realm getFullySyncRealm() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/fullsync")
+                .build();
+        realm = Realm.getInstance(config);
+        return realm;
+    }
+
+    @Test
+    public void unsubscribeAsync_nullOrEmptyArgumentsThrows() {
+        Realm realm = getPartialRealm();
+        Realm.UnsubscribeCallback callback = new Realm.UnsubscribeCallback() {
+            @Override
+            public void onSuccess(String subscriptionName) {
+            }
+
+            @Override
+            public void onError(String subscriptionName, Throwable error) {
+            }
+        };
+
+        try {
+            //noinspection ConstantConditions
+            realm.unsubscribeAsync(null, callback);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            realm.unsubscribeAsync("", callback);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            //noinspection ConstantConditions
+            realm.unsubscribeAsync("my-id", null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void unsubscribeAsync_nonLooperThreadThrows() {
+        Realm realm = getPartialRealm();
+        Realm.UnsubscribeCallback callback = new Realm.UnsubscribeCallback() {
+            @Override
+            public void onSuccess(String subscriptionName) {
+            }
+
+            @Override
+            public void onError(String subscriptionName, Throwable error) {
+            }
+        };
+
+        try {
+            //noinspection ConstantConditions
+            realm.unsubscribeAsync("my-id", callback);
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void unsubscribeAsync_nonPartialRealmThrows() {
+        Realm.UnsubscribeCallback callback = new Realm.UnsubscribeCallback() {
+            @Override
+            public void onSuccess(String subscriptionName) {
+            }
+
+            @Override
+            public void onError(String subscriptionName, Throwable error) {
+            }
+        };
+
+        Realm realm = getNormalRealm();
+        try {
+            //noinspection ConstantConditions
+            realm.unsubscribeAsync("my-id", callback);
+            fail();
+        } catch (UnsupportedOperationException ignore) {
+        } finally {
+            realm.close();
+        }
+
+        realm = getFullySyncRealm();
+        try {
+            //noinspection ConstantConditions
+            realm.unsubscribeAsync("my-id", callback);
+            fail();
+        } catch (UnsupportedOperationException ignore) {
+        } finally {
+            realm.close();
+        }
+
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void delete_throws() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+            try {
+                realm.deleteAll();
+                fail();
+            } catch (IllegalStateException e) {
+            }
+
+            try {
+                realm.delete(PartialSyncObjectA.class);
+                fail();
+            } catch (IllegalStateException e) {
+            }
+        realm.cancelTransaction();
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        try {
+            dynamicRealm.beginTransaction();
+            try {
+                dynamicRealm.delete(PartialSyncObjectA.class.getSimpleName());
+                fail();
+            } catch (IllegalStateException e) {
+            }
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
index 9e7573c865..36d0625db0 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
@@ -17,6 +17,7 @@
 package io.realm;
 
 import io.realm.internal.OsRealmConfig;
+import io.realm.internal.sync.permissions.ObjectPermissionsModule;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 /**
@@ -28,6 +29,7 @@
     public SyncConfiguration.Builder createSyncConfigurationBuilder(SyncUser user, String url) {
         return new SyncConfiguration.Builder(user, url)
                 .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .addModule(new ObjectPermissionsModule())
                 .directory(getRoot());
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index 97caaa18bd..61a1dbd3a0 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -25,7 +25,10 @@
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.UserStore;
 import io.realm.internal.network.AuthenticateResponse;
@@ -125,4 +128,18 @@ private static void addToUserStore(SyncUser user) {
             throw new AssertionError(e);
         }
     }
+
+    // Fully synchronize a Realm with the server by making sure that all changes are uploaded
+    // and downloaded again.
+    public static void syncRealm(Realm realm) {
+        SyncConfiguration config = (SyncConfiguration) realm.getConfiguration();
+        SyncSession session = SyncManager.getSession(config);
+        try {
+            session.uploadAllLocalChanges();
+            session.downloadAllServerChanges();
+        } catch (InterruptedException e) {
+            throw new AssertionError(e);
+        }
+        realm.refresh();
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index e099fe82b7..aa67d94199 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -63,7 +63,7 @@ set(classes_LIST
     io.realm.internal.OsObjectSchemaInfo io.realm.internal.OsResults
     io.realm.internal.NativeObjectReference io.realm.internal.OsCollectionChangeSet
     io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
-    io.realm.internal.OsObjectStore
+    io.realm.internal.OsObjectStore io.realm.internal.sync.OsSubscription
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
@@ -170,6 +170,7 @@ if (NOT build_SYNC)
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_RealmFileUserStore.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncManager.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncSession.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_internal_sync_OsSubscription.cpp
     )
 endif()
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp
index 807ce9afa2..e79ae3f0d8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp
@@ -87,7 +87,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeGetFi
 }
 
 JNIEXPORT jintArray JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeGetRanges(JNIEnv* env, jclass,
-                                                                                       jlong native_ptr, jint type)
+                                                                                         jlong native_ptr, jint type)
 {
     TR_ENTER_PTR(native_ptr)
     // no throws
@@ -105,7 +105,7 @@ JNIEXPORT jintArray JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeG
 }
 
 JNIEXPORT jintArray JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeGetIndices(JNIEnv* env, jclass,
-                                                                                        jlong native_ptr, jint type)
+                                                                                          jlong native_ptr, jint type)
 {
     TR_ENTER_PTR(native_ptr)
     // no throws
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index 8d07d997ce..66278fbcfd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -20,6 +20,8 @@
 #if REALM_ENABLE_SYNC
 #include <realm/sync/object.hpp>
 #endif
+#include <realm/util/to_string.hpp>
+
 #include <object_schema.hpp>
 #include <object.hpp>
 #include <shared_realm.hpp>
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
index 560eb31f52..9c3670b388 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
@@ -19,6 +19,7 @@
 #include <shared_realm.hpp>
 #include <results.hpp>
 #include <list.hpp>
+#include <realm/util/optional.hpp>
 
 #include "java_class_global_def.hpp"
 #include "java_sort_descriptor.hpp"
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsSharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsSharedRealm.cpp
index 1baf6190b7..034578b0b5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsSharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsSharedRealm.cpp
@@ -510,52 +510,48 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsSharedRealm_nativeRegisterSchema
     }
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_OsSharedRealm_nativeRegisterPartialSyncQuery(
-    REALM_UNUSED JNIEnv* env, REALM_UNUSED jobject j_shared_realm_instance, REALM_UNUSED jlong shared_realm_ptr, REALM_UNUSED jstring j_class_name,
-    REALM_UNUSED jstring j_query, REALM_UNUSED jobject j_callback)
+#if REALM_ENABLE_SYNC
+JNIEXPORT jint JNICALL Java_io_realm_internal_OsSharedRealm_nativeGetRealmPrivileges(
+    JNIEnv*, jclass, jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return static_cast<jint>(shared_realm->get_privileges());
+}
 
-#if REALM_ENABLE_SYNC
+JNIEXPORT jint JNICALL Java_io_realm_internal_OsSharedRealm_nativeGetClassPrivileges(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jstring j_class_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name(env, j_class_name);
+        return static_cast<jint>(shared_realm->get_privileges(StringData(class_name)));
+    }
+    CATCH_STD()
+    return 0;
+}
 
-    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+JNIEXPORT jint JNICALL Java_io_realm_internal_OsSharedRealm_nativeGetObjectPrivileges(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jlong row_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
     try {
-        JStringAccessor class_name(env, j_class_name);               // throws
-        JStringAccessor query(env, j_query);                         // throws
-
-        // The lambda will capture the copied reference and it will be unreferenced when the lambda's life cycle is over.
-        // That happens when the Realm is closed or the callback has been triggered once.
-        JavaGlobalRef j_callback_ref(env, j_callback);
-        JavaGlobalWeakRef j_shared_realm_instance_ref(env, j_shared_realm_instance);
-
-        static JavaClass shared_realm_class(env, "io/realm/internal/OsSharedRealm");
-        static JavaMethod partial_sync_cb(env, shared_realm_class, "runPartialSyncRegistrationCallback",
-                                          "(Ljava/lang/String;JLio/realm/internal/OsSharedRealm$PartialSyncCallback;)V");
-
-        auto cb = [j_callback_ref, j_shared_realm_instance_ref](Results results, std::exception_ptr err) {
-            JNIEnv* env = JniUtils::get_env(true);
-            j_shared_realm_instance_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
-                if (err) {
-                    try {
-                        std::rethrow_exception(err);
-                    }
-                    catch (const std::exception& e) {
-                        env->CallVoidMethod(row_obj, partial_sync_cb, to_jstring(env, e.what()),
-                                            reinterpret_cast<jlong>(nullptr), j_callback_ref.get());
-                    }
-                    return;
-                }
-
-                auto wrapper = new ResultsWrapper(results);
-                env->CallVoidMethod(row_obj, partial_sync_cb, nullptr, reinterpret_cast<jlong>(wrapper),
-                                    j_callback_ref.get());
-            });
-        };
-
-        partial_sync::register_query(shared_realm, class_name, query, std::move(cb));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto r = reinterpret_cast<Row*>(row_ptr);
+        RowExpr row = r->get_table()->get(r->get_index());
+
+        return static_cast<jint>(shared_realm->get_privileges(row));
     }
     CATCH_STD()
-#else
-    REALM_TERMINATE("Unsupported operation. Only available when used with the Realm Object Server");
+    return 0;
+}
 #endif
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsSharedRealm_nativeIsPartial(JNIEnv*, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    // No throws
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return to_jbool(shared_realm->is_partial());
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 346d614e57..d85ad5e1d9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -20,12 +20,13 @@
 #include "io_realm_internal_Property.h"
 #include "io_realm_internal_Table.h"
 
-#include "shared_realm.hpp"
-
 #include "java_accessor.hpp"
 #include "java_exception_def.hpp"
+#include "shared_realm.hpp"
 #include "jni_util/java_exception_thrower.hpp"
 
+#include <realm/util/to_string.hpp>
+
 using namespace std;
 using namespace realm;
 using namespace realm::_impl;
@@ -536,13 +537,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize(JNIEnv* env, job
     return static_cast<jlong>(TBL(nativeTablePtr)->size()); // noexcept
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear(JNIEnv* env, jobject, jlong nativeTablePtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear(JNIEnv* env, jobject, jlong nativeTablePtr, jboolean is_partial_realm)
 {
     if (!TABLE_VALID(env, TBL(nativeTablePtr))) {
         return;
     }
     try {
-        TBL(nativeTablePtr)->clear();
+        if (is_partial_realm) {
+            TBL(nativeTablePtr)->where().find_all().clear(RemoveMode::unordered);
+        } else {
+            TBL(nativeTablePtr)->clear();
+        }
     }
     CATCH_STD()
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
new file mode 100644
index 0000000000..5f9641eea1
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "io_realm_internal_sync_OsSubscription.h"
+
+#include "java_class_global_def.hpp"
+#include "observable_collection_wrapper.hpp"
+#include "util.hpp"
+#include "subscription_wrapper.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_method.hpp"
+
+#include <results.hpp>
+#include <sync/partial_sync.hpp>
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::_impl;
+
+typedef ObservableCollectionWrapper<Results> ResultsWrapper;
+
+static void finalize_subscription(jlong ptr);
+
+static void finalize_subscription(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<SubscriptionWrapper*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_sync_OsSubscription_nativeCreate(JNIEnv* env, jclass, jlong results_ptr, jstring j_subscription_name)
+{
+    TR_ENTER()
+    try {
+        const auto results = reinterpret_cast<ResultsWrapper*>(results_ptr);
+        JStringAccessor subscription_name(env, j_subscription_name);
+        auto key = subscription_name.is_null_or_empty() ? util::none : util::Optional<std::string>(subscription_name);
+        auto subscription = partial_sync::subscribe(results->collection(), key);
+        auto wrapper = new SubscriptionWrapper(std::move(subscription));
+        return reinterpret_cast<jlong>(wrapper);
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_sync_OsSubscription_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_subscription);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_sync_OsSubscription_nativeStartListening(JNIEnv* env, jobject object, jlong native_ptr)
+{
+    TR_ENTER()
+    try {
+        auto wrapper = reinterpret_cast<SubscriptionWrapper*>(native_ptr);
+        wrapper->start_listening(env, object);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_sync_OsSubscription_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER()
+    try {
+        auto wrapper = reinterpret_cast<SubscriptionWrapper*>(native_ptr);
+        wrapper->stop_listening();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_sync_OsSubscription_nativeGetState(JNIEnv* env, jclass, jlong native_ptr)
+{
+    TR_ENTER()
+    try {
+        auto wrapper = reinterpret_cast<SubscriptionWrapper*>(native_ptr);
+        return static_cast<jint>(wrapper->subscription().state());
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_sync_OsSubscription_nativeGetError(JNIEnv* env, jclass, jlong native_ptr)
+{
+    TR_ENTER()
+    try {
+        auto wrapper = reinterpret_cast<SubscriptionWrapper*>(native_ptr);
+        auto err = wrapper->subscription().error();
+        if (err) {
+            std::string error_message = "";
+            try {
+                std::rethrow_exception(err);
+            }
+            catch (const std::exception &e) {
+                error_message = e.what();
+            }
+
+            static JavaClass illegal_argument_class(env, "java/lang/IllegalArgumentException");
+            static JavaMethod illegal_argument_constructor(env, illegal_argument_class, "<init>", "(Ljava/lang/String;)V");
+            return static_cast<jthrowable>(env->NewObject(illegal_argument_class, illegal_argument_constructor, to_jstring(env, error_message)));
+        }
+        return nullptr;
+    }
+    CATCH_STD()
+    return nullptr;
+}
diff --git a/realm/realm-library/src/main/cpp/java_accessor.hpp b/realm/realm-library/src/main/cpp/java_accessor.hpp
index 3db10074c3..87eb4ee693 100644
--- a/realm/realm-library/src/main/cpp/java_accessor.hpp
+++ b/realm/realm-library/src/main/cpp/java_accessor.hpp
@@ -1,3 +1,4 @@
+
 /*
  * Copyright 2017 Realm Inc.
  *
@@ -24,6 +25,8 @@
 
 #include <realm/binary_data.hpp>
 #include <realm/table.hpp>
+#include <realm/util/any.hpp>
+#include <realm/util/to_string.hpp>
 
 #include <object_accessor.hpp>
 #include <realm/util/any.hpp>
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
index 2406d18498..c924307a6f 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.cpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -72,3 +72,21 @@ void JavaBindingContext::set_schema_changed_callback(JNIEnv* env, jobject schema
 {
     m_schema_changed_callback = JavaGlobalWeakRef(env, schema_changed_callback);
 }
+
+void JavaBindingContext::will_send_notifications() {
+    auto env = JniUtils::get_env();
+    m_java_notifier.call_with_local_ref(env, [&](JNIEnv*, jobject notifier_obj) {
+        static JavaMethod realm_notifier_will_send_notifications(env, JavaClassGlobalDef::realm_notifier(),
+                                                           "willSendNotifications", "()V");
+        env->CallVoidMethod(notifier_obj, realm_notifier_will_send_notifications);
+    });
+}
+
+void JavaBindingContext::did_send_notifications() {
+    auto env = JniUtils::get_env();
+    m_java_notifier.call_with_local_ref(env, [&](JNIEnv*, jobject notifier_obj) {
+        static JavaMethod realm_notifier_did_send_notifications(env, JavaClassGlobalDef::realm_notifier(),
+                                                                 "didSendNotifications", "()V");
+        env->CallVoidMethod(notifier_obj, realm_notifier_did_send_notifications);
+    });
+}
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index 0ff2caea2b..eeff8523b4 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -46,7 +46,8 @@ class JavaBindingContext final : public BindingContext {
     void did_change(std::vector<ObserverState> const& observers, std::vector<void*> const& invalidated,
                     bool version_changed = true) override;
     void schema_did_change(Schema const&) override;
-
+    void will_send_notifications() override;
+    void did_send_notifications() override;
     explicit JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
         : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier)
         , m_schema_changed_callback()
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 9aab0ffd5b..f2a536d29d 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 9aab0ffd5bc7bfc438ec28375ba581cf732f57ee
+Subproject commit f2a536d29de48e34e60799a5bf3f36e13806387e
diff --git a/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
index 6b86d91138..0f6ff53b76 100644
--- a/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
+++ b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
@@ -22,6 +22,9 @@
 #include "jni_util/java_method.hpp"
 #include "jni_util/log.hpp"
 
+#include <results.hpp>
+#include <realm/util/optional.hpp>
+
 namespace realm {
 namespace _impl {
 
diff --git a/realm/realm-library/src/main/cpp/subscription_wrapper.hpp b/realm/realm-library/src/main/cpp/subscription_wrapper.hpp
new file mode 100644
index 0000000000..7c58651637
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/subscription_wrapper.hpp
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_SUBSCRIPTION_WRAPPER_HPP
+#define REALM_JNI_IMPL_SUBSCRIPTION_WRAPPER_HPP
+
+
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
+
+#include <realm/util/optional.hpp>
+#include <sync/partial_sync.hpp>
+
+namespace realm {
+namespace _impl {
+
+// Wrapper of Object Store Subscription
+// We need to control the life cycle of Results/List, weak ref of Java OsResults/OsList object and the NotificationToken.
+// Wrap all three together, so when the Java OsResults/OsList object gets GCed, all three of them will be invalidated.
+class SubscriptionWrapper {
+public:
+    SubscriptionWrapper(partial_sync::Subscription subscription)
+        : m_subscription_weak_ref(),
+          m_notification_token(),
+          m_subscription(std::move(subscription))
+    {
+    }
+
+    ~SubscriptionWrapper() = default;
+
+    SubscriptionWrapper(SubscriptionWrapper &&) = delete;
+    SubscriptionWrapper &operator=(SubscriptionWrapper &&) = delete;
+    SubscriptionWrapper(SubscriptionWrapper const &) = delete;
+    SubscriptionWrapper &operator=(SubscriptionWrapper const &) = delete;
+
+    partial_sync::Subscription& subscription() {
+        return m_subscription;
+    };
+
+    void start_listening(JNIEnv* env, jobject j_subscription_object);
+    void stop_listening();
+
+private:
+    jni_util::JavaGlobalWeakRef m_subscription_weak_ref;
+    partial_sync::SubscriptionNotificationToken m_notification_token;
+    partial_sync::Subscription m_subscription;
+};
+
+void SubscriptionWrapper::start_listening(JNIEnv *env, jobject j_subscription_object)
+{
+    static jni_util::JavaClass os_results_class(env, "io/realm/internal/sync/OsSubscription");
+    static jni_util::JavaMethod notify_change_listeners(env, os_results_class, "notifyChangeListeners", "()V");
+
+    if (!m_subscription_weak_ref) {
+        m_subscription_weak_ref = jni_util::JavaGlobalWeakRef(env, j_subscription_object);
+    }
+
+    auto cb = [=]() {
+        // OS will call all notifiers' callback in one run, so check the Java exception first!!
+        if (env->ExceptionCheck())
+            return;
+
+        m_subscription_weak_ref.call_with_local_ref(env, [&](JNIEnv *local_env, jobject subscription_obj) {
+            local_env->CallVoidMethod(subscription_obj, notify_change_listeners);
+        });
+    };
+
+    m_notification_token = m_subscription.add_notification_callback(cb);
+}
+
+void SubscriptionWrapper::stop_listening()
+{
+    m_notification_token = {};
+}
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_JNI_IMPL_SUBSCRIPTION_WRAPPER_HPP
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 6161f2ad36..42071658f0 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -31,7 +31,6 @@
 #include <realm/timestamp.hpp>
 #include <realm/table.hpp>
 #include <realm/util/safe_int_ops.hpp>
-
 #include "io_realm_internal_Util.h"
 
 #include "java_exception_def.hpp"
@@ -452,6 +451,10 @@ class JStringAccessor {
 public:
     JStringAccessor(JNIEnv*, jstring); // throws
 
+    bool is_null_or_empty() {
+        return m_is_null || m_size == 0;
+    }
+
     operator realm::StringData() const
     {
         // To solve the link issue by directly using Table::max_string_size
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 37eddd6371..885ba03f55 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -26,26 +26,34 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import io.reactivex.Flowable;
 import javax.annotation.Nullable;
 
+import io.reactivex.Flowable;
+import io.realm.annotations.Beta;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsObjectStore;
 import io.realm.internal.OsRealmConfig;
 import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.OsSharedRealm;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
 import io.realm.internal.Util;
+import io.realm.internal.annotations.ObjectServer;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.RealmLog;
+import io.realm.sync.permissions.ObjectPrivileges;
+import io.realm.sync.permissions.RealmPermissions;
+import io.realm.sync.permissions.RealmPrivileges;
+import io.realm.sync.permissions.Role;
 
 /**
  * Base class for all Realm instances.
@@ -63,8 +71,12 @@
             "This Realm instance has already been closed, making it unusable.";
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
-    static final String LISTENER_NOT_ALLOWED_MESSAGE = "Listeners cannot be used on current thread.";
-
+    static final String LISTENER_NOT_ALLOWED_MESSAGE =
+            "Listeners cannot be used on current thread.";
+    static final String DELETE_NOT_SUPPORTED_UNDER_PARTIAL_SYNC =
+            "This API is not supported by partially " +
+            "synchronized Realms. Either unsubscribe using 'Realm.unsubscribeAsync()' or " +
+            "delete the objects using a query and 'RealmResults.deleteAllFromRealm()'";
 
     static volatile Context applicationContext;
 
@@ -433,6 +445,17 @@ protected void checkIfInTransaction() {
         }
     }
 
+    protected void checkIfPartialRealm() {
+        boolean isPartialRealm = false;
+        if (configuration.isSyncConfiguration()) {
+            isPartialRealm = ObjectServerFacade.getSyncFacadeIfPossible().isPartialRealm(configuration);
+        }
+
+        if (!isPartialRealm) {
+            throw new IllegalStateException("This method is only available on partially synchronized Realms.");
+        }
+    }
+
     /**
      * Checks if the Realm is valid and in a transaction.
      */
@@ -480,6 +503,41 @@ public long getVersion() {
         return OsObjectStore.getSchemaVersion(sharedRealm);
     }
 
+    /**
+     * Returns the privileges granted to the current user for this Realm.
+     *
+     * @return the privileges granted the current user for this Realm.
+     */
+    @Beta
+    @ObjectServer
+    public RealmPrivileges getPrivileges() {
+        checkIfValid();
+        return new RealmPrivileges(sharedRealm.getPrivileges());
+    }
+
+    /**
+     * Returns the privileges granted to the current user for the given object.
+     *
+     * @param object Realm object to get privileges for.
+     * @return the privileges granted the current user for the object.
+     * @throws IllegalArgumentException if the object is either null, unmanaged or not part of this Realm.
+     */
+    public ObjectPrivileges getPrivileges(RealmModel object) {
+        checkIfValid();
+        //noinspection ConstantConditions
+        if (object == null) {
+            throw new IllegalArgumentException("Non-null 'object' required.");
+        }
+        if (!RealmObject.isManaged(object)) {
+            throw new IllegalArgumentException("Only managed objects have privileges. This is a an unmanaged object: " + object.toString());
+        }
+        if (!((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(getPath())) {
+            throw new IllegalArgumentException("Object belongs to a different Realm.");
+        }
+        UncheckedRow row = (UncheckedRow) ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm();
+        return new ObjectPrivileges(sharedRealm.getObjectPrivileges(row));
+    }
+
     /**
      * Closes the Realm instance and all its resources.
      * <p>
@@ -594,13 +652,20 @@ public boolean isEmpty() {
 
     /**
      * Deletes all objects from this Realm.
+     * <p>
+     * If the Realm is a partially synchronized Realm, all subscriptions will be cleared as well.
      *
-     * @throws IllegalStateException if the corresponding Realm is closed or called from an incorrect thread.
+     * @throws IllegalStateException if the corresponding Realm is a partially synchronized Realm, is
+     * closed or called from an incorrect thread.
      */
     public void deleteAll() {
         checkIfValid();
+        if (sharedRealm.isPartial()) {
+            throw new IllegalStateException(DELETE_NOT_SUPPORTED_UNDER_PARTIAL_SYNC);
+        }
+        boolean isPartialRealm = sharedRealm.isPartial();
         for (RealmObjectSchema objectSchema : getSchema().getAll()) {
-            getSchema().getTable(objectSchema.getClassName()).clear();
+            getSchema().getTable(objectSchema.getClassName()).clear(isPartialRealm);
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index c62b5268d6..c8e164bc64 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -16,9 +16,10 @@
 
 package io.realm;
 
-import io.reactivex.Flowable;
 import java.util.Locale;
 
+import io.reactivex.Flowable;
+import io.realm.annotations.Beta;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.CheckedRow;
@@ -26,7 +27,10 @@
 import io.realm.internal.OsObjectStore;
 import io.realm.internal.OsSharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.Util;
+import io.realm.internal.annotations.ObjectServer;
 import io.realm.log.RealmLog;
+import io.realm.sync.permissions.ClassPrivileges;
 
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
@@ -223,11 +227,16 @@ public void removeAllChangeListeners() {
      * Deletes all objects of the specified class from the Realm.
      *
      * @param className the class for which all objects should be removed.
+     * @throws IllegalStateException if the corresponding Realm is a partially synchronized Realm, is
+     * closed or called from an incorrect thread.
      */
     public void delete(String className) {
         checkIfValid();
         checkIfInTransaction();
-        schema.getTable(className).clear();
+        if (sharedRealm.isPartial()) {
+            throw new IllegalStateException(DELETE_NOT_SUPPORTED_UNDER_PARTIAL_SYNC);
+        }
+        schema.getTable(className).clear(sharedRealm.isPartial());
     }
 
     /**
@@ -286,6 +295,86 @@ static DynamicRealm createInstance(OsSharedRealm sharedRealm) {
         return configuration.getRxFactory().from(this);
     }
 
+// FIXME: Depends on a typed schema. Find a work-around
+//    /**
+//     * {@inheritDoc}
+//     */
+//    @Beta
+//    @ObjectServer
+//    @Override
+//    public RealmPermissions getPermissions() {
+//        checkIfValid();
+//        Table table = sharedRealm.getTable("class___Realm");
+//        TableQuery query = table.where();
+//        OsResults result = OsResults.createFromQuery(sharedRealm, query);
+//        return new RealmResults<>(this, result, RealmPermissions.class).first();
+//    }
+
+
+// FIXME: Depends on a typed schema. Find a work-around
+//    /**
+//     * Returns all permissions associated with the given class. Attach a change listener
+//     * using {@link ClassPermissions#addChangeListener(RealmChangeListener)} to be notified about
+//     * any future changes.
+//     *
+//     * @param className class to receive permissions for.
+//     * @return the permissions for the given class or {@code null} if no permissions where found.
+//     * @throws RealmException if the class is not part of this Realms schema.
+//     */
+//    @Beta
+//    @ObjectServer
+//    public ClassPermissions getPermissions(String className) {
+//        checkIfValid();
+//        //noinspection ConstantConditions
+//        if (Util.isEmptyString(className)) {
+//            throw new IllegalArgumentException("Non-empty 'className' required.");
+//        }
+//        if (!schema.contains(className)) {
+//            throw new RealmException("Class '" + className + "' is not part of the schema for this Realm.");
+//        }
+//        Table table = sharedRealm.getTable("class___Class");
+//        TableQuery query = table.where()
+//                .equalTo(new long[]{table.getColumnIndex("name")}, new long[]{NativeObject.NULLPTR}, className);
+//        OsResults result = OsResults.createFromQuery(sharedRealm, query);
+//        return new RealmResults<>(this, result, ClassPermissions.class).first(null);
+//    }
+
+// FIXME: Depends on a typed schema. Find a work-around
+//    /**
+//     * {@inheritDoc}
+//     */
+//    @Beta
+//    @ObjectServer
+//    @Override
+//    public RealmResults<Role> getRoles() {
+//        checkIfValid();
+//        //noinspection ConstantConditions
+//        Table table = sharedRealm.getTable("class___Role");
+//        TableQuery query = table.where();
+//        OsResults result = OsResults.createFromQuery(sharedRealm, query);
+//        return new RealmResults<>(this, result, Role.class);
+//    }
+
+    /**
+     * Returns the privileges granted the current user for the given class.
+     *
+     * @param className class to get privileges for.
+     * @return the privileges granted the current user for the given class.
+     */
+    @Beta
+    @ObjectServer
+    public ClassPrivileges getPrivileges(String className) {
+        checkIfValid();
+        //noinspection ConstantConditions
+        if (Util.isEmptyString(className)) {
+            throw new IllegalArgumentException("Non-empty 'className' required.");
+        }
+        if (!schema.contains(className)) {
+            throw new RealmException("Class '" + className + "' is not part of the schema for this Realm");
+        }
+        return new ClassPrivileges(sharedRealm.getClassPrivileges(className));
+    }
+
     /**
      * Returns the mutable schema for this Realm.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
index 52ca14ee0c..97c1fcf9cd 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
@@ -18,6 +18,8 @@
 
 import java.util.Locale;
 
+import javax.annotation.Nullable;
+
 /**
  * This interface describes the changes made to a collection during the last update.
  * <p>
@@ -28,6 +30,44 @@
  * change, or an array of {@link Range}s.
  */
 public interface OrderedCollectionChangeSet {
+
+    /**
+     * State describing the nature of the changeset.
+     */
+    public enum State {
+        /**
+         * This state is used first time the callback is invoked. The query will have completed and
+         * data is ready for the UI.
+         */
+        INITIAL,
+        /**
+         * This state is used for every subsequent update after the first.
+         */
+        UPDATE,
+        /**
+         * This state is used if some error occurred on the background evaluating the query.
+         * <p>
+         * For local and fully synchronized Realms, this state should only be encountered if the
+         * Realm could not be succesfully opened in the background,.
+         * <p>
+         * For partially synchronized Realms, it is only possible to get into this state if an error
+         * happened while evaluating the query on the server or some other error prevented data from
+         * being downloaded.
+         * <p>
+         * In this state, the content of the {@link RealmResults} is undefined.
+         */
+        ERROR
+    }
+
+    /**
+     * Returns the state represented by this change. See {@link State} for a description of the
+     * different states a changeset can be in.
+     *
+     * @return what kind of state is represented by this changeset.
+     * @see State
+     */
+    State getState();
+
     /**
      * The deleted indices in the previous version of the collection.
      *
@@ -73,6 +113,54 @@
      */
     Range[] getChangeRanges();
 
+    /**
+     * Returns any error that happened. If an error has happened, the state of the collection and other
+     * changeset information is undefined. It is possible for a collection to go into an error state
+     * after being created and starting to send updates.
+     *
+     * @return the error that happened.
+     */
+    @Nullable
+    Throwable getError();
+
+    /**
+     * Returns {@code true} if the query result is considered "complete". For all local Realms, or
+     * fully synchronized Realms, this method will always return {@code true}.
+     * <p>
+     * This method thus only makes sense for partially synchronized Realms (as defined by setting
+     * {@link SyncConfiguration.Builder#partialRealm()}.
+     * <p>
+     * For those Realms, data is only downloaded when queried which means that until the data is
+     * downloaded, a local query might return a query result that would not have been possible on a
+     * fully synchronized Realm.
+     * <p>
+     * Consider the following case:
+     * <ol>
+     *   <li>An app is online and makes a query for all messages containing the word "Realm".</li>
+     *   <li>Partial synchronization downloads all those messages.</li>
+     *   <li>The app goes offline.</li>
+     *   <li>The app makes an offline query against all messages containing the word "Database".</li>
+     * </ol>
+     *
+     * Here there are two situations where the query result might be considered "incomplete".
+     * <p>
+     * The first is when the "Realm" query runs for the first time. The local query will finish
+     * faster than the network can download data so the query will initially report an empty
+     * incomplete query result.
+     * <p>
+     * The second is when the "Database" query is run. The initial query result will not be
+     * empty, but contain all messages that contain both "Realm" and "Database", as they are already
+     * available offline.
+     * <p>
+     * In both cases, a new notification will be triggered as soon as the device is able to download
+     * the data required to produce a "complete" query result.
+     *
+     * @return {@code true} if the query result is fully consistent with the server at some point in
+     * time. {@code false} if the query was executed while the device was offline or all data
+     * has not been downloaded yet.
+     */
+    boolean isCompleteResult();
+
     /**
      *
      */
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
index 24216e776d..6c57480848 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
@@ -35,8 +35,7 @@
      * This will be called when the async query is finished the first time or the collection of objects has changed.
      *
      * @param t the collection this listener is registered to.
-     * @param changeSet object with information about which rows in the collection were added, removed or modified.
-     * {@code null} is returned the first time an async query is completed.
+     * @param changeSet object with information about the change.
      */
-    void onChange(T t, @Nullable OrderedCollectionChangeSet changeSet);
+    void onChange(T t, OrderedCollectionChangeSet changeSet);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 194540d5f6..3bf2ba64fd 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -54,6 +54,7 @@
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
+import io.realm.internal.NativeObject;
 import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
@@ -65,9 +66,19 @@
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
+import io.realm.internal.TableQuery;
+import io.realm.internal.UncheckedRow;
+import io.realm.internal.Util;
+import io.realm.internal.annotations.ObjectServer;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.log.RealmLog;
+import io.realm.sync.permissions.ClassPermissions;
+import io.realm.sync.permissions.ClassPrivileges;
+import io.realm.sync.permissions.RealmPermissions;
+import io.realm.sync.permissions.RealmPrivileges;
+import io.realm.sync.permissions.Role;
 
 /**
  * The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating
@@ -1579,11 +1590,15 @@ public void run() {
      * Deletes all objects of the specified class from the Realm.
      *
      * @param clazz the class which objects should be removed.
-     * @throws IllegalStateException if the corresponding Realm is closed or called from an incorrect thread.
+     * @throws IllegalStateException if the corresponding Realm is a partially synchronized Realm, is
+     * closed or called from an incorrect thread.
      */
     public void delete(Class<? extends RealmModel> clazz) {
         checkIfValid();
-        schema.getTable(clazz).clear();
+        if (sharedRealm.isPartial()) {
+            throw new IllegalStateException(DELETE_NOT_SUPPORTED_UNDER_PARTIAL_SYNC);
+        }
+        schema.getTable(clazz).clear(sharedRealm.isPartial());
     }
 
 
@@ -1698,41 +1713,136 @@ public static boolean compactRealm(RealmConfiguration configuration) {
     }
 
     /**
-     * If the Realm is a partially synchronized Realm, fetch and synchronize the objects of a given
-     * object type that match the given query (in string format).
-     *
-     * The results will be returned asynchronously in the callback.
-     *
-     * @param clazz the class to query.
-     * @param query string query.
-     * @param callback A callback used to vend the results of a partial sync fetch.
-     * @throws IllegalStateException if it is called from a non-Looper or {@link IntentService} thread.
-     * @throws IllegalStateException if called from a non-synchronized (Realm Object Server) Realm.
+     * Cancel a named subscription that was created by calling {@link RealmQuery#findAllAsync(String)}.
+     * If after this, some objects are no longer part of any active subscription they will be removed
+     * locally from the device (but not on the server).
+     *
+     * The effect of unsubscribing is not immediate. The local Realm must coordinate with the Object
+     * Server before this can happen. A successful callback just indicate that the request was
+     * succesfully enqueued and any data will be removed as soon as possible. When the data is
+     * actually removed locally, a standard change notification will be triggered and from the
+     * perspective of the device it will look like the data was deleted.
+     *
+     * @param subscriptionName name of the subscription to remove
+     * @param callback callback reporting back if the intent to unsubscribe was enqueued successfully or failed.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @throws IllegalArgumentException if no {@code subscriptionName} or {@code callback} was provided.
+     * @throws IllegalStateException if called on a non-looper thread.
+     * @throws UnsupportedOperationException if the Realm is not a partially synchronized Realm.
      */
     @Beta
-    public <E extends RealmModel> void subscribeToObjects(final Class<E> clazz, String query, final PartialSyncCallback<E> callback) {
-        checkIfValid();
-        if (!configuration.isSyncConfiguration()) {
-            throw new IllegalStateException("Partial sync is only available for synchronized Realm (Realm Object Server)");
+    public RealmAsyncTask unsubscribeAsync(String subscriptionName, Realm.UnsubscribeCallback callback) {
+        if (Util.isEmptyString(subscriptionName)) {
+            throw new IllegalArgumentException("Non-empty 'subscriptionName' required.");
+        }
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("'callback' required.");
+        }
+        sharedRealm.capabilities.checkCanDeliverNotification("This method is only available from a Looper thread.");
+        if (!ObjectServerFacade.getSyncFacadeIfPossible().isPartialRealm(configuration)) {
+            throw new UnsupportedOperationException("Realm is not a partially synchronized Realm: " + configuration.getPath());
         }
 
-        sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
-
-        String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
-        OsSharedRealm.PartialSyncCallback internalCallback = new OsSharedRealm.PartialSyncCallback(className) {
+        return executeTransactionAsync(new Transaction() {
+            @Override
+            public void execute(Realm realm) {
+
+                // Need to manually run a dynamic query here.
+                // TODO Add support for DynamicRealm.executeTransactionAsync()
+                Table table = realm.sharedRealm.getTable("class___ResultSets");
+                TableQuery query = table.where()
+                        .equalTo(new long[]{table.getColumnIndex("name")}, new long[]{NativeObject.NULLPTR}, subscriptionName);
+
+                OsResults result = OsResults.createFromQuery(realm.sharedRealm, query);
+                long count = result.size();
+                if (count == 0) {
+                    throw new IllegalArgumentException("No active subscription named '"+ subscriptionName +"' exists.");
+                }
+                if (count > 1) {
+                    RealmLog.warn("Multiple subscriptions named '" + subscriptionName +  "' exists. This should not be possible. They will all be deleted");
+                }
+                result.clear();
+            }
+        }, new Transaction.OnSuccess() {
             @Override
-            public void onSuccess(OsResults osResults) {
-                RealmResults<E> results = new RealmResults<>(Realm.this, osResults, clazz);
-                callback.onSuccess(results);
+            public void onSuccess() {
+                callback.onSuccess(subscriptionName);
             }
-
+        }, new Transaction.OnError() {
             @Override
-            public void onError(RealmException error) {
-                callback.onError(error);
+            public void onError(Throwable error) {
+                callback.onError(subscriptionName, error);
             }
-        };
+        });
+    }
 
-        sharedRealm.registerPartialSyncQuery(query, internalCallback);
+    /**
+     * Returns all permissions associated with the current Realm. Attach a change listener
+     * using {@link RealmPermissions#addChangeListener(RealmChangeListener)} to be notified about
+     * any future changes.
+     *
+     * @return all permissions for the current Realm.
+     */
+    @Beta
+    @ObjectServer
+    public RealmPermissions getPermissions() {
+        checkIfValid();
+        return where(RealmPermissions.class).findFirst();
+    }
+
+    /**
+     * Returns all {@link Role} objects available in this Realm. Attach a change listener
+     * using {@link Role#addChangeListener(RealmChangeListener)} to be notified about
+     * any future changes.
+     *
+     * @return all roles available in the current Realm.
+     */
+    @Beta
+    @ObjectServer
+    public RealmResults<Role> getRoles() {
+        checkIfValid();
+        return where(Role.class).sort("name").findAll();
+    }
+
+    /**
+     * Returns the privileges granted the current user for the given class.
+     *
+     * @param clazz class to get privileges for.
+     * @return the privileges granted the current user for the given class.
+     */
+    @Beta
+    @ObjectServer
+    public ClassPrivileges getPrivileges(Class<? extends RealmModel> clazz) {
+        checkIfValid();
+        //noinspection ConstantConditions
+        if (clazz == null) {
+            throw new IllegalArgumentException("Non-null 'clazz' required.");
+        }
+        String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
+        return new ClassPrivileges(sharedRealm.getClassPrivileges(className));
+    }
+
+    /**
+     * Returns all permissions associated with the given class. Attach a change listener
+     * using {@link ClassPermissions#addChangeListener(RealmChangeListener)} to be notified about
+     * any future changes.
+     *
+     * @param clazz class to receive permissions for.
+     * @return the permissions for the given class or {@code null} if no permissions where found.
+     * @throws RealmException if the class is not part of this Realms schema.
+     */
+    @Beta
+    @ObjectServer
+    public ClassPermissions getPermissions(Class<? extends RealmModel> clazz) {
+        checkIfValid();
+        //noinspection ConstantConditions
+        if (clazz == null) {
+            throw new IllegalArgumentException("Non-null 'clazz' required.");
+        }
+        return where(ClassPermissions.class)
+                .equalTo("name", configuration.getSchemaMediator().getSimpleClassName(clazz))
+                .findFirst();
     }
 
     Table getTable(Class<? extends RealmModel> clazz) {
@@ -1833,6 +1943,28 @@ public void onError(Exception ignore) {}
         }
     }
 
+    /**
+     * Interface used when canceling partial sync subscriptions.
+     *
+     * @see #unsubscribeAsync(String, UnsubscribeCallback)
+     */
+    public interface UnsubscribeCallback {
+        /**
+         * Callback invoked when the request to unsubscribe was succesfully enqueued.
+         *
+         * @param subscriptionName subscription that was canceled.
+         */
+        void onSuccess(String subscriptionName);
+
+        /**
+         * Callback invoked if an error happened while trying to unsubscribe.
+         *
+         * @param subscriptionName subscription on which the error occurred.
+         * @param error cause of error.
+         */
+        void onError(String subscriptionName, Throwable error);
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -1851,9 +1983,4 @@ public void onError(Throwable exception) {
             super.onError(exception);
         }
     }
-
-    public static abstract class PartialSyncCallback<T extends RealmModel> {
-        public abstract void onSuccess(RealmResults<T> results);
-        public abstract void onError(RealmException error);
-    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 766a47e23e..66be10db7a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -658,6 +658,22 @@ public Builder modules(Object baseModule, Object... additionalModules) {
             return this;
         }
 
+        /**
+         * FIXME: Temporary visible
+         * DEBUG method. Will add a module unconditionally.
+         *
+         * Adds a module to already defined modules.
+         */
+        public final Builder addModule(Object module) {
+            //noinspection ConstantConditions
+            if (module != null) {
+                checkModule(module);
+                modules.add(module);
+            }
+
+            return this;
+        }
+
         /**
          * Sets the {@link RxObservableFactory} used to create Rx Observables from Realm objects.
          * The default factory is {@link RealmObservableFactory}.
@@ -749,14 +765,6 @@ public Builder compactOnLaunch(CompactOnLaunchCallback compactOnLaunch) {
             return this;
         }
 
-        private void addModule(Object module) {
-            //noinspection ConstantConditions
-            if (module != null) {
-                checkModule(module);
-                modules.add(module);
-            }
-        }
-
         /**
          * DEBUG method. This restricts the Realm schema to only consist of the provided classes without having to
          * create a module. These classes must be available in the default module. Calling this will remove any
@@ -805,6 +813,7 @@ public RealmConfiguration build() {
                 rxFactory = new RealmObservableFactory();
             }
 
+
             return new RealmConfiguration(directory,
                     fileName,
                     getCanonicalPath(new File(directory, fileName)),
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 7cb8bb2634..d2597933f0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -25,16 +25,19 @@
 
 import io.realm.annotations.Beta;
 import io.realm.annotations.Required;
-import io.realm.internal.OsResults;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsList;
+import io.realm.internal.OsResults;
 import io.realm.internal.PendingRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SortDescriptor;
+import io.realm.internal.SubscriptionAwareOsResults;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
+import io.realm.internal.Util;
 import io.realm.internal.fields.FieldDescriptor;
-import io.realm.log.RealmLog;
+import io.realm.internal.sync.SubscriptionAction;
 
 
 /**
@@ -45,7 +48,7 @@
  * RealmObject class is refactored care has to be taken to not break any queries.
  * <p>
  * A {@link io.realm.Realm} is unordered, which means that there is no guarantee that querying a Realm will return the
- * objects in the order they where inserted. Use {@link #findAllSorted(String)} and similar methods if a specific order
+ * objects in the order they where inserted. Use {@link #sort(String)} (String)} and similar methods if a specific order
  * is required.
  * <p>
  * A RealmQuery cannot be passed between different threads.
@@ -1536,9 +1539,8 @@ public boolean isValid() {
      * @return the query object
      */
     public RealmQuery<E> and() {
-    	realm.checkIfValid();
-
-    	return this;
+        realm.checkIfValid();
+        return this;
     }
 
     /**
@@ -1587,78 +1589,6 @@ public boolean isValid() {
         return this;
     }
 
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#distinctValues(String)} then {@link RealmQuery#findAll()}
-     *
-     * Returns a distinct set of objects of a specific class. If the result is sorted, the first
-     * object will be returned in case of multiple occurrences, otherwise it is undefined which
-     * object is returned.
-     * <p>
-     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
-     *
-     * @param fieldName the field name.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
-     * to linked fields.
-     */
-    @Deprecated
-    public RealmResults<E> distinct(String fieldName) {
-        realm.checkIfValid();
-
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), query.getTable(), fieldName);
-        return createRealmResults(query, null, distinctDescriptor, true);
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#distinctValues(String)} then {@link RealmQuery#findAllAsync()}
-     *
-     * Asynchronously returns a distinct set of objects of a specific class. If the result is
-     * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
-     * undefined which object is returned.
-     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
-     *
-     * @param fieldName the field name.
-     * @return immediately a {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     * query completes.
-     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
-     * to linked fields.
-     */
-    @Deprecated
-    public RealmResults<E> distinctAsync(String fieldName) {
-        realm.checkIfValid();
-
-        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), query.getTable(), fieldName);
-        return createRealmResults(query, null, distinctDescriptor, false);
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#distinctValues(String, String[])} then {@link RealmQuery#findAll()}
-     *
-     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
-     * given, all unique combinations of values in the fields will be returned. In case of multiple
-     * matches, it is undefined which object is returned. Unless the result is sorted, then the
-     * first object will be returned.
-     *
-     * @param firstFieldName first field name to use when finding distinct objects.
-     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     * is an unsupported type, or points to a linked field.
-     */
-    @Deprecated
-    public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
-        realm.checkIfValid();
-
-        String[] fieldNames = new String[1 + remainingFieldNames.length];
-
-        fieldNames[0] = firstFieldName;
-        System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
-        return createRealmResults(query, null, distinctDescriptor, true);
-    }
-
     /**
      * Calculates the sum of a given field.
      *
@@ -1823,11 +1753,17 @@ public long count() {
     public RealmResults<E> findAll() {
         realm.checkIfValid();
 
-        return createRealmResults(query, sortDescriptor, distinctDescriptor, true);
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, true, SubscriptionAction.NO_SUBSCRIPTION);
     }
 
     /**
      * Finds all objects that fulfill the query conditions. This method is only available from a Looper thread.
+     * <p>
+     * On partially synchronized Realms, defined by setting {@link SyncConfiguration.Builder#partialRealm()},
+     * this method will also create an anonymous subscription that will download all server data matching
+     * the query.
+     * </p>
+     *
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
@@ -1837,50 +1773,41 @@ public long count() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        return createRealmResults(query, sortDescriptor, distinctDescriptor, false);
+        SubscriptionAction subscriptionAction;
+        
+        // Don't create subscriptions for list queries as they are always part of an object covered by another query.
+        if (realm.sharedRealm.isPartial() && osList == null) {
+            subscriptionAction = SubscriptionAction.ANONYMOUS_SUBSCRIPTION;
+        }  else {
+            subscriptionAction = SubscriptionAction.NO_SUBSCRIPTION;
+        }
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, false, subscriptionAction);
     }
 
     /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort)} then {@link RealmQuery#findAll()}
-     *
-     * Finds all objects that fulfill the query conditions and sorted by specific field name.
+     * Finds all objects that fulfill the query condition(s). This method is only available from a Looper thread.
      * <p>
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName the field name to sort by.
-     * @param sortOrder how to sort the results.
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
-     * objects is returned.
-     * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     */
-    @SuppressWarnings("unchecked")
-    @Deprecated
-    public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
-        realm.checkIfValid();
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
-        return createRealmResults(query, sortDescriptor, null, true);
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort)} then {@link RealmQuery#findAllAsync()}
-     *
-     * Similar to {@link #findAllSorted(String, Sort)} but runs asynchronously on a worker thread
-     * (need a Realm opened from a looper thread to work).
+     * This method is only available on partially synchronized Realms and will also create a named subscription
+     * that will synchronize all server data matching the query. Named subscriptions can be removed again by
+     * calling {@code Realm.unsubscribe(subscriptionName}.
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
+     * @see io.realm.RealmResults
+     * @throws IllegalStateException If the Realm is a not a partially synchronized Realm.
      */
-    @Deprecated
-    public RealmResults<E> findAllSortedAsync(final String fieldName, final Sort sortOrder) {
+    public RealmResults<E> findAllAsync(String subscriptionName) {
         realm.checkIfValid();
+        realm.checkIfPartialRealm();
+        if (osList != null) {
+            throw new IllegalStateException("Cannot create subscriptions for queries based on a 'RealmList'");
+        }
+        if (Util.isEmptyString(subscriptionName)) {
+            throw new IllegalArgumentException("Non-empty 'subscriptionName' required.");
+        }
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
-        return createRealmResults(query, sortDescriptor, null, false);
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, false, SubscriptionAction.create(subscriptionName));
     }
 
     /**
@@ -1955,8 +1882,6 @@ public long count() {
     }
 
     /**
-     * BETA API: Will be renamed to {@code distinct} in next major release.
-     *
      * Selects a distinct set of objects of a specific class. If the result is sorted, the first object will be
      * returned in case of multiple occurrences, otherwise it is undefined which object is returned.
      * <p>
@@ -1968,13 +1893,11 @@ public long count() {
      * @throws IllegalStateException if distinct field names were already defined.
      */
     @Beta
-    public RealmQuery<E> distinctValues(String fieldName) {
-        return distinctValues(fieldName, new String[]{});
+    public RealmQuery<E> distinct(String fieldName) {
+        return distinct(fieldName, new String[]{});
     }
 
     /**
-     * BETA API: Will be renamed to {@code distinct} in next major release.
-     *
      * Selects a distinct set of objects of a specific class. When multiple distinct fields are
      * given, all unique combinations of values in the fields will be returned. In case of multiple
      * matches, it is undefined which object is returned. Unless the result is sorted, then the
@@ -1987,7 +1910,7 @@ public long count() {
      * @throws IllegalStateException if distinct field names were already defined.
      */
     @Beta
-    public RealmQuery<E> distinctValues(String firstFieldName, String... remainingFieldNames) {
+    public RealmQuery<E> distinct(String firstFieldName, String... remainingFieldNames) {
         realm.checkIfValid();
         if (distinctDescriptor != null) {
             throw new IllegalStateException("Distinct fields have already been defined.");
@@ -2003,130 +1926,10 @@ public long count() {
         return this;
     }
 
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String)} then {@link RealmQuery#findAll()}
-     *
-     * Finds all objects that fulfill the query conditions and sorted by specific field name in ascending order.
-     * <p>
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName the field name to sort by.
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
-     * objects is returned.
-     * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSorted(String fieldName) {
-        return findAllSorted(fieldName, Sort.ASCENDING);
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String)} then {@link RealmQuery#findAllAsync()}
-     *
-     * Similar to {@link #findAllSorted(String)} but runs asynchronously on a worker thread.
-     * This method is only available from a Looper thread.
-     *
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSortedAsync(String fieldName) {
-        return findAllSortedAsync(fieldName, Sort.ASCENDING);
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String[], Sort[])} then {@link RealmQuery#findAll()}
-     *
-     * Finds all objects that fulfill the query conditions and sorted by specific field names.
-     * <p>
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldNames an array of field names to sort by.
-     * @param sortOrders how to sort the field names.
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
-     * objects is returned.
-     * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
-        realm.checkIfValid();
-
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
-        return createRealmResults(query, sortDescriptor, null, true);
-    }
-
     private boolean isDynamicQuery() {
         return className != null;
     }
 
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String[], Sort[])} then {@link RealmQuery#findAllAsync()}
-     *
-     * Similar to {@link #findAllSorted(String[], Sort[])} but runs asynchronously.
-     * from a worker thread.
-     * This method is only available from a Looper thread.
-     *
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     * @see io.realm.RealmResults
-     */
-    @Deprecated
-    public RealmResults<E> findAllSortedAsync(String[] fieldNames, final Sort[] sortOrders) {
-        realm.checkIfValid();
-
-        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
-        return createRealmResults(query, sortDescriptor, null, false);
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort, String, Sort)} then {@link RealmQuery#findAll()}
-     *
-     * Finds all objects that fulfill the query conditions and sorted by specific field names in ascending order.
-     * <p>
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName1 first field name
-     * @param sortOrder1 sort order for first field
-     * @param fieldName2 second field name
-     * @param sortOrder2 sort order for second field
-     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
-     * objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
-            String fieldName2, Sort sortOrder2) {
-        return findAllSorted(new String[] {fieldName1, fieldName2}, new Sort[] {sortOrder1, sortOrder2});
-    }
-
-    /**
-     * @deprecated Since 4.3.0, now use {@link RealmQuery#sort(String, Sort, String, Sort)} then {@link RealmQuery#findAllAsync()}
-     *
-     * Similar to {@link #findAllSorted(String, Sort, String, Sort)} but runs asynchronously on a worker thread
-     * This method is only available from a Looper thread.
-     *
-     * @return immediately an empty {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
-     * {@link RealmObject} or a child {@link RealmList}.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
-            String fieldName2, Sort sortOrder2) {
-        return findAllSortedAsync(new String[] {fieldName1, fieldName2}, new Sort[] {sortOrder1, sortOrder2});
-    }
-
     /**
      * Finds the first object that fulfills the query conditions.
      *
@@ -2200,12 +2003,20 @@ public E findFirstAsync() {
         return result;
     }
 
+
     private RealmResults<E> createRealmResults(TableQuery query,
-            @Nullable SortDescriptor sortDescriptor,
-            @Nullable SortDescriptor distinctDescriptor,
-            boolean loadResults) {
+                                               @Nullable SortDescriptor sortDescriptor,
+                                               @Nullable SortDescriptor distinctDescriptor,
+                                               boolean loadResults,
+                                               SubscriptionAction subscriptionAction) {
         RealmResults<E> results;
-        OsResults osResults = OsResults.createFromQuery(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+        OsResults osResults;
+        if (subscriptionAction.shouldCreateSubscriptions()) {
+            osResults = SubscriptionAwareOsResults.createFromQuery(realm.sharedRealm, query, sortDescriptor, distinctDescriptor, subscriptionAction.getName());
+        } else {
+            osResults = OsResults.createFromQuery(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+        }
+
         if (isDynamicQuery()) {
             results = new RealmResults<>(realm, osResults, className);
         } else {
@@ -2214,6 +2025,7 @@ public E findFirstAsync() {
         if (loadResults) {
             results.load();
         }
+
         return results;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index de4a3c388f..a2596932d2 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -20,11 +20,10 @@
 import android.annotation.SuppressLint;
 import android.os.Looper;
 
-import io.reactivex.Flowable;
-import io.reactivex.Observable;
-
 import javax.annotation.Nullable;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.OsResults;
 import io.realm.internal.Row;
@@ -99,7 +98,6 @@
         return RealmQuery.createQueryFromResult(this);
     }
 
-
     /**
      * {@inheritDoc}
      */
diff --git a/realm/realm-library/src/main/java/io/realm/internal/EmptyLoadChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/EmptyLoadChangeSet.java
new file mode 100644
index 0000000000..3ac1a8ebad
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/EmptyLoadChangeSet.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmResults;
+import io.realm.internal.sync.OsSubscription;
+
+/**
+ * Empty changeset used if {@link RealmResults#load()} is called manually or if no collection
+ * changeset was available but the subscription was updated.
+ */
+public class EmptyLoadChangeSet extends OsCollectionChangeSet {
+
+    private static final int[] NO_INDEX_CHANGES = new int[0];
+    private static final Range[] NO_RANGE_CHANGES = new Range[0];
+
+    public EmptyLoadChangeSet(@Nullable OsSubscription subscription, boolean firstCallback, boolean isPartialRealm) {
+        super(0, firstCallback, subscription, isPartialRealm);
+    }
+
+    public EmptyLoadChangeSet(@Nullable OsSubscription subscription, boolean isPartialRealm) {
+        super(0, true, subscription, isPartialRealm);
+    }
+
+    @Override
+    public State getState() {
+        return State.INITIAL;
+    }
+
+    @Override
+    public int[] getDeletions() {
+        return NO_INDEX_CHANGES;
+    }
+
+    @Override
+    public int[] getInsertions() {
+        return NO_INDEX_CHANGES;
+    }
+
+    @Override
+    public int[] getChanges() {
+        return NO_INDEX_CHANGES;
+    }
+
+    @Override
+    public Range[] getDeletionRanges() {
+        return NO_RANGE_CHANGES;
+    }
+
+    @Override
+    public Range[] getInsertionRanges() {
+        return NO_RANGE_CHANGES;
+    }
+
+    @Override
+    public Range[] getChangeRanges() {
+        return NO_RANGE_CHANGES;
+    }
+
+    @Override
+    public Throwable getError() {
+        if (subscription != null && subscription.getState() == OsSubscription.SubscriptionState.ERROR) {
+            return subscription.getError();
+        }
+        return null;
+    }
+
+    @Override
+    public boolean isRemoteDataLoaded() {
+        return super.isRemoteDataLoaded();
+    }
+
+    @Override
+    public boolean isCompleteResult() {
+        return isRemoteDataLoaded();
+    }
+
+    @Override
+    public boolean isFirstAsyncCallback() {
+        return super.isFirstAsyncCallback();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        // Since this class represents "No collection" changes, it is only considered empty
+        // if no partial sync updates are found
+        if (subscription == null) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return super.toString();
+    }
+
+    @Override
+    public long getNativePtr() {
+        return super.getNativePtr();
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return super.getNativeFinalizerPtr();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 2e4cce938a..509ffa8c99 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -19,7 +19,6 @@
 import android.content.Context;
 
 import java.lang.reflect.InvocationTargetException;
-import java.net.URI;
 
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmException;
@@ -115,4 +114,16 @@ public void downloadRemoteChanges(RealmConfiguration config) {
     public boolean wasDownloadInterrupted(Throwable throwable) {
         return false;
     }
+
+    public boolean isPartialRealm(RealmConfiguration configuration) {
+        return false;
+    }
+
+    public void addSupportForObjectLevelPermissions(RealmConfiguration.Builder builder) {
+        // Do nothing
+    }
+
+    public OsResults createSubscriptionAwareResults(OsSharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor, SortDescriptor distinctDescriptor, String name) {
+        throw new IllegalStateException("Should only be called by builds supporting Sync");
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java b/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
index 7004df192c..be7ba607dd 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
@@ -9,16 +9,15 @@
 // Helper class for supporting add change listeners on OsResults & OsList.
 @Keep
 interface ObservableCollection {
-
     class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
         public CollectionObserverPair(T observer, Object listener) {
             super(observer, listener);
         }
 
-        public void onChange(T observer, @Nullable OrderedCollectionChangeSet changes) {
+        public void onChange(T observer, OsCollectionChangeSet changes) {
             if (listener instanceof OrderedRealmCollectionChangeListener) {
                 //noinspection unchecked
-                ((OrderedRealmCollectionChangeListener<T>) listener).onChange(observer, changes);
+                ((OrderedRealmCollectionChangeListener<T>) listener).onChange(observer, new StatefulCollectionChangeSet(changes));
             } else if (listener instanceof RealmChangeListener) {
                 //noinspection unchecked
                 ((RealmChangeListener<T>) listener).onChange(observer);
@@ -53,9 +52,9 @@ public int hashCode() {
     }
 
     class Callback implements ObserverPairList.Callback<CollectionObserverPair> {
-        private final OrderedCollectionChangeSet changeSet;
+        private final OsCollectionChangeSet changeSet;
 
-        Callback(@Nullable OrderedCollectionChangeSet changeSet) {
+        Callback(OsCollectionChangeSet changeSet) {
             this.changeSet = changeSet;
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
index 1a0c65a773..2132485f63 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
@@ -45,7 +45,7 @@
         // Should only be set by the outer class. To marked it as removed in case it is removed in foreach callback.
         boolean removed = false;
 
-        ObserverPair(T observer, S listener) {
+        public ObserverPair(T observer, S listener) {
             this.listener = listener;
             this.observerRef = new WeakReference<T>(observer);
         }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
index 93bbc3e7ac..44902a5e02 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
@@ -21,7 +21,7 @@
 import javax.annotation.Nullable;
 
 import io.realm.OrderedCollectionChangeSet;
-
+import io.realm.internal.sync.OsSubscription;
 
 /**
  * Implementation of {@link OrderedCollectionChangeSet}. This class holds a pointer to the Object Store's
@@ -45,12 +45,27 @@
 
     private static long finalizerPtr = nativeGetFinalizerPtr();
     private final long nativePtr;
+    private final boolean firstAsyncCallback;
+    protected final OsSubscription subscription;
+    protected final boolean isPartialRealm;
+
+    public OsCollectionChangeSet(long nativePtr, boolean firstAsyncCallback) {
+        this(nativePtr, firstAsyncCallback, null, false);
+    }
 
-    public OsCollectionChangeSet(long nativePtr) {
+    public OsCollectionChangeSet(long nativePtr, boolean firstAsyncCallback, @Nullable OsSubscription subscription, boolean isPartialRealm) {
         this.nativePtr = nativePtr;
+        this.firstAsyncCallback = firstAsyncCallback;
+        this.subscription = subscription;
+        this.isPartialRealm = isPartialRealm;
         NativeContext.dummyContext.addReference(this);
     }
 
+    @Override
+    public State getState() {
+        throw new UnsupportedOperationException("This method should be overridden in a subclass");
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -99,17 +114,46 @@ public OsCollectionChangeSet(long nativePtr) {
         return longArrayToRangeArray(nativeGetRanges(nativePtr, TYPE_MODIFICATION));
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public long getNativePtr() {
-        return nativePtr;
+    public Throwable getError() {
+        if (subscription != null && subscription.getState() == OsSubscription.SubscriptionState.ERROR) {
+            return subscription.getError();
+        }
+        return null;
     }
 
     @Override
-    public long getNativeFinalizerPtr() {
-        return finalizerPtr;
+    public boolean isCompleteResult() {
+        throw new UnsupportedOperationException("This method should be overridden in a subclass");
+    }
+
+    public boolean isRemoteDataLoaded() {
+        if (!isPartialRealm) {
+            return true;
+        } else if (subscription == null) {
+            // This will in some cases return false positives, like adding change listeners
+            // to synchronous queries. For now this is acceptable.
+            return false;
+        } else {
+            return subscription.getState() == OsSubscription.SubscriptionState.COMPLETE;
+        }
+    }
+
+    /**
+     * Returns {@code true} if this is the first time an asynchronous query returns a result, i.e.
+     * the query completed. 
+     */
+    public boolean isFirstAsyncCallback() {
+        return firstAsyncCallback;
+    }
+
+    /**
+     * Returns {@code true} if this changeset is empty, and doesn't contain any relevant changes.
+     */
+    public boolean isEmpty() {
+        // Since this wrap a Object Store changeset, it will always contains changes if an
+        // Object Store changeset exists.
+        return nativePtr == 0;
     }
 
     // Convert long array returned by the nativeGetXxxRanges() to Range array.
@@ -127,14 +171,6 @@ public long getNativeFinalizerPtr() {
         return ranges;
     }
 
-    private native static long nativeGetFinalizerPtr();
-
-    // Returns the ranges as an long array. eg.: [startIndex1, length1, startIndex2, length2, ...]
-    private native static int[] nativeGetRanges(long nativePtr, int type);
-
-    // Returns the indices array.
-    private native static int[] nativeGetIndices(long nativePtr, int type);
-
     @Override
     public String toString() {
         if (nativePtr == 0)  {
@@ -152,4 +188,25 @@ public String toString() {
         return string;
 
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return finalizerPtr;
+    }
+
+    private native static long nativeGetFinalizerPtr();
+
+    // Returns the ranges as a long array. eg.: [startIndex1, length1, startIndex2, length2, ...]
+    private native static int[] nativeGetRanges(long nativePtr, int type);
+
+    // Returns the indices array.
+    private native static int[] nativeGetIndices(long nativePtr, int type);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsList.java b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
index f532d6df69..6f30d9d364 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
@@ -247,11 +247,12 @@ public void removeAllListeners() {
     // Called by JNI
     @Override
     public void notifyChangeListeners(long nativeChangeSetPtr) {
-        if (nativeChangeSetPtr == 0) {
+        OsCollectionChangeSet changeset = new OsCollectionChangeSet(nativeChangeSetPtr, false);
+        if (changeset.isEmpty()) {
             // First time "query" returns. Do nothing.
             return;
         }
-        observerPairs.foreach(new Callback(new OsCollectionChangeSet(nativeChangeSetPtr)));
+        observerPairs.foreach(new Callback(changeset));
     }
 
     private static native long nativeGetFinalizerPtr();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
index c810eb9b9b..55690afbd1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
@@ -16,14 +16,17 @@
 
 package io.realm.internal;
 
+import java.util.ArrayList;
 import java.util.ConcurrentModificationException;
 import java.util.Date;
+import java.util.List;
 import java.util.NoSuchElementException;
 
 import javax.annotation.Nullable;
 
 import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.RealmChangeListener;
+import io.realm.internal.sync.OsSubscription;
 
 
 /**
@@ -202,9 +205,10 @@ public void set(@Nullable T object) {
     private final OsSharedRealm sharedRealm;
     private final NativeContext context;
     private final Table table;
-    private boolean loaded;
+    protected boolean loaded;
     private boolean isSnapshot = false;
-    private final ObserverPairList<CollectionObserverPair> observerPairs =
+
+    protected final ObserverPairList<CollectionObserverPair> observerPairs =
             new ObserverPairList<CollectionObserverPair>();
 
     // Public for static checking in JNI
@@ -431,16 +435,20 @@ public boolean isValid() {
     // Called by JNI
     @Override
     public void notifyChangeListeners(long nativeChangeSetPtr) {
-        if (nativeChangeSetPtr == 0 && isLoaded()) {
+        // Object Store compute the change set between the SharedGroup versions when the query created and the latest.
+        // So it is possible it deliver a non-empty change set for the first async query returns.
+        OsCollectionChangeSet changeset = (nativeChangeSetPtr == 0)
+                ? new EmptyLoadChangeSet(null, sharedRealm.isPartial())
+                : new OsCollectionChangeSet(nativeChangeSetPtr, !isLoaded(), null, sharedRealm.isPartial());
+
+        // Happens e.g. if a synchronous query is created, a change listener is added and then
+        // a transaction is started on the same thread. This will trigger all notifications
+        // and deliver an empty changeset.
+        if (changeset.isEmpty() && isLoaded()) {
             return;
         }
-        boolean wasLoaded = loaded;
         loaded = true;
-        // Object Store compute the change set between the SharedGroup versions when the query created and the latest.
-        // So it is possible it deliver a non-empty change set for the first async query returns. In this case, we
-        // return an empty change set to user since it is considered as the first time async query returns.
-        observerPairs.foreach(new Callback(nativeChangeSetPtr == 0 || !wasLoaded ?
-                null : new OsCollectionChangeSet(nativeChangeSetPtr)));
+        observerPairs.foreach(new Callback(changeset));
     }
 
     public Mode getMode() {
@@ -472,8 +480,8 @@ public void load() {
 
     private static native long nativeGetFinalizerPtr();
 
-    private static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr,
-            @Nullable SortDescriptor sortDesc, @Nullable SortDescriptor distinctDesc);
+    protected static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr,
+                                                     @Nullable SortDescriptor sortDesc, @Nullable SortDescriptor distinctDesc);
 
     private static native long nativeCreateSnapshot(long nativePtr);
 
@@ -517,4 +525,5 @@ private static native long nativeCreateResults(long sharedRealmNativePtr, long q
     private static native long nativeCreateResultsFromBacklinks(long sharedRealmNativePtr, long rowNativePtr, long srcTableNativePtr, long srColIndex);
 
     private static native void nativeEvaluateQueryIfNeeded(long nativePtr, boolean wantsNotifications);
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
index 137a2ef199..b897c13f5c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
@@ -26,9 +26,12 @@
 import javax.annotation.Nullable;
 
 import io.realm.RealmConfiguration;
+import io.realm.RealmModel;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
+import io.realm.internal.annotations.ObjectServer;
+import io.realm.sync.permissions.RealmPrivileges;
 
 @Keep
 public final class OsSharedRealm implements Closeable, NativeObject {
@@ -125,22 +128,6 @@ public int hashCode() {
         void onSchemaChanged();
     }
 
-    /**
-     * Callback function to be called from JNI by Object Store when the partial sync results returned.
-     */
-    @Keep
-    public abstract static class PartialSyncCallback {
-        private final String className;
-
-        protected PartialSyncCallback(String className) {
-            this.className = className;
-        }
-
-        public abstract void onSuccess(OsResults results);
-
-        public abstract void onError(RealmException error);
-    }
-
     // Const value for RealmFileException conversion
     public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
     public static final byte FILE_EXCEPTION_KIND_BAD_HISTORY = 1;
@@ -367,6 +354,21 @@ public void refresh() {
         return new OsSharedRealm.VersionID(versionId[0], versionId[1]);
     }
 
+    @ObjectServer
+    public int getPrivileges() {
+        return nativeGetRealmPrivileges(nativePtr);
+    }
+
+    @ObjectServer
+    public int getClassPrivileges(String className) {
+        return nativeGetClassPrivileges(nativePtr, className);
+    }
+
+    @ObjectServer
+    public int getObjectPrivileges(UncheckedRow row) {
+        return nativeGetObjectPrivileges(nativePtr, ((UncheckedRow) row).getNativePtr());
+    }
+
     public boolean isClosed() {
         return nativeIsClosed(nativePtr);
     }
@@ -399,10 +401,6 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
-    public void registerPartialSyncQuery(String query, PartialSyncCallback callback) {
-        nativeRegisterPartialSyncQuery(nativePtr, callback.className, query, callback);
-    }
-
     public RealmConfiguration getConfiguration() {
         return osRealmConfig.getRealmConfiguration();
     }
@@ -446,6 +444,13 @@ public void registerSchemaChangedCallback(SchemaChangedCallback callback) {
         nativeRegisterSchemaChangedCallback(nativePtr, callback);
     }
 
+    /**
+     * Returns {@code true} if this Realm is a partially synchronized Realm.
+     */
+    public boolean isPartial() {
+        return nativeIsPartial(nativePtr);
+    }
+
     // addIterator(), detachIterators() and invalidateIterators() are used to make RealmResults stable iterators work.
     // The iterator will iterate on a snapshot Results if it is accessed inside a transaction.
     // See https://github.com/realm/realm-java/issues/3883 for more information.
@@ -531,27 +536,6 @@ private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealm
         callback.onInit(new OsSharedRealm(nativeSharedRealmPtr, osRealmConfig));
     }
 
-    /**
-     * Called from JNI when the partial sync callback is invoked from the ObjectStore.
-     *
-     * @param error            if the partial sync query failed to register.
-     * @param nativeResultsPtr pointer to the {@code Results} of the partial sync query.
-     * @param callback         the callback registered from the user to notify the success/error of the partial sync query.
-     */
-    @SuppressWarnings("unused")
-    private void runPartialSyncRegistrationCallback(@Nullable String error, long nativeResultsPtr,
-                                                    PartialSyncCallback callback) {
-        if (error != null) {
-            callback.onError(new RealmException(error));
-        } else {
-            @SuppressWarnings("ConstantConditions")
-            Table table = getTable(Table.getTableNameForClass(callback.className));
-            OsResults results = new OsResults(this, table, nativeResultsPtr);
-            callback.onSuccess(results);
-        }
-    }
-
-
     private static native void nativeInit(String temporaryDirectoryPath);
 
     private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
@@ -613,6 +597,11 @@ private static native long nativeCreateTableWithPrimaryKeyField(long nativeShare
 
     private static native void nativeRegisterSchemaChangedCallback(long nativePtr, SchemaChangedCallback callback);
 
-    private native void nativeRegisterPartialSyncQuery(
-            long nativeSharedRealmPtr, String className, String query, PartialSyncCallback callback);
+    private static native int nativeGetRealmPrivileges(long nativePtr);
+
+    private static native int nativeGetClassPrivileges(long nativePtr, String className);
+
+    private static native int nativeGetObjectPrivileges(long nativePtr, long rowNativePtr);
+    private static native boolean nativeIsPartial(long nativePtr);
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
index cec9d4acdd..96e4f78481 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -88,6 +88,13 @@ protected RealmNotifier(@Nullable OsSharedRealm sharedRealm) {
     // This list is NOT supposed to be thread safe!
     private List<Runnable> transactionCallbacks = new ArrayList<Runnable>();
 
+    // List of runnables called when Object Store is about to start sending out notifications about
+    // a version update for the current thread.
+    private List<Runnable> startSendingNotificationsCallbacks = new ArrayList<>();
+
+    // List of runnables called when Object Store has finished sending out notifications for the
+    // version of the Realm on this thread.
+    private List<Runnable> finishedSendingNotificationsCallbacks = new ArrayList<>();
 
     // Called from JavaBindingContext::did_change.
     // This will be called in the caller thread when:
@@ -124,16 +131,34 @@ void beforeNotify() {
         sharedRealm.invalidateIterators();
     }
 
+    // Called from JavaBindingContext::will_send_notifications
+    // This will be called before any change notifications are delivered when updating a
+    // Realm version. This will be triggered even if no change listeners are registered.
+    void willSendNotifications() {
+        for (int i = 0; i < startSendingNotificationsCallbacks.size(); i++) {
+            startSendingNotificationsCallbacks.get(i).run();
+        }
+    }
+
+    // Called from JavaBindingContext::will_send_notifications
+    void didSendNotifications() {
+        for (int i = 0; i < startSendingNotificationsCallbacks.size(); i++) {
+            finishedSendingNotificationsCallbacks.get(i).run();
+        }
+    }
+
     /**
      * Called when close OsSharedRealm to clean up any event left in to queue.
      */
     @Override
     public void close() {
         removeAllChangeListeners();
+        startSendingNotificationsCallbacks.clear();
+        finishedSendingNotificationsCallbacks.clear();
     }
 
     public <T> void addChangeListener(T observer, RealmChangeListener<T> realmChangeListener) {
-        RealmObserverPair observerPair = new RealmObserverPair<T>(observer, realmChangeListener);
+        RealmObserverPair observerPair = new RealmObserverPair<>(observer, realmChangeListener);
         realmObserverPairs.add(observerPair);
     }
 
@@ -165,4 +190,12 @@ public void addTransactionCallback(Runnable runnable) {
     public int getListenersListSize() {
         return realmObserverPairs.size();
     }
+
+    public void addBeginSendingNotificationsCallback(Runnable runnable) {
+        startSendingNotificationsCallbacks.add(runnable);
+    }
+
+    public void addFinishedSendingNotificationsCallback(Runnable runnable) {
+        finishedSendingNotificationsCallbacks.add(runnable);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/StatefulCollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/StatefulCollectionChangeSet.java
new file mode 100644
index 0000000000..dae64a411e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/StatefulCollectionChangeSet.java
@@ -0,0 +1,87 @@
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.log.RealmLog;
+
+/**
+ * A wrapper around {@link OsCollectionChangeSet} that makes it stateful with regard to how many
+ * times it has been invoked.
+ *
+ * Note that Object Store will calculate the changes between the query was registered and when it
+ * completes. This information is not useful and might even be misleading when reporting first
+ * result ({@link io.realm.OrderedCollectionChangeSet.State#INITIAL}.
+ */
+public class StatefulCollectionChangeSet implements OrderedCollectionChangeSet {
+
+    private final OrderedCollectionChangeSet changeset;
+    private final Throwable error;
+    private final State state;
+    private final boolean remoteDataSynchronized;
+
+    /**
+     * @param backingChangeset Underlying changeset backing this.
+     */
+    public StatefulCollectionChangeSet(OsCollectionChangeSet backingChangeset) {
+        this.changeset = backingChangeset;
+
+        // Calculate the state here since object is immutable
+        boolean isInitial = backingChangeset.isFirstAsyncCallback();
+        remoteDataSynchronized = backingChangeset.isRemoteDataLoaded();
+
+        error = backingChangeset.getError();
+        if (error != null) {
+            state = State.ERROR;
+        } else {
+            state = (isInitial) ? State.INITIAL : State.UPDATE;
+        }
+    }
+
+    @Override
+    public State getState() {
+        return state;
+    }
+
+    @Override
+    public int[] getDeletions() {
+        return changeset.getDeletions();
+    }
+
+    @Override
+    public int[] getInsertions() {
+        return changeset.getInsertions();
+    }
+
+    @Override
+    public int[] getChanges() {
+        return changeset.getChanges();
+    }
+
+    @Override
+    public Range[] getDeletionRanges() {
+        return changeset.getDeletionRanges();
+    }
+
+    @Override
+    public Range[] getInsertionRanges() {
+        return changeset.getInsertionRanges();
+    }
+
+    @Override
+    public Range[] getChangeRanges() {
+        return changeset.getChangeRanges();
+    }
+
+    @Nullable
+    @Override
+    public Throwable getError() {
+        return error;
+    }
+
+    @Override
+    public boolean isCompleteResult() {
+        return remoteDataSynchronized;
+    }
+}
+
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
new file mode 100644
index 0000000000..18d91b4626
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmChangeListener;
+import io.realm.internal.sync.OsSubscription;
+
+/**
+ * Wrapper around Object Stores Results class that is capable of combining partial sync Subscription
+ * state updates and collection change updates.
+ */
+public class SubscriptionAwareOsResults extends OsResults {
+
+    // The native ptr to a delayed notification. Since Java group all notifications for each
+    // RealmResults, only one change from OS will ever be sent.
+    private long delayedNotificationPtr = 0;
+    // If true, the subscription somehow changed during this round of notifications being sent
+    private boolean subscriptionChanged;
+    // Reference to a (potential) underlying subscription
+    private OsSubscription subscription = null;
+    private boolean collectionChanged = false;
+    private boolean firstCallback;
+
+    public static SubscriptionAwareOsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query,
+                                                             @Nullable SortDescriptor sortDescriptor,
+                                                             @Nullable SortDescriptor distinctDescriptor,
+                                                             String subscriptionName) {
+        query.validateQuery();
+        long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(), sortDescriptor, distinctDescriptor);
+        return new SubscriptionAwareOsResults(sharedRealm, query.getTable(), ptr, subscriptionName);
+    }
+
+    SubscriptionAwareOsResults(OsSharedRealm sharedRealm, Table table, long nativePtr, String subscriptionName) {
+        super(sharedRealm, table, nativePtr);
+
+        this.firstCallback = true;
+        this.subscription = new OsSubscription(this, subscriptionName);
+        this.subscription.addChangeListener(new RealmChangeListener<OsSubscription>() {
+            @Override
+            public void onChange(OsSubscription o) {
+                subscriptionChanged = true;
+            }
+        });
+        RealmNotifier notifier = sharedRealm.realmNotifier;
+        notifier.addBeginSendingNotificationsCallback(new Runnable() {
+            @Override
+            public void run() {
+                subscriptionChanged = false;
+                collectionChanged = false;
+                delayedNotificationPtr = 0;
+            }
+        });
+        notifier.addFinishedSendingNotificationsCallback(new Runnable() {
+            @Override
+            public void run() {
+                if (collectionChanged || subscriptionChanged) {
+                    triggerDelayedChangeListener();
+                }
+            }
+        });
+    }
+
+    private void triggerDelayedChangeListener() {
+        // Only parse on the subscription if it actually changed
+        OsSubscription subscription = (subscriptionChanged) ? this.subscription : null;
+
+        // In case no collection listener was triggered, only trigger the listener if non-relevant
+        // changes happened to the subscription. In our case this means we only care about the
+        // errors and a completed subscription
+        if (delayedNotificationPtr == 0
+                && subscription != null
+                && subscription.getState() != OsSubscription.SubscriptionState.ERROR
+                && subscription.getState() != OsSubscription.SubscriptionState.COMPLETE) {
+            return;
+        }
+
+        OsCollectionChangeSet changeset;
+        if (delayedNotificationPtr == 0) {
+            changeset = new EmptyLoadChangeSet(subscription, firstCallback, true);
+        } else {
+            changeset = new OsCollectionChangeSet(delayedNotificationPtr, firstCallback, subscription, true);
+        }
+
+        // Happens e.g. if a synchronous query is created, a change listener is added and then
+        // a transaction is started on the same thread. This will trigger all notifications
+        // and deliver an empty changeset.
+        if (changeset.isEmpty() && isLoaded()) {
+            return;
+        }
+        loaded = true;
+        firstCallback = false;
+        observerPairs.foreach(new Callback(changeset));
+    }
+
+    @Override
+    public void notifyChangeListeners(long nativeChangeSetPtr) {
+        collectionChanged = true;
+        delayedNotificationPtr = nativeChangeSetPtr;
+    }
+
+}
+
+
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 8be0dc7078..533603d665 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -261,10 +261,12 @@ public boolean isEmpty() {
 
     /**
      * Clears the table i.e., deleting all rows in the table.
+     *
+     * If using partial sync, this method will behave similarly to 'findAll().deleteFromRealm()'.
      */
-    public void clear() {
+    public void clear(boolean partialRealm) {
         checkImmutable();
-        nativeClear(nativePtr);
+        nativeClear(nativePtr, partialRealm);
     }
 
     // Column Information.
@@ -724,7 +726,7 @@ public static String getTableNameForClass(String name) {
 
     private native long nativeSize(long nativeTablePtr);
 
-    private native void nativeClear(long nativeTablePtr);
+    private native void nativeClear(long nativeTablePtr, boolean partialRealm);
 
     private native long nativeGetColumnCount(long nativeTablePtr);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 6dc7389628..2e99d61680 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -47,6 +47,14 @@ public static String getTablePrefix() {
      * was a RealmProxy class.
      */
     public static Class<? extends RealmModel> getOriginalModelClass(Class<? extends RealmModel> clazz) {
+
+        // The compiler would allow these classes to be passed as arguments, but they are never
+        // valid as a Realm model class
+        if (clazz.equals(RealmModel.class) || clazz.equals(RealmObject.class)) {
+            throw new IllegalArgumentException("RealmModel or RealmObject was passed as an argument. " +
+                    "Only subclasses of these can be used as arguments to methods that accept a Realm model class.");
+        }
+
         // This cast is correct because 'clazz' is either the type
         // generated by RealmProxy or the original type extending directly from RealmObject.
         @SuppressWarnings("unchecked")
diff --git a/realm/realm-library/src/main/java/io/realm/internal/annotations/ObjectServer.java b/realm/realm-library/src/main/java/io/realm/internal/annotations/ObjectServer.java
new file mode 100644
index 0000000000..a70ebfc80a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/annotations/ObjectServer.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to mark the classes as being specific to the Realm Object Server.
+ * They will be stripped in the Base variant.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target({ElementType.TYPE, ElementType.METHOD})
+
+public @interface ObjectServer {
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 137ba6605d..88fa860c3e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -31,6 +31,7 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.OsSchemaInfo;
@@ -176,7 +177,7 @@ public boolean transformerApplied() {
     private RealmProxyMediator getMediator(Class<? extends RealmModel> clazz) {
         RealmProxyMediator mediator = mediators.get(clazz);
         if (mediator == null) {
-            throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
+            throw new RealmException(clazz.getSimpleName() + " is not part of the schema for this Realm");
         }
         return mediator;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java b/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
new file mode 100644
index 0000000000..608f91f601
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/OsSubscription.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.sync;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmChangeListener;
+import io.realm.internal.KeepMember;
+import io.realm.internal.NativeObject;
+import io.realm.internal.ObserverPairList;
+import io.realm.internal.OsResults;
+
+public class OsSubscription implements NativeObject {
+
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    // Mirrors the values in https://github.com/realm/realm-object-store/blob/master/src/sync/subscription_state.hpp
+    public enum SubscriptionState {
+        ERROR(-1),  // An error occurred while creating or processing the partial sync subscription.
+        CREATING(2), // The subscription is being created.
+        PENDING(0), // The subscription was created, but has not yet been processed by the sync server.
+        COMPLETE(1), // The subscription has been processed by the sync server and data is being synced to the device.
+        INVALIDATED(3); // The subscription has been removed.
+
+        private final int val;
+
+        SubscriptionState(int val) {
+            this.val = val;
+        }
+
+        public static SubscriptionState fromInternalValue(int val) {
+            for (SubscriptionState subscriptionState : values()) {
+                if (subscriptionState.val == val) {
+                    return subscriptionState;
+                }
+            }
+            throw new IllegalArgumentException("Unknown value: " + val);
+        }
+    }
+
+    private static class SubscriptionObserverPair
+            extends ObserverPairList.ObserverPair<OsSubscription, RealmChangeListener<OsSubscription>> {
+        public SubscriptionObserverPair(OsSubscription observer, RealmChangeListener<OsSubscription> listener) {
+            super(observer, listener);
+        }
+
+        public void onChange(OsSubscription observer) {
+            listener.onChange(observer);
+        }
+    }
+
+    private static class Callback implements ObserverPairList.Callback<SubscriptionObserverPair> {
+        @Override
+        public void onCalled(SubscriptionObserverPair pair, Object observer) {
+            pair.onChange((OsSubscription) observer);
+        }
+    }
+
+    private final long nativePtr;
+    protected final ObserverPairList<SubscriptionObserverPair> observerPairs = new ObserverPairList<>();
+
+    public OsSubscription(OsResults results, String subscriptionName) {
+        this.nativePtr = nativeCreate(results.getNativePtr(), subscriptionName);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public SubscriptionState getState() {
+        return SubscriptionState.fromInternalValue(nativeGetState(nativePtr));
+    }
+
+    @Nullable
+    public Throwable getError() {
+        return (Throwable) nativeGetError(nativePtr);
+    }
+
+    public void addChangeListener(RealmChangeListener<OsSubscription> listener) {
+        if (observerPairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+        observerPairs.add(new SubscriptionObserverPair(this, listener));
+    }
+
+    public void removeChangeListener(RealmChangeListener<OsSubscription> listener) {
+        observerPairs.remove(this, listener);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    // Called from JNI
+    @KeepMember
+    private void notifyChangeListeners() {
+        observerPairs.foreach(new Callback());
+    }
+
+    private static native long nativeCreate(long resultsNativePtr, String subscriptionName);
+
+    private static native long nativeGetFinalizerPtr();
+
+    private static native int nativeGetState(long nativePtr);
+
+    private static native Object nativeGetError(long nativePtr);
+
+    private native void nativeStartListening(long nativePtr);
+
+    private native void nativeStopListening(long nativePtr);
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java b/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java
new file mode 100644
index 0000000000..72c5ea0d72
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/SubscriptionAction.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.sync;
+
+/**
+ * Wrapper class describing if and how a subscription should be created when creating a query result.
+ */
+public class SubscriptionAction {
+    public static final SubscriptionAction NO_SUBSCRIPTION = new SubscriptionAction(null);
+    public static final SubscriptionAction ANONYMOUS_SUBSCRIPTION = new SubscriptionAction("");
+
+    public static SubscriptionAction create(String subscriptionName) {
+        return new SubscriptionAction(subscriptionName);
+    }
+
+    private final String subscriptionName;
+
+    private SubscriptionAction(String name) {
+        this.subscriptionName = name;
+    }
+
+    public boolean shouldCreateSubscriptions() {
+        return subscriptionName != null;
+    }
+
+    public String getName() {
+        return subscriptionName;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java
new file mode 100644
index 0000000000..aadd98706f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.Required;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * Class describing all permissions related to a given Realm model class. These permissions will
+ * be inherited by any concrete objects of the given type.
+ * <p>
+ * If a class level permission grants a privilege, it is still possible for individual objects
+ * to revoke them again, i.e. it is possible for the class level permission to grant general read
+ * access, while the individual objects are still able to revoke them.
+ * <p>
+ * The opposite is not true, so if a privilege is not granted at the class level, it can never
+ * be granted at the object level, no matter what kind of permissions are set there.
+ *
+ * @see <a href="FIX">Object Level Permissions</a> for an detailed description of the Realm Object
+ * Server permission system.
+ */
+@ObjectServer
+@RealmClass(name = "__Class")
+public class ClassPermissions extends RealmObject {
+
+    @PrimaryKey
+    @Required
+    private String name; // Name of the class in the schema
+    private RealmList<Permission> permissions = new RealmList<>();
+
+    @Ignore
+    Class<? extends RealmModel> modelClassRef;
+
+    public ClassPermissions() {
+        // Required by Realm
+    }
+
+    /**
+     * Creates permissions for the given Realm model class. Only one {@code ClassPermissions} object
+     * can exist pr Realm model class.
+     *
+     * @param clazz class to create permissions.
+     */
+    public ClassPermissions(Class<? extends RealmModel> clazz) {
+        if (clazz == null) {
+            throw new IllegalArgumentException("Non-null 'clazz' required.");
+        }
+        modelClassRef = clazz;
+        name = clazz.getSimpleName();
+    }
+
+    /**
+     * Returns the name of the class these permissions apply to. If this object is unmanaged
+     * this name returned will be the simple name of the Java class. If the object is managed
+     * it will be the internal name Realm uses to represent the class.
+     *
+     * @return the name of the class these permissions apply to.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns all Class level permissions for the class defined by {@link #getName()}. This is the
+     * default set of permissions for the class unless otherwise re-defined by object level
+     * permissions.
+     *
+     * @return all Class level permissions
+     */
+    public RealmList<Permission> getPermissions() {
+        return permissions;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPrivileges.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPrivileges.java
new file mode 100644
index 0000000000..dbaea92950
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPrivileges.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * This object combines all privileges granted on the Class by all Roles which the
+ * current User is a member of into the final privileges which will be enforced by
+ * the server.
+ *
+ * The privilege calculation is done locally using cached data, and inherently may
+ * be stale. It is possible that this method may indicate that an operation is
+ * permitted but the server will still reject it if permission is revoked before
+ * the changes have been integrated on the server. If this happens, the server will
+ * automatically revoke any illegal operations.
+ *
+ * Non-synchronized Realms always have permission to perform all operations.
+ */
+@ObjectServer
+public final class ClassPrivileges {
+
+    private boolean canRead;
+    private boolean canUpdate;
+    private boolean canDelete;
+    private boolean canSetPermissions;
+    private boolean canQuery;
+    private boolean canCreate;
+    private boolean canModifySchema;
+
+    public ClassPrivileges(long privileges) {
+        this.canRead = (privileges & (1 << 0)) != 0;
+        this.canUpdate = (privileges & (1 << 1)) != 0;
+        this.canDelete = (privileges & (1 << 2)) != 0;
+        this.canSetPermissions = (privileges & (1 << 3)) != 0;
+        this.canQuery = (privileges & (1 << 4)) != 0;
+        this.canCreate = (privileges & (1 << 5)) != 0;
+        this.canModifySchema = (privileges & (1 << 6)) != 0;
+    }
+
+    /**
+     * Returns whether or not the user can read objects of this type.
+     * <p>
+     * If {@code false}, the current User is not permitted to see objects of this type, and
+     + attempting to query this class will always return empty results.
+     + <p>
+     + Note that Read permissions are transitive, and so it may be possible to read an
+     + object which the user does not directly have Read permissions for by following a
+     + link to it from an object they do have Read permissions for. This does not apply
+     + to any of the other permission types.
+     *
+     * @return {@code true} if the user can read objects of the given type, {@code false} if not.
+     */
+    public boolean canRead() {
+        return canRead;
+    }
+
+    /**
+     * Returns whether or not the user can update objects of the given type.
+     * <p>
+     * If {@code true}, the user is allowed to update properties on all objects of this type in
+     * the Realm. This does not include updating permissions nor creating or deleting objects.
+     *
+     * @return {@code true} if the user can update objects of the given type, {@code false} if not.
+     */
+    public boolean canUpdate() {
+        return canUpdate;
+    };
+
+    /**
+     * Returns whether or not the user can change the {@link ClassPermissions} object representing
+     * the given class. See this clas for further details.
+     *
+     * @return {@code true} if the user can modify the {@link ClassPermissions} object for the given
+     * class, {@code false} if not.
+     * @see ClassPermissions
+     */
+    public boolean canSetPermissions() {
+        return canSetPermissions;
+    };
+
+    /**
+     * Returns whether or not the user can query the given class.
+     * <p>
+     * If this returns {@code false}, queries can still be run, but they will always return the
+     * empty result. This can be useful to prevent people from querying leaf objects in a tree
+     * structure and force them to only access objects through some parent objects that reference
+     * them.
+     *
+     * @return {@code true} if the user can query the given class, {@code false} if not.
+     */
+    public boolean canQuery() {
+        return canQuery;
+    }
+
+    /**
+     * Returns whether or not this user is allowed to create objects of this type.
+     *
+     * @return {@code true} if the user can create objects of this type, {@code false} if not.
+     */
+    public boolean canCreate() {
+        return canCreate;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ClassPrivileges that = (ClassPrivileges) o;
+
+        if (canRead != that.canRead) return false;
+        if (canUpdate != that.canUpdate) return false;
+        if (canDelete != that.canDelete) return false;
+        if (canSetPermissions != that.canSetPermissions) return false;
+        if (canQuery != that.canQuery) return false;
+        if (canCreate != that.canCreate) return false;
+        return canModifySchema == that.canModifySchema;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (canRead ? 1 : 0);
+        result = 31 * result + (canUpdate ? 1 : 0);
+        result = 31 * result + (canDelete ? 1 : 0);
+        result = 31 * result + (canSetPermissions ? 1 : 0);
+        result = 31 * result + (canQuery ? 1 : 0);
+        result = 31 * result + (canCreate ? 1 : 0);
+        result = 31 * result + (canModifySchema ? 1 : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "RealmPrivileges{" +
+                "canRead=" + canRead +
+                ", canUpdate=" + canUpdate +
+                ", canDelete=" + canDelete +
+                ", canSetPermissions=" + canSetPermissions +
+                ", canQuery=" + canQuery +
+                ", canCreate=" + canCreate +
+                ", canModifySchema=" + canModifySchema +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/ObjectPrivileges.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/ObjectPrivileges.java
new file mode 100644
index 0000000000..2ffff816da
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/ObjectPrivileges.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.Realm;
+import io.realm.RealmModel;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * This object combines all privileges granted on a Realm object by all Roles which the
+ * current User is a member of into the final privileges which will be enforced by
+ * the server.
+ *
+ * The privilege calculation is done locally using cached data, and inherently may
+ * be stale. It is possible that this method may indicate that an operation is
+ * permitted but the server will still reject it if permission is revoked before
+ * the changes have been integrated on the server. If this happens, the server will
+ * automatically revoke any illegal operations.
+ *
+ * Non-synchronized Realms always have permission to perform all operations.
+ */
+@ObjectServer
+public final class ObjectPrivileges {
+
+    private boolean canRead;
+    private boolean canUpdate;
+    private boolean canDelete;
+    private boolean canSetPermissions;
+    private boolean canQuery;
+    private boolean canCreate;
+    private boolean canModifySchema;
+
+    public ObjectPrivileges(long privileges) {
+        this.canRead = (privileges & (1 << 0)) != 0;
+        this.canUpdate = (privileges & (1 << 1)) != 0;
+        this.canDelete = (privileges & (1 << 2)) != 0;
+        this.canSetPermissions = (privileges & (1 << 3)) != 0;
+        this.canQuery = (privileges & (1 << 4)) != 0;
+        this.canCreate = (privileges & (1 << 5)) != 0;
+        this.canModifySchema = (privileges & (1 << 6)) != 0;
+    }
+
+    /**
+     * Returns whether or not the user can see/read the object.
+     *
+     * @return {@code true} if the user can read the object, {@code false} if not.
+     */
+    public boolean canRead() {
+        return canRead;
+    }
+
+    /**
+     * Returns whether or not the user can update fields on the object. This does not
+     * include deleting (see {@link #canDelete()} nor if permissions can be updated (see
+     * {@link #canSetPermissions()}).
+     *
+     * @return {@code true} if the user can update fields on the object, {@code false} if not.
+     */
+    public boolean canUpdate() {
+        return canUpdate;
+    };
+
+
+    /**
+     * Returns whether or not the user can delete the object.
+     *
+     * @return {@code true} if the user can delete the object, {@code false} if not.
+     */
+    public boolean canDelete() {
+        return canDelete;
+    }
+
+    /**
+     * Returns whether or not the user can change permissions on the object through its custom
+     * permission field (A field of the type {@code RealmList<Permission>}).
+     *
+     * @return {@code true} if the user can modify the permissions on the object, {@code false} if not.
+     */
+    public boolean canSetPermissions() {
+        return canSetPermissions;
+    };
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ObjectPrivileges that = (ObjectPrivileges) o;
+
+        if (canRead != that.canRead) return false;
+        if (canUpdate != that.canUpdate) return false;
+        if (canDelete != that.canDelete) return false;
+        if (canSetPermissions != that.canSetPermissions) return false;
+        if (canQuery != that.canQuery) return false;
+        if (canCreate != that.canCreate) return false;
+        return canModifySchema == that.canModifySchema;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (canRead ? 1 : 0);
+        result = 31 * result + (canUpdate ? 1 : 0);
+        result = 31 * result + (canDelete ? 1 : 0);
+        result = 31 * result + (canSetPermissions ? 1 : 0);
+        result = 31 * result + (canQuery ? 1 : 0);
+        result = 31 * result + (canCreate ? 1 : 0);
+        result = 31 * result + (canModifySchema ? 1 : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "RealmPrivileges{" +
+                "canRead=" + canRead +
+                ", canUpdate=" + canUpdate +
+                ", canDelete=" + canDelete +
+                ", canSetPermissions=" + canSetPermissions +
+                ", canQuery=" + canQuery +
+                ", canCreate=" + canCreate +
+                ", canModifySchema=" + canModifySchema +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/Permission.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/Permission.java
new file mode 100644
index 0000000000..d0838b4287
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/Permission.java
@@ -0,0 +1,573 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.RealmObject;
+import io.realm.annotations.RealmClass;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * This class encapsulates the privileges granted a given {@link Role}. These privileges can be
+ * applied to either the entire Realm, Classes or individual objects.
+ * <p>
+ * If no privileges are defined for an individual object, the values {@link ClassPermissions}
+ * will be inherited, if no values are defined there, the ones from {@link RealmPermissions} will
+ * be used. If no values can be found there, no privileges are granted.
+ * <p>
+ * Not all privileges are meaningful all levels, e.g. `canCreate` is only meaningful when applied to
+ * classes, but it can still be defined at the Realm level. In that case all class permission objects
+ * will inherit the value unless they specifically override it. See the individual privileges for the
+ * details.
+ * <p>
+ * When added to either {@link RealmPermissions}, {@link ClassPermissions} or a {@link RealmObject},
+ * only one Permission object can exist for that role. If multiple objects are added the behavior
+ * is undefined and the Object Server might modify or delete both objects.
+ *
+ * @see <a href="FIX">Object Level Permissions</a> for an detailed description of the Realm Object
+ * Server permission system.
+ */
+@ObjectServer
+@RealmClass(name = "__Permission")
+public class Permission extends RealmObject {
+
+    /**
+     * Creates a {@link Permission} object in a fluid manner.
+     */
+    public static class Builder {
+        private Role role;
+        private boolean canRead = false;
+        private boolean canUpdate = false;
+        private boolean canDelete = false;
+        private boolean canSetPermissions = false;
+        private boolean canQuery = false;
+        private boolean canCreate = false;
+        private boolean canModifySchema = false;
+
+        /**
+         * Creates the builder. The default state is that no privileges are enabled.
+         *
+         * @param role {@link Role} for which these privileges apply.
+         */
+        public Builder(Role role) {
+            this.role = role;
+        }
+
+        /**
+         * Enables all privileges.
+         */
+        public Builder allPrivileges() {
+            canRead = false;
+            canUpdate = false;
+            canDelete = false;
+            canSetPermissions = false;
+            canQuery = false;
+            canCreate = false;
+            canModifySchema = false;
+            return this;
+        }
+
+        /**
+         * Disables all privileges.
+         */
+        public Builder noPrivileges() {
+            canRead = true;
+            canUpdate = true;
+            canDelete = true;
+            canSetPermissions = true;
+            canQuery = true;
+            canCreate = true;
+            canModifySchema = true;
+            return this;
+        }
+
+        /**
+         * Defines if this role can read from given resource or not.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         The role is allowed to read all objects from the Realm. If {@code false}, the
+         *         Realm will appear completely empty to the role, effectively making it inaccessible.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         The role is allowed to read the objects of this type and all referenced objects,
+         *         even if those objects themselves have set this to {@code false}.
+         *         If {@code false}, the role cannot see any object of this type and all queries
+         *         against the type will return no results.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *          Determines if a role is allowed to see the individual object or not.
+         *     </li>
+         * </ol>
+         *
+         * @param canRead {@code true} if the role is allowed to read this resource, {@code false} if not.
+         */
+        public Builder canRead(boolean canRead) {
+            this.canRead = canRead;
+            return this;
+        }
+
+        /**
+         * Defines if this role can update the given resource or not.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         If {@code true}, the role is allowed update properties on all objects in the Realm.
+         *         This does not include updating permissions nor creating or deleting objects.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         If {@code true}, the role is allowed update properties on all objects of this type in
+         *         the Realm. This does not include updating permissions nor creating or deleting objects.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *         If {@code true}, the role is allowed to update properties on the object. This
+         *         does not cover updating permissions or deleting the object.
+         *     </li>
+         * </ol>
+         *
+         * @param canUpdate {@code true} if the role is allowed to update this resource, {@code false} if not.
+         */
+        public Builder canUpdate(boolean canUpdate) {
+            this.canUpdate = canUpdate;
+            return this;
+        }
+
+        /**
+         * Defines if this role can delete the given resource or not.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         Not applicable.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         Not applicable.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *         If {@code true}, the role is allowed to delete the object.
+         *     </li>
+         * </ol>
+         *
+         * @param canDelete {@code true} if the role is allowed to delete this resource, {@code false} if not.
+         */
+        public Builder canDelete(boolean canDelete) {
+            this.canDelete = canDelete;
+            return this;
+        }
+
+        /**
+         * Defines if this role is allowed to change permissions on the given resource.
+         * Permissions can only be granted at the same permission level or below. E.g. if set on
+         * a Class, it is not possible to change Realm level permissions, but does allow the role to
+         * change object level permissions for objects of that type.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         The role is allowed to modify the {@link RealmPermissions} object.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         The role is allowed the change the {@link ClassPermissions} object.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *         The role is allowed to change the permissions on this object.
+         *     </li>
+         * </ol>
+         *
+         * @param canSetPermissions {@code true} if the role is allowed to change the permissions for this resource.
+         */
+        public Builder canSetPermissions(boolean canSetPermissions) {
+            this.canSetPermissions = canSetPermissions;
+            return this;
+        }
+
+        /**
+         * Defines if this role is allowed to query the resource or not.
+         * <p>
+         * Note, that local queries are always possible, but the query result will just be empty.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         Not applicable.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         The role is allowed to query objects of this type.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *         Not applicable.
+         *     </li>
+         * </ol>
+         *
+         * @param canQuery {@code true} if the role is allowed to query objects of this type.
+         */
+        public Builder canQuery(boolean canQuery) {
+            this.canQuery = canQuery;
+            return this;
+        }
+
+
+        /**
+         * Defines if this role is allowed to create objects of this type.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         Not applicable.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         If {@code true}, the role is allowed to create objects of this type.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *         Not applicable.
+         *     </li>
+         * </ol>
+         *
+         * @param canCreate {@code true} if the role is allowed to create objects of this type.
+         */
+        public Builder canCreate(boolean canCreate) {
+            this.canCreate = canCreate;
+            return this;
+        }
+
+        /**
+         * Defines if this role is allowed to modify the schema of this resource.
+         *
+         * <ol>
+         *     <li>
+         *         <b>Realm:</b>
+         *         If {@code true} the role is allowed to create classes in the Realm.
+         *     </li>
+         *     <li>
+         *         <b>Class:</b>
+         *         If {@code true}, the role is allowed to add properties to the specified class.
+         *     </li>
+         *     <li>
+         *         <b>Object:</b>
+         *         Not applicable.
+         *     </li>
+         * </ol>
+         *
+         * @param canModifySchema {@code true} if the role is allowed to modify the schema of this resource.
+         */
+        public Builder canModifySchema(boolean canModifySchema) {
+            this.canModifySchema = canModifySchema;
+            return this;
+        }
+
+        /**
+         * Creates the unmanaged {@link Permission} object.
+         */
+        public Permission build() {
+            return new Permission(
+                    role,
+                    canRead,
+                    canUpdate,
+                    canDelete,
+                    canSetPermissions,
+                    canQuery,
+                    canCreate,
+                    canModifySchema
+            );
+        }
+    }
+
+    private Role role;
+    private boolean canRead;
+    private boolean canUpdate;
+    private boolean canDelete;
+    private boolean canSetPermissions;
+    private boolean canQuery;
+    private boolean canCreate;
+    private boolean canModifySchema;
+
+    public Permission() {
+        // Required by Realm
+    }
+
+    /**
+     * Creates a set of privileges for the given role.
+     */
+    public Permission(Role role) {
+        this.role = role;
+    }
+
+    /**
+     * Creates a set of privileges for the given role.
+     */
+    private Permission(Role role, boolean canRead, boolean canUpdate, boolean canDelete, boolean canSetPermissions, boolean canQuery, boolean canCreate, boolean canModifySchema) {
+        this.role = role;
+        this.canRead = canRead;
+        this.canUpdate = canUpdate;
+        this.canDelete = canDelete;
+        this.canSetPermissions = canSetPermissions;
+        this.canQuery = canQuery;
+        this.canCreate = canCreate;
+        this.canModifySchema = canModifySchema;
+    }
+
+    /**
+     * Returns the role these privileges apply to.
+     *
+     * @return the role these privileges apply to.
+     */
+    public Role getRole() {
+        return role;
+    }
+
+    /**
+     * Returns {@code true} if the role is allowed to read the resource, {@code false} if not.
+     */
+    public boolean canRead() {
+        return canRead;
+    }
+
+    /**
+     * Defines if this role can read from given resource or not.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         The role is allowed to read all objects from the Realm. If {@code false}, the
+     *         Realm will appear completely empty to the role, effectively making it inaccessible.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         The role is allowed to read the objects of this type and all referenced objects,
+     *         even if those objects themselves have set this to {@code false}.
+     *         If {@code false}, the role cannot see any object of this type and all queries
+     *         against the type will return no results.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *          Determines if a role is allowed to see the individual object or not.
+     *     </li>
+     * </ol>
+     *
+     * @param canRead {@code true} if the role is allowed to read this resource, {@code false} if not.
+     */
+    public void setCanRead(boolean canRead) {
+        this.canRead = canRead;
+    }
+
+    /**
+     * Returns {@code true} if the role is allowed to update the resource, {@code false} if not.
+     */
+    public boolean canUpdate() {
+        return canUpdate;
+    }
+
+    /**
+     * Defines if this role can update the given resource or not.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         If {@code true}, the role is allowed update properties on all objects in the Realm.
+     *         This does not include updating permissions nor creating or deleting objects.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         If {@code true}, the role is allowed update properties on all objects of this type in
+     *         the Realm. This does not include updating permissions nor creating or deleting objects.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         If {@code true}, the role is allowed to update properties on the object. This
+     *         does not cover updating permissions or deleting the object.
+     *     </li>
+     * </ol>
+     *
+     * @param canUpdate {@code true} if the role is allowed to update this resource, {@code false} if not.
+     */
+    public void setCanUpdate(boolean canUpdate) {
+        this.canUpdate = canUpdate;
+    }
+
+    /**
+     * Returns {@code true} if the role is allowed to delete the object , {@code false} if not.
+     */
+    public boolean canDelete() {
+        return canDelete;
+    }
+
+    /**
+     * Defines if this role can delete the given resource or not.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         Not applicable.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         Not applicable.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         If {@code true}, the role is allowed to delete the object.
+     *     </li>
+     * </ol>
+     *
+     * @param canDelete {@code true} if the role is allowed to delete this resource, {@code false} if not.
+     */
+    public void setCanDelete(boolean canDelete) {
+        this.canDelete = canDelete;
+    }
+
+    /**
+     * Returns {@code true} if this this role is allowed to change permissions on the given resource.
+     */
+    public boolean canSetPermissions() {
+        return canSetPermissions;
+    }
+
+    /**
+     * Defines if this role is allowed to change permissions on the given resource.
+     * Permissions can only be granted at the same permission level or below. E.g. if set on
+     * a Class, it is not possible to change Realm level permissions, but does allow the role to
+     * change object level permissions for objects of that type.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         The role is allowed to modify the {@link RealmPermissions} object.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         The role is allowed the change the {@link ClassPermissions} object.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         The role is allowed to change the permissions on this object.
+     *     </li>
+     * </ol>
+     *
+     * @param canSetPermissions {@code true} if the role is allowed to change the permissions for this resource.
+     */
+    public void setCanSetPermissions(boolean canSetPermissions) {
+        this.canSetPermissions = canSetPermissions;
+    }
+
+    /**
+     * Returns {@code true} if the role is allowed to query the resource, {@code false} if not.
+     */
+    public boolean canQuery() {
+        return canQuery;
+    }
+
+    /**
+     * Defines if this role is allowed to query the resource or not.
+     * <p>
+     * Note, that local queries are always possible, but the query result will just be empty.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         Not applicable.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         The role is allowed to query objects of this type.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         Not applicable.
+     *     </li>
+     * </ol>
+     *
+     * @param canQuery {@code true} if the role is allowed to query objects of this type.
+     */
+    public void setCanQuery(boolean canQuery) {
+        this.canQuery = canQuery;
+    }
+
+    /**
+     * Returns {@code true} if the role is allowed to create objects, {@code false} if not.
+     */
+    public boolean canCreate() {
+        return canCreate;
+    }
+
+    /**
+     * Defines if this role is allowed to create objects of this type.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         Not applicable.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         If {@code true}, the role is allowed to create objects of this type.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         Not applicable.
+     *     </li>
+     * </ol>
+     *
+     * @param canCreate {@code true} if the role is allowed to create objects of this type.
+     */
+    public void setCanCreate(boolean canCreate) {
+        this.canCreate = canCreate;
+    }
+
+    /**
+     * Returns {@code true} if the role is allowed to modify the schema of the resource,
+     * {@code false} if not.
+     */
+    public boolean canModifySchema() {
+        return canModifySchema;
+    }
+
+    /**
+     * Defines if this role is allowed to modify the schema of this resource.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         If {@code true} the role is allowed to create classes in the Realm.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         If {@code true}, the role is allowed to add properties to the specified class.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         Not applicable.
+     *     </li>
+     * </ol>
+     *
+     * @param canModifySchema {@code true} if the role is allowed to modify the schema of this resource.
+     */
+    public void setCanModifySchema(boolean canModifySchema) {
+        this.canModifySchema = canModifySchema;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/PermissionUser.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/PermissionUser.java
new file mode 100644
index 0000000000..7be7f168ba
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/PermissionUser.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.Required;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * Class describes a user in the Realm Object Servers Permission system.
+ * The Id should be identical to the value from {@code SyncUser.getIdentity()}
+ *
+ * @see <a href="FIX">Object Level Permissions</a> for an detailed description of the Realm Object
+ * Server permission system.
+ */
+@ObjectServer
+@RealmClass(name = "__User")
+public class PermissionUser extends RealmObject {
+    @PrimaryKey
+    @Required
+    private String id;
+
+    @LinkingObjects("members")
+    final RealmResults<Role> roles = null;
+
+    public PermissionUser() {
+        // Required by Realm
+    }
+
+    /**
+     * Creates a new user.
+     *
+     * @param id identify of the user. Should be identitical to {@code SyncUser.getIdentity()}.
+     */
+    public PermissionUser(String id) {
+        this.id = id;
+    }
+
+    /**
+     * Returns the identify of this user.
+     *
+     */
+    public String getId() {
+        return id;
+    }
+
+
+    /**
+     * Returns all {@link Role}s this user has.
+     *
+     * @return all roles this user has.
+     */
+    public @Nullable  RealmResults<Role> getRoles() {
+        return roles;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java
new file mode 100644
index 0000000000..41b0f05009
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * Class describing all permissions related to a given Realm. Permissions attached to this class
+ * are treated as the default permissions if not otherwise overridden by {@link ClassPermissions}
+ * or object level permissions.
+ *
+ * @see <a href="FIX">Object Level Permissions</a> for an detailed description of the Realm Object
+ * Server permission system.
+ */
+@ObjectServer
+@RealmClass(name = "__Realm")
+public class RealmPermissions extends RealmObject {
+    @PrimaryKey
+    private int id = 0; // Singleton object for the Realm file
+    private RealmList<Permission> permissions = new RealmList<>();
+
+    public RealmPermissions() {
+        // Required by Realm
+    }
+
+    /**
+     * Returns all Realm level permissions, i.e. permissions that apply to the Realm as a whole.
+     *
+     * @return all Realm level permissions
+     */
+    public RealmList<Permission> getPermissions() {
+        return permissions;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPrivileges.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPrivileges.java
new file mode 100644
index 0000000000..6213302d28
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPrivileges.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.Realm;
+import io.realm.RealmModel;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * This object combines all privileges granted on the Realm by all Roles which the
+ * current User is a member of into the final privileges which will be enforced by
+ * the server.
+ *
+ * The privilege calculation is done locally using cached data, and inherently may
+ * be stale. It is possible that this method may indicate that an operation is
+ * permitted but the server will still reject it if permission is revoked before
+ * the changes have been integrated on the server. If this happens, the server will automatically
+ * revoke any illegal operations.
+ *
+ * Non-synchronized Realms always have permission to perform all operations.
+ */
+@ObjectServer
+public final class RealmPrivileges {
+
+    private boolean canRead;
+    private boolean canUpdate;
+    private boolean canDelete;
+    private boolean canSetPermissions;
+    private boolean canQuery;
+    private boolean canCreate;
+    private boolean canModifySchema;
+
+    public RealmPrivileges(long privileges) {
+        this.canRead = (privileges & (1 << 0)) != 0;
+        this.canUpdate = (privileges & (1 << 1)) != 0;
+        this.canDelete = (privileges & (1 << 2)) != 0;
+        this.canSetPermissions = (privileges & (1 << 3)) != 0;
+        this.canQuery = (privileges & (1 << 4)) != 0;
+        this.canCreate = (privileges & (1 << 5)) != 0;
+        this.canModifySchema = (privileges & (1 << 6)) != 0;
+    }
+
+    /**
+     * Returns whether or not can see this Realm. If {@code true}, the user is allowed to read all
+     * objects and classes from the Realm. If {@code false}, the Realm will appear completely empty
+     * (including having no schema), effectively making it inaccessible.
+     *
+     * @return {@code true} if the user can see the Realm, {@code false} if not.
+     */
+    public boolean canRead() {
+        return canRead;
+    }
+
+    /**
+     * Returns whether or not the user can update Realm objects. If {@code true}, the user is
+     * allowed to update properties on all objects in the Realm. This does not include updating
+     * permissions nor creating or deleting objects. If {@code false}, the Realm is effectively
+     * read-only.
+     * <p>
+     * This property also in part control if schema updates are possible. If this returns
+     * {@code false}, the user is not allowed to update the schema, if {@code true}, schema updates
+     * are allowed if {@link #canModifySchema()} also returns {@code true}.
+     *
+     * @return {@code true} if the user can update this Realm, {@code false} if not.
+     */
+    public boolean canUpdate() {
+        return canUpdate;
+    };
+
+    /**
+     * Returns whether or not the user can change {@link RealmPermissions}. See this class for
+     * further information.
+     *
+     * @return {@code true} if the user can modify the {@link RealmPermissions} object,
+     * {@code false} if not.
+     * @see RealmPermissions
+     */
+    public boolean canSetPermissions() {
+        return canSetPermissions;
+    };
+
+    /**
+     * Returns whether or not the user can modify the schema of the given resource.
+     *
+     * <ol>
+     *     <li>
+     *         <b>Realm:</b>
+     *         If {@code true} the user is allowed to create classes in the Realm.
+     *     </li>
+     *     <li>
+     *         <b>Class:</b>
+     *         If {@code true}, the user is allowed to add properties to the given class.
+     *     </li>
+     *     <li>
+     *         <b>Object:</b>
+     *         Not applicable.
+     *     </li>
+     * </ol>
+     *
+     * @return {@code true} if the user can modify the schema of the given resource, {@code false} if not.
+     */
+    public boolean canModifySchema() {
+        return canModifySchema;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        RealmPrivileges that = (RealmPrivileges) o;
+
+        if (canRead != that.canRead) return false;
+        if (canUpdate != that.canUpdate) return false;
+        if (canDelete != that.canDelete) return false;
+        if (canSetPermissions != that.canSetPermissions) return false;
+        if (canQuery != that.canQuery) return false;
+        if (canCreate != that.canCreate) return false;
+        return canModifySchema == that.canModifySchema;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (canRead ? 1 : 0);
+        result = 31 * result + (canUpdate ? 1 : 0);
+        result = 31 * result + (canDelete ? 1 : 0);
+        result = 31 * result + (canSetPermissions ? 1 : 0);
+        result = 31 * result + (canQuery ? 1 : 0);
+        result = 31 * result + (canCreate ? 1 : 0);
+        result = 31 * result + (canModifySchema ? 1 : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "RealmPrivileges{" +
+                "canRead=" + canRead +
+                ", canUpdate=" + canUpdate +
+                ", canDelete=" + canDelete +
+                ", canSetPermissions=" + canSetPermissions +
+                ", canQuery=" + canQuery +
+                ", canCreate=" + canCreate +
+                ", canModifySchema=" + canModifySchema +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/Role.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/Role.java
new file mode 100644
index 0000000000..629ab67ff3
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/Role.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync.permissions;
+
+import io.realm.Realm;
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.Required;
+import io.realm.internal.Util;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * A role describes a function or area of authority in the Realm Object Server permission system.
+ * Multiple users can have the same role and a role can be assigned different permissions.
+ *
+ * @see <a href="FIX">Object Level Permissions</a> for an detailed description of the Realm Object
+ * Server permission system.
+ */
+@ObjectServer
+@RealmClass(name = "__Role")
+public class Role extends RealmObject {
+    @PrimaryKey
+    @Required
+    private String name;
+    private RealmList<PermissionUser> members = new RealmList<>();
+
+    public Role() {
+        // Required by Realm;
+    }
+
+    /**
+     * Creates a new named role. The name must be unique.
+     *
+     * @param name a unique name for the role.
+     */
+    public Role(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Returns the name of this role.
+     *
+     * @return name of this role.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Adds a member to this Role. Must be done from within a write transaction.
+     *
+     * @param userId userid of the SyncUser.
+     * @throws IllegalStateException if not in a write transaction.
+     * @throws IllegalArgumentException if {@code null} or empty {@code userId} is provided.
+     */
+    public void addMember(String userId) {
+        if (isManaged()) {
+            if (Util.isEmptyString(userId)) {
+                throw new IllegalArgumentException("Non-empty 'userId' required");
+            }
+            Realm realm = getRealm();
+            PermissionUser user = realm.where(PermissionUser.class).equalTo("id", userId).findFirst();
+            if (user == null) {
+                user = realm.createObject(PermissionUser.class, userId);
+            }
+            members.add(user);
+
+        } else {
+            throw new IllegalStateException("Can not add a member to a non managed Role");
+        }
+    }
+
+    /**
+     * Removes a member from this Role. Must be done from within a write transaction.
+     *
+     * @param userId userid of the SyncUser to remove.
+     * @return {@code true} if the user could be removed, {@code false} if not.
+     * @throws IllegalStateException if not in a write transaction.
+     */
+    public boolean removeMember(String userId) {
+        PermissionUser user = getRealm().where(PermissionUser.class).equalTo("id", userId).findFirst();
+        if (user != null) {
+            return members.remove(user);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Checks if the provided user has this role.
+     *
+     * @param userId user to check
+     * @return {@code true} if the user has this role, {@code false} if not.
+     */
+    public boolean hasMember(String userId) {
+        return members.where().equalTo("id", userId).count() > 0;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/package-info.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/package-info.java
new file mode 100644
index 0000000000..9c4e4ae3be
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.sync.permissions;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
index d41906a017..c9471a7df1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
@@ -205,7 +205,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                 })
                 .modules(new PermissionModule())
                 .waitForInitialRemoteData()
-                .readOnly()
+                 // .readOnly() Temporarily disabled due to issues with ROS 3.0.0-alpha.X
                 .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .build();
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 61de76ff92..362c9022b1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -22,6 +22,7 @@
 import java.io.UnsupportedEncodingException;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.net.URL;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.Arrays;
@@ -33,11 +34,13 @@
 
 import javax.annotation.Nullable;
 
+import io.realm.annotations.Beta;
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.OsRealmConfig;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Util;
+import io.realm.internal.sync.permissions.ObjectPermissionsModule;
 import io.realm.log.RealmLog;
 import io.realm.rx.RealmObservableFactory;
 import io.realm.rx.RxObservableFactory;
@@ -47,7 +50,7 @@
  * Object Server.
  * <p>
  * A valid {@link SyncUser} is required to create a {@link SyncConfiguration}. See {@link SyncCredentials} and
- * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)} for more information on
+ * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)} for more information on
  * how to get a user object.
  * <p>
  * A minimal {@link SyncConfiguration} can be found below.
@@ -180,6 +183,66 @@ public static RealmConfiguration forRecovery(String canonicalPath, @Nullable byt
         return forRecovery(canonicalPath, encryptionKey, schemaMediator);
     }
 
+    /**
+     * Creates an automatic default configuration based on the the currently logged in user.
+     * <p>
+     * This configuration will point to the default Realm on the server where the user was
+     * authenticated.
+     *
+     * @throws IllegalStateException if no user are logged in, or multiple users have. Only one should
+     * be logged in when calling this method.
+     * @return The constructed {@link SyncConfiguration}.
+     */
+    @Beta
+    public static SyncConfiguration automatic() {
+        SyncUser user = SyncUser.current();
+        if (user == null) {
+            throw new IllegalStateException("No user was logged in.");
+        }
+        return getDefaultConfig(user);
+    }
+
+    /**
+     * Creates an automatic default configuration for the provided user.
+     * <p>
+     * This configuration will point to the default Realm on the server where the user was
+     * authenticated.
+     *
+     * @throws IllegalArgumentException if no user was provided or the user isn't valid.
+     * @return The constructed {@link SyncConfiguration}.
+     */
+    @Beta
+    public static SyncConfiguration automatic(SyncUser user) {
+        if (user == null) {
+            throw new IllegalArgumentException("Non-null 'user' required.");
+        }
+        if (!user.isValid()) {
+            throw new IllegalArgumentException("User is no logger valid.  Log the user in again.");
+        }
+        return getDefaultConfig(user);
+    }
+
+    private static SyncConfiguration getDefaultConfig(SyncUser user) {
+        return new SyncConfiguration.Builder(user, createUrl(user))
+                .partialRealm()
+                .build();
+    }
+
+    // Infer the URL to the default Realm based on the server used to login the user
+    private static String createUrl(SyncUser user) {
+        URL url = user.getAuthenticationUrl();
+        String protocol = url.getProtocol();
+        String host = url.getHost();
+
+        if (protocol.equalsIgnoreCase("https")) {
+            protocol = "realms";
+        } else {
+            protocol = "realm";
+        }
+
+        return protocol + "://" + host + "/default";
+    }
+
     /**
      * Returns a {@link RealmConfiguration} appropriate to open a read-only, non-synced Realm to recover any pending changes.
      * This is useful when trying to open a backup/recovery Realm (after a client reset).
@@ -364,14 +427,12 @@ boolean isSyncConfiguration() {
 
     /**
      * Whether this configuration is for a partial synchronization Realm.
+     * <p>
      * Partial synchronization allows a synchronized Realm to be opened in such a way that
-     * only objects requested by the user are synchronized to the device. You can use it by setting
-     * the {@link Builder#partialRealm()}, opening the Realm, and then calling
-     * {@link Realm#subscribeToObjects(Class, String, Realm.PartialSyncCallback)} with the type of
-     * object you're interested in, a string containing a query determining which objects you want
-     * to subscribe to, and a callback which will report the results.
+     * only objects queried by the user are synchronized to the device.
      *
      * @return {@code true} to open a partial synchronization Realm {@code false} otherwise.
+     * @see Builder#partialRealm() for more details.
      */
     public boolean isPartialRealm() {
         return isPartial;
@@ -715,6 +776,43 @@ public Builder modules(Object baseModule, Object... additionalModules) {
             return this;
         }
 
+        /**
+         * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
+         * current schema for this Realm with the schema defined by the provided modules.
+         * <p>
+         * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
+         * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
+         * dependency is thus done using the following code:
+         * <p>
+         * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
+         * <p>
+         * @param modules list of modules tthe first Realm module (required).
+         * @throws IllegalArgumentException if any of the modules don't have the {@link RealmModule} annotation.
+         * @see Realm#getDefaultModule()
+         */
+        public Builder modules(Iterable<Object> modules) {
+            this.modules.clear();
+            if (modules != null) {
+                for (Object module : modules) {
+                    addModule(module);
+                }
+            }
+            return this;
+        }
+
+        /**
+         * Adds a module to the already defined modules.
+         */
+        public Builder addModule(Object module) {
+            //noinspection ConstantConditions
+            if (module != null) {
+                checkModule(module);
+                modules.add(module);
+            }
+
+            return this;
+        }
+
         /**
          * Sets the {@link RxObservableFactory} used to create Rx Observables from Realm objects.
          * The default factory is {@link RealmObservableFactory}.
@@ -865,7 +963,7 @@ private String MD5(String in) {
 
         /**
          * Setting this will cause the local Realm file used to synchronize changes to be deleted if the {@link SyncUser}
-         * owning this Realm logs out from the device using {@link SyncUser#logout()}.
+         * owning this Realm logs out from the device using {@link SyncUser#logOut()}.
          * <p>
          * The default behavior is that the Realm file is allowed to stay behind, making it possible for users to log
          * in again and have access to their data faster.
@@ -967,6 +1065,11 @@ public SyncConfiguration build() {
                 }
             }
 
+            // If partial sync is enabled, also add support for Object Level Permissions
+            if (isPartial) {
+                addModule(new ObjectPermissionsModule());
+            }
+
             return new SyncConfiguration(
                     // Realm Configuration options
                     realmFileDirectory,
@@ -997,14 +1100,6 @@ public SyncConfiguration build() {
             );
         }
 
-        private void addModule(Object module) {
-            //noinspection ConstantConditions
-            if (module != null) {
-                checkModule(module);
-                modules.add(module);
-            }
-        }
-
         private void checkModule(Object module) {
             if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
                 throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 560bafff7a..5b8945feab 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -78,7 +78,7 @@
      *
      * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials facebook(String facebookToken) {
@@ -91,7 +91,7 @@ public static SyncCredentials facebook(String facebookToken) {
      *
      * @param googleToken a google userIdentifier acquired by logging into Google.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials google(String googleToken) {
@@ -104,7 +104,7 @@ public static SyncCredentials google(String googleToken) {
      *
      * @param jwtToken a JWT token that identifies the user.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if the token is either {@code null} or empty.
      */
     public static SyncCredentials jwt(String jwtToken) {
@@ -119,7 +119,7 @@ public static SyncCredentials jwt(String jwtToken) {
      *  and it isn't possible to share the user details across devices.
      *
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      */
     public static SyncCredentials anonymous() {
         return new SyncCredentials("", IdentityProvider.ANONYMOUS, null);
@@ -134,7 +134,7 @@ public static SyncCredentials anonymous() {
      *
      * @param nickname that identifies a user
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if the nickname is either {@code null} or empty.
      */
     public static SyncCredentials nickname(String nickname, boolean isAdmin) {
@@ -154,7 +154,7 @@ public static SyncCredentials nickname(String nickname, boolean isAdmin) {
      * create a user twice when logging in, so this flag should only be set to {@code true} the first
      * time a users log in.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password, boolean createUser) {
@@ -172,7 +172,7 @@ public static SyncCredentials usernamePassword(String username, String password,
      * @param username username of the user.
      * @param password the users password.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password) {
@@ -189,7 +189,7 @@ public static SyncCredentials usernamePassword(String username, String password)
      * data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
      * classes will be converted using {@code toString()}.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if any parameter is either {@code null} or empty.
      */
     public static SyncCredentials custom(String userIdentifier, String identityProvider, @Nullable Map<String, Object> userInfo) {
@@ -204,7 +204,7 @@ public static SyncCredentials custom(String userIdentifier, String identityProvi
     /**
      * Creates credentials from an existing access token. Since an access token is the proof that a user already
      * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
-     * This means that providing these credentials to {@link SyncUser#login(SyncCredentials, String)} will always
+     * This means that providing these credentials to {@link SyncUser#logIn(SyncCredentials, String)} will always
      * succeed, but accessing any Realm after might fail if the token is no longer valid.
      * <p>
      * It is assumed that this user is not an administrator. Otherwise use {@link #accessToken(String, String, boolean)}.
@@ -212,7 +212,7 @@ public static SyncCredentials custom(String userIdentifier, String identityProvi
      * @param accessToken user's access token.
      * @param identifier user identifier.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}
      */
     public static SyncCredentials accessToken(String accessToken, String identifier) {
         return accessToken(accessToken, identifier, false);
@@ -221,7 +221,7 @@ public static SyncCredentials accessToken(String accessToken, String identifier)
     /**
      * Creates credentials from an existing access token. Since an access token is the proof that a user already
      * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
-     * This means that providing these credentials to {@link SyncUser#login(SyncCredentials, String)} will always
+     * This means that providing these credentials to {@link SyncUser#logIn(SyncCredentials, String)} will always
      * succeed, but accessing any Realm after might fail if the token is no longer valid.
      *
      * @param accessToken user's access token.
@@ -230,7 +230,7 @@ public static SyncCredentials accessToken(String accessToken, String identifier)
      * non-privileged users. It is to <i>not</i> possible to upgrade a non-admin token to an admin token by setting this
      * value. It is purely informational.
      * @return a set of credentials that can be used to log into the Object Server using
-     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * {@link SyncUser#logInAsync(SyncCredentials, String, SyncUser.Callback)}
      */
     public static SyncCredentials accessToken(String accessToken, String identifier, boolean isAdmin) {
         HashMap<String, Object> userInfo = new HashMap<String, Object>();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 7e022ed57f..cc45224295 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -148,7 +148,7 @@ static void init(String appId, UserStore userStore) {
 
     /**
      * Set the {@link UserStore} used by the Realm Object Server to save user information.
-     * If no Userstore is specified {@link SyncUser#currentUser()} will always return {@code null}.
+     * If no Userstore is specified {@link SyncUser#current()} will always return {@code null}.
      *
      * @param userStore {@link UserStore} to use.
      * @throws IllegalArgumentException if {@code userStore} is {@code null}.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index 1fe9941442..c7f98d65b9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -33,7 +33,6 @@
 
 import javax.annotation.Nullable;
 
-import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.Util;
 import io.realm.internal.android.AndroidCapabilities;
@@ -80,7 +79,7 @@
      * expired.
      * @throws IllegalStateException if multiple users are logged in.
      */
-    public static SyncUser currentUser() {
+    public static SyncUser current() {
         SyncUser user = SyncManager.getUserStore().getCurrent();
         if (user != null && user.isValid()) {
             return user;
@@ -135,7 +134,7 @@ public static SyncUser fromJson(String user) {
      * @throws ObjectServerError if the login failed.
      * @throws IllegalArgumentException if the URL is malformed.
      */
-    public static SyncUser login(final SyncCredentials credentials, final String authenticationUrl) throws ObjectServerError {
+    public static SyncUser logIn(final SyncCredentials credentials, final String authenticationUrl) throws ObjectServerError {
         URL authUrl;
         try {
             authUrl = new URL(authenticationUrl);
@@ -189,12 +188,12 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
      * @return representation of the async task that can be used to cancel it if needed.
      * @throws IllegalArgumentException if not on a Looper thread.
      */
-    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback<SyncUser> callback) {
+    public static RealmAsyncTask logInAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback<SyncUser> callback) {
         checkLooperThread("Asynchronous login is only possible from looper threads.");
         return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
             @Override
             public SyncUser run() throws ObjectServerError {
-                return login(credentials, authenticationUrl);
+                return logIn(credentials, authenticationUrl);
             }
         }.start();
     }
@@ -218,7 +217,7 @@ public SyncUser run() throws ObjectServerError {
 //     */
     // this is a fire and forget, end user should not worry about the state of the async query
     @SuppressWarnings("FutureReturnValueIgnored")
-    public void logout() {
+    public void logOut() {
         // Acquire lock to prevent users creating new instances
         synchronized (Realm.class) {
             if (!SyncManager.getUserStore().isActive(identity, authenticationUrl.toString())) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index e75638e138..b0ac440bbf 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -32,6 +32,7 @@
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.internal.sync.permissions.ObjectPermissionsModule;
 
 @SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
 @Keep
@@ -174,4 +175,19 @@ public void downloadRemoteChanges(RealmConfiguration config) {
     public boolean wasDownloadInterrupted(Throwable throwable) {
         return (throwable instanceof DownloadingRealmInterruptedException);
     }
+
+    @Override
+    public boolean isPartialRealm(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) configuration;
+            return syncConfig.isPartialRealm();
+        }
+        
+        return false;
+    }
+
+    @Override
+    public void addSupportForObjectLevelPermissions(RealmConfiguration.Builder builder) {
+        builder.addModule(new ObjectPermissionsModule());
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java
new file mode 100644
index 0000000000..e1f6f27af3
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java
@@ -0,0 +1,18 @@
+package io.realm.internal.sync.permissions;
+
+import io.realm.annotations.RealmModule;
+import io.realm.sync.permissions.ClassPermissions;
+import io.realm.sync.permissions.Permission;
+import io.realm.sync.permissions.RealmPermissions;
+import io.realm.sync.permissions.PermissionUser;
+import io.realm.sync.permissions.Role;
+
+@RealmModule(library = true, classes = {
+        ClassPermissions.class,
+        Permission.class,
+        RealmPermissions.class,
+        Role.class,
+        PermissionUser.class
+})
+public class ObjectPermissionsModule {
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
index 59dca34d0a..c10a9af401 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
@@ -26,7 +26,7 @@
 /**
  * This class represents the intent of giving a set of permissions to some users for some Realm(s).
  * <p>
- * If the request is successful, a {@link Permission} entry will be added to each affected users
+ * If the request is successful, a {@link io.realm.permissions.Permission} entry will be added to each affected users
  * {@link PermissionManager}, where it can be fetched using
  * {@link PermissionManager#getPermissions(PermissionManager.PermissionsCallback)}
  *
@@ -114,7 +114,7 @@ public UserCondition getCondition() {
      * all Realms, for which the user sending the request, has administrative rights.
      *
      * @return the Realm URL for which the permissions should be granted.
-     * @see Permission#mayManage()
+     * @see io.realm.permissions.Permission#mayManage()
      */
     public String getUrl() {
         return url;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
index 4c31b68f10..160ac6c8e3 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -26,7 +26,9 @@
 import java.io.File;
 import java.io.IOException;
 
+import io.realm.internal.OsRealmConfig;
 import io.realm.internal.Util;
+import io.realm.internal.sync.permissions.ObjectPermissionsModule;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.HttpUtils;
@@ -43,9 +45,6 @@
 
     private static int originalLogLevel;
 
-    @Rule
-    public final TestSyncConfigurationFactory configurationFactory = new TestSyncConfigurationFactory();
-
     @Rule
     public RunInLooperThread looperThread = new RunInLooperThread();
 
@@ -55,8 +54,13 @@
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
+    protected ConfigurationWrapper configurationFactory = new ConfigurationWrapper(looperThread);
+
+    static {
+        // Attempt to combat issues with the sync meta data Realm not being correctly cleaned
+    }
+
     protected void prepareEnvironmentForTest() throws IOException {
-        // FIXME Trying to reset the device environment is crashing tests somehow
         deleteRosFiles();
         if (BaseRealm.applicationContext != null) {
             // Realm was already initialized. Reset all internal state
@@ -128,4 +132,33 @@ private static void deleteFile(File file) throws IOException {
             throw new IllegalStateException("Failed to delete file or directory: " + file.getAbsolutePath());
         }
     }
-}
+
+    // Returns a valid SyncConfiguration usable by tests
+    // FIXME: WARNING: Do not use `SyncTestRealmConfigurationFactory`, but use this. Refactor later.
+    protected static class ConfigurationWrapper {
+
+        private final RunInLooperThread looperThread;
+
+        ConfigurationWrapper(RunInLooperThread looperThread) {
+            this.looperThread = looperThread;
+            try {
+                // The RunInLooperThread rule might not be fully created yet. Do it here.
+                // The `create()` call is idempotent, so should be safe.
+                looperThread.create();
+            } catch (IOException e) {
+                throw new IllegalStateException(e);
+            }
+        }
+
+        public SyncConfiguration.Builder createSyncConfigurationBuilder(SyncUser user, String url) {
+            return new SyncConfiguration.Builder(user, url)
+                    .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                    .modules(Realm.getDefaultModule(), new ObjectPermissionsModule())
+                    .directory(looperThread.getRoot());
+        }
+
+        public File getRoot() {
+            return looperThread.getRoot();
+        }
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
index 09715009a1..e25225fbbe 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
@@ -26,12 +26,14 @@ public void teardownTest() {
         if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
             // Non-looper tests can reset here
             restoreEnvironmentAfterTest();
+            stopSyncServer();
         } else {
             // Otherwise we need to wait for the test to complete
             looperThread.runAfterTest(new Runnable() {
                 @Override
                 public void run() {
                     restoreEnvironmentAfterTest();
+                    stopSyncServer();
                 }
             });
         }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
index 84c2788de8..37dc8a475f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
@@ -36,6 +36,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.internal.OsRealmConfig;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
@@ -54,6 +55,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
+@Ignore // FIXME: Temporary disable unit tests due to lates (3.0.0-alpha.2) ROS having issues. Re-enable once ROS is stable again.
 public class PermissionManagerTests extends StandardIntegrationTest {
 
     private SyncUser user;
@@ -117,6 +119,7 @@ public void onSuccess(RealmResults<Permission> permissions) {
 
                 // Create new Realm, which should create a new Permission entry
                 SyncConfiguration config2 = new SyncConfiguration.Builder(user, Constants.USER_REALM_2)
+                        .schema(AllJavaTypes.class)
                         .errorHandler(new SyncSession.ErrorHandler() {
                             @Override
                             public void onError(SyncSession session, ObjectServerError error) {
@@ -163,7 +166,9 @@ public void onSuccess(RealmResults<Permission> permissions) {
                 assertInitialPermissions(permissions);
 
                 for (int i = 0; i < TEST_SIZE; i++) {
-                    SyncConfiguration configNew = new SyncConfiguration.Builder(user, "realm://" + Constants.HOST + "/~/test" + i).build();
+                    SyncConfiguration configNew = new SyncConfiguration.Builder(user, "realm://" + Constants.HOST + "/~/test" + i)
+                            .schema(AllJavaTypes.class)
+                            .build();
                     Realm newRealm = Realm.getInstance(configNew);
                     looperThread.closeAfterTest(newRealm);
                 }
@@ -772,6 +777,7 @@ public void onSuccess() {
                 // Default permissions are not recorded in the __permission Realm for user2
                 // Only way to check is by opening the Realm.
                 SyncConfiguration config = new SyncConfiguration.Builder(user2, url)
+                        .schema(AllJavaTypes.class)
                         .waitForInitialRemoteData()
                         .errorHandler(new SyncSession.ErrorHandler() {
                             @Override
@@ -1180,6 +1186,7 @@ private String createRemoteRealm(SyncUser user, String realmName) {
         String url = Constants.AUTH_SERVER_URL + "~/" + realmName;
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
                 .name(realmName)
+                .schema(AllJavaTypes.class)
                 .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .build();
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index 68de33b306..a899730c7e 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -32,6 +32,7 @@
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
+import io.realm.rule.RunTestInLooperThread;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -40,14 +41,19 @@
 @RunWith(AndroidJUnit4.class)
 public class SSLConfigurationTests extends StandardIntegrationTest {
 
+    // TODO: All tests in this class are currently marked @RunTestInLooperThread,
+    // this is strictly not necessary, but currently needed to avoid other issues with setting
+    // up tests.
+
     @Rule
     public Timeout globalTimeout = Timeout.seconds(120);
 
     @Test
+    @RunTestInLooperThread
     public void trustedRootCA() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server
         //noinspection unchecked
@@ -63,11 +69,11 @@ public void trustedRootCA() throws InterruptedException {
         // make sure the changes gets to the server
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         //noinspection unchecked
         SyncConfiguration syncConfigSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
@@ -84,13 +90,15 @@ public void trustedRootCA() throws InterruptedException {
         } finally {
             realm.close();
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void withoutSSLVerification() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server
         //noinspection unchecked
@@ -106,11 +114,11 @@ public void withoutSSLVerification() throws InterruptedException {
         // make sure the changes gets to the server
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         //noinspection unchecked
         SyncConfiguration syncConfigSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
@@ -127,13 +135,15 @@ public void withoutSSLVerification() throws InterruptedException {
         } finally {
             realm.close();
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void trustedRootCA_syncShouldFailWithoutTrustedCA() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server
         //noinspection unchecked
@@ -149,11 +159,11 @@ public void trustedRootCA_syncShouldFailWithoutTrustedCA() throws InterruptedExc
         // make sure the changes gets to the server
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         //noinspection unchecked
         SyncConfiguration syncConfigSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
@@ -168,13 +178,15 @@ public void trustedRootCA_syncShouldFailWithoutTrustedCA() throws InterruptedExc
         } finally {
             realm.close();
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         int originalLevel = RealmLog.getLevel();
@@ -193,13 +205,15 @@ public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
                 testLogger.message);
         RealmLog.remove(testLogger);
         RealmLog.setLevel(originalLevel);
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void trustedRootCA_notExisting_certificate_willThrow() {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
         //noinspection unchecked
         SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .schema(StringOnly.class)
@@ -211,13 +225,15 @@ public void trustedRootCA_notExisting_certificate_willThrow() {
             fail();
         } catch (RealmFileException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void combiningTrustedRootCA_and_disableSSLVerification() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server using ssl_verify_path option
         //noinspection unchecked
@@ -234,11 +250,11 @@ public void combiningTrustedRootCA_and_disableSSLVerification() throws Interrupt
         // make sure the changes gets to the server
         SyncManager.getSession(syncConfigWithCertificate).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         //noinspection unchecked
         SyncConfiguration syncConfigDisableSSL = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
@@ -255,6 +271,7 @@ public void combiningTrustedRootCA_and_disableSSLVerification() throws Interrupt
         } finally {
             realm.close();
         }
+        looperThread.testComplete();
     }
 
     // IMPORTANT: Following test assume the root certificate is installed on the test device
@@ -262,10 +279,11 @@ public void combiningTrustedRootCA_and_disableSSLVerification() throws Interrupt
     //            adb push <realm-java>/tools/sync_test_server/keys/android_test_certificate.crt /sdcard/
     //            then import the certificate from the device (Settings/Security/Install from storage)
     @Test
+    @RunTestInLooperThread
     public void sslVerifyCallback_isUsed() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server using ssl_verify_path option
         //noinspection unchecked
@@ -281,11 +299,11 @@ public void sslVerifyCallback_isUsed() throws InterruptedException {
         // make sure the changes gets to the server
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes.
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         //noinspection unchecked
         SyncConfiguration syncConfigSecure = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
                 .name("useSsl")
@@ -301,5 +319,6 @@ public void sslVerifyCallback_isUsed() throws InterruptedException {
         } finally {
             realm.close();
         }
+        looperThread.testComplete();
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
index 858824853d..aa720b15de 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
@@ -27,6 +27,8 @@
 /**
  * The standard base class for integration tests.
  * This class will keep a ROS instance running for all tests to minimize the overhead between each test.
+ *
+ * NOTE: All tests extending this class should use `@RunTestInLooperThread` tests.
  */
 public abstract class StandardIntegrationTest extends BaseIntegrationTest {
 
@@ -35,6 +37,11 @@ public static void setupTestClass() throws Exception {
         startSyncServer();
     }
 
+    @AfterClass
+    public static void tearDownTestClass() throws Exception {
+        stopSyncServer();
+    }
+
     @Before
     public void setupTest() throws IOException {
         prepareEnvironmentForTest();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index ccaf33d00a..8b33e38896 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -67,7 +67,7 @@ public void getState_throwOnClosedSession() {
 
         SyncSession session = SyncManager.getSession(syncConfiguration);
         realm.close();
-        user.logout();
+        user.logOut();
         thrown.expect(IllegalStateException.class);
         thrown.expectMessage("Could not find session, Realm was probably closed");
         session.getState();
@@ -83,7 +83,7 @@ public void getState_loggedOut() {
 
         SyncSession session = SyncManager.getSession(syncConfiguration);
 
-        user.logout();
+        user.logOut();
 
         SyncSession.State state = session.getState();
         assertEquals(SyncSession.State.INACTIVE, state);
@@ -180,7 +180,7 @@ public void run() {
     public void logout_sameSyncUserMultipleSessions() {
         String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
-        SyncUser user =  SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user =  SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         SyncConfiguration syncConfiguration1 = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
@@ -206,13 +206,13 @@ public void logout_sameSyncUserMultipleSessions() {
 
         assertEquals(session1.getUser(), session2.getUser());
 
-        user.logout();
+        user.logOut();
 
         assertEquals(SyncSession.State.INACTIVE, session1.getState());
         assertEquals(SyncSession.State.INACTIVE, session2.getState());
 
         credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
-        SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         // reviving the sessions. The state could be changed concurrently.
         assertTrue(session1.getState() == SyncSession.State.WAITING_FOR_ACCESS_TOKEN ||
@@ -229,7 +229,7 @@ public void logout_sameSyncUserMultipleSessions() {
     public void logBackResumeUpload() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         final SyncConfiguration syncConfiguration = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
@@ -247,7 +247,7 @@ public void execute(Realm realm) {
         final SyncSession session = SyncManager.getSession(syncConfiguration);
         session.uploadAllLocalChanges();
 
-        user.logout();
+        user.logOut();
 
         // add a commit while we're still offline
         realm.executeTransaction(new Realm.Transaction() {
@@ -270,7 +270,7 @@ public void run() {
                 // when the offline commits get synchronized
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
                 SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
-                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+                SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);
 
                 SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
                         .modules(new StringOnlyModule())
@@ -298,7 +298,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
                 // this login will re-activate the logged out user, and resume all it's pending sessions
                 // the OS will trigger bindSessionWithConfig with the new refresh_token, in order to obtain
                 // a new access_token.
-                SyncUser.login(credentials, Constants.AUTH_URL);
+                SyncUser.logIn(credentials, Constants.AUTH_URL);
             }
         });
 
@@ -313,7 +313,7 @@ public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
         final List<Object> strongRefs = new ArrayList<>();
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         final char[] chars = new char[1_000_000];// 2MB
         Arrays.fill(chars, '.');
@@ -346,7 +346,7 @@ public void run() {
                 // using an admin user to open the Realm on different path on the device to monitor when all the uploads are done
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
                 SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
-                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+                SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);
 
                 SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
                         .modules(new StringOnlyModule())
@@ -374,7 +374,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
         TestHelper.awaitOrFail(testCompleted, 60);
         handlerThread.join();
 
-        user.logout();
+        user.logOut();
     }
 
     // A Realm that was opened before a user logged out should be able to resume downloading if the user logs back in.
@@ -382,7 +382,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
     public void downloadChangesWhenRealmOutOfScope() throws InterruptedException {
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         final SyncConfiguration syncConfiguration = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
@@ -398,11 +398,11 @@ public void downloadChangesWhenRealmOutOfScope() throws InterruptedException {
         session.uploadAllLocalChanges();
 
         // Log out the user.
-        user.logout();
+        user.logOut();
 
         // Log the user back in.
         credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
-        SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         // now let the admin upload some commits
         final CountDownLatch backgroundUpload = new CountDownLatch(1);
@@ -417,7 +417,7 @@ public void run() {
                 // using an admin user to open the Realm on different path on the device then some commits
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
                 SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
-                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+                SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);
 
                 SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
                         .modules(new StringOnlyModule())
@@ -458,11 +458,11 @@ public void run() {
     public void clientReset_manualTriggerAllowSessionToRestart() {
         final String uniqueName = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         final AtomicReference<SyncConfiguration> configRef = new AtomicReference<>(null);
-        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM).directory(looperThread.getRoot())
-
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .directory(looperThread.getRoot())
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
similarity index 85%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
rename to realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index 70db449819..083ee4b359 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -48,17 +48,18 @@
  * Catch all class for tests that not naturally fit anywhere else.
  */
 @RunWith(AndroidJUnit4.class)
-public class SyncedRealmTests extends StandardIntegrationTest {
+public class SyncedRealmIntegrationTests extends StandardIntegrationTest {
 
 
     @Test
     public void loginLogoutResumeSyncing() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
                 .schema(StringOnly.class)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .build();
 
         Realm realm = Realm.getInstance(config);
@@ -66,11 +67,22 @@ public void loginLogoutResumeSyncing() throws InterruptedException {
         realm.createObject(StringOnly.class).setChars("Foo");
         realm.commitTransaction();
         SyncManager.getSession(config).uploadAllLocalChanges();
-        user.logout();
+        user.logOut();
         realm.close();
-        assertTrue(Realm.deleteRealm(config));
+        try {
+            assertTrue(Realm.deleteRealm(config));
+        } catch (IllegalStateException e) {
+            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been
+            //        closed for now.
+            // https://github.com/realm/realm-java/issues/5416
+            if (e.getMessage().contains("It's not allowed to delete the file")) {
+                // retry after 1 second
+                SystemClock.sleep(1000);
+                assertTrue(Realm.deleteRealm(config));
+            }
+        }
 
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
         SyncConfiguration config2 = new SyncConfiguration.Builder(user, Constants.USER_REALM)
                 .schema(StringOnly.class)
                 .build();
@@ -108,7 +120,7 @@ public void waitForInitialRemoteData_mainThreadThrows() {
     public void waitForInitialRemoteData() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
         final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
@@ -126,11 +138,11 @@ public void execute(Realm realm) {
         });
         SyncManager.getSession(configOld).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with
         // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
         SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
                 .name("newRealm")
                 .schema(StringOnly.class)
@@ -161,7 +173,7 @@ public void execute(Realm realm) {
             " https://github.com/realm/realm-java/issues/5416")
     public void waitForInitialData_resilientInCaseOfRetries() throws InterruptedException {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
                 .waitForInitialRemoteData()
                 .build();
@@ -198,7 +210,7 @@ public void run() {
     @Ignore("See https://github.com/realm/realm-java/issues/5373")
     public void waitForInitialData_resilientInCaseOfRetriesAsync() {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
                 .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
                 .directory(configurationFactory.getRoot())
@@ -228,7 +240,7 @@ public void onError(Throwable exception) {
     public void waitForInitialRemoteData_readOnlyTrue() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
         final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
@@ -245,11 +257,11 @@ public void execute(Realm realm) {
         });
         SyncManager.getSession(configOld).uploadAllLocalChanges();
         realm.close();
-        user.logout();
+        user.logOut();
 
         // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
         // download the uploaded changes (pray it managed to do so within the time frame).
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
         final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .name("newRealm")
                 .waitForInitialRemoteData()
@@ -261,13 +273,13 @@ public void execute(Realm realm) {
         realm = Realm.getInstance(configNew);
         assertEquals(10, realm.where(StringOnly.class).count());
         realm.close();
-        user.logout();
+        user.logOut();
     }
     
     @Test
     public void waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .waitForInitialRemoteData()
                 .readOnly()
@@ -286,14 +298,14 @@ public void waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {
             if (realm != null) {
                 realm.close();
             }
-            user.logout();
+            user.logOut();
         }
     }
 
     @Test
     public void waitForInitialRemoteData_readOnlyFalse_upgradeSchema() {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .waitForInitialRemoteData() // Not readonly so Client should be allowed to write schema
                 .schema(StringOnly.class) // This schema should be written when opening the empty Realm.
@@ -306,7 +318,24 @@ public void waitForInitialRemoteData_readOnlyFalse_upgradeSchema() {
             assertEquals(0, realm.where(StringOnly.class).count());
         } finally {
             realm.close();
-            user.logout();
+            user.logOut();
+        }
+    }
+
+    @Test
+    public void defaultRealm() throws InterruptedException {
+        SyncCredentials credentials = SyncCredentials.nickname("test", true);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        SyncConfiguration config = SyncConfiguration.automatic();
+        Realm realm = Realm.getInstance(config);
+        SyncManager.getSession(config).downloadAllServerChanges();
+        realm.refresh();
+
+        try {
+            assertFalse(realm.isEmpty());
+        } finally {
+            realm.close();
+            user.logOut();
         }
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 09f4c8a275..009a988e86 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -65,7 +65,7 @@
     public void login_userNotExist() {
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
         try {
-            SyncUser.login(credentials, Constants.AUTH_URL);
+            SyncUser.logIn(credentials, Constants.AUTH_URL);
             fail();
         } catch (ObjectServerError expected) {
             assertEquals(ErrorCode.INVALID_CREDENTIALS, expected.getErrorCode());
@@ -76,7 +76,7 @@ public void login_userNotExist() {
     @RunTestInLooperThread
     public void loginAsync_userNotExist() {
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 fail();
@@ -95,7 +95,7 @@ public void onError(ObjectServerError error) {
     public void login_newUser() {
         String userId = UUID.randomUUID().toString();
         SyncCredentials credentials = SyncCredentials.usernamePassword(userId, "password", true);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertFalse(user.isAdmin());
@@ -119,11 +119,11 @@ public void onError(ObjectServerError error) {
     public void login_withAccessToken() {
         SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
         SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(adminUser).value(), "custom-admin-user", adminUser.isAdmin());
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertTrue(user.isAdmin());
-                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                         .errorHandler((session, error) -> fail("Session failed: " + error))
                         .build();
 
@@ -144,11 +144,11 @@ public void onError(ObjectServerError error) {
     @RunTestInLooperThread
     public void login_withAnonymous() {
         SyncCredentials credentials = SyncCredentials.anonymous();
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertFalse(user.isAdmin());
-                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                         .errorHandler((session, error) -> fail("Session failed: " + error))
                         .build();
 
@@ -170,11 +170,11 @@ public void onError(ObjectServerError error) {
     @RunTestInLooperThread
     public void login_withNickname() {
         SyncCredentials credentials = SyncCredentials.nickname("foo", false);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertFalse(user.isAdmin());
-                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                         .errorHandler((session, error) -> fail("Session failed: " + error))
                         .build();
 
@@ -196,11 +196,11 @@ public void onError(ObjectServerError error) {
     @RunTestInLooperThread
     public void login_withNicknameAsAdmin() {
         SyncCredentials credentials = SyncCredentials.nickname("foo", true);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+        SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 assertTrue(user.isAdmin());
-                final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
+                final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                         .errorHandler((session, error) -> fail("Session failed: " + error))
                         .build();
 
@@ -234,7 +234,7 @@ public void run() {
                         @Override
                         public void run() {
                             SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-                            SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+                            SyncUser.logInAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
                                 @Override
                                 public void onSuccess(SyncUser user) {
                                     fail();
@@ -264,17 +264,17 @@ public void changePassword() {
         String username = UUID.randomUUID().toString();
         String originalPassword = "password";
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
-        SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser userOld = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(userOld.isValid());
 
         // Change password and try to log in with new password
         String newPassword = "new-password";
         userOld.changePassword(newPassword);
-        userOld.logout();
+        userOld.logOut();
 
         // Make sure old password doesn't work
         try {
-            SyncUser.login(SyncCredentials.usernamePassword(username, originalPassword, false), Constants.AUTH_URL);
+            SyncUser.logIn(SyncCredentials.usernamePassword(username, originalPassword, false), Constants.AUTH_URL);
             fail();
         } catch (ObjectServerError e) {
             assertEquals(ErrorCode.INVALID_CREDENTIALS, e.getErrorCode());
@@ -282,7 +282,7 @@ public void changePassword() {
 
         // Then login with new password
         credentials = SyncCredentials.usernamePassword(username, newPassword, false);
-        SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser userNew = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(userNew.isValid());
         assertEquals(userOld.getIdentity(), userNew.getIdentity());
     }
@@ -292,7 +292,7 @@ public void changePassword_using_admin() {
         String username = UUID.randomUUID().toString();
         String originalPassword = "password";
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
-        SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser userOld = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(userOld.isValid());
 
         // Login an admin user
@@ -305,9 +305,9 @@ public void changePassword_using_admin() {
         adminUser.changePassword(userOld.getIdentity(), newPassword);
 
         // Try to log in with new password
-        userOld.logout();
+        userOld.logOut();
         credentials = SyncCredentials.usernamePassword(username, newPassword, false);
-        SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser userNew = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         assertTrue(userNew.isValid());
         assertEquals(userOld.getIdentity(), userNew.getIdentity());
@@ -319,7 +319,7 @@ public void changePassword_using_admin_async() {
         final String username = UUID.randomUUID().toString();
         final String originalPassword = "password";
         final SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
-        final SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncUser userOld = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(userOld.isValid());
 
         // Login an admin user
@@ -335,9 +335,9 @@ public void onSuccess(SyncUser administratorUser) {
                 assertEquals(adminUser, administratorUser);
 
                 // Try to log in with new password
-                userOld.logout();
+                userOld.logOut();
                 SyncCredentials credentials = SyncCredentials.usernamePassword(username, newPassword, false);
-                SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+                SyncUser userNew = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
                 assertTrue(userNew.isValid());
                 assertEquals(userOld.getIdentity(), userNew.getIdentity());
@@ -358,7 +358,7 @@ public void changePassword_throwWhenUserIsLoggedOut() {
         String username = UUID.randomUUID().toString();
         String password = "password";
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         SyncManager.addAuthenticationListener(new AuthenticationListener() {
             @Override
             public void loggedIn(SyncUser user) {
@@ -388,7 +388,7 @@ public void run() {
                 looperThread.testComplete();
             }
         });
-        user.logout();
+        user.logOut();
     }
 
     @Test
@@ -397,11 +397,11 @@ public void cachedInstanceShouldNotThrowIfRefreshTokenExpires() throws Interrupt
         String password = "password";
 
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        final SyncUser user = spy(SyncUser.login(credentials, Constants.AUTH_URL));
+        final SyncUser user = spy(SyncUser.logIn(credentials, Constants.AUTH_URL));
 
         when(user.isValid()).thenReturn(true, false);
 
-        final RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+        final RealmConfiguration configuration = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM).build();
         Realm realm = Realm.getInstance(configuration);
 
         assertFalse(user.isValid());
@@ -427,7 +427,7 @@ public void run() {
 
         realm.close();
         cachedInstance.close();
-        user.logout();
+        user.logOut();
     }
 
     @Test
@@ -436,15 +436,15 @@ public void buildingSyncConfigurationShouldThrowIfInvalidUser() {
         String password = "password";
 
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        SyncUser currentUser = SyncUser.currentUser();
-        user.logout();
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.current();
+        user.logOut();
 
         assertFalse(user.isValid());
 
         try {
             // We should not be able to build a configuration with an invalid/logged out user
-            new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+            configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM).build();
             fail("Invalid user, it should not be possible to create a SyncConfiguration");
         } catch (IllegalArgumentException expected) {
             // User not authenticated or authentication expired.
@@ -452,7 +452,7 @@ public void buildingSyncConfigurationShouldThrowIfInvalidUser() {
 
         try {
             // We should not be able to build a configuration with an invalid/logged out user
-            new SyncConfiguration.Builder(currentUser, Constants.USER_REALM).build();
+            configurationFactory.createSyncConfigurationBuilder(currentUser, Constants.USER_REALM).build();
             fail("Invalid currentUser, it should not be possible to create a SyncConfiguration");
         } catch (IllegalArgumentException expected) {
             // User not authenticated or authentication expired.
@@ -466,9 +466,9 @@ public void usingConfigurationWithInvalidUserShouldThrow() {
         String password = "password";
 
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
-        user.logout();
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        RealmConfiguration configuration = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM).build();
+        user.logOut();
         assertFalse(user.isValid());
         Realm instance = Realm.getInstance(configuration);
         instance.close();
@@ -477,9 +477,9 @@ public void usingConfigurationWithInvalidUserShouldThrow() {
     @Test
     public void logout_currentUserMoreThanOne() {
         UserFactory.createUniqueUser(Constants.AUTH_URL);
-        SyncUser.currentUser().logout();
+        SyncUser.current().logOut();
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        assertEquals(user, SyncUser.currentUser());
+        assertEquals(user, SyncUser.current());
     }
 
     // logging out 'user' should have the same impact on other instance(s) of the same user
@@ -489,36 +489,36 @@ public void loggingOutUserShouldImpactOtherInstances() throws InterruptedExcepti
         String password = "password";
 
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        SyncUser currentUser = SyncUser.currentUser();
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.current();
 
         assertTrue(user.isValid());
         assertEquals(user, currentUser);
 
-        user.logout();
+        user.logOut();
 
         assertFalse(user.isValid());
         assertFalse(currentUser.isValid());
     }
 
-    // logging out 'currentUser' should have the same impact on other instance(s) of the user
+    // logging out 'current' should have the same impact on other instance(s) of the user
     @Test
     public void loggingOutCurrentUserShouldImpactOtherInstances() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
 
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
-        SyncUser currentUser = SyncUser.currentUser();
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.current();
 
         assertTrue(user.isValid());
         assertEquals(user, currentUser);
 
-        SyncUser.currentUser().logout();
+        SyncUser.current().logOut();
 
         assertFalse(user.isValid());
         assertFalse(currentUser.isValid());
-        assertNull(SyncUser.currentUser());
+        assertNull(SyncUser.current());
     }
 
     // verify that multiple users can be logged in at the same time
@@ -530,7 +530,7 @@ public void multipleUsersCanBeLoggedInSimultaneously() {
         for (int i = 0; i < users.length; i++) {
             SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), password,
                     true);
-            users[i] = SyncUser.login(credentials, Constants.AUTH_URL);
+            users[i] = SyncUser.logIn(credentials, Constants.AUTH_URL);
         }
 
         for (int i = 0; i < users.length; i++) {
@@ -538,7 +538,7 @@ public void multipleUsersCanBeLoggedInSimultaneously() {
         }
 
         for (int i = 0; i < users.length; i++) {
-            users[i].logout();
+            users[i].logOut();
         }
 
         for (int i = 0; i < users.length; i++) {
@@ -555,17 +555,17 @@ public void singleUserCanBeLoggedInAndOutRepeatedly() {
         // register the user the first time
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
 
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(user.isValid());
-        user.logout();
+        user.logOut();
         assertFalse(user.isValid());
 
         // on subsequent logins, the user is already registered.
         credentials = credentials = SyncCredentials.usernamePassword(username, password, false);
         for (int i = 0; i < 3; i++) {
-            user = SyncUser.login(credentials, Constants.AUTH_URL);
+            user = SyncUser.logIn(credentials, Constants.AUTH_URL);
             assertTrue(user.isValid());
-            user.logout();
+            user.logOut();
             assertFalse(user.isValid());
         }
     }
@@ -576,7 +576,7 @@ public void revokedRefreshTokenIsNotSameAfterLogin() throws InterruptedException
         final String uniqueName = UUID.randomUUID().toString();
 
         final SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
-        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         final Token revokedRefreshToken = SyncTestUtils.getRefreshToken(user);
 
         SyncManager.addAuthenticationListener(new AuthenticationListener() {
@@ -588,7 +588,7 @@ public void loggedIn(SyncUser user) {
             @Override
             public void loggedOut(SyncUser user) {
                 SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
-                SyncUser loggedInUser = SyncUser.login(credentials, Constants.AUTH_URL);
+                SyncUser loggedInUser = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
                 Token token = SyncTestUtils.getRefreshToken(loggedInUser);
                 // still comparing the same user
@@ -601,7 +601,7 @@ public void loggedOut(SyncUser user) {
             }
         });
 
-        user.logout();
+        user.logOut();
         TestHelper.awaitOrFail(userLoggedInAgain);
     }
 
@@ -684,7 +684,7 @@ public void retrieve() {
         final String username = UUID.randomUUID().toString();
         final String password = "password";
         final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(user.isValid());
 
         String identity = user.getIdentity();
@@ -708,7 +708,7 @@ public void retrieve_logout() {
         final String username = UUID.randomUUID().toString();
         final String password = "password";
         final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         final String identity = user.getIdentity();
 
         // unless the refresh_token is revoked (via logout) the admin user can still retrieve the user
@@ -746,7 +746,7 @@ public void run() {
 
             }
         });
-        user.logout();
+        user.logOut();
     }
 
     @Test
@@ -762,7 +762,7 @@ public void retrieve_invalidProvider() {
         final String username = UUID.randomUUID().toString();
         final String password = "password";
         final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(user.isValid());
 
         SyncUserInfo userInfo = adminUser.retrieveInfoForUser("username", "invalid");
@@ -774,13 +774,13 @@ public void retrieve_notAdmin() {
         final String username1 = UUID.randomUUID().toString();
         final String password1 = "password";
         final SyncCredentials credentials1 = SyncCredentials.usernamePassword(username1, password1, true);
-        final SyncUser user1 = SyncUser.login(credentials1, Constants.AUTH_URL);
+        final SyncUser user1 = SyncUser.logIn(credentials1, Constants.AUTH_URL);
         assertTrue(user1.isValid());
 
         final String username2 = UUID.randomUUID().toString();
         final String password2 = "password";
         final SyncCredentials credentials2 = SyncCredentials.usernamePassword(username2, password2, true);
-        final SyncUser user2 = SyncUser.login(credentials2, Constants.AUTH_URL);
+        final SyncUser user2 = SyncUser.logIn(credentials2, Constants.AUTH_URL);
         assertTrue(user2.isValid());
 
         // trying to lookup user2 using user1 should not work (requires admin token)
@@ -797,7 +797,7 @@ public void retrieve_async() {
         final String username = UUID.randomUUID().toString();
         final String password = "password";
         final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
-        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         assertTrue(user.isValid());
 
         // Login an admin user
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 9c0418233c..7c8b64a2f7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -43,7 +43,7 @@ public void setEncryptionKey_canReOpenRealmWithoutKey() {
         // STEP 1: open a synced Realm using a local encryption key
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         final byte[] randomKey = TestHelper.getRandomKey();
 
@@ -69,11 +69,11 @@ public void onError(SyncSession session, ObjectServerError error) {
         // STEP 2:  make sure the changes gets to the server
         SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
         realm.close();
-        user.logout();
+        user.logOut();
 
         // STEP 3: try to open again the same sync Realm but different local name without the encryption key should not
         // fail
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
         SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .name("newName")
                 .modules(new StringOnlyModule())
@@ -92,7 +92,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         assertEquals("Hi Alice", all.get(0).getChars());
 
         realm.close();
-        user.logout();
+        user.logOut();
     }
 
     // If an encrypted synced Realm is re-opened with the wrong key, throw an exception.
@@ -101,7 +101,7 @@ public void setEncryptionKey_shouldCrashIfKeyNotProvided() throws InterruptedExc
         // STEP 1: open a synced Realm using a local encryption key
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         final byte[] randomKey = TestHelper.getRandomKey();
 
@@ -128,10 +128,10 @@ public void onError(SyncSession session, ObjectServerError error) {
         SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
 
         realm.close();
-        user.logout();
+        user.logOut();
 
         // STEP 3: try to open again the Realm without the encryption key should fail
-        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
         SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
                 .modules(new StringOnlyModule())
                 .waitForInitialRemoteData()
@@ -160,7 +160,7 @@ public void setEncryptionKey_differentClientsWithDifferentKeys() throws Interrup
         // STEP 1: prepare a synced Realm for client A
         String username = UUID.randomUUID().toString();
         String password = "password";
-        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncUser user = SyncUser.logIn(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
 
         final byte[] randomKey = TestHelper.getRandomKey();
 
@@ -190,7 +190,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         // STEP 3: prepare a synced Realm for client B (admin user)
         SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
         SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
-        SyncUser adminUser = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser adminUser = SyncUser.logIn(credentials, Constants.AUTH_URL);
 
         final byte[] adminRandomKey = TestHelper.getRandomKey();
 
@@ -235,9 +235,9 @@ public void onError(SyncSession session, ObjectServerError error) {
         assertEquals("Hi Bob", allSortedAdmin.get(1).getChars());
 
         adminRealm.close();
-        adminUser.logout();
+        adminUser.logOut();
 
         realm.close();
-        user.logout();
+        user.logOut();
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java
new file mode 100644
index 0000000000..c3f7979701
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.objectserver;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.ObjectServerError;
+import io.realm.PermissionManager;
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.annotations.RealmModule;
+import io.realm.entities.AllJavaTypes;
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.internal.permissions.PermissionModule;
+import io.realm.internal.sync.permissions.ObjectPermissionsModule;
+import io.realm.objectserver.model.PermissionObject;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.sync.permissions.ClassPrivileges;
+import io.realm.sync.permissions.ObjectPrivileges;
+import io.realm.sync.permissions.Permission;
+import io.realm.sync.permissions.RealmPrivileges;
+import io.realm.sync.permissions.Role;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ObjectLevelPermissionIntegrationTests extends StandardIntegrationTest {
+
+    @RealmModule(classes = {AllJavaTypes.class})
+    public static class ObjectLevelTestModule {
+    }
+
+    @RealmModule(classes = {PermissionObject.class})
+    public static class OLPermissionModule {
+    }
+
+    // Check default privileges after being online for the first time
+    @Test
+    @RunTestInLooperThread()
+    public void getPrivileges_serverDefaults() throws InterruptedException {
+        String realmUrl = Constants.GLOBAL_REALM + "_getPrivileges_serverDefaults";
+        List schemaModule = Arrays.asList(new ObjectLevelTestModule());
+        createWorldReadableRealm(realmUrl, schemaModule);
+
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, realmUrl)
+                .modules(schemaModule)
+                .partialRealm()
+                .build();
+
+        Realm realm = Realm.getInstance(syncConfig);
+
+        // Make sure that all objects are part of the Partial Sync transitive closure
+        realm.where(AllJavaTypes.class).findAllAsync("keep-AllJavaTypes");
+
+        // Create offline object
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(AllJavaTypes.class).count());
+
+        // Make sure that server permissions have been applied to local object
+        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
+        SyncManager.getSession(syncConfig).downloadAllServerChanges();
+        realm.refresh();
+
+        // Check Realm privileges
+        RealmPrivileges realmPrivileges = realm.getPrivileges();
+        assertFullAccess(realmPrivileges);
+
+        // Check Class privileges
+        ClassPrivileges classPrivileges = realm.getPrivileges(AllJavaTypes.class);
+        assertFullAccess(classPrivileges);
+
+        // Check Object privileges
+        assertEquals(1, realm.where(AllJavaTypes.class).count());
+        ObjectPrivileges objectPrivileges = realm.getPrivileges(obj);
+        assertFullAccess(objectPrivileges);
+
+        realm.close();
+        looperThread.testComplete();
+    }
+
+//    @Test
+//    @RunTestInLooperThread
+//    public void getRoles() {
+//        fail("FIXME");
+//        looperThread.testComplete();
+//    }
+
+    // Restrict read/write permission, only the owner of the object can see/modify it
+    @Test
+    @RunTestInLooperThread()
+    public void restrictAccessToOwner() throws InterruptedException {
+        String realmUrl = Constants.GLOBAL_REALM + "_restrictAccessToOwner";
+        List schemaModules = Arrays.asList(new StringOnlyModule(), new OLPermissionModule(), new ObjectPermissionsModule());
+        createWorldReadableRealm(realmUrl, schemaModules);
+
+        // connect with user1
+        SyncUser user1 = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration user1SyncConfig = configurationFactory
+                .createSyncConfigurationBuilder(user1, realmUrl)
+                .modules(schemaModules)
+                .partialRealm()
+                .build();
+        Realm user1Realm = Realm.getInstance(user1SyncConfig);
+        user1Realm.beginTransaction();
+
+        // added a new Role to restrict access to our objects
+        Role role = user1Realm.createObject(Role.class, "role_" + user1.getIdentity());
+        role.addMember(user1.getIdentity());
+
+        // add permission so this will be only visible and modifiable from user1
+        Permission userPermission = new Permission(role);
+        userPermission.setCanRead(true);
+        userPermission.setCanQuery(true);
+        userPermission.setCanCreate(true);
+        userPermission.setCanUpdate(true);
+        userPermission.setCanUpdate(true);
+        userPermission.setCanDelete(true);
+        userPermission.setCanSetPermissions(true);
+        userPermission.setCanModifySchema(true);
+
+        PermissionObject permissionObject1 = user1Realm.createObject(PermissionObject.class, "Foo");
+        permissionObject1.getPermissions().add(userPermission);
+        user1Realm.commitTransaction();
+
+        SyncManager.getSession(user1SyncConfig).uploadAllLocalChanges();
+        user1Realm.close();
+
+        // Connect with admin user and verify that user1 object is visible (non-partial Realm)
+        SyncUser adminUser = UserFactory.createNicknameUser(Constants.AUTH_URL, "admin2", true);
+        SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, realmUrl)
+                .modules(schemaModules)
+                .waitForInitialRemoteData()
+                .build();
+        Realm adminRealm = Realm.getInstance(adminConfig);
+        RealmResults<PermissionObject> allPermissionObjects = adminRealm.where(PermissionObject.class).findAll();
+        assertEquals(1, allPermissionObjects.size());
+        PermissionObject permissionObject = allPermissionObjects.first();
+        assertEquals("Foo", permissionObject.getName());
+        assertEquals(1, permissionObject.getPermissions().size());
+        Permission permission = permissionObject.getPermissions().get(0);
+        assertFullAccess(permission);
+        adminRealm.close();
+
+        // Connect with user 2 and verify that user1 object is not visible
+        SyncUser user2 = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfig2 = configurationFactory.createSyncConfigurationBuilder(user2, realmUrl)
+                .modules(schemaModules)
+                .partialRealm()
+                .build();
+        Realm user2Realm = Realm.getInstance(syncConfig2);
+        looperThread.closeAfterTest(user2Realm);
+        RealmResults<PermissionObject> allAsync = user2Realm.where(PermissionObject.class).findAllAsync();
+        looperThread.keepStrongReference(allAsync);
+        // new object should not be visible for user2 partial sync
+        allAsync.addChangeListener((permissionObjects2, changeSet) -> {
+            switch (changeSet.getState()) {
+                case INITIAL:
+                    assertEquals(0, permissionObjects2.size());
+                    break;
+                case UPDATE:
+                    assertEquals(0, permissionObjects2.size());
+                    looperThread.testComplete();
+                    break;
+                case ERROR:
+                    fail("Unexpected error callback");
+                    break;
+            }
+        });
+    }
+
+    private void assertFullAccess(Permission permission) {
+        assertTrue(permission.canCreate());
+        assertTrue(permission.canRead());
+        assertTrue(permission.canUpdate());
+        assertTrue(permission.canDelete());
+        assertTrue(permission.canQuery());
+        assertTrue(permission.canSetPermissions());
+        assertTrue(permission.canModifySchema());
+    }
+
+    private void assertFullAccess(ClassPrivileges privileges) {
+        assertTrue(privileges.canCreate());
+        assertTrue(privileges.canRead());
+        assertTrue(privileges.canUpdate());
+        assertTrue(privileges.canQuery());
+        assertTrue(privileges.canSetPermissions());
+    }
+
+    private void assertFullAccess(RealmPrivileges privileges) {
+        assertTrue(privileges.canRead());
+        assertTrue(privileges.canUpdate());
+        assertTrue(privileges.canSetPermissions());
+        assertTrue(privileges.canModifySchema());
+    }
+
+    private void assertFullAccess(ObjectPrivileges privileges) {
+        assertTrue(privileges.canRead());
+        assertTrue(privileges.canUpdate());
+        assertTrue(privileges.canDelete());
+        assertTrue(privileges.canSetPermissions());
+    }
+
+    private void createWorldReadableRealm(String realmUrl, List modules) {
+        HandlerThread t = new HandlerThread("create-realm-thread");
+        t.start();
+        Handler handler = new Handler(t.getLooper());
+        CountDownLatch setupRealm = new CountDownLatch(1);
+        handler.post(() -> {
+            final boolean oldValue = AndroidCapabilities.EMULATE_MAIN_THREAD;
+            SyncUser adminUser = UserFactory.createNicknameUser(Constants.AUTH_URL, "admin", true);
+            SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, realmUrl)
+                    .modules(modules)
+                    .addModule(new PermissionModule())
+                    .partialRealm()
+                    .waitForInitialRemoteData()
+                    .build();
+            Realm.getInstanceAsync(syncConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    AndroidCapabilities.EMULATE_MAIN_THREAD = true;
+                    PermissionManager pm = adminUser.getPermissionManager();
+                    pm.applyPermissions(new PermissionRequest(UserCondition.noExistingPermissions(), realmUrl, AccessLevel.WRITE), new PermissionManager.ApplyPermissionsCallback() {
+                        @Override
+                        public void onSuccess() {
+                            handler.post(() -> {
+                                AndroidCapabilities.EMULATE_MAIN_THREAD = oldValue;
+                                pm.close();
+                                realm.close();
+                                adminUser.logOut();
+                                setupRealm.countDown();
+                            });
+                        }
+
+                        @Override
+                        public void onError(ObjectServerError error) {
+                            fail(error.toString());
+                        }
+                    });
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    fail(exception.toString());
+                }
+            });
+        });
+        TestHelper.awaitOrFail(setupRealm);
+    }
+
+}
+
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
index 15d3f2ae49..accd479d25 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
@@ -1,59 +1,319 @@
 package io.realm.objectserver;
 
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.CountDownLatch;
-
+import io.realm.DynamicRealm;
+import io.realm.OrderedCollectionChangeSet;
 import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmList;
 import io.realm.RealmResults;
 import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.SyncUser;
-import io.realm.TestHelper;
-import io.realm.TestSyncConfigurationFactory;
-import io.realm.exceptions.RealmException;
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
 import io.realm.objectserver.model.PartialSyncModule;
 import io.realm.objectserver.model.PartialSyncObjectA;
 import io.realm.objectserver.model.PartialSyncObjectB;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
 
 import static org.hamcrest.number.OrderingComparison.greaterThan;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
 public class PartialSyncTests extends StandardIntegrationTest {
-    @Rule
-    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    private static final int TEST_SIZE = 10;
 
     @Test
-    public void partialSync() throws InterruptedException {
+    @RunTestInLooperThread
+    public void invalidQuery() {
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .partialRealm()
+                .build();
+        final Realm realm = Realm.getInstance(partialSyncConfig);
+        looperThread.closeAfterTest(realm);
 
-        final SyncConfiguration syncConfig = configFactory
-                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .waitForInitialRemoteData()
-                .modules(new PartialSyncModule())
+        // Backlinks not yet supported: https://github.com/realm/realm-core/pull/2947
+        RealmResults<AllJavaTypes> query = realm.where(AllJavaTypes.class).equalTo("objectParents.fieldString", "Foo").findAllAsync();
+        query.addChangeListener((results, changeSet) -> {
+                    if (changeSet.getState() == OrderedCollectionChangeSet.State.ERROR) {
+                        assertTrue(changeSet.getError() instanceof IllegalArgumentException);
+                        Throwable iae = changeSet.getError();
+                        assertTrue(iae.getMessage().contains("Querying over backlinks is disabled but backlinks were found"));
+                        looperThread.testComplete();
+                    }
+                });
+        looperThread.keepStrongReference(query);
+    }
+
+    // List queries are operating on data that are always up to date as data in a list will
+    // always be fetched as part of another top-level subscription. Thus `remoteDataLoaded` is
+    // always true and no queries on them can fail.
+    @Test
+    @RunTestInLooperThread
+    public void listQueries_doNotCreateSubscriptions() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .partialRealm()
                 .build();
 
-        final SyncConfiguration partialSyncConfig = configFactory
-                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+        final DynamicRealm dRealm = DynamicRealm.getInstance(partialSyncConfig);
+        final Realm realm = Realm.getInstance(partialSyncConfig);
+        looperThread.closeAfterTest(dRealm);
+        looperThread.closeAfterTest(realm);
+
+        realm.beginTransaction();
+        RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        list.add(new Dog("Fido"));
+        list.add(new Dog("Eido"));
+        realm.commitTransaction();
+
+        RealmResults<Dog> query = list.where().sort("name").findAllAsync();
+        query.addChangeListener((dogs, changeSet) -> {
+            assertEquals(OrderedCollectionChangeSet.State.INITIAL, changeSet.getState());
+            assertEquals(0, dRealm.where("__ResultSets").count());
+            looperThread.testComplete();
+        });
+        looperThread.keepStrongReference(query);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void anonymousSubscription() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+
+        // Download data in partial Realm
+        final Realm partialSyncRealm = getPartialRealm(user);
+        looperThread.closeAfterTest(partialSyncRealm);
+        assertTrue(partialSyncRealm.isEmpty());
+
+        RealmResults<PartialSyncObjectA> results = partialSyncRealm.where(PartialSyncObjectA.class)
+                .greaterThan("number", 5)
+                .findAllAsync();
+        looperThread.keepStrongReference(results);
+
+        results.addChangeListener((partialSyncObjectAS, changeSet) -> {
+            if (changeSet.isCompleteResult()) {
+                if (results.size() == 4) {
+                    for (PartialSyncObjectA object : results) {
+                        assertThat(object.getNumber(), greaterThan(5));
+                        assertEquals("partial", object.getString());
+                    }
+                    // make sure the Realm contains only PartialSyncObjectA
+                    assertEquals(0, partialSyncRealm.where(PartialSyncObjectB.class).count());
+                    looperThread.testComplete();
+                }
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void namedSubscription() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+
+        // Download data in partial Realm
+        final Realm partialSyncRealm = getPartialRealm(user);
+        looperThread.closeAfterTest(partialSyncRealm);
+        assertTrue(partialSyncRealm.isEmpty());
+
+        RealmResults<PartialSyncObjectA> results = partialSyncRealm.where(PartialSyncObjectA.class)
+                .greaterThan("number", 5)
+                .findAllAsync("my-subscription-id");
+        looperThread.keepStrongReference(results);
+
+        results.addChangeListener((partialSyncObjectAS, changeSet) -> {
+            if (changeSet.isCompleteResult()) {
+                if (results.size() == 4) {
+                    for (PartialSyncObjectA object : results) {
+                        assertThat(object.getNumber(), greaterThan(5));
+                        assertEquals("partial", object.getString());
+                    }
+                    // make sure the Realm contains only PartialSyncObjectA
+                    assertEquals(0, partialSyncRealm.where(PartialSyncObjectB.class).count());
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void partialSync_namedSubscriptionThrowsOnNonPartialRealms() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        final SyncConfiguration fullSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .name("fullySynchronizedRealm")
+                .build();
+
+        Realm realm = Realm.getInstance(fullSyncConfig);
+        looperThread.closeAfterTest(realm);
+
+        try {
+           realm.where(PartialSyncObjectA.class).findAllAsync("my-id");
+           fail();
+        } catch (IllegalStateException ignore) {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void partialSync_namedSubscription_namedConflictThrows() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        RealmResults<PartialSyncObjectA> results1 = realm.where(PartialSyncObjectA.class)
+                .findAllAsync("my-id");
+        results1.addChangeListener((results, changeSet) -> {
+            // Ignore. Just used to trigger partial sync path
+        });
+
+        RealmResults<PartialSyncObjectB> results2 = realm.where(PartialSyncObjectB.class)
+                .findAllAsync("my-id");
+        results2.addChangeListener((results, changeSet) -> {
+            if (changeSet.getState() == OrderedCollectionChangeSet.State.ERROR) {
+                assertEquals(OrderedCollectionChangeSet.State.ERROR, changeSet.getState());
+                assertTrue(changeSet.getError() instanceof IllegalArgumentException);
+                looperThread.testComplete();
+            }
+        });
+
+        looperThread.keepStrongReference(results1);
+        looperThread.keepStrongReference(results2);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void unsubscribeAsync() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+        Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        final String subscriptionName = "my-objects";
+        RealmResults<PartialSyncObjectB> r = realm.where(PartialSyncObjectB.class)
+                .greaterThan("number", 0)
+                .findAllAsync(subscriptionName);
+
+        r.addChangeListener((results, changeSet) -> {
+            if (changeSet.isCompleteResult()) {
+                // 1. Partial sync downloaded all expected objects
+                assertEquals(TEST_SIZE - 1, results.size());
+                r.removeAllChangeListeners();
+
+                // 2. Attempt to remove them again
+                realm.unsubscribeAsync(subscriptionName, new Realm.UnsubscribeCallback() {
+                    @Override
+                    public void onSuccess(String subscriptionName) {
+                        assertEquals(subscriptionName, subscriptionName);
+
+                        // Use global Realm change listener to avoid re-subscribing
+                        realm.addChangeListener(new RealmChangeListener<Realm>() {
+                            @Override
+                            public void onChange(Realm realm) {
+                                // Eventually they should be removed
+                                if (realm.where(PartialSyncObjectB.class).count() == 0) {
+                                    looperThread.testComplete();
+                                }
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onError(String subscriptionName, Throwable error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void unsubscribeAsync_nonExistingIdThrows() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        realm.unsubscribeAsync("i-dont-exist", new Realm.UnsubscribeCallback() {
+            @Override
+            public void onSuccess(String subscriptionName) {
+                fail();
+            }
+
+            @Override
+            public void onError(String subscriptionName, Throwable error) {
+                assertEquals("i-dont-exist", subscriptionName);
+                assertTrue(error instanceof IllegalArgumentException);
+                assertTrue(error.getMessage().contains("No active subscription named"));
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void clearTable() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        // Create test data and make sure it is uploaded to the server
+        RealmResults<PartialSyncObjectA> result = realm.where(PartialSyncObjectA.class).findAllAsync();
+        realm.executeTransaction(r -> {
+            r.createObject(PartialSyncObjectA.class).setString("ObjectA");
+        });
+        SyncTestUtils.syncRealm(realm);
+        assertEquals(1, result.size());
+
+        // Delete data and make sure it is accepted by the server
+        realm.executeTransaction(r -> {
+            // TODO the API's that actual use the clearTable instruction have all been disabled for now
+            // and are throwing IllegalStateException (realm.delete(Class) and realm.deleteAll).
+            // Keep the test for time being, but use the recommend workaround for deleting objects
+            // instead.
+            r.where(PartialSyncObjectA.class).findAll().deleteAllFromRealm();
+        });
+        SyncTestUtils.syncRealm(realm);
+        assertTrue(result.isEmpty());
+        looperThread.testComplete();
+    }
+
+    private Realm getPartialRealm(SyncUser user) {
+        final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                 .name("partialSync")
                 .modules(new PartialSyncModule())
                 .partialRealm()
                 .build();
+        return Realm.getInstance(partialSyncConfig);
+    }
+
+    private void createServerData(SyncUser user, String url) throws InterruptedException {
+        final SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, url)
+                .waitForInitialRemoteData()
+                .partialRealm()
+                .modules(new PartialSyncModule())
+                .build();
 
+        // Create server data
         Realm realm = Realm.getInstance(syncConfig);
         realm.beginTransaction();
         PartialSyncObjectA objectA = realm.createObject(PartialSyncObjectA.class);
@@ -87,64 +347,11 @@ public void partialSync() throws InterruptedException {
         objectA.setNumber(9);
         objectA.setString("partial");
 
-        for (int i = 0; i < 10; i++) {
+        for (int i = 0; i < TEST_SIZE; i++) {
             realm.createObject(PartialSyncObjectB.class).setNumber(i);
         }
         realm.commitTransaction();
-
         SyncManager.getSession(syncConfig).uploadAllLocalChanges();
         realm.close();
-
-        final CountDownLatch latch = new CountDownLatch(2);
-
-        HandlerThread handlerThread = new HandlerThread("background");
-        handlerThread.start();
-        Handler handler = new Handler(handlerThread.getLooper());
-        handler.post(new Runnable() {
-            @Override
-            public void run() {
-                final Realm partialSyncRealm = Realm.getInstance(partialSyncConfig);
-                assertTrue(partialSyncRealm.isEmpty());
-
-                partialSyncRealm.subscribeToObjects(PartialSyncObjectA.class, "number > 5", new Realm.PartialSyncCallback<PartialSyncObjectA>() {
-
-                    @Override
-                    public void onSuccess(RealmResults<PartialSyncObjectA> results) {
-                        assertEquals(4, results.size());
-                        for (PartialSyncObjectA object : results) {
-                            assertThat(object.getNumber(), greaterThan(5));
-                            assertEquals("partial", object.getString());
-                        }
-                        // make sure the Realm contains only PartialSyncObjectA
-                        assertEquals(0, partialSyncRealm.where(PartialSyncObjectB.class).count());
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(RealmException error) {
-                        fail(error.getMessage());
-                    }
-                });
-
-                // Invalid query
-                partialSyncRealm.subscribeToObjects(PartialSyncObjectA.class, "invalid_property > 5", new Realm.PartialSyncCallback<PartialSyncObjectA>() {
-
-                    @Override
-                    public void onSuccess(RealmResults<PartialSyncObjectA> results) {
-                        fail("Invalid query should not succeed");
-                    }
-
-                    @Override
-                    public void onError(RealmException error) {
-                        assertNotNull(error);
-                        partialSyncRealm.close();
-                        latch.countDown();
-                    }
-                });
-
-            }
-        });
-
-        TestHelper.awaitOrFail(latch);
-    }
+   }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 2b7c9383cb..214af8c97d 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -32,7 +32,10 @@
 import io.realm.RealmResults;
 import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
 import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.annotations.RealmModule;
 import io.realm.objectserver.model.ProcessInfo;
 import io.realm.objectserver.model.TestObject;
 import io.realm.objectserver.utils.Constants;
@@ -49,6 +52,9 @@
 @RunWith(AndroidJUnit4.class)
 public class ProcessCommitTests extends StandardIntegrationTest {
 
+    @RealmModule(classes = { ProcessInfo.class, TestObject.class })
+    public static class ProcessCommitTestsModule { }
+
     @Rule
     public RunWithRemoteService remoteService = new RunWithRemoteService();
 
@@ -68,6 +74,7 @@ protected void run() {
                 String realmUrl = Constants.SYNC_SERVER_URL;
 
                 final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
+                        .modules(new ProcessCommitTestsModule())
                         .directory(getService().getRoot())
                         .build();
                 getService().setRealm(Realm.getInstance(syncConfig));
@@ -79,13 +86,20 @@ protected void run() {
                 processInfo.setPid(android.os.Process.myPid());
                 processInfo.setThreadId(Thread.currentThread().getId());
                 realm.commitTransaction();
-                // FIXME: If we close the Realm here, the data won't be able to synced to the main process. Is it a bug
-                // in sync client which stops too early?
-                // Realm is currently configured with stop_immediately. This means the sync session is closed as soon as
-                // the last realm instance is closed. Not doing this would make the Realm lifecycle really
-                // unpredictable. We should have an easy way to wait for all changes to be uploaded though.
-                // Perhaps SyncSession.uploadAllLocalChanges() or something similar to
-                // SyncSesson.downloadAllServerChanges()
+                Thread t = new Thread(() -> {
+                    try {
+                        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
+                    } catch (InterruptedException e) {
+                        throw new IllegalStateException("Upload interrupted", e);
+                    }
+                });
+                t.start();
+                try {
+                    t.join(TestHelper.SHORT_WAIT_SECS * 1000);
+                } catch (InterruptedException e) {
+                    throw new IllegalStateException("Waiting for background thread interrupted", e);
+                }
+                realm.close();
             }
         };
 
@@ -93,7 +107,7 @@ protected void run() {
             @Override
             protected void run() {
                 getService().getRealm().close();
-                user.logout();
+                user.logOut();
             }
         };
     }
@@ -111,6 +125,7 @@ public void expectSimpleCommit() {
         final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);
         String realmUrl = Constants.SYNC_SERVER_URL;
         final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user,realmUrl)
+                .modules(new ProcessCommitTestsModule())
                 .directory(looperThread.getRoot())
                 .build();
         final Realm realm = Realm.getInstance(syncConfig);
@@ -122,7 +137,7 @@ public void onChange(RealmResults<ProcessInfo> element) {
                 assertEquals(1, all.size());
                 assertEquals("Background_Process1", all.get(0).getName());
                 realm.close();
-                user.logout();
+                user.logOut();
 
                 remoteService.triggerServiceStep(SimpleCommitRemoteService.stepB_closeRealmAndLogOut);
 
@@ -143,6 +158,7 @@ protected void run() {
                 String realmUrl = Constants.SYNC_SERVER_URL;
 
                 final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
+                        .modules(new ProcessCommitTestsModule())
                         .directory(getService().getRoot())
                         .name(UUID.randomUUID().toString() + ".realm")
                         .build();
@@ -169,7 +185,7 @@ protected void run() {
             @Override
             protected void run() {
                 getService().getRealm().close();
-                user.logout();
+                user.logOut();
             }
         };
     }
@@ -189,6 +205,7 @@ public void expectALot() throws Throwable {
         final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);
         String realmUrl = Constants.SYNC_SERVER_URL;
         final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user,realmUrl)
+                .modules(new ProcessCommitTestsModule())
                 .directory(looperThread.getRoot())
                 .build();
         final Realm realm = Realm.getInstance(syncConfig);
@@ -210,7 +227,7 @@ public void onChange(RealmResults<TestObject> element) {
                 if (counter == 10) {
                     remoteService.triggerServiceStep(ALotCommitsRemoteService.stepC_closeRealm);
                     realm.close();
-                    user.logout();
+                    user.logOut();
                     looperThread.testComplete();
                 } else {
                     remoteService.triggerServiceStep(ALotCommitsRemoteService.stepB_createObjects);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
index 9183adda5e..5efddd5eb7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -219,8 +219,8 @@ public void onChange(Progress progress) {
         adminRealm.close();
         // worker thread will hang if logout happens before listener triggered.
         worker.join();
-        userWithData.logout();
-        adminUser.logout();
+        userWithData.logOut();
+        adminUser.logOut();
     }
 
     // Make sure that a ProgressListener continues to report the correct thing, even if it crashed
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PermissionObject.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PermissionObject.java
new file mode 100644
index 0000000000..53903a2f34
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PermissionObject.java
@@ -0,0 +1,26 @@
+package io.realm.objectserver.model;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+import io.realm.sync.permissions.Permission;
+
+public class PermissionObject extends RealmObject {
+    @PrimaryKey
+    @Required
+    private String name;
+    private RealmList<Permission> permissions = new RealmList<>();
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public RealmList<Permission> getPermissions() {
+        return permissions;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index 70b9cf492b..9414bb4fcd 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -21,6 +21,7 @@
     public static String HOST = "127.0.0.1";
     public static final String USER_REALM = "realm://" + HOST + ":9080/~/tests";
     public static final String USER_REALM_2 = "realm://" + HOST + ":9080/~/tests2";
+    public static final String GLOBAL_REALM = "realm://" + HOST + ":9080/tests";
     public static final String USER_REALM_SECURE = "realms://" + HOST + ":9443/~/tests";
     public static final String SYNC_SERVER_URL = "realm://" + HOST + ":9080/~/tests";
     public static final String SYNC_SERVER_URL_2 = "realm://" + HOST + ":9080/~/tests2";
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index 24345677b3..ccfd1c2f85 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -18,22 +18,17 @@
 
 import android.os.Handler;
 import android.os.HandlerThread;
-import android.os.SystemClock;
 
 import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
 
-import io.realm.AuthenticationListener;
-import io.realm.ErrorCode;
-import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.SyncCredentials;
-import io.realm.SyncManager;
 import io.realm.SyncUser;
 import io.realm.TestHelper;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.log.RealmLog;
 
 import static org.junit.Assert.fail;
@@ -48,9 +43,12 @@
     // test starts and store it in a Realm. Then it can be retrieved for every process.
     private String userName;
     private static UserFactory instance;
-    private static RealmConfiguration configuration = new RealmConfiguration.Builder()
-            .name("user-factory.realm")
-            .build();
+    private static RealmConfiguration configuration;
+    static {
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder().name("user-factory.realm");
+        ObjectServerFacade.getSyncFacadeIfPossible().addSupportForObjectLevelPermissions(builder);
+        configuration = builder.build();
+    }
 
     private UserFactory(String userName) {
         this.userName = userName;
@@ -58,7 +56,7 @@ private UserFactory(String userName) {
 
     public SyncUser loginWithDefaultUser(String authUrl) {
         SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, false);
-        return SyncUser.login(credentials, authUrl);
+        return SyncUser.logIn(credentials, authUrl);
     }
 
     /**
@@ -79,20 +77,25 @@ public static SyncUser createUniqueUser(String authUrl) {
 
     private static SyncUser createUser(String username, String authUrl) {
         SyncCredentials credentials = SyncCredentials.usernamePassword(username, PASSWORD, true);
-        return SyncUser.login(credentials, authUrl);
+        return SyncUser.logIn(credentials, authUrl);
     }
 
 
     public SyncUser createDefaultUser(String authUrl) {
         SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, true);
-        return SyncUser.login(credentials, authUrl);
+        return SyncUser.logIn(credentials, authUrl);
     }
 
     public static SyncUser createAdminUser(String authUrl) {
         // `admin` required as user identifier to be granted admin rights.
         // ROS 2.0 comes with a default admin user named "realm-admin" with password "".
         SyncCredentials credentials = SyncCredentials.usernamePassword("realm-admin", "", false);
-        return SyncUser.login(credentials, authUrl);
+        return SyncUser.logIn(credentials, authUrl);
+    }
+
+    public static SyncUser createNicknameUser(String authUrl, String nickname, boolean isAdmin) {
+        SyncCredentials credentials = SyncCredentials.nickname(nickname, isAdmin);
+        return SyncUser.logIn(credentials, authUrl);
     }
 
     // Since we don't have a reliable way to reset the sync server and client, just use a new user factory for every
@@ -147,7 +150,7 @@ public static void logoutAllUsers() {
             public void run() {
                 Map<String, SyncUser> users = SyncUser.all();
                 for (SyncUser user : users.values()) {
-                    user.logout();
+                    user.logOut();
                 }
                 allUsersLoggedOut.countDown();
 
diff --git a/realm/realm-library/src/testUtils/java/io/realm/entities/AllTypesModelModule.java b/realm/realm-library/src/testUtils/java/io/realm/entities/AllTypesModelModule.java
new file mode 100644
index 0000000000..7f31e0b774
--- /dev/null
+++ b/realm/realm-library/src/testUtils/java/io/realm/entities/AllTypesModelModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = { AllTypes.class, Dog.class, Owner.class, Cat.class, DogPrimaryKey.class })
+public class AllTypesModelModule {
+
+}
+
diff --git a/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
index 74a0ec5a15..b6c6bb1e30 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -35,6 +35,7 @@
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.internal.ObjectServerFacade;
 
 import static org.junit.Assert.assertTrue;
 
@@ -129,7 +130,9 @@ private synchronized boolean isUnitTestFailed() {
     // This builder creates a configuration that is *NOT* managed.
     // You have to delete it yourself.
     public RealmConfiguration.Builder createConfigurationBuilder() {
-        return new RealmConfiguration.Builder().directory(getRoot());
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder().directory(getRoot());
+        ObjectServerFacade.getSyncFacadeIfPossible().addSupportForObjectLevelPermissions(builder);
+        return builder;
     }
 
     public RealmConfiguration createConfiguration() {
@@ -168,6 +171,8 @@ public RealmConfiguration createConfiguration(String subDir, String name, Object
 
         if (module != null) {
             builder.modules(module);
+        } else {
+            ObjectServerFacade.getSyncFacadeIfPossible().addSupportForObjectLevelPermissions(builder);
         }
 
         if (key != null) {
diff --git a/realm/realm-library/src/testUtils/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/testUtils/java/io/realm/services/RemoteProcessService.java
index 4062ee8e38..ec54957291 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/services/RemoteProcessService.java
@@ -31,6 +31,7 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesModelModule;
 
 /**
  * Helper service for multi-processes support testing.
@@ -128,7 +129,7 @@ private static String currentLine() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder().build());
+            thiz.testRealm = Realm.getInstance(getConfiguration());
             int expected = 1;
             long got = thiz.testRealm.where(AllTypes.class).count();
             if (expected == got) {
@@ -144,10 +145,15 @@ void run() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder().build());
+            thiz.testRealm = Realm.getInstance(getConfiguration());
             thiz.testRealm.close();
             response(null);
             Runtime.getRuntime().exit(0);
         }
     };
+
+    private static RealmConfiguration getConfiguration() {
+        return new RealmConfiguration.Builder().modules(new AllTypesModelModule()).build();
+    }
+
 }
diff --git a/version.txt b/version.txt
index 45963d3ece..c30f0ec2be 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-4.4.1-SNAPSHOT
\ No newline at end of file
+5.1.0-SNAPSHOT
\ No newline at end of file
