diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index e55980ca6e..a7a1c2385e 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -26,7 +26,7 @@
 #include "util.hpp"
 #include "jni_util/java_method.hpp"
 #include "jni_util/java_class.hpp"
-#include "jni_util/java_global_ref.hpp"
+#include "jni_util/java_global_weak_ref.hpp"
 #include "jni_util/jni_utils.hpp"
 #include "jni_util/java_exception_thrower.hpp"
 
@@ -132,16 +132,26 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSchemaConfi
             static JavaMethod run_migration_callback_method(
                 env, get_shared_realm_class(env), "runMigrationCallback",
                 "(JLio/realm/internal/OsRealmConfig;Lio/realm/internal/SharedRealm$MigrationCallback;J)V", true);
-            JavaGlobalRef j_config_ref(env, j_config, true);
-            JavaGlobalRef j_migration_callback_ref(env, j_migration_callback, true);
-            config.migration_function = [j_config_ref, j_migration_callback_ref](SharedRealm old_realm,
+            // weak ref to avoid leaks caused by circular refs.
+            JavaGlobalWeakRef j_config_weak(env, j_config);
+            JavaGlobalWeakRef j_migration_cb_weak(env, j_migration_callback);
+            // TODO: It would be great if we can use move constructor in the lambda capture which was introduced in
+            // c++14. But sadly it seems to be a bug with gcc 4.9 to support it.
+            config.migration_function = [j_migration_cb_weak, j_config_weak](SharedRealm old_realm,
                                                                                  SharedRealm realm, Schema&) {
                 JNIEnv* env = JniUtils::get_env(false);
                 // Java needs a new pointer for the SharedRealm life control.
                 SharedRealm* new_shared_realm_ptr = new SharedRealm(realm);
-                env->CallStaticVoidMethod(get_shared_realm_class(env), run_migration_callback_method,
-                                          reinterpret_cast<jlong>(new_shared_realm_ptr), j_config_ref.get(),
-                                          j_migration_callback_ref.get(), old_realm->schema_version());
+                JavaGlobalRef config_global = j_config_weak.global_ref(env);
+                if (!config_global) {
+                    return;
+                }
+
+                j_migration_cb_weak.call_with_local_ref(env, [&](JNIEnv* env, jobject obj) {
+                    env->CallStaticVoidMethod(get_shared_realm_class(env), run_migration_callback_method,
+                                              reinterpret_cast<jlong>(new_shared_realm_ptr), config_global.get(), obj,
+                                              old_realm->schema_version());
+                });
                 TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
             };
         }
@@ -162,13 +172,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetCompactOnLa
         if (j_compact_on_launch) {
             static JavaClass compact_on_launch_class(env, "io/realm/CompactOnLaunchCallback");
             static JavaMethod should_compact(env, compact_on_launch_class, "shouldCompact", "(JJ)Z");
-            JavaGlobalRef java_compact_on_launch_ref(env, j_compact_on_launch);
+            // weak ref to avoid leaks caused by circular refs.
+            JavaGlobalWeakRef java_compact_on_launch_weak(env, j_compact_on_launch);
 
-            config.should_compact_on_launch_function = [java_compact_on_launch_ref](uint64_t totalBytes,
+            config.should_compact_on_launch_function = [java_compact_on_launch_weak](uint64_t totalBytes,
                                                                                     uint64_t usedBytes) {
                 JNIEnv* env = JniUtils::get_env(false);
-                bool result = env->CallBooleanMethod(java_compact_on_launch_ref.get(), should_compact,
-                                                     static_cast<jlong>(totalBytes), static_cast<jlong>(usedBytes));
+                bool result = false;
+                java_compact_on_launch_weak.call_with_local_ref(env, [&](JNIEnv* env, jobject obj) {
+                    result = env->CallBooleanMethod(obj, should_compact, static_cast<jlong>(totalBytes),
+                                                    static_cast<jlong>(usedBytes));
+                });
                 TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
                 return result;
             };
@@ -194,15 +208,22 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInitializat
             static JavaMethod run_initialization_callback_method(
                 env, get_shared_realm_class(env), "runInitializationCallback",
                 "(JLio/realm/internal/OsRealmConfig;Lio/realm/internal/SharedRealm$InitializationCallback;)V", true);
-            JavaGlobalRef j_init_callback_ref(env, j_init_callback, true);
-            JavaGlobalRef j_config_ref(env, j_config, true);
-            config.initialization_function = [j_init_callback_ref, j_config_ref](SharedRealm realm) {
+            // weak ref to avoid leaks caused by circular refs.
+            JavaGlobalWeakRef j_init_cb_weak(env, j_init_callback);
+            JavaGlobalWeakRef j_config_weak(env, j_config);
+            config.initialization_function = [j_init_cb_weak, j_config_weak](SharedRealm realm) {
                 JNIEnv* env = JniUtils::get_env(false);
                 // Java needs a new pointer for the SharedRealm life control.
                 SharedRealm* new_shared_realm_ptr = new SharedRealm(realm);
-                env->CallStaticVoidMethod(get_shared_realm_class(env), run_initialization_callback_method,
-                                          reinterpret_cast<jlong>(new_shared_realm_ptr), j_config_ref.get(),
-                                          j_init_callback_ref.get());
+                JavaGlobalRef config_global_ref = j_config_weak.global_ref(env);
+                if (!config_global_ref) {
+                    return;
+                }
+                j_init_cb_weak.call_with_local_ref(env, [&](JNIEnv* env, jobject obj) {
+                    env->CallStaticVoidMethod(get_shared_realm_class(env), run_initialization_callback_method,
+                                              reinterpret_cast<jlong>(new_shared_realm_ptr), config_global_ref.get(),
+                                              obj);
+                });
                 TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env);
             };
         }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
index 1b118074e3..7c68165b63 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
@@ -45,6 +45,7 @@ class JavaGlobalRef {
     ~JavaGlobalRef();
 
     JavaGlobalRef& operator=(JavaGlobalRef&& rhs);
+    JavaGlobalRef& operator=(JavaGlobalRef& rhs) = delete;
     JavaGlobalRef(JavaGlobalRef&);
 
     inline operator bool() const noexcept
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
index 10718df40c..898cdeeace 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
@@ -19,7 +19,56 @@
 
 using namespace realm::jni_util;
 
-bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback> callback)
+JavaGlobalWeakRef::JavaGlobalWeakRef()
+    : m_weak(nullptr)
+{
+}
+
+JavaGlobalWeakRef::JavaGlobalWeakRef(JNIEnv* env, jobject obj)
+    : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr)
+{
+}
+
+JavaGlobalWeakRef::~JavaGlobalWeakRef()
+{
+    if (m_weak) {
+        JniUtils::get_env()->DeleteWeakGlobalRef(m_weak);
+    }
+}
+
+JavaGlobalWeakRef::JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs)
+    : m_weak(rhs.m_weak)
+{
+    rhs.m_weak = nullptr;
+}
+
+JavaGlobalWeakRef& JavaGlobalWeakRef::operator=(JavaGlobalWeakRef&& rhs)
+{
+    this->~JavaGlobalWeakRef();
+    new (this) JavaGlobalWeakRef(std::move(rhs));
+    return *this;
+}
+
+JavaGlobalWeakRef::JavaGlobalWeakRef(const JavaGlobalWeakRef& rhs)
+    : m_weak(JniUtils::get_env(true)->NewWeakGlobalRef(rhs.m_weak))
+{
+}
+
+JavaGlobalWeakRef& JavaGlobalWeakRef::operator=(const JavaGlobalWeakRef& rhs)
+{
+    new (this) JavaGlobalWeakRef(rhs);
+    return *this;
+}
+
+JavaGlobalRef JavaGlobalWeakRef::global_ref(JNIEnv* env) const
+{
+    if (!env) {
+        env = JniUtils::get_env(true);
+    }
+    return JavaGlobalRef(env, m_weak);
+}
+
+bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback> callback) const
 {
     if (!m_weak) {
         return false;
@@ -34,7 +83,7 @@ bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback>
     return true;
 }
 
-bool JavaGlobalWeakRef::call_with_local_ref(std::function<Callback> callback)
+bool JavaGlobalWeakRef::call_with_local_ref(std::function<Callback> callback) const
 {
     return call_with_local_ref(JniUtils::get_env(), callback);
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
index 4e6c60df56..f21d640f0a 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
@@ -28,48 +28,30 @@ namespace jni_util {
 // RAII wrapper for weak global ref.
 class JavaGlobalWeakRef {
 public:
-    JavaGlobalWeakRef()
-        : m_weak(nullptr)
-    {
-    }
-    JavaGlobalWeakRef(JNIEnv* env, jobject obj)
-        : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr)
-    {
-    }
-    ~JavaGlobalWeakRef()
-    {
-        if (m_weak) {
-            JniUtils::get_env()->DeleteWeakGlobalRef(m_weak);
-        }
-    }
+    JavaGlobalWeakRef();
+    JavaGlobalWeakRef(JNIEnv*, jobject);
+    ~JavaGlobalWeakRef();
 
-    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs)
-        : m_weak(rhs.m_weak)
-    {
-        rhs.m_weak = nullptr;
-    }
-    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs)
-    {
-        this->~JavaGlobalWeakRef();
-        new (this) JavaGlobalWeakRef(std::move(rhs));
-        return *this;
-    }
+    JavaGlobalWeakRef(JavaGlobalWeakRef&&);
+    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&&);
 
-    JavaGlobalWeakRef(const JavaGlobalWeakRef&) = delete;
-    JavaGlobalWeakRef& operator=(const JavaGlobalWeakRef&) = delete;
+    JavaGlobalWeakRef(const JavaGlobalWeakRef&);
+    JavaGlobalWeakRef& operator=(const JavaGlobalWeakRef&);
 
     inline operator bool() const noexcept
     {
         return m_weak != nullptr;
     }
 
+    JavaGlobalRef global_ref(JNIEnv* env = nullptr) const;
+
     using Callback = void(JNIEnv* env, jobject obj);
 
     // Acquire a local ref and run the callback with it if the weak ref is valid. The local ref will be deleted after
     // callback finished. Return false if the weak ref is not valid anymore.
-    bool call_with_local_ref(JNIEnv* env, std::function<Callback> callback);
+    bool call_with_local_ref(JNIEnv* env, std::function<Callback> callback) const ;
     // Try to get an JNIEnv for current thread then run the callback.
-    bool call_with_local_ref(std::function<Callback> callback);
+    bool call_with_local_ref(std::function<Callback> callback) const;
 
 private:
     jweak m_weak;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index bd4c16656b..096b62620d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -146,6 +146,15 @@ OsRealmConfig build() {
     // core destructor's thread safety.
     private final NativeContext context = new NativeContext();
 
+    // Hold a ref to callbacks to make sure they won't be GCed before getting called.
+    // JNI should only hold a weak ref in the lambda functions.
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final CompactOnLaunchCallback compactOnLaunchCallback;
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final SharedRealm.MigrationCallback migrationCallback;
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final SharedRealm.InitializationCallback initializationCallback;
+
     private OsRealmConfig(final RealmConfiguration config,
                           boolean autoUpdateNotification,
                           @Nullable OsSchemaInfo schemaInfo,
@@ -187,15 +196,17 @@ private OsRealmConfig(final RealmConfiguration config,
         }
         final long schemaVersion = config.getSchemaVersion();
         final long nativeSchemaPtr = schemaInfo == null ? 0 : schemaInfo.getNativePtr();
+        this.migrationCallback = migrationCallback;
         nativeSetSchemaConfig(nativePtr, schemaMode.getNativeValue(), schemaVersion, nativeSchemaPtr, migrationCallback);
 
         // Compact on launch
-        CompactOnLaunchCallback compactOnLaunchCallback = config.getCompactOnLaunchCallback();
+        this.compactOnLaunchCallback = config.getCompactOnLaunchCallback();
         if (compactOnLaunchCallback != null) {
             nativeSetCompactOnLaunchCallback(nativePtr, compactOnLaunchCallback);
         }
 
         // Initial data transaction
+        this.initializationCallback = initializationCallback;
         if (initializationCallback != null) {
             nativeSetInitializationCallback(nativePtr, initializationCallback);
         }
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index 8905ec397c..18d2139081 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -7,26 +7,6 @@ const exec = require('child_process').exec;
 var http = require('http');
 var dispatcher = require('httpdispatcher');
 
-// this query is used to check if ROS has started
-// while waiting for a permanante fix in https://github.com/realm/realm-object-server/issues/1297.
-// query should return 200 with the JSON payload Ex: {"version":"1.8.1","flavor":"developer","setupRequired":true}
-var options = {
-  hostname: '127.0.0.1',
-  port: 9080,
-  path: '/api/info',
-  method: 'GET'
-};
-
-function tryUntilROSStart(options, callback) {
-    var req = http.request(options, function(res) {
-        callback(null, res);
-    });
-    req.on('error', function(e) {
-        tryUntilROSStart(options, callback);
-    });
-    req.end();
-}
-
 // Automatically track and cleanup files at exit
 temp.track();
 
@@ -54,6 +34,12 @@ function handleRequest(request, response) {
 var syncServerChildProcess = null;
 
 function startRealmObjectServer(done) {
+    // Hack for checking the ROS is fully initialized.
+    // Consider the ROS is initialized fully only if log below shows twice
+    // "client: Closing Realm file: /tmp/ros117521-7-1eiqt7a/internal_data/permission/__auth.realm"
+    // https://github.com/realm/realm-object-server/issues/1297
+    var logFindingCounter = 2
+
     stopRealmObjectServer(function(err) {
         if(err) {
           return;
@@ -70,6 +56,12 @@ function startRealmObjectServer(done) {
                         { env: env, cwd: path});
                 // local config:
                 syncServerChildProcess.stdout.on('data', (data) => {
+                    if (logFindingCounter != 0 && /client: Closing Realm file: .*__auth.realm/.test(data)) {
+                        if (logFindingCounter == 1) {
+                            done()
+                        }
+                        logFindingCounter--
+                    }
                     winston.info(`stdout: ${data}`);
                 });
 
@@ -80,11 +72,6 @@ function startRealmObjectServer(done) {
                 syncServerChildProcess.on('close', (code) => {
                     winston.info(`child process exited with code ${code}`);
                 });
-
-                tryUntilROSStart(options, function(err, resp) {
-                    winston.info('>>>>>>>>>>>>>>>>>>> [ROS] server started <<<<<<<<<<<<<<<<<<<');
-                    done()
-                });
             }
         });
     });
@@ -107,7 +94,7 @@ function stopRealmObjectServer(callback) {
 dispatcher.onGet("/start", function(req, res) {
     startRealmObjectServer(() => {
         res.writeHead(200, {'Content-Type': 'text/plain'});
-        res.end('Server started');
+        res.end('Starting a server');
     })
 });
 
