diff --git a/build-distribution.sh b/build-distribution.sh
index bc8c2aa27f..573061ad63 100755
--- a/build-distribution.sh
+++ b/build-distribution.sh
@@ -28,6 +28,9 @@ cp -R examples/migrationExample/src distribution/RealmMigrationExample/app
 echo "Copying files to the distribution/RealmConcurrencyExample folder"
 cp -R examples/concurrencyExample/src distribution/RealmConcurrencyExample/app
 
+echo "Copying files to the distribution/RealmAdapterExample folder"
+cp -R examples/adapterExample/src distribution/RealmAdapterExample/app
+
 echo "Creating the Eclipse distribution"
 mkdir -p distribution/eclipse
 cp realm/build/libs/realm-${version}.jar distribution/eclipse
diff --git a/changelog.txt b/changelog.txt
index 55e58868c4..618a70a1d1 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,3 +1,10 @@
+0.73.0 (04 Nov 2014)
+  * Fixed a bug not allowing queries with more than 1024 conditions
+  * Rewritten the notification system. The API did not change but it's now much more reliable
+  * Added support for switching auto-refresh on and off (Realm.setAutoRefresh)
+  * Added RealmBaseAdapter and an example using it
+  * Added deleteFromRealm() method to RealmObject
+
 0.72.0 (27 Oct 2014)
   * Extended sorting support to more types: boolean, byte, short, int, long, float, double, Date, and String
     fields are now supported
diff --git a/distribution/RealmAdapterExample/.gitignore b/distribution/RealmAdapterExample/.gitignore
new file mode 100644
index 0000000000..afbdab33e9
--- /dev/null
+++ b/distribution/RealmAdapterExample/.gitignore
@@ -0,0 +1,6 @@
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
diff --git a/distribution/RealmAdapterExample/app/.gitignore b/distribution/RealmAdapterExample/app/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/distribution/RealmAdapterExample/app/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/distribution/RealmAdapterExample/app/build.gradle b/distribution/RealmAdapterExample/app/build.gradle
new file mode 100644
index 0000000000..e75b49a3dd
--- /dev/null
+++ b/distribution/RealmAdapterExample/app/build.gradle
@@ -0,0 +1,24 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 20
+    buildToolsVersion "20.0.0"
+
+    defaultConfig {
+        applicationId "io.realm.examples.realmadapterexample"
+        minSdkVersion 14
+        targetSdkVersion 20
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            runProguard false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile 'io.realm:realm-android:0.71.0'
+}
\ No newline at end of file
diff --git a/distribution/RealmAdapterExample/app/proguard-rules.pro b/distribution/RealmAdapterExample/app/proguard-rules.pro
new file mode 100644
index 0000000000..bb65c6fe88
--- /dev/null
+++ b/distribution/RealmAdapterExample/app/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/distribution/RealmAdapterExample/build.gradle b/distribution/RealmAdapterExample/build.gradle
new file mode 100644
index 0000000000..9b8abe4fe1
--- /dev/null
+++ b/distribution/RealmAdapterExample/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.12.2'
+
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
diff --git a/distribution/RealmAdapterExample/gradle.properties b/distribution/RealmAdapterExample/gradle.properties
new file mode 100644
index 0000000000..5d08ba75bb
--- /dev/null
+++ b/distribution/RealmAdapterExample/gradle.properties
@@ -0,0 +1,18 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..1e61d1fd3a
--- /dev/null
+++ b/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip
diff --git a/distribution/RealmAdapterExample/gradlew b/distribution/RealmAdapterExample/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/distribution/RealmAdapterExample/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmAdapterExample/gradlew.bat b/distribution/RealmAdapterExample/gradlew.bat
new file mode 100644
index 0000000000..aec99730b4
--- /dev/null
+++ b/distribution/RealmAdapterExample/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/distribution/RealmAdapterExample/settings.gradle b/distribution/RealmAdapterExample/settings.gradle
new file mode 100644
index 0000000000..e7b4def49c
--- /dev/null
+++ b/distribution/RealmAdapterExample/settings.gradle
@@ -0,0 +1 @@
+include ':app'
diff --git a/examples/adapterExample/build.gradle b/examples/adapterExample/build.gradle
new file mode 100644
index 0000000000..809030ab41
--- /dev/null
+++ b/examples/adapterExample/build.gradle
@@ -0,0 +1,28 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+
+    defaultConfig {
+        applicationId "io.realm.examples.realmadapters"
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            runProguard false
+            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+tasks.preBuild {
+    dependsOn ":realm:androidJar"
+}
+
+dependencies {
+    compile files("../../realm/build/libs/realm-${version}.jar")
+}
diff --git a/examples/adapterExample/proguard-rules.pro b/examples/adapterExample/proguard-rules.pro
new file mode 100644
index 0000000000..200fdffd58
--- /dev/null
+++ b/examples/adapterExample/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/adapterExample/src/main/AndroidManifest.xml b/examples/adapterExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..9d18300d12
--- /dev/null
+++ b/examples/adapterExample/src/main/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.realmadapters">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+
+        <activity
+            android:name=".MyActivity"
+            android:configChanges="keyboardHidden|orientation|screenSize"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
+    </application>
+
+</manifest>
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyActivity.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyActivity.java
new file mode 100644
index 0000000000..234ce5d891
--- /dev/null
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyActivity.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.realmadapters;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.ListView;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.examples.realmadapters.models.TimeStamp;
+
+
+public class MyActivity extends Activity {
+
+    private Realm realm;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_my);
+
+        Realm.deleteRealmFile(this);
+        realm = Realm.getInstance(this);
+        RealmResults<TimeStamp> timeStamps = realm.where(TimeStamp.class).findAll();
+        final MyAdapter adapter = new MyAdapter(this, R.id.listView, timeStamps, true);
+        ListView listView = (ListView) findViewById(R.id.listView);
+        listView.setAdapter(adapter);
+        listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+            @Override
+            public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
+                    realm.beginTransaction();
+                    adapter.getRealmResults().remove(i);
+                    realm.commitTransaction();
+                    return true;
+            }
+        });
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.my, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        int id = item.getItemId();
+        if (id == R.id.action_add) {
+            realm.beginTransaction();
+            TimeStamp timeStamp = realm.createObject(TimeStamp.class);
+            timeStamp.setTimeStamp(Long.toString(System.currentTimeMillis()));
+            realm.commitTransaction();
+        }
+        return true;
+    }
+}
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
new file mode 100644
index 0000000000..d0280da205
--- /dev/null
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/MyAdapter.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.realmadapters;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ListAdapter;
+import android.widget.TextView;
+
+import io.realm.RealmBaseAdapter;
+import io.realm.RealmResults;
+import io.realm.examples.realmadapters.models.TimeStamp;
+
+public class MyAdapter extends RealmBaseAdapter<TimeStamp> implements ListAdapter {
+
+    private class MyViewHolder {
+        TextView tvTimeStamp;
+    }
+
+    public MyAdapter(Context context, int resId, RealmResults<TimeStamp> realmResults, boolean automaticUpdate) {
+        super(context, realmResults, automaticUpdate);
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        MyViewHolder mViewHolder;
+        if (convertView == null) {
+            convertView = inflater.inflate(android.R.layout.simple_list_item_1, null);
+            mViewHolder = new MyViewHolder();
+            convertView.setTag(mViewHolder);
+        } else {
+            mViewHolder = (MyViewHolder) convertView.getTag();
+        }
+
+        mViewHolder.tvTimeStamp = detail(convertView, android.R.id.text1, realmResults.get(position).getTimeStamp());
+        return convertView;
+    }
+
+    private TextView detail(View v, int resId, String text) {
+        TextView tv = (TextView) v.findViewById(resId);
+        tv.setText(text);
+        return tv;
+    }
+
+    public RealmResults<TimeStamp> getRealmResults() {
+        return realmResults;
+    }
+}
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/models/TimeStamp.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/models/TimeStamp.java
new file mode 100644
index 0000000000..8945954fa2
--- /dev/null
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/models/TimeStamp.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.examples.realmadapters.models;
+
+import io.realm.RealmObject;
+
+public class TimeStamp extends RealmObject {
+    private String timeStamp;
+
+    public String getTimeStamp() {
+        return timeStamp;
+    }
+
+    public void setTimeStamp(String timeStamp) {
+        this.timeStamp = timeStamp;
+    }
+}
diff --git a/examples/adapterExample/src/main/res/drawable-hdpi/ic_launcher.png b/examples/adapterExample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..96a442e5b8
Binary files /dev/null and b/examples/adapterExample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/examples/adapterExample/src/main/res/drawable-mdpi/ic_launcher.png b/examples/adapterExample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..359047dfa4
Binary files /dev/null and b/examples/adapterExample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/examples/adapterExample/src/main/res/drawable-xhdpi/ic_launcher.png b/examples/adapterExample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..71c6d760f0
Binary files /dev/null and b/examples/adapterExample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/examples/adapterExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/adapterExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..4df1894644
Binary files /dev/null and b/examples/adapterExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/adapterExample/src/main/res/layout/activity_my.xml b/examples/adapterExample/src/main/res/layout/activity_my.xml
new file mode 100644
index 0000000000..99c0048a9f
--- /dev/null
+++ b/examples/adapterExample/src/main/res/layout/activity_my.xml
@@ -0,0 +1,20 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    tools:context=".MyActivity">
+
+
+    <ListView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:id="@+id/listView"
+        android:layout_alignParentTop="true"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentStart="true"
+        tools:listitem="@android:layout/simple_list_item_1" />
+</RelativeLayout>
diff --git a/examples/adapterExample/src/main/res/menu/my.xml b/examples/adapterExample/src/main/res/menu/my.xml
new file mode 100644
index 0000000000..bd4fcccd3e
--- /dev/null
+++ b/examples/adapterExample/src/main/res/menu/my.xml
@@ -0,0 +1,8 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".MyActivity" >
+    <item android:id="@+id/action_add"
+        android:icon="@android:drawable/ic_menu_add"
+        android:title="@string/add"
+        android:showAsAction="always"/>
+</menu>
diff --git a/examples/adapterExample/src/main/res/values-w820dp/dimens.xml b/examples/adapterExample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/examples/adapterExample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/examples/adapterExample/src/main/res/values/dimens.xml b/examples/adapterExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/adapterExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/adapterExample/src/main/res/values/strings.xml b/examples/adapterExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..7814181fb1
--- /dev/null
+++ b/examples/adapterExample/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Realm ListView</string>
+    <string name="action_settings">Settings</string>
+    <string name="add">Add</string>
+
+</resources>
\ No newline at end of file
diff --git a/examples/adapterExample/src/main/res/values/styles.xml b/examples/adapterExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..ff6c9d2c0f
--- /dev/null
+++ b/examples/adapterExample/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/examples/concurrencyExample/src/main/AndroidManifest.xml b/examples/concurrencyExample/src/main/AndroidManifest.xml
index be2982ac29..427caed469 100644
--- a/examples/concurrencyExample/src/main/AndroidManifest.xml
+++ b/examples/concurrencyExample/src/main/AndroidManifest.xml
@@ -7,6 +7,7 @@
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
+
         <activity
             android:name=".RealmExampleActivity"
             android:configChanges="keyboardHidden|orientation|screenSize"
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
index 224eaa0ca6..4463fac639 100644
--- a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
@@ -37,7 +37,7 @@
     @SuppressWarnings("UnusedDeclaration")
     public static final String TAG = RealmExampleActivity.class.getName();
 
-    private Realm realm = null;
+    private Realm realm;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -48,7 +48,7 @@ protected void onCreate(Bundle savedInstanceState) {
         findViewById(R.id.quit_button).setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
-                stopTransactionTests();
+                stopTests();
             }
         });
 
@@ -62,21 +62,25 @@ public void onClick(View view) {
     @Override
     public void onResume() {
         super.onResume();
-
-	//Alternatively can use transaction tests here...
-        //startTransactionTests();
-
-        startSpawnTests();
+        startTests();
     }
 
     @Override
     public void onStop() {
         super.onStop();
+        stopTests();
+    }
 
-	//Alternatively can use transaction tests here...
-        //stopTransactionTests();
+    private void startTests() {
+        startSpawnTests();
+        //Alternatively can use transaction tests here...
+        //startTransactionTests();
+    }
 
+    private void stopTests() {
         stopSpawnTests();
+        //Alternatively can use transaction tests here...
+        //stopTransactionTests();
     }
 
     // Using the screen form the user can inject into the Realm
@@ -87,12 +91,12 @@ public void onClick(View v) {
         String personAge = ((TextView) findViewById(R.id.age)).getText().toString();
         String petName = ((TextView) findViewById(R.id.pets_name)).getText().toString();
 
-        Integer parseAge = 0;
+        Integer parseAge;
         try {
             parseAge = Integer.parseInt(personAge);
         } catch (NumberFormatException ignored) {
-	        Log.d(TAG, "Age for a person invalid");
-	        return;
+            Log.d(TAG, "Age for a person invalid");
+            return;
         }
 
         realm.beginTransaction();
@@ -135,8 +139,8 @@ private void stopTransactionTests() {
     // which loop for a specified count
     private void startSpawnTests() {
         Intent serviceIntent = new Intent(this, SpawningService.class);
-        serviceIntent.putExtra(SpawningService.REALM_INSERTCOUNT_EXTRA, 10000000);
-        serviceIntent.putExtra(SpawningService.REALM_READCOUNT_EXTRA, 10000000);
+        serviceIntent.putExtra(SpawningService.REALM_INSERT_COUNT_EXTRA, 10000000);
+        serviceIntent.putExtra(SpawningService.REALM_READ_COUNT_EXTRA, 10000000);
         this.startService(serviceIntent);
     }
 
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java
index 8d502ce5d3..7acadcfcef 100644
--- a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java
@@ -19,6 +19,7 @@
 import android.app.Service;
 import android.content.Intent;
 import android.os.IBinder;
+import android.util.Log;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -30,39 +31,38 @@
 public class SpawningService extends Service {
 
     public static final String TAG = SpawningService.class.getName();
+    public static final String REALM_INSERT_COUNT_EXTRA = "RealmInsertCountExtra";
+    public static final String REALM_READ_COUNT_EXTRA = "RealmReadCountExtra";
 
-    public static final String REALM_INSERTCOUNT_EXTRA = "RealmInsertCountExtra";
-    public static final String REALM_READCOUNT_EXTRA   = "RealmReadCountExtra";
-
-    private List<KillableThread> allThreads = null;
-
-    public void onCreate() {
-        super.onCreate();
-    }
+    private List<KillableThread> allThreads = new ArrayList<KillableThread>();
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
+        if (intent == null) {
+            Log.i(TAG, "The intent is null");
+            throw new AssertionError();
+        }
 
-        int insertCount = intent.getIntExtra(REALM_INSERTCOUNT_EXTRA, 0);
-        int readCount   = intent.getIntExtra(REALM_READCOUNT_EXTRA, 0);
+        int insertCount = intent.getIntExtra(REALM_INSERT_COUNT_EXTRA, 0);
+        int readCount   = intent.getIntExtra(REALM_READ_COUNT_EXTRA, 0);
 
         try {
-            allThreads = new ArrayList<KillableThread>();
-            RealmWriter wT = new RealmWriter(this);
-            wT.setInsertCount(insertCount);
-            allThreads.add(wT);
-            wT.start();
-            RealmReader rT = new RealmReader(this);
-            rT.setReadCount(readCount);
-            allThreads.add(rT);
-            rT.start();
+            RealmWriter writerThread = new RealmWriter(this);
+            writerThread.setInsertCount(insertCount);
+            allThreads.add(writerThread);
+            writerThread.start();
+
+            RealmReader readerThread = new RealmReader(this);
+            readerThread.setReadCount(readCount);
+            allThreads.add(readerThread);
+            readerThread.start();
         } catch (Exception e) {
             e.printStackTrace();
             quit();
         }
 
         //Service should stay active as long as Activity is active
-        return START_STICKY;
+        return START_STICKY_COMPATIBILITY;
     }
 
     @Override
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java
index bca153d4f8..1b2776772d 100644
--- a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java
@@ -23,7 +23,7 @@
 import io.realm.Realm;
 import io.realm.examples.concurrency.model.Person;
 
-// Note that an IntentService operates in its own threadpool facilitated by Android
+// Note that an IntentService operates in its own thread-pool facilitated by Android
 public class TransactionService extends IntentService {
 
     public static final String TAG = TransactionService.class.getName();
@@ -43,7 +43,7 @@
     private Realm realm = null;
 
     public TransactionService() {
-        super(SpawningService.class.getName());
+        super(TransactionService.class.getName());
     }
 
     @Override
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java
index 9f7e738d05..882a4d7748 100644
--- a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java
@@ -17,45 +17,57 @@
 package io.realm.examples.concurrency.threads;
 
 import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
 import android.util.Log;
 
 import io.realm.Realm;
+import io.realm.RealmChangeListener;
 import io.realm.examples.concurrency.model.Person;
 
 public class RealmReader extends Thread implements KillableThread {
 
     public static final String TAG = RealmReader.class.getName();
+    private static final int KILL = 672783478;
 
-    private Context context = null;
-
-    private boolean mRunning = true;
-
+    private Context context;
     private int mReadCount = 0;
+    private Handler handler;
 
     public RealmReader(Context context) {
         this.context = context;
     }
 
     public void run() {
-        Realm realm = Realm.getInstance(context);
+        Looper.prepare();
+        final Realm realm = Realm.getInstance(context, true);
 
-        int loopCount = 0;
+        realm.addChangeListener(new RealmChangeListener() {
 
-        while (loopCount < mReadCount && mRunning) {
-            Person person = realm.where(Person.class)
-                    .beginsWith("name", "Foo")
-                    .between("age", 20, 50).findFirst();
-
-            if (loopCount % 1000 == 0) {
-                Log.d(TAG, "Found: " + person);
+            @Override
+            public void onChange() {
+                long peopleNumber = realm.where(Person.class).count();
+                if (peopleNumber % 10 == 0) {
+                    Log.d(TAG, "Found count " + peopleNumber);
+                }
+            }
+        });
+        
+        handler = new Handler() {
+            @Override
+            public void handleMessage(Message msg) {
+                if (msg.what == KILL) {
+                    Looper.myLooper().quit();
+                }
             }
-            loopCount++;
-        }
+        };
+        Looper.loop();
     }
 
     @Override
     public void terminate() {
-        mRunning = false;
+        handler.sendEmptyMessage(KILL);
     }
 
     @SuppressWarnings("UnusedDeclaration")
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java
index 53d7113a6a..9ecb448368 100644
--- a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java
@@ -27,10 +27,8 @@
 
     public static final String TAG = RealmWriter.class.getName();
 
-    private Context context = null;
-
+    private Context context;
     private boolean mRunning = true;
-
     private int mInsertCount = 0;
 
     public RealmWriter(Context context) {
@@ -38,29 +36,29 @@ public RealmWriter(Context context) {
     }
 
     public void run() {
-        Realm realm = Realm.getInstance(context);
+        Realm realm = Realm.getInstance(context, false);
 
-        int iterCount = 0;
+        int count = 0;
 
-        while (iterCount < mInsertCount && mRunning) {
+        while (count < mInsertCount && mRunning) {
             realm.beginTransaction();
 
             Person person = realm.createObject(Person.class);
-            person.setName("Foo" + iterCount);
-            person.setAge(iterCount % 20 + (50 - 20));
+            person.setName("Foo" + count);
+            person.setAge(count % 20 + (50 - 20));
 
             //Add a dog to every 50th person
-            if (iterCount % 50 == 0) {
+            if (count % 50 == 0) {
                 Dog dog = realm.createObject(Dog.class);
-                dog.setName("Foo" + iterCount + "Fido");
+                dog.setName("Foo" + count + "Fido");
                 person.setDog(dog);
             }
 
-            iterCount++;
+            count++;
             realm.commitTransaction();
 
-            if ((iterCount % 1000) == 0) {
-                Log.d(TAG, "WriteOperation#: " + iterCount + "," + Thread.currentThread().getName());
+            if ((count % 1000) == 0) {
+                Log.d(TAG, "WriteOperation#: " + count + "," + Thread.currentThread().getName());
             }
         }
     }
diff --git a/examples/concurrencyExample/src/main/res/layout/activity_realm_resultsexample.xml b/examples/concurrencyExample/src/main/res/layout/activity_realm_resultsexample.xml
new file mode 100644
index 0000000000..9192dc0ac9
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/layout/activity_realm_resultsexample.xml
@@ -0,0 +1,110 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:layout_margin="15dp"
+    android:orientation="vertical">
+
+    <LinearLayout
+        android:id="@+id/header"
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <TextView
+            android:id="@+id/update_message"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_margin="25dp"
+            android:gravity="center"
+            android:text="In the background there is a loop creating records."
+            android:textSize="24sp" />
+        <Button
+            android:id="@+id/quit_button"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="Stop Background Loop" />
+    </LinearLayout>
+    <LinearLayout
+        android:id="@+id/form"
+        android:layout_below="@id/header"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:background="#ff1144aa"
+        android:orientation="vertical"
+        android:padding="20dp">
+
+        <TextView android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_margin="7dp"
+            android:gravity="center"
+            android:text="You can also create records manually..."
+            android:textSize="22sp" />
+
+        <TextView android:id="@+id/message_timestamp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center_horizontal"
+            android:text="Create a Record:"
+            android:textColor="#ffafafaf"
+            android:textSize="22sp" />
+
+        <View android:layout_width="match_parent"
+            android:layout_height="1dp"
+            android:layout_margin="12dp"
+            android:background="#ffcfcfcf" />
+
+        <EditText android:id="@+id/name"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:hint="Enter Person's Name" />
+
+        <EditText android:id="@+id/age"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:hint="Enter Person's Age" />
+
+        <RadioGroup android:id="@+id/petType"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content">
+
+            <RadioButton android:id="@+id/hasCat"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Cat" />
+
+            <RadioButton android:id="@+id/hasDog"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="Dog" />
+        </RadioGroup>
+
+        <EditText android:id="@+id/pets_name"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:hint="Enter Pets Name" />
+
+        <Button android:id="@+id/insert_record_button"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="Create Record" />
+
+    </LinearLayout>
+    <LinearLayout
+        android:id="@+id/footer"
+        android:orientation="vertical"
+        android:layout_below="@id/form"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <TextView
+            android:id="@+id/size_status"
+            android:textSize="24sp"
+            android:textColor="@android:color/black"
+            android:background="@android:color/darker_gray"
+            android:layout_width="match_parent"
+            android:layout_height="40dp" />
+        <ListView
+            android:id="@+id/items_list"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+    </LinearLayout>
+</RelativeLayout>
+
diff --git a/examples/concurrencyExample/src/main/res/layout/simplelistitem.xml b/examples/concurrencyExample/src/main/res/layout/simplelistitem.xml
new file mode 100644
index 0000000000..9a63c4ce67
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/layout/simplelistitem.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/field1"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content" />
\ No newline at end of file
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/RealmIntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/RealmIntroExampleActivity.java
index b0b87fe4de..105d818ced 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/RealmIntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/RealmIntroExampleActivity.java
@@ -107,7 +107,7 @@ private String complexReadWrite() {
 
         // Open the default realm. All threads must use it's own reference to the realm.
         // Those can not be transferred across threads.
-        Realm realm = Realm.getInstance(this);
+        Realm realm = Realm.getInstance(this, false);
 
         // Add ten persons in one write transaction
         realm.beginTransaction();
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 0e15569362..bb6f25f438 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -253,7 +253,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 String getterPrefix = fieldTypeCanonicalName.equals("boolean")?"is":"get";
                 writer.beginMethod(fieldTypeCanonicalName, getterPrefix + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                 writer.emitStatement(
-                        "return (%s) realmGetRow().get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
+                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
                         fieldTypeCanonicalName, realmType, className, fieldName);
                 writer.endMethod();
                 writer.emitEmptyLine();
@@ -262,7 +262,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 writer.emitAnnotation("Override");
                 writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                 writer.emitStatement(
-                        "realmGetRow().set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
+                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
                         realmType, className, fieldName, castingType);
                 writer.endMethod();
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
@@ -273,11 +273,11 @@ public void generate() throws IOException, UnsupportedOperationException {
                 // Getter
                 writer.emitAnnotation("Override");
                 writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.beginControlFlow("if (realmGetRow().isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
+                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
                 writer.emitStatement("return null");
                 writer.endControlFlow();
                 writer.emitStatement(
-                        "return realm.get(%s.class, realmGetRow().getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
+                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
                         fieldTypeCanonicalName, className, fieldName);
                 writer.endMethod();
                 writer.emitEmptyLine();
@@ -286,9 +286,9 @@ public void generate() throws IOException, UnsupportedOperationException {
                 writer.emitAnnotation("Override");
                 writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                 writer.beginControlFlow("if (value == null)");
-                writer.emitStatement("realmGetRow().nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
+                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                 writer.endControlFlow();
-                writer.emitStatement("realmGetRow().setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.realmGetRow().getIndex())", className, fieldName);
+                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
                 writer.endMethod();
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 /**
@@ -306,7 +306,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 writer.emitAnnotation("Override");
                 writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                 writer.emitStatement(
-                        "return new RealmList(%s.class, realmGetRow().getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
+                        "return new RealmList(%s.class, row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
                         genericType, className, fieldName);
                 writer.endMethod();
                 writer.emitEmptyLine();
@@ -314,12 +314,12 @@ public void generate() throws IOException, UnsupportedOperationException {
                 // Setter
                 writer.emitAnnotation("Override");
                 writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("LinkView links = realmGetRow().getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
+                writer.emitStatement("LinkView links = row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                 writer.beginControlFlow("if (value == null)");
                 writer.emitStatement("return"); // TODO: delete all the links instead
                 writer.endControlFlow();
                 writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
-                writer.emitStatement("links.add(linkedObject.realmGetRow().getIndex())");
+                writer.emitStatement("links.add(linkedObject.row.getIndex())");
                 writer.endControlFlow();
                 writer.endMethod();
             } else {
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
index 6eb88f9d86..b0c2a5cfcb 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
@@ -29,7 +29,7 @@
     public static final String REALM_ANDROID_DOWNLOAD_URL = "http://static.realm.io/downloads/java/latest";
 
     private static final String VERSION_URL = "http://static.realm.io/update/java?";
-    private static final String REALM_VERSION = "0.72.0"; //TODO: The version value should be pulled from a build file
+    private static final String REALM_VERSION = "0.73.0"; //TODO: The version value should be pulled from a build file
     private static final int READ_TIMEOUT = 2000;
     private static final int CONNECT_TIMEOUT = 4000;
 
diff --git a/realm-jni/src/io_realm_internal_Row.cpp b/realm-jni/src/io_realm_internal_Row.cpp
index e7fcfe4f4b..b060ba409f 100644
--- a/realm-jni/src/io_realm_internal_Row.cpp
+++ b/realm-jni/src/io_realm_internal_Row.cpp
@@ -32,7 +32,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetColumnName
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex))
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
         return NULL;
     try {
         return to_jstring(env, ROW(nativeRowPtr)->get_column_name( S(columnIndex)));
@@ -55,7 +55,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
 JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetColumnType
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex))
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
         return 0;
 
     return static_cast<jint>( ROW(nativeRowPtr)->get_column_type( S(columnIndex)) ); // noexcept
@@ -64,7 +64,7 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetColumnType
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
-    if (!TABLE_VALID(env, ROW(nativeRowPtr)->get_table()))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->get_index();
@@ -73,7 +73,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Int))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
         return 0;
 
     return ROW(nativeRowPtr)->get_int( S(columnIndex) );
@@ -82,7 +82,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLong
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeGetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Bool))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
         return 0;
 
     return ROW(nativeRowPtr)->get_bool( S(columnIndex) );
@@ -91,7 +91,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeGetBoolean
 JNIEXPORT jfloat JNICALL Java_io_realm_internal_Row_nativeGetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Float))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
         return 0;
 
     return ROW(nativeRowPtr)->get_float( S(columnIndex) );
@@ -100,7 +100,7 @@ JNIEXPORT jfloat JNICALL Java_io_realm_internal_Row_nativeGetFloat
 JNIEXPORT jdouble JNICALL Java_io_realm_internal_Row_nativeGetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Double))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
         return 0;
 
     return ROW(nativeRowPtr)->get_double( S(columnIndex) );
@@ -109,7 +109,7 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Row_nativeGetDouble
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetDateTime
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_DateTime))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
         return 0;
 
     return ROW(nativeRowPtr)->get_datetime( S(columnIndex) ).get_datetime();
@@ -118,7 +118,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetDateTime
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_String))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
         return 0;
 
     try {
@@ -130,7 +130,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Binary))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
         return 0;
 
     BinaryData bin = ROW(nativeRowPtr)->get_binary( S(columnIndex) );
@@ -149,7 +149,7 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
 JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetMixedType
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Mixed))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
         return 0;
 
     DataType mixedType = ROW(nativeRowPtr)->get_mixed_type( S(columnIndex) );  // noexcept
@@ -159,7 +159,7 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetMixedType
 JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Mixed))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
         return NULL;
 
     Mixed value = ROW(nativeRowPtr)->get_mixed( S(columnIndex) );  // noexcept
@@ -172,7 +172,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
         return 0;
     if (ROW(nativeRowPtr)->is_null_link( S(columnIndex) )) {
         return jlong(-1);
@@ -183,7 +183,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLink
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsNullLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
         return 0;
 
     return ROW(nativeRowPtr)->is_null_link( S(columnIndex) );
@@ -192,7 +192,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsNullLink
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLinkView
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_LinkList))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
         return 0;
 
     LinkView* link_view_ptr = LangBindHelper::get_linklist_ptr( *ROW( nativeRowPtr ), S( columnIndex) );
@@ -202,7 +202,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLinkView
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Int))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
         return;
 
     try {
@@ -213,7 +213,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jboolean value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Bool))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
         return;
 
     try {
@@ -224,7 +224,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jfloat value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Float))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
         return;
 
     try {
@@ -235,7 +235,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jdouble value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Double))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
         return;
 
     try {
@@ -246,7 +246,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    if(!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_DateTime))
+    if(!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
         return;
 
     try {
@@ -257,7 +257,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jstring value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_String))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
         return;
 
     try {
@@ -269,7 +269,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Binary))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
         return;
 
     jbyte* bytePtr = env->GetByteArrayElements(value, NULL);
@@ -285,7 +285,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetMixed
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Mixed))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
         return;
     try {
         row_nativeSetMixed(ROW(nativeRowPtr), env, columnIndex, jMixedValue);
@@ -295,7 +295,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetMixed
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
         return;
 
     try {
@@ -306,7 +306,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
 JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeNullifyLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr)->get_table(), columnIndex, type_Link))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
         return;
 
     try {
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
index a1f8f02f20..4915ed8070 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -65,16 +65,13 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
 
 
 // helper functions and macros
-
 #define GET_ARRAY() \
-    jboolean isCopy; \
     jsize arr_len = env->GetArrayLength(columnIndexes); \
-    jlong *arr = env->GetLongArrayElements(columnIndexes, &isCopy);
+    jlong *arr = env->GetLongArrayElements(columnIndexes, NULL);
 
 
-#define RELEASE_ARRAY()     \
-    if (isCopy == JNI_TRUE) \
-        env->ReleaseLongArrayElements(columnIndexes, arr, 0);
+#define RELEASE_ARRAY() \
+    env->ReleaseLongArrayElements(columnIndexes, arr, 0);
 
 TableRef getTableLink(jlong nativeQueryPtr, jlong *arr, jsize arr_len) {
     TableRef tbl = Q(nativeQueryPtr)->get_table();
diff --git a/realm-jni/src/io_realm_internal_Util.cpp b/realm-jni/src/io_realm_internal_Util.cpp
index 67b294485b..fef8f636c7 100644
--- a/realm-jni/src/io_realm_internal_Util.cpp
+++ b/realm-jni/src/io_realm_internal_Util.cpp
@@ -116,6 +116,11 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
             if (dotest)
                 ThrowException(env, RuntimeError, "parm1", "parm2");
             break;
+        case RowInvalid:
+            expect = "java.lang.IllegalStateException: Illegal State: parm1";
+            if (dotest)
+                ThrowException(env, TableInvalid, "parm1", "parm2");
+            break;
     }
     if (dotest) {
         return NULL;
diff --git a/realm-jni/src/io_realm_internal_tableview.cpp b/realm-jni/src/io_realm_internal_tableview.cpp
index e633cae281..2ac2e128b8 100644
--- a/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm-jni/src/io_realm_internal_tableview.cpp
@@ -729,9 +729,8 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageInt(
         !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
         return 0;
 
-    // FIXME: Add support for native Average
     try {
-        return static_cast<jdouble>( TV(nativeViewPtr)->sum_int( S(columnIndex)) ) / TV(nativeViewPtr)->size();
+        return static_cast<jdouble>( TV(nativeViewPtr)->average_int( S(columnIndex)));
     } CATCH_STD()
     return 0;
 }
@@ -788,9 +787,8 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageFloat(
         !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
         return 0;
 
-    // FIXME: Add support for native Average
     try {
-        return TV(nativeViewPtr)->sum_float( S(columnIndex)) / TV(nativeViewPtr)->size();
+        return TV(nativeViewPtr)->average_float( S(columnIndex));
     } CATCH_STD()
     return 0;
 }
@@ -847,9 +845,8 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble(
         !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
         return 0;
 
-    // FIXME: Add support for native Average
     try {
-        return static_cast<jdouble>( TV(nativeViewPtr)->sum_double( S(columnIndex)) ) / TV(nativeViewPtr)->size();
+        return static_cast<jdouble>( TV(nativeViewPtr)->average_double( S(columnIndex)) );
     } CATCH_STD()
     return 0;
 }
diff --git a/realm-jni/src/util.cpp b/realm-jni/src/util.cpp
index bdc5cc3da2..0340f34dfe 100644
--- a/realm-jni/src/util.cpp
+++ b/realm-jni/src/util.cpp
@@ -100,6 +100,11 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, std::string classStr,
             jExceptionClass = env->FindClass("java/lang/RuntimeException");
             message = classStr;
             break;
+
+        case RowInvalid:
+            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
+            message = "Illegal State: " + classStr;
+            break;
     }
     if (jExceptionClass != NULL)
         env->ThrowNew(jExceptionClass, message.c_str());
diff --git a/realm-jni/src/util.hpp b/realm-jni/src/util.hpp
index 994bd8a51e..67eec99cb0 100644
--- a/realm-jni/src/util.hpp
+++ b/realm-jni/src/util.hpp
@@ -114,7 +114,8 @@ enum ExceptionKind {
     UnsupportedOperation = 9,
     OutOfMemory = 10,
     Unspecified = 11,
-    RuntimeError = 12
+    RuntimeError = 12,
+    RowInvalid = 13
 };
 
 extern void ThrowException(JNIEnv* env, ExceptionKind exception, std::string classStr, std::string itemStr = "");
@@ -143,6 +144,7 @@ extern void jprint(JNIEnv *env, char *txt);
 // Check parameters
 
 #define TABLE_VALID(env,ptr)    TableIsValid(env, ptr)
+#define ROW_VALID(env,ptr)      RowIsValid(env, ptr)
 
 #if CHECK_PARAMETERS
 
@@ -163,6 +165,9 @@ extern void jprint(JNIEnv *env, char *txt);
 #define TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type) TblIndexAndTypeValid(env, ptr, col, row, type, true)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) TblIndexAndTypeInsertValid(env, ptr, col, row, type)
 
+#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     RowColIndexAndTypeValid(env, ptr, col, type)
+#define ROW_AND_COL_INDEX_VALID(env,ptr,col)                    RowColIndexValid(env, ptr, col)
+
 #else
 
 #define ROW_INDEXES_VALID(env,ptr,start,end, range)             (true)
@@ -182,6 +187,9 @@ extern void jprint(JNIEnv *env, char *txt);
 #define TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type) (true)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) (true)
 
+#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
+#define ROW_AND_COL_INDEX_VALID(env,ptr,col)                    (true)
+
 #endif
 
 
@@ -203,7 +211,17 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
     }
     if (!valid) {
         TR_ERR((env, "Table %x is no longer attached!", objPtr));
-        ThrowException(env, TableInvalid, "Table is closed, and no longer valid to operate on.");
+        ThrowException(env, TableInvalid, "Table is no longer valid to operate on.");
+    }
+    return valid;
+}
+
+inline bool RowIsValid(JNIEnv* env, Row* rowPtr)
+{
+    bool valid = (rowPtr != NULL && rowPtr->is_attached());
+    if (!valid) {
+        TR_ERR((env, "Row %x is no longer attached!", rowPtr));
+        ThrowException(env, RowInvalid, "Row/Object is no longer valid to operate on. Was it deleted?");
     }
     return valid;
 }
@@ -299,6 +317,11 @@ inline bool TblColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
     return ColIndexValid(env, pTable, columnIndex);
 }
 
+inline bool RowColIndexValid(JNIEnv* env, Row* pRow, jlong columnIndex)
+{
+    return RowIsValid(env, pRow) && ColIndexValid(env, pRow->get_table(), columnIndex);
+}
+
 template <class T>
 inline bool IndexValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex)
 {
@@ -360,6 +383,12 @@ inline bool TblColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, i
         && ColIndexAndTypeValid(env, pTable, columnIndex, expectColType);
 }
 
+inline bool RowColIndexAndTypeValid(JNIEnv* env, Row* pRow, jlong columnIndex, int expectColType)
+{
+    return RowIsValid(env, pRow)
+        && ColIndexAndTypeValid(env, pRow->get_table(), columnIndex, expectColType);
+}
+
 
 template <class T>
 inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
diff --git a/realm/build.gradle b/realm/build.gradle
index 974787ed81..35c3779d1f 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -26,6 +26,7 @@ android {
 
 }
 dependencies {
+    compile 'com.intellij:annotations:+@jar'
     androidTestApt files("../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
 }
 
diff --git a/realm/src/androidTest/java/io/realm/NotificationsTest.java b/realm/src/androidTest/java/io/realm/NotificationsTest.java
index 6436da1ba5..31b68503f3 100644
--- a/realm/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/src/androidTest/java/io/realm/NotificationsTest.java
@@ -15,56 +15,192 @@
  */
 package io.realm;
 
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
 import android.test.AndroidTestCase;
-import android.util.Log;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.Dog;
-import io.realm.internal.android.LooperThread;
 
 public class NotificationsTest extends AndroidTestCase {
-    public void testMessageToDeadThread() {
-        Realm realm = Realm.getInstance(getContext());
+    public void testFailureOnNonLooperThread() {
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                try {
+                    @SuppressWarnings("UnusedDeclaration") Realm realm = Realm.getInstance(getContext());
+                    fail("The Realm instantiations should have thrown an exception");
+                } catch (IllegalStateException ignored) {}
+            }
+        };
+        thread.start();
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail();
+        }
+    }
 
-        // Number of handlers before
-        final int handlersBefore = LooperThread.handlers.size();
+    public void testNotifications() {
+        final AtomicBoolean changed = new AtomicBoolean(false);
 
-        // Make sure the Looper Thread is alive
-        LooperThread looperThread = LooperThread.getInstance();
-        assertTrue(looperThread.isAlive());
+        Thread listenerThread = new Thread() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(getContext());
+                realm.addChangeListener(new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        changed.set(true);
+                        Looper.myLooper().quit();
+                    }
+                });
+                Looper.loop();
+            }
+        };
+        listenerThread.start();
 
-        Thread thread = new Thread() {
+        Thread writerThread = new Thread() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(getContext(), false);
+                realm.beginTransaction();
+                Dog dog = realm.createObject(Dog.class);
+                dog.setName("Rex");
+                realm.commitTransaction();
+            }
+        };
+        writerThread.start();
+
+        try {
+            writerThread.join();
+            listenerThread.join(2000);
+        } catch (InterruptedException e) {
+            fail();
+        }
+
+        assertEquals(true, changed.get());
+    }
+
+    public void testNotificationsPlusSelfReceive() {
+        final AtomicInteger counter = new AtomicInteger(0);
+        final Queue<Handler> handlers = new ConcurrentLinkedQueue<Handler>();
+
+        Thread listenerThread = new Thread() {
             @Override
             public void run() {
-                Realm r = Realm.getInstance(getContext());
-                assertFalse(handlersBefore == LooperThread.handlers.size());
-                r.addChangeListener(new RealmChangeListener() {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(getContext());
+                realm.addChangeListener(new RealmChangeListener() {
                     @Override
                     public void onChange() {
-                        Log.i("Notification Test", "Notification Received");
+                        counter.incrementAndGet();
+                        Looper.myLooper().quit();
                     }
                 });
+                Looper.loop();
             }
         };
-        thread.start();
+        listenerThread.start();
+
+        Thread writerThread = new Thread() {
+
+            @Override
+            public void run() {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(getContext());
+                realm.addChangeListener(new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        counter.incrementAndGet();
+                    }
+                });
+                Handler handler = new Handler();
+                handlers.add(handler);
+                Looper.loop();
+            }
+        };
+        writerThread.start();
+        while (handlers.isEmpty()) {
+            try {
+                Thread.sleep(10);
+            } catch (InterruptedException e) {
+                fail();
+            }
+        }
+        Handler handler = handlers.poll();
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(getContext());
+                realm.beginTransaction();
+                Dog dog = realm.createObject(Dog.class);
+                dog.setName("Rex");
+                realm.commitTransaction();
+                Looper.myLooper().quit();
+            }
+        });
 
         try {
-            thread.join();
+            writerThread.join();
+            listenerThread.join(2000);
         } catch (InterruptedException e) {
             fail();
         }
-        assertFalse(thread.isAlive()); // Make sure the thread is dead
-        realm.beginTransaction();
-        Dog dog = realm.createObject(Dog.class);
-        dog.setName("Rex");
-        realm.commitTransaction();
 
-        // Give some time to log the exception
+        assertEquals(2, counter.get());
+    }
+
+    public void testFailingSetAutoRefreshOnNonLooperThread() {
+        final AtomicBoolean done = new AtomicBoolean(false);
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(getContext(), false);
+                boolean autoRefresh = realm.isAutoRefresh();
+                assertFalse(autoRefresh);
+                try {
+                    realm.setAutoRefresh(true);
+                    fail();
+                } catch (IllegalStateException ignored) {}
+                done.set(true);
+            }
+        };
+        thread.start();
         try {
-            Thread.sleep(500);
+            thread.join(1000);
         } catch (InterruptedException e) {
             fail();
         }
+        assertTrue(done.get());
+    }
 
-        assertEquals(0, looperThread.exceptions.size());
+    public void testSetAutoRefreshOnHandlerThread() {
+        final AtomicBoolean done = new AtomicBoolean(false);
+        HandlerThread thread = new HandlerThread("TestThread") {
+            @Override
+            protected void onLooperPrepared() {
+                Realm realm = Realm.getInstance(getContext());
+                assertTrue(realm.isAutoRefresh());
+                realm.setAutoRefresh(false);
+                assertFalse(realm.isAutoRefresh());
+                realm.setAutoRefresh(true);
+                assertTrue(realm.isAutoRefresh());
+                done.set(true);
+            }
+        };
+        thread.start();
+        try {
+            thread.join(1000);
+        } catch (InterruptedException e) {
+            fail();
+        }
+        assertTrue(done.get());
     }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmObjectTest.java b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
index 221f81c732..bd3279ea94 100644
--- a/realm/src/androidTest/java/io/realm/RealmObjectTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
@@ -19,6 +19,7 @@
 import android.test.AndroidTestCase;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
 import io.realm.internal.Row;
 
 
@@ -41,7 +42,7 @@ public void testRealmGetRowReturnsValidRow() {
         testRealm.beginTransaction();
         RealmObject realmObject = testRealm.createObject(AllTypes.class);
 
-        Row row = realmObject.realmGetRow();
+        Row row = realmObject.row;
 
         testRealm.commitTransaction();
         assertNotNull("RealmObject.realmGetRow returns zero ", row);
@@ -69,4 +70,30 @@ public void testStringEncoding() {
             i++;
         }
     }
+
+    public void testRemoveFromRealm() {
+        Realm realm = Realm.getInstance(getContext());
+        realm.beginTransaction();
+        Dog rex = realm.createObject(Dog.class);
+        rex.setName("Rex");
+        Dog fido = realm.createObject(Dog.class);
+        fido.setName("Fido");
+        realm.commitTransaction();
+
+        RealmResults<Dog> allDogsBefore = realm.where(Dog.class).equalTo("name", "Rex").findAll();
+        assertEquals(1, allDogsBefore.size());
+
+        realm.beginTransaction();
+        rex.removeFromRealm();
+        realm.commitTransaction();
+
+        RealmResults<Dog> allDogsAfter = realm.where(Dog.class).equalTo("name", "Rex").findAll();
+        assertEquals(0  , allDogsAfter.size());
+
+        fido.getName();
+        try {
+            rex.getName();
+            fail();
+        } catch (IllegalStateException ignored) {}
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsTest.java b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
index 1762f788e7..445a33aafc 100644
--- a/realm/src/androidTest/java/io/realm/RealmResultsTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
@@ -23,10 +23,11 @@
 import io.realm.entities.AllTypes;
 
 public class RealmResultsTest extends AndroidTestCase {
+    protected final static int TEST_DATA_SIZE = 2516;
+    protected final static int TEST_DATA_FIRST_HALF = 2*(TEST_DATA_SIZE/4)-1;
+    protected final static int TEST_DATA_LAST_HALF = 2*(TEST_DATA_SIZE/4)+1;
 
 
-    protected final static int TEST_DATA_SIZE = 516;
-
     protected Realm testRealm;
 
     private final static String FIELD_STRING = "columnString";
@@ -40,16 +41,17 @@
 
     @Override
     protected void setUp() throws InterruptedException {
-        Realm.deleteRealmFile(getContext());
+        boolean result = Realm.deleteRealmFile(getContext());
+        assertTrue(result);
+
         testRealm = Realm.getInstance(getContext());
 
         testRealm.beginTransaction();
-
         testRealm.allObjects(AllTypes.class).clear();
 
         for (int i = 0; i < TEST_DATA_SIZE; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnBoolean((i % 3) == 0);
+            allTypes.setColumnBoolean((i % 2) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date((long) i));
             allTypes.setColumnDouble(3.1415 + i);
@@ -58,7 +60,6 @@ protected void setUp() throws InterruptedException {
             allTypes.setColumnLong(i);
         }
         testRealm.commitTransaction();
-
     }
 
 
@@ -151,10 +152,30 @@ public void testSumGivesCorrectValue() {
 
     public void testAvgGivesCorrectValue() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        Double avg = Math.round(resultList.average(FIELD_DOUBLE) * 10000.0) / 10000.0;
-
-        assertEquals("ResultList.sum returned wrong sum", 260.6415, avg);
+        double N = (double)TEST_DATA_SIZE;
+
+        // Sum of numbers 1 to M: M*(M+1)/2
+        // See setUp() for values of fields
+        // N = TEST_DATA_SIZE
+
+        // Type: double; a = 3.1415
+        // a, a+1, ..., a+i, ..., a+N-1
+        // sum = 3.1415*N + N*(N-1)/2
+        // average = sum/N = 3.1415+(N-1)/2
+        double average = 3.1415+(N-1.0)*0.5;
+        assertEquals(average, resultList.average(FIELD_DOUBLE), 0.0001);
+
+        // Type: long
+        // 0, 1, ..., N-1
+        // sum = N*(N-1)/2
+        // average = sum/N = (N-1)/2
+        assertEquals(0.5*(N-1), resultList.average(FIELD_LONG), 0.0001);
+
+        // Type: float; b = 1.234567
+        // b, b+1, ..., b+i, ..., b+N-1
+        // sum = b*N + N*(N-1)/2
+        // average = sum/N = b + (N-1)/2
+        assertEquals(1.234567+0.5*(N-1.0), resultList.average(FIELD_FLOAT), 0.0001);
     }
 
 
@@ -190,7 +211,6 @@ public void testIsResultRemoveLastListSizeOk() {
 
         RealmResults<AllTypes> resultListCheck = testRealm.where(AllTypes.class).findAll();
         assertEquals("ResultList.removeLast not committed", TEST_DATA_SIZE - 1, resultListCheck.size());
-
     }
 
     public void testSortByLong() {
@@ -232,15 +252,15 @@ public void testSortByBoolean() {
         assertEquals(TEST_DATA_SIZE, sortedList.size());
         assertEquals("Last expected to be false", false, sortedList.last().isColumnBoolean());
         assertEquals("First expected to be true", true, sortedList.first().isColumnBoolean());
-        assertEquals("Expected to be true", true, sortedList.get(147).isColumnBoolean());
-        assertEquals("Expected to be false", false, sortedList.get(368).isColumnBoolean());
+        assertEquals("Expected to be true", true, sortedList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
+        assertEquals("Expected to be false", false, sortedList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
 
         RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_ASCENDING);
         assertEquals(TEST_DATA_SIZE, reverseList.size());
         assertEquals("Last expected to be true", true, reverseList.last().isColumnBoolean());
         assertEquals("First expected to be false", false, reverseList.first().isColumnBoolean());
-        assertEquals("Expected to be false", false, reverseList.get(147).isColumnBoolean());
-        assertEquals("Expected to be true", true, reverseList.get(368).isColumnBoolean());
+        assertEquals("Expected to be false", false, reverseList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
+        assertEquals("Expected to be true", true, reverseList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
 
         RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_DECENDING);
         assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
@@ -258,8 +278,13 @@ public void testSortByString() {
         RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_STRING, RealmResults.SORT_ORDER_ASCENDING);
         assertEquals(TEST_DATA_SIZE, reverseList.size());
         assertEquals("First excepted to be first", resultList.first().getColumnString(), reverseList.first().getColumnString());
-        assertEquals("Last excepted to be last", resultList.get(99).getColumnString(), reverseList.last().getColumnString());
 
+        int numberOfDigits = 1+((int)Math.log10(TEST_DATA_SIZE));
+        int largestNumber = 1;
+        for(int i=1; i<numberOfDigits; i++)
+            largestNumber *= 10;  // 10*10* ... *10
+        largestNumber = largestNumber-1;
+        assertEquals("Last excepted to be last", resultList.get(largestNumber).getColumnString(), reverseList.last().getColumnString());
         RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_STRING, RealmResults.SORT_ORDER_DECENDING);
         assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
     }
@@ -306,7 +331,6 @@ public void testSortOnNonExistingColumn() {
     }
 
 
-
     public void testCount() {
         assertEquals(TEST_DATA_SIZE, testRealm.where(AllTypes.class).count());
     }
@@ -319,4 +343,14 @@ public void testFindFirst() {
         AllTypes none = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "smurf").findFirst();
         assertNull(none);
     }
+
+    public void testManyConditions() {
+        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class);
+        query.equalTo(FIELD_LONG, 0);
+        for (int i = 1; i < TEST_DATA_SIZE; i++) {
+            query.or().equalTo(FIELD_LONG, i);
+        }
+        RealmResults<AllTypes> allTypesRealmResults = query.findAll();
+        assertEquals(TEST_DATA_SIZE, allTypesRealmResults.size());
+    }
 }
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index 0e1644a529..2cedd8d8cf 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -31,6 +31,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
@@ -40,19 +41,33 @@
 import io.realm.internal.Row;
 import io.realm.internal.SharedGroup;
 import io.realm.internal.Table;
-import io.realm.internal.android.LooperThread;
 
 
 /**
- * The Realm class is the storage and transactional manager of your object persistent store. Objects
+ * <p>The Realm class is the storage and transactional manager of your object persistent store. Objects
  * are created. Objects within a Realm can be queried and read at any time. Creating,
- * modifying, and deleting objects must be done through transactions.
- * <br>
- * The transactions ensure that multiple instances (on multiple threads) can access the objects
- * in a consistent state with full ACID guaranties.
- * <br>
- * The instances of a Realm will be automatically updated when one instance commits a
- * change (create, modify or delete an object).
+ * modifying, and deleting objects must be done through transactions.</p>
+ *
+ * <p>The transactions ensure that multiple instances (on multiple threads) can access the objects
+ * in a consistent state with full ACID guaranties.</p>
+ *
+ * <p>If auto-refresh is set the instance of the Realm will be automatically updated when another instance commits a
+ * change (create, modify or delete an object). This feature requires the Realm instance to be residing in a
+ * thread attached to a Looper (the main thread has a Looper by default)</p>
+ *
+ *<p>For normal threads Android provides a utility class that can be used like this:</p>
+ *
+ * <pre>
+ * HandlerThread thread = new HandlerThread("MyThread") {
+ *    @Override
+ *    protected void onLooperPrepared() {
+ *       Realm realm = Realm.getInstance(getContext());
+ *       // This realm will be updated by the event loop
+ *       // on every commit performed by other realm instances
+ *    }
+ * };
+ * thread.start();
+ * </pre>
  */
 public class Realm {
     public static final String DEFAULT_REALM_NAME = "default.realm";
@@ -65,13 +80,15 @@
             return new HashMap<String, Realm>();
         }
     };
+    private static final int REALM_CHANGED = 14930352; // Just a nice big Fibonacci number. For no reason :)
+    private static final Map<Handler, Integer> handlers = new ConcurrentHashMap<Handler, Integer>();
 
     @SuppressWarnings("UnusedDeclaration")
     private static SharedGroup.Durability defaultDurability = SharedGroup.Durability.FULL;
-    private static boolean autoRefresh = true;
+    private boolean autoRefresh;
+    private Handler handler;
 
     private final int id;
-    private final LooperThread looperThread = LooperThread.getInstance();
     private final SharedGroup sharedGroup;
     private final ImplicitTransaction transaction;
     private final Map<Class<?>, String> simpleClassNames = new HashMap<Class<?>, String>();
@@ -83,38 +100,15 @@
     private final Map<Class<?>, Table> tables = new HashMap<Class<?>, Table>();
     private static final long UNVERSIONED = -1;
 
-    private Handler handler;
-
     // Package protected to be reachable by proxy classes
     static final Map<String, Map<String, Long>> columnIndices = new HashMap<String, Map<String, Long>>();
 
     // The constructor in private to enforce the use of the static one
-    private Realm(String absolutePath, byte[] key) {
+    private Realm(String absolutePath, byte[] key, boolean autoRefresh) {
         this.sharedGroup = new SharedGroup(absolutePath, true, key);
         this.transaction = sharedGroup.beginImplicitTransaction();
         this.id = absolutePath.hashCode();
-        if (!looperThread.isAlive()) {
-            looperThread.start();
-        }
-
-        if (Looper.myLooper() == null) {
-            Looper.prepare();
-        }
-        handler = new Handler() {
-            @Override
-            public void handleMessage(Message message) {
-                if (message.what == LooperThread.REALM_CHANGED) {
-                    if (autoRefresh) {
-                        transaction.advanceRead();
-                    }
-                    sendNotifications();
-                }
-            }
-        };
-        if (Looper.myLooper() == null) {
-            Looper.loop();
-        }
-        LooperThread.handlers.put(handler, id);
+        setAutoRefresh(autoRefresh);
     }
 
     @Override
@@ -123,10 +117,55 @@ protected void finalize() throws Throwable {
         super.finalize();
     }
 
+    private class RealmCallback implements Handler.Callback {
+        @Override
+        public boolean handleMessage(Message message) {
+            if (message.what == REALM_CHANGED) {
+                transaction.advanceRead();
+                sendNotifications();
+            }
+            return true;
+        }
+    }
+
+    /**
+     * Retrieve the auto-refresh status of the Realm instance
+     * @return the auto-refresh status
+     */
+    public boolean isAutoRefresh() {
+        return autoRefresh;
+    }
+
+    /**
+     * Set the auto-refresh status of the Realm instance
+     *
+     * Auto-refresh is a feature to allows to automatically update the current realm instance and all its derived objects
+     * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in another thread.
+     * This feature is only available if the realm instance lives is a {@link android.os.Looper} enabled thread.
+     *
+     * @param autoRefresh true will turn auto-refresh on, false will turn it off
+     * @throws java.lang.IllegalStateException if trying to enable auto-refresh in a thread without Looper
+     */
+    public void setAutoRefresh(boolean autoRefresh) {
+        if (autoRefresh && Looper.myLooper() == null) {
+            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
+        }
+
+        if (autoRefresh && !this.autoRefresh) { // Switch it on
+            handler = new Handler(new RealmCallback());
+            handlers.put(handler, id);
+        } else if (!autoRefresh && this.autoRefresh && handler != null) { // Switch it off
+            handler.removeCallbacksAndMessages(null);
+            handlers.remove(handler);
+        }
+        this.autoRefresh = autoRefresh;
+    }
+
 //    public static void setDefaultDurability(SharedGroup.Durability durability) {
 //        defaultDurability = durability;
 //    }
 
+    // Public because of migrations
     public Table getTable(Class<?> clazz) {
         String simpleClassName = simpleClassNames.get(clazz);
         if (simpleClassName == null) {
@@ -139,63 +178,140 @@ public Table getTable(Class<?> clazz) {
     /**
      * Realm static constructor for the default realm "default.realm"
      *
+     * It sets auto-refresh on
+     *
      * @param context an Android {@link android.content.Context}
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated in a Thread without
+     *                                         a {@link android.os.Looper}
      * @throws RealmException                Other errors
      */
     public static Realm getInstance(Context context) {
-        return Realm.getInstance(context, DEFAULT_REALM_NAME, null);
+        return Realm.getInstance(context, DEFAULT_REALM_NAME, null, true);
+    }
+
+    /**
+     * Realm static constructor for the default realm "default.realm"
+     *
+     * @param context an Android context
+     * @param autoRefresh whether the Realm object and its derived objects (RealmResults and RealmObjects)
+     *                    should be automatically refreshed with the event loop (requires to be in a thread with a Looper)
+     * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated with auto-refresh
+     *                                         in a Thread without a {@link android.os.Looper}
+     * @throws RealmException                Other errors
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static Realm getInstance(Context context, boolean autoRefresh) {
+        return Realm.getInstance(context, DEFAULT_REALM_NAME, null, autoRefresh);
     }
 
     /**
      * Realm static constructor
      *
+     * It sets auto-refresh on
+     *
      * @param context  an Android {@link android.content.Context}
      * @param fileName the name of the file to save the Realm to
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated in a Thread without
+     *                                         a {@link android.os.Looper}
      * @throws RealmException                Other errors
      */
     @SuppressWarnings("UnusedDeclaration")
     public static Realm getInstance(Context context, String fileName) {
-        return Realm.create(context.getFilesDir(), fileName, null);
+        return Realm.create(context.getFilesDir(), fileName, null, true);
+    }
+
+    /**
+     * Realm static constructor
+     *
+     * @param context  an Android context
+     * @param fileName the name of the file to save the Realm to
+     * @param autoRefresh whether the Realm object and its derived objects (RealmResults and RealmObjects)
+     *                    should be automatically refreshed with the event loop (requires to be in a thread with a Looper)
+     * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated with auto-refresh
+     *                                         in a Thread without a {@link android.os.Looper}
+     * @throws RealmException                Other errors
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static Realm getInstance(Context context, String fileName, boolean autoRefresh) {
+        return Realm.create(context.getFilesDir(), fileName, null, autoRefresh);
+    }
+
+    /**
+     * Realm static constructor
+     *
+     * @param context an Android context
+     * @param key     a 32-byte encryption key
+     * @param autoRefresh whether the Realm object and its derived objects (RealmResults and RealmObjects)
+     *                    should be automatically refreshed with the event loop (requires to be in a thread with a Looper)
+     * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated with auto-refresh
+     *                                         in a Thread without a {@link android.os.Looper}
+     * @throws RealmException                Other errors
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static Realm getInstance(Context context, byte[] key, boolean autoRefresh) {
+        return Realm.getInstance(context, DEFAULT_REALM_NAME, key, autoRefresh);
     }
 
     /**
      * Realm static constructor
      *
+     * It sets auto-refresh on
+     *
      * @param context an Android {@link android.content.Context}
      * @param key     a 32-byte encryption key
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated in a Thread without
+     *                                         a {@link android.os.Looper}
      * @throws RealmException                Other errors
      */
     @SuppressWarnings("UnusedDeclaration")
     public static Realm getInstance(Context context, byte[] key) {
-        return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
+        return Realm.getInstance(context, DEFAULT_REALM_NAME, key, true);
     }
 
+
+
     /**
      * Realm static constructor
      *
      * @param context  an Android {@link android.content.Context}
      * @param fileName the name of the file to save the Realm to
      * @param key      a 32-byte encryption key
+     * @param autoRefresh whether the Realm object and its derived objects (RealmResults and RealmObjects)
+     *                    should be automatically refreshed with the event loop (requires to be in a thread with a Looper)
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated in a Thread without
+     *                                         a {@link android.os.Looper}
      * @throws RealmException                Other errors
      */
-    public static Realm getInstance(Context context, String fileName, byte[] key) {
-        return Realm.create(context.getFilesDir(), fileName, key);
+    public static Realm getInstance(Context context, String fileName, byte[] key, boolean autoRefresh) {
+        return Realm.create(context.getFilesDir(), fileName, key, autoRefresh);
     }
 
     /**
@@ -203,15 +319,19 @@ public static Realm getInstance(Context context, String fileName, byte[] key) {
      *
      * @param writableFolder absolute path to a writable directory
      * @param key            a 32-byte encryption key
+     * @param autoRefresh whether the Realm object and its derived objects (RealmResults and RealmObjects)
+     *                    should be automatically refreshed with the event loop (requires to be in a thread with a Looper)
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated in a Thread without
+     *                                         a {@link android.os.Looper}
      * @throws RealmException                Other errors
      */
     @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writableFolder, byte[] key) {
-        return Realm.create(writableFolder, DEFAULT_REALM_NAME, key);
+    public static Realm getInstance(File writableFolder, byte[] key, boolean autoRefresh) {
+        return Realm.create(writableFolder, DEFAULT_REALM_NAME, key, autoRefresh);
     }
 
     /**
@@ -220,23 +340,27 @@ public static Realm getInstance(File writableFolder, byte[] key) {
      * @param writableFolder absolute path to a writable directory
      * @param filename       the name of the file to save the Realm to
      * @param key            a 32-byte encryption key
+     * @param autoRefresh whether the Realm object and its derived objects (RealmResults and RealmObjects)
+     *                    should be automatically refreshed with the event loop (requires to be in a thread with a Looper)
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
+     * @throws java.lang.IllegalStateException The Realm is being instantiated in a Thread without
+     *                                         a {@link android.os.Looper}
      * @throws RealmException                Other errors
      */
-    public static Realm create(File writableFolder, String filename, byte[] key) {
+    public static Realm create(File writableFolder, String filename, byte[] key, boolean autoRefresh) {
         String absolutePath = new File(writableFolder, filename).getAbsolutePath();
-        return createAndValidate(absolutePath, key, true);
+        return createAndValidate(absolutePath, key, true, autoRefresh);
     }
 
-    private static Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema) {
+    private static Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema, boolean autoRefresh) {
         Map<String, Realm> realms = realmsCache.get();
         Realm realm = realms.get(absolutePath);
 
         if (realm == null) {
-            realm = new Realm(absolutePath, key);
+            realm = new Realm(absolutePath, key, autoRefresh);
             realms.put(absolutePath, realm);
             realmsCache.set(realms);
         }
@@ -469,8 +593,8 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
             e.printStackTrace();
             throw new RealmException("An exception occurred while instantiating the proxy class");
         }
-        result.realmSetRow(row);
-        result.setRealm(this);
+        result.row = row;
+        result.realm = this;
         return result;
     }
 
@@ -517,7 +641,6 @@ boolean contains(Class<?> clazz) {
      */
     public void addChangeListener(RealmChangeListener listener) {
         changeListeners.add(listener);
-        LooperThread.handlers.put(handler, id);
     }
 
     /**
@@ -528,9 +651,6 @@ public void addChangeListener(RealmChangeListener listener) {
      */
     public void removeChangeListener(RealmChangeListener listener) {
         changeListeners.remove(listener);
-        if (changeListeners.isEmpty()) {
-            LooperThread.handlers.remove(handler);
-        }
     }
 
     /**
@@ -540,7 +660,6 @@ public void removeChangeListener(RealmChangeListener listener) {
      */
     public void removeAllChangeListeners() {
         changeListeners.clear();
-        LooperThread.handlers.remove(handler);
     }
 
     void sendNotifications() {
@@ -558,9 +677,13 @@ boolean hasChanged() {
      * Transactions
      */
 
-//    public void refresh() {
-//        transaction.advanceRead();
-//    }
+    /**
+     * Refresh the Realm instance and all the RealmResults and RealmObjects instances coming from it
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public void refresh() {
+        transaction.advanceRead();
+    }
 
     /**
      * Starts a write transaction, this must be closed with {@link io.realm.Realm#commitTransaction()}
@@ -592,13 +715,16 @@ public void beginTransaction() {
     public void commitTransaction() {
         transaction.commitAndContinueAsRead();
 
-        Message message = Message.obtain();
-        message.arg1 = LooperThread.REALM_CHANGED;
-        message.arg2 = id;
-        if (looperThread.handler != null) {
-            looperThread.handler.sendMessage(message);
-        } else {
-            Log.i(TAG, "The LooperThread is not up and running yet. Commit message not sent");
+        for (Map.Entry<Handler, Integer> handlerIntegerEntry : handlers.entrySet()) {
+            Handler handler = handlerIntegerEntry.getKey();
+            int realmId = handlerIntegerEntry.getValue();
+            if (
+                    realmId == id                                // It's the right realm
+                    && !handler.hasMessages(REALM_CHANGED)       // The right message
+                    && handler.getLooper().getThread().isAlive() // The receiving thread is alive
+            ) {
+                handler.sendEmptyMessage(REALM_CHANGED);
+            }
         }
     }
 
@@ -646,18 +772,28 @@ void setVersion(long version) {
         metadataTable.setLong(0, 0, version);
     }
 
+    @SuppressWarnings("UnusedDeclaration")
     static public void migrateRealmAtPath(String realmPath, RealmMigration migration) {
-        migrateRealmAtPath(realmPath, null, migration);
+        migrateRealmAtPath(realmPath, null, migration, true);
     }
 
     static public void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration) {
-        Realm realm = Realm.createAndValidate(realmPath, key, false);
+        migrateRealmAtPath(realmPath, key, migration, true);
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    static public void migrateRealmAtPath(String realmPath, RealmMigration migration, boolean autoRefresh) {
+        migrateRealmAtPath(realmPath, null, migration, autoRefresh);
+    }
+
+    static public void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration, boolean autoUpdate) {
+        Realm realm = Realm.createAndValidate(realmPath, key, false, autoUpdate);
         realm.beginTransaction();
         realm.setVersion(migration.execute(realm, realm.getVersion()));
         realm.commitTransaction();
 
         Map<String, Realm> realms = realmsCache.get();
-        realms.put(realmPath, new Realm(realmPath, key));
+        realms.put(realmPath, new Realm(realmPath, key, autoUpdate));
         realmsCache.set(realms);
     }
 
diff --git a/realm/src/main/java/io/realm/RealmBaseAdapter.java b/realm/src/main/java/io/realm/RealmBaseAdapter.java
new file mode 100644
index 0000000000..8fd6d1e583
--- /dev/null
+++ b/realm/src/main/java/io/realm/RealmBaseAdapter.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.widget.BaseAdapter;
+
+public abstract class RealmBaseAdapter<T extends RealmObject> extends BaseAdapter {
+
+    protected LayoutInflater inflater;
+    protected RealmResults<T> realmResults;
+    protected Context context;
+
+    public RealmBaseAdapter(Context context, RealmResults<T> realmResults, boolean automaticUpdate) {
+        if (context == null) {
+            throw new IllegalArgumentException("Context cannot be null");
+        }
+        if (realmResults == null) {
+            throw new IllegalArgumentException("RealmResults cannot be null");
+        }
+
+        this.context = context;
+        this.realmResults = realmResults;
+        this.inflater = LayoutInflater.from(context);
+        if (automaticUpdate) {
+            realmResults.getRealm().addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    notifyDataSetChanged();
+                }
+            });
+        }
+    }
+
+    @Override
+    public int getCount() {
+        return realmResults.size();
+    }
+
+    @Override
+    public T getItem(int i) {
+        return realmResults.get(i);
+    }
+
+    @Override
+    public long getItemId(int i) {
+        return i; // TODO: find better solution once we have unique IDs
+    }
+
+    /**
+     * Update the RealmResults associated to the Adapter. Useful when the query has been changed.
+     * If the query does not change you might consider using the automaticUpdate feature
+     * @param realmResults the new RealmResults coming from the new query.
+     */
+    public void updateRealmResults(RealmResults<T> realmResults) {
+        this.realmResults = realmResults;
+        notifyDataSetChanged();
+    }
+}
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
index 4de644b403..81624008ea 100644
--- a/realm/src/main/java/io/realm/RealmList.java
+++ b/realm/src/main/java/io/realm/RealmList.java
@@ -43,7 +43,7 @@
      */
     @Override
     public void add(int location, E object) {
-        view.insert(location, object.realmGetRow().getIndex());
+        view.insert(location, object.row.getIndex());
     }
 
     /**
@@ -51,7 +51,7 @@ public void add(int location, E object) {
      */
     @Override
     public boolean add(E object) {
-        view.add(object.realmGetRow().getIndex());
+        view.add(object.row.getIndex());
         return true;
     }
 
@@ -60,7 +60,7 @@ public boolean add(E object) {
      */
     @Override
     public E set(int location, E object) {
-        view.set(location, object.realmGetRow().getIndex());
+        view.set(location, object.row.getIndex());
         return object;
     }
 
diff --git a/realm/src/main/java/io/realm/RealmObject.java b/realm/src/main/java/io/realm/RealmObject.java
index 0a69e12e93..b6fb989e18 100644
--- a/realm/src/main/java/io/realm/RealmObject.java
+++ b/realm/src/main/java/io/realm/RealmObject.java
@@ -20,7 +20,7 @@
 import io.realm.annotations.RealmClass;
 
 /**
- * In Realm you define your model classes by subclassing RealmObject and adding fields to be
+ * In Realm you define your model classes by sub-classing RealmObject and adding fields to be
  * persisted. You then create your objects within a Realm, and use your custom subclasses instead
  * of using the RealmObject class directly.
  * <br>
@@ -37,19 +37,19 @@
     protected Row row;
     protected Realm realm;
 
-    protected Realm getRealm() {
-        return realm;
-    }
-
-    protected void setRealm(Realm realm) {
-        this.realm = realm;
-    }
-
-    protected Row realmGetRow() {
-        return row;
-    }
-
-    protected void realmSetRow(Row row) {
-        this.row = row;
+    /**
+     * Removes the object from the Realm it is currently associated to.
+     *
+     * After this method is called the object will be invalid and any operation (read or write)
+     * performed on it will fail with an IllegalStateException
+     */
+    public void removeFromRealm() {
+        if (row == null) {
+            throw new IllegalStateException("Object malformed: missing Row. Make sure to instantiate RealmObjects with Realm.createObject()");
+        }
+        if (realm == null) {
+            throw new IllegalStateException("Object malformed: missing Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
+        }
+        row.getTable().remove(row.getIndex());
     }
 }
diff --git a/realm/src/main/java/io/realm/internal/Row.java b/realm/src/main/java/io/realm/internal/Row.java
index 14a793bdc7..e23703c76a 100644
--- a/realm/src/main/java/io/realm/internal/Row.java
+++ b/realm/src/main/java/io/realm/internal/Row.java
@@ -81,6 +81,10 @@ public ColumnType getColumnType(long columnIndex) {
 
     // Getters
 
+    public Table getTable() {
+        return parent;
+    }
+
     public long getIndex() {
         return nativeGetIndex(nativePtr);
     }
diff --git a/realm/src/main/java/io/realm/internal/Util.java b/realm/src/main/java/io/realm/internal/Util.java
index b84406a47b..e7c0b8dac4 100644
--- a/realm/src/main/java/io/realm/internal/Util.java
+++ b/realm/src/main/java/io/realm/internal/Util.java
@@ -61,7 +61,8 @@ public static void waitForEnter() {
         Exception_UnsupportedOperation(9),
         Exception_OutOfMemory(10),
         Exception_Unspecified(11),
-        Exception_RuntimeError(12);
+        Exception_RuntimeError(12),
+        Exception_RowInvalid(13);
 
         private final int nativeTestcase;
         private Testcase(int nativeValue)
diff --git a/realm/src/main/java/io/realm/internal/android/LooperThread.java b/realm/src/main/java/io/realm/internal/android/LooperThread.java
deleted file mode 100644
index 7edd0d18c2..0000000000
--- a/realm/src/main/java/io/realm/internal/android/LooperThread.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.android;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * This thread continuously receives and dispatches messages regarding changes in realms.
- */
-public class LooperThread extends Thread {
-    // Message types
-    public static final int REALM_CHANGED  = 3;
-    public static final Map<Handler, Integer> handlers = new ConcurrentHashMap<Handler, Integer>();
-
-    public Handler handler;
-    public List<RuntimeException> exceptions = new ArrayList<RuntimeException>();
-
-    private static final String TAG = LooperThread.class.getName();
-    private static LooperThread instance;
-
-    // private because it's a singleton
-    private LooperThread() {}
-
-    // thread safe static constructor
-    public static LooperThread getInstance() {
-        if (instance == null) {
-            synchronized (LooperThread.class) {
-                if (instance == null) {
-                    instance = new LooperThread();
-                }
-            }
-        }
-        return instance;
-    }
-
-    @Override
-    public void run() {
-        Looper.prepare();
-
-        handler = new Handler() {
-            @Override
-            public void handleMessage(Message message) {
-                if (message.arg1 == REALM_CHANGED) {
-                    for (Map.Entry<Handler, Integer> entry : handlers.entrySet()) {
-                        if (entry.getValue() == message.arg2) {
-                            Handler currentHandler = entry.getKey();
-                            if (currentHandler.getLooper().getThread().isAlive() &&
-                                !currentHandler.hasMessages(REALM_CHANGED))
-                            {
-                                try {
-                                    currentHandler.sendEmptyMessage(REALM_CHANGED);
-                                } catch (RuntimeException e) {
-                                    exceptions.add(e);
-                                    Log.w(TAG, e.getMessage());
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        };
-
-        Looper.loop();
-    }
-}
diff --git a/settings.gradle b/settings.gradle
index 898f839d2c..b145cac317 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,4 +1,4 @@
-include 'realm', ':introExample', ':gridViewExample', ':concurrencyExample', ':encryptionExample', ':migrationExample'
+include 'realm', ':introExample', ':gridViewExample', ':concurrencyExample', ':encryptionExample', ':migrationExample', ':adapterExample'
 include ':performance'
 project(':performance').projectDir = new File('examples/performance')
 
@@ -8,3 +8,4 @@ project(':gridViewExample').projectDir = new File('examples/gridViewExample')
 project(':concurrencyExample').projectDir = new File('examples/concurrencyExample')
 project(':encryptionExample').projectDir = new File('examples/encryptionExample')
 project(':migrationExample').projectDir = new File('examples/migrationExample')
+project(':adapterExample').projectDir = new File('examples/adapterExample')
diff --git a/version.txt b/version.txt
index 67d5f802ff..598d667c91 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.72.0
\ No newline at end of file
+0.73.0
\ No newline at end of file
