diff --git a/CHANGELOG.md b/CHANGELOG.md
index fe6553ba91..894ba9713a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,13 +1,50 @@
-## 5.7.0 (2017-09-24)
+## 5.?.? (2018-mm-dd)
 
-## Enhancements
+### Enhancements
+* None
+
+### Fixed
+* ?? (Issue [#??](https://github.com/realm/realm-java/issues/??), since ??).
+
+### Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* None
+
+
+## 5.7.1 (2018-10-22)
+
+### Enhancements
+* None
+
+### Fixed
+* `RealmResults` listeners not triggering the initial callback for Query-based Realm when the device is offline. (Issue [#6235](https://github.com/realm/realm-java/issues/6235), since 5.0.0).
+
+### Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* None
+
+
+## 5.7.0 (2018-09-24)
+
+### Enhancements
 * [ObjectServer] Devices will now report download progress for read-only Realms which 
   will allow the server to compact files sooner, saving server space. This does not affect 
   the client. You will need to upgrade your Realm Object Server to at least version 3.11.0 
   or use [Realm Cloud](https://cloud.realm.io). If you try to connect to a ROS v3.10.x or 
   previous, you will see an error like `Wrong protocol version in Sync HTTP request, 
   client protocol version = 25, server protocol version = 24`.
-  
+
+### Fixed
+* None
+
 ### Compatibility
 * Realm Object Server: 3.11.0 or later.
 * File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
@@ -32,7 +69,7 @@
   `sort()` would always be applied before `distinct()`.
 * Building with Android App Bundle is now supported ([#5977](https://github.com/realm/realm-java/issues/5977)).
 
-### Fixes
+### Fixed
 * None
 
 ### Compatibility
@@ -48,7 +85,6 @@
 ## 5.5.0 (2018-08-31)
 
 ### Enhancements
-
 * [ObjectServer] Added `ConnectionState` enum describing the states a connection can be in.
 * [ObjectServer] Added `SyncSession.isConnected()` and `SyncSession.getConnectionState()`.
 * [ObjectServer] Added support for observing connection changes for a session using `SyncSession.addConnectionChangeListener()` and `SyncSession.removeConnectionChangeListener()`.
@@ -64,18 +100,15 @@
   * `SyncManager.addCustomRequestHeaders(Map<String, String> headers, String host)`
   * `SyncConfiguration.Builder.urlPrefix(String prefix)`
  
-### Bug Fixes
-
+### Fixed
 * Methods and classes requiring synchronized Realms have been removed from the standard AAR package. They are now only visible when enabling synchronized Realms in Gradle. The methods and classes will still be visible in the source files and docs, but annotated with `@ObjectServer` (#5799).
 
 ### Internal
-
 * Updated to Realm Sync 3.9.4
 * Updated to Realm Core 5.8.0
 * Updated to Object Store commit: b0fc2814d9e6061ce5ba1da887aab6cfba4755ca
 
 ### Credits
-
 * Thanks to @lucasdornelasv for improving the performance of `Realm.copyToRealm()`, `Realm.copyToRealmOrUpdate()` and `Realm.copyFromRealm()` #(6124). 
 
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
index c9ab8d4e0e..0f601cde9c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
@@ -16,8 +16,6 @@
 
 package io.realm.internal;
 
-import javax.annotation.Nullable;
-
 import io.realm.RealmChangeListener;
 import io.realm.internal.core.DescriptorOrdering;
 import io.realm.internal.sync.OsSubscription;
@@ -85,6 +83,7 @@ private void triggerDelayedChangeListener() {
         // errors and a completed subscription
         if (delayedNotificationPtr == 0
                 && subscription != null
+                && !firstCallback
                 && subscription.getState() != OsSubscription.SubscriptionState.ERROR
                 && subscription.getState() != OsSubscription.SubscriptionState.COMPLETE) {
             return;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index ff2eeb70b0..551c872067 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -29,6 +29,7 @@
 import java.util.Random;
 import java.util.UUID;
 
+import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -439,4 +440,31 @@ public void onError(SyncSession session, ObjectServerError error) {
         looperThread.closeAfterTest(realm);
     }
 
+
+    /**
+     * Tests https://github.com/realm/realm-java/issues/6235
+     * This checks that the INITIAL callback is called for query-based notifications even when
+     * the device is offline.
+     */
+    @Test
+    @RunTestInLooperThread
+    public void listenersTriggerWhenOffline() {
+        SyncUser user = SyncTestUtils.createTestUser(); // Creating a fake user will make it behave as "offline"
+        String url = "http://foo.com/offlineListeners";
+        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, url)
+                .build();
+        Realm realm = Realm.getInstance(config);
+        looperThread.closeAfterTest(realm);
+
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+
+        looperThread.keepStrongReference(results);
+        results.addChangeListener((objects, changeSet) -> {
+            if(changeSet.getState() == OrderedCollectionChangeSet.State.INITIAL) {
+                assertTrue(results.isLoaded());
+                assertFalse(changeSet.isCompleteResult());
+                looperThread.testComplete();
+            }
+        });
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index 7f9f185107..4c7baeece9 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -126,9 +126,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         realm.createObject(StringOnly.class).setChars("Hi Alice");
         realm.commitTransaction();
 
-        // STEP 2: make sure the changes gets to the server
-        SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
-
+        // STEP 2: Close the Realm and log the user out to forget about it.
         realm.close();
         user.logOut();
 
diff --git a/version.txt b/version.txt
index 4f39750113..6ef65ad751 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1,2 @@
-5.8.0-SNAPSHOT
\ No newline at end of file
+5.8.0-SNAPSHOT
+
