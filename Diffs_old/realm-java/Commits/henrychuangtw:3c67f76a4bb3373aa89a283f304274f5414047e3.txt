diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index 187ea46746..4d223c132d 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -38,6 +38,8 @@
 #### Version of Realm and tooling
 Realm version(s): ?
 
+Realm sync feature enabled: yes/no
+
 Android Studio version: ?
 
 Which Android version and device: ?
diff --git a/.gitignore b/.gitignore
index a72b66b484..7d38506f03 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,7 +1,6 @@
 # Gradle build artifacts
 build
 realm/build
-realm-jni/build
 
 # Gradle cache
 .gradle
@@ -12,6 +11,7 @@ local.properties
 # Core
 core
 core-*
+realm-sync-android-*
 
 # Android Studio
 .idea
@@ -46,3 +46,9 @@ distribution/RealmGridViewExample/app/src
 distribution/RealmIntroExample/app/src
 distribution/RealmMigrationExample/app/src
 
+# Generated JNI headers
+realm/realm-library/src/main/cpp/jni_include
+# Downloaded core
+realm/realm-library/distribution
+# Cmake output
+realm/realm-library/.externalNativeBuild
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000000..35b419c520
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "realm/realm-library/src/main/cpp/object-store"]
+	path = realm/realm-library/src/main/cpp/object-store
+	url = https://github.com/realm/realm-object-store.git
diff --git a/CHANGELOG.md b/CHANGELOG.md
index bacad0d716..deecc12ea7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,185 @@
+## 2.3.0
+
+### Object Server API Changes (In Beta)
+
+* Add a default `UserStore` based on the Realm Object Store (`ObjectStoreUserStore`).
+
+## 2.2.2
+
+### Object Server API Changes (In Beta)
+
+* Disabled `Realm.compactRealm()` when sync is enabled as it might corrupt the Realm (https://github.com/realm/realm-core/issues/2345).
+
+### Bug fixes
+
+* "operation not permitted" issue when creating Realm file on some devices' external storage (#3629).
+
+### Enhancements
+
+* All major public classes are now non-final. This is mostly a compromise to support Mockito. All protected fields/methods are still not considered part of the public API and can change without notice (#3869).
+
+### Internal
+
+* Upgraded Realm Core to 2.1.0.
+* Upgraded Realm Sync to 1.0.0-BETA-5.0.
+
+## 2.2.1
+
+### Object Server API Changes (In Beta)
+
+* Fixed `SyncConfiguration.toString()` so it now outputs a correct description instead of an empty string (#3787).
+
+### Bug fixes
+
+* Added version number to the native library, preventing ReLinker from accidentally loading old code (#3775).
+* `Realm.getLocalInstanceCount(config)` throwing NullPointerException if called after all Realms have been closed (#3791).
+
+## 2.2.0
+
+### Object Server API Changes (In Beta)
+
+* Added support for `SyncUser.getManagementRealm()` and permission changes.
+
+### Bug fixes
+
+* Kotlin projects no longer create the `RealmDefaultModule` if no Realm model classes are present (#3746).
+* Remove `includedescriptorclasses` option from ProGuard rule file in order to support built-in shrinker of Android Gradle Plugin (#3714).
+* Unexpected `RealmMigrationNeededException` was thrown when a field was added to synced Realm.
+
+### Enhancements
+
+* Added support for the `annotationProcessor` configuration provided by Android Gradle Plugin 2.2.0 or later. Realm plugin adds its annotation processor to the `annotationProcessor` configuration instead of `apt` configuration if it is available and the `com.neenbedankt.android-apt` plugin is not used. In Kotlin projects, `kapt` is used instead of the `annotationProcessor` configuration (#3026).
+
+## 2.1.1
+
+### Bug fixes
+
+* Fixed a bug in `Realm.insert` and `Realm.insertOrUpdate` methods causing a `StackOverFlow` when you try to insert a cyclic graph of objects between Realms (#3732).
+
+### Object Server API Changes (In Beta)
+
+* Set default RxFactory to `SyncConfiguration`.
+
+### Bug fixes
+
+* ProGuard configuration introduced in 2.1.0 unexpectedly kept classes that did not have the @KeepMember annotation (#3689).
+
+## 2.1.0
+
+### Breaking changes
+
+* * `SecureUserStore` has been moved to its own GitHub repository: https://github.com/realm/realm-android-user-store
+  See https://github.com/realm/realm-android-user-store/blob/master/README.md for further info on how to include it.
+
+
+### Object Server API Changes (In Beta)
+
+* Renamed `User` to `SyncUser`, `Credentials` to `SyncCredentials` and `Session` to `SyncSession` to align names with Cocoa.
+* Removed `SyncManager.setLogLevel()`. Use `RealmLog.setLevel()` instead.
+* `SyncUser.logout()` now correctly clears `SyncUser.currentUser()` (#3638).
+* Missing ProGuard configuration for libraries used by Sync extension (#3596).
+* Error handler was not called when sync session failed (#3597).
+* Added `User.all()` that returns all known Realm Object Server users.
+* Upgraded Realm Sync to 1.0.0-BETA-3.2
+
+### Deprecated
+
+* `Logger`. Use `RealmLogger` instead.
+* `AndroidLogger`. The logger for Android is implemented in native code instead.
+
+### Bug fixes
+
+* The following were not kept by ProGuard: names of native methods not in the `io.realm.internal` package, names of classes used in method signature (#3596).
+* Permission error when a database file was located on external storage (#3140).
+* Memory leak when unsubscribing from a RealmResults/RealmObject RxJava Observable (#3552).
+
+### Enhancements
+
+* `Realm.compactRealm()` now works for encrypted Realms.
+* Added `first(E defaultValue)` and `last(E defaultValue)` methods to `RealmList` and `RealmResult`. These methods will return the provided object instead of throwing an `IndexOutOfBoundsException` if the list is empty.
+* Reduce transformer logger verbosity (#3608).
+* `RealmLog.setLevel(int)` for setting the log level across all loggers.
+
+### Internal
+
+* Upgraded Realm Core to 2.1.3
+
+### Credits
+
+* Thanks to Max Furman (@maxfurman) for adding support for `first()` and `last()` default values.
+
+## 2.0.2
+
+This release is not protocol-compatible with previous versions of the Realm Mobile Platform. The base library is still fully compatible.
+
+### Bug fixes
+
+* Build error when using Java 7 (#3563).
+
+### Internal
+
+* Upgraded Realm Core to 2.1.0
+* Upgraded Realm Sync to 1.0.0-BETA-2.0.
+
+## 2.0.1
+
+### Bug fixes
+
+* `android.net.conn.CONNECTIVITY_CHANGE` broadcast caused `RuntimeException` if sync extension was disabled (#3505).
+* `android.net.conn.CONNECTIVITY_CHANGE` was not delivered on Android 7 devices.
+* `distinctAsync` did not respect other query parameters (#3537).
+* `ConcurrentModificationException` from Gradle when building an application (#3501).
+
+### Internal
+
+* Upgraded to Realm Core 2.0.1 / Realm Sync 1.3-BETA
+
+## 2.0.0
+
+This release introduces support for the Realm Mobile Platform!
+See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview of these great new features.
+
+### Breaking Changes
+
+* Files written by Realm 2.0 cannot be read by 1.x or earlier versions. Old files can still be opened.
+* It is now required to call `Realm.init(Context)` before calling any other Realm API.
+* Removed `RealmConfiguration.Builder(Context)`, `RealmConfiguration.Builder(Context, File)` and `RealmConfiguration.Builder(File)` constructors.
+* `isValid()` now always returns `true` instead of `false` for unmanaged `RealmObject` and `RealmList`. This puts it in line with the behaviour of the Cocoa and .NET API's (#3101).
+* armeabi is not supported anymore.
+* Added new `RealmFileException`.
+  - `IncompatibleLockFileException` has been removed and replaced by `RealmFileException` with kind `INCOMPATIBLE_LOCK_FILE`.
+  - `RealmIOExcpetion` has been removed and replaced by `RealmFileException`.
+* `RealmConfiguration.Builder.assetFile(Context, String)` has been renamed to `RealmConfiguration.Builder.assetFile(String)`.
+* Object with primary key is now required to define it when the object is created. This means that `Realm.createObject(Class<E>)` and `DynamicRealm.createObject(String)` now throws `RealmException` if they are used to create an object with a primary key field. Use `Realm.createObject(Class<E>, Object)` or `DynamicRealm.createObject(String, Object)` instead.
+* Importing from JSON without the primary key field defined in the JSON object now throws `IllegalArgumentException`.
+* Now `Realm.beginTransaction()`, `Realm.executeTransaction()` and `Realm.waitForChange()` throw `RealmMigrationNeededException` if a remote process introduces incompatible schema changes (#3409).
+* The primary key value of an object can no longer be changed after the object was created. Instead a new object must be created and all fields copied over.
+* Now `Realm.createObject(Class)` and `Realm.createObject(Class,Object)` take the values from the model's fields and default constructor. Creating objects through the `DynamicRealm` does not use these values (#777).
+* When `Realm.create*FromJson()`s create a new `RealmObject`, now they take the default values defined by the field itself and its default constructor for those fields that are not defined in the JSON object.
+
+### Enhancements
+
+* Added `realmObject.isManaged()`, `RealmObject.isManaged(obj)` and `RealmCollection.isManaged()` (#3101).
+* Added `RealmConfiguration.Builder.directory(File)`.
+* `RealmLog` has been moved to the public API. It is now possible to control which events Realm emit to Logcat. See the `RealmLog` class for more details.
+* Typed `RealmObject`s can now continue to access their fields properly even though the schema was changed while the Realm was open (#3409).
+* A `RealmMigrationNeededException` will be thrown with a cause to show the detailed message when a migration is needed and the migration block is not in the `RealmConfiguration`.
+
+
+### Bug fixes
+
+* Fixed a lint error in proxy classes when the 'minSdkVersion' of user's project is smaller than 11 (#3356).
+* Fixed a potential crash when there were lots of async queries waiting in the queue.
+* Fixed a bug causing the Realm Transformer to not transform field access in the model's constructors (#3361).
+* Fixed a bug causing a build failure when the Realm Transformer adds accessors to a model class that was already transformed in other project (#3469).
+* Fixed a bug causing the `NullPointerException` when calling getters/setters in the model's constructors (#2536).
+
+### Internal
+
+* Moved JNI build to CMake.
+* Updated Realm Core to 2.0.0.
+* Updated ReLinker to 1.2.2.
+
 ## 1.2.0
 
 ### Bug fixes
@@ -47,6 +229,7 @@
 ### Internal
 
 * Updated Realm Core to 1.4.2.
+* Improved sorting speed.
 
 ## 1.1.0
 
@@ -159,7 +342,7 @@ No changes since 0.91.1.
 * Removed `HandlerController` from the public API.
 * Removed constructor of `RealmAsyncTask` from the public API (#1594).
 * `RealmBaseAdapter` has been moved to its own GitHub repository: https://github.com/realm/realm-android-adapters
-  See https://github.com/realm/realm-android-adapters/README.md for further info on how to include it.
+  See https://github.com/realm/realm-android-adapters/blob/master/README.md for further info on how to include it.
 * File format of Realm files is changed. Files will be automatically upgraded but opening a Realm file with older
   versions of Realm is not possible.
 
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 117abc2ef9..e25a9af5f1 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -182,3 +182,19 @@ public RealmQuery<E> equalTo(String fieldName, String fieldValue, boolean caseSe
 
 Above is based on the official guidelines from Oracle regarding Javadoc: http://www.oracle.com/technetwork/articles/java/index-137868.html
 
+### Branch Strategy
+
+We have two branches for shared development: `master` and `releases`. We make releases from each.
+
+`master`:
+
+* The `master` branch is where major/minor versions are released from.
+* It is for new features and/or breaking changes.
+
+`releases`:
+
+* The releases branch is where patch versions are released from.
+* It is mainly for bug fixes.
+* Every commit is automatically merged to `master`.
+* Minor changes (e.g. to documentation, tests, and the build system) may not affect end users but should still be merged to `releases` to avoid diverging too far from `master` and to reduce the likelihood of merge conflicts.
+
diff --git a/Dockerfile b/Dockerfile
index 0029aaebbf..b3a8820a23 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -9,26 +9,42 @@ ENV LC_ALL "en_US.UTF-8"
 # Set the environment variables
 ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64
 ENV ANDROID_HOME /opt/android-sdk-linux
-ENV NDK_HOME /opt/android-ndk
+# Need by cmake
+ENV ANDROID_NDK_HOME /opt/android-ndk
+ENV ANDROID_NDK /opt/android-ndk
 ENV PATH ${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
 ENV PATH ${PATH}:${NDK_HOME}
+ENV NDK_CCACHE /usr/bin/ccache
+ENV NDK_LCACHE /usr/bin/lcache
 
-# Install the JDK
-# We are going to need some 32 bit binaries because aapt requires it
-# file is need by the script that creates NDK toolchains
+# The 32 bit binaries because aapt requires it
+# `file` is need by the script that creates NDK toolchains
+# Keep the packages in alphabetical order to make it easy to avoid duplication
 RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 \
     && apt-get update -qq \
-    && apt-get install -y file git curl wget zip unzip \
-                       bsdmainutils \
-                       build-essential \
-                       openjdk-8-jdk-headless \
-                       libc6:i386 libstdc++6:i386 libgcc1:i386 libncurses5:i386 libz1:i386 \
+    && apt-get install -y bsdmainutils \
+                          build-essential \
+                          ccache \
+                          curl \
+                          file \
+                          git \
+                          libc6:i386 \
+                          libgcc1:i386 \
+                          libncurses5:i386 \
+                          libstdc++6:i386 \
+                          libz1:i386 \
+                          openjdk-8-jdk-headless \
+                          s3cmd \
+                          unzip \
+                          wget \
+                          zip \
     && apt-get clean
 
 # Install the Android SDK
-RUN cd /opt && wget -q https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz -O android-sdk.tgz
-RUN cd /opt && tar -xvzf android-sdk.tgz
-RUN cd /opt && rm -f android-sdk.tgz
+RUN cd /opt && \
+    wget -q https://dl.google.com/android/repository/tools_r25.1.7-linux.zip -O android-tools-linux.zip && \
+    unzip android-tools-linux.zip -d ${ANDROID_HOME} && \
+    rm -f android-tools-linux.zip
 
 # Grab what's needed in the SDK
 # ↓ updates tools to at least 25.1.7, but that prints 'Nothing was installed' (so I don't check the outputs).
@@ -39,8 +55,25 @@ RUN echo y | android update sdk --no-ui --all --filter extra-android-m2repositor
 RUN echo y | android update sdk --no-ui --all --filter android-24 | grep 'package installed'
 
 # Install the NDK
-RUN mkdir /opt/android-ndk-tmp
-RUN cd /opt/android-ndk-tmp && wget -q http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin -O android-ndk.bin
-RUN cd /opt/android-ndk-tmp && chmod a+x ./android-ndk.bin && ./android-ndk.bin
-RUN cd /opt/android-ndk-tmp && mv ./android-ndk-r10e /opt/android-ndk
-RUN rm -rf /opt/android-ndk-tmp
+RUN mkdir /opt/android-ndk-tmp && \
+    cd /opt/android-ndk-tmp && \
+    wget -q http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin -O android-ndk.bin && \
+    chmod a+x ./android-ndk.bin && \
+    ./android-ndk.bin && \
+    mv android-ndk-r10e /opt/android-ndk && \
+    rm -rf /opt/android-ndk-tmp && \
+    chmod -R a+rX /opt/android-ndk
+
+# Install cmake
+RUN mkdir /opt/cmake-tmp && \
+    cd /opt/cmake-tmp && \
+    wget -q https://dl.google.com/android/repository/cmake-3.6.3133135-linux-x86_64.zip -O cmake-linux.zip && \
+    unzip cmake-linux.zip -d ${ANDROID_HOME}/cmake && \
+    rm -rf /opt/cmake-tmp
+
+# Make the SDK universally readable
+RUN chmod -R a+rX ${ANDROID_HOME}
+
+# Install lcache
+RUN wget -q https://github.com/beeender/lcache/releases/download/v0.0.2/lcache-linux -O /usr/bin/lcache && \
+    chmod +x /usr/bin/lcache
diff --git a/Jenkinsfile b/Jenkinsfile
index be329c01d2..364ad7d9fb 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -3,65 +3,112 @@
 import groovy.json.JsonOutput
 
 def buildSuccess = false
+def rosContainer
 try {
   node('android') {
     // Allocate a custom workspace to avoid having % in the path (it breaks ld)
     ws('/tmp/realm-java') {
-      stage 'SCM'
-      checkout scm
-      // Make sure not to delete the folder that Jenkins allocates to store scripts
-      sh 'git clean -ffdx -e .????????'
-
-      stage 'Docker build'
-      def buildEnv = docker.build 'realm-java:snapshot'
-      buildEnv.inside("--privileged -v /dev/bus/usb:/dev/bus/usb -v ${env.HOME}/gradle-cache:/root/.gradle -v /root/adbkeys:/root/.android") {
-        stage 'JVM tests'
-        try {
-          gradle 'assemble check javadoc'
-        } finally {
-          storeJunitResults 'realm/realm-annotations-processor/build/test-results/TEST-*.xml'
-          storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
-          step([$class: 'LintPublisher'])
-        }
-
-        stage 'Static code analysis'
-        try {
-          gradle('realm', 'findbugs pmd checkstyle')
-        } finally {
-          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
-          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
-          step([$class: 'CheckStylePublisher',
-          canComputeNew: false,
-          defaultEncoding: '',
-          healthy: '',
-          pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
-          unHealthy: ''
-          ])
-        }
-
-        stage 'Run instrumented tests'
-        boolean archiveLog = true
-        String backgroundPid
-        try {
-          backgroundPid = startLogCatCollector()
-          gradle('realm', 'connectedUnitTests')
-          archiveLog = false;
-        } finally {
-          stopLogCatCollector(backgroundPid, archiveLog)
-          storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/TEST-*.xml'
-        }
-
-        // TODO: add support for running monkey on the example apps
-
-        if (env.BRANCH_NAME == 'master') {
-          stage 'Collect metrics'
-          collectAarMetrics()
-
-          stage 'Publish to OJO'
-          withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
-            sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+      stage('SCM') {
+        checkout([
+          $class: 'GitSCM',
+          branches: scm.branches,
+          gitTool: 'native git',
+          extensions: scm.extensions + [
+            [$class: 'CleanCheckout'],
+            [$class: 'SubmoduleOption', recursiveSubmodules: true]
+          ],
+          userRemoteConfigs: scm.userRemoteConfigs
+        ])
+      }
+
+      def buildEnv
+      def rosEnv
+      stage('Docker build') {
+        // Clean any potential old containers
+        sh 'docker rm ros || true' 
+
+        // Docker image for build
+        buildEnv = docker.build 'realm-java:snapshot'
+        // Docker image for testing Realm Object Server
+        def dependProperties = readProperties file: 'dependencies.list'
+        def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
+        rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
+      }
+
+      rosContainer = rosEnv.run("-v /tmp=/tmp/.ros " +
+              "--name ros")
+
+      try {
+          buildEnv.inside("-e HOME=/tmp " +
+                  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
+                  "--privileged " +
+                  "-v /dev/bus/usb:/dev/bus/usb " +
+                  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
+                  "-v ${env.HOME}/.android:/tmp/.android " +
+                  "-v ${env.HOME}/ccache:/tmp/.ccache " +
+                  "-v ${env.HOME}/lcache:/tmp/.lcache " +
+                  "--network container:ros") {
+            stage('JVM tests') {
+              try {
+                withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
+                  sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG}"
+                }
+              } finally {
+                storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
+                storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+                step([$class: 'LintPublisher'])
+              }
+            }
+
+            stage('Static code analysis') {
+              try {
+                gradle('realm', 'findbugs pmd checkstyle')
+              } finally {
+                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
+                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
+                step([$class: 'CheckStylePublisher',
+                canComputeNew: false,
+                defaultEncoding: '',
+                healthy: '',
+                pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+                unHealthy: ''
+                ])
+              }
+            }
+
+            stage('Run instrumented tests') {
+              lock("${env.NODE_NAME}-android") {
+                boolean archiveLog = true
+                String backgroundPid
+                try {
+                  backgroundPid = startLogCatCollector()
+                  forwardAdbPorts()
+                  gradle('realm', 'connectedUnitTests')
+                  archiveLog = false;
+                } finally {
+                  stopLogCatCollector(backgroundPid, archiveLog)
+                  storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+                }
+              }
+            }
+
+            // TODO: add support for running monkey on the example apps
+
+            if (env.BRANCH_NAME == 'master') {
+              stage('Collect metrics') {
+                collectAarMetrics()
+              }
+
+              stage('Publish to OJO') {
+                withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
+                  sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+                }
+              }
+            }
           }
-        }
+      } finally {
+          sh "docker logs ros"
+          rosContainer.stop()
       }
     }
   }
@@ -72,16 +119,16 @@ try {
   buildSuccess = false
   throw e
 } finally {
-  if (['master', 'releases'].contains(env.BRANCH_NAME)) {
+  if (['master', 'releases'].contains(env.BRANCH_NAME) && !buildSuccess) {
     node {
       withCredentials([[$class: 'StringBinding', credentialsId: 'slack-java-url', variable: 'SLACK_URL']]) {
         def payload = JsonOutput.toJson([
           username: 'Mr. Jenkins',
           icon_emoji: ':jenkins:',
           attachments: [[
-            'title': "The ${env.BRANCH_NAME} branch is ${buildSuccess?'healthy.':'broken!'}",
+            'title': "The ${env.BRANCH_NAME} branch is broken!",
             'text': "<${env.BUILD_URL}|Click here> to check the build.",
-            'color': "${buildSuccess?'good':'danger'}"
+            'color': "danger"
           ]]
         ])
         sh "curl -X POST --data-urlencode \'payload=${payload}\' ${env.SLACK_URL}"
@@ -90,6 +137,12 @@ try {
   }
 }
 
+def forwardAdbPorts() {
+  sh ''' adb reverse tcp:7800 tcp:7800 &&
+      adb reverse tcp:8080 tcp:8080 &&
+      adb reverse tcp:8888 tcp:8888
+  '''
+}
 
 def String startLogCatCollector() {
   sh '''adb logcat -c
@@ -108,19 +161,19 @@ def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
       'glob' : 'logcat.txt'
     ])
   }
-  sh 'rm logcat.txt '
+  sh 'rm logcat.txt'
 }
 
-def sendMetrics(String metric, String value) {
+def sendMetrics(String metricName, String metricValue, Map<String, String> tags) {
+  def tagsString = getTagsString(tags)
   withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
-    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
+    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metricName},${tagsString} value=${metricValue}i' --user '${env.influx_user}:${env.influx_pass}'"
   }
 }
 
-def sendTaggedMetric(String metric, String value, String tagName, String tagValue) {
-  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
-    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric},${tagName}=${tagValue} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
-  }
+@NonCPS
+def getTagsString(Map<String, String> tags) {
+  return tags.collect { k,v -> "$k=$v" }.join(',')
 }
 
 def storeJunitResults(String path) {
@@ -131,24 +184,30 @@ def storeJunitResults(String path) {
 }
 
 def collectAarMetrics() {
-  sh '''set -xe
-  cd realm/realm-library/build/outputs/aar
-  unzip realm-android-library-release.aar -d unzipped
-  find $ANDROID_HOME -name dx | sort -r | head -n 1 > dx
-  $(cat dx) --dex --output=temp.dex unzipped/classes.jar
-  cat temp.dex | head -c 92 | tail -c 4 | hexdump -e '1/4 "%d"' > methods
-  '''
-
-  sendMetrics('methods', readFile('realm/realm-library/build/outputs/aar/methods'))
-
-  def aarFile = findFiles(glob: 'realm/realm-library/build/outputs/aar/realm-android-library-release.aar')[0]
-  sendMetrics('aar_size', aarFile.length as String)
-
-  def soFiles = findFiles(glob: 'realm/realm-library/build/outputs/aar/unzipped/jni/*/librealm-jni.so')
-  for (int i = 0; i < soFiles.length; i++) {
-      def abiName = soFiles[i].path.tokenize('/')[-2]
-      def libSize = soFiles[i].length as String
-      sendTaggedMetric('abi_size', libSize, 'type', abiName)
+  def flavors = ['base', 'objectServer']
+  for (def i = 0; i < flavors.size(); i++) {
+    def flavor = flavors[i]
+    sh """set -xe
+      cd realm/realm-library/build/outputs/aar
+      unzip realm-android-library-${flavor}-release.aar -d unzipped${flavor}
+      find \$ANDROID_HOME -name dx | sort -r | head -n 1 > dx
+      \$(cat dx) --dex --output=temp${flavor}.dex unzipped${flavor}/classes.jar
+      cat temp${flavor}.dex | head -c 92 | tail -c 4 | hexdump -e '1/4 \"%d\"' > methods${flavor}
+    """
+
+    def methods = readFile("realm/realm-library/build/outputs/aar/methods${flavor}")
+    sendMetrics('methods', methods, ['flavor':flavor])
+
+    def aarFile = findFiles(glob: "realm/realm-library/build/outputs/aar/realm-android-library-${flavor}-release.aar")[0]
+    sendMetrics('aar_size', aarFile.length as String, ['flavor':flavor])
+
+    def soFiles = findFiles(glob: "realm/realm-library/build/outputs/aar/unzipped${flavor}/jni/*/librealm-jni.so")
+    for (def j = 0; j < soFiles.size(); j++) {
+        def soFile = soFiles[j]
+        def abiName = soFile.path.tokenize('/')[-2]
+        def libSize = soFile.length as String
+        sendMetrics('abi_size', libSize, ['flavor':flavor, 'type':abiName])
+    }
   }
 }
 
diff --git a/LICENSE b/LICENSE
index 62e2f9e364..273b4d5f7b 100644
--- a/LICENSE
+++ b/LICENSE
@@ -4,7 +4,7 @@ TABLE OF CONTENTS
 2. Realm Components
 3. Export Compliance
 
--------------------------------------------------------------------------------
+1. -------------------------------------------------------------------------------
 
                                  Apache License
                            Version 2.0, January 2004
@@ -183,31 +183,7 @@ TABLE OF CONTENTS
 
    END OF TERMS AND CONDITIONS
 
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright {yyyy} {name of copyright owner}
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
+2. -------------------------------------------------------------------------------
 
 REALM COMPONENTS
 
@@ -215,11 +191,11 @@ This software contains components with separate copyright and license terms.
 Your use of these components is subject to the terms and conditions of the
 following licenses.
 
-For the Realm Core component
+For the Realm Platform Extensions component
 
-  Realm Core Binary License
+  Realm Platform Extensions License
 
-  Copyright (c) 2011-2015 Realm Inc All rights reserved
+  Copyright (c) 2011-2016 Realm Inc All rights reserved
 
   Redistribution and use in binary form, with or without modification, is
   permitted provided that the following conditions are met:
@@ -250,6 +226,8 @@ For the Realm Core component
   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
 
+3. -------------------------------------------------------------------------------
+
 EXPORT COMPLIANCE
 
 You understand that the Software may contain cryptographic functions that may be
diff --git a/README.md b/README.md
index 6a24fa16f7..1496891c4c 100644
--- a/README.md
+++ b/README.md
@@ -42,9 +42,11 @@ buildscript {
     }
 }
 
-repositories {
-    maven {
-        url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
+allprojects {
+    repositories {
+        maven {
+            url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
+        }
     }
 }
 ```
@@ -55,12 +57,12 @@ See [version.txt](version.txt) for the latest version number.
 
 In case you don't want to use the precompiled version, you can build Realm yourself from source.
 
-Prerequisites:
+### Prerequisites
 
- * Make sure `make` is available in your `$PATH`
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studio’s **Android SDK Manager**)
+ * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studio’s **Android SDK Manager**).
  * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
+ * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
  * Or you can use [Hombrew-versions](https://github.com/Homebrew/homebrew-versions) to install Android NDK for Mac:
 
     ```
@@ -72,14 +74,20 @@ Prerequisites:
 
     ```
     export ANDROID_HOME=~/Library/Android/sdk
-    export NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
+    export ANDROID_NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
+    ```
+
+ * If you want to build with Android Studio, `ndk.dir` has to be defined in the `realm/local.properties` as well.
+
+    ```
+    ndk.dir=/usr/local/Cellar/android-ndk-r10e/r10e
     ```
 
  * If you are using OS X, you'd be better to add following lines to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see those environment variables.
 
     ```
     launchctl setenv ANDROID_HOME "$ANDROID_HOME"
-    launchctl setenv NDK_HOME "$NDK_HOME"
+    launchctl setenv ANDROID_NDK_HOME "$ANDROID_NDK_HOME"
     ```
 
  * And if you'd like to specify the location to store the archives of Realm's core, set `REALM_CORE_DOWNLOAD_DIR` environment variable. It enables you to keep core's archive when executing `git clean -xfd`.
@@ -94,6 +102,22 @@ Prerequisites:
    launchctl setenv REALM_CORE_DOWNLOAD_DIR "$REALM_CORE_DOWNLOAD_DIR"
    ```
 
+### Download sources
+
+You can download the source code of Realm Java by using git. Since realm-java has git submodules, use `--recursive` when cloning the repository.
+
+```
+git clone git@github.com:realm/realm-java.git --recursive
+```
+
+or
+
+```
+git clone https://github.com/realm/realm-java.git --recursive
+```
+
+### Build
+
 Once you have completed all the pre-requisites building Realm is done with a simple command
 
 ```
@@ -139,6 +163,30 @@ The `./examples` folder contain a number of example projects showing how Realm c
 
 Standalone examples can be [downloaded from website](https://realm.io/docs/java/latest/#getting-started).
 
+## Running Tests Using The Realm Object Server
+
+Tests in `realm/realm-library/src/syncIntegrationTest` require a running testing server to work.
+A docker image can be built from `tools/sync_test_server/Dockerfile` to run the test server.
+`tools/sync_test_server/start_server.sh` will build the docker image automatically.
+
+To run a testing server locally:
+
+1. Install docker.
+
+2. Run `tools/sync_test_server/start_server.sh`:
+
+```sh
+cd tools/sync_test_server
+./start_server.sh
+```
+
+3. Run instrumentation tests:
+
+```sh
+cd realm
+./gradlew connectedObjectServerDebugAndroidTest
+```
+
 ## Contributing
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
diff --git a/build.gradle b/build.gradle
index 43db7f348b..cd7c5facad 100644
--- a/build.gradle
+++ b/build.gradle
@@ -14,7 +14,7 @@ def currentVersion = file("${projectDir}/version.txt").text.trim();
 def props = new Properties()
 props.load(new FileInputStream("${rootDir}/realm.properties"))
 props.each { key, val ->
-    project.set(key, val)
+    project.ext.set(key, val)
 }
 
 task assembleAnnotations(type:GradleBuild) {
@@ -28,7 +28,7 @@ task installAnnotations(type:GradleBuild) {
     group = 'Install'
     description = 'Install the jar realm-annotations into mavenLocal()'
     buildFile = file('realm-annotations/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
 }
 
 task assembleTransformer(type:GradleBuild) {
@@ -44,7 +44,7 @@ task installTransformer(type:GradleBuild) {
     description = 'Install the jar realm-transformer into mavenLocal()'
     dependsOn installAnnotations
     buildFile = file('realm-transformer/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
 }
 
 task assembleRealm(type:GradleBuild) {
@@ -57,6 +57,9 @@ task assembleRealm(type:GradleBuild) {
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
+    if (project.hasProperty('s3cfg')) {
+        startParameter.projectProperties += [s3cfg: project.getProperty('s3cfg')]
+    }
 }
 
 task checkExamples(type:GradleBuild) {
@@ -102,10 +105,13 @@ task installRealm(type:GradleBuild) {
     description = 'Install the artifacts of Realm libraries into mavenLocal()'
     dependsOn installTransformer
     buildFile = file('realm/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
+    if (project.hasProperty('s3cfg')) {
+        startParameter.projectProperties += [s3cfg: project.getProperty('s3cfg')]
+    }
 }
 
 task assembleGradlePlugin(type:GradleBuild) {
@@ -123,7 +129,7 @@ task installGradlePlugin(type:GradleBuild) {
     dependsOn installRealm
     dependsOn installTransformer
     buildFile = file('gradle-plugin/build.gradle')
-    tasks = ['install']
+    tasks = ['publishToMavenLocal']
 }
 
 task installRealmJava(type:Task) {
@@ -213,7 +219,7 @@ task distributionJniUnstrippedPackage(type:Zip) {
     archiveName = "realm-java-jni-libs-unstripped-${currentVersion}.zip"
     destinationDir = file("${buildDir}/outputs/distribution")
 
-    from("realm/realm-jni/build/outputs/jniLibs-unstripped") {
+    from("realm/realm-library/build/outputs/jniLibs-unstripped") {
         include '**/*.so'
     }
 }
@@ -348,7 +354,7 @@ task ojoRealm(type: GradleBuild) {
     description = 'Publish the Realm AAR and AP SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
-    tasks = ['artifactoryPublish']
+    tasks = ['ojoUpload']
     startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
diff --git a/dependencies.list b/dependencies.list
new file mode 100644
index 0000000000..e1ea9c6811
--- /dev/null
+++ b/dependencies.list
@@ -0,0 +1,8 @@
+# Realm Sync Core release used by Realm Java
+# https://github.com/realm/realm-sync/releases
+REALM_SYNC_VERSION=1.0.0-BETA-5.0
+REALM_SYNC_SHA256=7bbaa9cdef722d85489feb1b70da11d5640869540d9a0fc40621de7352dd9ffd
+
+# Object Server Release used by Integration tests
+# https://packagecloud.io/realm/realm?filter=debs
+REALM_OBJECT_SERVER_DE_VERSION=1.0.0-BETA-4.11-449
diff --git a/examples/build.gradle b/examples/build.gradle
index 47be4e4ca1..64b863d9f8 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -16,7 +16,7 @@ allprojects {
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:2.1.0'
+            classpath 'com.android.tools.build:gradle:2.2.0'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
             classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
diff --git a/examples/encryptionExample/lint.xml b/examples/encryptionExample/lint.xml
index 0666c5455c..6793b0702b 100644
--- a/examples/encryptionExample/lint.xml
+++ b/examples/encryptionExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="TrulyRandom" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/encryptionExample/src/main/AndroidManifest.xml b/examples/encryptionExample/src/main/AndroidManifest.xml
index b3bb0e1028..00f9f6c7be 100644
--- a/examples/encryptionExample/src/main/AndroidManifest.xml
+++ b/examples/encryptionExample/src/main/AndroidManifest.xml
@@ -1,8 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.examples.encryptionexample">
+<manifest package="io.realm.examples.encryptionexample"
+          xmlns:android="http://schemas.android.com/apk/res/android">
 
     <application
+        android:name=".MyApplication"
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
@@ -12,8 +13,8 @@
             android:configChanges="keyboardHidden|orientation|screenSize"
             android:label="Realm Encryption Example">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
     </application>
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
index edf66fdaef..d40a95ce1a 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
@@ -42,7 +42,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // * http://nelenkov.blogspot.dk/2012/05/storing-application-secrets-in-androids.html
         byte[] key = new byte[64];
         new SecureRandom().nextBytes(key);
-        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this)
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder()
                 .encryptionKey(key)
                 .build();
 
diff --git a/realm/realm-jni/src/java_lang_List_Util.hpp b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/MyApplication.java
similarity index 65%
rename from realm/realm-jni/src/java_lang_List_Util.hpp
rename to examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/MyApplication.java
index a360a247b4..83fc8be016 100644
--- a/realm/realm-jni/src/java_lang_List_Util.hpp
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/MyApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,20 +14,17 @@
  * limitations under the License.
  */
 
-#ifndef JAVA_LANG_LIST_UTIL_H
-#define JAVA_LANG_LIST_UTIL_H
+package io.realm.examples.encryptionexample;
 
-#include <jni.h>
+import android.app.Application;
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+import io.realm.Realm;
 
-jint java_lang_List_size(JNIEnv* env, jobject jList);
-jobject java_lang_List_get(JNIEnv* env, jobject jList, jint index);
+public class MyApplication extends Application {
 
-#ifdef __cplusplus
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
+    }
 }
-#endif
-
-#endif
diff --git a/examples/gradle.properties b/examples/gradle.properties
new file mode 100644
index 0000000000..4a9594aeec
--- /dev/null
+++ b/examples/gradle.properties
@@ -0,0 +1 @@
+org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..f930473763 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:25:59 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/examples/gradlew b/examples/gradlew
index 97fac783e1..27309d9231 100755
--- a/examples/gradlew
+++ b/examples/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/examples/gradlew.bat b/examples/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/examples/gradlew.bat
+++ b/examples/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/examples/gridViewExample/lint.xml b/examples/gridViewExample/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/gridViewExample/lint.xml
+++ b/examples/gridViewExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/gridViewExample/src/main/AndroidManifest.xml b/examples/gridViewExample/src/main/AndroidManifest.xml
index 1bf1d8752c..45615afd2b 100644
--- a/examples/gridViewExample/src/main/AndroidManifest.xml
+++ b/examples/gridViewExample/src/main/AndroidManifest.xml
@@ -3,6 +3,7 @@
     package="io.realm.examples.realmgridview">
 
     <application
+        android:name=".MyApplication"
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index 759b451b8c..c37961ae44 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -54,7 +54,7 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_realm_example);
 
-        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder().build();
 
         // Clear the realm from last time
         Realm.deleteRealm(realmConfiguration);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/MyApplication.java
similarity index 64%
rename from realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
rename to examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/MyApplication.java
index bf2de63996..2cef075c10 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/MyApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +14,17 @@
  * limitations under the License.
  */
 
-package io.realm.internal.android;
+package io.realm.examples.realmgridview;
 
-import io.realm.internal.log.RealmLog;
+import android.app.Application;
 
-/**
- * RealmLogger for Android debug builds. This logs everything as default.
- */
-public class DebugAndroidLogger extends AndroidLogger {
+import io.realm.Realm;
+
+public class MyApplication extends Application {
 
-    public DebugAndroidLogger() {
-        setMinimumLogLevel(RealmLog.VERBOSE);
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
     }
 }
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index d61e93b5a3..6559bb309a 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -1,6 +1,5 @@
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
-apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'realm-android'
 
 android {
diff --git a/examples/introExample/lint.xml b/examples/introExample/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/introExample/lint.xml
+++ b/examples/introExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/introExample/src/main/AndroidManifest.xml b/examples/introExample/src/main/AndroidManifest.xml
index f23c433da2..b98d60f027 100644
--- a/examples/introExample/src/main/AndroidManifest.xml
+++ b/examples/introExample/src/main/AndroidManifest.xml
@@ -5,6 +5,7 @@
     <application
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
+        android:name=".MyApplication"
         android:theme="@style/AppTheme" >
         <activity
             android:name=".IntroExampleActivity"
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index 668f954d24..faa6b1eb78 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -24,7 +24,6 @@
 import android.widget.TextView;
 
 import io.realm.Realm;
-import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
 import io.realm.Sort;
 import io.realm.examples.intro.model.Cat;
@@ -37,7 +36,6 @@
     private LinearLayout rootLayout = null;
 
     private Realm realm;
-    private RealmConfiguration realmConfig;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -49,10 +47,8 @@ protected void onCreate(Bundle savedInstanceState) {
         // These operations are small enough that
         // we can generally safely run them on the UI thread.
 
-        // Create the Realm configuration
-        realmConfig = new RealmConfiguration.Builder(this).build();
-        // Open the Realm for the UI thread.
-        realm = Realm.getInstance(realmConfig);
+        // Create the Realm instance
+        realm = Realm.getDefaultInstance();
 
         basicCRUD(realm);
         basicQuery(realm);
@@ -148,9 +144,9 @@ private void basicLinkQuery(Realm realm) {
     private String complexReadWrite() {
         String status = "\nPerforming complex Read/Write operation...";
 
-        // Open the default realm. All threads must use it's own reference to the realm.
+        // Open the default realm. All threads must use its own reference to the realm.
         // Those can not be transferred across threads.
-        Realm realm = Realm.getInstance(realmConfig);
+        Realm realm = Realm.getDefaultInstance();
 
         // Add ten persons in one transaction
         realm.executeTransaction(new Realm.Transaction() {
@@ -206,7 +202,7 @@ public void execute(Realm realm) {
     private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
-        Realm realm = Realm.getInstance(realmConfig);
+        Realm realm = Realm.getDefaultInstance();
         status += "\nNumber of persons: " + realm.where(Person.class).count();
 
         // Find all persons where age between 7 and 9 and name begins with "Person".
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java b/examples/introExample/src/main/java/io/realm/examples/intro/MyApplication.java
similarity index 61%
rename from realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
rename to examples/introExample/src/main/java/io/realm/examples/intro/MyApplication.java
index ce7e28966f..45e40f3748 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/MyApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +14,18 @@
  * limitations under the License.
  */
 
-package io.realm.internal.android;
+package io.realm.examples.intro;
 
-import io.realm.internal.log.RealmLog;
+import android.app.Application;
 
-/**
- * This is the RealmLogger used by Realm in Release builds. It only logs warnings and errors by default.
- */
-public class ReleaseAndroidLogger extends AndroidLogger {
+import io.realm.Realm;
+
+public class MyApplication extends Application {
 
-    public ReleaseAndroidLogger() {
-        setMinimumLogLevel(RealmLog.WARN);
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // Initialize Realm. Should only be done once when the application starts.
+        Realm.init(this);
     }
 }
diff --git a/examples/jsonExample/lint.xml b/examples/jsonExample/lint.xml
index 6a7edc9890..a443370a1a 100644
--- a/examples/jsonExample/lint.xml
+++ b/examples/jsonExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/jsonExample/src/main/AndroidManifest.xml b/examples/jsonExample/src/main/AndroidManifest.xml
index 7c50dd72f8..4183198de1 100644
--- a/examples/jsonExample/src/main/AndroidManifest.xml
+++ b/examples/jsonExample/src/main/AndroidManifest.xml
@@ -3,6 +3,7 @@
     package="io.realm.examples.json">
 
     <application
+        android:name=".MyApplication"
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
index 233a563017..1e00b55e85 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
@@ -46,7 +46,7 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_realm_example);
 
-        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(realmConfiguration);
         realm = Realm.getInstance(realmConfiguration);
     }
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/MyApplication.java b/examples/jsonExample/src/main/java/io/realm/examples/json/MyApplication.java
new file mode 100644
index 0000000000..15c1a8e387
--- /dev/null
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/MyApplication.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.json;
+
+import android.app.Application;
+
+import io.realm.Realm;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
+    }
+}
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index a7baf526da..8741e4a82f 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.0.3'
+    ext.kotlin_version = '1.0.4'
     repositories {
         jcenter()
         mavenCentral()
@@ -51,6 +51,5 @@ android {
 
 dependencies {
     compile "org.jetbrains.kotlin:kotlin-stdlib:${kotlin_version}"
-    compile "org.jetbrains.kotlin:kotlin-reflect:${kotlin_version}"
     compile 'org.jetbrains.anko:anko-sdk15:0.8.2'
 }
diff --git a/examples/kotlinExample/lint.xml b/examples/kotlinExample/lint.xml
index cc4d461aee..7d530f741e 100644
--- a/examples/kotlinExample/lint.xml
+++ b/examples/kotlinExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/kotlinExample/src/main/AndroidManifest.xml b/examples/kotlinExample/src/main/AndroidManifest.xml
index 3373613527..eecca70a66 100644
--- a/examples/kotlinExample/src/main/AndroidManifest.xml
+++ b/examples/kotlinExample/src/main/AndroidManifest.xml
@@ -2,6 +2,7 @@
           xmlns:android="http://schemas.android.com/apk/res/android">
 
     <application
+        android:name=".MyApplication"
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 5c6c37f1ec..d903e5a208 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -23,7 +23,6 @@ import android.widget.LinearLayout
 import android.widget.TextView
 import io.realm.Realm
 import io.realm.Sort
-import io.realm.RealmConfiguration
 import io.realm.examples.kotlin.model.Cat
 import io.realm.examples.kotlin.model.Dog
 import io.realm.examples.kotlin.model.Person
@@ -31,16 +30,14 @@ import org.jetbrains.anko.async
 import org.jetbrains.anko.uiThread
 import kotlin.properties.Delegates
 
-
 class KotlinExampleActivity : Activity() {
 
     companion object {
-        val TAG: String = KotlinExampleActivity::class.qualifiedName as String
+        val TAG: String = KotlinExampleActivity::class.java.simpleName
     }
 
     private var rootLayout: LinearLayout by Delegates.notNull()
     private var realm: Realm by Delegates.notNull()
-    private var realmConfig: RealmConfiguration by Delegates.notNull()
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
@@ -51,12 +48,8 @@ class KotlinExampleActivity : Activity() {
         // These operations are small enough that
         // we can generally safely run them on the UI thread.
 
-        // Create configuration and reset Realm.
-        realmConfig = RealmConfiguration.Builder(this).build()
-        Realm.deleteRealm(realmConfig)
-
         // Open the realm for the UI thread.
-        realm = Realm.getInstance(realmConfig)
+        realm = Realm.getDefaultInstance()
 
         basicCRUD(realm)
         basicQuery(realm)
@@ -100,14 +93,13 @@ class KotlinExampleActivity : Activity() {
         // All writes must be wrapped in a transaction to facilitate safe multi threading
         realm.executeTransaction {
             // Add a person
-            var person = realm.createObject(Person::class.java)
-            person.id = 1
+            val person = realm.createObject(Person::class.java, 1)
             person.name = "Young Person"
             person.age = 14
         }
 
         // Find the first person (no query conditions) and read a field
-        var person = realm.where(Person::class.java).findFirst()
+        val person = realm.where(Person::class.java).findFirst()
         showStatus(person.name + ": " + person.age)
 
         // Update person in a transaction
@@ -139,9 +131,9 @@ class KotlinExampleActivity : Activity() {
     private fun complexReadWrite(): String {
         var status = "\nPerforming complex Read/Write operation..."
 
-        // Open the default realm. All threads must use it's own reference to the realm.
+        // Open the default realm. All threads must use its own reference to the realm.
         // Those can not be transferred across threads.
-        val realm = Realm.getInstance(realmConfig)
+        val realm = Realm.getDefaultInstance()
 
         // Add ten persons in one transaction
         realm.executeTransaction {
@@ -184,7 +176,7 @@ class KotlinExampleActivity : Activity() {
         }
 
         // Sorting
-        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING);
+        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
         check(realm.where(Person::class.java).findAll().last().name == sortedPersons.first().name)
         status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
 
@@ -197,7 +189,7 @@ class KotlinExampleActivity : Activity() {
 
         // Realm implements the Closable interface, therefore we can make use of Kotlin's built-in
         // extension method 'use' (pun intended).
-        Realm.getInstance(realmConfig).use {
+        Realm.getDefaultInstance().use {
             // 'it' is the implicit lambda parameter of type Realm
             status += "\nNumber of persons: ${it.where(Person::class.java).count()}"
 
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/MyApplication.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/MyApplication.kt
new file mode 100644
index 0000000000..a4b9665a3b
--- /dev/null
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/MyApplication.kt
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin
+
+import android.app.Application
+
+import io.realm.Realm
+
+class MyApplication : Application() {
+
+    override fun onCreate() {
+        super.onCreate()
+        // Initialize Realm. Should only be done once when the application starts.
+        Realm.init(this)
+    }
+}
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
index 36deb5c3dc..c408a12472 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
@@ -30,7 +30,9 @@ open class Person(
         // All properties are by default persisted.
         // Properties can be annotated with PrimaryKey or Index.
         // If you use non-nullable types, properties must be initialized with non-null values.
-        @PrimaryKey open var name: String = "",
+        @PrimaryKey open var id: Long = 0,
+
+        open var name: String = "",
 
         open var age: Int = 0,
 
@@ -41,9 +43,8 @@ open class Person(
         open var cats: RealmList<Cat> = RealmList(),
 
         // You can instruct Realm to ignore a field and not persist it.
-        @Ignore open var tempReference: Int = 0,
+        @Ignore open var tempReference: Int = 0
 
-        open var id: Long = 0
 ) : RealmObject() {
     // The Kotlin compiler generates standard getters and setters.
     // Realm will overload them and code inside them is ignored.
diff --git a/examples/migrationExample/lint.xml b/examples/migrationExample/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/migrationExample/lint.xml
+++ b/examples/migrationExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/migrationExample/src/main/AndroidManifest.xml b/examples/migrationExample/src/main/AndroidManifest.xml
index b21664e66a..255b3327bc 100644
--- a/examples/migrationExample/src/main/AndroidManifest.xml
+++ b/examples/migrationExample/src/main/AndroidManifest.xml
@@ -3,6 +3,7 @@
     package="io.realm.examples.realmmigrationexample" >
 
     <application
+        android:name=".MyApplication"
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
index c96ccdabc4..5d86249c17 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
@@ -53,14 +53,14 @@ protected void onCreate(Bundle savedInstanceState) {
         rootLayout.removeAllViews();
 
         // 3 versions of the databases for testing. Normally you would only have one.
-        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default0), "default0");
-        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default1), "default1");
-        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default2), "default2");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default0), "default0.realm");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default1), "default1.realm");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default2), "default2.realm");
 
         // When you create a RealmConfiguration you can specify the version of the schema.
         // If the schema does not have that version a RealmMigrationNeededException will be thrown.
-        RealmConfiguration config0 = new RealmConfiguration.Builder(this)
-                .name("default0")
+        RealmConfiguration config0 = new RealmConfiguration.Builder()
+                .name("default0.realm")
                 .schemaVersion(3)
                 .build();
 
@@ -77,8 +77,8 @@ protected void onCreate(Bundle savedInstanceState) {
 
         // Or you can add the migration code to the configuration. This will run the migration code without throwing
         // a RealmMigrationNeededException.
-        RealmConfiguration config1 = new RealmConfiguration.Builder(this)
-                .name("default1")
+        RealmConfiguration config1 = new RealmConfiguration.Builder()
+                .name("default1.realm")
                 .schemaVersion(3)
                 .migration(new Migration())
                 .build();
@@ -90,8 +90,8 @@ protected void onCreate(Bundle savedInstanceState) {
 
         // or you can set .deleteRealmIfMigrationNeeded() if you don't want to bother with migrations.
         // WARNING: This will delete all data in the Realm though.
-        RealmConfiguration config2 = new RealmConfiguration.Builder(this)
-                .name("default2")
+        RealmConfiguration config2 = new RealmConfiguration.Builder()
+                .name("default2.realm")
                 .schemaVersion(3)
                 .deleteRealmIfMigrationNeeded()
                 .build();
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MyApplication.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MyApplication.java
new file mode 100644
index 0000000000..a41c19048a
--- /dev/null
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MyApplication.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.realmmigrationexample;
+
+import android.app.Application;
+
+import io.realm.Realm;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
+    }
+}
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index 957f094945..c8e16e60d3 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -25,9 +25,8 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled true
-            proguardFiles getDefaultProguardFile('proguard-android.txt'),
-                    'proguard-rules.pro'
+            minifyEnabled false // FIXME Why is this suddenly broken?
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
             signingConfig signingConfigs.release
         }
     }
diff --git a/examples/moduleExample/app/lint.xml b/examples/moduleExample/app/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/moduleExample/app/lint.xml
+++ b/examples/moduleExample/app/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/moduleExample/app/src/main/AndroidManifest.xml b/examples/moduleExample/app/src/main/AndroidManifest.xml
index c5aaf2017b..9d91b1c020 100644
--- a/examples/moduleExample/app/src/main/AndroidManifest.xml
+++ b/examples/moduleExample/app/src/main/AndroidManifest.xml
@@ -3,6 +3,7 @@
     package="io.realm.examples.appmodules" >
 
     <application
+        android:name=".MyApplication"
         android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index 246bafadfc..1d2cb4a177 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -58,19 +58,19 @@ protected void onCreate(Bundle savedInstanceState) {
         // The default Realm instance implicitly knows about all classes in the realmModuleAppExample Android Studio
         // module. This does not include the classes from the realmModuleLibraryExample AS module so a Realm using this
         // configuration would know about the following classes: { Cow, Pig, Snake, Spider }
-        RealmConfiguration defaultConfig = new RealmConfiguration.Builder(this).build();
+        RealmConfiguration defaultConfig = new RealmConfiguration.Builder().build();
 
         // It is possible to extend the default schema by adding additional Realm modules using modules(). This can
         // also be Realm modules from libraries. The below Realm contains the following classes: { Cow, Pig, Snake,
         // Spider, Cat, Dog }
-        RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder(this)
+        RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder()
                 .name("farm.realm")
                 .modules(Realm.getDefaultModule(), new DomesticAnimalsModule())
                 .build();
 
         // Or you can completely replace the default schema.
         // This Realm contains the following classes: { Elephant, Lion, Zebra, Snake, Spider }
-        RealmConfiguration exoticAnimalsConfig = new RealmConfiguration.Builder(this)
+        RealmConfiguration exoticAnimalsConfig = new RealmConfiguration.Builder()
                 .name("exotic.realm")
                 .modules(new ZooAnimalsModule(), new CreepyAnimalsModule())
                 .build();
@@ -144,7 +144,7 @@ public void execute(Realm realm) {
         // And Realms in library projects are independent from Realms in the app code
         showStatus("Interacting with library code that uses Realm internally");
         int animals = 5;
-        Zoo libraryZoo = new Zoo(this);
+        Zoo libraryZoo = new Zoo();
         libraryZoo.open();
         showStatus("Adding animals: " + animals);
         libraryZoo.addAnimals(5);
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/MyApplication.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/MyApplication.java
new file mode 100644
index 0000000000..61afd4ba36
--- /dev/null
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/MyApplication.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules;
+
+import android.app.Application;
+
+import io.realm.Realm;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
+    }
+}
diff --git a/examples/moduleExample/library/lint.xml b/examples/moduleExample/library/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/moduleExample/library/lint.xml
+++ b/examples/moduleExample/library/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
index f33c90cbbd..b7d68f2eb6 100644
--- a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
@@ -32,9 +32,9 @@
     private final RealmConfiguration realmConfig;
     private Realm realm;
 
-    public Zoo(Context context) {
-        realmConfig = new RealmConfiguration.Builder(context) // Beware this is the app context
-                .name("library.zoo.realm")                    // So always use a unique name
+    public Zoo() {
+        realmConfig = new RealmConfiguration.Builder()     // The app is responsible for calling `Realm.init(Context)`
+                .name("library.zoo.realm")                 // So always use a unique name
                 .modules(new AllAnimalsModule())           // Always use explicit modules in library projects
                 .build();
 
diff --git a/examples/newsreaderExample/lint.xml b/examples/newsreaderExample/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/newsreaderExample/lint.xml
+++ b/examples/newsreaderExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
index d8f575dd1a..77674d9c2b 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
@@ -44,7 +44,8 @@ public void handleError(Throwable e) {
         });
 
         // Configure default configuration for Realm
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(this).build();
+        Realm.init(this);
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder().build();
         Realm.setDefaultConfiguration(realmConfig);
     }
 
diff --git a/examples/objectServerExample/README.md b/examples/objectServerExample/README.md
new file mode 100644
index 0000000000..f9ec43ab2d
--- /dev/null
+++ b/examples/objectServerExample/README.md
@@ -0,0 +1,14 @@
+# Using this example
+
+This example shows a minimal example on how to connect to and use the
+Realm Object Server to synchronize changes between devices.
+
+The example will assume that the Object Server is running on the machine
+building the example and the IP address will automatically be injected
+into the build configuration.
+
+If this for some reasons does not work, please insert the IP Address into
+the `build.gradle` accordingly.
+
+To read more about the Realm Object Server and how to deploy it, see
+https://realm.io/news/introducing-realm-mobile-platform/
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
new file mode 100644
index 0000000000..52a4c63f4a
--- /dev/null
+++ b/examples/objectServerExample/build.gradle
@@ -0,0 +1,67 @@
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+apply plugin: 'realm-android'
+
+// Credit: http://jeremie-martinez.com/2015/05/05/inject-host-gradle/
+def getIP() {
+    InetAddress result = null;
+    Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
+    while (interfaces.hasMoreElements()) {
+        Enumeration<InetAddress> addresses = interfaces.nextElement().getInetAddresses();
+        while (addresses.hasMoreElements()) {
+            InetAddress address = addresses.nextElement();
+            if (!address.isLoopbackAddress()) {
+                if (address.isSiteLocalAddress()) {
+                    return address.getHostAddress();
+                } else if (result == null) {
+                    result = address;
+                }
+            }
+        }
+    }
+    return (result != null ? result : InetAddress.getLocalHost()).getHostAddress();
+}
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId 'io.realm.examples.objectserver'
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        // This will automatically try to detect the IP address of the machine
+        // building the example. It is assumed that this machine is also running
+        // the Object Server. If not, replace 'host' with the IP of the machine
+        // hosting the server. In some cases the wrong IP address will also
+        // be detected. In that case also insert the IP address manually.
+        def host = getIP()
+        debug {
+            buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+        }
+        release {
+            minifyEnabled false
+            buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+realm {
+    syncEnabled = true
+}
+
+dependencies {
+    compile 'com.android.support:support-v4:24.2.0'
+    compile 'com.android.support:design:24.2.0'
+    compile 'com.jakewharton:butterknife:8.3.0'
+    annotationProcessor 'com.jakewharton:butterknife-compiler:8.3.0'
+}
diff --git a/examples/objectServerExample/lint.xml b/examples/objectServerExample/lint.xml
new file mode 100644
index 0000000000..6a9810cdcb
--- /dev/null
+++ b/examples/objectServerExample/lint.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<lint>
+    <!-- Disable the given check in this project -->
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
+</lint>
diff --git a/examples/objectServerExample/src/main/AndroidManifest.xml b/examples/objectServerExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..45e5d52c1c
--- /dev/null
+++ b/examples/objectServerExample/src/main/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.objectserver" >
+
+    <application
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:name="io.realm.examples.objectserver.MyApplication"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name="io.realm.examples.objectserver.CounterActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity
+            android:name="io.realm.examples.objectserver.LoginActivity"
+            android:label="Login" >
+        </activity>
+    </application>
+
+</manifest>
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
new file mode 100644
index 0000000000..97c67d2443
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.TextView;
+
+import java.util.Locale;
+
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import butterknife.OnClick;
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.SyncConfiguration;
+import io.realm.SyncUser;
+import io.realm.examples.objectserver.model.CRDTCounter;
+
+public class CounterActivity extends AppCompatActivity {
+
+    private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
+
+    private Realm realm;
+    private CRDTCounter counter;
+    private SyncUser user;
+
+    @BindView(R.id.text_counter) TextView counterView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_counter);
+        ButterKnife.bind(this);
+
+        // Check if we have a valid user, otherwise redirect to login
+        if (SyncUser.currentUser() == null) {
+            gotoLoginActivity();
+        }
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        user = SyncUser.currentUser();
+        if (user != null) {
+            // Create a RealmConfiguration for our user
+            SyncConfiguration config = new SyncConfiguration.Builder(user, REALM_URL)
+                    .initialData(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            realm.createObject(CRDTCounter.class, 1);
+                        }
+                    })
+                    .build();
+
+            // This will automatically sync all changes in the background for as long as the Realm is open
+            realm = Realm.getInstance(config);
+
+            counter = realm.where(CRDTCounter.class).findFirstAsync();
+            counter.addChangeListener(new RealmChangeListener<CRDTCounter>() {
+                @Override
+                public void onChange(CRDTCounter counter) {
+                    if (counter.isValid()) {
+                        counterView.setText(String.format(Locale.US, "%d", counter.getCount()));
+                    } else {
+                        counterView.setText("-");
+                    }
+                }
+            });
+            counterView.setText("0");
+        }
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        closeRealm();
+        user = null;
+    }
+
+    private void closeRealm() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.menu_counter, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch(item.getItemId()) {
+            case R.id.action_logout:
+                closeRealm();
+                user.logout();
+                gotoLoginActivity();
+                return true;
+
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
+    @OnClick(R.id.upper)
+    public void incrementCounter() {
+        adjustCounter(1);
+    }
+
+    @OnClick(R.id.lower)
+    public void decrementCounter() {
+        adjustCounter(-1);
+    }
+
+    private void adjustCounter(final int adjustment) {
+        // A synchronized Realm can get written to at any point in time, so doing synchronous writes on the UI
+        // thread is HIGHLY discouraged as it might block longer than intended. Only use async transactions.
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                CRDTCounter counter = realm.where(CRDTCounter.class).findFirst();
+                counter.add(adjustment);
+            }
+        });
+    }
+
+    private void gotoLoginActivity() {
+        Intent intent = new Intent(this, LoginActivity.class);
+        startActivity(intent);
+    }
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
new file mode 100644
index 0000000000..5ce56afb27
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver;
+
+import android.app.ProgressDialog;
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.Toast;
+
+import butterknife.BindView;
+import butterknife.ButterKnife;
+import io.realm.SyncCredentials;
+import io.realm.ObjectServerError;
+import io.realm.SyncUser;
+import io.realm.UserStore;
+
+import static io.realm.ErrorCode.UNKNOWN_ACCOUNT;
+
+public class LoginActivity extends AppCompatActivity {
+
+    @BindView(R.id.input_username) EditText username;
+    @BindView(R.id.input_password) EditText password;
+    @BindView(R.id.button_login) Button loginButton;
+    @BindView(R.id.button_create) Button createUserButton;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_login);
+        ButterKnife.bind(this);
+        loginButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                login(false);
+            }
+        });
+        createUserButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                login(true);
+            }
+        });
+    }
+
+    public void login(boolean createUser) {
+        if (!validate()) {
+            onLoginFailed("Invalid username or password");
+            return;
+        }
+
+        createUserButton.setEnabled(false);
+        loginButton.setEnabled(false);
+
+        final ProgressDialog progressDialog = new ProgressDialog(LoginActivity.this);
+        progressDialog.setIndeterminate(true);
+        progressDialog.setMessage("Authenticating...");
+        progressDialog.show();
+
+        String username = this.username.getText().toString();
+        String password = this.password.getText().toString();
+
+        SyncCredentials creds = SyncCredentials.usernamePassword(username, password, createUser);
+        String authUrl = "http://" + BuildConfig.OBJECT_SERVER_IP + ":9080/auth";
+        SyncUser.Callback callback = new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                progressDialog.dismiss();
+                onLoginSuccess();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                progressDialog.dismiss();
+                String errorMsg;
+                switch (error.getErrorCode()) {
+                    case UNKNOWN_ACCOUNT:
+                        errorMsg = "Account does not exists.";
+                        break;
+                    case INVALID_CREDENTIALS:
+                        errorMsg = "User name and password does not match";
+                        break;
+                    default:
+                        errorMsg = error.toString();
+                }
+                onLoginFailed(errorMsg);
+            }
+        };
+
+        SyncUser.loginAsync(creds, authUrl, callback);
+    }
+
+    @Override
+    public void onBackPressed() {
+        // Disable going back to the MainActivity
+        moveTaskToBack(true);
+    }
+
+    public void onLoginSuccess() {
+        loginButton.setEnabled(true);
+        createUserButton.setEnabled(true);
+        finish();
+    }
+
+    public void onLoginFailed(String errorMsg) {
+        loginButton.setEnabled(true);
+        createUserButton.setEnabled(true);
+        Toast.makeText(getBaseContext(), errorMsg, Toast.LENGTH_LONG).show();
+    }
+
+    public boolean validate() {
+        boolean valid = true;
+        String email = username.getText().toString();
+        String password = this.password.getText().toString();
+
+        if (email.isEmpty()) {
+            valid = false;
+        }
+
+        if (password.isEmpty()) {
+            valid = false;
+        }
+
+        return valid;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
similarity index 54%
rename from realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java
rename to examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
index dac99bc040..8fb13a829b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,25 +14,24 @@
  * limitations under the License.
  */
 
-package io.realm.internal;
+package io.realm.examples.objectserver;
 
-public class ReadTransaction extends Group {
+import android.app.Application;
+import android.util.Log;
 
-    private final SharedGroup db;
+import io.realm.Realm;
+import io.realm.log.RealmLog;
 
-    ReadTransaction(Context context, SharedGroup db, long nativePointer) {
-        super(context, nativePointer, true); // make Group immutable
-        this.db = db;
-    }
-
-    public void endRead() {
-        db.endRead();
-    }
+public class MyApplication extends Application {
 
     @Override
-    public void close() {
-        db.endRead();
-    }
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
 
-    protected void finalize() {} // Nullify the actions of Group.finalize()
+        // Enable full log output when debugging
+        if (BuildConfig.DEBUG) {
+            RealmLog.setLevel(Log.VERBOSE);
+        }
+    }
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
new file mode 100644
index 0000000000..93096e3ac6
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver.model;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+/**
+ * Counter class that is eventually consistent. Two devices can simultaneous increment this and eventually reach
+ * the same value.
+ *
+ * @see <href ref="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict Free Replicated Data Structures</href>
+ */
+public class CRDTCounter extends RealmObject {
+
+    @PrimaryKey
+    private long id;
+    private RealmList<CounterOperation> operations;
+
+    public CRDTCounter() {
+        // Required by Realm
+    }
+
+    public CRDTCounter(long id) {
+        this.id = id;
+    }
+
+    public long getCount() {
+        return operations.where().sum("adjustment").longValue();
+    }
+
+    public void add(long val) {
+        operations.add(new CounterOperation(val));
+    }
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java
new file mode 100644
index 0000000000..53342f648d
--- /dev/null
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class CounterOperation extends RealmObject {
+    public long adjustment;
+    public CounterOperation() {};
+    public CounterOperation(long adjustment) {
+        this.adjustment = adjustment;
+    }
+}
diff --git a/examples/objectServerExample/src/main/res/drawable-xxhdpi/ic_exit_to_app_white_24dp.png b/examples/objectServerExample/src/main/res/drawable-xxhdpi/ic_exit_to_app_white_24dp.png
new file mode 100644
index 0000000000..c04fe6e0e3
Binary files /dev/null and b/examples/objectServerExample/src/main/res/drawable-xxhdpi/ic_exit_to_app_white_24dp.png differ
diff --git a/examples/objectServerExample/src/main/res/drawable-xxxhdpi/ic_exit_to_app_white_24dp.png b/examples/objectServerExample/src/main/res/drawable-xxxhdpi/ic_exit_to_app_white_24dp.png
new file mode 100644
index 0000000000..27a9d7b05a
Binary files /dev/null and b/examples/objectServerExample/src/main/res/drawable-xxxhdpi/ic_exit_to_app_white_24dp.png differ
diff --git a/examples/objectServerExample/src/main/res/drawable/button_counter.xml b/examples/objectServerExample/src/main/res/drawable/button_counter.xml
new file mode 100644
index 0000000000..0d8fd827aa
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/drawable/button_counter.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@color/touch_area_pressed" android:state_pressed="true"/>
+    <item android:drawable="@color/touch_area_pressed" android:state_focused="true"/>
+    <item android:drawable="@android:color/background_light"/>
+</selector>
diff --git a/examples/objectServerExample/src/main/res/drawable/logo.png b/examples/objectServerExample/src/main/res/drawable/logo.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/objectServerExample/src/main/res/drawable/logo.png differ
diff --git a/examples/objectServerExample/src/main/res/layout/activity_counter.xml b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
new file mode 100644
index 0000000000..62127eca0d
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
@@ -0,0 +1,37 @@
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:weightSum="1.0">
+
+        <View
+            android:id="@+id/upper"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="0.5"
+            android:background="@drawable/button_counter">
+        </View>
+
+        <View
+            android:id="@+id/lower"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="0.5"
+            android:background="@drawable/button_counter">
+        </View>
+    </LinearLayout>
+
+    <TextView
+        android:id="@+id/text_counter"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"
+        android:fontFamily="sans-serif-light"
+        android:textSize="160sp"/>
+
+</RelativeLayout>
diff --git a/examples/objectServerExample/src/main/res/layout/activity_login.xml b/examples/objectServerExample/src/main/res/layout/activity_login.xml
new file mode 100644
index 0000000000..142ad539e1
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/layout/activity_login.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:fitsSystemWindows="true">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:paddingLeft="24dp"
+        android:paddingRight="24dp"
+        android:paddingTop="56dp">
+
+        <ImageView
+            android:layout_width="wrap_content"
+            android:layout_height="72dp"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginBottom="24dp"
+            android:src="@drawable/logo"/>
+
+        <android.support.design.widget.TextInputLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="8dp"
+            android:layout_marginTop="8dp">
+
+            <EditText
+                android:id="@+id/input_username"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Username"
+                android:inputType="text"/>
+        </android.support.design.widget.TextInputLayout>
+
+        <android.support.design.widget.TextInputLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="8dp"
+            android:layout_marginTop="8dp">
+
+            <EditText
+                android:id="@+id/input_password"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Password"
+                android:inputType="textPassword"/>
+        </android.support.design.widget.TextInputLayout>
+
+        <android.support.v7.widget.AppCompatButton
+            android:id="@+id/button_login"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="12dp"
+            android:layout_marginTop="24dp"
+            android:padding="12dp"
+            android:text="Login" />
+
+        <android.support.v7.widget.AppCompatButton
+            android:id="@+id/button_create"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="24dp"
+            android:padding="12dp"
+            android:text="Create account and login" />
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/examples/objectServerExample/src/main/res/menu/menu_counter.xml b/examples/objectServerExample/src/main/res/menu/menu_counter.xml
new file mode 100644
index 0000000000..858fd2e7e8
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/menu/menu_counter.xml
@@ -0,0 +1,11 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto"
+      xmlns:tools="http://schemas.android.com/tools"
+      tools:context=".CounterActivity">
+    <item
+        android:id="@+id/action_logout"
+        android:orderInCategory="100"
+        android:title="Logout"
+        android:icon="@drawable/ic_exit_to_app_white_24dp"
+        app:showAsAction="always"/>
+</menu>
diff --git a/examples/objectServerExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/objectServerExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/objectServerExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/objectServerExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/objectServerExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/objectServerExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/values-w820dp/dimens.xml b/examples/objectServerExample/src/main/res/values-w820dp/dimens.xml
similarity index 100%
rename from examples/threadExample/src/main/res/values-w820dp/dimens.xml
rename to examples/objectServerExample/src/main/res/values-w820dp/dimens.xml
diff --git a/examples/objectServerExample/src/main/res/values/dimens.xml b/examples/objectServerExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/objectServerExample/src/main/res/values/realm_colors.xml b/examples/objectServerExample/src/main/res/values/realm_colors.xml
new file mode 100644
index 0000000000..aada8ea195
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/realm_colors.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    // Grays
+    <color name="charcoal">#1C233F</color>
+    <color name="elephant">#9A9BA5</color>
+    <color name="elephant_half">#b1b3bf</color>
+    <color name="dove">#EBEBF2</color>
+
+    // Orb colors
+    <color name="ultramarine">#39477F</color>
+    <color name="indigo">#59569E</color>
+    <color name="grape_jelly">#9A59A5</color>
+    <color name="mulberry">#D34CA3</color>
+    <color name="flamingo">#F25192</color>
+    <color name="sexy_salmon">#F77C88</color>
+    <color name="peach">#FC9F95</color>
+    <color name="melon">#FCC397</color>
+
+    // Material adjustments
+    <color name="flamingo_darker">#d64881</color>
+    <color name="touch_area_pressed">#dadada</color>
+
+</resources>
\ No newline at end of file
diff --git a/examples/objectServerExample/src/main/res/values/strings.xml b/examples/objectServerExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..10e43bd0a9
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">Object Server Example</string>
+</resources>
diff --git a/examples/objectServerExample/src/main/res/values/styles.xml b/examples/objectServerExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..333a4944af
--- /dev/null
+++ b/examples/objectServerExample/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <item name="colorPrimary">@color/flamingo</item>
+        <item name="colorPrimaryDark">@color/flamingo_darker</item>
+        <item name="colorAccent">@color/ultramarine</item>
+    </style>
+</resources>
+
diff --git a/examples/rxJavaExample/lint.xml b/examples/rxJavaExample/lint.xml
index cc4d461aee..7d530f741e 100644
--- a/examples/rxJavaExample/lint.xml
+++ b/examples/rxJavaExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
index 22e5e2b6db..9ac0f17b60 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
@@ -45,7 +45,8 @@
     public void onCreate() {
         super.onCreate();
         context = this;
-        RealmConfiguration config = new RealmConfiguration.Builder(this).build();
+        Realm.init(this);
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(config);
         Realm.setDefaultConfiguration(config);
         createTestData();
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
index 15a792100c..6a5c27991b 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
@@ -75,7 +75,7 @@ protected void onResume() {
                     @Override
                     public Boolean call(RealmResults<Person> persons) {
                         // Only continue once data is actually loaded
-                        // RealmObservables will emit the unloaded (empty) list as it's first item
+                        // RealmObservables will emit the unloaded (empty) list as its first item
                         return persons.isLoaded();
                     }
                 })
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
new file mode 100644
index 0000000000..7222838bea
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -0,0 +1,38 @@
+apply plugin: 'com.android.application'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion 24
+    buildToolsVersion "24.0.0"
+
+    defaultConfig {
+        applicationId "io.realm.examples.securetokenandroidkeystore"
+        minSdkVersion 9
+        targetSdkVersion 24
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    compile 'com.android.support:appcompat-v7:24.2.0'
+    testCompile 'junit:junit:4.12'
+    compile 'io.realm:android-secure-userstore:1.0.0'
+}
+
+realm {
+    syncEnabled = true
+}
\ No newline at end of file
diff --git a/examples/secureTokenAndroidKeyStore/lint.xml b/examples/secureTokenAndroidKeyStore/lint.xml
new file mode 100644
index 0000000000..5f242796c5
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/lint.xml
@@ -0,0 +1,5 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+</lint>
diff --git a/examples/secureTokenAndroidKeyStore/proguard-rules.pro b/examples/secureTokenAndroidKeyStore/proguard-rules.pro
new file mode 100644
index 0000000000..740907a636
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/Nabil/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml b/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..15f02a70aa
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.securetokenandroidkeystore">
+
+    <application android:allowBackup="true" android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"
+        android:name="examples.io.realm.securetokenandroidkeystore.MyApplication">
+        <activity android:name="examples.io.realm.securetokenandroidkeystore.MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
new file mode 100644
index 0000000000..c4b618b704
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.securetokenandroidkeystore;
+
+import android.os.Bundle;
+import android.support.v4.content.ContextCompat;
+import android.support.v7.app.AppCompatActivity;
+import android.widget.TextView;
+
+import com.example.securetokenandroidkeystore.R;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.security.KeyStoreException;
+import java.util.UUID;
+
+import io.realm.android.CipherClient;
+import io.realm.android.SecureUserStore;
+import io.realm.SyncUser;
+import io.realm.android.SecureUserStore;
+import io.realm.SyncManager;
+import io.realm.SyncConfiguration;
+import io.realm.Realm;
+import io.realm.internal.objectserver.Token;
+import io.realm.internal.objectserver.ObjectServerUser;
+
+/**
+ * Activity responsible of unlocking the KeyStore
+ * before using the {@link realm.io.android.SecureUserStore} to encrypt
+ * the Token we get from the session
+ */
+public class MainActivity extends AppCompatActivity {
+    private CipherClient cryptoClient;
+    private TextView txtKeystoreState;
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        txtKeystoreState = (TextView) findViewById(R.id.txtLabelKeyStore);
+
+        try {
+            cryptoClient = new CipherClient(this);
+            if (cryptoClient.isKeystoreUnlocked()) {
+                buildSyncConf();
+                keystoreUnlockedMessage();
+            } else {
+                cryptoClient.unlockKeystore();
+            }
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        try {
+            // We return to the app after the KeyStore is unlocked or not.
+            if (cryptoClient.isKeystoreUnlocked()) {
+                buildSyncConf();
+                keystoreUnlockedMessage ();
+            } else {
+                keystoreLockedMessage ();
+            }
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        }
+    }
+
+    // build SyncConfiguration with a user store to store encrypted Token.
+    private void buildSyncConf () {
+        try {
+            SyncManager.setUserStore(new SecureUserStore(MainActivity.this));
+            // the rest of Sync logic ...
+            SyncUser user = createTestUser(0);
+            String url = "realm://objectserver.realm.io/default";
+            SyncConfiguration secureConfig = new SyncConfiguration.Builder(user, url).build();
+            Realm realm = Realm.getInstance(secureConfig);
+            // ... 
+
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        }
+    }
+    // Helpers
+    private final static String USER_TOKEN = UUID.randomUUID().toString();
+    private final static String REALM_TOKEN = UUID.randomUUID().toString();
+
+    private static SyncUser createTestUser(long expires) {
+        Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
+        Token accessToken = new Token(REALM_TOKEN, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
+        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
+
+        JSONObject obj = new JSONObject();
+        try {
+            JSONArray realmList = new JSONArray();
+            JSONObject realmDesc = new JSONObject();
+            realmDesc.put("uri", "realm://objectserver.realm.io/default");
+            realmDesc.put("description", desc.toJson());
+            realmList.put(realmDesc);
+
+            obj.put("authUrl", "http://objectserver.realm.io/auth");
+            obj.put("userToken", userToken.toJson());
+            obj.put("realms", realmList);
+            return SyncUser.fromJson(obj.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void keystoreLockedMessage () {
+        txtKeystoreState.setBackgroundColor(ContextCompat.getColor(this, R.color.colorLocked));
+        txtKeystoreState.setText(R.string.locked_text);
+    }
+
+    private void keystoreUnlockedMessage () {
+        txtKeystoreState.setBackgroundColor(ContextCompat.getColor(this, R.color.colorActivated));
+        txtKeystoreState.setText(R.string.unlocked_text);
+    }
+}
+
diff --git a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MyApplication.java b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MyApplication.java
new file mode 100644
index 0000000000..8af665821a
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MyApplication.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.securetokenandroidkeystore;
+
+import android.app.Application;
+
+import io.realm.Realm;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // Initialize Realm. Should only be done once when the application starts.
+        Realm.init(this);
+    }
+}
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/layout/activity_main.xml b/examples/secureTokenAndroidKeyStore/src/main/res/layout/activity_main.xml
new file mode 100644
index 0000000000..eff5fd5e7b
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/layout/activity_main.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:tools="http://schemas.android.com/tools"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_height="match_parent"
+    android:layout_width="match_parent"
+    android:orientation="horizontal"
+    android:gravity="center">
+
+    <TextView
+        android:id="@+id/txtLabelKeyStore"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+        android:text="@string/locked_text"
+        android:background="@color/colorLocked"
+        android:textSize="18sp"/>
+
+</RelativeLayout>
+
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/secureTokenAndroidKeyStore/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/values/colors.xml b/examples/secureTokenAndroidKeyStore/src/main/res/values/colors.xml
new file mode 100644
index 0000000000..59411e9175
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/values/colors.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+    <color name="colorActivated">#00CC00</color>
+    <color name="colorLocked">#CC0000</color>
+</resources>
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/values/strings.xml b/examples/secureTokenAndroidKeyStore/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..d028dcda8a
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/values/strings.xml
@@ -0,0 +1,5 @@
+<resources>
+    <string name="app_name">secureTokenAndroidKeyStore</string>
+    <string name="locked_text">Key Store Locked/Uninitialised:\nYou can not encrypt the Token</string>
+    <string name="unlocked_text">Key Store Unlocked:\nYou can encrypt the Token</string>
+</resources>
diff --git a/examples/secureTokenAndroidKeyStore/src/main/res/values/styles.xml b/examples/secureTokenAndroidKeyStore/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..daa2a5c2f0
--- /dev/null
+++ b/examples/secureTokenAndroidKeyStore/src/main/res/values/styles.xml
@@ -0,0 +1,11 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+</resources>
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 9b18f1e779..0f9f5242bd 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -1,3 +1,4 @@
+include 'secureTokenAndroidKeyStore'
 include 'encryptionExample'
 include 'gridViewExample'
 include 'introExample'
@@ -11,6 +12,7 @@ include 'threadExample'
 include 'unitTestExample'
 include 'newsreaderExample'
 include 'rxJavaExample'
+include 'objectServerExample'
 
 rootProject.name = 'realm-examples'
 
diff --git a/examples/threadExample/lint.xml b/examples/threadExample/lint.xml
index 3af2534ba6..6a9810cdcb 100644
--- a/examples/threadExample/lint.xml
+++ b/examples/threadExample/lint.xml
@@ -6,4 +6,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
index 6d730bce93..3fdde6744e 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -178,7 +178,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                 view.setTag(viewHolder);
             }
             ViewHolder vh = (ViewHolder) view.getTag();
-            vh.text.setText(view.getResources().getString(R.string.coordinate, getItem(i).getX(),getItem(i).getY()));
+            vh.text.setText(view.getResources().getString(R.string.coordinate, getItem(i).getX(), getItem(i).getY()));
             return view;
         }
 
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java b/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
index 7ced58b6c8..a043477ecf 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
@@ -28,7 +28,8 @@ public void onCreate() {
         super.onCreate();
 
         // Configure Realm for the application
-        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        Realm.init(this);
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(realmConfiguration); // Clean slate
         Realm.setDefaultConfiguration(realmConfiguration); // Make this Realm the default
     }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
index c64cf21644..566bd07ef3 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
@@ -100,10 +100,9 @@ public void onActivityCreated(Bundle savedInstanceState) {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                person = realm.createObject(Person.class);
+                person = realm.createObject(Person.class, UUID.randomUUID().toString());
                 person.setName("Jane");
                 person.setAge(42);
-                person.setId(UUID.randomUUID().toString());
             }
         });
         textContent.setText(person.toString());
diff --git a/examples/threadExample/src/main/res/values/strings.xml b/examples/threadExample/src/main/res/values/strings.xml
index b1480bd6cc..240767c073 100644
--- a/examples/threadExample/src/main/res/values/strings.xml
+++ b/examples/threadExample/src/main/res/values/strings.xml
@@ -13,7 +13,7 @@
     <string name="title_section4">Object Passing</string>
     <string name="start_intent_service">Passing to Intent Service</string>
     <string name="start_receiver">Passing To Receiver</string>
-    <string name="coordinate">[X= %1$s Y= %2$s]</string>
+    <string name="coordinate">[X= %1$d Y= %2$d]</string>
     <string name="start">Start</string>
 
 </resources>
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index f4a1b95430..a6752c2738 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -1,6 +1,5 @@
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
-apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'realm-android'
 
 android {
diff --git a/examples/unitTestExample/lint.xml b/examples/unitTestExample/lint.xml
index 1d3dbb0011..1f5e37cb86 100644
--- a/examples/unitTestExample/lint.xml
+++ b/examples/unitTestExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="LogNotTimber" severity="ignore" />
+    <issue id="InvalidPackage" severity="ignore" />
 </lint>
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
index b918cdd6f4..479037fabb 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
@@ -36,19 +36,17 @@
     private LinearLayout rootLayout = null;
 
     private Realm realm;
-    private static RealmConfiguration realmConfig;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+        Realm.init(getApplicationContext());
         setContentView(R.layout.activity_example);
         rootLayout = ((LinearLayout) findViewById(R.id.container));
         rootLayout.removeAllViews();
 
-        // Create Realm configuration if it doesn't exist.
-        realmConfig = new RealmConfiguration.Builder(this).build();
         // Open the default Realm for the UI thread.
-        realm = Realm.getInstance(realmConfig);
+        realm = Realm.getDefaultInstance();
 
         // Clean up from previous run
         cleanUp();
@@ -160,7 +158,7 @@ public void execute(Realm realm) {
     private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
-        Realm realm = Realm.getInstance(realmConfig);
+        Realm realm = Realm.getDefaultInstance();
         status += "\nNumber of people in the DB: " + realm.where(Person.class).count();
 
         // Find all persons where age between 1 and 99 and name begins with "J".
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 4e23a70df5..97b51b752d 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -19,15 +19,20 @@
 import android.content.Context;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
+import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.core.classloader.annotations.SuppressStaticInitializationFor;
+import org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl;
 import org.powermock.modules.junit4.rule.PowerMockRule;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ActivityController;
 
@@ -41,6 +46,9 @@
 import io.realm.RealmResults;
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
+import io.realm.internal.Util;
+import io.realm.log.Logger;
+import io.realm.log.RealmLog;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -60,7 +68,8 @@
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
-@PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class})
+@SuppressStaticInitializationFor("io.realm.internal.Util")
+@PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class, RealmLog.class})
 public class ExampleActivityTest {
 
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
@@ -74,10 +83,12 @@
     @Before
     public void setup() throws Exception {
 
-        // Setup Realm to be mocked
+        // Setup Realm to be mocked. The order of these matters
+        mockStatic(RealmCore.class);
+        mockStatic(RealmLog.class);
         mockStatic(Realm.class);
         mockStatic(RealmConfiguration.class);
-        mockStatic(RealmCore.class);
+        Realm.init(RuntimeEnvironment.application);
 
         // Create the mock
         final Realm mockRealm = mock(Realm.class);
@@ -89,12 +100,13 @@ public void setup() throws Exception {
         doNothing().when(RealmCore.class);
         RealmCore.loadLibrary(any(Context.class));
 
+
         // TODO: Mock the RealmConfiguration's constructor. If the RealmConfiguration.Builder.build can be mocked, this
         // is not necessary anymore.
         whenNew(RealmConfiguration.class).withAnyArguments().thenReturn(mockRealmConfig);
 
         // Anytime getInstance is called with any configuration, then return the mockRealm
-        when(Realm.getInstance(any(RealmConfiguration.class))).thenReturn(mockRealm);
+        when(Realm.getDefaultInstance()).thenReturn(mockRealm);
 
         // Anytime we ask Realm to create a Person, return a new instance.
         when(mockRealm.createObject(Person.class)).thenReturn(new Person());
@@ -165,20 +177,20 @@ public void setup() throws Exception {
     }
 
 
+    @Ignore("FIXME: Some problems mocking OKHttp")
     @Test
     public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Create activity
-        ActivityController<ExampleActivity> controller =
-                Robolectric.buildActivity(ExampleActivity.class).setup();
+        ActivityController<ExampleActivity> controller = Robolectric.buildActivity(ExampleActivity.class).setup();
         ExampleActivity activity = controller.get();
 
         assertThat(activity.getTitle().toString(), is("Unit Test Example"));
 
         // Verify that two Realm.getInstance() calls took place.
         verifyStatic(times(2));
-        Realm.getInstance(any(RealmConfiguration.class));
+        Realm.getDefaultInstance();
 
         // verify that we have four begin and commit transaction calls
         // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
@@ -211,19 +223,19 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
      * Have to verify the transaction execution in a different test because
      * of a problem with Powermock: https://github.com/jayway/powermock/issues/649
      */
+    @Ignore("FIXME: Some problems mocking OKHttp")
     @Test
     public void shouldBeAbleToVerifyTransactionCalls() {
 
         // Create activity
-        ActivityController<ExampleActivity> controller =
-                Robolectric.buildActivity(ExampleActivity.class).setup();
+        ActivityController<ExampleActivity> controller = Robolectric.buildActivity(ExampleActivity.class).setup();
         ExampleActivity activity = controller.get();
 
         assertThat(activity.getTitle().toString(), is("Unit Test Example"));
 
         // Verify that two Realm.getInstance() calls took place.
         verifyStatic(times(2));
-        Realm.getInstance(any(RealmConfiguration.class));
+        Realm.getDefaultInstance();
 
         // verify that we have four begin and commit transaction calls
         // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
index e7be410e33..147c9aa553 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
@@ -24,6 +24,7 @@
 import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.core.classloader.annotations.SuppressStaticInitializationFor;
 import org.powermock.modules.junit4.rule.PowerMockRule;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.annotation.Config;
@@ -32,6 +33,7 @@
 import io.realm.examples.unittesting.model.Dog;
 import io.realm.examples.unittesting.repository.DogRepository;
 import io.realm.examples.unittesting.repository.DogRepositoryImpl;
+import io.realm.log.RealmLog;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -45,7 +47,8 @@
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 19)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
-@PrepareForTest({Realm.class})
+@SuppressStaticInitializationFor("io.realm.internal.Util")
+@PrepareForTest({Realm.class, RealmLog.class})
 public class ExampleRealmTest {
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
 
@@ -55,6 +58,7 @@
 
     @Before
     public void setup() {
+        mockStatic(RealmLog.class);
         mockStatic(Realm.class);
 
         Realm mockRealm = PowerMockito.mock(Realm.class);
@@ -103,7 +107,7 @@ public void shouldVerifyThatDogWasCreated() {
         dogRepo.createDog("Spot");
 
         // Attempting to verify that a method was called (executeTransaction) on a partial
-        // mock will return unexpected resultes due to the partial mock. For example,
+        // mock will return unexpected results due to the partial mock. For example,
         // verifying that `executeTransaction` was called only once will fail as Powermock
         // actually calls the method 3 times for some reason. I cannot determine why at this
         // point.
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index 2bcb843bee..945728116b 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -17,7 +17,7 @@ apply plugin: 'com.jfrog.bintray'
 def props = new Properties()
 props.load(new FileInputStream("${rootDir}/../realm.properties"))
 props.each { key, val ->
-    project.set(key, val)
+    project.ext.set(key, val)
 }
 
 repositories {
@@ -112,6 +112,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index b761216703..3baa851b28 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..4912622457 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:21:04 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/gradle-plugin/gradlew b/gradle-plugin/gradlew
index 91a7e269e1..27309d9231 100755
--- a/gradle-plugin/gradlew
+++ b/gradle-plugin/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/gradle-plugin/gradlew.bat b/gradle-plugin/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/gradle-plugin/gradlew.bat
+++ b/gradle-plugin/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index c533258ce2..0b28d9a15c 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -39,27 +39,39 @@ class Realm implements Plugin<Project> {
             throw new GradleException('Realm gradle plugin only supports android gradle plugin 1.5.0 or later.')
         }
 
-        def usesKotlinPlugin = project.plugins.findPlugin('kotlin-android') != null
-        def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
+        def syncEnabledDefault = false
+        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault)
 
-        def isKaptProject = usesKotlinPlugin && !usesAptPlugin
+        def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
+        def isKotlinProject = project.plugins.findPlugin('kotlin-android') != null
+        def hasAnnotationProcessorConfiguration = project.getConfigurations().findByName('annotationProcessor') != null
+        // TODO add a parameter in 'realm' block if this should be specified by users
+        def preferAptOnKotlinProject = false
 
-        if (!isKaptProject) {
+        if (shouldApplyAndroidAptPlugin(usesAptPlugin, isKotlinProject,
+                                        hasAnnotationProcessorConfiguration, preferAptOnKotlinProject)) {
             project.plugins.apply(AndroidAptPlugin)
+            usesAptPlugin = true
         }
 
         project.android.registerTransform(new RealmTransformer(project))
+
         project.repositories.add(project.getRepositories().jcenter())
-        project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
         project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
-        if (isKaptProject) {
-            project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
-            project.dependencies.add("kapt", "io.realm:realm-annotations-processor:${Version.VERSION}")
-        } else {
+        if (usesAptPlugin) {
             project.dependencies.add("apt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("apt", "io.realm:realm-annotations-processor:${Version.VERSION}")
             project.dependencies.add("androidTestApt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("androidTestApt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+        } else if (isKotlinProject && !preferAptOnKotlinProject) {
+            project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("kapt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+        } else {
+            assert hasAnnotationProcessorConfiguration
+            project.dependencies.add("annotationProcessor", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("annotationProcessor", "io.realm:realm-annotations-processor:${Version.VERSION}")
+            project.dependencies.add("androidTestAnnotationProcessor", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("androidTestAnnotationProcessor", "io.realm:realm-annotations-processor:${Version.VERSION}")
         }
     }
 
@@ -71,4 +83,19 @@ class Realm implements Plugin<Project> {
             return false
         }
     }
+
+    private static boolean shouldApplyAndroidAptPlugin(boolean usesAptPlugin, boolean isKotlinProject,
+                                                       boolean hasAnnotationProcessorConfiguration,
+                                                       boolean preferAptOnKotlinProject) {
+        if (usesAptPlugin) {
+            // for any projects that uses android-apt plugin already. No need to apply it twice.
+            return false
+        }
+        if (isKotlinProject) {
+            // for any Kotlin projects where user did not apply 'android-apt' plugin manually.
+            return preferAptOnKotlinProject && !hasAnnotationProcessorConfiguration
+        }
+        // for any Java Projects where user did not apply 'android-apt' plugin manually.
+        return !hasAnnotationProcessorConfiguration
+    }
 }
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
new file mode 100644
index 0000000000..ac2fc4012a
--- /dev/null
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.gradle
+
+import org.gradle.api.Project
+
+class RealmPluginExtension {
+    private Project project
+    def boolean syncEnabled
+
+    RealmPluginExtension(Project project, boolean syncEnabledDefault) {
+        this.project = project
+        setSyncEnabled(syncEnabledDefault)
+    }
+
+    void setSyncEnabled(value) {
+        this.syncEnabled = value;
+
+        // remove realm android library first
+        def iterator = project.getConfigurations().getByName("compile").getDependencies().iterator();
+        while (iterator.hasNext()) {
+            def item = iterator.next()
+            if (item.group == 'io.realm' && item.name.startsWith('realm-android-library')) {
+                iterator.remove()
+            }
+        }
+
+        // then add again
+        def artifactName = "realm-android-library${syncEnabled ? '-object-server' : ''}"
+        project.dependencies.add("compile", "io.realm:${artifactName}:${Version.VERSION}")
+    }
+}
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index d73ef15836..c99d4f53b4 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -53,7 +53,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:2.1.0'
+                classpath 'com.android.tools.build:gradle:2.2.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
@@ -78,7 +78,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:2.1.0'
+                classpath 'com.android.tools.build:gradle:2.2.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..bc6b7c4622 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:03:29 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/gradlew b/gradlew
index 97fac783e1..27309d9231 100755
--- a/gradlew
+++ b/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/gradlew.bat b/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index 5fd63be38b..a372797de3 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -54,6 +54,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..a18e4af3f9 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:22:29 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/realm-annotations/gradlew b/realm-annotations/gradlew
index 97fac783e1..27309d9231 100755
--- a/realm-annotations/gradlew
+++ b/realm-annotations/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/realm-annotations/gradlew.bat b/realm-annotations/gradlew.bat
index 8a0b282aa6..f6d5974e72 100644
--- a/realm-annotations/gradlew.bat
+++ b/realm-annotations/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Beta.java b/realm-annotations/src/main/java/io/realm/annotations/Beta.java
new file mode 100644
index 0000000000..f35dd4da23
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/Beta.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is added to classes, constructors or methods which are considered in beta phase.
+ * It indicates that any public interface can change without prior announcements.
+ * Moreover, classes, constructors, and methods annotated as beta are not considered at production
+ * quality, and should be used with care.
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD})
+public @interface Beta {
+}
diff --git a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
index ddef303a14..b9e263cf4e 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
@@ -25,10 +25,11 @@
  * The @PrimaryKey annotation will mark a field as a primary key inside Realm. Only one field in a
  * RealmObject class can have this annotation, and the field should uniquely identify the object.
  * Trying to insert an object with an existing primary key will result in an
- * {@link io.realm.exceptions.RealmPrimaryKeyConstraintException}.
- *
+ * {@link io.realm.exceptions.RealmPrimaryKeyConstraintException}. Primary key cannot be changed
+ * after the object created.
+ * <p>
  * Primary keys also count as having the {@link Index} annotation.
- *
+ * <p>
  * It is allowed to apply this annotation on the following primitive types: byte, short, int, and long.
  * String, Byte, Short, Integer, and Long are also allowed, and further permitted to have {@code null}
  * as a primary key value.
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index 5b98178bea..2dc0dadb96 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -18,6 +18,11 @@ apply plugin: 'com.jfrog.bintray'
 group = 'io.realm'
 version = file("${projectDir}/../version.txt").text.trim();
 
+def properties = new Properties()
+properties.load(new FileInputStream("${projectDir}/../dependencies.list"))
+
+def syncVersion = properties.getProperty('REALM_SYNC_VERSION')
+
 sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
@@ -59,7 +64,7 @@ import org.apache.tools.ant.filters.ReplaceTokens
 task generateVersionClass(type: Copy) {
     from 'src/main/templates/Version.java'
     into 'build/generated-src/main/java/io/realm/transformer'
-    filter(ReplaceTokens, tokens: [version: version])
+    filter(ReplaceTokens, tokens: [version: version, syncVersion: syncVersion])
     outputs.upToDateWhen { false }
 }
 
@@ -99,6 +104,19 @@ publishing {
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..e9bd4ba64f 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:33:05 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/realm-transformer/gradlew b/realm-transformer/gradlew
index 97fac783e1..27309d9231 100755
--- a/realm-transformer/gradlew
+++ b/realm-transformer/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/realm-transformer/gradlew.bat b/realm-transformer/gradlew.bat
index 8a0b282aa6..f6d5974e72 100644
--- a/realm-transformer/gradlew.bat
+++ b/realm-transformer/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index b927ef5b38..82f3ac292b 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -37,14 +37,14 @@ class BytecodeModifier {
      * @param clazz the CtClass to add accessors to.
      */
     public static void addRealmAccessors(CtClass clazz) {
-        logger.info "  Realm: Adding accessors to ${clazz.simpleName}"
+        logger.debug "  Realm: Adding accessors to ${clazz.simpleName}"
         def methods = clazz.getDeclaredMethods()*.name
         clazz.declaredFields.each { CtField field ->
             if (!Modifier.isStatic(field.getModifiers()) && !field.hasAnnotation(Ignore.class)) {
-                if (!methods.contains("realmGet\$${field.name}")) {
+                if (!methods.contains("realmGet\$${field.name}".toString())) {
                     clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
                 }
-                if (!methods.contains("realmSet\$${field.name}")) {
+                if (!methods.contains("realmSet\$${field.name}".toString())) {
                     clazz.addMethod(CtNewMethod.setter("realmSet\$${field.name}", field))
                 }
             }
@@ -57,17 +57,16 @@ class BytecodeModifier {
      * @param clazz The CtClass to modify
      * @param managedFields List of fields whose access should be replaced
      */
-    public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields, List<CtClass> modelClasses) {
+    public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields) {
         clazz.getDeclaredBehaviors().each { behavior ->
-            logger.info "    Behavior: ${behavior.name}"
+            logger.debug "    Behavior: ${behavior.name}"
             if (
                 (
                     behavior instanceof CtMethod &&
                     !behavior.name.startsWith('realmGet$') &&
                     !behavior.name.startsWith('realmSet$')
                 ) || (
-                    behavior instanceof CtConstructor &&
-                    !modelClasses.contains(clazz)
+                    behavior instanceof CtConstructor
                 )
             ) {
                 behavior.instrument(new FieldAccessToAccessorConverter(managedFields, clazz, behavior))
@@ -95,7 +94,9 @@ class BytecodeModifier {
         final CtClass ctClass
         final CtBehavior behavior
 
-        FieldAccessToAccessorConverter(List<CtField> managedFields, CtClass ctClass, CtBehavior behavior) {
+        FieldAccessToAccessorConverter(List<CtField> managedFields,
+                                       CtClass ctClass,
+                                       CtBehavior behavior) {
             this.managedFields = managedFields
             this.ctClass = ctClass
             this.behavior = behavior
@@ -103,13 +104,13 @@ class BytecodeModifier {
 
         @Override
         void edit(FieldAccess fieldAccess) throws CannotCompileException {
-            logger.info "      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}"
+            logger.debug "      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}"
             def isRealmFieldAccess = managedFields.find {
                 fieldAccess.className.equals(it.declaringClass.name) && fieldAccess.fieldName.equals(it.name)
             }
             if (isRealmFieldAccess != null) {
-                logger.info "        Realm: Manipulating ${ctClass.simpleName}.${behavior.name}(): ${fieldAccess.fieldName}"
-                logger.info "        Methods: ${ctClass.declaredMethods}"
+                logger.debug "        Realm: Manipulating ${ctClass.simpleName}.${behavior.name}(): ${fieldAccess.fieldName}"
+                logger.debug "        Methods: ${ctClass.declaredMethods}"
                 def fieldName = fieldAccess.fieldName
                 if (fieldAccess.isReader()) {
                     fieldAccess.replace('$_ = $0.realmGet$' + fieldName + '();')
@@ -126,7 +127,7 @@ class BytecodeModifier {
      * @param clazz The CtClass to modify.
      */
     public static void overrideTransformedMarker(CtClass clazz) {
-        logger.info "  Realm: Marking as transformed ${clazz.simpleName}"
+        logger.debug "  Realm: Marking as transformed ${clazz.simpleName}"
         try {
             clazz.getDeclaredMethod("transformerApplied", new CtClass[0])
         } catch (NotFoundException ignored) {
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index d58fb39b7c..857cd304b2 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -94,7 +94,7 @@ class RealmTransformer extends Transform {
         // javassist. See https://github.com/realm/realm-java/issues/2703.
         addBootClassesToClassPool(classPool)
 
-        logger.info "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
+        logger.debug "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
 
         // mark as transformed
         def baseProxyMediator = classPool.get('io.realm.internal.RealmProxyMediator')
@@ -103,7 +103,7 @@ class RealmTransformer extends Transform {
                 .findAll { it.matches(mediatorPattern) }
                 .collect { classPool.getCtClass(it) }
                 .findAll { it.superclass?.equals(baseProxyMediator) }
-        logger.info "Proxy Mediator Classes: ${proxyMediatorClasses*.name}"
+        logger.debug "Proxy Mediator Classes: ${proxyMediatorClasses*.name}"
         proxyMediatorClasses.each {
             BytecodeModifier.overrideTransformedMarker(it);
         }
@@ -116,7 +116,7 @@ class RealmTransformer extends Transform {
         def inputModelClasses = allModelClasses.findAll {
             inputClassNames.contains(it.name)
         }
-        logger.info "Model Classes: ${allModelClasses*.name}"
+        logger.debug "Model Classes: ${allModelClasses*.name}"
 
         // Populate a list of the fields that need to be managed with bytecode manipulation
         def allManagedFields = []
@@ -125,7 +125,7 @@ class RealmTransformer extends Transform {
                 !it.hasAnnotation(Ignore.class) && !Modifier.isStatic(it.getModifiers())
             })
         }
-        logger.info "Managed Fields: ${allManagedFields*.name}"
+        logger.debug "Managed Fields: ${allManagedFields*.name}"
 
         // Add accessors to the model classes in the target project
         inputModelClasses.each {
@@ -135,18 +135,18 @@ class RealmTransformer extends Transform {
 
         // Use accessors instead of direct field access
         inputClassNames.each {
-            logger.info "  Modifying class ${it}"
+            logger.debug "  Modifying class ${it}"
             def ctClass = classPool.getCtClass(it)
-            BytecodeModifier.useRealmAccessors(ctClass, allManagedFields, allModelClasses)
+            BytecodeModifier.useRealmAccessors(ctClass, allManagedFields)
             ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
         }
 
         copyResourceFiles(inputs, outputProvider)
 
         def toc = System.currentTimeMillis()
-        logger.info "Realm Transform time: ${toc-tic} milliseconds"
+        logger.debug "Realm Transform time: ${toc-tic} milliseconds"
 
-        sendAnalytics(inputs, inputModelClasses)
+        this.sendAnalytics(inputs, inputModelClasses)
     }
 
     /**
@@ -154,7 +154,7 @@ class RealmTransformer extends Transform {
      * @param inputs the inputs provided by the Transform API
      * @param inputModelClasses a list of ctClasses describing the Realm models
      */
-    private static sendAnalytics(Collection<TransformInput> inputs, List<CtClass> inputModelClasses) {
+    private sendAnalytics(Collection<TransformInput> inputs, List<CtClass> inputModelClasses) {
         def containsKotlin = false
         inputs.each {
             it.directoryInputs.each {
@@ -177,7 +177,8 @@ class RealmTransformer extends Transform {
         def env = System.getenv()
         def disableAnalytics = env["REALM_DISABLE_ANALYTICS"]
         if (disableAnalytics == null || disableAnalytics != "true") {
-            def analytics = RealmAnalytics.getInstance(packages as Set, containsKotlin)
+            boolean sync = project?.realm?.syncEnabled != null && project.realm.syncEnabled
+            def analytics = new RealmAnalytics(packages as Set, containsKotlin, sync)
             analytics.execute()
         }
     }
@@ -246,7 +247,7 @@ class RealmTransformer extends Transform {
                     // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
                     // `/`. It depends on how the jar file was created.
                     // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
-                    def className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
+                    String className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
                             .replace('/' as char , '.' as char)
                             .replace('\\' as char , '.' as char)
                     classNames.add(className)
@@ -262,7 +263,7 @@ class RealmTransformer extends Transform {
                 def dirPath = it.file.absolutePath
                 it.file.eachFileRecurse(FileType.FILES) {
                     if (!it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
-                        logger.info "  Copying resource ${it}"
+                        logger.debug "  Copying resource ${it}"
                         def dest = new File(getOutputFile(outputProvider),
                                 it.absolutePath.substring(dirPath.length()))
                         dest.parentFile.mkdirs()
@@ -293,13 +294,13 @@ class RealmTransformer extends Transform {
         try {
             project.android.bootClasspath.each {
                 String path = it.absolutePath
-                logger.info "Add boot class " + path + " to class pool."
+                logger.debug "Add boot class " + path + " to class pool."
                 classPool.appendClassPath(path)
             }
         } catch (Exception e) {
             // Just log it. It might not impact the transforming if the method which needs to be transformer doesn't
             // contain classes from android.jar.
-            logger.info("Cannot get bootClasspath caused by:", e)
+            logger.debug("Cannot get bootClasspath caused by:", e)
         }
     }
 }
diff --git a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
index bd1709453b..18dd7b827b 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/RealmAnalytics.java
@@ -19,11 +19,9 @@
 import java.io.UnsupportedEncodingException;
 import java.net.HttpURLConnection;
 import java.net.MalformedURLException;
-import java.net.NetworkInterface;
 import java.net.SocketException;
 import java.net.URL;
 import java.security.NoSuchAlgorithmException;
-import java.util.Enumeration;
 import java.util.Set;
 
 // Asynchronously submits build information to Realm when the annotation
@@ -69,6 +67,7 @@
             + "      \"Anonymized Bundle ID\": \"%APP_ID%\",\n"
             + "      \"Binding\": \"java\",\n"
             + "      \"Language\": \"%LANGUAGE%\",\n"
+            + "      \"Sync Version\": %SYNC_VERSION%,\n"
             + "      \"Realm Version\": \"%REALM_VERSION%\",\n"
             + "      \"Host OS Type\": \"%OS_TYPE%\",\n"
             + "      \"Host OS Version\": \"%OS_VERSION%\",\n"
@@ -80,17 +79,12 @@
     private Set<String> packages;
 
     private boolean usesKotlin;
+    private boolean usesSync;
 
-    private RealmAnalytics(Set<String> packages, boolean usesKotlin) {
+    public RealmAnalytics(Set<String> packages, boolean usesKotlin, boolean usesSync) {
         this.packages = packages;
         this.usesKotlin = usesKotlin;
-    }
-
-    public static RealmAnalytics getInstance(Set<String> packages, boolean usesKotlin) {
-        if (instance == null) {
-            instance = new RealmAnalytics(packages, usesKotlin);
-        }
-        return instance;
+        this.usesSync = usesSync;
     }
 
     private void send() {
@@ -135,7 +129,8 @@ public String generateJson() throws SocketException, NoSuchAlgorithmException {
                 .replaceAll("%TOKEN%", TOKEN)
                 .replaceAll("%USER_ID%", ComputerIdentifierGenerator.get())
                 .replaceAll("%APP_ID%", getAnonymousAppId())
-                .replaceAll("%LANGUAGE%", usesKotlin?"kotlin":"java")
+                .replaceAll("%LANGUAGE%", usesKotlin ? "kotlin" : "java")
+                .replaceAll("%SYNC_VERSION%", usesSync ? "\"" + Version.SYNC_VERSION + "\"": "null")
                 .replaceAll("%REALM_VERSION%", Version.VERSION)
                 .replaceAll("%OS_TYPE%", System.getProperty("os.name"))
                 .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
diff --git a/realm-transformer/src/main/templates/Version.java b/realm-transformer/src/main/templates/Version.java
index e1d6208e55..9239f52d3e 100644
--- a/realm-transformer/src/main/templates/Version.java
+++ b/realm-transformer/src/main/templates/Version.java
@@ -2,4 +2,5 @@
 
 public class Version {
     public static final String VERSION = "@version@";
+    public static final String SYNC_VERSION = "@syncVersion@";
 }
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
index 65609cd5df..495289af6d 100644
--- a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
+++ b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
@@ -52,6 +52,68 @@ class BytecodeModifierTest extends Specification {
         }
     }
 
+    // https://github.com/realm/realm-java/issues/3469
+    def "AddRealmAccessors_duplicateSetter"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('testClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        and: 'add a setter'
+        def setter = CtNewMethod.setter('realmSet$age', ctField)
+        ctClass.addMethod(setter)
+
+        when: 'addRealmAccessors is called'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        then: 'a getter for the field is generated'
+        def ctMethods = ctClass.getDeclaredMethods()
+        def methodNames = ctMethods.name
+        methodNames.contains('realmGet$age')
+
+        and: 'the setter is not changed'
+        ctMethods.find {it.name.equals('realmSet$age')} == setter
+
+        and: 'the accessors are public'
+        ctMethods.each {
+            it.getModifiers() == Modifier.PUBLIC
+        }
+    }
+
+    // https://github.com/realm/realm-java/issues/3469
+    def "AddRealmAccessors_duplicateGetter"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('testClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        and: 'add a getter'
+        def getter = CtNewMethod.getter('realmGet$age', ctField)
+        ctClass.addMethod(getter)
+
+        when: 'addRealmAccessors is called'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        then: 'a setter for the field is generated'
+        def ctMethods = ctClass.getDeclaredMethods()
+        def methodNames = ctMethods.name
+        methodNames.contains('realmSet$age')
+
+        and: 'the getter is not changed'
+        ctMethods.find {it.name.equals('realmGet$age')} == getter
+
+        and: 'the accessors are public'
+        ctMethods.each {
+            it.getModifiers() == Modifier.PUBLIC
+        }
+    }
+
     def "AddRealmAccessors_IgnoreAnnotation"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
@@ -79,7 +141,7 @@ class BytecodeModifierTest extends Specification {
     def "UseRealmAccessors"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('testClass')
+        def ctClass = classPool.makeClass('TestClass')
 
         and: 'add a field'
         def ctField = new CtField(CtClass.intType, 'age', ctClass)
@@ -93,23 +155,13 @@ class BytecodeModifierTest extends Specification {
         BytecodeModifier.addRealmAccessors(ctClass)
 
         when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(ctClass, [ctField], [])
+        BytecodeModifier.useRealmAccessors(ctClass, [ctField])
 
-        then: 'the field is not used in the method anymore'
-        def methodInfo = ctMethod.getMethodInfo()
-        def codeAttribute = methodInfo.getCodeAttribute()
-        def fieldIsUsed = false
-        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
-            int index = ci.next();
-            int op = ci.byteAt(index);
-            if (op == Opcode.GETFIELD) {
-                fieldIsUsed = true
-            }
-        }
-        !fieldIsUsed
+        then: 'the field is not used and getter is called in the method '
+        !isFieldRead(ctMethod) && hasMethodCall(ctMethod)
     }
 
-    def "UseRealmAccessorsInNonDefaultConstructor"() {
+    def "UseRealmAccessors_fieldAccessConstructorIsTransformed"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
         def ctClass = classPool.makeClass('TestClass')
@@ -122,27 +174,50 @@ class BytecodeModifierTest extends Specification {
         def ctMethod = CtNewMethod.make('private void setupAge(int age) { this.age = age; }', ctClass)
         ctClass.addMethod(ctMethod)
 
-        and: 'add a constructor that uses the method'
-        def ctConstructor = CtNewConstructor.make('public TestClass(int age) { setupAge(age); }', ctClass)
-        ctClass.addConstructor(ctConstructor)
+        and: 'add a default constructor that uses the method'
+        def ctDefaultConstructor = CtNewConstructor.make('public TestClass() { int myAge = this.age; }', ctClass)
+        ctClass.addConstructor(ctDefaultConstructor)
+
+        and: 'add a non-default constructor that uses the method'
+        def ctNonDefaultConstructor = CtNewConstructor.make('public TestClass(TestClass other) { int otherAge = other.age; }', ctClass)
+        ctClass.addConstructor(ctNonDefaultConstructor)
 
         and: 'realm accessors are added'
         BytecodeModifier.addRealmAccessors(ctClass)
 
         when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(ctClass, [ctField], [])
+        BytecodeModifier.useRealmAccessors(ctClass, [ctField])
 
         then: 'the field is not used in the method anymore'
-        def methodInfo = ctMethod.getMethodInfo()
+        !isFieldRead(ctDefaultConstructor) && hasMethodCall(ctDefaultConstructor) &&
+                !isFieldRead(ctNonDefaultConstructor) && hasMethodCall(ctNonDefaultConstructor)
+    }
+
+    private static def isFieldRead(CtBehavior behavior) {
+        def methodInfo = behavior.getMethodInfo()
         def codeAttribute = methodInfo.getCodeAttribute()
-        def fieldIsUsed = false
+
+        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
+            int index = ci.next();
+            int op = ci.byteAt(index);
+            if (op == Opcode.GETFIELD) {
+                return true
+            }
+        }
+        return false
+    }
+
+    private static def hasMethodCall(CtBehavior behavior) {
+        def methodInfo = behavior.getMethodInfo()
+        def codeAttribute = methodInfo.getCodeAttribute()
+
         for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
             int index = ci.next();
             int op = ci.byteAt(index);
-            if (op == Opcode.PUTFIELD) {
-                fieldIsUsed = true
+            if (op == Opcode.INVOKEVIRTUAL) {
+                return true
             }
         }
-        !fieldIsUsed
+        return false
     }
 }
diff --git a/realm.properties b/realm.properties
index 60d64cf12c..1be5af0639 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=2.7
+gradleVersion=2.14.1
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index 61e092c997..d520cb8024 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -6,14 +6,13 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
-        classpath 'de.undercouch:gradle-download-task:2.0.0'
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
+        classpath 'com.android.tools.build:gradle:2.2.2'
+        classpath 'de.undercouch:gradle-download-task:3.1.1'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.0.1'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
     }
@@ -23,7 +22,7 @@ allprojects {
     def props = new Properties()
     props.load(new FileInputStream("${rootDir}/../realm.properties"))
     props.each { key, val ->
-        project.set(key, val)
+        project.ext.set(key, val)
     }
 
     group = 'io.realm'
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index 37ab1ae7e9..10553d8870 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -7,21 +7,6 @@
     <Match>
         <Class name="~.*\.Manifest\$.*"/>
     </Match>
-    <Match>
-        <Class name="io.realm.internal.ImplicitTransaction" />
-        <Method name="finalize" />
-        <Bug pattern="FI_NULLIFY_SUPER" />
-    </Match>
-    <Match>
-        <Class name="io.realm.internal.ReadTransaction" />
-        <Method name="finalize" />
-        <Bug pattern="FI_NULLIFY_SUPER" />
-    </Match>
-    <Match>
-        <Class name="io.realm.internal.WriteTransaction" />
-        <Method name="finalize" />
-        <Bug pattern="FI_NULLIFY_SUPER" />
-    </Match>
     <Match>
         <Class name="io.realm.Realm" />
         <Method name="checkHasPrimaryKey" />
@@ -43,15 +28,22 @@
         <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
     </Match>
     <Match>
-        <Class name="io.realm.internal.SharedGroup" />
-        <Field name="INCREMENTAL_BACKOFF_MS" />
-        <Bug pattern="MS_FINAL_PKGPROTECT" />
+        <Class name="io.realm.SyncManager" />
+        <Field name="APP_ID" />
+        <Bug pattern="MS_SHOULD_BE_FINAL" />
     </Match>
     <Match>
-        <Class name="io.realm.internal.SharedGroup" />
-        <Field name="INCREMENTAL_BACKOFF_LIMIT_MS" />
-        <Bug pattern="MS_SHOULD_BE_FINAL" />
+        <Class name="io.realm.SyncManager" />
+        <Field name="APP_ID" />
+        <Bug pattern="MS_CANNOT_BE_FINAL" />
     </Match>
+    <Match>
+        <Class name="io.realm.SyncUser" />
+        <Field name="managementRealmConfig" />
+        <Bug pattern="IS2_INCONSISTENT_SYNC" />
+    </Match>
+
+
 
     <!-- Unit tests -->
     <Match>
@@ -73,5 +65,48 @@
         <Method name="completedAsyncRealmObject" />
         <Bug pattern="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN" />
     </Match>
-
+    <Match>
+        <Class name="io.realm.permissions.PermissionChange" />
+        <Method name="mayManage" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.permissions.PermissionChange" />
+        <Method name="mayRead" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.permissions.PermissionChange" />
+        <Method name="mayWrite" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.PermissionChangeRealmProxy" />
+        <Method name="realmGet$mayManage" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.PermissionChangeRealmProxy" />
+        <Method name="realmGet$mayRead" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.PermissionChangeRealmProxy" />
+        <Method name="realmGet$mayWrite" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
+    <Match>
+        <Class name="io.realm.permissions.PermissionChange" />
+        <Method name="getCreatedAt" />
+        <Bug pattern="EI_EXPOSE_REP" />
+    </Match>
+    <Match>
+        <Class name="io.realm.permissions.PermissionChange" />
+        <Method name="getUpdatedAt" />
+        <Bug pattern="EI_EXPOSE_REP" />
+    </Match>
+    <Match>
+        <Class name="io.realm.PermissionChangeRealmProxy" />
+        <Bug pattern="BC_IMPOSSIBLE_CAST" />
+    </Match>
 </FindBugsFilter>
diff --git a/realm/config/pmd/ruleset.xml b/realm/config/pmd/ruleset.xml
index a3596aa24e..c777aa8319 100644
--- a/realm/config/pmd/ruleset.xml
+++ b/realm/config/pmd/ruleset.xml
@@ -8,10 +8,6 @@
         Realm PMD ruleset
     </description>
 
-    <rule ref="rulesets/java/basic.xml">
-        <exclude name="UselessParentheses"/>
-    </rule>
-
     <rule ref="rulesets/java/android.xml"/>
 
-</ruleset>
\ No newline at end of file
+</ruleset>
diff --git a/realm/gradle.properties b/realm/gradle.properties
index 033fd72f9a..f3f16fcaac 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1 +1 @@
-org.gradle.jvmargs=-Xms256m -Xmx2048m
+org.gradle.jvmargs=-Xms512m -Xmx2048m
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index e8c6bf7bb4..3baa851b28 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..897f3bf902 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Jan 05 14:18:17 CET 2016
+#Tue Sep 20 14:03:59 CST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
diff --git a/realm/gradlew b/realm/gradlew
index 97fac783e1..27309d9231 100755
--- a/realm/gradlew
+++ b/realm/gradlew
@@ -6,12 +6,30 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
diff --git a/realm/gradlew.bat b/realm/gradlew.bat
index aec99730b4..f6d5974e72 100644
--- a/realm/gradlew.bat
+++ b/realm/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,7 +46,7 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
 if "%@eval[2+2]" == "4" goto 4NT_args
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index b6ca11d063..ac1e0ba50c 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -11,7 +11,7 @@ dependencies {
     compile group:'com.squareup', name:'javawriter', version:'2.5.0'
     compile "io.realm:realm-annotations:${version}"
 
-    testCompile files('../realm-library/build/intermediates/bundles/release/classes.jar') // Java projects cannot depend on AAR files
+    testCompile files('../realm-library/build/intermediates/bundles/base/release/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
@@ -40,6 +40,11 @@ sourceSets {
 compileJava.dependsOn generateVersionClass
 compileTestJava.dependsOn ':realm-library:assemble'
 
+task ojoUpload() {
+    dependsOn "artifactoryPublish"
+    group = 'Publishing'
+}
+
 def commonPom = {
     licenses {
         license {
@@ -61,19 +66,32 @@ def commonPom = {
 
 publishing {
     publications {
-        realmPublication(MavenPublication) {
+        basePublication(MavenPublication) {
             groupId 'io.realm'
             artifactId = 'realm-annotations-processor'
             from components.java
             pom.withXml {
                 Node root = asNode()
-                root.appendNode('name', 'realm-gradle-plugin')
+                root.appendNode('name', 'realm-annotations-processor')
                 root.appendNode('description', 'Annotation Processor for Realm. Realm is a mobile database: a replacement for SQLite & ORMs')
                 root.appendNode('url', 'http://realm.io')
                 root.children().last() + commonPom
             }
         }
     }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
+    }
 }
 
 bintray {
@@ -83,7 +101,7 @@ bintray {
     dryRun = false
     publish = false
 
-    publications = ['realmPublication']
+    publications = ['basePublication']
     pkg {
         repo = 'maven'
         name = 'realm-annotations-processor'
@@ -106,7 +124,7 @@ artifactory {
             password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
         }
         defaults {
-            publications ('realmPublication')
+            publications ('basePublication')
         }
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index e13bbc4626..de43217461 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -204,7 +204,7 @@ private boolean checkReferenceTypes() {
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
-            Utils.error("A default public constructor with no argument must be declared if a custom constructor is declared.");
+            Utils.error("A default public constructor with no argument must be declared in " + className + " if a custom constructor is declared.");
             return false;
         } else {
             return true;
@@ -322,7 +322,7 @@ public String getSimpleClassName() {
      */
     public boolean isModelClass() {
         String type = classType.toString();
-        if (type.equals("io.realm.dynamic.DynamicRealmObject")) {
+        if (type.equals("io.realm.DynamicRealmObject")) {
             return false;
         }
         return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
@@ -373,6 +373,29 @@ public boolean isNullable(VariableElement variableElement) {
         return nullableFields.contains(variableElement);
     }
 
+    /**
+     * Checks if a VariableElement is indexed.
+     *
+     * @param variableElement the element/field
+     * @return {@code true} if a VariableElement is indexed, {@code false} otherwise.
+     */
+    public boolean isIndexed(VariableElement variableElement) {
+        return indexedFields.contains(variableElement);
+    }
+
+    /**
+     * Checks if a VariableElement is a primary key.
+     *
+     * @param variableElement the element/field
+     * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
+     */
+    public boolean isPrimaryKey(VariableElement variableElement) {
+        if (primaryKey == null) {
+            return false;
+        }
+        return primaryKey.equals(variableElement);
+    }
+
     private boolean isValidPrimaryKeyType(TypeMirror type) {
         for (TypeMirror validType : validPrimaryKeyTypes) {
             if (typeUtils.isAssignable(type, validType)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 68b2f11ca9..791f81df9c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -28,6 +28,11 @@
     public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
     static final String STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
             "throw new IllegalArgumentException(\"Trying to set non-nullable field '%s' to null.\")";
+    static final String STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON =
+            "throw new IllegalArgumentException(\"JSON object doesn't have the primary key field '%s'.\")";
+    static final String STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED =
+            "throw new io.realm.exceptions.RealmException(\"Primary key field '%s' cannot be changed after object" +
+                    " was created.\")";
 
     static final Map<String, String> JAVA_TO_REALM_TYPES;
     static {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index be87d9004c..1ace559402 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -101,11 +101,13 @@ public boolean generate(ProcessingEnvironment processingEnv) {
             return false;
         }
 
-        // Add default realm module if needed.
-        if (libraryModules.size() == 0) {
+        // Create default Realm module if needed.
+        // Note: Kotlin will trigger the annotation processor even if no Realm annotations are used.
+        // The DefaultRealmModule should not be created in this case either.
+        if (libraryModules.size() == 0 && availableClasses.size() > 0) {
             shouldCreateDefaultModule = true;
-            String defautModuleName = Constants.REALM_PACKAGE_NAME + "." + Constants.DEFAULT_MODULE_CLASS_NAME;
-            modules.put(defautModuleName, availableClasses);
+            String defaultModuleName = Constants.REALM_PACKAGE_NAME + "." + Constants.DEFAULT_MODULE_CLASS_NAME;
+            modules.put(defaultModuleName, availableClasses);
         }
 
         return true;
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index cd63ab09a3..af9402ab21 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -68,7 +68,7 @@ public void emitTypeConversion(String interfaceName, String setter, String field
 
             @Override
             public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String
-                    fieldType, JavaWriter writer)
+                    fieldType, JavaWriter writer, boolean isPrimaryKey)
                     throws IOException {
                 writer
                     .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
@@ -110,7 +110,7 @@ public void emitTypeConversion(String interfaceName, String setter, String field
 
             @Override
             public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String
-                    fieldType, JavaWriter writer)
+                    fieldType, JavaWriter writer, boolean isPrimaryKey)
                     throws IOException {
                 writer
                     .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
@@ -183,11 +183,16 @@ public static void emitFillRealmListWithJsonValue(String interfaceName, String g
     }
 
 
-    public static void emitFillJavaTypeFromStream(String interfaceName, String setter, String fieldName, String
+    public static void emitFillJavaTypeFromStream(String interfaceName, ClassMetaData metaData, String fieldName, String
             fieldType, JavaWriter writer) throws IOException {
+        String setter = metaData.getSetter(fieldName);
+        boolean isPrimaryKey = false;
+        if (metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName)) {
+            isPrimaryKey = true;
+        }
         if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
             JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType,
-                    writer);
+                    writer, isPrimaryKey);
         }
     }
 
@@ -211,6 +216,7 @@ public static void emitFillRealmListFromStream(String interfaceName, String gett
                 .emitStatement("reader.skipValue()")
                 .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
             .nextControlFlow("else")
+                .emitStatement("((%s) obj).%s(new RealmList<%s>())", interfaceName, setter, fieldTypeCanonicalName)
                 .emitStatement("reader.beginArray()")
                 .beginControlFlow("while (reader.hasNext())")
                     .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
@@ -264,7 +270,7 @@ public void emitTypeConversion(String interfaceName, String setter, String field
 
         @Override
         public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                                             JavaWriter writer)
+                                             JavaWriter writer, boolean isPrimaryKey)
                 throws IOException {
             String statementSetNullOrThrow;
             if (Utils.isPrimitiveType(fieldType)) {
@@ -281,6 +287,9 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
                 .nextControlFlow("else")
                     .emitStatement("((%s) obj).%s((%s) reader.next%s())", interfaceName, setter, castType, jsonType)
                 .endControlFlow();
+            if (isPrimaryKey) {
+                writer.emitStatement("jsonHasPrimaryKey = true");
+            }
         }
 
         @Override
@@ -292,15 +301,14 @@ public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("obj = (%1$s) realm.createObject(%2$s.class, null)",
+                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, null, true, excludeFields)",
                                 qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
                     .nextControlFlow("else")
-                        .emitStatement("obj = (%1$s) realm.createObject(%2$s.class, json.get%3$s(\"%4$s\"))",
+                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
                                 qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass, jsonType, fieldName)
                     .endControlFlow()
                 .nextControlFlow("else")
-                    .emitStatement("obj = (%1$s) realm.createObject(%2$s.class)",
-                            qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
+                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, fieldName)
                     .endControlFlow();
         }
     }
@@ -309,7 +317,7 @@ public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
         void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType, JavaWriter
                 writer) throws IOException;
         void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                                      JavaWriter writer) throws IOException;
+                                      JavaWriter writer, boolean isPrimaryKey) throws IOException;
         void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
                                               String qualifiedRealmObjectProxyClass,
                                               String fieldName, JavaWriter writer) throws IOException;
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 1e437f8bcf..59f14327d7 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -90,6 +90,28 @@
  *  <li>Each time a static helper method is needed, Realm can now delegate these method calls to the appropriate
  *    Mediator which in turn will delegate the method call to the appropriate RealmObjectProxy class.</li>
  * </ol>
+ *
+ * <h1>CREATING A MANAGED RealmObject</h1>
+ *
+ * To allow to specify default values by model's constructor or direct field assignment,
+ * the flow of creating the proxy object is a bit complicated. This section illustrates
+ * how proxy object should be created.
+ *
+ * <ol>
+ *  <li>Get the thread local {@code io.realm.BaseRealm.RealmObjectContext} instance by {@code BaseRealm.objectContext.get()} </li>
+ *  <li>Set the object context information to the {@code RealmObjectContext} those should be set to the creating proxy object.</li>
+ *  <li>Create proxy object ({@code new io.realm.FooRealmProxy()}).</li>
+ *  <li>Set the object context information to the created proxy when the first access of its accessors (or in its constructor if accessors are not used in the model's constructor).</li>
+ *  <li>Clear the object context information in the thread local {@code io.realm.BaseRealm.RealmObjectContext} instance by calling {@code
+ *  #clear()} method.</li>
+ * </ol>
+ *
+ * The reason of this complicated step is that we can't pass these context information
+ * via the constructor of the proxy. It's because the constructor of the proxy is executed
+ * <b>after</b> the constructor of the model class. The access to the fields in the model's
+ * constructor happens before the assignment of the context information to the 'proxyState'.
+ * This will cause the {@link NullPointerException} if getters/setter is accessed in the model's
+ * constructor (see https://github.com/realm/realm-java/issues/2536 ).
  */
 @SupportedAnnotationTypes({
         "io.realm.annotations.RealmClass",
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index cc4f726bf0..f87f679bb8 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -62,17 +62,22 @@ public void generate() throws IOException, UnsupportedOperationException {
                 .emitEmptyLine();
 
         ArrayList<String> imports = new ArrayList<String>();
+        imports.add("android.annotation.TargetApi");
+        imports.add("android.os.Build");
         imports.add("android.util.JsonReader");
         imports.add("android.util.JsonToken");
-        imports.add("io.realm.RealmFieldType");
+        imports.add("io.realm.RealmObjectSchema");
+        imports.add("io.realm.RealmSchema");
         imports.add("io.realm.exceptions.RealmMigrationNeededException");
         imports.add("io.realm.internal.ColumnInfo");
         imports.add("io.realm.internal.RealmObjectProxy");
+        imports.add("io.realm.internal.Row");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
-        imports.add("io.realm.internal.ImplicitTransaction");
+        imports.add("io.realm.internal.SharedRealm");
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
+        imports.add("io.realm.log.RealmLog");
         imports.add("java.io.IOException");
         imports.add("java.util.ArrayList");
         imports.add("java.util.Collections");
@@ -103,7 +108,9 @@ public void generate() throws IOException, UnsupportedOperationException {
 
         emitClassFields(writer);
         emitConstructor(writer);
+        emitInjectContextMethod(writer);
         emitAccessors(writer);
+        emitCreateRealmObjectSchemaMethod(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetTableNameMethod(writer);
@@ -133,13 +140,14 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
                 columnInfoClassName(),                       // full qualified name of the item to generate
                 "class",                                     // the type of the item
                 EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
-                "ColumnInfo")                                // base class
+                "ColumnInfo",                                // base class
+                "Cloneable")                                 // interfaces
                 .emitEmptyLine();
 
         // fields
         for (VariableElement variableElement : metadata.getFields()) {
             writer.emitField("long", columnIndexVarName(variableElement),
-                    EnumSet.of(Modifier.PUBLIC, Modifier.FINAL));
+                    EnumSet.of(Modifier.PUBLIC));
         }
         writer.emitEmptyLine();
 
@@ -155,18 +163,49 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
             writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
                     columnIndexVarName, simpleClassName, columnName);
             writer.emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
-            writer.emitEmptyLine();
         }
+        writer.emitEmptyLine();
         writer.emitStatement("setIndicesMap(indicesMap)");
         writer.endConstructor();
+        writer.emitEmptyLine();
 
-        writer.endType();
+        // copyColumnInfoFrom method
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",                      // return type
+                "copyColumnInfoFrom",        // method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.FINAL), // modifiers
+                "ColumnInfo", "other");      // parameters
+        {
+            writer.emitStatement("final %1$s otherInfo = (%1$s) other", columnInfoClassName());
+
+            // copy field values
+            for (VariableElement variableElement : metadata.getFields()) {
+                writer.emitStatement("this.%1$s = otherInfo.%1$s", columnIndexVarName(variableElement));
+            }
+            writer.emitEmptyLine();
+            writer.emitStatement("setIndicesMap(otherInfo.getIndicesMap())");
+        }
+        writer.endMethod();
         writer.emitEmptyLine();
+
+        // clone method
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                columnInfoClassName(),       // return type
+                "clone",                     // method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.FINAL)) // modifiers
+                // method body
+                .emitStatement("return (%1$s) super.clone()", columnInfoClassName())
+                .endMethod()
+                .emitEmptyLine();
+
+        writer.endType();
     }
 
     private void emitClassFields(JavaWriter writer) throws IOException {
-        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
-        writer.emitField("ProxyState", "proxyState", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
+        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE));
+        writer.emitField("ProxyState", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
@@ -188,27 +227,30 @@ private void emitClassFields(JavaWriter writer) throws IOException {
 
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class), "ColumnInfo", "columnInfo");
-        writer.emitStatement("this.columnInfo = (%s) columnInfo", columnInfoClassName());
-        writer.emitStatement("this.proxyState = new ProxyState(%s.class, this)", qualifiedClassName);
+        writer.beginConstructor(EnumSet.noneOf(Modifier.class));
+        writer.beginControlFlow("if (proxyState == null)")
+                .emitStatement("injectObjectContext()")
+                .endControlFlow();
+        writer.emitStatement("proxyState.setConstructionFinished()");
         writer.endConstructor();
         writer.emitEmptyLine();
     }
 
-    private void emitAccessors(JavaWriter writer) throws IOException {
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
+    private void emitAccessors(final JavaWriter writer) throws IOException {
+        for (final VariableElement field : metadata.getFields()) {
+            final String fieldName = field.getSimpleName().toString();
+            final String fieldTypeCanonicalName = field.asType().toString();
 
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 /**
                  * Primitives and boxed types
                  */
-                String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+                final String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
 
                 // Getter
                 writer.emitAnnotation("SuppressWarnings", "\"cast\"");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
                 // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
@@ -220,7 +262,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // For Boxed types, this should be the corresponding primitive types. Others remain the same.
                 String castingBackType;
-                if (Utils.isBoxedType(field.asType().toString())) {
+                if (Utils.isBoxedType(fieldTypeCanonicalName)) {
                     Types typeUtils = processingEnvironment.getTypeUtils();
                     castingBackType = typeUtils.unboxedType(field.asType()).toString();
                 } else {
@@ -234,24 +276,53 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                emitCodeForInjectingObjectContext(writer);
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+                    @Override
+                    public void emit(JavaWriter writer) throws IOException {
+                        // set value as default value
+                        writer.emitStatement("final Row row = proxyState.getRow$realm()");
+
+                        if (metadata.isNullable(field)) {
+                            writer.beginControlFlow("if (value == null)")
+                                    .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
+                                            fieldIndexVariableReference(field))
+                                    .emitStatement("return")
+                                .endControlFlow();
+                        } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                            writer.beginControlFlow("if (value == null)")
+                                    .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                                .endControlFlow();
+                        }
+                        writer.emitStatement(
+                                "row.getTable().set%s(%s, row.getIndex(), value, true)",
+                                realmType, fieldIndexVariableReference(field));
+                        writer.emitStatement("return");
+                    }
+                });
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
                 // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
-                if (metadata.isNullable(field)) {
-                    writer.beginControlFlow("if (value == null)")
-                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
-                        .emitStatement("return")
-                    .endControlFlow();
-                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
-                    // Same reason, throw IAE earlier.
-                    writer
-                        .beginControlFlow("if (value == null)")
-                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                        .endControlFlow();
+                if (metadata.isPrimaryKey(field)) {
+                    // Primary key is not allowed to be changed after object created.
+                    writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
+                } else {
+                    if (metadata.isNullable(field)) {
+                        writer.beginControlFlow("if (value == null)")
+                                .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
+                                .emitStatement("return")
+                                .endControlFlow();
+                    } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                        // Same reason, throw IAE earlier.
+                        writer
+                                .beginControlFlow("if (value == null)")
+                                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                                .endControlFlow();
+                    }
+                    writer.emitStatement(
+                            "proxyState.getRow$realm().set%s(%s, value)",
+                            realmType, fieldIndexVariableReference(field));
                 }
-                writer.emitStatement(
-                        "proxyState.getRow$realm().set%s(%s, value)",
-                        realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
             } else if (Utils.isRealmModel(field)) {
                 /**
@@ -260,23 +331,55 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field));
                         writer.emitStatement("return null");
                         writer.endControlFlow();
-                writer.emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s))",
+                writer.emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
                         fieldTypeCanonicalName, fieldIndexVariableReference(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                emitCodeForInjectingObjectContext(writer);
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+                    @Override
+                    public void emit(JavaWriter writer) throws IOException {
+                        // check excludeFields
+                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                                field.getSimpleName().toString())
+                                .emitStatement("return")
+                            .endControlFlow();
+                        writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
+                                .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
+                            .endControlFlow();
+
+                        // set value as default value
+                        writer.emitStatement("final Row row = proxyState.getRow$realm()");
+                        writer.beginControlFlow("if (value == null)")
+                                .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
+                                .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
+                                .emitStatement("return")
+                            .endControlFlow();
+                        writer.beginControlFlow("if (!RealmObject.isValid(value))")
+                                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
+                            .endControlFlow();
+                        writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
+                            .endControlFlow();
+                        writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
+                                fieldIndexVariableReference(field));
+                        writer.emitStatement("return");
+                    }
+                });
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (value == null)");
                     writer.emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field));
                     writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!RealmObject.isValid(value))");
+                writer.beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))");
                     writer.emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")");
                 writer.endControlFlow();
                 writer.beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
@@ -292,6 +395,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.emitSingleLineComment("use the cached value if available");
                 writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
@@ -308,6 +412,32 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                emitCodeForInjectingObjectContext(writer);
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
+                    @Override
+                    public void emit(JavaWriter writer) throws IOException {
+                        // check excludeFields
+                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                                field.getSimpleName().toString())
+                                .emitStatement("return")
+                                .endControlFlow();
+                        final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
+                        writer.beginControlFlow("if (value != null && !value.isManaged())")
+                                .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
+                                .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
+                                .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
+                                .beginControlFlow("for (%1$s item : original)", modelFqcn)
+                                    .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                                        .emitStatement("value.add(item)")
+                                    .nextControlFlow("else")
+                                        .emitStatement("value.add(realm.copyToRealm(item))")
+                                    .endControlFlow()
+                                .endControlFlow()
+                            .endControlFlow();
+
+                        // LinkView currently does not support default value feature. Just fallback to normal code.
+                    }
+                });
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
                 writer.emitStatement("links.clear()");
@@ -315,7 +445,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                     writer.emitStatement("return");
                 writer.endControlFlow();
                 writer.beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)");
-                    writer.beginControlFlow("if (!RealmObject.isValid(linkedObject))");
+                    writer.beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))");
                         writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")");
                     writer.endControlFlow();
                     writer.beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
@@ -332,6 +462,57 @@ private void emitAccessors(JavaWriter writer) throws IOException {
         }
     }
 
+    private void emitCodeForInjectingObjectContext(JavaWriter writer) throws IOException {
+        // if invoked from model's constructor, inject BaseRealm and Row
+        writer.beginControlFlow("if (proxyState == null)");
+        {
+            writer.emitSingleLineComment("Called from model's constructor. Inject context.");
+            writer.emitStatement("injectObjectContext()");
+        }
+        writer.endControlFlow();
+        writer.emitEmptyLine();
+    }
+
+    private interface CodeEmitter {
+        void emit(JavaWriter writer) throws IOException;
+    }
+
+    private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKey,
+                                              CodeEmitter defaultValueCodeEmitter) throws IOException {
+        writer.beginControlFlow("if (proxyState.isUnderConstruction())");
+        if (isPrimaryKey) {
+            writer.emitSingleLineComment("default value of the primary key is always ignored.");
+            writer.emitStatement("return");
+        } else {
+            writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
+                    .emitStatement("return")
+                    .endControlFlow();
+            defaultValueCodeEmitter.emit(writer);
+        }
+        writer.endControlFlow();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInjectContextMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "void", // Return type
+                "injectObjectContext", // Method name
+                EnumSet.of(Modifier.PRIVATE) // Modifiers
+                ); // Argument type & argument name
+
+        writer.emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()");
+        writer.emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName());
+        writer.emitStatement("this.proxyState = new ProxyState(%1$s.class, this)", qualifiedClassName);
+        writer.emitStatement("proxyState.setRealm$realm(context.getRealm())");
+        writer.emitStatement("proxyState.setRow$realm(context.getRow())");
+        writer.emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())");
+        writer.emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+
     private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod("ProxyState", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC));
@@ -340,15 +521,63 @@ private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOExce
         writer.emitEmptyLine();
     }
 
+    private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "RealmObjectSchema", // Return type
+                "createRealmObjectSchema", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "RealmSchema", "realmSchema"); // Argument type & argument name
+
+        writer.beginControlFlow("if (!realmSchema.contains(\"" + this.simpleClassName + "\"))");
+        writer.emitStatement("RealmObjectSchema realmObjectSchema = realmSchema.create(\"%s\")", this.simpleClassName);
+
+        // For each field generate corresponding table index constant
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldTypeCanonicalName = field.asType().toString();
+            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
+
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+                String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
+                String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
+                String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
+                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", %s, %s, %s, %s))",
+                        fieldName,
+                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
+                        primaryKeyFlag,
+                        indexedFlag,
+                        nullableFlag);
+            } else if (Utils.isRealmModel(field)) {
+                writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))");
+                writer.emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
+                writer.endControlFlow();
+                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\")))",
+                        fieldName, fieldTypeSimpleName);
+            } else if (Utils.isRealmList(field)) {
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName +"\"))");
+                writer.emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX);
+                writer.endControlFlow();
+                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\")))",
+                        fieldName, genericTypeSimpleName);
+            }
+        }
+        writer.emitStatement("return realmObjectSchema");
+        writer.endControlFlow();
+        writer.emitStatement("return realmSchema.get(\"" + this.simpleClassName + "\")");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitInitTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 "Table", // Return type
                 "initTable", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "ImplicitTransaction", "transaction"); // Argument type & argument name
+                "SharedRealm", "sharedRealm"); // Argument type & argument name
 
-        writer.beginControlFlow("if (!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
+        writer.beginControlFlow("if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
 
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
@@ -367,17 +596,17 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         fieldName, nullableFlag);
             } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("%s%s.initTable(sharedRealm)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", transaction.getTable(\"%s%s\"))",
+                writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", sharedRealm.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
-                writer.emitStatement("%s.initTable(transaction)", Utils.getProxyClassName(genericTypeSimpleName));
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
+                writer.emitStatement("%s.initTable(sharedRealm)", Utils.getProxyClassName(genericTypeSimpleName));
                 writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", transaction.getTable(\"%s%s\"))",
+                writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", sharedRealm.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, genericTypeSimpleName);
             }
         }
@@ -396,36 +625,47 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("return table");
         writer.endControlFlow();
-        writer.emitStatement("return transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
+        writer.emitStatement("return sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                columnInfoClassName(), // Return type
-                "validateTable", // Method name
+                columnInfoClassName(),        // Return type
+                "validateTable",              // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "ImplicitTransaction", "transaction"); // Argument type & argument name
+                "SharedRealm", "sharedRealm", // Argument type & argument name
+                "boolean", "allowExtraColumns");
 
-        writer.beginControlFlow("if (transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
+        writer.beginControlFlow("if (sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
 
         // verify number of columns
-        writer.beginControlFlow("if (table.getColumnCount() != " + metadata.getFields().size() + ")");
-        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Field count does not match - expected %d but was \" + table.getColumnCount())",
-                metadata.getFields().size());
+        writer.emitStatement("final long columnCount = table.getColumnCount()");
+        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
+            writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Field count is less than expected - expected %d but was \" + columnCount)",
+                        metadata.getFields().size());
+            writer.endControlFlow();
+            writer.beginControlFlow("if (allowExtraColumns)");
+                writer.emitStatement("RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
+                        metadata.getFields().size());
+            writer.nextControlFlow("else");
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Field count is more than expected - expected %d but was \" + columnCount)",
+                        metadata.getFields().size());
+            writer.endControlFlow();
         writer.endControlFlow();
 
         // create type dictionary for lookup
         writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
-        writer.beginControlFlow("for (long i = 0; i < " + metadata.getFields().size() + "; i++)");
+        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)");
         writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
         writer.endControlFlow();
         writer.emitEmptyLine();
 
         // create an instance of ColumnInfo
-        writer.emitStatement("final %1$s columnInfo = new %1$s(transaction.getPath(), table)", columnInfoClassName());
+        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName());
         writer.emitEmptyLine();
 
         // For each field verify there is a corresponding
@@ -438,13 +678,13 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                 // make sure types align
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s' in existing Realm file. " +
                         "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
                         "\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
                         fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
@@ -452,20 +692,20 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 if (metadata.isNullable(field)) {
                     writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
                     // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
-                    if (field.equals(metadata.getPrimaryKey())) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                    if (metadata.isPrimaryKey(field)) {
+                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                 "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                 "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                                 fieldName);
                     // nullability check for boxed types
                     } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                 "\"Field '%s' does not support null values in the existing Realm file. " +
                                 "Either set @Required, use the primitive type for field '%s' " +
                                 "or migrate using RealmObjectSchema.setNullable().\")",
                                 fieldName, fieldName);
                     } else {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                 " \"Field '%s' is required. Either set @Required to field '%s' " +
                                 "or migrate using RealmObjectSchema.setNullable().\")",
                                 fieldName, fieldName);
@@ -473,7 +713,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     writer.endControlFlow();
                 } else {
                     // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
-                    if (field.equals(metadata.getPrimaryKey())) {
+                    if (metadata.isPrimaryKey(field)) {
                         writer
                             .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != TableOrView.NO_MATCH)",
                                     fieldIndexVariableReference(field), fieldIndexVariableReference(field))
@@ -484,12 +724,12 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     } else {
                         writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
                         if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
-                            writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                            writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                     " \"Field '%s' does support null values in the existing Realm file. " +
                                     "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                                     fieldName, fieldName);
                         } else {
-                            writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                            writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                     " \"Field '%s' does support null values in the existing Realm file. " +
                                     "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                                     fieldName, fieldName);
@@ -499,58 +739,58 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 }
 
                 // Validate @PrimaryKey
-                if (field.equals(metadata.getPrimaryKey())) {
+                if (metadata.isPrimaryKey(field)) {
                     writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Primary key not defined for field '%s' in existing Realm file. Add @PrimaryKey.\")", fieldName);
+                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary key not defined for field '%s' in existing Realm file. Add @PrimaryKey.\")", fieldName);
                     writer.endControlFlow();
                 }
 
                 // Validate @Index
                 if (metadata.getIndexedFields().contains(field)) {
                     writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Index not defined for field '%s' in existing Realm file. " +
+                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Index not defined for field '%s' in existing Realm file. " +
                             "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
                     writer.endControlFlow();
                 }
 
             } else if (Utils.isRealmModel(field)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s' in existing Realm file. " +
                         "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing class '%s%s' for field '%s'\")",
                         Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
-                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
                 writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                         fieldIndexVariableReference(field), fieldIndex);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                         fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
             } else if (Utils.isRealmList(field)) { // Link Lists
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s'\")",
                         genericTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing class '%s%s' for field '%s'\")",
                         Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
-                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
+                writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
                 writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                         fieldIndexVariableReference(field), fieldIndex);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                         fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
             }
@@ -560,7 +800,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("return %s", "columnInfo");
 
         writer.nextControlFlow("else");
-        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"The '%s' class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
+        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"The '%s' class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
@@ -600,6 +840,8 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .emitStatement("return object")
             .endControlFlow();
 
+        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
+
         writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)");
         writer.beginControlFlow("if (cachedRealmObject != null)")
                 .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
@@ -645,12 +887,16 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
 
                 writer
                     .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                        .emitStatement("realmObject = new %s(realm.schema.getColumnInfo(%s.class))",
-                                qualifiedGeneratedClassName,
-                                qualifiedClassName)
-                        .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm)")
-                        .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
-                        .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                        .beginControlFlow("try")
+                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                                    " realm.schema.getColumnInfo(%s.class)," +
+                                    " false, Collections.<String> emptyList())", qualifiedClassName)
+                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
+                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                        .nextControlFlow("finally")
+                            .emitStatement("objectContext.clear()")
+                        .endControlFlow()
+
                     .nextControlFlow("else")
                         .emitStatement("canUpdate = false")
                     .endControlFlow();
@@ -676,7 +922,7 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
                 || "int".equals(fieldType)
                 || "short".equals(fieldType)
                 || "byte".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Long".equals(fieldType)
                 || "java.lang.Integer".equals(fieldType)
@@ -685,52 +931,52 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("Number %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue())", fieldName, getter);
+                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
         } else if ("double".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if("java.lang.Double".equals(fieldType)) {
             writer
                     .emitStatement("Double %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
         } else if ("float".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Float".equals(fieldType)) {
             writer
                     .emitStatement("Float %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
         } else if ("boolean".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Boolean".equals(fieldType)) {
             writer
                     .emitStatement("Boolean %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
@@ -738,10 +984,10 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("byte[] %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
@@ -750,10 +996,10 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("java.util.Date %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime())", fieldName, getter);
+                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
 
@@ -761,10 +1007,10 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
             writer
                     .emitStatement("String %s = ((%s)object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
                     if (isUpdate) {
                         writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
                     }
                     writer.endControlFlow();
         } else {
@@ -813,7 +1059,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                                         Utils.getProxyClassSimpleName(field),
                                         fieldName)
                             .endControlFlow()
-                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -830,7 +1076,6 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                              .endControlFlow()
                              .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                             .endControlFlow()
-                            .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
                         .endControlFlow()
                         .emitEmptyLine();
 
@@ -891,7 +1136,7 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                                         Utils.getProxyClassSimpleName(field),
                                         fieldName)
                                 .endControlFlow()
-                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
             } else if (Utils.isRealmList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -908,7 +1153,6 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                              .endControlFlow()
                         .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                         .endControlFlow()
-                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
                         .endControlFlow()
                         .emitEmptyLine();
 
@@ -965,7 +1209,7 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                                         fieldName,
                                         Utils.getProxyClassSimpleName(field))
                             .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
                                 // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                             .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
@@ -987,7 +1231,6 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                                 .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                             .endControlFlow()
                         .endControlFlow()
-                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
                         .emitEmptyLine();
 
             } else {
@@ -1046,7 +1289,7 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                                         fieldName,
                                         Utils.getProxyClassSimpleName(field))
                                     .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
                                 // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                             .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
@@ -1068,7 +1311,6 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                             .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                             .endControlFlow()
                         .endControlFlow()
-                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
                         .emitEmptyLine();
 
             } else {
@@ -1122,15 +1364,11 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
             }
 
             writer.beginControlFlow("if (rowIndex == TableOrView.NO_MATCH)");
-            writer.emitStatement("rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1)");
             if (Utils.isString(metadata.getPrimaryKey())) {
-                writer.beginControlFlow("if (primaryKeyValue != null)");
-                writer.emitStatement("Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue)");
-                writer.endControlFlow();
+                writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false)");
             } else {
-                writer.beginControlFlow("if (primaryKeyValue != null)");
-                writer.emitStatement("Table.nativeSetLong(tableNativePtr, pkColumnIndex, rowIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
-                writer.endControlFlow();
+                writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(((%s) object).%s(), false)",
+                        interfaceName, primaryKeyGetter);
             }
 
             if (throwIfPrimaryKeyDuplicate) {
@@ -1158,11 +1396,13 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
               .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
               .nextControlFlow("else");
 
+            writer.emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
             if (metadata.hasPrimaryKey()) {
-                writer.emitStatement("%s realmObject = realm.createObject(%s.class, ((%s) newObject).%s())",
+                writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
                         qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
             } else {
-                writer.emitStatement("%s realmObject = realm.createObject(%s.class)", qualifiedClassName, qualifiedClassName);
+                writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
+                        qualifiedClassName, qualifiedClassName);
             }
             writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
             for (VariableElement field : metadata.getFields()) {
@@ -1171,6 +1411,11 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 String setter = metadata.getSetter(fieldName);
                 String getter = metadata.getGetter(fieldName);
 
+                if (metadata.isPrimaryKey(field)) {
+                    // PK has been set when creating object.
+                    continue;
+                }
+
                 if (Utils.isRealmModel(field)) {
                     writer
                         .emitEmptyLine()
@@ -1447,7 +1692,7 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
         writer.emitStatement("String path = proxyState.getRealm$realm().getPath()");
         writer.emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName);
-        writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false;");
+        writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false");
         writer.emitEmptyLine();
         writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
         writer.emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName);
@@ -1460,7 +1705,6 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-
     private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
@@ -1470,8 +1714,17 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                 Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Collections.singletonList("JSONException"));
 
+        final int modelOrListCount = countModelOrListFields(metadata.getFields());
+        if (modelOrListCount == 0) {
+            writer.emitStatement("final List<String> excludeFields = Collections.<String> emptyList()");
+        } else {
+            writer.emitStatement("final List<String> excludeFields = new ArrayList<String>(%1$d)",
+                    modelOrListCount);
+        }
         if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s obj = realm.createObject(%s.class)", qualifiedClassName, qualifiedClassName);
+            buildExcludeFieldsList(writer, metadata.getFields());
+            writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
+                    qualifiedClassName, qualifiedClassName);
         } else {
             String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
             writer
@@ -1497,14 +1750,20 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             }
             writer
                     .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                        .emitStatement("obj = new %s(realm.schema.getColumnInfo(%s.class))",
-                                qualifiedGeneratedClassName, qualifiedClassName)
-                        .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm)")
-                        .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
+                        .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                        .beginControlFlow("try")
+                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                                    " realm.schema.getColumnInfo(%s.class)," +
+                                    " false, Collections.<String> emptyList())", qualifiedClassName)
+                            .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
+                        .nextControlFlow("finally")
+                            .emitStatement("objectContext.clear()")
+                        .endControlFlow()
                     .endControlFlow()
                 .endControlFlow();
 
             writer.beginControlFlow("if (obj == null)");
+            buildExcludeFieldsList(writer, metadata.getFields());
             String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
             String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
             RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedClassName, qualifiedGeneratedClassName,
@@ -1515,6 +1774,10 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
+            if (metadata.isPrimaryKey(field)) {
+                // Primary key has already been set when adding new row or finding the existing row.
+                continue;
+            }
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                         interfaceName,
@@ -1551,8 +1814,22 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         writer.emitEmptyLine();
     }
 
+    private void buildExcludeFieldsList(JavaWriter writer, List<VariableElement> fields) throws IOException {
+        for (VariableElement field : fields) {
+            if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
+                final String fieldName = field.getSimpleName().toString();
+                writer.beginControlFlow("if (json.has(\"%1$s\"))", fieldName)
+                        .emitStatement("excludeFields.add(\"%1$s\")", fieldName)
+                        .endControlFlow();
+            }
+        }
+    }
+
+    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
+    // instead of createObject() to avoid parsing the stream twice.
     private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
+        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
         writer.beginMethod(
                 qualifiedClassName,
                 "createUsingJsonStream",
@@ -1560,7 +1837,10 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                 Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                 Collections.singletonList("IOException"));
 
-        writer.emitStatement("%s obj = realm.createObject(%s.class)",qualifiedClassName, qualifiedClassName);
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("boolean jsonHasPrimaryKey = false");
+        }
+        writer.emitStatement("%s obj = new %s()", qualifiedClassName, qualifiedClassName);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
@@ -1598,7 +1878,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                         interfaceName,
-                        metadata.getSetter(fieldName),
+                        metadata,
                         fieldName,
                         qualifiedFieldType,
                         writer
@@ -1613,9 +1893,16 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         }
         writer.endControlFlow();
         writer.emitStatement("reader.endObject()");
+        if (metadata.hasPrimaryKey()) {
+            writer.beginControlFlow("if (!jsonHasPrimaryKey)");
+            writer.emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey());
+            writer.endControlFlow();
+        }
+        writer.emitStatement("obj = realm.copyToRealm(obj)");
         writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
+
     }
 
     private String columnInfoClassName() {
@@ -1629,4 +1916,14 @@ private String columnIndexVarName(VariableElement variableElement) {
     private String fieldIndexVariableReference(VariableElement variableElement) {
         return "columnInfo." + columnIndexVarName(variableElement);
     }
+
+    private static int countModelOrListFields(List<VariableElement> fields) {
+        int count = 0;
+        for (VariableElement f : fields) {
+            if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
+                count++;
+            }
+        }
+        return count;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 091253a819..e438b10348 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -69,15 +69,17 @@ public void generate() throws IOException {
                 "java.util.HashSet",
                 "java.util.List",
                 "java.util.Map",
-                "java.util.IdentityHashMap",
+                "java.util.HashMap",
                 "java.util.Set",
                 "java.util.Iterator",
                 "java.util.Collection",
                 "io.realm.internal.ColumnInfo",
-                "io.realm.internal.ImplicitTransaction",
+                "io.realm.internal.SharedRealm",
                 "io.realm.internal.RealmObjectProxy",
                 "io.realm.internal.RealmProxyMediator",
+                "io.realm.internal.Row",
                 "io.realm.internal.Table",
+                "io.realm.RealmObjectSchema",
                 "org.json.JSONException",
                 "org.json.JSONObject"
         );
@@ -94,6 +96,7 @@ public void generate() throws IOException {
 
         emitFields(writer);
         emitCreateTableMethod(writer);
+        emitCreateRealmObjectSchema(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitGetTableNameMethod(writer);
@@ -123,18 +126,36 @@ private void emitFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    private void emitCreateRealmObjectSchema(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "RealmObjectSchema",
+                "createRealmObjectSchema",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmModel>", "clazz", "RealmSchema", "realmSchema"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return %s.createRealmObjectSchema(realmSchema)", qualifiedProxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitCreateTableMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
                 "Table",
                 "createTable",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "ImplicitTransaction", "transaction"
+                "Class<? extends RealmModel>", "clazz", "SharedRealm", "sharedRealm"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.initTable(transaction)", qualifiedProxyClasses.get(i));
+                writer.emitStatement("return %s.initTable(sharedRealm)", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -147,12 +168,15 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 "ColumnInfo",
                 "validateTable",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "ImplicitTransaction", "transaction"
+                "Class<? extends RealmModel>", "clazz", // Argument type & argument name
+                "SharedRealm", "sharedRealm",
+                "boolean", "allowExtraColumns"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.validateTable(transaction)", qualifiedProxyClasses.get(i));
+                writer.emitStatement("return %s.validateTable(sharedRealm, allowExtraColumns)",
+                        qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -201,14 +225,25 @@ private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
                 "<E extends RealmModel> E",
                 "newInstance",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<E>", "clazz", "ColumnInfo", "columnInfo"
+                "Class<E>", "clazz",
+                "Object", "baseRealm",
+                "Row", "row",
+                "ColumnInfo", "columnInfo",
+                "boolean", "acceptDefaultValue",
+                "List<String>", "excludeFields"
         );
+        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
+        writer.beginControlFlow("try")
+                .emitStatement("objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields)");
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(new %s(columnInfo))", qualifiedProxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(new %s())", qualifiedProxyClasses.get(i));
             }
         }, writer);
+        writer.nextControlFlow("finally")
+                .emitStatement("objectContext.clear()")
+                .endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -295,7 +330,7 @@ private void emitInsertOrUpdateListToRealmMethod(JavaWriter writer) throws IOExc
 
         writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
         writer.emitStatement("RealmModel object = null");
-        writer.emitStatement("Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size())");
+        writer.emitStatement("Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())");
 
         writer.beginControlFlow("if (iterator.hasNext())")
                 .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
@@ -336,7 +371,7 @@ private void emitInsertListToRealmMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
         writer.emitStatement("RealmModel object = null");
-        writer.emitStatement("Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size())");
+        writer.emitStatement("Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())");
 
         writer.beginControlFlow("if (iterator.hasNext())")
                 .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 1412974f42..d67ccc944c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -1,17 +1,22 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -27,53 +32,67 @@
 public class AllTypesRealmProxy extends some.test.AllTypes
         implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
-    static final class AllTypesColumnInfo extends ColumnInfo {
+    static final class AllTypesColumnInfo extends ColumnInfo
+            implements Cloneable {
 
-        public final long columnStringIndex;
-        public final long columnLongIndex;
-        public final long columnFloatIndex;
-        public final long columnDoubleIndex;
-        public final long columnBooleanIndex;
-        public final long columnDateIndex;
-        public final long columnBinaryIndex;
-        public final long columnObjectIndex;
-        public final long columnRealmListIndex;
+        public long columnStringIndex;
+        public long columnLongIndex;
+        public long columnFloatIndex;
+        public long columnDoubleIndex;
+        public long columnBooleanIndex;
+        public long columnDateIndex;
+        public long columnBinaryIndex;
+        public long columnObjectIndex;
+        public long columnRealmListIndex;
 
         AllTypesColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(9);
             this.columnStringIndex = getValidColumnIndex(path, table, "AllTypes", "columnString");
             indicesMap.put("columnString", this.columnStringIndex);
-
             this.columnLongIndex = getValidColumnIndex(path, table, "AllTypes", "columnLong");
             indicesMap.put("columnLong", this.columnLongIndex);
-
             this.columnFloatIndex = getValidColumnIndex(path, table, "AllTypes", "columnFloat");
             indicesMap.put("columnFloat", this.columnFloatIndex);
-
             this.columnDoubleIndex = getValidColumnIndex(path, table, "AllTypes", "columnDouble");
             indicesMap.put("columnDouble", this.columnDoubleIndex);
-
             this.columnBooleanIndex = getValidColumnIndex(path, table, "AllTypes", "columnBoolean");
             indicesMap.put("columnBoolean", this.columnBooleanIndex);
-
             this.columnDateIndex = getValidColumnIndex(path, table, "AllTypes", "columnDate");
             indicesMap.put("columnDate", this.columnDateIndex);
-
             this.columnBinaryIndex = getValidColumnIndex(path, table, "AllTypes", "columnBinary");
             indicesMap.put("columnBinary", this.columnBinaryIndex);
-
             this.columnObjectIndex = getValidColumnIndex(path, table, "AllTypes", "columnObject");
             indicesMap.put("columnObject", this.columnObjectIndex);
-
             this.columnRealmListIndex = getValidColumnIndex(path, table, "AllTypes", "columnRealmList");
             indicesMap.put("columnRealmList", this.columnRealmListIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final AllTypesColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final AllTypesColumnInfo otherInfo = (AllTypesColumnInfo) other;
+            this.columnStringIndex = otherInfo.columnStringIndex;
+            this.columnLongIndex = otherInfo.columnLongIndex;
+            this.columnFloatIndex = otherInfo.columnFloatIndex;
+            this.columnDoubleIndex = otherInfo.columnDoubleIndex;
+            this.columnBooleanIndex = otherInfo.columnBooleanIndex;
+            this.columnDateIndex = otherInfo.columnDateIndex;
+            this.columnBinaryIndex = otherInfo.columnBinaryIndex;
+            this.columnObjectIndex = otherInfo.columnObjectIndex;
+            this.columnRealmListIndex = otherInfo.columnRealmListIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final AllTypesColumnInfo clone() {
+            return (AllTypesColumnInfo) super.clone();
+        }
+
+    }
+    private AllTypesColumnInfo columnInfo;
+    private ProxyState proxyState;
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
     private static final List<String> FIELD_NAMES;
     static {
@@ -90,77 +109,198 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    AllTypesRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (AllTypesColumnInfo) columnInfo;
+    AllTypesRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
         this.proxyState = new ProxyState(some.test.AllTypes.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public String realmGet$columnString() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
     }
 
     public void realmSet$columnString(String value) {
-        proxyState.getRealm$realm().checkIfValid();
-        if (value == null) {
-            proxyState.getRow$realm().setNull(columnInfo.columnStringIndex);
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            // default value of the primary key is always ignored.
             return;
         }
-        proxyState.getRow$realm().setString(columnInfo.columnStringIndex, value);
+
+        proxyState.getRealm$realm().checkIfValid();
+        throw new io.realm.exceptions.RealmException("Primary key field 'columnString' cannot be changed after object was created.");
     }
 
     @SuppressWarnings("cast")
     public long realmGet$columnLong() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
     }
 
     public void realmSet$columnLong(long value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setLong(columnInfo.columnLongIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
     }
 
     @SuppressWarnings("cast")
     public float realmGet$columnFloat() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
     }
 
     public void realmSet$columnFloat(float value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setFloat(columnInfo.columnFloatIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
     }
 
     @SuppressWarnings("cast")
     public double realmGet$columnDouble() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
     }
 
     public void realmSet$columnDouble(double value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setDouble(columnInfo.columnDoubleIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$columnBoolean() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
     }
 
     public void realmSet$columnBoolean(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.columnBooleanIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Date realmGet$columnDate() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
     }
 
     public void realmSet$columnDate(Date value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
+            }
+            row.getTable().setDate(columnInfo.columnDateIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
@@ -170,11 +310,33 @@
 
     @SuppressWarnings("cast")
     public byte[] realmGet$columnBinary() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
     }
 
     public void realmSet$columnBinary(byte[] value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
+            }
+            row.getTable().setBinaryByteArray(columnInfo.columnBinaryIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
@@ -183,20 +345,56 @@
     }
 
     public some.test.AllTypes realmGet$columnObject() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
             return null;
         }
-        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex));
+        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex), false, Collections.<String>emptyList());
     }
 
     public void realmSet$columnObject(some.test.AllTypes value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnObject")) {
+                return;
+            }
+            if (value != null && !RealmObject.isManaged(value)) {
+                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                // Table#nullifyLink() does not support default value. Just using Row.
+                row.nullifyLink(columnInfo.columnObjectIndex);
+                return;
+            }
+            if (!RealmObject.isValid(value)) {
+                throw new IllegalArgumentException("'value' is not a valid managed object.");
+            }
+            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
+                throw new IllegalArgumentException("'value' belongs to a different Realm.");
+            }
+            row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
             return;
         }
-        if (!RealmObject.isValid(value)) {
+        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
         if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -206,6 +404,11 @@
     }
 
     public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         // use the cached value if available
         if (columnRealmListRealmList != null) {
@@ -218,6 +421,32 @@
     }
 
     public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
+                return;
+            }
+            if (value != null && !value.isManaged()) {
+                final Realm realm = (Realm) proxyState.getRealm$realm();
+                final RealmList<some.test.AllTypes> original = value;
+                value = new RealmList<some.test.AllTypes>();
+                for (some.test.AllTypes item : original) {
+                    if (item == null || RealmObject.isManaged(item)) {
+                        value.add(item);
+                    } else {
+                        value.add(realm.copyToRealm(item));
+                    }
+                }
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
         links.clear();
@@ -225,7 +454,7 @@
             return;
         }
         for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
-            if (!RealmObject.isValid(linkedObject)) {
+            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
                 throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
             }
             if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -235,9 +464,32 @@
         }
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_AllTypes")) {
-            Table table = transaction.getTable("class_AllTypes");
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("AllTypes")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
+            realmObjectSchema.add(new Property("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            if (!realmSchema.contains("AllTypes")) {
+                AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
+            }
+            realmObjectSchema.add(new Property("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes")));
+            if (!realmSchema.contains("AllTypes")) {
+                AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
+            }
+            realmObjectSchema.add(new Property("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes")));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("AllTypes");
+    }
+
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_AllTypes")) {
+            Table table = sharedRealm.getTable("class_AllTypes");
             table.addColumn(RealmFieldType.STRING, "columnString", Table.NULLABLE);
             table.addColumn(RealmFieldType.INTEGER, "columnLong", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.FLOAT, "columnFloat", Table.NOT_NULLABLE);
@@ -245,132 +497,140 @@ public static Table initTable(ImplicitTransaction transaction) {
             table.addColumn(RealmFieldType.BOOLEAN, "columnBoolean", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.DATE, "columnDate", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.BINARY, "columnBinary", Table.NOT_NULLABLE);
-            if (!transaction.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(transaction);
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                AllTypesRealmProxy.initTable(sharedRealm);
             }
-            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", transaction.getTable("class_AllTypes"));
-            if (!transaction.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(transaction);
+            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", sharedRealm.getTable("class_AllTypes"));
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                AllTypesRealmProxy.initTable(sharedRealm);
             }
-            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", transaction.getTable("class_AllTypes"));
+            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", sharedRealm.getTable("class_AllTypes"));
             table.addSearchIndex(table.getColumnIndex("columnString"));
             table.setPrimaryKey("columnString");
             return table;
         }
-        return transaction.getTable("class_AllTypes");
+        return sharedRealm.getTable("class_AllTypes");
     }
 
-    public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_AllTypes")) {
-            Table table = transaction.getTable("class_AllTypes");
-            if (table.getColumnCount() != 9) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 9 but was " + table.getColumnCount());
+    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_AllTypes")) {
+            Table table = sharedRealm.getTable("class_AllTypes");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 9) {
+                if (columnCount < 9) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < 9; i++) {
+            for (long i = 0; i < columnCount; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(transaction.getPath(), table);
+            final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("columnString")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnString") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
             }
             if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
             }
             if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
             }
             if (!columnTypes.containsKey("columnLong")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnLongIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnFloat")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnDouble")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnBoolean")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnDate")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnDateIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnBinary")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnObject")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
             }
-            if (!transaction.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
             }
-            Table table_7 = transaction.getTable("class_AllTypes");
+            Table table_7 = sharedRealm.getTable("class_AllTypes");
             if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
             }
             if (!columnTypes.containsKey("columnRealmList")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnRealmList'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnRealmList'");
             }
             if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
             }
-            if (!transaction.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
             }
-            Table table_8 = transaction.getTable("class_AllTypes");
+            Table table_8 = sharedRealm.getTable("class_AllTypes");
             if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
         }
     }
 
@@ -385,6 +645,7 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
+        final List<String> excludeFields = new ArrayList<String>(2);
         some.test.AllTypes obj = null;
         if (update) {
             Table table = realm.getTable(some.test.AllTypes.class);
@@ -396,27 +657,30 @@ public static String getTableName() {
                 rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
             }
             if (rowIndex != TableOrView.NO_MATCH) {
-                obj = new io.realm.AllTypesRealmProxy(realm.schema.getColumnInfo(some.test.AllTypes.class));
-                ((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm);
-                ((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
+                final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+                try {
+                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                    obj = new io.realm.AllTypesRealmProxy();
+                } finally {
+                    objectContext.clear();
+                }
             }
         }
         if (obj == null) {
+            if (json.has("columnObject")) {
+                excludeFields.add("columnObject");
+            }
+            if (json.has("columnRealmList")) {
+                excludeFields.add("columnRealmList");
+            }
             if (json.has("columnString")) {
                 if (json.isNull("columnString")) {
-                    obj = (io.realm.AllTypesRealmProxy) realm.createObject(some.test.AllTypes.class, null);
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
                 } else {
-                    obj = (io.realm.AllTypesRealmProxy) realm.createObject(some.test.AllTypes.class, json.getString("columnString"));
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, json.getString("columnString"), true, excludeFields);
                 }
             } else {
-                obj = (io.realm.AllTypesRealmProxy) realm.createObject(some.test.AllTypes.class);
-            }
-        }
-        if (json.has("columnString")) {
-            if (json.isNull("columnString")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
-            } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) json.getString("columnString"));
+                throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
             }
         }
         if (json.has("columnLong")) {
@@ -490,9 +754,11 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.AllTypes obj = realm.createObject(some.test.AllTypes.class);
+        boolean jsonHasPrimaryKey = false;
+        some.test.AllTypes obj = new some.test.AllTypes();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -503,6 +769,7 @@ public static String getTableName() {
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) reader.nextString());
                 }
+                jsonHasPrimaryKey = true;
             } else if (name.equals("columnLong")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
@@ -563,6 +830,7 @@ public static String getTableName() {
                     reader.skipValue();
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
                 } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                     reader.beginArray();
                     while (reader.hasNext()) {
                         some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
@@ -575,6 +843,10 @@ public static String getTableName() {
             }
         }
         reader.endObject();
+        if (!jsonHasPrimaryKey) {
+            throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
+        }
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
@@ -585,6 +857,7 @@ public static String getTableName() {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.AllTypes) cachedRealmObject;
@@ -602,10 +875,13 @@ public static String getTableName() {
                     rowIndex = table.findFirstString(pkColumnIndex, value);
                 }
                 if (rowIndex != TableOrView.NO_MATCH) {
-                    realmObject = new io.realm.AllTypesRealmProxy(realm.schema.getColumnInfo(some.test.AllTypes.class));
-                    ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
-                    ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
-                    cache.put(object, (RealmObjectProxy) realmObject);
+                    try {
+                        objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                        realmObject = new io.realm.AllTypesRealmProxy();
+                        cache.put(object, (RealmObjectProxy) realmObject);
+                    } finally {
+                        objectContext.clear();
+                    }
                 } else {
                     canUpdate = false;
                 }
@@ -624,9 +900,9 @@ public static String getTableName() {
         if (cachedRealmObject != null) {
             return (some.test.AllTypes) cachedRealmObject;
         } else {
-            some.test.AllTypes realmObject = realm.createObject(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
             cache.put(newObject, (RealmObjectProxy) realmObject);
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
             ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
             ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
             ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
@@ -680,25 +956,22 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
         if (rowIndex == TableOrView.NO_MATCH) {
-            rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-            if (primaryKeyValue != null) {
-                Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
-            }
+            rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
         } else {
             Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
         }
         cache.put(object, rowIndex);
-        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
         java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
         if (realmGet$columnDate != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
         }
         byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
         if (realmGet$columnBinary != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -707,7 +980,7 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             if (cachecolumnObject == null) {
                 cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
         }
 
         RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
@@ -720,7 +993,6 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
                 }
                 LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
             }
-            LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
         }
 
         return rowIndex;
@@ -747,25 +1019,22 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
                 }
                 if (rowIndex == TableOrView.NO_MATCH) {
-                    rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                    if (primaryKeyValue != null) {
-                        Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
-                    }
+                    rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
                 } else {
                     Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
                 }
                 cache.put(object, rowIndex);
-                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
                 java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
                 if (realmGet$columnDate != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
                 }
                 byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
                 if (realmGet$columnBinary != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
                 }
 
                 some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -774,7 +1043,7 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     if (cachecolumnObject == null) {
                         cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
                     }
-                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
                 }
 
                 RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
@@ -787,7 +1056,6 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                         }
                         LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                     }
-                    LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
                 }
 
             }
@@ -810,27 +1078,24 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
         if (rowIndex == TableOrView.NO_MATCH) {
-            rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-            if (primaryKeyValue != null) {
-                Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
-            }
+            rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
         }
         cache.put(object, rowIndex);
-        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
         java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
         if (realmGet$columnDate != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
         }
         byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
         if (realmGet$columnBinary != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
         }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -839,7 +1104,7 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             if (cachecolumnObject == null) {
                 cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
         } else {
             Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
         }
@@ -856,7 +1121,6 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
                 LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
             }
         }
-        LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
 
         return rowIndex;
     }
@@ -882,27 +1146,24 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
                 }
                 if (rowIndex == TableOrView.NO_MATCH) {
-                    rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                    if (primaryKeyValue != null) {
-                        Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
-                    }
+                    rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
                 }
                 cache.put(object, rowIndex);
-                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
-                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
-                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
                 java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
                 if (realmGet$columnDate != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
                 }
                 byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
                 if (realmGet$columnBinary != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
                 }
 
                 some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
@@ -911,7 +1172,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     if (cachecolumnObject == null) {
                         cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
                     }
-                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
                 } else {
                     Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
                 }
@@ -928,7 +1189,6 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                         LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                     }
                 }
-                LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
 
             }
         }
@@ -1086,7 +1346,7 @@ public boolean equals(Object o) {
 
         String path = proxyState.getRealm$realm().getPath();
         String otherPath = aAllTypes.proxyState.getRealm$realm().getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
 
         String tableName = proxyState.getRow$realm().getTable().getName();
         String otherTableName = aAllTypes.proxyState.getRow$realm().getTable().getName();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index de1dc8239f..7200c4e70e 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -1,17 +1,22 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -27,33 +32,47 @@
 public class BooleansRealmProxy extends some.test.Booleans
         implements RealmObjectProxy, BooleansRealmProxyInterface {
 
-    static final class BooleansColumnInfo extends ColumnInfo {
+    static final class BooleansColumnInfo extends ColumnInfo
+            implements Cloneable {
 
-        public final long doneIndex;
-        public final long isReadyIndex;
-        public final long mCompletedIndex;
-        public final long anotherBooleanIndex;
+        public long doneIndex;
+        public long isReadyIndex;
+        public long mCompletedIndex;
+        public long anotherBooleanIndex;
 
         BooleansColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(4);
             this.doneIndex = getValidColumnIndex(path, table, "Booleans", "done");
             indicesMap.put("done", this.doneIndex);
-
             this.isReadyIndex = getValidColumnIndex(path, table, "Booleans", "isReady");
             indicesMap.put("isReady", this.isReadyIndex);
-
             this.mCompletedIndex = getValidColumnIndex(path, table, "Booleans", "mCompleted");
             indicesMap.put("mCompleted", this.mCompletedIndex);
-
             this.anotherBooleanIndex = getValidColumnIndex(path, table, "Booleans", "anotherBoolean");
             indicesMap.put("anotherBoolean", this.anotherBooleanIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final BooleansColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final BooleansColumnInfo otherInfo = (BooleansColumnInfo) other;
+            this.doneIndex = otherInfo.doneIndex;
+            this.isReadyIndex = otherInfo.isReadyIndex;
+            this.mCompletedIndex = otherInfo.mCompletedIndex;
+            this.anotherBooleanIndex = otherInfo.anotherBooleanIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final BooleansColumnInfo clone() {
+            return (BooleansColumnInfo) super.clone();
+        }
+
+    }
+    private BooleansColumnInfo columnInfo;
+    private ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -64,58 +83,158 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    BooleansRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (BooleansColumnInfo) columnInfo;
+    BooleansRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (BooleansColumnInfo) context.getColumnInfo();
         this.proxyState = new ProxyState(some.test.Booleans.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$done() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.doneIndex);
     }
 
     public void realmSet$done(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.doneIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.doneIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$isReady() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.isReadyIndex);
     }
 
     public void realmSet$isReady(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.isReadyIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.isReadyIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$mCompleted() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.mCompletedIndex);
     }
 
     public void realmSet$mCompleted(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.mCompletedIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.mCompletedIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$anotherBoolean() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.anotherBooleanIndex);
     }
 
     public void realmSet$anotherBoolean(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setBoolean(columnInfo.anotherBooleanIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.anotherBooleanIndex, value);
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_Booleans")) {
-            Table table = transaction.getTable("class_Booleans");
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("Booleans")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("Booleans");
+            realmObjectSchema.add(new Property("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("Booleans");
+    }
+
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_Booleans")) {
+            Table table = sharedRealm.getTable("class_Booleans");
             table.addColumn(RealmFieldType.BOOLEAN, "done", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.BOOLEAN, "isReady", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.BOOLEAN, "mCompleted", Table.NOT_NULLABLE);
@@ -123,61 +242,69 @@ public static Table initTable(ImplicitTransaction transaction) {
             table.setPrimaryKey("");
             return table;
         }
-        return transaction.getTable("class_Booleans");
+        return sharedRealm.getTable("class_Booleans");
     }
 
-    public static BooleansColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_Booleans")) {
-            Table table = transaction.getTable("class_Booleans");
-            if (table.getColumnCount() != 4) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 4 but was " + table.getColumnCount());
+    public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_Booleans")) {
+            Table table = sharedRealm.getTable("class_Booleans");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 4) {
+                if (columnCount < 4) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 4 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 4 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 4 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < 4; i++) {
+            for (long i = 0; i < columnCount; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final BooleansColumnInfo columnInfo = new BooleansColumnInfo(transaction.getPath(), table);
+            final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("done")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.doneIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("isReady")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.isReadyIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("mCompleted")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("anotherBoolean")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
         }
     }
 
@@ -192,7 +319,8 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        some.test.Booleans obj = realm.createObject(some.test.Booleans.class);
+        final List<String> excludeFields = Collections.<String> emptyList();
+        some.test.Booleans obj = realm.createObjectInternal(some.test.Booleans.class, true, excludeFields);
         if (json.has("done")) {
             if (json.isNull("done")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
@@ -225,9 +353,10 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.Booleans obj = realm.createObject(some.test.Booleans.class);
+        some.test.Booleans obj = new some.test.Booleans();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -264,6 +393,7 @@ public static String getTableName() {
             }
         }
         reader.endObject();
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
@@ -274,6 +404,7 @@ public static String getTableName() {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.Booleans) cachedRealmObject;
@@ -287,7 +418,8 @@ public static String getTableName() {
         if (cachedRealmObject != null) {
             return (some.test.Booleans) cachedRealmObject;
         } else {
-            some.test.Booleans realmObject = realm.createObject(some.test.Booleans.class);
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.Booleans realmObject = realm.createObjectInternal(some.test.Booleans.class, false, Collections.<String>emptyList());
             cache.put(newObject, (RealmObjectProxy) realmObject);
             ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
             ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
@@ -306,10 +438,10 @@ public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
         return rowIndex;
     }
 
@@ -327,10 +459,10 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 }
                 long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                 cache.put(object, rowIndex);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
             }
         }
     }
@@ -344,10 +476,10 @@ public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<Re
         BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
         long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
         cache.put(object, rowIndex);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
         return rowIndex;
     }
 
@@ -365,10 +497,10 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 }
                 long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                 cache.put(object, rowIndex);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
             }
         }
     }
@@ -449,7 +581,7 @@ public boolean equals(Object o) {
 
         String path = proxyState.getRealm$realm().getPath();
         String otherPath = aBooleans.proxyState.getRealm$realm().getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
 
         String tableName = proxyState.getRow$realm().getTable().getName();
         String otherTableName = aBooleans.proxyState.getRow$realm().getTable().getName();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 4d62f6ef04..608868bb72 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -1,17 +1,22 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -27,101 +32,115 @@
 public class NullTypesRealmProxy extends some.test.NullTypes
         implements RealmObjectProxy, NullTypesRealmProxyInterface {
 
-    static final class NullTypesColumnInfo extends ColumnInfo {
-
-        public final long fieldStringNotNullIndex;
-        public final long fieldStringNullIndex;
-        public final long fieldBooleanNotNullIndex;
-        public final long fieldBooleanNullIndex;
-        public final long fieldBytesNotNullIndex;
-        public final long fieldBytesNullIndex;
-        public final long fieldByteNotNullIndex;
-        public final long fieldByteNullIndex;
-        public final long fieldShortNotNullIndex;
-        public final long fieldShortNullIndex;
-        public final long fieldIntegerNotNullIndex;
-        public final long fieldIntegerNullIndex;
-        public final long fieldLongNotNullIndex;
-        public final long fieldLongNullIndex;
-        public final long fieldFloatNotNullIndex;
-        public final long fieldFloatNullIndex;
-        public final long fieldDoubleNotNullIndex;
-        public final long fieldDoubleNullIndex;
-        public final long fieldDateNotNullIndex;
-        public final long fieldDateNullIndex;
-        public final long fieldObjectNullIndex;
+    static final class NullTypesColumnInfo extends ColumnInfo
+            implements Cloneable {
+
+        public long fieldStringNotNullIndex;
+        public long fieldStringNullIndex;
+        public long fieldBooleanNotNullIndex;
+        public long fieldBooleanNullIndex;
+        public long fieldBytesNotNullIndex;
+        public long fieldBytesNullIndex;
+        public long fieldByteNotNullIndex;
+        public long fieldByteNullIndex;
+        public long fieldShortNotNullIndex;
+        public long fieldShortNullIndex;
+        public long fieldIntegerNotNullIndex;
+        public long fieldIntegerNullIndex;
+        public long fieldLongNotNullIndex;
+        public long fieldLongNullIndex;
+        public long fieldFloatNotNullIndex;
+        public long fieldFloatNullIndex;
+        public long fieldDoubleNotNullIndex;
+        public long fieldDoubleNullIndex;
+        public long fieldDateNotNullIndex;
+        public long fieldDateNullIndex;
+        public long fieldObjectNullIndex;
 
         NullTypesColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(21);
             this.fieldStringNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNotNull");
             indicesMap.put("fieldStringNotNull", this.fieldStringNotNullIndex);
-
             this.fieldStringNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNull");
             indicesMap.put("fieldStringNull", this.fieldStringNullIndex);
-
             this.fieldBooleanNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNotNull");
             indicesMap.put("fieldBooleanNotNull", this.fieldBooleanNotNullIndex);
-
             this.fieldBooleanNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNull");
             indicesMap.put("fieldBooleanNull", this.fieldBooleanNullIndex);
-
             this.fieldBytesNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNotNull");
             indicesMap.put("fieldBytesNotNull", this.fieldBytesNotNullIndex);
-
             this.fieldBytesNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNull");
             indicesMap.put("fieldBytesNull", this.fieldBytesNullIndex);
-
             this.fieldByteNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNotNull");
             indicesMap.put("fieldByteNotNull", this.fieldByteNotNullIndex);
-
             this.fieldByteNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNull");
             indicesMap.put("fieldByteNull", this.fieldByteNullIndex);
-
             this.fieldShortNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNotNull");
             indicesMap.put("fieldShortNotNull", this.fieldShortNotNullIndex);
-
             this.fieldShortNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNull");
             indicesMap.put("fieldShortNull", this.fieldShortNullIndex);
-
             this.fieldIntegerNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNotNull");
             indicesMap.put("fieldIntegerNotNull", this.fieldIntegerNotNullIndex);
-
             this.fieldIntegerNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNull");
             indicesMap.put("fieldIntegerNull", this.fieldIntegerNullIndex);
-
             this.fieldLongNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNotNull");
             indicesMap.put("fieldLongNotNull", this.fieldLongNotNullIndex);
-
             this.fieldLongNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNull");
             indicesMap.put("fieldLongNull", this.fieldLongNullIndex);
-
             this.fieldFloatNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNotNull");
             indicesMap.put("fieldFloatNotNull", this.fieldFloatNotNullIndex);
-
             this.fieldFloatNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNull");
             indicesMap.put("fieldFloatNull", this.fieldFloatNullIndex);
-
             this.fieldDoubleNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNotNull");
             indicesMap.put("fieldDoubleNotNull", this.fieldDoubleNotNullIndex);
-
             this.fieldDoubleNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNull");
             indicesMap.put("fieldDoubleNull", this.fieldDoubleNullIndex);
-
             this.fieldDateNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNotNull");
             indicesMap.put("fieldDateNotNull", this.fieldDateNotNullIndex);
-
             this.fieldDateNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNull");
             indicesMap.put("fieldDateNull", this.fieldDateNullIndex);
-
             this.fieldObjectNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldObjectNull");
             indicesMap.put("fieldObjectNull", this.fieldObjectNullIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final NullTypesColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final NullTypesColumnInfo otherInfo = (NullTypesColumnInfo) other;
+            this.fieldStringNotNullIndex = otherInfo.fieldStringNotNullIndex;
+            this.fieldStringNullIndex = otherInfo.fieldStringNullIndex;
+            this.fieldBooleanNotNullIndex = otherInfo.fieldBooleanNotNullIndex;
+            this.fieldBooleanNullIndex = otherInfo.fieldBooleanNullIndex;
+            this.fieldBytesNotNullIndex = otherInfo.fieldBytesNotNullIndex;
+            this.fieldBytesNullIndex = otherInfo.fieldBytesNullIndex;
+            this.fieldByteNotNullIndex = otherInfo.fieldByteNotNullIndex;
+            this.fieldByteNullIndex = otherInfo.fieldByteNullIndex;
+            this.fieldShortNotNullIndex = otherInfo.fieldShortNotNullIndex;
+            this.fieldShortNullIndex = otherInfo.fieldShortNullIndex;
+            this.fieldIntegerNotNullIndex = otherInfo.fieldIntegerNotNullIndex;
+            this.fieldIntegerNullIndex = otherInfo.fieldIntegerNullIndex;
+            this.fieldLongNotNullIndex = otherInfo.fieldLongNotNullIndex;
+            this.fieldLongNullIndex = otherInfo.fieldLongNullIndex;
+            this.fieldFloatNotNullIndex = otherInfo.fieldFloatNotNullIndex;
+            this.fieldFloatNullIndex = otherInfo.fieldFloatNullIndex;
+            this.fieldDoubleNotNullIndex = otherInfo.fieldDoubleNotNullIndex;
+            this.fieldDoubleNullIndex = otherInfo.fieldDoubleNullIndex;
+            this.fieldDateNotNullIndex = otherInfo.fieldDateNotNullIndex;
+            this.fieldDateNullIndex = otherInfo.fieldDateNullIndex;
+            this.fieldObjectNullIndex = otherInfo.fieldObjectNullIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final NullTypesColumnInfo clone() {
+            return (NullTypesColumnInfo) super.clone();
+        }
+
+    }
+    private NullTypesColumnInfo columnInfo;
+    private ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -149,18 +168,52 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    NullTypesRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (NullTypesColumnInfo) columnInfo;
+    NullTypesRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (NullTypesColumnInfo) context.getColumnInfo();
         this.proxyState = new ProxyState(some.test.NullTypes.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNotNullIndex);
     }
 
     public void realmSet$fieldStringNotNull(String value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldStringNotNull' to null.");
+            }
+            row.getTable().setString(columnInfo.fieldStringNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldStringNotNull' to null.");
@@ -170,11 +223,34 @@
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNullIndex);
     }
 
     public void realmSet$fieldStringNull(String value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldStringNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.fieldStringNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldStringNullIndex);
@@ -185,11 +261,33 @@
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNotNullIndex);
     }
 
     public void realmSet$fieldBooleanNotNull(Boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBooleanNotNull' to null.");
+            }
+            row.getTable().setBoolean(columnInfo.fieldBooleanNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBooleanNotNull' to null.");
@@ -199,6 +297,11 @@
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldBooleanNullIndex)) {
             return null;
@@ -207,6 +310,24 @@
     }
 
     public void realmSet$fieldBooleanNull(Boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldBooleanNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setBoolean(columnInfo.fieldBooleanNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldBooleanNullIndex);
@@ -217,11 +338,33 @@
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
     }
 
     public void realmSet$fieldBytesNotNull(byte[] value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBytesNotNull' to null.");
+            }
+            row.getTable().setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBytesNotNull' to null.");
@@ -231,11 +374,34 @@
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNullIndex);
     }
 
     public void realmSet$fieldBytesNull(byte[] value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldBytesNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setBinaryByteArray(columnInfo.fieldBytesNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldBytesNullIndex);
@@ -246,11 +412,33 @@
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNotNullIndex);
     }
 
     public void realmSet$fieldByteNotNull(Byte value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldByteNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldByteNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldByteNotNull' to null.");
@@ -260,6 +448,11 @@
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldByteNullIndex)) {
             return null;
@@ -268,6 +461,24 @@
     }
 
     public void realmSet$fieldByteNull(Byte value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldByteNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldByteNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldByteNullIndex);
@@ -278,11 +489,33 @@
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNotNullIndex);
     }
 
     public void realmSet$fieldShortNotNull(Short value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldShortNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldShortNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldShortNotNull' to null.");
@@ -292,6 +525,11 @@
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldShortNullIndex)) {
             return null;
@@ -300,6 +538,24 @@
     }
 
     public void realmSet$fieldShortNull(Short value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldShortNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldShortNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldShortNullIndex);
@@ -310,11 +566,33 @@
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNotNullIndex);
     }
 
     public void realmSet$fieldIntegerNotNull(Integer value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldIntegerNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldIntegerNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldIntegerNotNull' to null.");
@@ -324,6 +602,11 @@
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldIntegerNullIndex)) {
             return null;
@@ -332,6 +615,24 @@
     }
 
     public void realmSet$fieldIntegerNull(Integer value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldIntegerNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldIntegerNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldIntegerNullIndex);
@@ -342,11 +643,33 @@
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNotNullIndex);
     }
 
     public void realmSet$fieldLongNotNull(Long value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldLongNotNull' to null.");
+            }
+            row.getTable().setLong(columnInfo.fieldLongNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldLongNotNull' to null.");
@@ -356,6 +679,11 @@
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldLongNullIndex)) {
             return null;
@@ -364,6 +692,24 @@
     }
 
     public void realmSet$fieldLongNull(Long value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldLongNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setLong(columnInfo.fieldLongNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldLongNullIndex);
@@ -374,11 +720,33 @@
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNotNullIndex);
     }
 
     public void realmSet$fieldFloatNotNull(Float value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldFloatNotNull' to null.");
+            }
+            row.getTable().setFloat(columnInfo.fieldFloatNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldFloatNotNull' to null.");
@@ -388,6 +756,11 @@
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldFloatNullIndex)) {
             return null;
@@ -396,6 +769,24 @@
     }
 
     public void realmSet$fieldFloatNull(Float value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldFloatNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setFloat(columnInfo.fieldFloatNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldFloatNullIndex);
@@ -406,11 +797,33 @@
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNotNullIndex);
     }
 
     public void realmSet$fieldDoubleNotNull(Double value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDoubleNotNull' to null.");
+            }
+            row.getTable().setDouble(columnInfo.fieldDoubleNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDoubleNotNull' to null.");
@@ -420,6 +833,11 @@
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldDoubleNullIndex)) {
             return null;
@@ -428,6 +846,24 @@
     }
 
     public void realmSet$fieldDoubleNull(Double value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldDoubleNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setDouble(columnInfo.fieldDoubleNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldDoubleNullIndex);
@@ -438,11 +874,33 @@
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNotNullIndex);
     }
 
     public void realmSet$fieldDateNotNull(Date value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDateNotNull' to null.");
+            }
+            row.getTable().setDate(columnInfo.fieldDateNotNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDateNotNull' to null.");
@@ -452,6 +910,11 @@
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldDateNullIndex)) {
             return null;
@@ -460,6 +923,24 @@
     }
 
     public void realmSet$fieldDateNull(Date value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.fieldDateNullIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setDate(columnInfo.fieldDateNullIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldDateNullIndex);
@@ -469,20 +950,56 @@
     }
 
     public some.test.NullTypes realmGet$fieldObjectNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.fieldObjectNullIndex)) {
             return null;
         }
-        return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex));
+        return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex), false, Collections.<String>emptyList());
     }
 
     public void realmSet$fieldObjectNull(some.test.NullTypes value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldObjectNull")) {
+                return;
+            }
+            if (value != null && !RealmObject.isManaged(value)) {
+                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                // Table#nullifyLink() does not support default value. Just using Row.
+                row.nullifyLink(columnInfo.fieldObjectNullIndex);
+                return;
+            }
+            if (!RealmObject.isValid(value)) {
+                throw new IllegalArgumentException("'value' is not a valid managed object.");
+            }
+            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
+                throw new IllegalArgumentException("'value' belongs to a different Realm.");
+            }
+            row.getTable().setLink(columnInfo.fieldObjectNullIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
             return;
         }
-        if (!RealmObject.isValid(value)) {
+        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
         if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -491,9 +1008,41 @@
         proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_NullTypes")) {
-            Table table = transaction.getTable("class_NullTypes");
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("NullTypes")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("NullTypes");
+            realmObjectSchema.add(new Property("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add(new Property("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            if (!realmSchema.contains("NullTypes")) {
+                NullTypesRealmProxy.createRealmObjectSchema(realmSchema);
+            }
+            realmObjectSchema.add(new Property("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes")));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("NullTypes");
+    }
+
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_NullTypes")) {
+            Table table = sharedRealm.getTable("class_NullTypes");
             table.addColumn(RealmFieldType.STRING, "fieldStringNotNull", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.STRING, "fieldStringNull", Table.NULLABLE);
             table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNotNull", Table.NOT_NULLABLE);
@@ -514,225 +1063,233 @@ public static Table initTable(ImplicitTransaction transaction) {
             table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNull", Table.NULLABLE);
             table.addColumn(RealmFieldType.DATE, "fieldDateNotNull", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.DATE, "fieldDateNull", Table.NULLABLE);
-            if (!transaction.hasTable("class_NullTypes")) {
-                NullTypesRealmProxy.initTable(transaction);
+            if (!sharedRealm.hasTable("class_NullTypes")) {
+                NullTypesRealmProxy.initTable(sharedRealm);
             }
-            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", transaction.getTable("class_NullTypes"));
+            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", sharedRealm.getTable("class_NullTypes"));
             table.setPrimaryKey("");
             return table;
         }
-        return transaction.getTable("class_NullTypes");
+        return sharedRealm.getTable("class_NullTypes");
     }
 
-    public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_NullTypes")) {
-            Table table = transaction.getTable("class_NullTypes");
-            if (table.getColumnCount() != 21) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 21 but was " + table.getColumnCount());
+    public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_NullTypes")) {
+            Table table = sharedRealm.getTable("class_NullTypes");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 21) {
+                if (columnCount < 21) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 21 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 21 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 21 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < 21; i++) {
+            for (long i = 0; i < columnCount; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(transaction.getPath(), table);
+            final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("fieldStringNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldStringNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBooleanNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBooleanNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBytesNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBytesNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldByteNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldByteNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldShortNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldShortNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldIntegerNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldIntegerNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldLongNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldLongNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldFloatNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldFloatNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDoubleNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDoubleNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDateNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDateNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldObjectNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
             }
-            if (!transaction.hasTable("class_NullTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
+            if (!sharedRealm.hasTable("class_NullTypes")) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
             }
-            Table table_20 = transaction.getTable("class_NullTypes");
+            Table table_20 = sharedRealm.getTable("class_NullTypes");
             if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
         }
     }
 
@@ -747,7 +1304,11 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        some.test.NullTypes obj = realm.createObject(some.test.NullTypes.class);
+        final List<String> excludeFields = new ArrayList<String>(1);
+        if (json.has("fieldObjectNull")) {
+            excludeFields.add("fieldObjectNull");
+        }
+        some.test.NullTypes obj = realm.createObjectInternal(some.test.NullTypes.class, true, excludeFields);
         if (json.has("fieldStringNotNull")) {
             if (json.isNull("fieldStringNotNull")) {
                 ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
@@ -910,9 +1471,10 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.NullTypes obj = realm.createObject(some.test.NullTypes.class);
+        some.test.NullTypes obj = new some.test.NullTypes();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -1079,6 +1641,7 @@ public static String getTableName() {
             }
         }
         reader.endObject();
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
@@ -1089,6 +1652,7 @@ public static String getTableName() {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.NullTypes) cachedRealmObject;
@@ -1102,7 +1666,8 @@ public static String getTableName() {
         if (cachedRealmObject != null) {
             return (some.test.NullTypes) cachedRealmObject;
         } else {
-            some.test.NullTypes realmObject = realm.createObject(some.test.NullTypes.class);
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.NullTypes realmObject = realm.createObjectInternal(some.test.NullTypes.class, false, Collections.<String>emptyList());
             cache.put(newObject, (RealmObjectProxy) realmObject);
             ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
             ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
@@ -1151,83 +1716,83 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
         cache.put(object, rowIndex);
         String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
         if (realmGet$fieldStringNotNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
         }
         String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
         if (realmGet$fieldStringNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
         }
         Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
         if (realmGet$fieldBooleanNotNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
         }
         Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
         if (realmGet$fieldBooleanNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
         }
         byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
         if (realmGet$fieldBytesNotNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
         }
         byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
         if (realmGet$fieldBytesNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
         }
         Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
         if (realmGet$fieldByteNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
         }
         Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
         if (realmGet$fieldByteNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
         }
         Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
         if (realmGet$fieldShortNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
         }
         Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
         if (realmGet$fieldShortNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
         }
         Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
         if (realmGet$fieldIntegerNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
         }
         Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
         if (realmGet$fieldIntegerNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
         }
         Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
         if (realmGet$fieldLongNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
         }
         Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
         if (realmGet$fieldLongNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         }
         Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
         if (realmGet$fieldFloatNotNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
         }
         Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
         if (realmGet$fieldFloatNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
         }
         Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
         if (realmGet$fieldDoubleNotNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
         }
         Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
         if (realmGet$fieldDoubleNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
         }
         java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
         if (realmGet$fieldDateNotNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
         }
         java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
         if (realmGet$fieldDateNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
         }
 
         some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1236,7 +1801,7 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
             if (cachefieldObjectNull == null) {
                 cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
         }
         return rowIndex;
     }
@@ -1257,83 +1822,83 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 cache.put(object, rowIndex);
                 String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
                 if (realmGet$fieldStringNotNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
                 }
                 String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
                 if (realmGet$fieldStringNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
                 }
                 Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
                 if (realmGet$fieldBooleanNotNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
                 }
                 Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
                 if (realmGet$fieldBooleanNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
                 }
                 byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
                 if (realmGet$fieldBytesNotNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
                 }
                 byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
                 if (realmGet$fieldBytesNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
                 }
                 Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
                 if (realmGet$fieldByteNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
                 }
                 Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
                 if (realmGet$fieldByteNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
                 }
                 Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
                 if (realmGet$fieldShortNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
                 }
                 Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
                 if (realmGet$fieldShortNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
                 }
                 Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
                 if (realmGet$fieldIntegerNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
                 }
                 Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
                 if (realmGet$fieldIntegerNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
                 }
                 Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
                 if (realmGet$fieldLongNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
                 }
                 Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
                 if (realmGet$fieldLongNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
                 }
                 Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
                 if (realmGet$fieldFloatNotNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
                 }
                 Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
                 if (realmGet$fieldFloatNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
                 }
                 Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
                 if (realmGet$fieldDoubleNotNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
                 }
                 Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
                 if (realmGet$fieldDoubleNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
                 }
                 java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
                 if (realmGet$fieldDateNotNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
                 }
                 java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
                 if (realmGet$fieldDateNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
                 }
 
                 some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1342,7 +1907,7 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     if (cachefieldObjectNull == null) {
                         cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
                     }
-                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
                 }
             }
         }
@@ -1359,123 +1924,123 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
         cache.put(object, rowIndex);
         String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
         if (realmGet$fieldStringNotNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
         }
         String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
         if (realmGet$fieldStringNull != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
         }
         Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
         if (realmGet$fieldBooleanNotNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
         }
         Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
         if (realmGet$fieldBooleanNull != null) {
-            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
         }
         byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
         if (realmGet$fieldBytesNotNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
         }
         byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
         if (realmGet$fieldBytesNull != null) {
-            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
         }
         Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
         if (realmGet$fieldByteNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
         if (realmGet$fieldByteNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
         }
         Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
         if (realmGet$fieldShortNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
         if (realmGet$fieldShortNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
         }
         Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
         if (realmGet$fieldIntegerNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
         if (realmGet$fieldIntegerNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
         }
         Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
         if (realmGet$fieldLongNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
         }
         Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
         if (realmGet$fieldLongNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
         }
         Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
         if (realmGet$fieldFloatNotNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
         }
         Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
         if (realmGet$fieldFloatNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
         }
         Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
         if (realmGet$fieldDoubleNotNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
         }
         Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
         if (realmGet$fieldDoubleNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
         }
         java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
         if (realmGet$fieldDateNotNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
         }
         java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
         if (realmGet$fieldDateNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
         }
 
         some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1484,7 +2049,7 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
             if (cachefieldObjectNull == null) {
                 cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
         } else {
             Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
         }
@@ -1507,123 +2072,123 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 cache.put(object, rowIndex);
                 String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
                 if (realmGet$fieldStringNotNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
                 }
                 String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
                 if (realmGet$fieldStringNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
                 }
                 Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
                 if (realmGet$fieldBooleanNotNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
                 }
                 Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
                 if (realmGet$fieldBooleanNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
                 }
                 byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
                 if (realmGet$fieldBytesNotNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
                 }
                 byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
                 if (realmGet$fieldBytesNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
                 if (realmGet$fieldByteNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
                 if (realmGet$fieldByteNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
                 if (realmGet$fieldShortNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
                 if (realmGet$fieldShortNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
                 if (realmGet$fieldIntegerNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
                 if (realmGet$fieldIntegerNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
                 if (realmGet$fieldLongNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
                 }
                 Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
                 if (realmGet$fieldLongNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
                 }
                 Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
                 if (realmGet$fieldFloatNotNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
                 }
                 Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
                 if (realmGet$fieldFloatNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
                 }
                 Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
                 if (realmGet$fieldDoubleNotNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
                 }
                 Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
                 if (realmGet$fieldDoubleNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
                 }
                 java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
                 if (realmGet$fieldDateNotNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
                 }
                 java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
                 if (realmGet$fieldDateNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
                 }
 
                 some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
@@ -1632,7 +2197,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     if (cachefieldObjectNull == null) {
                         cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
                     }
-                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
                 } else {
                     Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
                 }
@@ -1803,7 +2368,7 @@ public boolean equals(Object o) {
 
         String path = proxyState.getRealm$realm().getPath();
         String otherPath = aNullTypes.proxyState.getRealm$realm().getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
 
         String tableName = proxyState.getRow$realm().getTable().getName();
         String otherTableName = aNullTypes.proxyState.getRow$realm().getTable().getName();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index dacfbdf3f1..e72e461844 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -2,16 +2,18 @@
 
 
 import android.util.JsonReader;
+import io.realm.RealmObjectSchema;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
-import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -30,60 +32,77 @@
     }
 
     @Override
-    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.initTable(transaction);
+            return io.realm.AllTypesRealmProxy.initTable(sharedRealm);
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.validateTable(transaction);
+            return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm, boolean allowExtraColumns) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.getFieldNames();
+            return io.realm.AllTypesRealmProxy.validateTable(sharedRealm, allowExtraColumns);
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public String getTableName(Class<? extends RealmModel> clazz) {
+    public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.getTableName();
+            return io.realm.AllTypesRealmProxy.getFieldNames();
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public String getTableName(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return clazz.cast(new io.realm.AllTypesRealmProxy(columnInfo));
+            return io.realm.AllTypesRealmProxy.getTableName();
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
+    @Override
+    public <E extends RealmModel> E newInstance(Class<E> clazz, Object baseRealm, Row row, ColumnInfo columnInfo, boolean acceptDefaultValue, List<String> excludeFields) {
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        try {
+            objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields);
+            checkClass(clazz);
+
+            if (clazz.equals(some.test.AllTypes.class)) {
+                return clazz.cast(new io.realm.AllTypesRealmProxy());
+            } else {
+                throw getMissingProxyClassException(clazz);
+            }
+        } finally {
+            objectContext.clear();
+        }
+    }
+
     @Override
     public Set<Class<? extends RealmModel>> getModelClasses() {
         return MODEL_CLASSES;
@@ -119,7 +138,7 @@ public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache)
     public void insert(Realm realm, Collection<? extends RealmModel> objects) {
         Iterator<? extends RealmModel> iterator = objects.iterator();
         RealmModel object = null;
-        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size());
+        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size());
         if (iterator.hasNext()) {
             //  access the first element to figure out the clazz for the routing below
             object = iterator.next();
@@ -159,7 +178,7 @@ public void insertOrUpdate(Realm realm, RealmModel obj, Map<RealmModel, Long> ca
     public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
         Iterator<? extends RealmModel> iterator = objects.iterator();
         RealmModel object = null;
-        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size());
+        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size());
         if (iterator.hasNext()) {
             //  access the first element to figure out the clazz for the routing below
             object = iterator.next();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 942bbc2d2d..3dc59b6feb 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -1,17 +1,22 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -27,25 +32,39 @@
 public class SimpleRealmProxy extends some.test.Simple
         implements RealmObjectProxy, SimpleRealmProxyInterface {
 
-    static final class SimpleColumnInfo extends ColumnInfo {
+    static final class SimpleColumnInfo extends ColumnInfo
+            implements Cloneable {
 
-        public final long nameIndex;
-        public final long ageIndex;
+        public long nameIndex;
+        public long ageIndex;
 
         SimpleColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(2);
             this.nameIndex = getValidColumnIndex(path, table, "Simple", "name");
             indicesMap.put("name", this.nameIndex);
-
             this.ageIndex = getValidColumnIndex(path, table, "Simple", "age");
             indicesMap.put("age", this.ageIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final SimpleColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final SimpleColumnInfo otherInfo = (SimpleColumnInfo) other;
+            this.nameIndex = otherInfo.nameIndex;
+            this.ageIndex = otherInfo.ageIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final SimpleColumnInfo clone() {
+            return (SimpleColumnInfo) super.clone();
+        }
+
+    }
+    private SimpleColumnInfo columnInfo;
+    private ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -54,18 +73,53 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    SimpleRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (SimpleColumnInfo) columnInfo;
+    SimpleRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (SimpleColumnInfo) context.getColumnInfo();
         this.proxyState = new ProxyState(some.test.Simple.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public String realmGet$name() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.nameIndex);
     }
 
     public void realmSet$name(String value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            if (value == null) {
+                row.getTable().setNull(columnInfo.nameIndex, row.getIndex(), true);
+                return;
+            }
+            row.getTable().setString(columnInfo.nameIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.nameIndex);
@@ -76,60 +130,97 @@
 
     @SuppressWarnings("cast")
     public int realmGet$age() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.ageIndex);
     }
 
     public void realmSet$age(int value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            final Row row = proxyState.getRow$realm();
+            row.getTable().setLong(columnInfo.ageIndex, row.getIndex(), value, true);
+            return;
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setLong(columnInfo.ageIndex, value);
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_Simple")) {
-            Table table = transaction.getTable("class_Simple");
+    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
+        if (!realmSchema.contains("Simple")) {
+            RealmObjectSchema realmObjectSchema = realmSchema.create("Simple");
+            realmObjectSchema.add(new Property("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add(new Property("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            return realmObjectSchema;
+        }
+        return realmSchema.get("Simple");
+    }
+
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_Simple")) {
+            Table table = sharedRealm.getTable("class_Simple");
             table.addColumn(RealmFieldType.STRING, "name", Table.NULLABLE);
             table.addColumn(RealmFieldType.INTEGER, "age", Table.NOT_NULLABLE);
             table.setPrimaryKey("");
             return table;
         }
-        return transaction.getTable("class_Simple");
+        return sharedRealm.getTable("class_Simple");
     }
 
-    public static SimpleColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_Simple")) {
-            Table table = transaction.getTable("class_Simple");
-            if (table.getColumnCount() != 2) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 2 but was " + table.getColumnCount());
+    public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_Simple")) {
+            Table table = sharedRealm.getTable("class_Simple");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 2) {
+                if (columnCount < 2) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 2 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 2 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 2 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-            for (long i = 0; i < 2; i++) {
+            for (long i = 0; i < columnCount; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final SimpleColumnInfo columnInfo = new SimpleColumnInfo(transaction.getPath(), table);
+            final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("name")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("name") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.nameIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("age")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("age") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.ageIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
         }
     }
 
@@ -144,7 +235,8 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        some.test.Simple obj = realm.createObject(some.test.Simple.class);
+        final List<String> excludeFields = Collections.<String> emptyList();
+        some.test.Simple obj = realm.createObjectInternal(some.test.Simple.class, true, excludeFields);
         if (json.has("name")) {
             if (json.isNull("name")) {
                 ((SimpleRealmProxyInterface) obj).realmSet$name(null);
@@ -163,9 +255,10 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.Simple obj = realm.createObject(some.test.Simple.class);
+        some.test.Simple obj = new some.test.Simple();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -188,6 +281,7 @@ public static String getTableName() {
             }
         }
         reader.endObject();
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
@@ -198,6 +292,7 @@ public static String getTableName() {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.Simple) cachedRealmObject;
@@ -211,7 +306,8 @@ public static String getTableName() {
         if (cachedRealmObject != null) {
             return (some.test.Simple) cachedRealmObject;
         } else {
-            some.test.Simple realmObject = realm.createObject(some.test.Simple.class);
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.Simple realmObject = realm.createObjectInternal(some.test.Simple.class, false, Collections.<String>emptyList());
             cache.put(newObject, (RealmObjectProxy) realmObject);
             ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
             ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
@@ -230,9 +326,9 @@ public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,L
         cache.put(object, rowIndex);
         String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
         if (realmGet$name != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
         }
-        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
         return rowIndex;
     }
 
@@ -252,9 +348,9 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 cache.put(object, rowIndex);
                 String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
                 if (realmGet$name != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
                 }
-                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
             }
         }
     }
@@ -270,11 +366,11 @@ public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<Real
         cache.put(object, rowIndex);
         String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
         if (realmGet$name != null) {
-            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
         } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
         }
-        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
         return rowIndex;
     }
 
@@ -294,11 +390,11 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 cache.put(object, rowIndex);
                 String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
                 if (realmGet$name != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
                 }
-                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
             }
         }
     }
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
deleted file mode 100644
index b7d0fc5331..0000000000
--- a/realm/realm-jni/build.gradle
+++ /dev/null
@@ -1,372 +0,0 @@
-import java.security.MessageDigest
-
-ext.coreVersion = '1.5.1'
-// empty or comment out this to disable hash checking
-ext.coreSha256Hash = 'a034d3250c820a15126721142d168a2ac4a12223b75bb324958ca2a70442720d'
-ext.forceDownloadCore =
-        project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
-// gcc is default for the NDK. It also produces smaller binaries
-ext.clang = project.hasProperty('clang') ? project.getProperty('clang').toBoolean() : false
-// Build with debug symbols
-ext.debugBuild = project.hasProperty('debugBuild') ? project.getProperty('debugBuild').toBoolean() : false
-// Strip the symbols from the so file or not. If debugBuild is true, this one will be always false.
-ext.stripSymbols = project.hasProperty('stripSymbols') ? project.getProperty('stripSymbols').toBoolean() : true
-// Set the core source code path. By setting this, the core will be built from source. And coreVersion will be read from
-// core source code.
-ext.coreSourcePath = project.hasProperty('coreSourcePath') ? project.getProperty('coreSourcePath') : null
-// The location of core archive.
-ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
-// target ABIs to build(null means all).
-// To obtain the ABI of the connected device, execute "adb shell getprop ro.product.cpu.abi"
-ext.buildTargetAbis = project.hasProperty('buildTargetABIs') ? project.getProperty('buildTargetABIs').split(',').collect {it.trim()} : null
-
-def commonCflags = [ '-Os', '-std=c++14', '-Wmissing-declarations' , '-Werror', '-fsigned-char']
-// LTO and debugging don't play well together
-if (!ext.debugBuild) {
-    commonCflags += [ '-fvisibility=hidden', '-ffunction-sections', '-fdata-sections', '-flto' ]
-}
-
-enum Compiler {
-    GCC, CLANG
-}
-
-// Unfortunately the NDK has no consistency when it comes to naming.
-// This Class holds all the different names used and some more information
-class Toolchain {
-    // The standard name: arm, arm64, mips, x86
-    String name
-
-    // The name used when generating the standalone toolchain
-    String fullName
-
-    // The prefix commands use. i.e. arm-linux-androideabi-gcc
-    String commandPrefix
-
-    // Which version of each compiler to use
-    Map<Compiler, String> version
-
-    // The first Android platform to support this toolchain
-    int platform
-}
-
-// This class describes the specific target
-class Target {
-    // The name of the target. This is used for the task names
-    String name
-
-    // The name of the abi. It is also the name of the folder where the Android Gradle plugin
-    // expects to find the shared library
-    String abi
-
-    // The toolchain associated to this target
-    Toolchain toolchain
-
-    // The CFLAGS specific to this target
-    List<String> cflags
-}
-
-// We are using gcc 4.9 for all architectures
-def toolchains = [
-    new Toolchain( name:'arm', fullName:'arm-linux-androideabi', commandPrefix:'arm-linux-androideabi', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:8 ),
-    new Toolchain( name:'arm64', fullName:'aarch64-linux-android', commandPrefix:'aarch64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 ),
-    new Toolchain( name:'mips', fullName:'mipsel-linux-android', commandPrefix:'mipsel-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:9 ),
-    new Toolchain( name:'x86', fullName:'x86', commandPrefix:'i686-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:9 ),
-    new Toolchain( name:'x86_64', fullName:'x86_64', commandPrefix:'x86_64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 )
-]
-
-def allTargets = [
-    new Target( name:'arm',     abi:'armeabi',     toolchain:toolchains.find {it.name == 'arm'},    cflags:[ '-mthumb' ] ),
-    new Target( name:'arm-v7a', abi:'armeabi-v7a', toolchain:toolchains.find {it.name == 'arm'},    cflags:[ '-mthumb', '-march=armv7-a', '-mfloat-abi=softfp', '-mfpu=vfpv3-d16' ] ),
-    new Target( name:'arm64',   abi:'arm64-v8a',   toolchain:toolchains.find {it.name == 'arm64'},  cflags:[] ),
-    new Target( name:'mips',    abi:'mips',        toolchain:toolchains.find {it.name == 'mips'},   cflags:[] ),
-    new Target( name:'x86',     abi:'x86',         toolchain:toolchains.find {it.name == 'x86'},    cflags:[] ),
-    new Target( name:'x86_64',  abi:'x86_64',      toolchain:toolchains.find {it.name == 'x86_64'}, cflags:[] )
-]
-
-def targets
-if (ext.buildTargetAbis == null) {
-    targets = allTargets;
-} else {
-    targets = ext.buildTargetAbis.collect { targetAbi ->
-        def target = allTargets.find {it.abi == targetAbi}
-        if (!target) {
-            throw new GradleException("Warning: no target ABIs found for '${targetAbi}'." +
-                    " Please check 'buildTargetABIs' property." +
-                    " Supprted ABIs are ${allTargets.collect {it.abi}. join(', ')}.")
-        }
-        return target
-    }
-}
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'de.undercouch:gradle-download-task:2.0.0'
-    }
-}
-
-apply plugin: 'de.undercouch.download'
-
-if (ext.debugBuild) {
-    // Debug build should never strip symbols
-    ext.stripSymbols = false
-}
-if (ext.coreSourcePath) {
-    // Run the "sh build.sh get-version" to get the core version.
-    ext.coreVersion = "sh build.sh get-version".execute([], file(coreSourcePath)).text.trim()
-}
-
-def getNdk() {
-    if (!System.env.NDK_HOME) {
-        throw new GradleException('The NDK_HOME environment variable is not set.')
-    }
-    def ndkDir = file(System.env.NDK_HOME)
-    if (!ndkDir.directory) {
-        throw new GradleException('The path provided in the NDK_HOME environment variable is not a folder.')
-    }
-    def detectedNdkVersion
-    if (file("${ndkDir}/RELEASE.TXT").file) {
-        detectedNdkVersion = file("${ndkDir}/RELEASE.TXT").text.trim().split()[0].split('-')[0]
-    } else if (file("${ndkDir}/source.properties").file) {
-        def reader = file("${ndkDir}/source.properties").newReader()
-        try {
-            def props = new Properties()
-            props.load(reader)
-            detectedNdkVersion = props.get('Pkg.Revision')
-            if (detectedNdkVersion == null) {
-                throw new GradleException("failed to obtain ndk version information from ${ndkDir}/source.properties")
-            }
-        } finally {
-            reader.close()
-        }
-    } else {
-        throw new GradleException('The path provided in the NDK_HOME environment variable does not seem to be an Android NDK.')
-    }
-    //noinspection GroovyVariableNotAssigned
-    if (detectedNdkVersion != ndkVersion) {
-        throw new GradleException("Your NDK version: ${detectedNdkVersion}. Realm JNI should be compiled with the version ${ndkVersion} of NDK.")
-    }
-    return ndkDir
-}
-
-def getStrippedExt() {
-    return stripSymbols ? "-stripped" : ""
-}
-
-def getDebugExt() {
-    return debugBuild ? "-dbg" : ""
-}
-
-if (!ext.coreArchiveDir) {
-    ext.coreArchiveDir = ".."
-}
-ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/core-android-${project.coreVersion}.tar.gz")
-ext.coreDir = file("${buildDir}/core-${project.coreVersion}")
-
-def coreDownloaded = false
-
-task downloadCore(group: 'build setup', description: 'Download the latest version of realm core') {
-    def isHashCheckingEnabled = {
-        return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
-    }
-
-    def calcSha256Hash = {File targetFile ->
-        MessageDigest sha = MessageDigest.getInstance("SHA-256");
-        Formatter hexHash = new Formatter()
-        sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
-        return hexHash.toString()
-    }
-
-    def shouldDownloadCore = {
-        if (!project.coreArchiveFile.exists()) {
-            return true
-        }
-        if (project.forceDownloadCore) {
-            return true;
-        }
-        if (!isHashCheckingEnabled()) {
-            println "Skipping hash check(empty \'coreSha256Hash\')."
-            return false
-        }
-
-        def calculatedHash = calcSha256Hash(project.coreArchiveFile)
-        if (project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
-            return false
-        }
-
-        println "Existing archive hash mismatch(Expected: ${project.coreSha256Hash.toLowerCase()}" +
-                " but got ${calculatedHash.toLowerCase()}). Download new version."
-        return true
-    }
-
-    doLast {
-        if (shouldDownloadCore()) {
-            download {
-                src "http://static.realm.io/downloads/core/realm-core-android-${project.coreVersion}.tar.gz"
-                dest project.coreArchiveFile
-                onlyIfNewer false
-            }
-            coreDownloaded = true
-
-            if (isHashCheckingEnabled()) {
-                def calculatedHash = calcSha256Hash(project.coreArchiveFile)
-                if (!project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
-                    throw new GradleException("Invalid checksum for file '" +
-                            "${project.coreArchiveFile.getName()}'. Expected " +
-                            "${project.coreSha256Hash.toLowerCase()} but got " +
-                            "${calculatedHash.toLowerCase()}.");
-                }
-            } else {
-                println 'Skipping hash check(empty \'coreSha256Hash\').'
-            }
-        }
-    }
-}
-
-task compileCore(group: 'build setup', description: 'Compile the core library from source code') {
-    // Build the library from core source code
-    doFirst {
-        if (!coreSourcePath) {
-            throw new GradleException('The coreSourcePath is not set.')
-        }
-        exec {
-            workingDir = coreSourcePath
-            commandLine = [
-                    "bash",
-                    "build.sh",
-                    "build-android"
-            ]
-        }
-    }
-
-    // Copy the core tar ball
-    doLast {
-        copy {
-            from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
-            into project.coreArchiveFile.parent
-            rename "realm-core-android-${coreVersion}.tar.gz", "core-android-${coreVersion}.tar.gz"
-        }
-    }
-}
-
-task deployCore(group: 'build setup', description: 'Deploy the latest version of realm core') {
-    dependsOn {
-        coreSourcePath ? compileCore : downloadCore
-    }
-
-    outputs.upToDateWhen {
-        // Clean up the coreDir if it is newly downloaded or compiled from source
-        if (coreDownloaded || coreSourcePath) {
-            return false
-        }
-
-        return project.coreDir.exists()
-    }
-
-    doLast {
-        exec {
-            commandLine = [
-                    'rm',
-                    '-rf',
-                    project.coreDir.getAbsolutePath()
-            ]
-        }
-        copy {
-            from tarTree(project.coreArchiveFile)
-            into project.coreDir
-        }
-	exec {
-	    commandLine = [ 'git', 'clean', '-xfd', "${projectDir}/src" ]
-	}
-    }
-}
-
-toolchains.each { toolchain ->
-    def ndkDir = getNdk()
-    task "generateNdkToolchain${toolchain.name.capitalize()}"(type: Exec) {
-        group 'build setup'
-        description "Generate the NDK standalone toolchain for the ${toolchain.name.capitalize()} platform"
-        outputs.dir file("${buildDir}/standalone-toolchains/${toolchain.name}")
-        commandLine = [
-            "bash",
-            "${ndkDir}/build/tools/make-standalone-toolchain.sh",
-            "--platform=android-${toolchain.platform}",
-            "--install-dir=${buildDir}/standalone-toolchains/${toolchain.name}",
-            "--toolchain=${toolchain.fullName}-${clang?'clang'+toolchain.version[Compiler.CLANG]:toolchain.version[Compiler.GCC]}"
-        ]
-    }
-}
-
-targets.each { target ->
-    task "buildAndroidJni${target.name.capitalize()}"(type: Exec) {
-        group 'build'
-        description "Build the Android JNI shared library for the ${target.name.capitalize()} platform"
-        dependsOn deployCore
-        dependsOn "generateNdkToolchain${target.toolchain.name.capitalize()}"
-        environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
-        environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
-        environment STRIP: "${target.toolchain.commandPrefix}-strip -o librealm-jni-${target.name}-stripped.so"
-        environment REALM_ANDROID: '1'
-        commandLine = [
-            'make',
-            "-j${Runtime.getRuntime().availableProcessors() * 2}",
-            "-l${Runtime.getRuntime().availableProcessors()}",
-            '-C', "${projectDir}/src",
-            "CC_IS=${clang?'clang':'gcc'}",
-            "REALM_CFLAGS_COMMON=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${project.coreDir}/include",
-            "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
-            "BASE_DENOM=${target.name}",
-            "REALM_LDFLAGS_COMMON=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${project.coreDir} -Wl,--gc-sections -Wl,-soname,librealm-jni.so",
-            'LIB_SUFFIX_SHARED=.so',
-            "librealm-jni-${target.name}${getDebugExt()}.so"
-        ]
-    }
-
-    task "copyAndroidJni${target.name.capitalize()}"(dependsOn: "buildAndroidJni${target.name.capitalize()}") << {
-        copy {
-            from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so"
-            into "${projectDir}/../realm-library/src/main/jniLibs/${target.abi}"
-            rename "librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so", 'librealm-jni.so'
-        }
-
-        // Store the unstripped version
-        copy {
-            from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
-            into "${buildDir}/outputs/jniLibs-unstripped/${target.abi}"
-            rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
-        }
-    }
-}
-
-task buildAndroidJni(group: 'build', description: 'Build the Android JNI shared library for all the supported platforms') {
-    targets.each { target ->
-        dependsOn "copyAndroidJni${target.name.capitalize()}"
-    }
-}
-
-task clean(type: Delete) {
-    outputs.upToDateWhen {
-        project.hasProperty('dontCleanJniFiles')
-    }
-
-    delete project.buildDir
-
-    delete fileTree(dir: "${projectDir}/../realm-library/src/main/jniLibs/", include: '**/librealm-jni*.so')
-    delete fileTree(dir: "${projectDir}/src/", include: '**/librealm-jni*-stripped.so')
-
-    doLast {
-        targets.each { target ->
-            exec {
-                commandLine = [
-                        'make',
-                        '-C', "${projectDir}/src",
-                        "BASE_DENOM=${target.name}",
-                        'LIB_SUFFIX_SHARED=.so',
-                        'clean'
-                ]
-            }
-        }
-    }
-}
diff --git a/realm/realm-jni/generate-jni-headers.sh b/realm/realm-jni/generate-jni-headers.sh
deleted file mode 100755
index 692757c4c8..0000000000
--- a/realm/realm-jni/generate-jni-headers.sh
+++ /dev/null
@@ -1,18 +0,0 @@
-#!/bin/bash
-#
-# Generate header file for JNI calls
-#
-# Assumption: the .java files have been compiled
-# 1. build project using Android Studio (or gradle); unit tests will probably fail due to missing native methods
-# 2. run this script
-# 3. rebuild project using Android Studio (or gradle)
-
-# Setting up
-CLASSDIR="$(pwd)/../realm-library/build/intermediates/classes/release/"
-JNIDIR="$(pwd)/src"
-
-# Generate the headers
-(cd "$CLASSDIR" && javah -jni -classpath "$CLASSDIR" -d "$JNIDIR" io.realm.internal.Group io.realm.internal.LinkView io.realm.internal.Row io.realm.internal.SharedGroup io.realm.internal.Table io.realm.internal.TableQuery io.realm.internal.TableView io.realm.internal.Util)
-
-# Remove "empty" header files (they have 13 lines)
-wc -l "$JNIDIR"/*.h | grep " 13 " | awk '{print $2}' | xargs rm -f
diff --git a/realm/realm-jni/generic.mk b/realm/realm-jni/generic.mk
deleted file mode 100644
index 9b0d6fdf55..0000000000
--- a/realm/realm-jni/generic.mk
+++ /dev/null
@@ -1,1971 +0,0 @@
-# Generic makefile that captures some of the ideas of GNU Automake,
-# especially with respect to naming targets.
-#
-# Author: Kristian Spangsege
-#
-# Version: 1.0.2
-#
-# This makefile requires GNU Make. It has been tested with version
-# 3.81, and it is known to work well on both Linux and OS X.
-#
-#
-# Major goals
-# -----------
-#
-# clean ........ Delete targets and other files that are produced
-#                while building.
-#
-# build (default) Build convenience libraries (`noinst_LIBRARIES`)
-#                plus everything that `install-only` wants to install
-#                (when disregarding `INSTALL_FILTER`). If necessary,
-#                the convenience libraries will also be built in
-#                'debug' mode.
-#
-# install ...... Same as `build` followed by `install-only`.
-#
-# uninstall .... Uninstall everything that `install` would install.
-#
-# install-only . Installs `HEADERS`, `LIBRARIES`, `PROGRAMS`, and
-#                `DEV_PROGRAMS`. Whether static libraries and/or
-#                'debug' mode versions are also installed depends on
-#                various configuration parameters. Note that
-#                `INSTALL_FILTER` can be used to select a subset of
-#                the above.
-#
-# ### Selective building
-#
-# release ...... Builds `LIBRARIES`, `noinst_LIBRARIES`, `PROGRAMS`,
-#                `DEV_PROGRAMS`, and `noinst_PROGRAMS` in 'release'
-#                mode.
-#
-# nodebug ...... Builds everything that `release` does, plus static
-#                versions installable libraries (`LIBRARIES`) in
-#                'release' mode.
-#
-# debug ........ Builds everything that `release` does, but in 'debug'
-#                mode.
-#
-# cover ........ Builds everything that `release` does, but in 'code
-#                coverage' mode.
-#
-# everything ... Builds `LIBRARIES`, `noinst_LIBRARIES`,
-#                `check_LIBRARIES`, `PROGRAMS`, `DEV_PROGRAMS`, and
-#                `noinst_PROGRAMS` in both 'release' and 'debug' mode.
-#
-# ### Testing
-#
-# check ......... Build `LIBRARIES`, `noinst_LIBRARIES`,
-#                 `check_LIBRARIES`, `PROGRAMS`, and `check_PROGRAMS`
-#                 in 'release' mode, then run all `check_PROGRAMS`.
-#
-# check-debug ... Same as `check`, but in 'debug' mode.
-#
-# check-cover ... Same as `check`, but in 'code coverage' mode.
-#
-# memcheck, memcheck-debug Same as `check` and `check-debug`
-#                 respectively, but runs each program under Valgrind.
-#
-# check-norun, check-debug-norun, check-cover-norun Same as `check`,
-#                 `check-debug`, and `check-cover` respectively, but
-#                 stop after building.
-#
-#
-# Building installable programs and libraries
-# -------------------------------------------
-#
-# Here is an example of a complete `Makefile` that uses `generic.mk`
-# to build a program called `myprog` out of two source files called
-# `foo.cpp` and `bar.cpp`:
-#
-#   bin_PROGRAMS = myprog
-#   myprog_SOURCES = foo.cpp bar.cpp
-#   include generic.mk
-#
-# The `bin` in `bin_PROGRAMS` means that your program will be
-# installed in the directory specified by the `bindir` variable which
-# is set to `/usr/local/bin` by default. This can be overridden by
-# setting `prefix`, `exec_prefix`, or `bindir`.
-#
-# Note: You can place `generic.mk` anywhere you like inside your
-# project, but you must always refer to it by a relative path, and if
-# you have multiple `Makefile`s in multiple directories, they must all
-# refer to the same `generic.mk`.
-#
-# Here is how to build a library:
-#
-#   include_HEADERS = foo.hpp
-#   lib_LIBRARIES = libfoo.a
-#   libfoo_a_SOURCES = libfoo.cpp
-#
-# Again, the `lib` prefix in `lib_LIBRARIES` means that your library
-# will be installed in the directory specified by the `libdir`
-# variable which is typically set to `/usr/local/lib` by default. The
-# exact default path depends on the chosen installation prefix as well
-# as platform policies, for example, on a 64 bit Fedora, it will be
-# `/usr/local/lib64`. This can be overridden by setting `prefix`,
-# `exec_prefix`, or `libdir`.
-#
-# The `lib` prefix in `libfoo.a` is mandatory for all installed
-# libraries. The `.a` suffix is mandatory for both installed an
-# non-installed libraries. The actual extension of the installed
-# library is not necessarily going to be `.a`. For a shared library on
-# Linux, it will be `.so` by default. The important point is that the
-# specified library name is a logical name that is mapped to one or
-# more physical names by `generic.mk`.
-#
-# Note that `.` is replaced by `_` when referring to `libfoo.a` in
-# `libfoo_a_SOURCES`. In general, when a target (program or library)
-# name is used as part of a variable name, any character that is
-# neither alphanumeric nor an underscore, is converted to an
-# underscore.
-#
-# Installed libraries are generally accompanied by one or more headers
-# to be included by applications that use the library. Such headers
-# must be listed in the `include_HEADERS` variable. Headers are
-# installed in `/usr/local/include` by default, but this can be
-# changed by setting the `prefix` or `includedir` variable. Note also
-# that headers can be installed in a subdirectory of
-# `/usr/local/include` or even into a multi-level hierarchy of
-# subdirectories (see the 'Subdirectories' section for more on this).
-#
-# To build more than one program, or more than one library, simply
-# list all of them in `bin_PROGRAMS` or `lib_LIBRARIES`. For
-# example:
-#
-#   bin_PROGRAMS = hilbert banach
-#   hilbert_SOURCES = ...
-#   banach_SOURCES = ...
-#
-# Here is how to build a library as well as a program that uses the
-# library:
-#
-#   lib_LIBRARIES = libmyparser.a
-#   bin_PROGRAMS = parser
-#   libmyparser_a_SOURCES = myparser.c
-#   parser_SOURCES = parser.c
-#   parser_LIBS = libmyparser.a
-#
-# I you have two libraries, and one depends on the other:
-#
-#   lib_LIBRARIES = libfoo.a libbar.a
-#   libbar_a_LIBS = libfoo.a
-#
-# The installation directory for programs, libraries, and headers is
-# determined by the primary prefix being used. Note that `PROGRAMS`,
-# `LIBRARIES`, and `HEADERS` are primaries, and that `bin` is a
-# primary prefix in `bin_PROGRAMS`, for example. The following primary
-# prefixes are supported directly by `generic.mk`:
-#
-#   Prefix     Variable    Installation directory  Default value
-#   ----------------------------------------------------------------------------
-#   bin        bindir      $(exec_prefix)/bin      (/usr/local/bin)
-#   sbin       sbindir     $(exec_prefix)/sbin     (/usr/local/sbin)
-#   lib        libdir      $(exec_prefix)/lib      (/usr/local/lib)         (*1)
-#   libexec    libexecdir  $(exec_prefix)/libexec  (/usr/local/libexec)
-#   include    includedir  $(prefix)/include       (/usr/local/include)
-#   subinclude includedir  $(prefix)/include/...   (/usr/local/include/...) (*2)
-#
-#   (*1) The actual default value depends on the platform.
-#   (*2) Only available when `INCLUDE_ROOT` is specified.
-#
-# You can also install a program, a library, or a header into a
-# non-default directory by defining a custom primary prefix. This is
-# usefull when you want (for other purposes) to maintain the default
-# values of the standard prefixes. Here is an example:
-#
-#   EXTRA_PRIMARY_PREFIXES = libhome
-#   libhomedir = /usr/lib/mydeamon/bin
-#   libhome_PROGRAMS = mydaemon
-#
-# When doing 'filtered installs' (using `make install
-# INSTALL_FILTER=...`) there is a distinction between two categories
-# of programs, ordinary programs and 'developer programs'. When a
-# project that provides a library gets distributed in compiled form,
-# it is customary to offer two packages, the main one, that provides
-# the shared library, and a secondary one that provides the header
-# files. Some such projects offer programs that are packaged together
-# with the shared library, and other programs that are packaged
-# together with the headers. The latter category is what we refer to
-# as 'developer programs' when working with filtered installs.
-#
-# To mark a program as a 'developer program' use the special primary
-# prefix 'DEV' as in the following example:
-#
-#   DEV_PROGRAMS = mylib-config
-#   mylib_config_SOURCES = ...
-#
-# These programs are installed into the same directory as
-# `bin_PROGRAMS`.
-#
-#
-# Convenience libraries
-# ---------------------
-#
-# A convenience library is one that is not installed, but gets linked
-# statically into programs that are built as part of the same
-# project. Convenience libraries are created by using the special
-# primary prefix `noinst`, for example:
-#
-#   noinst_LIBRARIES = util.a
-#   bin_PROGRAMS = foo
-#   foo_SOURCES = foo.cpp
-#   foo_LIBS = util.a
-#
-# Note that in contrast to installed libraries, names of convenience
-# libraries are not required to have `lib` as a prefix, but the `.a`
-# suffix is still mandatory. Additionally, convenience library names
-# do not have to be unique. Indeed, it is valid for a program to be
-# linked against two convenience libraries of the same name, as long
-# as they reside in different subdirectories within the
-# project. Installed libraries, on the other hand, need to have
-# system-wide unique names.
-#
-# It is an error to list a convenience library as a dependency of
-# another convenience library or as a dependency of an installed
-# library. Only programs can be declared to depend on convenience
-# libraries.
-#
-# A convenience library such as `util.a` can be made to depend on
-# project-local installed libraries by listing them in the
-# `util_a_LIBS` variable. This can be done because code in `util.a`
-# depends on those other libraries, or it can be done simply to avoid
-# specifying them repeatedly for multiple programs. On top of that, it
-# is possible to attach a set of extra linker flags to a convenience
-# library, to be used when linking programs against it. Such flags are
-# listed in `util_a_LDFLAGS`. This can be used, for example, to
-# specify linking against system libraries or other separately
-# installed libraries.
-#
-#
-# Installed programs
-# ------------------
-#
-# If a program, that is supposed to be installed, is linked against a
-# locally built shared library, then `generic.mk` will pass the
-# appropriate `-rpath` option to the program linker, such that the
-# dynamic linker can find the library in its installed
-# location. Unfortunately this does not enable the program to find the
-# locally built library, and therefore it will generally not be
-# possible to execute the program until after the library is
-# installed.
-#
-# To work around this problem, `generic.mk` will create an extra
-# version of the program, where it sets the `RPATH` in such a way that
-# the (yet to be installed) library can be found. The name of the
-# extra version is constructed by appending `-noinst` to the name of
-# the regular version. The extra 'noinst' version is created only for
-# testing purposes, and it will not be included during
-# installation. It should be noted that the extra 'noinst' version is
-# created only for programs that are linked against locally built,
-# shared libraries.
-#
-# The extra 'noinst' versions of installed programs, as well as test
-# programs and programs declared using the special primary prefix
-# `noinst`, are all configured with relative `RPATH`s. This means that
-# they will continue to work even when the project is relocated to a
-# different directory, as long as the internal directory structure
-# remains the same.
-#
-# Note that the standard installation procedure, that places targets
-# in system directories according to category (`/usr/local/bin`,
-# `/usr/local/lib`, ...), does not in general preserve the relative
-# paths between targets with respect to how they occur in your project
-# directory. Further more, the standard installation procedure is
-# based upon the idea that the final installed location of targets is
-# specified and fixed at build time.
-#
-# As a special option, `generic.mk` can be asked to completely disable
-# its support for installation, and instead link all programs as if
-# they had been declared as 'noinst' programs in the first place. This
-# mode also disables the creation of the extra 'noinst' versions (as
-# they would be redundant), and it will disable shared library
-# versioning, that is, it will build each library as if no version was
-# specified for it (see 'Library versioning' below). This mode is
-# enabled by setting the environment variable `ENABLE_NOINST_BUILD` to
-# a non-empty value. Be sure to do a `make clean` when you switch
-# between 'noinst' and regular mode.
-#
-#
-# Programs that are not installed
-# -------------------------------
-#
-# Sometimes it is desirable to build a program that is not supposed to
-# be installed when running `make install`. One reason could be that
-# the program is used only for testing. Such programs are created by
-# using the special primary prefix `noinst`, for example:
-#
-#   noinst_PROGRAMS = performance
-#
-# There is another related category of programs called 'test programs'
-# that are both built and executed when running `make test`. These
-# programs are created by using the `check` primary prefix, and are
-# also not installed:
-#
-#   check_PROGRAMS = test_foo test_bar
-#
-# It is also possible to create a convenience library that is built
-# only when 'test programs' are built. List libraries of this kind in
-# `check_LIBRARIES`.
-#
-#
-# Subdirectories
-# --------------
-#
-# In larger projects it is desirable to organize the source files into
-# multiple subdirectories. This can be done in two ways, using a
-# single `Makefile` or using multiple `Makefile`s. When using a single
-# `Makefile`, refer to the source files using relative paths as
-# follows:
-#
-#   myprog_SOURCES = foo/alpha.cpp bar/beta.cpp
-#
-# The alternative is to use multiple `Makefile`s. This requires one or
-# more subdirectories each one with an extra subordinate
-# `Makefile`. The top-level `Makefile` must then use the `SUBDIRS`
-# variable to list each of the involved subdirectories. When there is
-# a dependency between two subdirectories, the top-level `Makefile`
-# must declare this. Here is an example:
-#
-#   Makefile:
-#     SUBDIRS = foo bar
-#     bar_DEPS = foo
-#     include generic.mk
-#
-#   foo/Makefile:
-#     lib_LIBRARIES = util.a
-#     util_a_SOURCES = ...
-#     include ../generic.mk
-#
-#   bar/Makefile:
-#     bin_PROGRAMS = myprog
-#     myprog_SOURCES = ...
-#     myprog_LIBS = ../foo/util.a
-#
-# To declare that a subdirectory `foo` depends on stuff in the current
-# directory (presumably libraries), include `.` in `foo_DEPS`. To
-# declare that the current directory depends on stuff in a
-# subdirectory, list that subdirectory in the `DIR_DEPS` variable as
-# in the following example:
-#
-#   Makefile:
-#     SUBDIRS = util
-#     DIR_DEPS = util
-#     bin_PROGRAMS = myprog
-#     myprog_SOURCES = ...
-#     myprog_LIBS = util/util.a
-#     include generic.mk
-#
-#   util/Makefile:
-#     noinst_LIBRARIES = util.a
-#     util_a_SOURCES = ...
-#     include ../generic.mk
-#
-# FIXME: Mention `PASSIVE_SUBDIRS` (such directories are cleaned but
-# not otherwise included during recursive `make` invocations).
-#
-#
-# Compiler and linker flags
-# -------------------------
-#
-# Extra compiler and linker flags can be specified for each target
-# (program or library):
-#
-#   bin_PROGRAMS = myprog
-#   myprog_SOURCES = foo.cpp bar.cpp
-#   myprog_CFLAGS = -Wno-long-long
-#   myprog_LDFLAGS = -lparser
-#
-# Compiler flags can also be specified for individual object files,
-# for example, to add flags just to the compilation of `foo.o`:
-#
-#   foo_o_CFLAGS = -I/opt/parser-1.5/include
-#
-# Compiler and linker flags can be specified for all targets in a
-# directory (the directory containing the `Makefile`) as follows:
-#
-#   DIR_CFLAGS = ...
-#   DIR_LDFLAGS = ...
-#
-# In a project that consists of multiple subprojects (each one in its
-# own subdirectory and with its own `Makefile`,) compiler and linker
-# flags can be specified for all targets in the project by setting
-# `PROJECT_CFLAGS` and `PROJECT_LDFLAGS` in `project.mk`:
-#
-#   PROJECT_CFLAGS = ...
-#   PROJECT_LDFLAGS = ...
-#
-# All these compiler and linker flag specifications are additive.
-#
-#
-# Debug and coverage analysis modes
-# ---------------------------------
-#
-#   foo_o_CFLAGS_OPTIM
-#   foo_o_CFLAGS_DEBUG
-#   foo_o_CFLAGS_COVER
-#
-#
-# Library versioning
-# ------------------
-#
-#   lib_LIBRARIES = libmyparser.a
-#   libmyparser_a_VERSION = 4:0:0
-#
-# Format: CURRENT[:REVISION[:AGE]]
-#
-# At each new public release:
-#   If the interface has changed at all:
-#     Increment CURRENT and reset REVISION to zero
-#     Let COMPAT be the least number such that the new library (in
-#       its binary form) can be used as a drop-in replacement for
-#       all previous releases whose CURRENT is greater than or equal
-#       to COMPAT
-#     If COMPAT + AGE < CURRENT:
-#       Increment AGE
-#     Else:
-#       Reset AGE to zero
-#   Else:
-#     Increment REVISION
-#
-# The meaning of this version string is identical to the one defined
-# by GNU Libtool. See also
-# http://www.gnu.org/software/libtool/manual/libtool.html#Libtool-versioning
-#
-#
-# Generated sources
-# -----------------
-#
-# FIXME: Describe `GENERATED_SOURCES`.
-#
-#
-# Configuration variables
-# -----------------------
-#
-# All variables listed in the section CONFIG VARIABLES are available
-# for modification in `project.mk`, and they may also be overridden on
-# the command line. For example, to enable POSIX Threads and disable
-# automatic dependency tracking, you could do this:
-#
-#   make CFLAGS_PTHREADS="-pthreads" CFLAGS_AUTODEP=""
-#
-# If CFLAGS is specified in the environment or on the command line, it
-# will replace the value of CFLAGS_GENERAL. Similarly with LDFLAGS and
-# ARFLAGS.
-#
-# If EXTRA_CFLAGS is specified on the command line, its contents will
-# be added to CFLAGS_GENERAL. Similarly with LDFLAGS.
-#
-# If CC, CXX, OCC, OCXX, LD, and AR are specified in the environment
-# or on the command line, their values will be respected.
-#
-# NOTE: When you change the configuration specified via the
-# environment or the command line from one invocation of make to the
-# next, you should always start with a 'make clean'. MAKE does this
-# automatically when you change `project.mk`.
-#
-# If `CC` is neither specified in the environment nor on the command
-# line, `generic.mk` will look for a number of well-known compilers
-# (GCC, Clang), and set `CC` accordingly. If CXX or OCC is neither
-# specified in the environment nor on the command line, it will be set
-# to whatever `CC` is set to. Likewise, if `OCXX` is neither specified
-# in the environment nor on the command line, it will be set to
-# whatever `OCC` is set to. If `LD` or `AR` is neither specified in
-# the environment nor on the command line, `generic.mk` will attempt
-# to derive their values from `CC`.
-#
-# A number of variables are provided to query about the
-# detected/specified tool chain:
-#
-# If `generic.mk` can identify the contents of `CC` as GCC or Clang,
-# it sets `CC_IS` to `gcc` or `clang` respectively, and
-# `CC_IS_GCC_LIKE` to `yes`. Otherwise it sets both `CC_IS` and
-# `CC_IS_GCC_LIKE` to empty strings. Equivalent variables exist for
-# `CXX`, `OCC`, `OCXX`, and `LD`.
-#
-# Additionally, if `IS_CC`, `IS_CXX`, `IS_OCC`, and `IS_OCXX` are all
-# equal, then `COMPILER_IS` is set to that value (`gcc` or
-# `clang`). Likewise, if all four are GCC-like, then
-# `COMPILER_IS_GCC_LIKE` is set to `yes`.
-#
-# In general, `generic.mk` can identify a compiler or linker as GCC if
-# its name (when arguments are stripped away and path is removed) is
-# `gcc` or `g++`, or begins with `gcc-` or `g++-`. Likewise with Clang
-# if the name is `clang` or `clang++`.
-#
-# When `COMPILER_IS_GCC_LIKE` is true (not empty), `generic.mk` will
-# add a number of sensible GCC-like compiler flags for optimization,
-# debugging, profiling, header dependency tracking, and
-# more. Likewise, if `LD_IS_GCC_LIKE` is not empty, extra linker flags
-# will be added.
-#
-# If you set `CC` to something that is GCC-like, but is not
-# automatically identified as such (e.g. `arm-linux-androideabi-gcc`),
-# you can manually override `CC_IS` (or any of the other classifying
-# variables) on the `make` command line. When done right, this will
-# fix "chained" classification variables, and reenable the automatic
-# addition of extra GCC-like compiler/linker flags.
-#
-#
-# Technicalities
-# --------------
-#
-# Project local files and directories mentioned in variables passed to
-# `generic.mk` as part of specifying target, source, or subdirectory
-# paths, must consist entirely of letters, digits, `_`, `-`, and `.`
-# (all from the ASCII character set). In particular, spaces are not
-# allowed. When variable names are constructed from paths, `/`, `-`,
-# and `.` are folded to `_`.
-#
-# The same restriction applies to all installation directories
-# (`bindir`, `libdir` `includedir`, etc.).
-#
-# On the other hand, the value of `DESTDIR` may contain any graphical
-# characters from the ASCII character set as well as SPACE and TAB.
-#
-# Except when you are building in 'code coverage' mode, the absolute
-# path to the root of your project may contain any graphical
-# characters from ASCII as well as SPACE and TAB. However, when you
-# are building in 'code coverage' mode, your project root path must
-# adhere to the same restrictions that apply to project local target
-# paths passed to `generic.mk`.
-
-
-
-# CONFIG VARIABLES
-
-# The relative path to the root of the include tree. If specified, a
-# corresponding include option (`-I`) is added to the compiler command
-# line for all object file targets in the project, and the primary
-# prefix `subinclude` becomes available in Makefiles contained inside
-# the specified directory.
-INCLUDE_ROOT =
-
-CFLAGS_OPTIM          = -DNDEBUG
-CFLAGS_DEBUG          =
-CFLAGS_COVER          =
-CFLAGS_SHARED         =
-CFLAGS_PTHREADS       =
-CFLAGS_GENERAL        =
-CFLAGS_C              =
-CFLAGS_CXX            =
-CFLAGS_OBJC           =
-CFLAGS_ARCH           =
-CFLAGS_INCLUDE        =
-CFLAGS_AUTODEP        =
-LDFLAGS_OPTIM         = $(filter-out -D%,$(CFLAGS_OPTIM))
-LDFLAGS_DEBUG         = $(filter-out -D%,$(CFLAGS_DEBUG))
-LDFLAGS_COVER         = $(filter-out -D%,$(CFLAGS_COVER))
-LDFLAGS_SHARED        =
-LDFLAGS_PTHREADS      = $(CFLAGS_PTHREADS)
-LDFLAGS_GENERAL       =
-LDFLAGS_ARCH          = $(CFLAGS_ARCH)
-ARFLAGS_GENERAL       = csr
-
-PROJECT_CFLAGS        =
-PROJECT_CFLAGS_OPTIM  =
-PROJECT_CFLAGS_DEBUG  =
-PROJECT_CFLAGS_COVER  =
-PROJECT_LDFLAGS       =
-PROJECT_LDFLAGS_OPTIM =
-PROJECT_LDFLAGS_DEBUG =
-PROJECT_LDFLAGS_COVER =
-
-LIB_SUFFIX_STATIC     = .a
-LIB_SUFFIX_SHARED     = .so
-LIB_SUFFIX_LIBDEPS    = .libdeps
-
-ifneq ($(filter undefined environment,$(origin PROG_SUFFIX)),)
-PROG_SUFFIX           =
-endif
-
-BASE_DENOM            =
-OBJ_DENOM_SHARED      = .pic
-OBJ_DENOM_OPTIM       =
-OBJ_DENOM_DEBUG       = .dbg
-OBJ_DENOM_COVER       = .cov
-LIB_DENOM_OPTIM       =
-LIB_DENOM_DEBUG       = -dbg
-LIB_DENOM_COVER       = -cov
-PROG_DENOM_OPTIM      =
-PROG_DENOM_DEBUG      = -dbg
-PROG_DENOM_COVER      = -cov
-
-# When set to an empty value, 'make install' will not install the
-# static versions of the libraries mentioned in lib_LIBRARIES, and a
-# plain 'make' will not even build them. When set to a nonempty value,
-# the opposite is true.
-ENABLE_INSTALL_STATIC_LIBS =
-
-# When set to an empty value, 'make install' will not install the
-# debug versions of the libraries mentioned in lib_LIBRARIES, and a
-# plain 'make' will not even build them. When set to a nonempty value,
-# the opposite is true.
-ENABLE_INSTALL_DEBUG_LIBS =
-
-# When set to an empty value, 'make install' will not install the
-# debug versions of the programs mentioned in bin_PROGRAMS, and a
-# plain 'make' will not even build them. When set to a nonempty value,
-# the opposite is true.
-ENABLE_INSTALL_DEBUG_PROGS =
-
-# Use this if you want to install only a subset of what is usually
-# installed. For example, to produce a separate binary and development
-# package for a library product, you can run 'make install
-# INSTALL_FILTER=shared-libs,progs' for the binary package and 'make
-# install INSTALL_FILTER=static-libs,dev-progs,headers' for the
-# development package. This filter affects uninstallation the same way
-# it affects installation.
-INSTALL_FILTER = shared-libs,static-libs,progs,dev-progs,headers
-
-# Installation (GNU style)
-prefix          = /usr/local
-exec_prefix     = $(prefix)
-bindir          = $(exec_prefix)/bin
-sbindir         = $(exec_prefix)/sbin
-libdir          = $(if $(USE_LIB64),$(exec_prefix)/lib64,$(exec_prefix)/lib)
-libexecdir      = $(exec_prefix)/libexec
-includedir      = $(prefix)/include
-INSTALL         = install
-INSTALL_DIR     = $(INSTALL) -d
-INSTALL_DATA    = $(INSTALL) -m 644
-INSTALL_LIBRARY = $(INSTALL) -m 644
-INSTALL_PROGRAM = $(INSTALL)
-
-VALGRIND       ?= valgrind
-VALGRIND_FLAGS ?= --quiet --track-origins=yes --leak-check=yes --leak-resolution=low
-
-# Alternative filesystem root for installation
-DESTDIR =
-
-
-
-# UTILITY CONSTANTS AND FUNCTIONS
-
-EMPTY :=
-SPACE := $(EMPTY) $(EMPTY)
-COMMA := ,
-APOSTROPHE := $(patsubst "%",%,"'")
-
-define NEWLINE
-$(EMPTY)
-$(EMPTY)
-endef
-
-define TAB
-	$(EMPTY)
-endef
-
-NL_TAB := $(NEWLINE)$(TAB)
-
-IDENTITY = $(1)
-
-IS_EQUAL_TO = $(and $(findstring $(1),$(2)),$(findstring $(2),$(1)))
-
-# ARGS: prefix, string
-IS_PREFIX_OF = $(findstring .$(call IS_PREFIX_OF_1,$(1)),.$(call IS_PREFIX_OF_1,$(2)))
-IS_PREFIX_OF_1 = $(subst .,:d:,$(subst :,:c:,$(1)))
-
-COND_PREPEND = $(if $(2),$(1)$(2))
-COND_APPEND  = $(if $(1),$(1)$(2))
-
-LIST_CONCAT  = $(if $(and $(1),$(2)),$(1) $(2),$(1)$(2))
-LIST_REVERSE = $(if $(1),$(call LIST_CONCAT,$(call LIST_REVERSE,$(wordlist 2,$(words $(1)),$(1))),$(firstword $(1))))
-
-# ARGS: predicate, list, optional_predicate_arg
-STABLE_PARTITION = $(call STABLE_PARTITION_1,$(1),$(strip $(2)),$(3))
-STABLE_PARTITION_1 = $(if $(2),$(call STABLE_PARTITION_2,$(1),$(wordlist 2,$(words $(2)),$(2)),$(3),$(4),$(5),$(word 1,$(2))),$(strip $(4) $(5)))
-STABLE_PARTITION_2 = $(if $(call $(1),$(6),$(3)),$(call STABLE_PARTITION_1,$(1),$(2),$(3),$(4) $(6),$(5)),$(call STABLE_PARTITION_1,$(1),$(2),$(3),$(4),$(5) $(6)))
-
-# ARGS: predicate, list, optional_predicate_arg
-# Expands to first entry that satisfies the predicate, or the empty string if no entry satsifies it.
-FIND = $(call FIND_1,$(1),$(strip $(2)),$(3))
-FIND_1 = $(if $(2),$(call FIND_2,$(1),$(2),$(3),$(word 1,$(2))))
-FIND_2 = $(if $(call $(1),$(4),$(3)),$(4),$(call FIND_1,$(1),$(wordlist 2,$(words $(2)),$(2)),$(3)))
-
-# ARGS: func, init_accum, list
-FOLD_LEFT = $(call FOLD_LEFT_1,$(1),$(2),$(strip $(3)))
-FOLD_LEFT_1 = $(if $(3),$(call FOLD_LEFT_1,$(1),$(call $(1),$(2),$(word 1,$(3))),$(wordlist 2,$(words $(3)),$(3))),$(2))
-
-# ARGS: list_1, list_2
-UNION = $(call FOLD_LEFT,UNION_1,$(1),$(2))
-UNION_1 = $(if $(call FIND,IS_EQUAL_TO,$(1),$(2)),$(1),$(if $(1),$(1) $(2),$(2)))
-
-# ARGS: list
-REMOVE_DUPES = $(call UNION,,$(1))
-
-# ARGS: predicate, list, optional_predicate_arg
-FILTER = $(call FILTER_1,$(1),$(strip $(2)),$(3))
-FILTER_1 = $(if $(2),$(call FILTER_1,$(1),$(wordlist 2,$(words $(2)),$(2)),$(3),$(call LIST_CONCAT,$(4),$(if $(call $(1),$(word 1,$(2)),$(3)),$(word 1,$(2))))),$(4))
-
-# ARGS: list
-REMOVE_PREFIXES = $(call FILTER,REMOVE_PREFIXES_1,$(1),$(1))
-REMOVE_PREFIXES_1 = $(if $(call FIND,REMOVE_PREFIXES_2,$(2),$(1)),,x)
-REMOVE_PREFIXES_2 = $(if $(call IS_EQUAL_TO,$(2),$(1)),,$(call IS_PREFIX_OF,$(2),$(1)))
-
-HIDE_SPACE   = $(subst $(TAB),:t:,$(subst $(SPACE),:s:,$(subst :,:c:,$(1))))
-UNHIDE_SPACE = $(subst :c:,:,$(subst :s:,$(SPACE),$(subst :t:,$(TAB),$(1))))
-
-# If `a` and `b` are relative or absolute paths (without a final
-# slash), and `b` points to a directory, then PATH_DIFF(a,b) expands
-# to the relative path from `b` to `a`. If abspath(a) and abspath(b)
-# are the same path, then PATH_DIFF(a,b) expands to the empty string.
-PATH_DIFF = $(call PATH_DIFF_2,$(call PATH_DIFF_1,$(1)),$(call PATH_DIFF_1,$(2)))
-PATH_DIFF_1 = $(subst /,$(SPACE),$(abspath $(call HIDE_SPACE,$(if $(filter /%,$(1)),$(1),$(abspath .)/$(1)))))
-PATH_DIFF_2 = $(if $(and $(1),$(2),$(call IS_EQUAL_TO,$(word 1,$(1)),$(word 1,$(2)))),$(call PATH_DIFF_2,$(wordlist 2,$(words $(1)),$(1)),$(wordlist 2,$(words $(2)),$(2))),$(call UNHIDE_SPACE,$(subst $(SPACE),/,$(strip $(patsubst %,..,$(2)) $(1)))))
-
-# If `p` is already an absolute path, or if `optional_abs_base` is not
-# specified, then `MAKE_ABS_PATH(p, optional_abs_base)` expands to
-# `abspath(p)`. Otherwise, `optional_abs_base` must be an absolute
-# path, and this function expands to
-# `abspath(optional_abs_base+'/'+p)`. As opposed to the built-in
-# function `abspath()`, this function properly handles paths that
-# contain spaces.
-MAKE_ABS_PATH = $(call UNHIDE_SPACE,$(abspath $(call HIDE_SPACE,$(if $(filter /%,$(1)),$(1),$(or $(2),$(abspath .))/$(1)))))
-
-# If `p` and `base` are paths, then MAKE_REL_PATH(p,base) expands to
-# the relative path from abspath(base) to abspath(p). If the two paths
-# are equal, it expands to `.`. If `base` is unspecified, it defaults
-# to `.`.
-MAKE_REL_PATH = $(or $(call PATH_DIFF,$(1),$(or $(2),.)),.)
-
-IS_SAME_PATH_AS = $(call IS_EQUAL_TO,$(call CANON_PATH_HIDE_SPACE,$(1)),$(call CANON_PATH_HIDE_SPACE,$(2)))
-IS_PATH_CONTAINED_IN = $(call IS_PREFIX_OF,$(call CANON_PATH_HIDE_SPACE,$(2))/,$(call CANON_PATH_HIDE_SPACE,$(1)))
-CANON_PATH_HIDE_SPACE = $(abspath $(call HIDE_SPACE,$(patsubst %/,%,$(if $(filter /%,$(1)),$(1),$(abspath .)/$(1)))))
-
-# Only a `*` is recognized, and at most one is allowed per component
-# of the wildcard path. Matching is guaranteed to fail if any
-# component of the wildcard path has more than one star and the
-# non-wildcard path has no stars in it.
-#
-# ARGS: wildcard_path, path
-WILDCARD_PATH_MATCH = $(and $(call WILDCARD_PATH_MATCH_1,$(dir $(1)),$(dir $(2))),$(filter $(subst *,%,$(subst %,\%,$(notdir $(1)))),$(notdir $(2))))
-WILDCARD_PATH_MATCH_1 = $(if $(filter-out / ./,$(1) $(2)),$(if $(filter / ./,$(1) $(2)),,$(call WILDCARD_PATH_MATCH,$(patsubst %/,%,$(1)),$(patsubst %/,%,$(2)))),$(filter // ././,$(1)$(2)))
-
-# ARGS: wildcard_paths, paths
-WILDCARD_PATHS_FILTER_OUT = $(foreach x,$(2),$(if $(strip $(foreach y,$(1),$(call WILDCARD_PATH_MATCH,$(y),$(x)))),,$(x)))
-
-# Escape space, tab, and the following 21 characters using backslashes: !"#$&'()*;<>?[\]`{|}~
-SHELL_ESCAPE = $(shell printf '%s\n' '$(call SHELL_ESCAPE_1,$(1))' | sed $(SHELL_ESCAPE_2))
-SHELL_ESCAPE_1 = $(subst $(APOSTROPHE),$(APOSTROPHE)\$(APOSTROPHE)$(APOSTROPHE),$(1))
-SHELL_ESCAPE_2 = 's/\([]$(TAB)$(SPACE)!"\#$$&'\''()*;<>?[\`{|}~]\)/\\\1/g'
-
-HAVE_CMD = $(shell which $(word 1,$(1)))
-
-# ARGS: command, prefix_to_class_map
-# Returns empty if identification fails
-IDENT_CMD = $(call IDENT_CMD_1,$(notdir $(word 1,$(1))),$(2))
-IDENT_CMD_1 = $(word 1,$(foreach x,$(2),$(call IDENT_CMD_2,$(1),$(subst :,$(SPACE),$(x)))))
-IDENT_CMD_2 = $(call IDENT_CMD_3,$(1),$(word 1,$(2)),$(word 2,$(2)))
-IDENT_CMD_3 = $(if $(call IS_PREFIX_OF,$(2)-,$(1)-),$(3))
-
-# ARGS: command, subsitutions
-# Returns empty if mapping fails
-MAP_CMD = $(call MAP_CMD_1,$(word 1,$(1)),$(wordlist 2,$(words $(1)),$(1)),$(2))
-MAP_CMD_1 = $(call MAP_CMD_2,$(if $(findstring /,$(1)),$(dir $(1))),$(notdir $(1)),$(2),$(3))
-MAP_CMD_2 = $(call MAP_CMD_3,$(1),$(word 1,$(foreach x,$(4),$(call MAP_CMD_4,$(x),$(2)))),$(3))
-MAP_CMD_3 = $(if $(2),$(call LIST_CONCAT,$(1)$(2),$(3)))
-MAP_CMD_4 = $(call MAP_CMD_5,$(subst :,$(SPACE),$(1)),$(2))
-MAP_CMD_5 = $(call MAP_CMD_6,-$(word 1,$(1))-,-$(word 2,$(1))-,-$(2)-)
-MAP_CMD_6 = $(if $(findstring $(1),$(3)),$(call MAP_CMD_7,$(patsubst -%-,%,$(subst $(1),$(2),$(3)))))
-MAP_CMD_7 = $(if $(call HAVE_CMD,$(1)),$(1))
-
-CAT_OPT_FILE = $(shell cat $(1) 2>/dev/null)
-
-# Library for non-negative integer arithmetic.
-#
-# Note: It is an error if a numeric (unencoded) argument is greater
-# than 65536.
-#
-# This implementation is an adaptation of John Graham-Cumming's work at
-# http://www.cmcrossroads.com/article/learning-gnu-make-functions-arithmetic
-INT_ADD = $(call INT_DEC,$(call INT_ADD_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_SUB = $(call INT_DEC,$(call INT_SUB_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_MUL = $(call INT_DEC,$(call INT_MUL_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_DIV = $(call INT_DEC,$(call INT_DIV_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_MAX = $(call INT_DEC,$(call INT_MAX_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_MIN = $(call INT_DEC,$(call INT_MIN_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_EQ  = $(call INT_EQ_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_NE  = $(call INT_NE_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_GT  = $(call INT_GT_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_LT  = $(call INT_LT_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_GTE = $(call INT_GTE_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_LTE = $(call INT_LTE_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_ADD_E = $(1) $(2)
-INT_SUB_E = $(if $(call INT_GTE_E,$(1),$(2)),$(filter-out xx,$(join $(1),$(2))),$(error Subtraction underflow))
-INT_MUL_E = $(foreach a,$(1),$(2))
-INT_DIV_E = $(if $(filter-out $(words $(2)),0),$(call INT_DIV_2,$(1),$(2)),$(error Division by zero))
-INT_DIV_2 = $(if $(call INT_GTE_E,$(1),$(2)),x $(call INT_DIV_2,$(call INT_SUB_E,$(1),$(2)),$(2)))
-INT_MAX_E = $(subst xx,x,$(join $(1),$(2)))
-INT_MIN_E = $(subst xx,x,$(filter xx,$(join $(1),$(2))))
-INT_EQ_E  = $(filter $(words $(1)),$(words $(2)))
-INT_NE_E  = $(filter-out $(words $(1)),$(words $(2)))
-INT_GT_E  = $(filter-out $(words $(2)),$(words $(call INT_MAX_E,$(1),$(2))))
-INT_LT_E  = $(filter-out $(words $(1)),$(words $(call INT_MAX_E,$(1),$(2))))
-INT_GTE_E = $(call INT_GT_E,$(1),$(2))$(call INT_EQ_E,$(1),$(2))
-INT_LTE_E = $(call INT_LT_E,$(1),$(2))$(call INT_EQ_E,$(1),$(2))
-# More efficient increment / decrement
-INT_INC_E = $(1) x
-INT_DEC_E = $(wordlist 2,$(words $(1)),$(1))
-# More efficient double / halve
-INT_DBL_E = $(1) $(1)
-INT_HLV_E = $(subst xx,x,$(filter-out xy x y,$(join $(1),$(foreach a,$(1),y x))))
-# Encode / decode
-INT_DEC = $(words $(1))
-INT_ENC = $(wordlist 1,$(1),$(INT_65536))
-INT_16    := x x x x x x x x x x x x x x x
-INT_65536 := $(foreach a,$(INT_16),$(foreach b,$(INT_16),$(foreach c,$(INT_16),$(INT_16))))
-
-
-
-# PLATFORM SPECIFICS
-
-OS := $(shell uname)
-ARCH := $(shell uname -m)
-
-ifeq ($(OS),Darwin)
-  LIB_SUFFIX_SHARED = .dylib
-endif
-
-USE_LIB64 =
-ifeq ($(OS),Linux)
-  IS_64BIT = $(filter x86_64 ia64,$(ARCH))
-  ifneq ($(IS_64BIT),)
-    ifeq ($(shell [ -e /etc/redhat-release -o -e /etc/SuSE-release ] && echo yes),yes)
-      USE_LIB64 = 1
-    else ifneq ($(shell [ -e /etc/system-release ] && grep Amazon /etc/system-release),)
-      USE_LIB64 = 1
-    endif
-  endif
-endif
-
-
-
-# SETUP A GCC-LIKE TOOL CHAIN IF POSSIBLE
-
-# If CC is not specified, search PATH for these compilers in the
-# specified order.
-ifeq ($(OS),Darwin)
-  COMPILER_DETECT_LIST = clang llvm-gcc gcc
-else
-  COMPILER_DETECT_LIST = gcc clang
-endif
-
-# Compiler identification. Maps command prefix to compiler class.
-COMPILER_IDENT_MAP = gcc:gcc g++:gcc llvm-gcc:gcc llvm-g++:gcc clang:clang clang++:clang
-
-# Compiler classes that are mostly like GCC.
-GCC_LIKE_COMPILERS = gcc clang
-
-# How to map C compiler to corresponding C++ linker.
-CC_TO_CXXL_MAP = gcc:g++ g++:g++ clang:clang++ clang++:clang++
-
-# How to map C compiler to corresponding archiver (static libraries).
-CC_TO_AR_MAP  = gcc:gcc-ar g++:gcc-ar gcc:ar g++:ar clang:clang-ar clang++:clang-ar clang:ar clang++:ar
-
-DETECT_COMPILER = $(call FIND,HAVE_CMD,$(COMPILER_DETECT_LIST))
-IDENT_COMPILER = $(call IDENT_CMD,$(1),$(COMPILER_IDENT_MAP))
-CLASS_IS_GCC_LIKE = $(if $(filter $(GCC_LIKE_COMPILERS),$(1)),yes)
-
-# C compiler
-CC_SPECIFIED := $(filter-out undefined default,$(origin CC))
-ifeq ($(CC_SPECIFIED),)
-  # CC was not specified
-  X := $(call DETECT_COMPILER)
-  ifneq ($(X),)
-    CC := $(X)
-  endif
-endif
-CC_IS := $(call IDENT_COMPILER,$(CC))
-CC_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(CC_IS))
-
-# C++ compiler
-CXX_SPECIFIED := $(filter-out undefined default,$(origin CXX))
-ifeq ($(CXX_SPECIFIED),)
-  # CXX was not specified
-  CXX := $(CC)
-  CXX_IS := $(CC_IS)
-  CXX_IS_GCC_LIKE := $(CC_IS_GCC_LIKE)
-else
-  CXX_IS := $(call IDENT_COMPILER,$(CXX))
-  CXX_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(CXX_IS))
-endif
-
-# Objective-C compiler
-OCC_SPECIFIED := $(filter-out undefined default,$(origin OCC))
-ifeq ($(OCC_SPECIFIED),)
-  # OCC was not specified
-  OCC := $(CC)
-  OCC_IS := $(CC_IS)
-  OCC_IS_GCC_LIKE := $(CC_IS_GCC_LIKE)
-else
-  OCC_IS := $(call IDENT_COMPILER,$(OCC))
-  OCC_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(OCC_IS))
-endif
-
-# Objective-C++ compiler
-OCXX_SPECIFIED := $(filter-out undefined default,$(origin OCXX))
-ifeq ($(OCXX_SPECIFIED),)
-  # OCXX was not specified
-  OCXX := $(OCC)
-  OCXX_IS := $(OCC_IS)
-  OCXX_IS_GCC_LIKE := $(OCC_IS_GCC_LIKE)
-else
-  OCXX_IS := $(call IDENT_COMPILER,$(OCXX))
-  OCXX_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(OCXX_IS))
-endif
-
-COMPILER_IS = $(if $(word 2,$(call REMOVE_DUPES,x$(CC_IS) x$(CXX_IS) x$(OCC_IS) x$(OCXX_IS))),,$(CC_IS))
-COMPILER_IS_GCC_LIKE := $(and $(CC_IS_GCC_LIKE),$(CXX_IS_GCC_LIKE),$(OCC_IS_GCC_LIKE),$(OCXX_IS_GCC_LIKE))
-
-ifneq ($(COMPILER_IS_GCC_LIKE),)
-  CFLAGS_OPTIM   = -O3 -DNDEBUG
-  CFLAGS_DEBUG   = -ggdb
-  CFLAGS_COVER   = --coverage
-  CFLAGS_SHARED  = -fPIC -DPIC
-  CFLAGS_GENERAL = -Wall
-  CFLAGS_AUTODEP = -MMD -MP
-endif
-
-# Linker
-X := $(EMPTY)
-LD_SPECIFIED = $(filter-out undefined default,$(origin LD))
-ifeq ($(LD_SPECIFIED),)
-  # LD was not specified
-  ifneq ($(CC_IS_GCC_LIKE),)
-    X := $(call MAP_CMD,$(CC),$(CC_TO_CXXL_MAP))
-    ifneq ($(X),)
-      LD := $(X)
-      LD_IS := $(CC_IS)
-      LD_IS_GCC_LIKE := yes
-    endif
-  endif
-endif
-ifeq ($(X),)
-  LD_IS := $(call IDENT_COMPILER,$(LD))
-  LD_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(LD_IS))
-endif
-ifneq ($(LD_IS_GCC_LIKE),)
-  LDFLAGS_SHARED = -shared
-endif
-
-# Archiver (static libraries)
-AR_SPECIFIED = $(filter-out undefined default,$(origin AR))
-ifeq ($(AR_SPECIFIED),)
-  # AR was not specified
-  ifneq ($(CC_IS_GCC_LIKE),)
-    X := $(call MAP_CMD,$(CC),$(CC_TO_AR_MAP))
-    ifneq ($(X),)
-      AR := $(X)
-    endif
-  endif
-endif
-
-
-
-# LOAD PROJECT SPECIFIC CONFIGURATION
-
-EXTRA_CFLAGS  =
-EXTRA_LDFLAGS =
-
-GENERIC_MK := $(lastword $(MAKEFILE_LIST))
-GENERIC_MK_DIR := $(patsubst %/,%,$(dir $(GENERIC_MK)))
-PROJECT_MK := $(GENERIC_MK_DIR)/project.mk
-DEP_MAKEFILES := Makefile $(GENERIC_MK)
-ifneq ($(wildcard $(PROJECT_MK)),)
-  DEP_MAKEFILES += $(PROJECT_MK)
-  include $(PROJECT_MK)
-endif
-
-ifneq ($(INCLUDE_ROOT),)
-  REL_INCLUDE_ROOT := $(call MAKE_REL_PATH,$(dir $(GENERIC_MK))/$(INCLUDE_ROOT))
-endif
-
-ROOT_INC_FLAG := $(EMPTY)
-ROOT_INC_FLAG_COVER := $(EMPTY)
-ifneq ($(REL_INCLUDE_ROOT),)
-  ROOT_INC_FLAG += -I$(REL_INCLUDE_ROOT)
-  ROOT_INC_FLAG_COVER += -I$(call MAKE_ABS_PATH,$(REL_INCLUDE_ROOT))
-endif
-
-
-
-# SETUP BUILD COMMANDS
-
-CFLAGS_SPECIFIED  := $(filter-out undefined default,$(origin CFLAGS))
-LDFLAGS_SPECIFIED := $(filter-out undefined default,$(origin LDFLAGS))
-ARFLAGS_SPECIFIED := $(filter-out undefined default,$(origin ARFLAGS))
-ifneq ($(CFLAGS_SPECIFIED),)
-CFLAGS_GENERAL = $(CFLAGS)
-endif
-ifneq ($(LDFLAGS_SPECIFIED),)
-LDFLAGS_GENERAL = $(LDFLAGS)
-endif
-ifneq ($(ARFLAGS_SPECIFIED),)
-ARFLAGS_GENERAL = $(ARFLAGS)
-endif
-CFLAGS_GENERAL  += $(EXTRA_CFLAGS)
-LDFLAGS_GENERAL += $(EXTRA_LDFLAGS)
-
-CC_STATIC_OPTIM   = $(CC) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_SHARED_OPTIM   = $(CC) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_STATIC_DEBUG   = $(CC) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_SHARED_DEBUG   = $(CC) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_STATIC_COVER   = $(CC) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-CC_SHARED_COVER   = $(CC) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-CXX_STATIC_OPTIM  = $(CXX) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_SHARED_OPTIM  = $(CXX) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_STATIC_DEBUG  = $(CXX) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_SHARED_DEBUG  = $(CXX) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_STATIC_COVER  = $(CXX) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-CXX_SHARED_COVER  = $(CXX) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-OCC_STATIC_OPTIM  = $(OCC) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_SHARED_OPTIM  = $(OCC) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_STATIC_DEBUG  = $(OCC) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_SHARED_DEBUG  = $(OCC) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_STATIC_COVER  = $(OCC) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-OCC_SHARED_COVER  = $(OCC) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-OCXX_STATIC_OPTIM = $(OCXX) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_SHARED_OPTIM = $(OCXX) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_STATIC_DEBUG = $(OCXX) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_SHARED_DEBUG = $(OCXX) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_STATIC_COVER = $(OCXX) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-OCXX_SHARED_COVER = $(OCXX) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-CFLAGS_OTHER = $(CFLAGS_ARCH) $(CFLAGS_INCLUDE) $(CFLAGS_AUTODEP)
-
-LD_LIB_OPTIM      = $(LD) $(LDFLAGS_SHARED) $(LDFLAGS_OPTIM) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_LIB_DEBUG      = $(LD) $(LDFLAGS_SHARED) $(LDFLAGS_DEBUG) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_LIB_COVER      = $(LD) $(LDFLAGS_SHARED) $(LDFLAGS_COVER) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_PROG_OPTIM     = $(LD) $(LDFLAGS_OPTIM) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_PROG_DEBUG     = $(LD) $(LDFLAGS_DEBUG) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_PROG_COVER     = $(LD) $(LDFLAGS_COVER) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-
-
-
-BASE_DENOM_2            := $(if $(BASE_DENOM),-$(BASE_DENOM))
-SUFFIX_OBJ_STATIC_OPTIM := $(BASE_DENOM_2)$(OBJ_DENOM_OPTIM).o
-SUFFIX_OBJ_SHARED_OPTIM := $(BASE_DENOM_2)$(OBJ_DENOM_OPTIM)$(OBJ_DENOM_SHARED).o
-SUFFIX_OBJ_STATIC_DEBUG := $(BASE_DENOM_2)$(OBJ_DENOM_DEBUG).o
-SUFFIX_OBJ_SHARED_DEBUG := $(BASE_DENOM_2)$(OBJ_DENOM_DEBUG)$(OBJ_DENOM_SHARED).o
-SUFFIX_OBJ_STATIC_COVER := $(BASE_DENOM_2)$(OBJ_DENOM_COVER).o
-SUFFIX_OBJ_SHARED_COVER := $(BASE_DENOM_2)$(OBJ_DENOM_COVER)$(OBJ_DENOM_SHARED).o
-SUFFIX_LIB_STATIC_OPTIM := $(BASE_DENOM_2)$(LIB_DENOM_OPTIM)$(LIB_SUFFIX_STATIC)
-SUFFIX_LIB_SHARED_OPTIM := $(BASE_DENOM_2)$(LIB_DENOM_OPTIM)$(LIB_SUFFIX_SHARED)
-SUFFIX_LIB_STATIC_DEBUG := $(BASE_DENOM_2)$(LIB_DENOM_DEBUG)$(LIB_SUFFIX_STATIC)
-SUFFIX_LIB_SHARED_DEBUG := $(BASE_DENOM_2)$(LIB_DENOM_DEBUG)$(LIB_SUFFIX_SHARED)
-SUFFIX_LIB_STATIC_COVER := $(BASE_DENOM_2)$(LIB_DENOM_COVER)$(LIB_SUFFIX_STATIC)
-SUFFIX_LIB_SHARED_COVER := $(BASE_DENOM_2)$(LIB_DENOM_COVER)$(LIB_SUFFIX_SHARED)
-SUFFIX_PROG_OPTIM       := $(BASE_DENOM_2)$(PROG_DENOM_OPTIM)$(PROG_SUFFIX)
-SUFFIX_PROG_DEBUG       := $(BASE_DENOM_2)$(PROG_DENOM_DEBUG)$(PROG_SUFFIX)
-SUFFIX_PROG_COVER       := $(BASE_DENOM_2)$(PROG_DENOM_COVER)$(PROG_SUFFIX)
-
-GET_FLAGS = $($(1)) $($(1)_$(2))
-FOLD_TARGET = $(subst /,_,$(subst .,_,$(subst -,_,$(1))))
-GET_LIBRARY_STEM         = $(patsubst %.a,%,$(1))
-GET_OBJECTS_FOR_TARGET   = $(addsuffix $(2),$(basename $($(call FOLD_TARGET,$(1))_SOURCES)))
-GET_LDFLAGS_FOR_TARGET   = $(foreach x,PROJECT DIR $(call FOLD_TARGET,$(1)),$(call GET_FLAGS,$(x)_LDFLAGS,$(2)))
-GET_DEPS_FOR_TARGET      = $($(call FOLD_TARGET,$(1))_DEPS)
-GET_LIBRARY_VERSION      = $(call GET_LIBRARY_VERSION_2,$(strip $($(call FOLD_TARGET,$(1))_VERSION)))
-GET_LIBRARY_VERSION_2    = $(if $(1),$(wordlist 1,3,$(subst :, ,$(1):0:0)))
-
-PRIMARIES := HEADERS LIBRARIES PROGRAMS
-PRIMARY_PREFIXES := bin sbin lib libexec include
-INCLUDE_SUBDIR :=
-
-USING_SUBINCLUDE := $(strip $(foreach x,$(PRIMARIES) $(PRIMARIES)_EXTRA_UNINSTALL,$(subinclude_$(x))$(nobase_subinclude_$(x))))
-ifneq ($(USING_SUBINCLUDE),)
-ifeq ($(REL_INCLUDE_ROOT),)
-$(error Cannot determine installation directory for `subinclude` when `INCLUDE_ROOT` is unspecified)
-endif
-INSIDE_INCLUDE_ROOT := $(or $(call IS_SAME_PATH_AS,.,$(REL_INCLUDE_ROOT)),$(call IS_PATH_CONTAINED_IN,.,$(REL_INCLUDE_ROOT)))
-ifeq ($(INSIDE_INCLUDE_ROOT),)
-$(error Cannot determine installation directory for `subinclude` from outside `INCLUDE_ROOT`)
-endif
-PRIMARY_PREFIXES += subinclude
-INCLUDE_SUBDIR := $(call PATH_DIFF,.,$(REL_INCLUDE_ROOT))
-endif
-
-PRIMARY_PREFIXES += $(EXTRA_PRIMARY_PREFIXES)
-
-# ARGS: primary_prefix
-GET_INSTALL_DIR = $(if $(filter subinclude,$(1)),$(call GET_ROOT_INSTALL_DIR,include)$(call COND_PREPEND,/,$(INCLUDE_SUBDIR)),$(call GET_ROOT_INSTALL_DIR,$(1)))
-GET_ROOT_INSTALL_DIR = $(if $($(1)dir),$(patsubst %/,%,$($(1)dir)),$(error Variable `$(1)dir` was not specified))
-
-# ARGS: folded_lib_target, install_dir
-define RECORD_LIB_INSTALL_DIR
-GMK_INSTALL_DIR_$(1) = $(2)
-endef
-
-# ARGS: primary_prefix, install_dir
-RECORD_LIB_INSTALL_DIRS = \
-$(foreach x,$($(1)_LIBRARIES),$(eval $(call RECORD_LIB_INSTALL_DIR,$(call FOLD_TARGET,$(x)),$(2))))\
-$(foreach x,$(nobase_$(1)_LIBRARIES),$(eval $(call RECORD_LIB_INSTALL_DIR,$(call FOLD_TARGET,$(x)),$(patsubst %/,%,$(dir $(2)/$(x))))))
-
-$(foreach x,$(PRIMARY_PREFIXES),$(call RECORD_LIB_INSTALL_DIRS,$(x),$(call GET_INSTALL_DIR,$(x))))
-
-# ARGS: installable_lib_target
-GET_INSTALL_DIR_FOR_LIB_TARGET = $(value GMK_INSTALL_DIR_$(call FOLD_TARGET,$(1)))
-
-INST_PROGRAMS  := $(strip $(foreach x,$(PRIMARY_PREFIXES),$($(x)_PROGRAMS)  $(nobase_$(x)_PROGRAMS)))
-INST_LIBRARIES := $(strip $(foreach x,$(PRIMARY_PREFIXES),$($(x)_LIBRARIES) $(nobase_$(x)_LIBRARIES)))
-
-LIBRARIES := $(INST_LIBRARIES) $(noinst_LIBRARIES) $(check_LIBRARIES)
-PROGRAMS  := $(INST_PROGRAMS) $(DEV_PROGRAMS) $(noinst_PROGRAMS) $(check_PROGRAMS)
-
-SOURCE_DIRS := $(patsubst ././,./,$(patsubst %,./%,$(call REMOVE_DUPES,$(dir $(foreach x,$(LIBRARIES) $(PROGRAMS),$($(call FOLD_TARGET,$(x))_SOURCES))))))
-
-OBJECTS_STATIC_OPTIM := $(foreach x,$(LIBRARIES) $(PROGRAMS),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_STATIC_OPTIM)))
-OBJECTS_SHARED_OPTIM := $(foreach x,$(LIBRARIES),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_SHARED_OPTIM)))
-OBJECTS_STATIC_DEBUG := $(foreach x,$(LIBRARIES) $(PROGRAMS),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_STATIC_DEBUG)))
-OBJECTS_SHARED_DEBUG := $(foreach x,$(LIBRARIES),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_SHARED_DEBUG)))
-OBJECTS_STATIC_COVER := $(foreach x,$(LIBRARIES) $(PROGRAMS),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_STATIC_COVER)))
-OBJECTS_SHARED_COVER := $(foreach x,$(LIBRARIES),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_SHARED_COVER)))
-OBJECTS := $(sort $(OBJECTS_STATIC_OPTIM) $(OBJECTS_SHARED_OPTIM) $(OBJECTS_STATIC_DEBUG) $(OBJECTS_SHARED_DEBUG) $(OBJECTS_STATIC_COVER) $(OBJECTS_SHARED_COVER))
-
-TARGETS_LIB_STATIC_OPTIM   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_OPTIM))
-TARGETS_LIB_SHARED_OPTIM   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_SHARED_OPTIM))
-TARGETS_LIB_STATIC_DEBUG   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_DEBUG))
-TARGETS_LIB_SHARED_DEBUG   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_SHARED_DEBUG))
-TARGETS_LIB_STATIC_COVER   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_COVER))
-TARGETS_LIB_SHARED_COVER   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_SHARED_COVER))
-TARGETS_INST_LIB_LIBDEPS   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS))
-TARGETS_NOINST_LIB_OPTIM   := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_OPTIM))
-TARGETS_NOINST_LIB_DEBUG   := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_DEBUG))
-TARGETS_NOINST_LIB_COVER   := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_COVER))
-TARGETS_NOINST_LIB_LIBDEPS := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS))
-TARGETS_CHECK_LIB_OPTIM     := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_OPTIM))
-TARGETS_CHECK_LIB_DEBUG     := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_DEBUG))
-TARGETS_CHECK_LIB_COVER     := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_COVER))
-TARGETS_CHECK_LIB_LIBDEPS   := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS))
-TARGETS_PROG_OPTIM         := $(foreach x,$(INST_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_PROG_DEBUG         := $(foreach x,$(INST_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_PROG_COVER         := $(foreach x,$(INST_PROGRAMS),$(x)$(SUFFIX_PROG_COVER))
-TARGETS_DEV_PROG_OPTIM     := $(foreach x,$(DEV_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_DEV_PROG_DEBUG     := $(foreach x,$(DEV_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_NOINST_PROG_OPTIM  := $(foreach x,$(noinst_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_NOINST_PROG_DEBUG  := $(foreach x,$(noinst_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_NOINST_PROG_COVER  := $(foreach x,$(noinst_PROGRAMS),$(x)$(SUFFIX_PROG_COVER))
-TARGETS_CHECK_PROG_OPTIM    := $(foreach x,$(check_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_CHECK_PROG_DEBUG    := $(foreach x,$(check_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_CHECK_PROG_COVER    := $(foreach x,$(check_PROGRAMS),$(x)$(SUFFIX_PROG_COVER))
-
-TARGETS_BUILD :=
-ifneq ($(ENABLE_INSTALL_STATIC_LIBS),)
-TARGETS_BUILD += $(TARGETS_LIB_STATIC_OPTIM)
-endif
-TARGETS_BUILD += $(TARGETS_LIB_SHARED_OPTIM)
-ifneq ($(or $(ENABLE_INSTALL_DEBUG_LIBS),$(ENABLE_INSTALL_DEBUG_PROGS)),)
-TARGETS_BUILD += $(TARGETS_LIB_SHARED_DEBUG)
-endif
-TARGETS_BUILD += $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_BUILD += $(TARGETS_NOINST_LIB_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_PROGS),)
-TARGETS_BUILD += $(TARGETS_NOINST_LIB_DEBUG)
-endif
-TARGETS_BUILD += $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_BUILD += $(TARGETS_PROG_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_PROGS),)
-TARGETS_BUILD += $(TARGETS_PROG_DEBUG)
-endif
-TARGETS_BUILD += $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_DEV_PROG_DEBUG) $(TARGETS_NOINST_PROG_OPTIM)
-
-TARGETS_RELEASE     := $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_RELEASE     += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_RELEASE     += $(TARGETS_PROG_OPTIM) $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_NOINST_PROG_OPTIM)
-TARGETS_NODEBUG     := $(TARGETS_LIB_STATIC_OPTIM) $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_NODEBUG     += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_NODEBUG     += $(TARGETS_PROG_OPTIM) $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_NOINST_PROG_OPTIM)
-TARGETS_DEBUG       := $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_DEBUG       += $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_DEBUG       += $(TARGETS_PROG_DEBUG) $(TARGETS_DEV_PROG_DEBUG) $(TARGETS_NOINST_PROG_DEBUG)
-TARGETS_COVER       := $(TARGETS_LIB_SHARED_COVER) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_COVER       += $(TARGETS_NOINST_LIB_COVER) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_COVER       += $(TARGETS_PROG_COVER) $(TARGETS_NOINST_PROG_COVER)
-TARGETS_CHECK       := $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_CHECK       += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_CHECK       += $(TARGETS_CHECK_LIB_OPTIM) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_CHECK       += $(TARGETS_PROG_OPTIM) $(TARGETS_CHECK_PROG_OPTIM)
-TARGETS_CHECK_DEBUG := $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_CHECK_DEBUG += $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_CHECK_DEBUG += $(TARGETS_CHECK_LIB_DEBUG) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_CHECK_DEBUG += $(TARGETS_PROG_DEBUG) $(TARGETS_CHECK_PROG_DEBUG)
-TARGETS_CHECK_COVER := $(TARGETS_LIB_SHARED_COVER) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_CHECK_COVER += $(TARGETS_NOINST_LIB_COVER) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_CHECK_COVER += $(TARGETS_CHECK_LIB_COVER) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_CHECK_COVER += $(TARGETS_PROG_COVER) $(TARGETS_CHECK_PROG_COVER)
-
-TARGETS_EVERYTHING := $(TARGETS_LIB_STATIC_OPTIM) $(TARGETS_LIB_SHARED_OPTIM)
-TARGETS_EVERYTHING += $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_EVERYTHING += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_EVERYTHING += $(TARGETS_CHECK_LIB_OPTIM) $(TARGETS_CHECK_LIB_DEBUG) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_EVERYTHING += $(TARGETS_PROG_OPTIM) $(TARGETS_PROG_DEBUG)
-TARGETS_EVERYTHING += $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_DEV_PROG_DEBUG)
-TARGETS_EVERYTHING += $(TARGETS_NOINST_PROG_OPTIM) $(TARGETS_NOINST_PROG_DEBUG)
-TARGETS_EVERYTHING += $(TARGETS_CHECK_PROG_OPTIM) $(TARGETS_CHECK_PROG_DEBUG)
-
-TARGETS_LIB_STATIC  := $(TARGETS_LIB_STATIC_OPTIM) $(TARGETS_LIB_STATIC_DEBUG) $(TARGETS_LIB_STATIC_COVER)
-TARGETS_LIB_SHARED  := $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_LIB_SHARED_COVER)
-TARGETS_NOINST_LIB  := $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_COVER)
-TARGETS_CHECK_LIB   := $(TARGETS_CHECK_LIB_OPTIM) $(TARGETS_CHECK_LIB_DEBUG) $(TARGETS_CHECK_LIB_COVER)
-TARGETS_PROG        := $(TARGETS_PROG_OPTIM) $(TARGETS_PROG_DEBUG) $(TARGETS_PROG_COVER)
-TARGETS_DEV_PROG    := $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_DEV_PROG_DEBUG)
-TARGETS_NOINST_PROG := $(TARGETS_NOINST_PROG_OPTIM) $(TARGETS_NOINST_PROG_DEBUG) $(TARGETS_NOINST_PROG_COVER)
-TARGETS_CHECK_PROG  := $(TARGETS_CHECK_PROG_OPTIM) $(TARGETS_CHECK_PROG_DEBUG) $(TARGETS_CHECK_PROG_COVER)
-TARGETS_PROG_ALL    := $(foreach x,$(TARGETS_PROG) $(TARGETS_DEV_PROG),$(x) $(x)-noinst) $(TARGETS_NOINST_PROG) $(TARGETS_CHECK_PROG)
-
-# ARGS: real_local_path, version
-GET_SHARED_LIB_ALIASES = $(1)
-
-ifeq ($(OS),Linux)
-
-GET_SHARED_LIB_ALIASES   = $(if $(2),$(call GET_SHARED_LIB_ALIASES_2,$(1),$(call MAP_SHARED_LIB_VERSION,$(2))),$(1))
-GET_SHARED_LIB_ALIASES_2 = $(1) $(1).$(word 1,$(2)) $(1).$(word 2,$(2))
-
-MAP_SHARED_LIB_VERSION   = $(call MAP_SHARED_LIB_VERSION_2,$(word 1,$(1)),$(word 2,$(1)),$(word 3,$(1)))
-MAP_SHARED_LIB_VERSION_2 = $(call MAP_SHARED_LIB_VERSION_3,$(call INT_SUB,$(1),$(3)),$(3),$(2))
-MAP_SHARED_LIB_VERSION_3 = $(1) $(1).$(2).$(3)
-
-endif
-
-ifeq ($(OS),Darwin)
-
-GET_SHARED_LIB_ALIASES = $(if $(2),$(1) $(word 1,$(call MAP_SHARED_LIB_VERSION,$(1),$(2))),$(1))
-
-MAP_SHARED_LIB_VERSION   = $(call MAP_SHARED_LIB_VERSION_2,$(1),$(word 1,$(2)),$(word 2,$(2)),$(word 3,$(2)))
-MAP_SHARED_LIB_VERSION_2 = $(call MAP_SHARED_LIB_VERSION_3,$(1),$(call INT_SUB,$(2),$(4)),$(call INT_ADD,$(2),1),$(3))
-MAP_SHARED_LIB_VERSION_3 = $(patsubst %.dylib,%,$(1)).$(2).dylib $(3) $(3).$(4)
-
-endif
-
-TARGETS_LIB_SHARED_ALIASES = $(foreach x,$(INST_LIBRARIES),$(foreach y,OPTIM DEBUG COVER,$(call TARGETS_LIB_SHARED_ALIASES_1,$(x),$(SUFFIX_LIB_SHARED_$(y)))))
-TARGETS_LIB_SHARED_ALIASES_1 = $(call GET_SHARED_LIB_ALIASES,$(call GET_LIBRARY_STEM,$(1))$(2),$(call GET_LIBRARY_VERSION,$(1)))
-
-TARGETS := $(TARGETS_LIB_STATIC) $(TARGETS_LIB_SHARED_ALIASES) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS += $(TARGETS_NOINST_LIB) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS += $(TARGETS_CHECK_LIB) $(TARGETS_CHECK_LIB_LIBDEPS) $(TARGETS_PROG_ALL)
-
-RECURSIVE_GOALS = build release nodebug debug cover everything clean install-only uninstall \
-check-norun check-debug-norun check-cover-norun check check-debug check-cover memcheck memcheck-debug
-
-.DEFAULT_GOAL :=
-
-.PHONY: all
-all: build
-
-build/local:             $(TARGETS_BUILD)
-release/local:           $(TARGETS_RELEASE)
-nodebug/local:           $(TARGETS_NODEBUG)
-debug/local:             $(TARGETS_DEBUG)
-cover/local:             $(TARGETS_COVER)
-everything/local:        $(TARGETS_EVERYTHING)
-check-norun/local:       $(TARGETS_CHECK)
-check-debug-norun/local: $(TARGETS_CHECK_DEBUG)
-check-cover-norun/local: $(TARGETS_CHECK_COVER)
-
-
-# Update everything if any makefile or any generated source has changed
-$(GENERATED_SOURCES) $(OBJECTS) $(TARGETS): $(DEP_MAKEFILES)
-$(OBJECTS): $(GENERATED_SOURCES)
-
-# Disable all suffix rules and some interfering implicit pattern rules
-.SUFFIXES:
-%: %.o
-%: %.c
-%: %.cpp
-
-
-
-# SUBPROJECTS
-
-# ARGS: recursive_goal, subdirs_for_goal, subdir_deps_for_this_dir
-define RECURSIVE_GOAL_RULES
-.PHONY: $(1) $(1)/this-dir $(1)/local
-$(1): $(1)/this-dir $(patsubst %,$(1)/subdir/%,$(2))
-ifeq ($(strip $(3)),)
-$(1)/this-dir: $(1)/local
-else
-$(1)/this-dir:
-	@$$(MAKE) --no-print-directory $(1)/local
-endif
-endef
-
-# ARGS: recursive_goal, subdir_dep_for_this_dir
-define SUBDIR_DEP_FOR_THIS_DIR_RULE
-$(1)/this-dir: $(1)/subdir/$(2)
-endef
-
-# ARGS: recursive_goal, subdir
-define RECURSIVE_GOAL_SUBDIR_RULES
-.PHONY: $(1)/subdir/$(2)
-ifeq ($(1),build)
-$(1)/subdir/$(2):
-	@$$(MAKE) -w -C $(2)
-else
-$(1)/subdir/$(2):
-	@$$(MAKE) -w -C $(2) $(1)
-endif
-endef
-
-# ARGS: recursive_goal, subdir, dep
-define SUBDIR_DEP_RULE
-ifeq ($(3),.)
-$(1)/subdir/$(2): $(1)/this-dir
-else
-$(1)/subdir/$(2): $(1)/subdir/$(3)
-endif
-endef
-
-AVAIL_PASSIVE_SUBDIRS := $(foreach x,$(PASSIVE_SUBDIRS),$(if $(realpath $(x)),$(x)))
-
-# ARGS: recursive_goal
-GET_SUBDIRS_FOR_RECURSIVE_GOAL = $(if $(filter clean,$(1)),$(SUBDIRS) $(AVAIL_PASSIVE_SUBDIRS),$(SUBDIRS))
-
-# ARGS: recursive_goal
-GET_SUBDIR_DEPS_FOR_THIS_DIR = $(if $(filter clean install-only,$(1)),,$(if $(filter uninstall,$(1)),$(SUBDIRS),$(DIR_DEPS)))
-
-# ARGS: recursive_goal, subdir
-GET_SUBDIR_DEPS = $(if $(filter clean uninstall,$(1)),,$(if $(filter install-only,$(1)),.,$($(call FOLD_TARGET,$(2))_DEPS)))
-
-# ARGS: recursive_goal, subdir, deps
-EVAL_RECURSIVE_GOAL_SUBDIR_RULES = \
-$(eval $(call RECURSIVE_GOAL_SUBDIR_RULES,$(1),$(2)))\
-$(foreach x,$(call GET_SUBDIR_DEPS,$(1),$(2)),$(eval $(call SUBDIR_DEP_RULE,$(1),$(2),$(x))))
-
-# ARGS: recursive_goal, subdir_deps_for_this_dir
-EVAL_RECURSIVE_GOAL_RULES = \
-$(eval $(call RECURSIVE_GOAL_RULES,$(1),$(call GET_SUBDIRS_FOR_RECURSIVE_GOAL,$(1)),$(2)))\
-$(foreach x,$(2),$(eval $(call SUBDIR_DEP_FOR_THIS_DIR_RULE,$(1),$(x))))\
-$(foreach x,$(SUBDIRS) $(PASSIVE_SUBDIRS),$(call EVAL_RECURSIVE_GOAL_SUBDIR_RULES,$(1),$(x)))
-
-$(foreach x,$(RECURSIVE_GOALS),$(call EVAL_RECURSIVE_GOAL_RULES,$(x),$(call GET_SUBDIR_DEPS_FOR_THIS_DIR,$(x))))
-
-
-
-# CLEANING
-
-GET_CLEAN_FILES = $(strip $(call WILDCARD_PATHS_FILTER_OUT,$(EXTRA_CLEAN),$(foreach x,$(SOURCE_DIRS),$(foreach y,*.d *.o *.gcno *.gcda,$(patsubst ./%,%,$(x))$(y))) $(TARGETS)) $(EXTRA_CLEAN))
-
-ifneq ($(word 1,$(or $(SOURCE_DIRS),$(TARGETS),$(EXTRA_CLEAN))),)
-define CLEANING_RULES
-clean/local:
-	$$(RM) $$(call GET_CLEAN_FILES)
-endef
-$(eval $(CLEANING_RULES))
-endif
-
-
-
-# INSTALL / UNINSTALL
-
-.PHONY: install
-install: build
-	@$(MAKE) install-only
-
-HAS_STAR = $(call HAS_STAR_1,$(subst *,x$(SPACE)x,$(subst $(SPACE),x,$(1))))
-HAS_STAR_1 = $(wordlist 2,$(words $(1)),$(1))
-
-CHECK_WILDCARD = $(if $(call HAS_STAR,$(word 1,$(subst /,$(SPACE),$(1)))),$(error For your safety, uninstallation wildcards are not allowed to appear at the root level of the target installation directory [$(1)]))
-CHECK_WILDCARDS = $(foreach x,$(PRIMARIES),$(foreach y,$(notdir $($(1)_$(x)_EXTRA_UNINSTALL)) $(nobase_$(1)_$(x)_EXTRA_UNINSTALL),$(call CHECK_WILDCARD,$(2)$(y))))
-$(foreach x,$(PRIMARY_PREFIXES),$(call CHECK_WILDCARDS,$(x),$(if $(filter subinclude,$(x)),$(call COND_APPEND,$(INCLUDE_SUBDIR),/))))
-
-DESTDIR_2 := $(call SHELL_ESCAPE,$(call UNHIDE_SPACE,$(patsubst %/,%,$(call HIDE_SPACE,$(value DESTDIR)))))
-
-# ARGS: install_dir, real_local_paths
-INSTALL_RECIPE_FILES   = $(NL_TAB)$$(INSTALL_DATA) $(2) $$(DESTDIR_2)$(1)
-UNINSTALL_RECIPE_FILES = $(NL_TAB)$$(RM) $(foreach x,$(2),$$(DESTDIR_2)$(1)/$(x))
-
-# ARGS: install_dir, real_local_paths
-INSTALL_RECIPE_LIBS = $(NL_TAB)$$(INSTALL_LIBRARY) $(2) $$(DESTDIR_2)$(1)
-
-# ARGS: real_local_path, version
-INSTALL_FILES_VERSIONED_LIB = $(1)
-
-# ARGS: install_dir, real_local_path, version
-INSTALL_RECIPE_VERSIONED_LIB = $(INSTALL_RECIPE_LIBS)
-
-ifeq ($(OS),Linux)
-INSTALL_FILES_VERSIONED_LIB    = $(if $(2),$(call INSTALL_FILES_VERSIONED_LIB_1,$(1),$(call MAP_SHARED_LIB_VERSION,$(2))),$(1))
-INSTALL_FILES_VERSIONED_LIB_1  = $(1) $(1).$(word 1,$(2)) $(1).$(word 2,$(2))
-INSTALL_RECIPE_VERSIONED_LIB   = $(if $(3),$(call INSTALL_RECIPE_VERSIONED_LIB_1,$(1),$(2),$(call MAP_SHARED_LIB_VERSION,$(3))),$(INSTALL_RECIPE_LIBS))
-INSTALL_RECIPE_VERSIONED_LIB_1 = $(call INSTALL_RECIPE_VERSIONED_LIB_2,$(1),$(2),$(2).$(word 1,$(3)),$(2).$(word 2,$(3)))
-INSTALL_RECIPE_VERSIONED_LIB_2 = $(call INSTALL_RECIPE_LIBS,$(1),$(4))$(NL_TAB)cd $$(DESTDIR_2)$(1) && ln -s -f $(notdir $(4)) $(notdir $(3)) && ln -s -f $(notdir $(3)) $(notdir $(2))
-endif
-
-ifeq ($(OS),Darwin)
-INSTALL_FILES_VERSIONED_LIB    = $(if $(2),$(1) $(word 1,$(call MAP_SHARED_LIB_VERSION,$(1),$(2))),$(1))
-INSTALL_RECIPE_VERSIONED_LIB   = $(if $(3),$(call INSTALL_RECIPE_VERSIONED_LIB_1,$(1),$(2),$(word 1,$(call MAP_SHARED_LIB_VERSION,$(2),$(3)))),$(INSTALL_RECIPE_LIBS))
-INSTALL_RECIPE_VERSIONED_LIB_1 = $(call INSTALL_RECIPE_LIBS,$(1),$(3))$(NL_TAB)cd $$(DESTDIR_2)$(1) && ln -s -f $(notdir $(3)) $(notdir $(2))
-endif
-
-INST_STATIC_LIB_SUFFICES :=
-INST_SHARED_LIB_SUFFICES :=
-INST_PROG_SUFFICES :=
-ifneq ($(ENABLE_INSTALL_STATIC_LIBS),)
-INST_STATIC_LIB_SUFFICES += +$(SUFFIX_LIB_STATIC_OPTIM)
-endif
-INST_SHARED_LIB_SUFFICES += +$(SUFFIX_LIB_SHARED_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_LIBS),)
-INST_SHARED_LIB_SUFFICES += +$(SUFFIX_LIB_SHARED_DEBUG)
-endif
-INST_PROG_SUFFICES += +$(SUFFIX_PROG_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_PROGS),)
-INST_PROG_SUFFICES += +$(SUFFIX_PROG_DEBUG)
-endif
-
-# ARGS: abstract_targets
-INSTALL_FILES_STATIC_LIBS = $(foreach x,$(1),$(foreach y,$(INST_STATIC_LIB_SUFFICES),$(call GET_LIBRARY_STEM,$(x))$(patsubst +%,%,$(y))))
-INSTALL_FILES_SHARED_LIBS = $(foreach x,$(1),$(foreach y,$(INST_SHARED_LIB_SUFFICES),$(call INSTALL_FILES_VERSIONED_LIB,$(call GET_LIBRARY_STEM,$(x))$(patsubst +%,%,$(y)),$(call GET_LIBRARY_VERSION,$(x)))))
-INSTALL_FILES_PROGRAMS    = $(foreach x,$(1),$(foreach y,$(INST_PROG_SUFFICES),$(x)$(patsubst +%,%,$(y))))
-
-# ARGS: install_dir, abstract_targets
-INSTALL_RECIPE_STATIC_LIBS = $(call INSTALL_RECIPE_STATIC_LIBS_1,$(1),$(call INSTALL_FILES_STATIC_LIBS,$(2)))
-INSTALL_RECIPE_STATIC_LIBS_1 = $(if $(2),$(call INSTALL_RECIPE_LIBS,$(1),$(2)))
-INSTALL_RECIPE_SHARED_LIBS = $(foreach x,$(2),$(foreach y,$(INST_SHARED_LIB_SUFFICES),$(call INSTALL_RECIPE_VERSIONED_LIB,$(1),$(call GET_LIBRARY_STEM,$(x))$(patsubst +%,%,$(y)),$(call GET_LIBRARY_VERSION,$(x)))$(NEWLINE)))
-INSTALL_RECIPE_PROGRAMS    = $(NL_TAB)$$(INSTALL_PROGRAM) $(call INSTALL_FILES_PROGRAMS,$(2)) $$(DESTDIR_2)$(1)
-
-# ARGS: primary, is_for_uninstall
-GET_INSTALL_DIRS = $(foreach x,$(PRIMARY_PREFIXES),$(if $(filter subinclude,$(x)),$(call GET_INSTALL_DIRS_1,$(call GET_ROOT_INSTALL_DIR,include),$(call COND_APPEND,$(INCLUDE_SUBDIR),/),$(x),$(1),$(2)),$(call GET_INSTALL_DIRS_1,$(call GET_ROOT_INSTALL_DIR,$(x)),,$(x),$(1),$(2))))
-
-# ARGS: root_install_dir, opt_include_subdir_slash, primary_prefix, primary, is_for_uninstall
-GET_INSTALL_DIRS_1 = $(call GET_INSTALL_DIRS_2,$(1),$(2),$(notdir $($(3)_$(4))) $(nobase_$(3)_$(4)),$(5))
-
-# ARGS: root_install_dir, opt_include_subdir_slash, nobase_targets, is_for_uninstall
-GET_INSTALL_DIRS_2 = $(foreach x,$(call REMOVE_DUPES,$(patsubst %/,%,$(dir $(addprefix $(2),$(3))))),$(if $(filter .,$(x)),$(if $(4),,$(1)),$(foreach y,$(call SUBDIR_PARENT_EXPAND,$(x)),$(1)/$(y))))
-
-SUBDIR_PARENT_EXPAND = $(if $(filter-out ./,$(dir $(1))),$(call SUBDIR_PARENT_EXPAND,$(patsubst %/,%,$(dir $(1)))) $(1),$(1))
-
-# ARGS: primary, get_recipes
-GET_INSTALL_RECIPES = $(foreach x,$(PRIMARY_PREFIXES),$(call GET_INSTALL_RECIPES_1,$(2),$(call GET_INSTALL_DIR,$(x)),$(strip $($(x)_$(1))),$(nobase_$(x)_$(1))))
-
-# ARGS: get_recipes, install_dir, abstract_targets, nobase_targets
-GET_INSTALL_RECIPES_1 = $(if $(3),$(call $(1),$(2),$(3))$(NEWLINE)) $(foreach x,$(call REMOVE_DUPES,$(dir $(4))),$(call $(1),$(2)$(patsubst %/,/%,$(filter-out ./,$(x))),$(strip $(foreach y,$(4),$(if $(call IS_EQUAL_TO,$(dir $(y)),$(x)),$(y)))))$(NEWLINE))
-
-# ARGS: primary, get_files
-GET_UNINSTALL_RECIPES = $(foreach x,$(PRIMARY_PREFIXES),$(call GET_UNINSTALL_RECIPES_1,$(call GET_INSTALL_DIR,$(x)),$(2),$($(x)_$(1)),$(nobase_$(x)_$(1)),$(call REMOVE_DUPES,$(notdir $($(x)_$(1)_EXTRA_UNINSTALL)) $(nobase_$(x)_$(1)_EXTRA_UNINSTALL))))
-
-# ARGS: install_dir, get_files, abstract_targets, nobase_targets, extra_uninstall
-GET_UNINSTALL_RECIPES_1 = $(call GET_UNINSTALL_RECIPES_2,$(1),$(strip $(call WILDCARD_PATHS_FILTER_OUT,$(5),$(notdir $(call $(2),$(3))) $(call $(2),$(4))) $(5)))
-
-# ARGS: install_dir, uninstall_paths
-GET_UNINSTALL_RECIPES_2 = $(if $(2), $(call UNINSTALL_RECIPE_FILES,$(1),$(2))$(NEWLINE))
-
-INSTALL_DIRS :=
-UNINSTALL_DIRS :=
-EXTRA_UNINSTALL_DIRS :=
-INSTALL_RECIPES :=
-UNINSTALL_RECIPES :=
-
-INSTALL_FILTER_2 := $(subst $(COMMA),$(SPACE),$(INSTALL_FILTER))
-
-ifneq ($(filter headers,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,HEADERS)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,HEADERS,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,HEADERS_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,HEADERS,INSTALL_RECIPE_FILES)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,HEADERS,IDENTITY)$(NEWLINE)
-endif
-ifneq ($(filter static-libs,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,LIBRARIES,INSTALL_RECIPE_STATIC_LIBS)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,LIBRARIES,INSTALL_FILES_STATIC_LIBS)$(NEWLINE)
-endif
-ifneq ($(filter shared-libs,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,LIBRARIES,INSTALL_RECIPE_SHARED_LIBS)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,LIBRARIES,INSTALL_FILES_SHARED_LIBS)$(NEWLINE)
-endif
-ifneq ($(filter progs,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,PROGRAMS)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,PROGRAMS,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,PROGRAMS_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,PROGRAMS,INSTALL_RECIPE_PROGRAMS)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,PROGRAMS,INSTALL_FILES_PROGRAMS)$(NEWLINE)
-endif
-ifneq ($(and $(filter dev-progs,$(INSTALL_FILTER_2)),$(strip $(DEV_PROGRAMS))),)
-INSTALL_DIRS += $(call GET_ROOT_INSTALL_DIR,bin)
-INSTALL_RECIPES += $(call INSTALL_RECIPE_PROGRAMS,$(call GET_ROOT_INSTALL_DIR,bin),$(DEV_PROGRAMS))$(NEWLINE)
-UNINSTALL_RECIPES += $(call UNINSTALL_RECIPE_FILES,$(call GET_ROOT_INSTALL_DIR,bin),$(call INSTALL_FILES_PROGRAMS,$(DEV_PROGRAMS)))$(NEWLINE)
-endif
-
-# ARGS: paths, extra_paths
-FILTER_UNINSTALL_DIRS = $(call FOLD_LEFT,FILTER_UNINSTALL_DIRS_1,$(1) $(2),$(2))
-FILTER_UNINSTALL_DIRS_1 = $(call REMOVE_DUPES,$(foreach x,$(1),$(if $(call WILDCARD_PATH_MATCH,$(2),$(x)),$(2),$(x))))
-
-INSTALL_DIR_RECIPES   := $(if $(strip $(INSTALL_DIRS)),$(NL_TAB)$$(INSTALL_DIR) $(foreach x,$(call REMOVE_PREFIXES,$(patsubst %,%/,$(call REMOVE_DUPES,$(INSTALL_DIRS)))),$$(DESTDIR_2)$(x))$(NEWLINE))
-UNINSTALL_DIR_RECIPES := $(foreach x,$(call LIST_REVERSE,$(call FILTER_UNINSTALL_DIRS,$(call REMOVE_DUPES,$(UNINSTALL_DIRS)),$(call REMOVE_DUPES,$(EXTRA_UNINSTALL_DIRS)))),$(NL_TAB)-rmdir $$(DESTDIR_2)$(x)/$(NEWLINE))
-
-define INSTALL_RULES
-install-only/local:$(INSTALL_DIR_RECIPES)$(INSTALL_RECIPES)
-uninstall/local:$(UNINSTALL_RECIPES)$(UNINSTALL_DIR_RECIPES)
-endef
-
-ifeq ($(ENABLE_NOINST_BUILD),)
-$(eval $(INSTALL_RULES))
-endif
-
-
-# TESTING (A.K.A CHECKING)
-
-define CHECK_RULES
-
-check/local: $(TARGETS_CHECK)
-$(foreach x,$(TARGETS_CHECK_PROG_OPTIM),$(NL_TAB)./$(x)$(NEWLINE))
-
-check-debug/local: $(TARGETS_CHECK_DEBUG)
-$(foreach x,$(TARGETS_CHECK_PROG_DEBUG),$(NL_TAB)./$(x)$(NEWLINE))
-
-memcheck/local: $(TARGETS_CHECK)
-$(foreach x,$(TARGETS_CHECK_PROG_OPTIM),$(NL_TAB)$$(VALGRIND) $$(VALGRIND_FLAGS) --error-exitcode=1 ./$(x) --no-error-exitcode$(NEWLINE))
-
-memcheck-debug/local: $(TARGETS_CHECK_DEBUG)
-$(foreach x,$(TARGETS_CHECK_PROG_DEBUG),$(NL_TAB)$$(VALGRIND) $$(VALGRIND_FLAGS) --error-exitcode=1 ./$(x) --no-error-exitcode$(NEWLINE))
-
-ifneq ($(strip $(or $(SOURCE_DIRS),$(TARGETS_CHECK_COVER))),)
-check-cover/local: $(TARGETS_CHECK_COVER)
-$(if $(SOURCE_DIRS),$(NL_TAB)$$(RM) $(foreach x,$(SOURCE_DIRS),$(patsubst ./%,%,$(x))*.gcda))
-$(foreach x,$(TARGETS_CHECK_PROG_COVER),$(NL_TAB)-./$(x)$(NEWLINE))
-endif
-
-endef
-
-$(eval $(CHECK_RULES))
-
-
-
-# LINKING PROGRAMS
-
-# ARGS: origin_pattern, target_pattern, list
-FILTER_PATSUBST = $(patsubst $(1),$(2),$(filter $(1),$(3)))
-
-# ARGS: patterns, list
-FILTER_UNPACK   = $(foreach x,$(2),$(call FILTER_UNPACK_1,$(call FIND,FILTER_UNPACK_2,$(1),$(x)),$(x)))
-FILTER_UNPACK_1 = $(and $(1),$(patsubst $(1),%,$(2)))
-FILTER_UNPACK_2 = $(filter $(1),$(2))
-
-# ARGS: func, patterns, list, optional_arg
-PATTERN_UNPACK_MAP   = $(foreach x,$(3),$(call PATTERN_UNPACK_MAP_1,$(1),$(call FIND,PATTERN_UNPACK_MAP_2,$(2),$(x)),$(x),$(4)))
-# ARGS: func, optional_matching_pattern, entry, optional_arg
-PATTERN_UNPACK_MAP_1 = $(if $(2),$(patsubst %,$(2),$(call $(1),$(patsubst $(2),%,$(3)),$(4))),$(3))
-PATTERN_UNPACK_MAP_2 = $(filter $(1),$(2))
-
-MANGLE_LIBREF = $(subst /,_s,$(subst .,_d,$(subst -,_e,$(subst _,_u,$(1)))))
-
-# Expand the contents of the `target_LIBS` variable for the specified
-# target. The target must either be a program or an installed
-# library. Relative paths in the output will be expressed relative to
-# the directory holding the local `Makefile`.
-#
-# Output for each convenience library `x/y/libfoo.a`:
-#
-#     noinst:x/y/libfoo libdeps:x/y/libfoo.libdeps
-#     ldflag-opt:flag... ldflag-dbg:flag... ldflag-cov:flag...
-#
-# For each installed library `x/y/libfoo.a` referenced directly or in
-# two steps via a convenience library:
-#
-#     inst:x/y/libfoo libdeps:x/y/libfoo.libdeps dir:x/y lib:foo
-#
-# For each installed library `x/y/libfoo.a` referenced directly or
-# indirectly in any number of steps, and installed as
-# `/foo/bar/libfoo.so`:
-#
-#     rpath:/foo/bar rpath-noinst:x/y
-#
-# ARGS: abstract_target
-EXPAND_INST_LIB_LIBREFS = $(call EXPAND_LIBREFS,$(1),rpath:$(call GET_INSTALL_DIR_FOR_LIB_TARGET,$(1)) rpath-noinst:$(patsubst %/,%,$(dir $(1))))
-# ARGS: abstract_target, initial_elems
-EXPAND_LIBREFS = $(call REMOVE_DUPES,$(2) $(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),$(call EXPAND_LIBREF,$(x))))
-# ARGS: libref
-EXPAND_LIBREF = $(call EXPAND_LIBREF_1,$(1),$(call MANGLE_LIBREF,$(1)))
-EXPAND_LIBREF_1 = $(if $(GMK_CELR_$(2)),,$(eval GMK_ELR_$(2) := $$(call EXPAND_LIBREF_2,$(1))$(NEWLINE)GMK_CELR_$(2) = x))$(GMK_ELR_$(2))
-EXPAND_LIBREF_2 = $(call EXPAND_LIBREF_3,$(call GET_LIBRARY_STEM,$(x)),$(call READ_LIBDEPS,$(x)))
-# ARGS: libref_stem, libref_libdeps_contents
-EXPAND_LIBREF_3 = $(if $(filter noinst,$(2)),$(call EXPAND_LIBREF_NOINST,$(1),$(2)),$(call EXPAND_LIBREF_INST,$(1),$(2)))
-EXPAND_LIBREF_NOINST = $(call EXPAND_LIBREF_4,noinst:$(1) libdeps:$(1)$(LIB_SUFFIX_LIBDEPS) $(filter-out noinst,$(2)))
-EXPAND_LIBREF_INST   = $(call EXPAND_LIBREF_4,lib:$(1).a libdeps:$(1)$(LIB_SUFFIX_LIBDEPS) $(2))
-# ARGS: partially_expanded_libdeps
-EXPAND_LIBREF_4 = $(foreach x,$(1),$(if $(filter lib:%,$(x)),$(call EXPAND_LIBREF_5,$(call GET_LIBRARY_STEM,$(patsubst lib:%,%,$(x)))),$(x)))
-# ARGS: nested_libref_stem
-EXPAND_LIBREF_5 = $(call EXPAND_LIBREF_6,$(1),$(dir $(1)),$(notdir $(1)))
-# ARGS: nested_libref_stem, dir_part, nondir_part
-EXPAND_LIBREF_6 = inst:$(1) dir:$(patsubst %/,%,$(2)) $(patsubst lib%,lib:%,$(3))
-
-# Read the contents of the `.libdeps` file for the specified library
-# and translate relative paths such that they are expressed relative
-# to the directory holding the local `Makefile`. For referenced
-# libraries defined in the local `Makefile`, the contents needs to be
-# computed "on the fly" because the `.libdeps` file may not yet be up
-# to date.
-#
-# ARGS: abstract_libref
-READ_LIBDEPS   = $(if $(call IS_LOCAL_NOINST_LIB,$(1)),$(call MAKE_NOINST_LIBDEPS,$(1)),$(if $(call IS_LOCAL_INST_LIB,$(1)),$(call MAKE_INST_LIBDEPS,$(1)),$(call READ_LIBDEPS_1,$(1))))
-READ_LIBDEPS_1 = $(call PATTERN_UNPACK_MAP,READ_LIBDEPS_2,lib:% rpath-noinst:%,$(call CAT_OPT_FILE,$(call GET_LIBRARY_STEM,$(1))$(LIB_SUFFIX_LIBDEPS)),$(dir $(1)))
-READ_LIBDEPS_2 = $(call MAKE_REL_PATH,$(2)$(1))
-# Is the specified library one that is defined in the local Makefile?
-IS_LOCAL_INST_LIB   = $(call FIND,IS_SAME_PATH_AS,$(INST_LIBRARIES),$(1))
-IS_LOCAL_NOINST_LIB = $(call FIND,IS_SAME_PATH_AS,$(noinst_LIBRARIES) $(check_LIBRARIES),$(1))
-
-# Quote elements for shell and translate relative paths such that they
-# become relative to the specified target directory. It is assumed
-# that the relative paths are currently relative to the current
-# working directory.
-#
-# ARGS: libdeps_contents, target_dir
-EXPORT_LIBDEPS = $(foreach x,$(call PATTERN_UNPACK_MAP,EXPORT_LIBDEPS_1,lib:% rpath-noinst:%,$(1),$(2)),$(call SHELL_ESCAPE,$(x)))
-EXPORT_LIBDEPS_1 = $(call MAKE_REL_PATH,$(1),$(2))
-
-# Compute what is almost the contents to be placed in the `.libdeps`
-# file for the specified library. The only thing that sets it apart
-# from what must ultimately be placed in the file, is that all
-# relative paths in the output of this function will be expressed
-# relative to the directory holding the local `Makefile`, and not
-# relative to the directory holding the `.libdeps` file (in case they
-# differ).
-#
-# ARGS: abstract_target
-MAKE_INST_LIBDEPS     = $(call EXTRACT_INST_LIB_LIBDEPS,$(call EXPAND_INST_LIB_LIBREFS,$(1)))
-MAKE_NOINST_LIBDEPS   = $(strip noinst $(call MAKE_NOINST_LIBDEPS_1,$(1)) $(call MAKE_NOINST_LIBDEPS_2,$(1)))
-MAKE_NOINST_LIBDEPS_1 = $(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),lib:$(x) $(call READ_LIBDEPS,$(x)))
-MAKE_NOINST_LIBDEPS_2 = $(call MAKE_NOINST_LIBDEPS_3,$(1)) $(call MAKE_NOINST_LIBDEPS_4,$(1)) $(call MAKE_NOINST_LIBDEPS_5,$(1))
-MAKE_NOINST_LIBDEPS_3 = $(foreach x,$(call GET_FLAGS,$(call FOLD_TARGET,$(1))_LDFLAGS,OPTIM),ldflag-opt:$(x))
-MAKE_NOINST_LIBDEPS_4 = $(foreach x,$(call GET_FLAGS,$(call FOLD_TARGET,$(1))_LDFLAGS,DEBUG),ldflag-dbg:$(x))
-MAKE_NOINST_LIBDEPS_5 = $(foreach x,$(call GET_FLAGS,$(call FOLD_TARGET,$(1))_LDFLAGS,COVER),ldflag-cov:$(x))
-
-# ARGS: expanded_librefs
-EXTRACT_INST_LIB_LIBDEPS = $(filter rpath:% rpath-noinst:%,$(1))
-
-# Add library name qualification, and select the appropriate set of
-# linker flags for the specified compilation mode.
-#
-# ARGS: expanded_librefs, compile_mode
-FINALIZE_EXPANDED_LIBREFS   = $(call SELECT_LDFLAGS_$(2),$(call QUALIFY_LIBREFS,$(1),$(2)))
-QUALIFY_LIBREFS = $(call QUALIFY_LIBREFS_1,$(1),$(SUFFIX_LIB_STATIC_$(2)),$(SUFFIX_LIB_SHARED_$(2)),$(BASE_DENOM_2)$(LIB_DENOM_$(2)))
-QUALIFY_LIBREFS_1 = $(patsubst noinst:%,noinst:%$(2),$(patsubst inst:%,inst:%$(3),$(patsubst lib:%,lib:%$(4),$(1))))
-SELECT_LDFLAGS_OPTIM = $(patsubst ldflag-opt:%,ldflag:%,$(filter-out ldflag-dbg:% ldflag-cov:%,$(1)))
-SELECT_LDFLAGS_DEBUG = $(patsubst ldflag-dbg:%,ldflag:%,$(filter-out ldflag-opt:% ldflag-cov:%,$(1)))
-SELECT_LDFLAGS_COVER = $(patsubst ldflag-cov:%,ldflag:%,$(filter-out ldflag-opt:% ldflag-dbg:%,$(1)))
-
-# ARGS: abstract_target
-GET_LIBREFS_DEP_INFO = $(call GET_LIBREFS_DEP_INFO_1,$(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),$(call EXPAND_LIBREF,$(x))))
-GET_LIBREFS_DEP_INFO_1 = $(filter noinst:% inst:% libdeps:%,$(1)) $(if $(filter rpath-noinst:%,$(1)),noinst_rpath)
-
-# ARGS: librefs_dep_info, compile_mode
-FINALIZE_LIBREFS_DEP_INFO = $(call FILTER_UNPACK,noinst:% inst:% libdeps:%,$(call QUALIFY_LIBREFS,$(1),$(2)))
-
-# ARGS: finalized_expanded_librefs
-LDFLAGS_FROM_LIBREFS = $(call FILTER_PATSUBST,noinst:%,%,$(1)) $(call FILTER_PATSUBST,lib:%,-l%,$(1)) $(call FILTER_PATSUBST,dir:%,-L%,$(1)) $(call FILTER_PATSUBST,ldflag:%,%,$(1))
-RPATHS_FROM_LIBREFS = $(NOINST_RPATHS_FROM_LIBREFS)
-ifeq ($(ENABLE_NOINST_BUILD),)
-RPATHS_FROM_LIBREFS = $(foreach x,$(call FILTER_PATSUBST,rpath:%,%,$(1)),-Wl,-rpath,$(x))
-endif
-NOINST_RPATHS_FROM_LIBREFS = $(foreach x,$(call FILTER_PATSUBST,rpath-noinst:%,%,$(1)),-Wl,-rpath,\$$ORIGIN$(if $(call IS_EQUAL_TO,$(x),.),,/$(x)))
-ifeq ($(OS),Darwin)
-NOINST_RPATHS_FROM_LIBREFS = $(foreach x,$(call FILTER_PATSUBST,rpath-noinst:%,%,$(1)),-Wl,-rpath,@loader_path/$(x))
-endif
-
-# ARGS: target, objects, abstract_target, compile_mode
-NOINST_PROG_RECIPE = $(call NOINST_PROG_RECIPE_1,$(1),$(2),$(3),$(4),$(call FINALIZE_EXPANDED_LIBREFS,$(call EXPAND_LIBREFS,$(3)),$(4)))
-NOINST_PROG_RECIPE_1 = $(call LIST_CONCAT,$(strip $(LD_PROG_$(4)) $(2) $(call LDFLAGS_FROM_LIBREFS,$(5)) $(call GET_LDFLAGS_FOR_TARGET,$(3),$(4)) $(LDFLAGS_ARCH)),$(call NOINST_RPATHS_FROM_LIBREFS,$(5))) -o $(1)
-
-INST_PROG_RECIPE = $(call INST_PROG_RECIPE_1,$(1),$(2),$(3),$(4),$(call FINALIZE_EXPANDED_LIBREFS,$(call EXPAND_LIBREFS,$(3)),$(4)))
-INST_PROG_RECIPE_1 = $(strip $(LD_PROG_$(4)) $(2) $(call LDFLAGS_FROM_LIBREFS,$(5)) $(call GET_LDFLAGS_FOR_TARGET,$(3),$(4)) $(LDFLAGS_ARCH) $(call RPATHS_FROM_LIBREFS,$(5))) -o $(1)
-
-# ARGS: target, objects, deps, abstract_target, compile_mode, has_noinst_rpaths
-define NOINST_PROG_RULES
-$(1): $(2) $(3)
-	$$(call NOINST_PROG_RECIPE,$(1),$(2),$(4),$(5))
-endef
-define INST_PROG_RULES
-ifeq ($(if $(ENABLE_NOINST_BUILD),,$(6)),)
-$(1): $(2) $(3)
-	$$(call INST_PROG_RECIPE,$(1),$(2),$(4),$(5))
-else
-$(1) $(1)-noinst: $(2) $(3)
-	$$(call INST_PROG_RECIPE,$(1),$(2),$(4),$(5))
-	$$(call NOINST_PROG_RECIPE,$(1)-noinst,$(2),$(4),$(5))
-endif
-endef
-
-# ARGS: abstract_target, abstract_objects, librefs_dep_info, extra_deps, compile_mode, prog_type
-EVAL_PROG_RULES_3 = $(eval $(call $(6)_PROG_RULES,$(1)$(SUFFIX_PROG_$(5)),$(patsubst %.o,%$(SUFFIX_OBJ_STATIC_$(5)),$(2)),$(call FINALIZE_LIBREFS_DEP_INFO,$(3),$(5)) $(call GET_DEPS_FOR_TARGET,$(1)),$(1),$(5),$(filter noinst_rpath,$(3))))
-
-EVAL_PROG_RULES_2 = $(foreach x,OPTIM DEBUG COVER,$(call EVAL_PROG_RULES_3,$(1),$(2),$(3),$(4),$(x),$(5)))
-
-EVAL_PROG_RULES_1 = $(call EVAL_PROG_RULES_2,$(1),$(call GET_OBJECTS_FOR_TARGET,$(1),.o),$(call GET_LIBREFS_DEP_INFO,$(1)),$(call GET_DEPS_FOR_TARGET,$(1)),$(2))
-
-$(foreach x,$(noinst_PROGRAMS) $(check_PROGRAMS),$(call EVAL_PROG_RULES_1,$(x),NOINST))
-$(foreach x,$(INST_PROGRAMS) $(DEV_PROGRAMS),$(call EVAL_PROG_RULES_1,$(x),INST))
-
-
-
-# CREATING/LINKING LIBRARIES
-
-# For each library `libfoo.a` (installed or uninstalled) a 'libdeps'
-# file called `libfoo.libdeps` is also created. This file contains a
-# space-separated list of entries of various different kinds needed
-# when linking project-local targets against the library. The order of
-# entries is immaterial.
-#
-#
-# If `libinst.a` is an installed library, then `libinst.libdeps`
-# contains a number of `rpath:` and `noninst-rpath:` entries. The
-# `rpath:` entries are used in `-rpath` flags when linking installed
-# programs against `libinst.a`. The `rpath-noinst:` entries are
-# similar, but they are used when linking programs that are not
-# installed (i.e., those that can be executed before `libinst.a` is
-# installed). While the paths specified by the `rpath:` entries are
-# absolute, the paths specified by the `noninst-rpath:` entries are
-# always relative to the directory containing the 'libdeps' file.
-#
-# First of all, `libinst.libdeps` contains an `rpath:` and a
-# `rpath-noinst:` entry for itself. For instance:
-#
-#     rpath:/usr/local/lib rpath-noinst:.
-#
-# Further more, `libinst.libdeps` contains an `rpath:` and a
-# `rpath-noinst:` entry for each installed library `libxxx.a`, that
-# `libinst.a` depends on, and which is also part of this project,
-# unless those entries would lead to duplicates. This is true even
-# when `libxxx.a` is an indirect dependency of `libinst.a`
-# (transitivity). For example, if `libxxx.a` is an dependency of
-# `libyyy.a` and `libyyy.a` is a dependency of `libinst.a`, then
-# `libxxx.a` is an indirect dependency of `libinst.a`. Let us assume
-# that `libinst.a`, `libxxx.a`, and `libyyy.a` are located in
-# subdirectories `inst`, `xxx`, and `yyy` respectively, and all are
-# installed in `/usr/local/lib`, then `libinst.libdeps` will contain
-#
-#     rpath:/usr/local/lib rpath-noinst:. rpath-noinst:../xxx
-#     rpath-noinst:../yyy
-#
-# Had they all been located in the same directory, `libinst.libdeps`
-# would instead contain
-#
-#     rpath:/usr/local/lib rpath-noinst:.
-#
-#
-# If `libconv.a` is a convenience library (not installed), then
-# `libconv.libdeps` contains a `noinst` entry that identifies it as a
-# convenience library from the point of view of `Makefile`s in other
-# subdirectories. Apart from that, it contains a `lib:` entry for each
-# installed project-local library that `libconv.a` directly depends
-# on, and it contains the union of the contents of the 'libdeps' files
-# associated with each of those `lib:` entries with relative paths
-# transformed as necessary. Aa with `noninst-rpath:`, the paths
-# specified by the `lib:` entries are always relative to the directory
-# containing the 'libdeps' file. For example, if `libconv.a` depends
-# on `libinst.a`, and `libconv.a` is located in the root directory of
-# the project, and the installed libraries are located in distinct
-# subdirectories as described in an example above, then
-# `libconv.libdeps` will contain
-#
-#     noinst lib:inst/libinst.a rpath:/usr/local/lib rpath-noinst:inst
-#     rpath-noinst:xxx rpath-noinst:yyy
-#
-# Note how the relative paths in the `rpath-noinst:` entries have been
-# transformed such that they are now relative to the root directory.
-#
-# When extra linker flags are attached to a convenience library, those
-# flags will also be carried in the 'libdeps' file. For example,
-# `libconv.libdeps` might contain
-#
-#     ldflag-opt:-lmagic ldflag-opt:-L/opt/magic/lib
-#     ldflag-dbg:-lmagic ldflag-dbg:-L/opt/magic-debug/lib
-#     ldflag-cov:-lmagic ldflag-cov:-L/opt/magic-debug/lib
-#
-# The `ldflag-opt:` entries are used when compiling in optimized
-# (default) mode, while the `ldflag-dbg:` and the `ldflag-cov:`
-# entries are used when compiling in debug and coverage modes
-# respectively.
-
-# ARGS: target, objects, extra_deps
-define STATIC_LIBRARY_RULE
-$(1): $(2) $(3)
-	$$(RM) $(1)
-	$$(strip $$(AR) $$(ARFLAGS_GENERAL) $(1) $(2))
-endef
-
-# ARGS: real_local_path, objects, finalized_expanded_librefs, extra_deps, link_cmd, ldflags, lib_version
-SHARED_LIBRARY_RULE_HELPER = $(call SHARED_LIBRARY_RULE,$(1),$(2) $(call FILTER_UNPACK,inst:% libdeps:%,$(3)) $(4),$(5) $(2) $(call LDFLAGS_FROM_LIBREFS,$(3)) $(6) $$(LDFLAGS_ARCH),$(if $(ENABLE_NOINST_BUILD),,$(7)))
-
-# ARGS: qual_lib_name, deps, cmd, version
-SHARED_LIBRARY_RULE = $(SHARED_LIBRARY_RULE_DEFAULT)
-define SHARED_LIBRARY_RULE_DEFAULT
-$(1): $(2)
-	$$(strip $(3)) -o $(1)
-	$(STRIP) -s $(1)
-endef
-
-ifeq ($(OS),Linux)
-
-# ARGS: qual_lib_name, deps, cmd, version
-SHARED_LIBRARY_RULE = $(if $(4),$(call SHARED_LIBRARY_RULE_VER,$(1),$(2),$(3),$(call MAP_SHARED_LIB_VERSION,$(4))),$(SHARED_LIBRARY_RULE_DEFAULT))
-
-# ARGS: qual_lib_name, deps, cmd, mapped_version
-SHARED_LIBRARY_RULE_VER = $(call SHARED_LIBRARY_RULE_VER_2,$(1),$(2),$(3),$(word 1,$(4)),$(word 2,$(4)))
-
-# ARGS: qual_lib_name, deps, cmd, major_version, full_version
-define SHARED_LIBRARY_RULE_VER_2
-$(1) $(1).$(4) $(1).$(5): $(2)
-	$$(strip $(3) -Wl,-soname,$(notdir $(1).$(4))) -o $(1).$(5)
-	ln -s -f $(notdir $(1).$(5)) $(1).$(4)
-	ln -s -f $(notdir $(1).$(4)) $(1)
-endef
-
-endif
-
-ifeq ($(OS),Darwin)
-
-# See http://www.mikeash.com/pyblog/friday-qa-2009-11-06-linking-and-install-names.html
-
-# ARGS: qual_lib_name, deps, cmd, version
-SHARED_LIBRARY_RULE = $(if $(4),$(call SHARED_LIBRARY_RULE_VER,$(1),$(2),$(3),$(call MAP_SHARED_LIB_VERSION,$(1),$(4))),$(SHARED_LIBRARY_RULE_DEFAULT))
-
-# ARGS: qual_lib_name, deps, cmd, mapped_version
-SHARED_LIBRARY_RULE_VER = $(call SHARED_LIBRARY_RULE_VER_2,$(1),$(2),$(3),$(word 1,$(4)),$(word 2,$(4)),$(word 3,$(4)))
-
-# ARGS: qual_lib_name, deps, cmd, qual_lib_name_with_version, compatibility_version, current_version
-define SHARED_LIBRARY_RULE_VER_2
-$(1) $(4): $(2)
-	$$(strip $(3) -install_name @rpath/$(notdir $(4)) -compatibility_version $(5) -current_version $(6)) -o $(4)
-	ln -s -f $(notdir $(4)) $(1)
-endef
-
-endif
-
-# ARGS: target_stem_path, contents, deps
-define LIBDEPS_RULE
-$(1)$$(LIB_SUFFIX_LIBDEPS): $(3) $$(DEP_MAKEFILES)
-	echo $$(call EXPORT_LIBDEPS,$(2),$(dir $(1))) >$(1)$$(LIB_SUFFIX_LIBDEPS)
-endef
-
-# ARGS: abstract_target, extra_deps
-define NOINST_LIB_RULES
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_OPTIM),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_OPTIM)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_DEBUG),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_DEBUG)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_COVER),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_COVER)),$(3))
-$(call LIBDEPS_RULE,$(call GET_LIBRARY_STEM,$(1)),$(call MAKE_NOINST_LIBDEPS,$(1)),$(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS)))
-endef
-
-# ARGS: abstract_target, expanded_librefs, extra_deps
-define INST_LIB_RULES
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_OPTIM),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_OPTIM)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_DEBUG),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_DEBUG)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_COVER),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_COVER)),$(3))
-$(call SHARED_LIBRARY_RULE_HELPER,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_SHARED_OPTIM),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_SHARED_OPTIM)),$(call FINALIZE_EXPANDED_LIBREFS,$(2),OPTIM),$(3),$$(LD_LIB_OPTIM),$(call GET_LDFLAGS_FOR_TARGET,$(1),OPTIM),$(call GET_LIBRARY_VERSION,$(1)))
-$(call SHARED_LIBRARY_RULE_HELPER,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_SHARED_DEBUG),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_SHARED_DEBUG)),$(call FINALIZE_EXPANDED_LIBREFS,$(2),DEBUG),$(3),$$(LD_LIB_DEBUG),$(call GET_LDFLAGS_FOR_TARGET,$(1),DEBUG),$(call GET_LIBRARY_VERSION,$(1)))
-$(call SHARED_LIBRARY_RULE_HELPER,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_SHARED_COVER),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_SHARED_COVER)),$(call FINALIZE_EXPANDED_LIBREFS,$(2),COVER),$(3),$$(LD_LIB_COVER),$(call GET_LDFLAGS_FOR_TARGET,$(1),COVER),$(call GET_LIBRARY_VERSION,$(1)))
-$(call LIBDEPS_RULE,$(call GET_LIBRARY_STEM,$(1)),$(call EXTRACT_INST_LIB_LIBDEPS,$(2)),$(call FILTER_PATSUBST,libdeps:%,%,$(2)))
-endef
-
-define LIBRARY_RULES
-$(foreach x,$(noinst_LIBRARIES) $(check_LIBRARIES),$(NEWLINE)$(call NOINST_LIB_RULES,$(x),$(call GET_DEPS_FOR_TARGET,$(x)))$(NEWLINE))
-$(foreach x,$(INST_LIBRARIES),$(NEWLINE)$(call INST_LIB_RULES,$(x),$(call EXPAND_INST_LIB_LIBREFS,$(x)),$(call GET_DEPS_FOR_TARGET,$(x)))$(NEWLINE))
-endef
-
-$(eval $(LIBRARY_RULES))
-
-
-
-# FLEX AND BISON
-
-%.flex.cpp %.flex.hpp: %.flex $(DEP_MAKEFILES)
-	flex --outfile=$*.flex.cpp --header-file=$*.flex.hpp $<
-
-%.bison.cpp %.bison.hpp: %.bison $(DEP_MAKEFILES)
-	bison --output=$*.bison.cpp --defines=$*.bison.hpp $<
-
-
-
-# COMPILING + AUTOMATIC DEPENDENCIES
-
-$(foreach x,$(LIBRARIES) $(PROGRAMS),$(foreach y,$(call GET_OBJECTS_FOR_TARGET,$(x),.o),$(eval GMK_TARGETS_$(call FOLD_TARGET,$(y)) += $(x))))
-
-GET_CFLAGS_FOR_TARGET = $(foreach x,PROJECT DIR $(foreach y,$(GMK_TARGETS_$(call FOLD_TARGET,$(1))) $(1),$(call FOLD_TARGET,$(y))),$(call GET_FLAGS,$(x)_CFLAGS,$(2)))
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.c
-	$(strip $(CC_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.cpp
-	$(strip $(CXX_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.c
-	$(strip $(CC_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.cpp
-	$(strip $(CXX_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.c
-	$(strip $(CC_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.cpp
-	$(strip $(CXX_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.c
-	$(strip $(CC_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.cpp
-	$(strip $(CXX_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.c
-	$(strip $(CC_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.cpp
-	$(strip $(CXX_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.c
-	$(strip $(CC_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.cpp
-	$(strip $(CXX_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.m
-	$(strip $(OCC_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.mm
-	$(strip $(OCXX_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.m
-	$(strip $(OCC_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.mm
-	$(strip $(OCXX_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.m
-	$(strip $(OCC_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.mm
-	$(strip $(OCXX_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.m
-	$(strip $(OCC_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.mm
-	$(strip $(OCXX_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.m
-	$(strip $(OCC_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.mm
-	$(strip $(OCXX_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.m
-	$(strip $(OCC_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.mm
-	$(strip $(OCXX_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-
--include $(OBJECTS:.o=.d)
diff --git a/realm/realm-jni/project.mk b/realm/realm-jni/project.mk
deleted file mode 100644
index cf9b0e6b95..0000000000
--- a/realm/realm-jni/project.mk
+++ /dev/null
@@ -1,64 +0,0 @@
-ENABLE_INSTALL_DEBUG_LIBS = 1
-
-# Construct fat binaries on Darwin when using Clang
-ifneq ($(REALM_ENABLE_FAT_BINARIES),)
-  ifeq ($(OS),Darwin)
-    ifeq ($(COMPILER_IS),clang)
-      CFLAGS_ARCH += -arch i386 -arch x86_64
-    endif
-  endif
-endif
-
-ifeq ($(OS),Darwin)
-  CFLAGS_ARCH += -mmacosx-version-min=10.8 -stdlib=libc++
-endif
-
-# FIXME: '-fno-elide-constructors' currently causes Realm to fail
-#CFLAGS_DEBUG += -fno-elide-constructors
-CFLAGS_PTHREADS += -pthread
-CFLAGS_GENERAL += -Wextra -ansi -pedantic -Wno-long-long
-
-# Avoid a warning from Clang when linking on OS X. By default,
-# `LDFLAGS_PTHREADS` inherits its value from `CFLAGS_PTHREADS`, so we
-# have to override that with an empty value.
-ifeq ($(OS),Darwin)
-  ifeq ($(LD_IS),clang)
-    LDFLAGS_PTHREADS = $(EMPTY)
-  endif
-endif
-
-# Load dynamic configuration
-#ifeq ($(NO_CONFIG_MK),)
-  #CONFIG_MK = $(GENERIC_MK_DIR)/config.mk
-  #DEP_MAKEFILES += $(CONFIG_MK)
-  #include $(CONFIG_MK)
-  LIB_SUFFIX_SHARED = $(JNI_SUFFIX)
-  #EXTRA_PRIMARY_PREFIXES = jni
-  #jnidir = $(JNI_INSTALL_DIR)
-#endif
-
-ifeq ($(REALM_ANDROID),)
-  REALM_LDFLAGS += -llog
-  CFLAGS_INCLUDE += $(JAVA_CFLAGS)
-  ifneq ($(REALM_ENABLE_MEM_USAGE),)
-    PROJECT_CFLAGS += -DREALM_ENABLE_MEM_USAGE
-    ifeq ($(shell pkg-config libprocps --exists 2>/dev/null && echo yes),yes)
-      PROCPS_CFLAGS  := $(shell pkg-config libprocps --cflags)
-      PROCPS_LDFLAGS := $(shell pkg-config libprocps --libs)
-      PROJECT_CFLAGS  += $(PROCPS_CFLAGS)
-      PROJECT_LDFLAGS += $(PROCPS_LDFLAGS)
-    else
-      PROJECT_LDFLAGS += -lproc
-    endif
-  endif
-else
-  PROJECT_CFLAGS += -DANDROID
-  CFLAGS_OPTIM = -Os -DNDEBUG
-endif
-
-PROJECT_CFLAGS_OPTIM  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS)
-PROJECT_CFLAGS_DEBUG  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS_DBG)
-PROJECT_CFLAGS_COVER  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS_DBG)
-PROJECT_LDFLAGS_OPTIM += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS)
-PROJECT_LDFLAGS_DEBUG += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS_DBG)
-PROJECT_LDFLAGS_COVER += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS_DBG)
diff --git a/realm/realm-jni/src/Makefile b/realm/realm-jni/src/Makefile
deleted file mode 100644
index 4a8eabdd10..0000000000
--- a/realm/realm-jni/src/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-lib_LIBRARIES = librealm-jni.a
-
-JNI_SOURCES := $(wildcard *.cpp)
-librealm_jni_a_SOURCES = $(JNI_SOURCES)
-
-include ../generic.mk
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.h b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
deleted file mode 100644
index 8674f9947c..0000000000
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.h
+++ /dev/null
@@ -1,197 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_CheckedRow */
-
-#ifndef _Included_io_realm_internal_CheckedRow
-#define _Included_io_realm_internal_CheckedRow
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetLong
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetBoolean
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeIsNullLink
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetByteArray
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetLinkView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv *, jclass, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetLong
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetBoolean
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetFloat
- * Signature: (JJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetLink
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetDouble
- * Signature: (JJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetTimestamp
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetString
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetByteArray
- * Signature: (JJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeNullifyLink
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Group.cpp b/realm/realm-jni/src/io_realm_internal_Group.cpp
deleted file mode 100644
index f916bae98d..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Group.cpp
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <realm/util/safe_int_ops.hpp>
-
-#include "util.hpp"
-#include "io_realm_internal_Group.h"
-
-using namespace realm;
-using std::string;
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__(
-    JNIEnv*,  jobject)
-{
-    TR_ENTER()
-    Group *ptr = new Group();
-    TR("Group::createNative(): %p.", VOID_PTR(ptr))
-    return reinterpret_cast<jlong>(ptr);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_String_2I(
-    JNIEnv* env, jobject, jstring jFileName, jint mode)
-{
-    TR_ENTER()
-
-    Group* pGroup = 0;
-    StringData file_name;
-    try {
-        JStringAccessor file_name_tmp(env, jFileName); // throws
-        file_name = StringData(file_name_tmp);
-        Group::OpenMode openmode;
-        switch (mode) {
-        case 0: openmode = Group::mode_ReadOnly; break;
-        case 1: openmode = Group::mode_ReadWrite; break;
-        case 2: openmode = Group::mode_ReadWriteNoCreate; break;
-        default:
-            TR("Invalid mode: %d", mode)
-            ThrowException(env, IllegalArgument, "Group(): Invalid mode parameter.");
-            return 0;
-        }
-
-        pGroup = new Group(file_name, NULL, openmode);
-
-        TR("group: %p", VOID_PTR(pGroup))
-        return reinterpret_cast<jlong>(pGroup);
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-
-    // Failed - cleanup
-    if (pGroup)
-        delete pGroup;
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative___3B(
-    JNIEnv* env, jobject, jbyteArray jData)
-{
-    TR_ENTER()
-    // Copy the group buffer given
-    jsize byteArrayLength = env->GetArrayLength(jData);
-    if (byteArrayLength == 0)
-        return 0;
-    jbyte* buf = static_cast<jbyte*>(malloc(S(byteArrayLength)*sizeof(jbyte)));
-    if (!buf) {
-        ThrowException(env, OutOfMemory, "copying the group buffer.");
-        return 0;
-    }
-    env->GetByteArrayRegion(jData, 0, byteArrayLength, buf);
-
-    TR("%d bytes.", byteArrayLength)
-    Group* pGroup = 0;
-    try {
-        pGroup = new Group(BinaryData(reinterpret_cast<char*>(buf), S(byteArrayLength)), true);
-        TR("groupPtr: %p", VOID_PTR(pGroup))
-        return reinterpret_cast<jlong>(pGroup);
-    }
-    CATCH_FILE("memory-buffer")
-    CATCH_STD()
-
-    // Failed - cleanup
-    if (buf)
-        free(buf);
-    return 0;
-}
-
-// FIXME: Remove this method? It's dangerous to not own the group data...
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_nio_ByteBuffer_2(
-    JNIEnv* env, jobject, jobject jByteBuffer)
-{
-    TR_ENTER()
-    BinaryData bin;
-    if (!GetBinaryData(env, jByteBuffer, bin))
-        return 0;
-    TR("%" PRId64 " bytes.", S64(bin.size()))
-
-    Group* pGroup = 0;
-    try {
-        pGroup = new Group(BinaryData(bin.data(), bin.size()), false);
-    }
-    CATCH_FILE("memory-buffer")
-    CATCH_STD()
-
-    TR("%p", VOID_PTR(pGroup))
-    return reinterpret_cast<jlong>(pGroup);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeClose(
-    JNIEnv*, jclass, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    delete G(nativeGroupPtr);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeSize(
-    JNIEnv*, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    return static_cast<jlong>( G(nativeGroupPtr)->size() ); // noexcept
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring jTableName)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor tableName(env, jTableName); // throws
-        return G(nativeGroupPtr)->has_table(tableName);
-    } CATCH_STD()
-    return false;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jint index)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        return to_jstring(env, G(nativeGroupPtr)->get_table_name(index));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring name)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor table_name(env, name);
-        G(nativeGroupPtr)->remove_table(table_name);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring oldName, jstring newName)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor old_name(env, oldName);
-        JStringAccessor new_name(env, newName);
-        G(nativeGroupPtr)->rename_table(old_name, new_name);
-    } CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr(
-    JNIEnv *env, jobject, jlong nativeGroupPtr, jstring name)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor tableName(env, name); // throws
-        Table* pTable = LangBindHelper::get_or_add_table(*G(nativeGroupPtr), tableName);
-        return (jlong)pTable;
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring jFileName, jbyteArray keyArray)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    StringData file_name;
-    KeyBuffer key(env, keyArray);
-    try {
-        JStringAccessor file_name_tmp(env, jFileName); // throws
-        file_name = StringData(file_name_tmp);
-#ifdef REALM_ENABLE_ENCRYPTION
-        G(nativeGroupPtr)->write(file_name, key.data());
-#else
-        G(nativeGroupPtr)->write(file_name);
-#endif
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-}
-
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Group_nativeWriteToMem(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    BinaryData buffer;
-    char* bufPtr = 0;
-    try {
-        buffer = G(nativeGroupPtr)->write_to_mem(); // throws
-        bufPtr = const_cast<char*>(buffer.data());
-        // Copy the data to Java array, so Java owns it.
-        jbyteArray jArray = 0;
-        if (buffer.size() <= MAX_JSIZE) {
-            jsize jlen = static_cast<jsize>(buffer.size());
-            jArray = env->NewByteArray(jlen);
-            if (jArray)
-                // Copy data to Byte[]
-                env->SetByteArrayRegion(jArray, 0, jlen, reinterpret_cast<const jbyte*>(bufPtr));
-                // SetByteArrayRegion() may throw ArrayIndexOutOfBoundsException - logic error
-        }
-        if (!jArray) {
-            ThrowException(env, IndexOutOfBounds, "Group too big to copy and write.");
-        }
-        free(bufPtr);
-        return jArray;
-    }
-    CATCH_STD()
-    if (bufPtr)
-        free(bufPtr);
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeCommit(
-    JNIEnv*, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER()
-    G(nativeGroupPtr)->commit();
-}
-
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToJson(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    Group* grp = G(nativeGroupPtr);
-
-    try {
-        // Write group to string in JSON format
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        grp->to_json(ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    Group* grp = G(nativeGroupPtr);
-    try {
-        // Write group to string
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        grp->to_string(ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
-    JNIEnv*, jobject, jlong nativeGroupPtr)
-{
-    Group* grp = G(nativeGroupPtr);
-    const size_t table_prefix_length = TABLE_PREFIX.length();
-
-    for (size_t i = 0; i < grp->size(); ++i) {
-        ConstTableRef table = grp->get_table(i);
-        const string table_name = table->get_name();
-        if (table_name.compare(0, table_prefix_length, TABLE_PREFIX) == 0 && !table->is_empty()) {
-            return false;
-        }
-    }
-    return true;
-}
diff --git a/realm/realm-jni/src/io_realm_internal_Group.h b/realm/realm-jni/src/io_realm_internal_Group.h
deleted file mode 100644
index 0099bfec7c..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Group.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Group */
-
-#ifndef _Included_io_realm_internal_Group
-#define _Included_io_realm_internal_Group
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef io_realm_internal_Group_MODE_READONLY
-#define io_realm_internal_Group_MODE_READONLY 0L
-#undef io_realm_internal_Group_MODE_READWRITE
-#define io_realm_internal_Group_MODE_READWRITE 1L
-#undef io_realm_internal_Group_MODE_READWRITE_NOCREATE
-#define io_realm_internal_Group_MODE_READWRITE_NOCREATE 2L
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeRemoveTable
- * Signature: (JLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeRenameTable
- * Signature: (JLjava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable
-  (JNIEnv *, jobject, jlong, jstring, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__
-  (JNIEnv *, jobject);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: (Ljava/lang/String;I)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_String_2I
-  (JNIEnv *, jobject, jstring, jint);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: ([B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative___3B
-  (JNIEnv *, jobject, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: (Ljava/nio/ByteBuffer;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_nio_ByteBuffer_2
-  (JNIEnv *, jobject, jobject);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeGetTableName
- * Signature: (JI)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName
-  (JNIEnv *, jobject, jlong, jint);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeHasTable
- * Signature: (JLjava/lang/String;)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeWriteToFile
- * Signature: (JLjava/lang/String;[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile
-  (JNIEnv *, jobject, jlong, jstring, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeGetTableNativePtr
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeWriteToMem
- * Signature: (J)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Group_nativeWriteToMem
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeToJson
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToJson
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeCommit
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeCommit
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeToString
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeIsEmpty
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.h b/realm/realm-jni/src/io_realm_internal_LinkView.h
deleted file mode 100644
index 7c9e93e61e..0000000000
--- a/realm/realm-jni/src/io_realm_internal_LinkView.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_LinkView */
-
-#ifndef _Included_io_realm_internal_LinkView
-#define _Included_io_realm_internal_LinkView
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeGetRow
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeGetTargetRowIndex
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeAdd
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
-  (JNIEnv *, jclass, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeInsert
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeSet
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeMove
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeRemove
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeClear
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeIsEmpty
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeWhere
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeIsAttached
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeFind
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeRemoveTargetRow
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeRemoveAllTargetRows
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeGetTargetTable
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
deleted file mode 100644
index 229d9a540e..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ /dev/null
@@ -1,329 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-
-#include "util.hpp"
-
-#include <realm/group_shared.hpp>
-#include <realm/replication.hpp>
-#include <realm/commit_log.hpp>
-
-#include "util.hpp"
-#include "io_realm_internal_SharedGroup.h"
-
-using namespace std;
-using namespace realm;
-
-inline static bool jint_to_durability_level(JNIEnv* env, jint durability, SharedGroup::DurabilityLevel &level) {
-    if (durability == 0)
-        level = SharedGroup::durability_Full;
-    else if (durability == 1)
-        level = SharedGroup::durability_MemOnly;
-    else if (durability == 2)
-#ifdef _WIN32
-        level = SharedGroup::durability_Full;   // For Windows, use Full instead of Async
-#else
-        level = SharedGroup::durability_Async;
-#endif
-    else {
-        ThrowException(env, UnsupportedOperation, "Unsupported durability.");
-        return false;
-    }
-
-    return true;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
-    JNIEnv* env, jobject, jstring jfile_name, jint durability, jboolean no_create, jboolean enable_replication, jbyteArray keyArray)
-{
-    TR_ENTER()
-    StringData file_name;
-
-    SharedGroup* db = 0;
-    try {
-        JStringAccessor file_name_tmp(env, jfile_name); // throws
-        file_name = StringData(file_name_tmp);
-
-        if (enable_replication) {
-#ifdef REALM_ENABLE_REPLICATION
-            ThrowException(env, UnsupportedOperation,
-                           "Replication is not currently supported by the Java language binding.");
-//            db = new SharedGroup(SharedGroup::replication_tag(), *file_name_ptr ? file_name_ptr : 0);
-#else
-            ThrowException(env, UnsupportedOperation,
-                           "Replication was disabled in the native library at compile time.");
-#endif
-        }
-        else {
-            SharedGroup::DurabilityLevel level;
-            // Exception thrown for wrong durability value
-            if (!jint_to_durability_level(env, durability, level)) {
-                return 0;
-            }
-
-            KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-            db = new SharedGroup(file_name, no_create != 0, level, key.data());
-#else
-            db = new SharedGroup(file_name, no_create != 0, level);
-#endif
-        }
-        return reinterpret_cast<jlong>(db);
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
-  (JNIEnv* env, jobject, jlong native_replication_ptr, jint durability, jbyteArray keyArray)
-{
-    TR_ENTER()
-
-    SharedGroup::DurabilityLevel level;
-    // Exception thrown for wrong durability value
-    if (!jint_to_durability_level(env, durability, level)) {
-        return 0;
-    }
-
-    try {
-        KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level, key.data());
-#else
-        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level);
-#endif
-        return reinterpret_cast<jlong>(db);
-    }
-    CATCH_FILE()
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplication
-  (JNIEnv* env, jobject, jstring jfile_name, jbyteArray keyArray)
-{
-    TR_ENTER()
-    StringData file_name;
-    try {     
-        JStringAccessor file_name_tmp(env, jfile_name); // throws
-        file_name = StringData(file_name_tmp);
-        KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-        std::unique_ptr<Replication> hist = make_client_history(file_name, key.data());
-#else
-        std::unique_ptr<Replication> hist = make_client_history(file_name);
-#endif
-        return reinterpret_cast<jlong>(hist.release());
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
-  (JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        Group& group = const_cast<Group&>(SG(native_ptr)->begin_read());
-        return reinterpret_cast<jlong>(&group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-(JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        LangBindHelper::advance_read(*SG(native_ptr));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
-(JNIEnv *env, jobject, jlong native_ptr, jlong version, jlong index)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        SharedGroup::VersionID versionId(version, index);
-        LangBindHelper::advance_read(*SG(native_ptr), versionId);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr) 
-    try {
-        LangBindHelper::promote_to_write(*SG(native_ptr));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinueAsRead
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        LangBindHelper::commit_and_continue_as_read( *SG(native_ptr) );
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
-  (JNIEnv *, jobject, jlong native_replication_ptr)
-{
-    TR_ENTER_PTR(native_replication_ptr)
-    delete CH(native_replication_ptr);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose(
-    JNIEnv*, jclass, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    delete SG(native_ptr);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeReserve(
-   JNIEnv *env, jobject, jlong native_ptr, jlong bytes)
-{
-    TR_ENTER_PTR(native_ptr)
-    if (bytes <= 0) {
-        ThrowException(env, UnsupportedOperation, "number of bytes must be > 0.");
-        return;
-    }
-
-    try {
-         SG(native_ptr)->reserve(S(bytes));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginRead(
-    JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        const Group& group = SG(native_ptr)->begin_read();
-        return reinterpret_cast<jlong>(&group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeEndRead(
-    JNIEnv *, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    SG(native_ptr)->end_read();     // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginWrite(
-    JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        Group& group = SG(native_ptr)->begin_write();
-        return reinterpret_cast<jlong>(&group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommit(
-    JNIEnv*, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    SG(native_ptr)->commit();   // noexcept
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback(
-    JNIEnv*, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    SG(native_ptr)->rollback();   // noexcept
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead(
-    JNIEnv *, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    LangBindHelper::rollback_and_continue_as_read(*SG(native_ptr));
-}
-
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeHasChanged
-  (JNIEnv *, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    return SG(native_ptr)->has_changed();   // noexcept
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact(
-    JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        return SG(native_ptr)->compact(); // throws
-    }
-    CATCH_FILE()
-    CATCH_STD()
-    return false;
-}
-
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
-        (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER()
-    SharedGroup::VersionID version_id = SG(native_ptr)->get_version_of_current_transaction();
-
-    jlong version_array [2];
-    version_array[0] = static_cast<jlong>(version_id.version);
-    version_array[1] = static_cast<jlong>(version_id.index);
-
-    jlongArray version_data = env->NewLongArray(2);
-    if (version_data == NULL) {
-        ThrowException(env, OutOfMemory, "Could not allocate memory to return versionID.");
-        return NULL;
-    }
-    env->SetLongArrayRegion(version_data, 0, 2, version_array);
-
-    return version_data;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        return static_cast<jboolean>(SG(native_ptr)->wait_for_change());
-    } CATCH_STD()
-    return false;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        SG(native_ptr)->wait_for_change_release();
-    } CATCH_STD()
-}
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.h b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
deleted file mode 100644
index 2e0dd9d035..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.h
+++ /dev/null
@@ -1,201 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_SharedGroup */
-
-#ifndef _Included_io_realm_internal_SharedGroup
-#define _Included_io_realm_internal_SharedGroup
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef io_realm_internal_SharedGroup_IMPLICIT_TRANSACTION
-#define io_realm_internal_SharedGroup_IMPLICIT_TRANSACTION 1L
-#undef io_realm_internal_SharedGroup_EXPLICIT_TRANSACTION
-#define io_realm_internal_SharedGroup_EXPLICIT_TRANSACTION 0L
-#undef io_realm_internal_SharedGroup_CREATE_FILE_YES
-#define io_realm_internal_SharedGroup_CREATE_FILE_YES 0L
-#undef io_realm_internal_SharedGroup_CREATE_FILE_NO
-#define io_realm_internal_SharedGroup_CREATE_FILE_NO 1L
-#undef io_realm_internal_SharedGroup_ENABLE_REPLICATION
-#define io_realm_internal_SharedGroup_ENABLE_REPLICATION 1L
-#undef io_realm_internal_SharedGroup_DISABLE_REPLICATION
-#define io_realm_internal_SharedGroup_DISABLE_REPLICATION 0L
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    createNativeWithImplicitTransactions
- * Signature: (JI[B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
-  (JNIEnv *, jobject, jlong, jint, jbyteArray);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCreateReplication
- * Signature: (Ljava/lang/String;[B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplication
-  (JNIEnv *, jobject, jstring, jbyteArray);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCommitAndContinueAsRead
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinueAsRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeBeginImplicit
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeReserve
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeReserve
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeHasChanged
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeHasChanged
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeBeginRead
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeEndRead
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeEndRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeBeginWrite
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginWrite
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCommit
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommit
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeRollback
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCreate
- * Signature: (Ljava/lang/String;IZZ[B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate
-  (JNIEnv *, jobject, jstring, jint, jboolean, jboolean, jbyteArray);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCompact
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCloseReplication
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeRollbackAndContinueAsRead
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeGetVersionID
- * Signature: (J)[J
- */
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeWaitForChange
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeStopWaitForChange
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeAdvanceRead
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeAdvanceReadToVersion
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativePromoteToWrite
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
deleted file mode 100644
index 7f0218941d..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Table.h
+++ /dev/null
@@ -1,759 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Table */
-
-#ifndef _Included_io_realm_internal_Table
-#define _Included_io_realm_internal_Table
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef io_realm_internal_Table_TABLE_MAX_LENGTH
-#define io_realm_internal_Table_TABLE_MAX_LENGTH 56L
-#undef io_realm_internal_Table_INFINITE
-#define io_realm_internal_Table_INFINITE -1LL
-#undef io_realm_internal_Table_INTEGER_DEFAULT_VALUE
-#define io_realm_internal_Table_INTEGER_DEFAULT_VALUE 0LL
-#undef io_realm_internal_Table_NULLABLE
-#define io_realm_internal_Table_NULLABLE 1L
-#undef io_realm_internal_Table_NOT_NULLABLE
-#define io_realm_internal_Table_NOT_NULLABLE 0L
-#undef io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX
-#define io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
-#undef io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX
-#define io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX 1LL
-#undef io_realm_internal_Table_NO_PRIMARY_KEY
-#define io_realm_internal_Table_NO_PRIMARY_KEY -2LL
-#undef io_realm_internal_Table_DEBUG
-#define io_realm_internal_Table_DEBUG 0L
-/*
- * Class:     io_realm_internal_Table
- * Method:    createNative
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative
-  (JNIEnv *, jobject);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsValid
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsRootTable
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddColumn
- * Signature: (JILjava/lang/String;Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn
-  (JNIEnv *, jobject, jlong, jint, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddColumnLink
- * Signature: (JILjava/lang/String;J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink
-  (JNIEnv *, jobject, jlong, jint, jstring, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRenameColumn
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveColumn
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsColumnNullable
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeConvertColumnToNullable
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeConvertColumnToNotNullable
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeClear
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemove
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemove
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveLast
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveLast
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMoveLastOver
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddEmptyRow
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow
-  (JNIEnv *, jclass, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSortedView
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSortedViewMulti
- * Signature: (J[J[Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti
-  (JNIEnv *, jobject, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLong
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetBoolean
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetFloat
- * Signature: (JJJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetDouble
- * Signature: (JJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetString
- * Signature: (JJJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetByteArray
- * Signature: (JJJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLink
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLinkView
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView
-  (JNIEnv *, jclass, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLinkTarget
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetRowPtr
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetLong
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong
-  (JNIEnv *, jclass, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetBoolean
- * Signature: (JJJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean
-  (JNIEnv *, jclass, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetFloat
- * Signature: (JJJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat
-  (JNIEnv *, jclass, jlong, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetDouble
- * Signature: (JJJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble
-  (JNIEnv *, jclass, jlong, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetTimestamp
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp
-  (JNIEnv *, jclass, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetString
- * Signature: (JJJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString
-  (JNIEnv *, jclass, jlong, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetNull
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull
-  (JNIEnv *, jclass, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetByteArray
- * Signature: (JJJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray
-  (JNIEnv *, jclass, jlong, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetLink
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv *, jclass, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetPrimaryKey
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMigratePrimaryKeyTableIfNeeded
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddSearchIndex
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveSearchIndex
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeHasSearchIndex
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSearchIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsNullLink
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeNullifyLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink
-  (JNIEnv *, jclass, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAverageInt
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSumFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMaximumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMinimumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAverageFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMaximumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMinimumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAverageDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountLong
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeWhere
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt
-  (JNIEnv *, jclass, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString
-  (JNIEnv *, jclass, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstNull
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull
-  (JNIEnv *, jclass, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeLowerBoundInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLowerBoundInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeUpperBoundInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativePivot
- * Signature: (JJJIJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativePivot
-  (JNIEnv *, jobject, jlong, jlong, jlong, jint, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetDistinctView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetName
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeOptimize
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeToJson
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeHasSameSchema
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeVersion
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.h b/realm/realm-jni/src/io_realm_internal_TableQuery.h
deleted file mode 100644
index 129da77a12..0000000000
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.h
+++ /dev/null
@@ -1,605 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_TableQuery */
-
-#ifndef _Included_io_realm_internal_TableQuery
-#define _Included_io_realm_internal_TableQuery
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeValidateQuery
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeTableview
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeTableview
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGroup
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEndGroup
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeOr
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeOr
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNot
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreater
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLess
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetween
- * Signature: (J[JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreater
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLess
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetween
- * Signature: (J[JFF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreater
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLess
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetween
- * Signature: (J[JDD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ
-  (JNIEnv *, jobject, jlong, jlongArray, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetweenTimestamp
- * Signature: (J[JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[J[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3B
-  (JNIEnv *, jobject, jlong, jlongArray, jbyteArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[J[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B
-  (JNIEnv *, jobject, jlong, jlongArray, jbyteArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBeginsWith
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEndsWith
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeContains
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsEmpty
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFind
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAll
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSumInt
- * Signature: (JJJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumInt
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumInt
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeAverageInt
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSumFloat
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumFloat
- * Signature: (JJJJJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumFloat
- * Signature: (JJJJJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeAverageFloat
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSumDouble
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumDouble
- * Signature: (JJJJJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumDouble
- * Signature: (JJJJJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeAverageDouble
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumTimestamp
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumTimestamp
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsNull
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsNotNull
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeCount
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeRemove
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeImportHandoverTableViewIntoSharedGroup
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeHandoverQuery
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllSortedWithHandover
- * Signature: (JJJJJJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *, jclass, jlong, jlong, jlong, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllWithHandover
- * Signature: (JJJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv *, jclass, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGetDistinctViewWithHandover
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-  (JNIEnv *, jclass, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindWithHandover
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
-  (JNIEnv *, jclass, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllMultiSortedWithHandover
- * Signature: (JJJJJ[J[Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *, jclass, jlong, jlong, jlong, jlong, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeImportHandoverRowIntoSharedGroup
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
-  (JNIEnv *, jclass, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeCloseQueryHandover
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBatchUpdateQueries
- * Signature: (J[J[[J[[J[[Z)[J
- */
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-  (JNIEnv *, jclass, jlong, jlongArray, jobjectArray, jobjectArray, jobjectArray);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
deleted file mode 100644
index fb1cfb53fe..0000000000
--- a/realm/realm-jni/src/io_realm_internal_TableView.h
+++ /dev/null
@@ -1,527 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_TableView */
-
-#ifndef _Included_io_realm_internal_TableView
-#define _Included_io_realm_internal_TableView
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef io_realm_internal_TableView_DEBUG
-#define io_realm_internal_TableView_DEBUG 0L
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetSourceRowIndex
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSourceRowIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetLong
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetBoolean
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetFloat
- * Signature: (JJJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetDouble
- * Signature: (JJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetString
- * Signature: (JJJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetByteArray
- * Signature: (JJJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetLink
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetLong
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetBoolean
- * Signature: (JJJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetFloat
- * Signature: (JJJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetDouble
- * Signature: (JJJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetTimestampValue
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetString
- * Signature: (JJJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetByteArray
- * Signature: (JJJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetLink
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeIsNullLink
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeNullifyLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeClear
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClear
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeRemoveRow
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeRemoveRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstDate
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllDate
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindBySourceNdx
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumInt
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumInt
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAverageInt
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSumFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumFloat
- * Signature: (JJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumFloat
- * Signature: (JJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAverageFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumDouble
- * Signature: (JJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumDouble
- * Signature: (JJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAverageDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumTimestamp
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumTimestamp
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSort
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSortMulti
- * Signature: (J[J[Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti
-  (JNIEnv *, jobject, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    createNativeTableView
- * Signature: (Lio/realm/internal/Table;J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView
-  (JNIEnv *, jobject, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeToJson
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeWhere
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativePivot
- * Signature: (JJJIJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot
-  (JNIEnv *, jobject, jlong, jlong, jlong, jint, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeDistinct
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSyncIfNeeded
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeDistinctMulti
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSync
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
deleted file mode 100644
index 267be9e485..0000000000
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
+++ /dev/null
@@ -1,245 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_UncheckedRow */
-
-#ifndef _Included_io_realm_internal_UncheckedRow
-#define _Included_io_realm_internal_UncheckedRow
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetIndex
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetLong
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetBoolean
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeIsNullLink
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetByteArray
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetLinkView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv *, jclass, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetLong
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetBoolean
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetFloat
- * Signature: (JJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetLink
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetDouble
- * Signature: (JJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetTimestamp
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetString
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetByteArray
- * Signature: (JJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeNullifyLink
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeIsAttached
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeHasColumn
- * Signature: (JLjava/lang/String;)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeIsNull
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetNull
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
-  (JNIEnv *, jobject, jlong, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Util.cpp b/realm/realm-jni/src/io_realm_internal_Util.cpp
deleted file mode 100644
index 49eb55f255..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Util.cpp
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-
-#include <realm/string_data.hpp>
-#include <realm/unicode.hpp>
-
-#include "util.hpp"
-#include "mem_usage.hpp"
-#include "io_realm_internal_Util.h"
-
-using std::string;
-
-//#define USE_VLD
-#if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
-    #include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
-#endif
-
-// used by logging
-int trace_level = 0;
-const char* log_tag = "REALM";
-
-const string TABLE_PREFIX("class_");
-
-
-JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
-{
-    JNIEnv* env;
-    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
-        return JNI_ERR;
-    }
-    else {
-        // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
-        java_lang_long        = GetClass(env, "java/lang/Long");
-        java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
-        java_lang_float       = GetClass(env, "java/lang/Float");
-        java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
-        java_lang_double      = GetClass(env, "java/lang/Double");
-        java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
-    }
-
-    return JNI_VERSION_1_6;
-}
-
-JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
-{
-    JNIEnv* env;
-    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
-        return;
-    }
-    else {
-        env->DeleteGlobalRef(java_lang_long);
-        env->DeleteGlobalRef(java_lang_float);
-        env->DeleteGlobalRef(java_lang_double);
-    }
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel(JNIEnv*, jclass, jint level)
-{
-    trace_level = level;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
-{
-    return GetMemUsage();
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
-    JNIEnv* env, jclass)
-{
-    realm::StringData sd(TABLE_PREFIX);
-    return to_jstring(env, sd);
-}
-
-// -------------------------- Testcases for exception handling
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
-    JNIEnv *env, jclass, jint testcase, jboolean dotest, jlong)
-{
-    string expect;
-
-    switch (ExceptionKind(testcase)) {
-        case ClassNotFound:
-            expect = "java.lang.ClassNotFoundException: Class 'parm1' could not be located.";
-            if (dotest)
-                ThrowException(env, ClassNotFound, "parm1", "parm2");
-            break;
-        case NoSuchField:
-            expect = "java.lang.NoSuchFieldException: Field 'parm2' could not be located in class io.realm.parm1";
-            if (dotest)
-                ThrowException(env, NoSuchField, "parm1", "parm2");
-            break;
-        case NoSuchMethod:
-            expect = "java.lang.NoSuchMethodException: Method 'parm2' could not be located in class io.realm.parm1";
-            if (dotest)
-                ThrowException(env, NoSuchMethod, "parm1", "parm2");
-            break;
-        case IllegalArgument:
-            expect = "java.lang.IllegalArgumentException: Illegal Argument: parm1";
-            if (dotest)
-                ThrowException(env, IllegalArgument, "parm1", "parm2");
-            break;
-        case IOFailed:
-            expect = "io.realm.exceptions.RealmIOException: Failed to open parm1. parm2";
-            if (dotest)
-                ThrowException(env, IOFailed, "parm1", "parm2");
-            break;
-        case FileNotFound:
-            expect = "io.realm.exceptions.RealmIOException: File not found: parm1.";
-            if (dotest)
-                ThrowException(env, FileNotFound, "parm1", "parm2");
-            break;
-        case FileAccessError:
-            expect = "io.realm.exceptions.RealmIOException: Failed to access: parm1. parm2";
-            if (dotest)
-                ThrowException(env, FileAccessError, "parm1", "parm2");
-            break;
-        case IndexOutOfBounds:
-            expect = "java.lang.ArrayIndexOutOfBoundsException: parm1";
-            if (dotest)
-                ThrowException(env, IndexOutOfBounds, "parm1", "parm2");
-            break;
-        case TableInvalid:
-            expect = "java.lang.IllegalStateException: Illegal State: parm1";
-            if (dotest)
-                ThrowException(env, TableInvalid, "parm1", "parm2");
-            break;
-        case UnsupportedOperation:
-            expect = "java.lang.UnsupportedOperationException: parm1";
-            if (dotest)
-                ThrowException(env, UnsupportedOperation, "parm1", "parm2");
-            break;
-        case OutOfMemory:
-            expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
-            if (dotest)
-                ThrowException(env, OutOfMemory, "parm1", "parm2");
-            break;
-        case FatalError:
-            expect = "io.realm.exceptions.RealmError: Unrecoverable error. parm1";
-            if (dotest)
-                ThrowException(env, FatalError, "parm1", "parm2");
-            break;
-        case RuntimeError:
-            expect = "java.lang.RuntimeException: parm1";
-            if (dotest)
-                ThrowException(env, RuntimeError, "parm1", "parm2");
-            break;
-        case RowInvalid:
-            expect = "java.lang.IllegalStateException: Illegal State: parm1";
-            if (dotest)
-                ThrowException(env, RowInvalid, "parm1", "parm2");
-            break;
-        case CrossTableLink:
-            expect = "java.lang.IllegalStateException: This class is referenced by other classes. Remove those fields first before removing this class.";
-            if (dotest)
-                ThrowException(env, CrossTableLink, "parm1");
-            break;
-        case BadVersion:
-            expect = "io.realm.internal.async.BadVersionException: parm1";
-            if (dotest)
-                ThrowException(env, BadVersion, "parm1", "parm2");
-            break;
-        case LockFileError:
-            expect = "io.realm.exceptions.IncompatibleLockFileException: parm1";
-            if (dotest)
-                ThrowException(env, LockFileError, "parm1", "parm2");
-            break;
-
-
-    }
-    if (dotest) {
-        return NULL;
-    }
-    return to_jstring(env, expect);
-}
-
diff --git a/realm/realm-jni/src/io_realm_internal_Util.h b/realm/realm-jni/src/io_realm_internal_Util.h
deleted file mode 100644
index 8a41d65d19..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Util.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Util */
-
-#ifndef _Included_io_realm_internal_Util
-#define _Included_io_realm_internal_Util
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeGetMemUsage
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage
-  (JNIEnv *, jclass);
-
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeSetDebugLevel
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel
-  (JNIEnv *, jclass, jint);
-
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeGetTablePrefix
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix
-  (JNIEnv *, jclass);
-
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeTestcase
- * Signature: (IZJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase
-  (JNIEnv *, jclass, jint, jboolean, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/java_lang_List_Util.cpp b/realm/realm-jni/src/java_lang_List_Util.cpp
deleted file mode 100644
index d1a1853b28..0000000000
--- a/realm/realm-jni/src/java_lang_List_Util.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "java_lang_List_Util.hpp"
-
-jint java_lang_List_size(JNIEnv* env, jobject jList)
-{
-    // WARNING: do not cache these methods, list class may be different based on the object jlist
-    jclass jListClass = env->GetObjectClass(jList);
-    if (jListClass == NULL)
-        return 0;
-    jmethodID jListSizeMethodId = env->GetMethodID(jListClass, "size", "()I");
-    if (jListSizeMethodId == NULL) {
-        ThrowException(env, NoSuchMethod, "jList", "size");
-        return 0;
-    }
-    return env->CallIntMethod(jList, jListSizeMethodId);
-}
-
-jobject java_lang_List_get(JNIEnv* env, jobject jList, jint index)
-{
-    // WARNING: do not cache these methods/classes, list class may be different based on the object jlist
-    jclass jListClass = env->GetObjectClass(jList);
-     if (jListClass == NULL)
-        return NULL;
-    jmethodID jListGetMethodId = env->GetMethodID(jListClass, "get", "(I)Ljava/lang/Object;");
-    if (jListGetMethodId == NULL) {
-        ThrowException(env, NoSuchMethod, "jList", "get");
-        return NULL;
-    }
-    return env->CallObjectMethod(jList, jListGetMethodId, index);
-}
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index d3127e906f..a0810cb77c 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -1,13 +1,36 @@
+import java.security.MessageDigest
+
 apply plugin: 'com.android.library'
-apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'com.github.dcendents.android-maven'
 apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
-apply plugin: 'com.jfrog.bintray'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
 apply plugin: 'checkstyle'
 apply plugin: 'com.github.kt3k.coveralls'
+apply plugin: 'de.undercouch.download'
+
+def properties = new Properties()
+properties.load(new FileInputStream("${projectDir}/../../dependencies.list"))
+
+ext.coreVersion = properties.getProperty('REALM_SYNC_VERSION')
+// empty or comment out this to disable hash checking
+ext.coreSha256Hash = properties.getProperty('REALM_SYNC_SHA256')
+ext.forceDownloadCore =
+        project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
+// Set the core source code path. By setting this, the core will be built from source. And coreVersion will be read from
+// core source code.
+ext.coreSourcePath = project.hasProperty('coreSourcePath') ? project.getProperty('coreSourcePath') : null
+// The location of core archive.
+ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
+if (!ext.coreArchiveDir) {
+    ext.coreArchiveDir = ".."
+}
+ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/realm-sync-android-${project.coreVersion}.tar.gz")
+ext.coreDistributionDir = file("${projectDir}/distribution/realm-core/")
+ext.coreDir = file("${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
+ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE')
+ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
 
 android {
     compileSdkVersion 24
@@ -16,9 +39,34 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion 24
+        versionName version
         project.archivesBaseName = "realm-android-library"
-        consumerProguardFiles 'proguard-rules.pro'
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        externalNativeBuild {
+            cmake {
+                arguments "-DREALM_CORE_DIST_DIR:STRING=${project.coreDir.getAbsolutePath()}",
+                          // FIXME:
+                          // This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
+                          // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
+                          // JNI build currently (lack of lto linking support).
+                          // This file should be removed and use the one from Android SDK cmake package when it supports lto.
+                        "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
+                if (project.ccachePath) arguments "-DNDK_CCACHE=$project.ccachePath"
+                if (project.lcachePath) arguments "-DNDK_LCACHE=$project.lcachePath"
+                if (project.hasProperty('buildTargetABIs')) {
+                    abiFilters(*project.getProperty('buildTargetABIs').trim().split('\\s*,\\s*'))
+                } else {
+                    // armeabi is not supported anymore.
+                    abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a', 'mips'
+                }
+            }
+        }
+    }
+
+    externalNativeBuild {
+        cmake {
+            path 'src/main/cpp/CMakeLists.txt'
+        }
     }
 
     buildTypes {
@@ -31,6 +79,9 @@ android {
         androidTest {
             java.srcDirs += 'src/benchmarks/java'
         }
+        androidTestObjectServer {
+            java.srcDirs += 'src/syncIntegrationTest/java'
+        }
     }
 
     packagingOptions {
@@ -41,8 +92,26 @@ android {
     lintOptions {
         abortOnError false
     }
-}
 
+    productFlavors {
+        base {
+            externalNativeBuild {
+                cmake {
+                    arguments "-DREALM_FLAVOR=base"
+                }
+            }
+            consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-base.pro'
+        }
+        objectServer {
+            externalNativeBuild {
+                cmake {
+                    arguments "-DREALM_FLAVOR=objectServer"
+                }
+            }
+            consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-objectServer.pro'
+        }
+    }
+}
 
 coveralls.jacocoReportPath = "${buildDir}/reports/coverage/debug/report.xml"
 
@@ -55,28 +124,36 @@ repositories {
 }
 
 dependencies {
+    objectServerAnnotationProcessor project(':realm-annotations-processor')
     provided 'io.reactivex:rxjava:1.1.0'
     compile "io.realm:realm-annotations:${version}"
-    compile 'com.getkeepsafe.relinker:relinker:1.2.1'
-
+    compile 'com.getkeepsafe.relinker:relinker:1.2.2'
+    objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
     androidTestCompile 'com.android.support:support-annotations:24.0.0'
     androidTestCompile 'com.android.support.test:runner:0.5'
     androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
     androidTestCompile 'com.opencsv:opencsv:3.4'
     androidTestCompile 'dk.ilios:spanner:0.6.0'
-
-    androidTestApt project(':realm-annotations-processor')
+    androidTestAnnotationProcessor project(':realm-annotations-processor')
 }
 
 task sourcesJar(type: Jar) {
+    from android.sourceSets.objectServer.java.srcDirs
     from android.sourceSets.main.java.srcDirs
     classifier = 'sources'
 }
 
+def betaTag = 'Beta:a:<div style="border-style:solid;border-width:2px">This software is considered in beta phase. ' +
+        'It indicates that any public interface can change without prior announcements. ' +
+        'Moreover, classes, constructors, and methods annotated as beta are not ' +
+        'considered at production quality, and should be used with care.</div>'
+
 task javadoc(type: Javadoc) {
+    source android.sourceSets.objectServer.java.srcDirs
     source android.sourceSets.main.java.srcDirs
     source "../../realm-annotations/src/main/java"
     classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
@@ -89,9 +166,11 @@ task javadoc(type: Javadoc) {
         locale = 'en_US'
         overview = 'src/overview.html'
 
-        links "http://docs.oracle.com/javase/7/docs/api/"
+        links "https://docs.oracle.com/javase/7/docs/api/"
         links "http://reactivex.io/RxJava/javadoc/"
-        linksOffline "http://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
+        linksOffline "https://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
+
+        tags = [ betaTag ]
     }
     exclude '**/internal/**'
     exclude '**/BuildConfig.java'
@@ -109,10 +188,8 @@ task javadocJar(type: Jar, dependsOn: javadoc) {
     from javadoc.destinationDir
 }
 
-preBuild.dependsOn ':realm-jni:buildAndroidJni'
-
 task findbugs(type: FindBugs) {
-    dependsOn assembleDebug
+    dependsOn assemble
     group = 'Verification'
 
     ignoreFailures = false
@@ -139,7 +216,6 @@ task pmd(type: Pmd) {
 
     source = fileTree('src/main/java')
     ruleSetFiles = files("${projectDir}/../config/pmd/ruleset.xml")
-    ruleSets = [] // This needs to be here to remove the default checks
 
     reports {
         xml.enabled = false
@@ -216,25 +292,70 @@ install {
     }
 }
 
-bintray {
-    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
-    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+// The publications doesn't know about our AAR dependencies, so we have to manually add them to the pom
+// Credit: http://stackoverflow.com/questions/24743562/gradle-not-including-dependencies-in-published-pom-xml
+def createPomDependencies(configurationNames) {
+    return {
+        def dependenciesNode = asNode().appendNode('dependencies')
+        configurationNames.each { configurationName ->
+            configurations[configurationName].allDependencies.each {
+                if (it.group != null && it.name != null) {
+                    def dependencyNode = dependenciesNode.appendNode('dependency')
+                    dependencyNode.appendNode('groupId', it.group)
+                    dependencyNode.appendNode('artifactId', it.name)
+                    dependencyNode.appendNode('version', it.version)
+
+                    //If there are any exclusions in dependency
+                    if (it.excludeRules.size() > 0) {
+                        def exclusionsNode = dependencyNode.appendNode('exclusions')
+                        it.excludeRules.each { rule ->
+                            def exclusionNode = exclusionsNode.appendNode('exclusion')
+                            exclusionNode.appendNode('groupId', rule.group)
+                            exclusionNode.appendNode('artifactId', rule.module)
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
 
-    dryRun = false
-    publish = false
+publishing {
+    publications {
+        basePublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android-library'
+            version project.version
+            artifact file("${rootDir}/realm-library/build/outputs/aar/realm-android-library-base-release.aar")
+            artifact sourcesJar
+            artifact javadocJar
+
+            pom.withXml(createPomDependencies(["baseCompile", "compile"]))
+        }
 
-    configurations = ['archives']
+        objectServerPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android-library-object-server'
+            version project.version
+            artifact file("${rootDir}/realm-library/build/outputs/aar/realm-android-library-objectServer-release.aar")
+            artifact sourcesJar
+            artifact javadocJar
 
-    pkg {
-        repo = 'maven'
-        name = 'realm-android-library'
-        desc = 'Realm for Android'
-        websiteUrl = 'http://realm.io'
-        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
-        vcsUrl = 'https://github.com/realm/realm-java.git'
-        licenses = ['Apache-2.0']
-        labels = ['android', 'realm']
-        publicDownloadNumbers = false
+            pom.withXml(createPomDependencies(["objectServerCompile", "compile"]))
+        }
+    }
+    repositories {
+        maven {
+            credentials(AwsCredentials) {
+                accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
+                secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
+            }
+            if(project.version.endsWith('-SNAPSHOT')) {
+                url "s3://realm-ci-artifacts/maven/snapshots/"
+            } else {
+                url "s3://realm-ci-artifacts/maven/releases/"
+            }
+        }
     }
 }
 
@@ -245,10 +366,9 @@ artifactory {
             repoKey = 'oss-snapshot-local'
             username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
             password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
-            maven = true
         }
         defaults {
-            publishConfigs('archives')
+            publications('basePublication', 'objectServerPublication')
             publishPom = true
             publishIvy = false
         }
@@ -259,3 +379,352 @@ artifacts {
     archives javadocJar
     archives sourcesJar
 }
+
+
+def coreDownloaded = false
+
+task downloadCore() {
+    group = 'build setup'
+    description = 'Download the latest version of Realm Core'
+    def isHashCheckingEnabled = {
+        return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
+    }
+
+    def calcSha256Hash = {File targetFile ->
+        MessageDigest sha = MessageDigest.getInstance("SHA-256")
+        Formatter hexHash = new Formatter()
+        sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
+        return hexHash.toString()
+    }
+
+    def shouldDownloadCore = {
+        if (!project.coreArchiveFile.exists()) {
+            return true
+        }
+        if (project.forceDownloadCore) {
+            return true;
+        }
+        if (!isHashCheckingEnabled()) {
+            println "Skipping hash check(empty \'coreSha256Hash\')."
+            return false
+        }
+
+        def calculatedHash = calcSha256Hash(project.coreArchiveFile)
+        if (project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
+            return false
+        }
+
+        println "Existing archive hash mismatch (Expected: ${project.coreSha256Hash.toLowerCase()}" +
+                " but got ${calculatedHash.toLowerCase()}). Download new version."
+        return true
+    }
+
+    doLast {
+        if (shouldDownloadCore()) {
+            download {
+                src "http://static.realm.io/downloads/sync/realm-sync-android-${project.coreVersion}.tar.gz"
+                dest project.coreArchiveFile
+                onlyIfNewer false
+            }
+            coreDownloaded = true
+
+            if (isHashCheckingEnabled()) {
+                def calculatedHash = calcSha256Hash(project.coreArchiveFile)
+                if (!project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
+                    throw new GradleException("Invalid checksum for file '" +
+                            "${project.coreArchiveFile.getName()}'. Expected " +
+                            "${project.coreSha256Hash.toLowerCase()} but got " +
+                            "${calculatedHash.toLowerCase()}.");
+                }
+            } else {
+                println 'Skipping hash check (empty \'coreSha256Hash\').'
+            }
+        }
+    }
+}
+
+task compileCore(group: 'build setup', description: 'Compile the core library from source code') {
+    // Build the library from core source code
+    doFirst {
+        if (!coreSourcePath) {
+            throw new GradleException('The coreSourcePath is not set.')
+        }
+        exec {
+            workingDir = coreSourcePath
+            commandLine = [
+                    "bash",
+                    "build.sh",
+                    "build-android"
+            ]
+        }
+    }
+
+    // Copy the core tar ball
+    doLast {
+        copy {
+            from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
+            into project.coreArchiveFile.parent
+            rename "realm-core-android-${coreVersion}.tar.gz", "realm-sync-android-${coreVersion}.tar.gz"
+        }
+    }
+}
+
+task deployCore(group: 'build setup', description: 'Deploy the latest version of Realm Core') {
+    dependsOn {
+        coreSourcePath ? compileCore : downloadCore
+    }
+
+    outputs.upToDateWhen {
+        // Clean up the coreDir if it is newly downloaded or compiled from source
+        if (coreDownloaded || coreSourcePath) {
+            return false
+        }
+
+        return project.coreDir.exists()
+    }
+
+    doLast {
+        // Delete all files to avoid multiple copies of the same header file in Android Studio.
+        exec {
+            commandLine = [
+                    'rm',
+                    '-rf',
+                    project.coreDistributionDir.getAbsolutePath()
+            ]
+        }
+        copy {
+            from tarTree(project.coreArchiveFile)
+            into project.coreDir
+        }
+    }
+}
+
+publishToMavenLocal.dependsOn assemble
+preBuild.dependsOn deployCore
+
+if (project.hasProperty('dontCleanJniFiles')) {
+    project.afterEvaluate {
+        tasks.all { task ->
+            if (task.name.startsWith('externalNativeBuildClean')) {
+                task.enabled = false
+            }
+        }
+    }
+} else {
+    task cleanExternalBuildFiles(type: Delete) {
+        delete project.file('.externalNativeBuild')
+        // Clean .so files that were created by old build script (realm/realm-jni/build.gradle).
+        delete project.file('src/main/jniLibs')
+    }
+    clean.dependsOn cleanExternalBuildFiles
+}
+
+project.afterEvaluate {
+    android.libraryVariants.all { variant ->
+        variant.externalNativeBuildTasks[0].dependsOn(checkNdk)
+    }
+}
+
+task checkNdk() << {
+    def ndkPathInEnvVariable = System.env.ANDROID_NDK_HOME
+    if (!ndkPathInEnvVariable) {
+        throw new GradleException("The environment variable 'ANDROID_NDK_HOME' must be set.")
+    }
+    checkNdk(ndkPathInEnvVariable)
+
+    def localPropFile = rootProject.file('local.properties')
+    if (!localPropFile.exists()) {
+        // we can skip the checks since 'ANDROID_NDK_HOME' will be used instead.
+    } else {
+        def String ndkPathInLocalProperties = getValueFromPropertiesFile(localPropFile, 'ndk.dir')
+        if (!ndkPathInLocalProperties) {
+            throw new GradleException("'ndk.dir' must be set in ${localPropFile.getAbsolutePath()}.")
+        }
+        checkNdk(ndkPathInLocalProperties)
+        if (new File(ndkPathInLocalProperties).getCanonicalPath()
+                != new File(ndkPathInEnvVariable).getCanonicalPath()) {
+            throw new GradleException(
+                    "The value of environment variable 'ANDROID_NDK_HOME' (${ndkPathInEnvVariable}) and"
+                            + " 'ndk.dir' in 'local.properties' (${ndkPathInLocalProperties}) "
+                            + ' must point the same directory.')
+        }
+    }
+}
+
+android.productFlavors.all { flavor ->
+    def librarySuffix = flavor.name == 'base' ? '' : '-object-server'
+    def userName = project.findProperty('bintrayUser') ?: 'noUser'
+    def accessKey = project.findProperty('bintrayKey') ?: 'noKey'
+
+    // BINTRAY
+
+    task("bintrayAar${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "assemble${flavor.name.capitalize()}"
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+    }
+
+    task("bintraySources${flavor.name.capitalize()}", type: Exec) {
+        dependsOn sourcesJar
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+    }
+
+    task("bintrayJavadoc${flavor.name.capitalize()}", type: Exec) {
+        dependsOn javadocJar
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+    }
+
+    task("bintrayPom${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
+        group = 'Publishing'
+        commandLine 'curl',
+            '-X',
+            'PUT',
+            '-T',
+            "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+            '-u',
+            "${userName}:${accessKey}",
+            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+    }
+
+    // OJO
+
+    task("ojoAar${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "assemble${flavor.name.capitalize()}"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+    }
+
+    task("ojoSources${flavor.name.capitalize()}", type: Exec) {
+        dependsOn sourcesJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+    }
+
+    task("ojoJavadoc${flavor.name.capitalize()}", type: Exec) {
+        dependsOn javadocJar
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+    }
+
+    task("ojoPom${flavor.name.capitalize()}", type: Exec) {
+        dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
+        group = 'Publishing'
+        commandLine 'curl',
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://oss.jfrog.org/artifactory/oss-snapshot-local/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+    }
+
+    task("bintray${flavor.name.capitalize()}") {
+        dependsOn "bintrayAar${flavor.name.capitalize()}"
+        dependsOn "bintraySources${flavor.name.capitalize()}"
+        dependsOn "bintrayJavadoc${flavor.name.capitalize()}"
+        dependsOn "bintrayPom${flavor.name.capitalize()}"
+        group = 'Publishing'
+    }
+
+    task("ojo${flavor.name.capitalize()}") {
+        dependsOn "ojoAar${flavor.name.capitalize()}"
+        dependsOn "ojoSources${flavor.name.capitalize()}"
+        dependsOn "ojoJavadoc${flavor.name.capitalize()}"
+        dependsOn "ojoPom${flavor.name.capitalize()}"
+        group = 'Publishing'
+    }
+}
+
+task bintrayUpload() {
+    android.productFlavors.all { flavor ->
+        dependsOn "bintray${flavor.name.capitalize()}"
+    }
+    group = 'Publishing'
+}
+
+task ojoUpload() {
+    android.productFlavors.all { flavor ->
+        dependsOn "ojo${flavor.name.capitalize()}"
+    }
+    group = 'Publishing'
+}
+
+def checkNdk(String ndkPath) {
+    def detectedNdkVersion
+    def releaseFile = new File(ndkPath, 'RELEASE.TXT')
+    def propertyFile = new File(ndkPath, 'source.properties')
+    if (releaseFile.isFile()) {
+        detectedNdkVersion = releaseFile.text.trim().split()[0].split('-')[0]
+    } else if (propertyFile.isFile()) {
+        detectedNdkVersion = getValueFromPropertiesFile(propertyFile, 'Pkg.Revision')
+        if (detectedNdkVersion == null) {
+            throw new GradleException("Failed to obtain the NDK version information from ${ndkPath}/source.properties")
+        }
+    } else {
+        throw new GradleException("Neither ${releaseFile.getAbsolutePath()} nor ${propertyFile.getAbsolutePath()} is a file.")
+    }
+    if (detectedNdkVersion != project.ndkVersion) {
+        throw new GradleException("Your NDK version: ${detectedNdkVersion}."
+                +" Realm JNI must be compiled with the version ${project.ndkVersion} of NDK.")
+    }
+}
+
+def getValueFromPropertiesFile(File propFile, String key) {
+    if (!propFile.isFile() || !propFile.canRead()) {
+        return null
+    }
+    def prop = new Properties()
+    def reader = propFile.newReader()
+    try {
+        prop.load(reader)
+    } finally {
+        reader.close()
+    }
+    return prop.get(key)
+}
diff --git a/realm/realm-library/proguard-rules-base.pro b/realm/realm-library/proguard-rules-base.pro
new file mode 100644
index 0000000000..26e41702f8
--- /dev/null
+++ b/realm/realm-library/proguard-rules-base.pro
@@ -0,0 +1,2 @@
+# It's OK not to exist SyncObjectServerFacade in base library.
+-dontnote io.realm.internal.objectserver.SyncObjectServerFacade
diff --git a/realm/realm-library/proguard-rules.pro b/realm/realm-library/proguard-rules-common.pro
similarity index 61%
rename from realm/realm-library/proguard-rules.pro
rename to realm/realm-library/proguard-rules-common.pro
index 2ad1784f1a..fb972bb245 100644
--- a/realm/realm-library/proguard-rules.pro
+++ b/realm/realm-library/proguard-rules-common.pro
@@ -1,11 +1,18 @@
 -keep class io.realm.annotations.RealmModule
 -keep @io.realm.annotations.RealmModule class *
+
 -keep class io.realm.internal.Keep
 -keep @io.realm.internal.Keep class * { *; }
+
+-keep class io.realm.internal.KeepMember
+-keep @io.realm.internal.KeepMember class * { @io.realm.internal.KeepMember *; }
+
 -dontwarn javax.**
 -dontwarn io.realm.**
 -keep class io.realm.RealmCollection
 -keep class io.realm.OrderedRealmCollection
--keepclasseswithmembernames class io.realm.internal.** {
+-keepclasseswithmembernames class io.realm.** {
     native <methods>;
 }
+
+-dontnote rx.Observable
diff --git a/realm/realm-library/proguard-rules-objectServer.pro b/realm/realm-library/proguard-rules-objectServer.pro
new file mode 100644
index 0000000000..d4b249abb8
--- /dev/null
+++ b/realm/realm-library/proguard-rules-objectServer.pro
@@ -0,0 +1,7 @@
+-dontnote android.security.KeyStore
+-dontwarn okio.Okio
+-dontwarn okio.DeflaterSink
+
+-dontnote com.android.org.conscrypt.SSLParametersImpl
+-dontnote org.apache.harmony.xnet.provider.jsse.SSLParametersImpl
+-dontnote sun.security.ssl.SSLContextImpl
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index 357f8f7ef8..c7741a695f 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -3,12 +3,14 @@
           xmlns:android="http://schemas.android.com/apk/res/android"
           xmlns:tools="http://schemas.android.com/tools">
 
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
 
     <uses-sdk tools:overrideLibrary="dk.ilios.spanner"/>
     <uses-sdk
-        android:minSdkVersion="16"
+        android:minSdkVersion="9"
         android:targetSdkVersion="22"/>
 
     <application>
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index 0d64918ed8..ee6946c1f9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -17,7 +17,6 @@
 package io.realm;
 
 import android.support.test.runner.AndroidJUnit4;
-import android.util.Log;
 
 import org.junit.After;
 import org.junit.Before;
@@ -44,6 +43,7 @@
 import io.realm.entities.HumanModule;
 import io.realm.entities.NoPrimaryKeyWithPrimaryKeyObjectRelation;
 import io.realm.entities.NullTypes;
+import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsLong;
 import io.realm.entities.PrimaryKeyAsString;
@@ -88,6 +88,7 @@ public void tearDown() {
     public void insert() {
         AllJavaTypes obj = new AllJavaTypes();
         obj.setFieldIgnored("cookie");
+        obj.setFieldId(42);
         obj.setFieldLong(42);
         obj.setFieldString("obj1");
 
@@ -98,6 +99,7 @@ public void insert() {
 
         AllJavaTypes allTypes = new AllJavaTypes();
         allTypes.setFieldString("String");
+        allTypes.setFieldId(1L);
         allTypes.setFieldLong(1L);
         allTypes.setFieldFloat(1F);
         allTypes.setFieldDouble(1D);
@@ -291,6 +293,46 @@ public void insertOrUpdate_cyclicType() {
         assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
     }
 
+    @Test
+    public void insertOrUpdate_cyclicDependenciesFromOtherRealm() {
+        RealmConfiguration config1 = configFactory.createConfiguration("realm1");
+        RealmConfiguration config2 = configFactory.createConfiguration("realm2");
+
+        Realm realm1 = Realm.getInstance(config1);
+        Realm realm2 = Realm.getInstance(config2);
+
+        realm1.beginTransaction();
+        Owner owner = realm1.createObject(Owner.class);
+        owner.setName("Kiba");
+        Dog dog = realm1.createObject(Dog.class);
+        dog.setName("Akamaru");
+        owner.getDogs().add(dog);
+        dog.setOwner(owner);
+        realm1.commitTransaction();
+
+        //Copy object with relations from realm1 to realm2
+        realm2.beginTransaction();
+        realm2.insertOrUpdate(owner);
+        realm2.commitTransaction();
+
+        assertEquals(1, realm1.where(Owner.class).count());
+        assertEquals(1, realm1.where(Owner.class).findFirst().getDogs().size());
+        assertEquals(1, realm1.where(Dog.class).count());
+
+        assertEquals(realm1.where(Owner.class).count(), realm2.where(Owner.class).count());
+        assertEquals(realm1.where(Dog.class).count(), realm2.where(Dog.class).count());
+
+        assertEquals(1, realm2.where(Owner.class).findFirst().getDogs().size());
+
+        assertEquals(realm1.where(Owner.class).findFirst().getName(), realm2.where(Owner.class).findFirst().getName());
+
+        assertEquals(realm1.where(Owner.class).findFirst().getDogs().first().getName()
+                , realm2.where(Owner.class).findFirst().getDogs().first().getName());
+
+        realm1.close();
+        realm2.close();
+    }
+
     @Test
     public void insert_nullPrimaryKey() {
         PrimaryKeyAsString primaryKeyAsString = new PrimaryKeyAsString();
@@ -765,6 +807,7 @@ public void insert_listWithNullElement() {
     @Test
     public void insertOrUpdate_managedObject() {
         AllJavaTypes obj = new AllJavaTypes();
+        obj.setFieldId(42);
         obj.setFieldIgnored("cookie");
         obj.setFieldLong(42);
         obj.setFieldString("obj1");
@@ -808,11 +851,11 @@ public void insertOrUpdate_linkingManagedToUnmanagedObject() {
         realm.insertOrUpdate(unmanagedObject);
         realm.commitTransaction();
 
-        AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 8).findFirst();
+        AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 8).findFirst();
         assertNotNull(first);
-        assertEquals(8, first.getFieldLong(), 0);
+        assertEquals(8, first.getFieldId(), 0);
         assertNotNull(first.getFieldObject());
-        assertEquals(42, first.getFieldObject().getFieldLong());
+        assertEquals(42, first.getFieldObject().getFieldId());
         assertEquals(2, realm.where(AllJavaTypes.class).count());
     }
 
@@ -833,8 +876,8 @@ public void insertManagedObjectWillNotDuplicate() {
     @Test
     public void insertOrUpdate_collectionOfManagedObjects() {
         realm.beginTransaction();
-        AllTypesPrimaryKey allTypes = realm.createObject(AllTypesPrimaryKey.class);
-        allTypes.getColumnRealmList().add(realm.createObject(DogPrimaryKey.class));
+        AllTypesPrimaryKey allTypes = realm.createObject(AllTypesPrimaryKey.class, 0);
+        allTypes.getColumnRealmList().add(realm.createObject(DogPrimaryKey.class, 0));
         realm.commitTransaction();
         assertEquals(1, allTypes.getColumnRealmList().size());
 
@@ -856,8 +899,8 @@ public void insertOrUpdate_collectionOfManagedObjects() {
     @Test
     public void insertOrUpdate_shouldNotClearRealmList() {
         realm.beginTransaction();
-        AllTypesPrimaryKey allTypes = realm.createObject(AllTypesPrimaryKey.class);
-        allTypes.getColumnRealmList().add(realm.createObject(DogPrimaryKey.class));
+        AllTypesPrimaryKey allTypes = realm.createObject(AllTypesPrimaryKey.class, 0);
+        allTypes.getColumnRealmList().add(realm.createObject(DogPrimaryKey.class, 0));
         realm.commitTransaction();
         assertEquals(1, allTypes.getColumnRealmList().size());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index d147fd591a..1ef8aad27b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -49,7 +49,7 @@
 
     // Enumerate all methods from the RealmCollection interface that depend on Realm API's.
     protected enum RealmCollectionMethod {
-        WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID
+        WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID, IS_MANAGED
     }
 
     // Enumerate all methods from the Collection interface
@@ -94,8 +94,8 @@ protected void populateRealm(Realm realm, int objects) {
             }
 
             // Add all items to the RealmList on the first object
-            AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst();
-            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+            AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 0).findFirst();
+            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_ID, Sort.ASCENDING);
             RealmList<AllJavaTypes> list = firstObj.getFieldList();
             for (int i = 0; i < listData.size(); i++) {
                 list.add(listData.get(i));
@@ -200,7 +200,7 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
                 return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
 
             case MANAGED_REALMLIST:
-                AllJavaTypes first = realm.createObject(AllJavaTypes.class);
+                AllJavaTypes first = realm.createObject(AllJavaTypes.class, 0);
                 first.setFieldString(args[0]);
                 first.getFieldList().add(first);
                 for (int i = 1; i < args.length; i++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
new file mode 100644
index 0000000000..0205aa80ce
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.annotation.NonNull;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.google.common.collect.ImmutableMap;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.internal.ColumnIndices;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotSame;
+import static junit.framework.Assert.assertSame;
+import static org.junit.Assert.assertNotEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class ColumnIndicesTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private RealmProxyMediator mediator;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+        mediator = config.getSchemaMediator();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @NonNull
+    private ColumnIndices create(long schemaVersion) {
+        final CatRealmProxy.CatColumnInfo catColumnInfo;
+        final DogRealmProxy.DogColumnInfo dogColumnInfo;
+        catColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        dogColumnInfo = (DogRealmProxy.DogColumnInfo) mediator.validateTable(Dog.class, realm.sharedRealm, false);
+
+        return new ColumnIndices(schemaVersion,
+                ImmutableMap.<Class<? extends RealmModel>, ColumnInfo>of(
+                        Cat.class, catColumnInfo,
+                        Dog.class, dogColumnInfo));
+    }
+
+    @Test
+    public void copyDeeply() {
+        final long schemaVersion = 100;
+
+        final ColumnIndices columnIndices = create(schemaVersion);
+        final ColumnIndices deepCopy = columnIndices.clone();
+
+        assertEquals(schemaVersion, deepCopy.getSchemaVersion());
+        assertEquals(columnIndices.getColumnIndex(Cat.class, Cat.FIELD_NAME),
+                deepCopy.getColumnIndex(Cat.class, Cat.FIELD_NAME));
+        assertEquals(columnIndices.getColumnIndex(Dog.class, Dog.FIELD_AGE),
+                deepCopy.getColumnIndex(Dog.class, Dog.FIELD_AGE));
+
+        // check if those are different instance.
+        assertNotSame(columnIndices, deepCopy);
+        assertNotSame(columnIndices.getColumnInfo(Cat.class), deepCopy.getColumnInfo(Cat.class));
+        assertNotSame(columnIndices.getColumnInfo(Dog.class), deepCopy.getColumnInfo(Dog.class));
+    }
+
+    @Test
+    public void copyFrom() {
+        final long sourceSchemaVersion = 101;
+        final long targetSchemaVersion = 100;
+
+        final ColumnIndices source = create(sourceSchemaVersion);
+        final ColumnIndices target = create(targetSchemaVersion);
+
+        final CatRealmProxy.CatColumnInfo catColumnInfoInSource = (CatRealmProxy.CatColumnInfo) source.getColumnInfo(Cat.class);
+        final CatRealmProxy.CatColumnInfo catColumnInfoInTarget = (CatRealmProxy.CatColumnInfo) target.getColumnInfo(Cat.class);
+
+        catColumnInfoInSource.nameIndex++;
+
+        // check preconditions
+        assertNotEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
+        assertNotSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
+
+        target.copyFrom(source,  mediator);
+
+        assertEquals(sourceSchemaVersion, target.getSchemaVersion());
+        assertEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
+        assertSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
new file mode 100644
index 0000000000..ae20b233a3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.Cat;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotSame;
+import static junit.framework.Assert.assertSame;
+
+@RunWith(AndroidJUnit4.class)
+public class ColumnInfoTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void copyColumnInfoFrom_checkIndex() {
+        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        final CatRealmProxy.CatColumnInfo sourceColumnInfo, targetColumnInfo;
+        sourceColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        targetColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        // check precondition
+        assertNotSame(sourceColumnInfo, targetColumnInfo);
+        assertNotSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
+
+        sourceColumnInfo.nameIndex = 1;
+        sourceColumnInfo.ageIndex = 2;
+        sourceColumnInfo.heightIndex = 3;
+        sourceColumnInfo.weightIndex = 4;
+        sourceColumnInfo.hasTailIndex = 5;
+        sourceColumnInfo.birthdayIndex = 6;
+        sourceColumnInfo.ownerIndex = 7;
+        sourceColumnInfo.scaredOfDogIndex = 8;
+
+        targetColumnInfo.nameIndex = 0;
+        targetColumnInfo.ageIndex = 0;
+        targetColumnInfo.heightIndex = 0;
+        targetColumnInfo.weightIndex = 0;
+        targetColumnInfo.hasTailIndex = 0;
+        targetColumnInfo.birthdayIndex = 0;
+        targetColumnInfo.ownerIndex = 0;
+        targetColumnInfo.scaredOfDogIndex = 0;
+
+        targetColumnInfo.copyColumnInfoFrom(sourceColumnInfo);
+
+        assertEquals(1, targetColumnInfo.nameIndex);
+        assertEquals(2, targetColumnInfo.ageIndex);
+        assertEquals(3, targetColumnInfo.heightIndex);
+        assertEquals(4, targetColumnInfo.weightIndex);
+        assertEquals(5, targetColumnInfo.hasTailIndex);
+        assertEquals(6, targetColumnInfo.birthdayIndex);
+        assertEquals(7, targetColumnInfo.ownerIndex);
+        assertEquals(8, targetColumnInfo.scaredOfDogIndex);
+
+        // current implementation shares the indices map.
+        assertSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
+    }
+
+    @Test
+    public void clone_hasSameValue() {
+        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        final CatRealmProxy.CatColumnInfo columnInfo;
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        columnInfo.nameIndex = 1;
+        columnInfo.ageIndex = 2;
+        columnInfo.heightIndex = 3;
+        columnInfo.weightIndex = 4;
+        columnInfo.hasTailIndex = 5;
+        columnInfo.birthdayIndex = 6;
+        columnInfo.ownerIndex = 7;
+        columnInfo.scaredOfDogIndex = 8;
+
+        CatRealmProxy.CatColumnInfo copy = columnInfo.clone();
+
+        // modify original object
+        columnInfo.nameIndex = 0;
+        columnInfo.ageIndex = 0;
+        columnInfo.heightIndex = 0;
+        columnInfo.weightIndex = 0;
+        columnInfo.hasTailIndex = 0;
+        columnInfo.birthdayIndex = 0;
+        columnInfo.ownerIndex = 0;
+        columnInfo.scaredOfDogIndex = 0;
+
+        assertNotSame(columnInfo, copy);
+
+        assertEquals(1, copy.nameIndex);
+        assertEquals(2, copy.ageIndex);
+        assertEquals(3, copy.heightIndex);
+        assertEquals(4, copy.weightIndex);
+        assertEquals(5, copy.hasTailIndex);
+        assertEquals(6, copy.birthdayIndex);
+        assertEquals(7, copy.ownerIndex);
+        assertEquals(8, copy.scaredOfDogIndex);
+
+        // current implementation shares the indices map between copies.
+        assertSame(columnInfo.getIndicesMap(), copy.getIndicesMap());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index d9153010a2..9386beb7cb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -37,6 +37,15 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsByte;
+import io.realm.entities.PrimaryKeyAsInteger;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsShort;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.exceptions.RealmException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -68,7 +77,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
-        typedObj = realm.createObject(AllJavaTypes.class);
+        typedObj = realm.createObject(AllJavaTypes.class, 1);
         typedObj.setFieldString("str");
         typedObj.setFieldShort((short) 1);
         typedObj.setFieldInt(1);
@@ -122,6 +131,11 @@ public void constructor_deletedObjectThrows() {
         new DynamicRealmObject(typedObj);
     }
 
+    @Test (expected = IllegalArgumentException.class)
+    public void constructor_unmanagedObjectThrows() {
+        new DynamicRealmObject(new AllTypes());
+    }
+
     // Test that all getters fail if given invalid field name
     @Test
     public void typedGetter_illegalFieldNameThrows() {
@@ -137,7 +151,12 @@ public void typedGetter_illegalFieldNameThrows() {
             // of failing values. Only difference is the wrong type column has to be different.
             List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
             try {
-                callGetter(type, args);
+                callGetter(dObjTyped, type, args);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            try {
+                callGetter(dObjDynamic, type, args);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -150,9 +169,19 @@ public void typedGetter_wrongUnderlyingTypeThrows() {
             try {
                 // Make sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.DOUBLE) {
-                    callGetter(type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                    callGetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                } else {
+                    callGetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
+                }
+                fail(type + " failed to throw.");
+            } catch (IllegalArgumentException ignored) {
+            }
+            try {
+                // Make sure we hit the wrong underlying type for all types.
+                if (type == SupportedType.DOUBLE) {
+                    callGetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
                 } else {
-                    callGetter(type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
+                    callGetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
                 }
                 fail(type + " failed to throw.");
             } catch (IllegalArgumentException ignored) {
@@ -161,21 +190,21 @@ public void typedGetter_wrongUnderlyingTypeThrows() {
     }
 
     // Helper method for calling getters with different field names
-    private void callGetter(SupportedType type, List<String> fieldNames) {
+    private static void callGetter(DynamicRealmObject target, SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
             switch (type) {
-                case BOOLEAN: dObjTyped.getBoolean(fieldName); break;
-                case SHORT: dObjTyped.getShort(fieldName); break;
-                case INT: dObjTyped.getInt(fieldName); break;
-                case LONG: dObjTyped.getLong(fieldName); break;
-                case BYTE: dObjTyped.getByte(fieldName); break;
-                case FLOAT: dObjTyped.getFloat(fieldName); break;
-                case DOUBLE: dObjTyped.getDouble(fieldName); break;
-                case STRING: dObjTyped.getString(fieldName); break;
-                case BINARY: dObjTyped.getBlob(fieldName); break;
-                case DATE: dObjTyped.getDate(fieldName); break;
-                case OBJECT: dObjTyped.getObject(fieldName); break;
-                case LIST: dObjTyped.getList(fieldName); break;
+                case BOOLEAN: target.getBoolean(fieldName); break;
+                case SHORT: target.getShort(fieldName); break;
+                case INT: target.getInt(fieldName); break;
+                case LONG: target.getLong(fieldName); break;
+                case BYTE: target.getByte(fieldName); break;
+                case FLOAT: target.getFloat(fieldName); break;
+                case DOUBLE: target.getDouble(fieldName); break;
+                case STRING: target.getString(fieldName); break;
+                case BINARY: target.getBlob(fieldName); break;
+                case DATE: target.getDate(fieldName); break;
+                case OBJECT: target.getObject(fieldName); break;
+                case LIST: target.getList(fieldName); break;
                 default:
                     fail();
             }
@@ -195,7 +224,12 @@ public void typedSetter_illegalFieldNameThrows() {
         for (SupportedType type : SupportedType.values()) {
             List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
             try {
-                callSetter(type, args);
+                callSetter(dObjTyped, type, args);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            try {
+                callSetter(dObjDynamic, type, args);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -209,34 +243,91 @@ public void typedSetter_wrongUnderlyingTypeThrows() {
             try {
                 // Make sure we hit the wrong underlying type for all types.
                 if (type == SupportedType.STRING) {
-                    callSetter(type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
+                    callSetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
                 } else {
-                    callSetter(type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                    callSetter(dObjTyped, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
                 }
                 fail();
             } catch (IllegalArgumentException ignored) {
             } finally {
                 realm.cancelTransaction();
             }
+            dynamicRealm.beginTransaction();
+            try {
+                // Make sure we hit the wrong underlying type for all types.
+                if (type == SupportedType.STRING) {
+                    callSetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
+                } else {
+                    callSetter(dObjDynamic, type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                }
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            } finally {
+                dynamicRealm.cancelTransaction();
+            }
+        }
+    }
+
+    private void callSetterOnPrimaryKey(String className, DynamicRealmObject object) {
+        switch (className) {
+            case PrimaryKeyAsByte.CLASS_NAME:
+                object.setByte(PrimaryKeyAsByte.FIELD_ID, (byte) 42);
+                break;
+            case PrimaryKeyAsShort.CLASS_NAME:
+                object.setShort(PrimaryKeyAsShort.FIELD_ID, (short) 42);
+                break;
+            case PrimaryKeyAsInteger.CLASS_NAME:
+                object.setInt(PrimaryKeyAsInteger.FIELD_ID, 42);
+                break;
+            case PrimaryKeyAsLong.CLASS_NAME:
+                object.setLong(PrimaryKeyAsLong.FIELD_ID, 42);
+                break;
+            case PrimaryKeyAsString.CLASS_NAME:
+                object.setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "42");
+                break;
+            default:
+                fail();
+        }
+    }
+
+    @Test
+    public void typedSetter_changePrimaryKeyThrows() {
+        final String[] primaryKeyClasses = {PrimaryKeyAsByte.CLASS_NAME, PrimaryKeyAsShort.CLASS_NAME,
+                PrimaryKeyAsInteger.CLASS_NAME, PrimaryKeyAsLong.CLASS_NAME, PrimaryKeyAsString.CLASS_NAME};
+        for (String pkClass : primaryKeyClasses) {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object;
+            if (pkClass.equals(PrimaryKeyAsString.CLASS_NAME)) {
+                object = dynamicRealm.createObject(pkClass, "");
+            } else {
+                object = dynamicRealm.createObject(pkClass, 0);
+            }
+
+            try {
+                callSetterOnPrimaryKey(pkClass, object);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            dynamicRealm.cancelTransaction();
         }
     }
 
     // Helper method for calling setters with different field names
-    private void callSetter(SupportedType type, List<String> fieldNames) {
+    private static void callSetter(DynamicRealmObject target, SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
             switch (type) {
-                case BOOLEAN: dObjTyped.setBoolean(fieldName, false); break;
-                case SHORT: dObjTyped.setShort(fieldName, (short) 1); break;
-                case INT: dObjTyped.setInt(fieldName, 1); break;
-                case LONG: dObjTyped.setLong(fieldName, 1L); break;
-                case BYTE: dObjTyped.setByte(fieldName, (byte) 4); break;
-                case FLOAT: dObjTyped.setFloat(fieldName, 1.23f); break;
-                case DOUBLE: dObjTyped.setDouble(fieldName, 1.23d); break;
-                case STRING: dObjTyped.setString(fieldName, "foo"); break;
-                case BINARY: dObjTyped.setBlob(fieldName, new byte[]{}); break;
-                case DATE: dObjTyped.getDate(fieldName); break;
-                case OBJECT: dObjTyped.setObject(fieldName, null); break;
-                case LIST: dObjTyped.setList(fieldName, null); break;
+                case BOOLEAN: target.setBoolean(fieldName, false); break;
+                case SHORT: target.setShort(fieldName, (short) 1); break;
+                case INT: target.setInt(fieldName, 1); break;
+                case LONG: target.setLong(fieldName, 1L); break;
+                case BYTE: target.setByte(fieldName, (byte) 4); break;
+                case FLOAT: target.setFloat(fieldName, 1.23f); break;
+                case DOUBLE: target.setDouble(fieldName, 1.23d); break;
+                case STRING: target.setString(fieldName, "foo"); break;
+                case BINARY: target.setBlob(fieldName, new byte[]{}); break;
+                case DATE: target.getDate(fieldName); break;
+                case OBJECT: target.setObject(fieldName, null); target.setObject(fieldName, target); break;
+                case LIST: target.setList(fieldName, new RealmList<DynamicRealmObject>()); break;
                 default:
                     fail();
             }
@@ -247,7 +338,7 @@ private void callSetter(SupportedType type, List<String> fieldNames) {
     @Test
     public void typedGettersAndSetters() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -311,7 +402,7 @@ public void typedGettersAndSetters() {
     @Test
     public void setter_null() {
         realm.beginTransaction();
-        NullTypes obj = realm.createObject(NullTypes.class);
+        NullTypes obj = realm.createObject(NullTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -384,7 +475,7 @@ public void setter_null() {
     @Test
     public void setter_nullOnRequiredFieldsThrows() {
         realm.beginTransaction();
-        NullTypes obj = realm.createObject(NullTypes.class);
+        NullTypes obj = realm.createObject(NullTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -418,7 +509,7 @@ public void setter_nullOnRequiredFieldsThrows() {
     @Test
     public void typedSetter_null() {
         realm.beginTransaction();
-        NullTypes obj = realm.createObject(NullTypes.class);
+        NullTypes obj = realm.createObject(NullTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -461,6 +552,29 @@ public void typedSetter_null() {
         }
     }
 
+    @Test
+    public void setNull_changePrimaryKeyThrows() {
+        final String[] primaryKeyClasses = {PrimaryKeyAsBoxedByte.CLASS_NAME, PrimaryKeyAsBoxedShort.CLASS_NAME,
+                PrimaryKeyAsBoxedInteger.CLASS_NAME, PrimaryKeyAsBoxedLong.CLASS_NAME, PrimaryKeyAsString.CLASS_NAME};
+        for (String pkClass : primaryKeyClasses) {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object;
+            boolean isStringPK = pkClass.equals(PrimaryKeyAsString.CLASS_NAME);
+            if (isStringPK) {
+                object = dynamicRealm.createObject(pkClass, "");
+            } else {
+                object = dynamicRealm.createObject(pkClass, 0);
+            }
+
+            try {
+                object.setNull(isStringPK ? PrimaryKeyAsString.FIELD_PRIMARY_KEY : "id");
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            dynamicRealm.cancelTransaction();
+        }
+    }
+
     @Test
     public void setObject_differentType() {
         realm.beginTransaction();
@@ -478,7 +592,7 @@ public void setObject_differentType() {
     @Test
     public void setObject_wrongTypeThrows() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         Dog otherObj = realm.createObject(Dog.class);
         DynamicRealmObject dynamicObj = new DynamicRealmObject(obj);
         DynamicRealmObject dynamicWrongType = new DynamicRealmObject(otherObj);
@@ -611,8 +725,7 @@ public void untypedSetter_listWrongTypeThrows() {
     @Test
     public void untypedSetter_listMixedTypesThrows() {
         realm.beginTransaction();
-        AllJavaTypes obj1 = realm.createObject(AllJavaTypes.class);
-        obj1.setFieldLong(2);
+        AllJavaTypes obj1 = realm.createObject(AllJavaTypes.class, 2);
         CyclicType obj2 = realm.createObject(CyclicType.class);
 
         RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
@@ -644,7 +757,7 @@ public void getList() {
     @Test
     public void untypedGetterSetter() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -713,7 +826,7 @@ public void untypedGetterSetter() {
     @Test
     public void untypedSetter_usingStringConversion() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -767,7 +880,7 @@ public void untypedSetter_usingStringConversion() {
     @Test
     public void untypedSetter_illegalImplicitConversionThrows() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -780,7 +893,7 @@ public void untypedSetter_illegalImplicitConversionThrows() {
                             dObj.set(AllJavaTypes.FIELD_INT, "foo");
                             break;
                         case LONG:
-                            dObj.set(AllJavaTypes.FIELD_LONG, "foo");
+                            dObj.set(AllJavaTypes.FIELD_ID, "foo");
                             break;
                         case FLOAT:
                             dObj.set(AllJavaTypes.FIELD_FLOAT, "foo");
@@ -819,6 +932,38 @@ public void untypedSetter_illegalImplicitConversionThrows() {
         }
     }
 
+    private void testChangePrimaryKeyThroughUntypedSetter(String value) {
+        final String[] primaryKeyClasses = {PrimaryKeyAsBoxedByte.CLASS_NAME, PrimaryKeyAsBoxedShort.CLASS_NAME,
+                PrimaryKeyAsBoxedInteger.CLASS_NAME, PrimaryKeyAsBoxedLong.CLASS_NAME, PrimaryKeyAsString.CLASS_NAME};
+        for (String pkClass : primaryKeyClasses) {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object;
+            boolean isStringPK = pkClass.equals(PrimaryKeyAsString.CLASS_NAME);
+            if (isStringPK) {
+                object = dynamicRealm.createObject(pkClass, "");
+            } else {
+                object = dynamicRealm.createObject(pkClass, 0);
+            }
+
+            try {
+                object.set(isStringPK ? PrimaryKeyAsString.FIELD_PRIMARY_KEY : "id", value);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            dynamicRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void untypedSetter_setValue_changePrimaryKeyThrows() {
+        testChangePrimaryKeyThroughUntypedSetter("42");
+    }
+
+    @Test
+    public void untypedSetter_setNull_changePrimaryKeyThrows() {
+        testChangePrimaryKeyThroughUntypedSetter(null);
+    }
+
     @Test
     public void isNull_nullNotSupportedField() {
         assertFalse(dObjTyped.isNull(AllJavaTypes.FIELD_INT));
@@ -827,7 +972,7 @@ public void isNull_nullNotSupportedField() {
     @Test
     public void isNull_true() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         realm.commitTransaction();
 
         assertTrue(new DynamicRealmObject(obj).isNull(AllJavaTypes.FIELD_OBJECT));
@@ -840,10 +985,10 @@ public void isNull_false() {
 
     @Test
     public void getFieldNames() {
-        String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT,
-                AllJavaTypes.FIELD_LONG, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT, AllJavaTypes.FIELD_DOUBLE,
-                AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE, AllJavaTypes.FIELD_BINARY,
-                AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
+        String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID, AllJavaTypes.FIELD_LONG,
+                AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT,
+                AllJavaTypes.FIELD_DOUBLE, AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE,
+                AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
         String[] keys = dObjTyped.getFieldNames();
         assertArrayEquals(expectedKeys, keys);
     }
@@ -913,7 +1058,7 @@ public void toString_test() {
     @Test
     public void toString_nullValues() {
         dynamicRealm.beginTransaction();
-        final DynamicRealmObject obj = dynamicRealm.createObject(NullTypes.CLASS_NAME);
+        final DynamicRealmObject obj = dynamicRealm.createObject(NullTypes.CLASS_NAME, 0);
         dynamicRealm.commitTransaction();
 
         String str = obj.toString();
@@ -931,6 +1076,7 @@ public void toString_nullValues() {
         assertTrue(str.contains(NullTypes.FIELD_LIST_NULL + ":RealmList<NullTypes>[0]"));
     }
 
+
     public void testExceptionMessage() {
         // test for https://github.com/realm/realm-java/issues/2141
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 52afe5073c..cca89c96ca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -40,8 +40,9 @@
 import io.realm.entities.PrimaryKeyAsBoxedLong;
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.HandlerControllerConstants;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -233,6 +234,12 @@ public void createObject_illegalPrimaryKeyValue() {
         realm.createObject(DogPrimaryKey.CLASS_NAME, "bar");
     }
 
+    @Test(expected = RealmException.class)
+    public void createObject_absentPrimaryKeyThrows() {
+        realm.beginTransaction();
+        realm.createObject(DogPrimaryKey.CLASS_NAME);
+    }
+
     @Test
     public void where() {
         realm.beginTransaction();
@@ -375,6 +382,7 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 looperThread.testComplete();
             }
         });
+        looperThread.keepStrongReference.add(allTypes);
     }
 
     @Test
@@ -399,6 +407,7 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 looperThread.testComplete();
             }
         });
+        looperThread.keepStrongReference.add(allTypes);
     }
 
     // Initialize a Dynamic Realm used by the *Async tests and keep it ref in the looperThread.
@@ -515,6 +524,8 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
                 signalCallbackDone.run();
             }
         });
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/GCTests.java b/realm/realm-library/src/androidTest/java/io/realm/GCTests.java
new file mode 100644
index 0000000000..106733e813
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/GCTests.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.TestCase.assertNotNull;
+
+// This test is for the fact we don't have locks for native objects creation that when finalizer/phantom thread free the
+// native object, the same Realm could have some native objects creation at the same time.
+// If the native object's destructor is not thread safe, there is a big chance that those tests crash with a seg-fault.
+// test_destructor_thread_safety.cpp in core tests the similar things.
+@RunWith(AndroidJUnit4.class)
+public class GCTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private RealmConfiguration realmConfig;
+
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class).getColumnRealmList().add(realm.createObject(Dog.class));
+        realm.commitTransaction();
+        realm.close();
+
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    @Test
+    public void createRealmResults() {
+        for (int i = 0; i < 100; i++) {
+            Realm realm = Realm.getInstance(realmConfig);
+            for (int j = 0; j < 1000; j++) {
+                realm.where(AllTypes.class).findAll();
+            }
+            realm.close();
+        }
+    }
+
+    @Test
+    public void createRealmResultsFromRealmResults() {
+        for (int i = 0; i < 100; i++) {
+            Realm realm = Realm.getInstance(realmConfig);
+            for (int j = 0; j < 1000; j++) {
+                realm.where(AllTypes.class).findAll().where().findAll();
+            }
+            realm.close();
+        }
+    }
+
+    @Test
+    public void createRealmResultsFromRealmList() {
+        for (int i = 0; i < 100; i++) {
+            Realm realm = Realm.getInstance(realmConfig);
+            for (int j = 0; j < 1000; j++) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.getColumnRealmList().where().findAll();
+            }
+            realm.close();
+        }
+    }
+
+    @Test
+    public void createRealmObject() {
+        for (int i = 0; i < 100; i++) {
+            Realm realm = Realm.getInstance(realmConfig);
+            for (int j = 0; j < 1000; j++) {
+                realm.where(AllTypes.class).findFirst();
+            }
+            realm.close();
+        }
+    }
+
+    @Test
+    public void createRealmObjectFromRealmResults() {
+        for (int i = 0; i < 100; i++) {
+            Realm realm = Realm.getInstance(realmConfig);
+            for (int j = 0; j < 1000; j++) {
+                assertNotNull(realm.where(AllTypes.class).findAll().first());
+            }
+            realm.close();
+        }
+    }
+
+    @Test
+    public void createRealmObjectsFromRealmList() {
+        for (int i = 0; i < 100; i++) {
+            Realm realm = Realm.getInstance(realmConfig);
+            for (int j = 0; j < 1000; j++) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                assertNotNull(allTypes.getColumnRealmList().first());
+            }
+            realm.close();
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 2f19f3c5a5..c903d110c7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -170,7 +170,7 @@ public void tearDown() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                NullTypes obj = realm.createObject(NullTypes.class);
+                NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
                 return obj.getFieldListNull();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 0812e5f972..0c40da4b90 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -139,7 +139,7 @@ public void tearDown() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                NullTypes obj = realm.createObject(NullTypes.class);
+                NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
                 return obj.getFieldListNull();
 
@@ -522,6 +522,7 @@ public void realmMethods_invalidFieldNames() {
                         case WHERE:
                         case DELETE_ALL_FROM_REALM:
                         case IS_VALID:
+                        case IS_MANAGED:
                             continue;
 
                         default:
@@ -553,6 +554,7 @@ public void realmMethods_invalidFieldType() {
                     case WHERE:
                     case DELETE_ALL_FROM_REALM:
                     case IS_VALID:
+                    case IS_MANAGED:
                         continue;
 
                     default:
@@ -636,6 +638,11 @@ public void isValid_realmClosed() {
         assertFalse(collection.isValid());
     }
 
+    @Test
+    public void isManaged() {
+        assertTrue(collection.isManaged());
+    }
+
     @Test
     public void contains_deletedRealmObject() {
         AllJavaTypes obj = collection.iterator().next();
@@ -717,6 +724,7 @@ public Boolean call() throws Exception {
                         case MAX_DATE: collection.maxDate(AllJavaTypes.FIELD_DATE); break;
                         case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
                         case IS_VALID: collection.isValid(); break;
+                        case IS_MANAGED: collection.isManaged(); return true;
                     }
                     return false;
                 } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 6de7246d95..0a8979656f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -28,14 +28,13 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.lang.ref.WeakReference;
-import java.util.Map;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -48,8 +47,9 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
-import io.realm.internal.log.Logger;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLogger;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -317,24 +317,6 @@ public void run() {
         assertTrue(result);
     }
 
-    @Test
-    @UiThreadTest
-    public void handlerNotRemovedToSoon() {
-        RealmConfiguration realmConfig = configFactory.createConfiguration("private-realm");
-        Realm.deleteRealm(realmConfig);
-        Realm instance1 = Realm.getInstance(realmConfig);
-        Realm instance2 = Realm.getInstance(realmConfig);
-        assertEquals(instance1.getPath(), instance2.getPath());
-        assertNotNull(instance1.handler);
-
-        // If multiple instances are open on the same thread, don't remove handler on that thread
-        // until last instance is closed.
-        instance2.close();
-        assertNotNull(instance1.handler);
-        instance1.close();
-        assertNull(instance1.handler);
-    }
-
     @Test
     @RunTestInLooperThread
     public void commitTransaction_delayChangeListenerOnSameThread() {
@@ -666,7 +648,7 @@ public void run() {
         // Create a commit on another thread
         TestHelper.awaitOrFail(backgroundLooperStartedAndStopped);
         Realm realm = Realm.getInstance(realmConfig);
-        Logger logger = TestHelper.getFailureLogger(Log.WARN);
+        RealmLogger logger = TestHelper.getFailureLogger(Log.WARN);
         RealmLog.add(logger);
 
         realm.beginTransaction();
@@ -974,6 +956,7 @@ public void onChange(Realm element) {
         });
     }
 
+    // FIXME check if the SharedRealm Changed in handleAsyncTransactionCompleted and reenable this test.
     // We precisely depend on the order of triggering change listeners right now.
     // So it should be:
     // 1. Synced object listener
@@ -984,6 +967,7 @@ public void onChange(Realm element) {
     // If this case fails on your code, think twice before changing the test!
     // https://github.com/realm/realm-java/issues/2408 is related to this test!
     @Test
+    @Ignore("Listener on Realm might be trigger more times, ignore for now")
     @RunTestInLooperThread
     public void callingOrdersOfListeners() {
         final Realm realm = looperThread.realm;
@@ -1197,9 +1181,11 @@ public void warnIfMixingSyncWritesAndAsyncQueries() {
         final AtomicBoolean warningLogged = new AtomicBoolean(false);
         final TestHelper.TestLogger testLogger = new TestHelper.TestLogger() {
             @Override
-            public void w(String message) {
+            public void log(int level, String tag, Throwable throwable, String message) {
                 assertTrue(message.contains("Mixing asynchronous queries with local writes should be avoided."));
-                warningLogged.set(true);
+                if (level == LogLevel.WARN) {
+                    warningLogged.set(true);
+                }
             }
         };
         RealmLog.add(testLogger);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 7fbed86aca..0643ba9316 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -126,7 +126,7 @@ private void appendElementToCollection(Realm realm, CollectionClass collection)
     }
 
     private void createNewObject() {
-        Number currentMax = realm.where(AllJavaTypes.class).max(AllJavaTypes.FIELD_LONG);
+        Number currentMax = realm.where(AllJavaTypes.class).max(AllJavaTypes.FIELD_ID);
         long nextId = 0;
         if (currentMax != null) {
             nextId = currentMax.longValue() + 1;
@@ -724,6 +724,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedColl
                 case MIN_DATE:
                 case MAX_DATE:
                 case IS_VALID:
+                case IS_MANAGED:
                     realm.cancelTransaction();
                     continue;
                 default:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index 4d4665e4d7..8bee6afa70 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -220,6 +220,14 @@ public void first_emptyCollection() {
         }
     }
 
+    @Test
+    public void first_withDefault() {
+        AllJavaTypes defaultObject = new AllJavaTypes();
+        collection = createEmptyCollection(realm, collectionClass);
+        assertEquals(defaultObject, collection.first(defaultObject));
+        assertEquals(null, collection.first(null)); // Null is an acceptable default
+    }
+
     @Test
     public void last() {
         assertEquals(collection.get(TEST_SIZE - 1), collection.last());
@@ -235,6 +243,14 @@ public void last_emptyCollection() {
         }
     }
 
+    @Test
+    public void last_withDefault() {
+        AllJavaTypes defaultObject = new AllJavaTypes();
+        collection = createEmptyCollection(realm, collectionClass);
+        assertEquals(defaultObject, collection.last(defaultObject));
+        assertEquals(null, collection.last(null)); // Null is an acceptable default
+    }
+
     @Test
     public void get_validIndex() {
         AllJavaTypes first = collection.get(0);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index 81c4938f31..6677482d9c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -50,7 +50,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
-        AnnotationTypes object = realm.createObject(AnnotationTypes.class);
+        AnnotationTypes object = realm.createObject(AnnotationTypes.class, 0);
         object.setNotIndexString("String 1");
         object.setIndexString("String 2");
         object.setIgnoreString("String 3");
@@ -102,9 +102,8 @@ public void index() {
     public void primaryKey_migration_long() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class);
+            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
             obj.setId(i);
-            obj.setName("String" + i);
         }
 
         Table table = realm.getTable(PrimaryKeyAsString.class);
@@ -118,9 +117,8 @@ public void primaryKey_migration_long() {
     public void primaryKey_migration_longDuplicateValues() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class);
+            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
             obj.setId(1); // Create duplicate values
-            obj.setName("String" + i);
         }
 
         Table table = realm.getTable(PrimaryKeyAsString.class);
@@ -139,8 +137,7 @@ public void primaryKey_migration_longDuplicateValues() {
     public void primaryKey_migration_string() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class);
-            obj.setId(i);
+            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
             obj.setName("String" + i);
         }
 
@@ -155,8 +152,7 @@ public void primaryKey_migration_string() {
     public void primaryKey_migration_stringDuplicateValues() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class);
-            obj.setId(i);
+            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
             obj.setName("String"); // Create duplicate values
         }
 
@@ -175,7 +171,7 @@ public void primaryKey_migration_stringDuplicateValues() {
     public void primaryKey_checkPrimaryKeyOnCreate() {
         realm.beginTransaction();
         try {
-            realm.createObject(AnnotationTypes.class);
+            realm.createObject(AnnotationTypes.class, 0);
             fail("Two empty objects cannot be created on the same table if a primary key is defined");
         } catch (RealmPrimaryKeyConstraintException ignored) {
         } finally {
@@ -183,32 +179,12 @@ public void primaryKey_checkPrimaryKeyOnCreate() {
         }
     }
 
-    // It should be allowed to override the primary key value with the same value
-    @Test
-    public void primaryKey_defaultStringValue() {
-        realm.beginTransaction();
-        PrimaryKeyAsString str = realm.createObject(PrimaryKeyAsString.class);
-        str.setName("");
-        realm.commitTransaction();
-    }
-
-    // It should be allowed to override the primary key value with the same value
-    @Test
-    public void primaryKey_defaultLongValue() {
-        realm.beginTransaction();
-        PrimaryKeyAsLong str = realm.createObject(PrimaryKeyAsLong.class);
-        str.setId(0);
-        realm.commitTransaction();
-    }
-
     @Test
     public void primaryKey_errorOnInsertingSameObject() {
         try {
             realm.beginTransaction();
-            AnnotationTypes obj1 = realm.createObject(AnnotationTypes.class);
-            obj1.setId(1);
-            AnnotationTypes obj2 = realm.createObject(AnnotationTypes.class);
-            obj2.setId(1);
+            realm.createObject(AnnotationTypes.class, 1);
+            realm.createObject(AnnotationTypes.class, 1);
             fail("Inserting two objects with same primary key should fail");
         } catch (RealmPrimaryKeyConstraintException ignored) {
         } finally {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index b36526ddaf..9375d6efd8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -45,7 +45,8 @@
 import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -171,7 +172,7 @@ public void onChange(Realm object) {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_exceptionHandling() throws Throwable {
-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);
         RealmLog.add(testLogger);
 
         final Realm realm = looperThread.realm;
@@ -365,7 +366,8 @@ public void unmanagedObjectAsyncBehaviour() {
         dog.setAge(10);
 
         assertTrue(dog.isLoaded());
-        assertFalse(dog.isValid());
+        assertTrue(dog.isValid());
+        assertFalse(dog.isManaged());
     }
 
     @Test
@@ -422,6 +424,7 @@ public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
+        looperThread.keepStrongReference.add(results);
 
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
@@ -1122,7 +1125,7 @@ public void findAllSortedAsync_batchUpdate() {
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
                     case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
-                        if (numberOfIntercept.incrementAndGet() == 1) {
+                        if (numberOfIntercept.incrementAndGet() == 2 /* 2 queries are both completed */) {
                             // 6. The first time the async queries complete we start an update from
                             // another background thread. This will cause queries to rerun when the
                             // background thread notifies this thread.
@@ -1618,6 +1621,31 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread()
+    public void distinctAsync_rememberQueryParams() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        final int TEST_SIZE = 10;
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.createObject(AllJavaTypes.class, i);
+        }
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class)
+                .notEqualTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2)
+                .distinctAsync(AllJavaTypes.FIELD_ID);
+
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllJavaTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllJavaTypes> results) {
+                assertEquals(TEST_SIZE - 1, results.size());
+                assertEquals(0, results.where().equalTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2).count());
+                looperThread.testComplete();
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void distinctAsync_notIndexedFields() throws Throwable {
@@ -1870,8 +1898,8 @@ public void onChange(AllTypes object) {
             public void run() {
                 Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
                 // Advancing the Realm without generating notifications
-                bgRealm.sharedGroupManager.promoteToWrite();
-                bgRealm.sharedGroupManager.commitAndContinueAsRead();
+                bgRealm.sharedRealm.beginTransaction();
+                bgRealm.sharedRealm.commitTransaction();
                 Realm.asyncTaskExecutor.resume();
                 bgRealm.close();
                 signalClosedRealm.countDown();
@@ -2111,6 +2139,57 @@ public void run() {
         realm.close();
     }
 
+    // This test reproduce the issue in https://secure.helpscout.net/conversation/244053233/6163/?folderId=366141
+    // First it creates 512 async queries, then trigger a transaction to make the queries gets update with
+    // nativeBatchUpdateQueries. It should not exceed the limits of local ref map size in JNI.
+    @Test
+    @RunTestInLooperThread
+    public void batchUpdate_localRefIsDeletedInLoopOfNativeBatchUpdateQueries() {
+        final Realm realm = looperThread.realm;
+        // For Android, the size of local ref map is 512. Use 1024 for more pressure.
+        final int TEST_COUNT = 1024;
+        final AtomicBoolean updatesTriggered = new AtomicBoolean(false);
+        // The first time onChange gets called for every results.
+        final AtomicInteger firstOnChangeCounter = new AtomicInteger(0);
+        // The second time onChange gets called for every results which is triggered by the transaction.
+        final AtomicInteger secondOnChangeCounter = new AtomicInteger(0);
+
+        final RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                if (updatesTriggered.get())  {
+                    // Step 4: Test finished after all results's onChange gets called the 2nd time.
+                    int count  = secondOnChangeCounter.addAndGet(1);
+                    if (count == TEST_COUNT) {
+                        realm.removeAllChangeListeners();
+                        looperThread.testComplete();
+                    }
+                } else {
+                    int count  = firstOnChangeCounter.addAndGet(1);
+                    if (count == TEST_COUNT) {
+                        // Step 3: Commit the transaction to trigger queries updates.
+                        updatesTriggered.set(true);
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.createObject(AllTypes.class);
+                            }
+                        });
+                    } else {
+                        // Step 2: Create 2nd - TEST_COUNT queries.
+                        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+                        results.addChangeListener(this);
+                        looperThread.keepStrongReference.add(results);
+                    }
+                }
+            }
+        };
+        // Step 1. Create first async to kick the test start.
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        results.addChangeListener(listener);
+        looperThread.keepStrongReference.add(results);
+    }
+
     // *** Helper methods ***
 
     private void populateTestRealm(final Realm testRealm, int objects) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index abbc3a37dc..c8213e7d9c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -31,6 +31,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -105,7 +106,8 @@ public void getInstanceClearsCacheWhenFailed() {
         realm.close();
         try {
             Realm.getInstance(configB); // Try to open with key 2
-        } catch (IllegalArgumentException ignored) {
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
             // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
             // if initialization failed.
             assertTrue(Realm.deleteRealm(configA));
@@ -152,7 +154,8 @@ public void dontCacheWrongConfigurations() throws IOException {
         try {
             Realm.getInstance(wrongConfig);
             fail();
-        } catch (IllegalArgumentException ignored) {
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
 
         // Try again with proper key
@@ -179,7 +182,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
 
         // 1. Write a copy of the encrypted Realm to a new file
         Realm testRealm = Realm.getInstance(config);
-        File copiedRealm = new File(config.getRealmFolder(), "encrypted-copy.realm");
+        File copiedRealm = new File(config.getRealmDirectory(), "encrypted-copy.realm");
         if (copiedRealm.exists()) {
             assertTrue(copiedRealm.delete());
         }
@@ -190,7 +193,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         Realm.deleteRealm(config);
 
         // 3. Rename the new file to the old file name.
-        assertTrue(copiedRealm.renameTo(new File(config.getRealmFolder(), REALM_NAME)));
+        assertTrue(copiedRealm.renameTo(new File(config.getRealmDirectory(), REALM_NAME)));
 
         // 4. Try to open the file again with the new password
         // If the configuration cache wasn't cleared this would fail as we would detect two
@@ -263,9 +266,9 @@ public void releaseCacheInOneThread() {
         Realm realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         Realm realmB = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         RealmCache.release(realmA);
-        assertNotNull(realmA.sharedGroupManager);
+        assertNotNull(realmA.sharedRealm);
         RealmCache.release(realmB);
-        assertNull(realmB.sharedGroupManager);
+        assertNull(realmB.sharedRealm);
         // No crash but warning in the log
         RealmCache.release(realmB);
 
@@ -275,9 +278,9 @@ public void releaseCacheInOneThread() {
         DynamicRealm dynamicRealmB = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
         RealmCache.release(dynamicRealmA);
-        assertNotNull(dynamicRealmA.sharedGroupManager);
+        assertNotNull(dynamicRealmA.sharedRealm);
         RealmCache.release(dynamicRealmB);
-        assertNull(dynamicRealmB.sharedGroupManager);
+        assertNull(dynamicRealmB.sharedRealm);
         // No crash but warning in the log
         RealmCache.release(dynamicRealmB);
 
@@ -285,8 +288,8 @@ public void releaseCacheInOneThread() {
         realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig, DynamicRealm.class);
         RealmCache.release(realmA);
-        assertNull(realmA.sharedGroupManager);
+        assertNull(realmA.sharedRealm);
         RealmCache.release(dynamicRealmA);
-        assertNull(realmA.sharedGroupManager);
+        assertNull(realmA.sharedRealm);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
index 23f08c5aec..b058f3357a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
@@ -127,7 +127,7 @@ public void onChange(RealmResults<AllTypesRealmModel> result) {
         });
 
         realm.beginTransaction();
-        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class, 0);
         model.columnString = "data 1";
         realm.commitTransaction();
     }
@@ -160,7 +160,7 @@ public void onChange(Cat object) {
     public void returnedRealmModelIsNotNull() {
         Realm realm = looperThread.realm;
         realm.beginTransaction();
-        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class, 0);
         realm.commitTransaction();
 
         looperThread.keepStrongReference.add(model);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index 4daa4e751c..1fcc0c64df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -137,7 +137,7 @@ public void tearDown() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                NullTypes obj = realm.createObject(NullTypes.class);
+                NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
                 return obj.getFieldListNull();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 3b58dcce74..2763ab5b16 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -20,6 +20,7 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import android.content.Context;
@@ -43,7 +44,7 @@
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
@@ -70,11 +71,16 @@
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    RealmConfiguration defaultConfig;
-    Realm realm;
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Context context;
+    private  RealmConfiguration defaultConfig;
+    private Realm realm;
 
     @Before
     public void setUp() {
+        context = InstrumentationRegistry.getTargetContext();
         defaultConfig = configFactory.createConfiguration();
     }
 
@@ -101,16 +107,6 @@ public void setDefaultConfiguration_nullThrows() throws NoSuchFieldException, Il
         }
     }
 
-    @Test
-    public void getDefaultInstance_nullThrows() throws NoSuchFieldException, IllegalAccessException {
-        clearDefaultConfiguration();
-        try {
-            Realm.getDefaultInstance();
-            fail();
-        } catch (NullPointerException ignored) {
-        }
-    }
-
     @Test
     public void getInstance_nullConfigThrows() {
         try {
@@ -121,40 +117,42 @@ public void getInstance_nullConfigThrows() {
     }
 
     @Test
-    public void constructBuilder_nullDirThrows() {
+    public void constructBuilder_nullNameThrows() {
         try {
-            new RealmConfiguration.Builder((File) null).build();
+            new RealmConfiguration.Builder(context).name(null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
-    public void constructBuilder_createSubFoldersThrows() {
-        File folder = new File(configFactory.getRoot() + "/subfolder1/subfolder2/");
+    public void constructBuilder_emptyNameThrows() {
         try {
-            new RealmConfiguration.Builder(folder).build();
-            fail("Assuming that sub folders are created automatically should fail.");
+            new RealmConfiguration.Builder(context).name("");
+            fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
+    @Test(expected = IllegalArgumentException.class)
+    public void directory_null() {
+        new RealmConfiguration.Builder(context).directory(null);
+    }
+
     @Test
-    public void constructBuilder_nullNameThrows() {
-        try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).name(null).build();
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+    public void directory_writeProtectedDir() {
+        File dir = new File("/");
+        thrown.expect(IllegalArgumentException.class);
+        new RealmConfiguration.Builder(context).directory(dir);
     }
 
     @Test
-    public void constructBuilder_emptyNameThrows() {
-        try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).name("").build();
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+    public void directory_dirIsAFile() throws IOException {
+        File dir = configFactory.getRoot();
+        File file = new File(dir, "dummyfile");
+        assertTrue(file.createNewFile());
+        thrown.expect(IllegalArgumentException.class);
+        new RealmConfiguration.Builder(context).directory(file);
     }
 
     @Test
@@ -173,7 +171,7 @@ public void getInstance_idForHashCollision() {
     @Test
     public void constructBuilder_nullKeyThrows() {
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(null).build();
+            new RealmConfiguration.Builder(context).encryptionKey(null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -188,7 +186,7 @@ public void constructBuilder_wrongKeyLengthThrows() {
         };
         for (byte[] key : wrongKeys) {
             try {
-                new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(key).build();
+                new RealmConfiguration.Builder(context).encryptionKey(key);
                 fail("Key with length " + key.length + " should throw an exception");
             } catch (IllegalArgumentException ignored) {
             }
@@ -198,7 +196,7 @@ public void constructBuilder_wrongKeyLengthThrows() {
     @Test
     public void constructBuilder_negativeVersionThrows() {
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(-1).build();
+            new RealmConfiguration.Builder(context).schemaVersion(-1);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -206,14 +204,19 @@ public void constructBuilder_negativeVersionThrows() {
 
     @Test
     public void constructBuilder_versionLessThanDiscVersionThrows() {
-        realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(42).build());
+        realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schemaVersion(42)
+                .build());
         realm.close();
 
         int[] wrongVersions = new int[] { 0, 1, 41 };
         for (int version : wrongVersions) {
             try {
-                realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot())
-                        .schemaVersion(version).build());
+                realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                        .directory(configFactory.getRoot())
+                        .schemaVersion(version)
+                        .build());
                 fail("Version " + version + " should throw an exception");
             } catch (IllegalArgumentException ignored) {
             }
@@ -223,14 +226,20 @@ public void constructBuilder_versionLessThanDiscVersionThrows() {
     @Test
     public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
         // Create initial Realm
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .schemaVersion(42).schema(Dog.class).build();
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schemaVersion(42)
+                .schema(Dog.class)
+                .build();
         Realm.getInstance(config).close();
 
         // Create new instance with a configuration containing another schema
         try {
-            config = new RealmConfiguration.Builder(configFactory.getRoot())
-                    .schemaVersion(42).schema(AllTypesPrimaryKey.class).build();
+            config = new RealmConfiguration.Builder(context)
+                    .directory(configFactory.getRoot())
+                    .schemaVersion(42)
+                    .schema(AllTypesPrimaryKey.class)
+                    .build();
             realm = Realm.getInstance(config);
             fail("A migration should be required");
         } catch (RealmMigrationNeededException ignored) {
@@ -239,7 +248,10 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
 
     @Test
     public void customSchemaDontIncludeLinkedClasses() {
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot()).schema(Dog.class).build();
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schema(Dog.class)
+                .build();
         realm = Realm.getInstance(config);
         try {
             assertEquals(3, realm.getTable(Owner.class).getColumnCount());
@@ -251,7 +263,7 @@ public void customSchemaDontIncludeLinkedClasses() {
     @Test
     public void migration_nullThrows() {
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).migration(null).build();
+            new RealmConfiguration.Builder(context).migration(null).build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -261,14 +273,14 @@ public void migration_nullThrows() {
     public void modules_nonRealmModulesThrows() {
         // Test first argument
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).modules(new Object());
+            new RealmConfiguration.Builder(context).modules(new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Test second argument
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).modules(Realm.getDefaultModule(), new Object());
+            new RealmConfiguration.Builder(context).modules(Realm.getDefaultModule(), new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -276,8 +288,10 @@ public void modules_nonRealmModulesThrows() {
 
     @Test
     public void modules() {
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(configFactory.getRoot())
-                .modules(Realm.getDefaultModule(), (Object) null).build();
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .modules(Realm.getDefaultModule(), (Object) null)
+                .build();
         realm = Realm.getInstance(realmConfig);
         assertNotNull(realm.getTable(AllTypes.class));
     }
@@ -298,7 +312,8 @@ public void getInstance() {
 
     @Test
     public void standardSetup() {
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .name("foo.realm")
                 .encryptionKey(TestHelper.getRandomKey())
                 .schemaVersion(42)
@@ -320,7 +335,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void deleteRealmIfMigrationNeeded() {
         // Populate v0 of a Realm with an object
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .schema(Dog.class)
                 .schemaVersion(0)
                 .build();
@@ -333,7 +349,8 @@ public void deleteRealmIfMigrationNeeded() {
         realm.close();
 
         // Change schema and verify that Realm has been cleared
-        config = new RealmConfiguration.Builder(configFactory.getRoot())
+        config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .schema(Owner.class, Dog.class)
                 .schemaVersion(1)
                 .deleteRealmIfMigrationNeeded()
@@ -350,8 +367,8 @@ public void deleteRealmIfMigrationNeeded_failsWhenAssetFileProvided() {
         RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
         try {
             builder
-                    .assetFile(context, "asset_file.realm")
-                    .deleteRealmIfMigrationNeeded();
+                .assetFile("asset_file.realm")
+                .deleteRealmIfMigrationNeeded();
             fail();
         } catch (IllegalStateException expected) {
             assertEquals("Realm cannot clear its schema when previously configured to use an asset file by calling assetFile().",
@@ -367,44 +384,50 @@ public void upgradeVersionWithNoMigration() {
 
         // Version upgrades should always require a migration.
         try {
-            realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot())
-                    .schemaVersion(42).build());
+            realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                    .directory(configFactory.getRoot())
+                    .schemaVersion(42)
+                    .build());
             fail();
-        } catch (RealmMigrationNeededException ignored) {
+        } catch (RealmMigrationNeededException expected) {
+            // And it should come with a cause.
+            assertNotNull(expected.getCause());
         }
     }
 
     @Test
     public void equals() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).build();
         assertTrue(config1.equals(config2));
     }
 
     @Test
     public void equalsWhenRxJavaUnavailable() {
         // test for https://github.com/realm/realm-java/issues/2416
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config1);
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config2);
         assertTrue(config1.equals(config2));
     }
 
     @Test
     public void hashCode_Test() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         assertEquals(config1.hashCode(), config2.hashCode());
     }
 
     @Test
     public void equals_withCustomModules() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
 
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new AnimalModule(), new HumanModule())
                 .build();
 
@@ -413,10 +436,12 @@ public void equals_withCustomModules() {
 
     @Test
     public void hashCode_withCustomModules() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new AnimalModule(), new HumanModule())
                 .build();
 
@@ -425,10 +450,12 @@ public void hashCode_withCustomModules() {
 
     @Test
     public void hashCode_withDifferentRxObservableFactory() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .rxFactory(new RealmObservableFactory())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .rxFactory(new RealmObservableFactory() {
                     @Override
                     public int hashCode() {
@@ -442,8 +469,8 @@ public int hashCode() {
 
     @Test
     public void equals_configurationsReturnCachedRealm() {
-        Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
-        Realm realm2 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
+        Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build());
+        Realm realm2 = Realm.getInstance(new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build());
         try {
             assertEquals(realm1, realm2);
         } finally {
@@ -454,8 +481,8 @@ public void equals_configurationsReturnCachedRealm() {
 
     @Test
     public void schemaVersion_differentVersionsThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(1).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(2).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).schemaVersion(1).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).schemaVersion(2).build();
 
         Realm realm1 = Realm.getInstance(config1);
         try {
@@ -469,10 +496,14 @@ public void schemaVersion_differentVersionsThrows() {
 
     @Test
     public void encryptionKey_differentEncryptionKeysThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .encryptionKey(TestHelper.getRandomKey()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .encryptionKey(TestHelper.getRandomKey()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
 
         Realm realm1 = Realm.getInstance(config1);
         try {
@@ -486,9 +517,12 @@ public void encryptionKey_differentEncryptionKeysThrows() {
 
     @Test
     public void schema_differentSchemasThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .schema(AllTypes.class).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schema(AllTypes.class)
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .schema(CyclicType.class).build();
 
         Realm realm1 = Realm.getInstance(config1);
@@ -504,8 +538,13 @@ public void schema_differentSchemasThrows() {
     // Creating Realm instances with same name but different durabilities is not allowed.
     @Test
     public void inMemory_differentDurabilityThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).inMemory().build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .inMemory()
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .build();
 
         // Create In-memory Realm first.
         Realm realm1 = Realm.getInstance(config1);
@@ -533,8 +572,8 @@ public void inMemory_differentDurabilityThrows() {
     // It is allowed to create multiple Realm with same name but in different directory
     @Test
     public void constructBuilder_differentDirSameName() throws IOException {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.newFolder()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.newFolder()).build();
 
         Realm realm1 = Realm.getInstance(config1);
         Realm realm2 = Realm.getInstance(config2);
@@ -547,7 +586,10 @@ public void encryptionKey_keyStorage() throws Exception {
         // Generate a key and use it in a RealmConfiguration
         byte[] oldKey = TestHelper.getRandomKey(12345);
         byte[] key = oldKey;
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(key).build();
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .encryptionKey(key)
+                .build();
 
         // Generate a different key and assign it to the same variable
         byte[] newKey = TestHelper.getRandomKey(67890);
@@ -577,8 +619,10 @@ public void modelClassesForDefaultMediator() throws Exception {
 
     @Test
     public void modelClasses_forGeneratedMediator() throws Exception {
-        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .modules(new HumanModule()).build();
+        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .modules(new HumanModule())
+                .build();
         assertTrue(config.getSchemaMediator() instanceof HumanModuleMediator);
 
         final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
@@ -597,8 +641,10 @@ public void modelClasses_forGeneratedMediator() throws Exception {
 
     @Test
     public void modelClasses_forCompositeMediator() throws Exception {
-        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .modules(new HumanModule(), new AnimalModule()).build();
+        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .modules(new HumanModule(), new AnimalModule())
+                .build();
         assertTrue(config.getSchemaMediator() instanceof CompositeMediator);
 
         final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
@@ -618,8 +664,10 @@ public void modelClasses_forCompositeMediator() throws Exception {
     @Test
     public void modelClasses_forFilterableMediator() throws Exception {
         //noinspection unchecked
-        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .schema(AllTypes.class, CatOwner.class).build();
+        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schema(AllTypes.class, CatOwner.class)
+                .build();
         assertTrue(config.getSchemaMediator() instanceof FilterableMediator);
 
         final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
@@ -800,15 +848,14 @@ public void initialDataTransactionAssetFile() throws IOException {
 
     @Test
     public void assetFileNullAndEmptyFileName() {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
         try {
-            new RealmConfiguration.Builder(context).assetFile(context, null).build();
+            new RealmConfiguration.Builder(context).assetFile(null).build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         try {
-            new RealmConfiguration.Builder(context).assetFile(context, "").build();
+            new RealmConfiguration.Builder(context).assetFile("").build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -816,13 +863,11 @@ public void assetFileNullAndEmptyFileName() {
 
     @Test
     public void assetFileWithInMemoryConfig() {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
-
         // Ensure that there is no data
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
         try {
-            new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm").inMemory().build();
+            new RealmConfiguration.Builder(context).assetFile("asset_file.realm").inMemory().build();
             fail();
         } catch (RealmException ignored) {
         }
@@ -830,30 +875,27 @@ public void assetFileWithInMemoryConfig() {
 
     @Test
     public void assetFileFakeFile() {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
-
         // Ensure that there is no data
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
-        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "no_file").build();
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile("no_file").build();
         try {
             Realm.getInstance(configuration);
             fail();
-        } catch (RealmIOException ignored) {
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
     }
 
     @Test
     public void assetFileValidFile() throws IOException {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
-
         // Ensure that there is no data
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
         RealmConfiguration configuration = new RealmConfiguration
                 .Builder(context)
                 .modules(new AssetFileModule())
-                .assetFile(context, "asset_file.realm")
+                .assetFile("asset_file.realm")
                 .build();
         Realm.deleteRealm(configuration);
 
@@ -887,7 +929,7 @@ public void assetFile_failsWhenDeleteRealmIfMigrationNeededConfigured() {
         try {
             builder
                     .deleteRealmIfMigrationNeeded()
-                    .assetFile(context, "asset_file.realm");
+                    .assetFile("asset_file.realm");
             fail();
         } catch (IllegalStateException expected) {
             assertEquals("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().",
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index a2ed08b3e1..b273290f41 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -16,32 +16,46 @@
 
 package io.realm;
 
-import android.os.StrictMode;
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
 
 import junit.framework.AssertionFailedError;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
 import java.io.File;
-import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
 import io.realm.entities.Dog;
+import io.realm.exceptions.RealmFileException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmInMemoryTest {
 
-public class RealmInMemoryTest extends AndroidTestCase {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
     private final static String IDENTIFIER = "InMemRealmTest";
 
     private Realm testRealm;
     private RealmConfiguration inMemConf;
 
-    @Override
-    protected void setUp() throws Exception {
-        RealmConfiguration onDiskConf = new RealmConfiguration.Builder(getContext())
+    @Before
+    public void setUp() {
+        RealmConfiguration onDiskConf = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER)
                 .build();
-        inMemConf = new RealmConfiguration.Builder(getContext())
+        inMemConf = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER)
                 .inMemory()
                 .build();
@@ -51,8 +65,8 @@ protected void setUp() throws Exception {
         testRealm = Realm.getInstance(inMemConf);
     }
 
-    @Override
-    protected void tearDown() throws Exception {
+    @After
+    public void tearDown() {
         if (testRealm != null) {
             testRealm.close();
         }
@@ -60,14 +74,8 @@ protected void tearDown() throws Exception {
 
     // Testing the in-memory Realm by Creating one instance, adding a record, then close the instance.
     // By the next time in-memory Realm instance with the same name created, it should be empty.
-    // Use StrictMode to check no disk IO would happen in VM to this thread.
-    public void testInMemoryRealm() {
-        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
-                .detectDiskReads()
-                .detectDiskWrites()
-                .penaltyDeath()
-                .build());
-
+    @Test
+    public void inMemoryRealm() {
         testRealm.beginTransaction();
         Dog dog = testRealm.createObject(Dog.class);
         dog.setName("DinoDog");
@@ -81,19 +89,18 @@ public void testInMemoryRealm() {
         // in-mem-realm with same identifier should create a fresh new instance.
         testRealm = Realm.getInstance(inMemConf);
         assertEquals(testRealm.where(Dog.class).count(), 0);
-
-        StrictMode.enableDefaults();
     }
 
     // Two in-memory Realms with different names should not affect each other.
-    public void testInMemoryRealmWithDifferentNames() {
+    @Test
+    public void inMemoryRealmWithDifferentNames() {
         testRealm.beginTransaction();
         Dog dog = testRealm.createObject(Dog.class);
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
         // Create the 2nd in-memory Realm with a different name. To make sure they are not affecting each other.
-        RealmConfiguration inMemConf2 = new RealmConfiguration.Builder(getContext())
+        RealmConfiguration inMemConf2 = configFactory.createConfigurationBuilder()
                 .name(IDENTIFIER + "2")
                 .inMemory()
                 .build();
@@ -104,15 +111,18 @@ public void testInMemoryRealmWithDifferentNames() {
         testRealm2.commitTransaction();
 
         assertEquals(testRealm.where(Dog.class).count(), 1);
+        //noinspection ConstantConditions
         assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
         assertEquals(testRealm2.where(Dog.class).count(), 1);
+        //noinspection ConstantConditions
         assertEquals(testRealm2.where(Dog.class).findFirst().getName(), "UFODog");
 
         testRealm2.close();
     }
 
     // Test deleteRealm called on a in-memory Realm instance
-    public void testDelete() {
+    @Test
+    public void delete() {
         RealmConfiguration configuration = testRealm.getConfiguration();
         try {
             Realm.deleteRealm(configuration);
@@ -127,14 +137,15 @@ public void testDelete() {
     }
 
     // Test if an in-memory Realm can be written to disk with/without encryption
-    public void testWriteCopyTo() throws IOException {
+    @Test
+    public void writeCopyTo() {
         byte[] key = TestHelper.getRandomKey();
         String fileName = IDENTIFIER + ".realm";
         String encFileName = IDENTIFIER + ".enc.realm";
-        RealmConfiguration conf = new RealmConfiguration.Builder(getContext())
+        RealmConfiguration conf = configFactory.createConfigurationBuilder()
                 .name(fileName)
                 .build();
-        RealmConfiguration encConf = new RealmConfiguration.Builder(getContext())
+        RealmConfiguration encConf = configFactory.createConfigurationBuilder()
                 .name(encFileName)
                 .encryptionKey(key)
                 .build();
@@ -148,25 +159,26 @@ public void testWriteCopyTo() throws IOException {
         testRealm.commitTransaction();
 
         // Test a normal Realm file
-        testRealm.writeCopyTo(new File(getContext().getFilesDir(), fileName));
+        testRealm.writeCopyTo(new File(configFactory.getRoot(), fileName));
         Realm onDiskRealm = Realm.getInstance(conf);
         assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
 
         // Test a encrypted Realm file
-        testRealm.writeEncryptedCopyTo(new File(getContext().getFilesDir(), encFileName), key);
+        testRealm.writeEncryptedCopyTo(new File(configFactory.getRoot(), encFileName), key);
         onDiskRealm = Realm.getInstance(encConf);
         assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
         // Test with a wrong key to see if it fails as expected.
         try {
-            RealmConfiguration wrongKeyConf = new RealmConfiguration.Builder(getContext())
+            RealmConfiguration wrongKeyConf = configFactory.createConfigurationBuilder()
                     .name(encFileName)
                     .encryptionKey(TestHelper.getRandomKey(42))
                     .build();
             Realm.getInstance(wrongKeyConf);
-            fail("Realm.getInstance should fail with illegal argument");
-        } catch (IllegalArgumentException ignored) {
+            fail("Realm.getInstance should fail with RealmFileException");
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
     }
 
@@ -177,7 +189,8 @@ public void testWriteCopyTo() throws IOException {
     //    another instance is still held by the other thread.
     // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
     //    specific name exists.
-    public void testMultiThread() throws InterruptedException, ExecutionException {
+    @Test
+    public void multiThread() throws InterruptedException, ExecutionException {
         final CountDownLatch workerCommittedLatch = new CountDownLatch(1);
         final CountDownLatch workerClosedLatch = new CountDownLatch(1);
         final CountDownLatch realmInMainClosedLatch = new CountDownLatch(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
new file mode 100644
index 0000000000..58fa4950b3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Build;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
+import static org.junit.Assume.assumeThat;
+
+@RunWith(Parameterized.class)
+public class RealmJsonAbsentPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    // parameters for testing absent primary key value. PrimaryKey field is absent.
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+            {PrimaryKeyAsBoxedByte.class,    "{ \"name\":\"HaHaHaHaHaHaHaHaH\" }"},
+            {PrimaryKeyAsBoxedShort.class,   "{ \"name\":\"KeyValueTestIsFun\" }"},
+            {PrimaryKeyAsBoxedInteger.class, "{ \"name\":\"FunValueTestIsKey\" }"},
+            {PrimaryKeyAsBoxedLong.class,    "{ \"name\":\"NameAsBoxedLong-!\" }"},
+            {PrimaryKeyAsString.class,       "{ \"id\":2429214 }"}
+        });
+    }
+
+    final private Class<? extends RealmObject> clazz;
+    final private String jsonString;
+
+    public RealmJsonAbsentPrimaryKeyTests(Class<? extends RealmObject> clazz, String jsonString) {
+        this.jsonString = jsonString;
+        this.clazz = clazz;
+    }
+
+    // Testing absent primary key value for createObjectFromJson()
+    @Test
+    public void createObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateObjectFromJson()
+    @Test
+    public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createAllFromJson()
+    @Test
+    public void createAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createAllFromJson(clazz, jsonArray);
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateAllFromJson()
+    @Test
+    public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateAllFromJson(clazz, jsonArray);
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createObjectFromJson() stream version
+    @Test
+    public void createObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createObjectFromJson(clazz, TestHelper.stringToStream(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateObjectFromJson() stream version
+    @Test
+    public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateObjectFromJson(clazz, TestHelper.stringToStream(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createAllFromJson() stream version
+    @Test
+    public void createAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createAllFromJson(clazz, TestHelper.stringToStream(jsonArray.toString()));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateAllFromJson() stream version
+    @Test
+    public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateAllFromJson(clazz, TestHelper.stringToStream(jsonArray.toString()));
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
index c5482eb151..f0345f07bd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
@@ -57,7 +57,7 @@ public void tearDown() {
         }
     }
 
-    // parameters for testing null primary key value. PrimaryKey field is explicitly null or absent.
+    // parameters for testing null primary key value. PrimaryKey field is explicitly null
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
@@ -65,12 +65,7 @@ public void tearDown() {
             {PrimaryKeyAsBoxedShort.class,   "YouBetItIsNullKey", "{ \"id\":null, \"name\":\"YouBetItIsNullKey\" }"},
             {PrimaryKeyAsBoxedInteger.class, "Gosh Didnt KnowIt", "{ \"id\":null, \"name\":\"Gosh Didnt KnowIt\" }"},
             {PrimaryKeyAsBoxedLong.class,    "?YOUNOWKNOWRIGHT?", "{ \"id\":null, \"name\":\"?YOUNOWKNOWRIGHT?\" }"},
-            {PrimaryKeyAsBoxedByte.class,    "HaHaHaHaHaHaHaHaH", "{ \"name\":\"HaHaHaHaHaHaHaHaH\" }"},
-            {PrimaryKeyAsBoxedShort.class,   "KeyValueTestIsFun", "{ \"name\":\"KeyValueTestIsFun\" }"},
-            {PrimaryKeyAsBoxedInteger.class, "FunValueTestIsKey", "{ \"name\":\"FunValueTestIsKey\" }"},
-            {PrimaryKeyAsBoxedLong.class,    "NameAsBoxedLong-!", "{ \"name\":\"NameAsBoxedLong-!\" }"},
             {PrimaryKeyAsString.class,       "4299121",           "{ \"name\":null, \"id\":4299121  }"},
-            {PrimaryKeyAsString.class,       "2429214",           "{ \"id\":2429214 }"}
         });
     }
 
@@ -84,9 +79,9 @@ public RealmJsonNullPrimaryKeyTests(Class<? extends RealmObject> clazz, String s
         this.clazz = clazz;
     }
 
-    // Testing null or absent primary key value for createObjectFromJson()
+    // Testing null primary key value for createObjectFromJson()
     @Test
-    public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() throws JSONException {
+    public void createObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONException {
         realm.beginTransaction();
         realm.createObjectFromJson(clazz, new JSONObject(jsonString));
         realm.commitTransaction();
@@ -107,9 +102,9 @@ public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() thro
         }
     }
 
-    // Testing null or absent primary key value for createOrUpdateObjectFromJson()
+    // Testing null primary key value for createOrUpdateObjectFromJson()
     @Test
-    public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() throws JSONException {
+    public void createOrUpdateObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONException {
         realm.beginTransaction();
         realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
         realm.commitTransaction();
@@ -130,11 +125,11 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObjec
         }
     }
 
-    // Testing null or absent primary key value for createObject() -> createOrUpdateObjectFromJson()
+    // Testing null primary key value for createObject() -> createOrUpdateObjectFromJson()
     @Test
-    public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJsonObject() throws JSONException {
+    public void createOrUpdateObjectFromJson_primaryKey_isNull_updateFromJsonObject() throws JSONException {
         realm.beginTransaction();
-        realm.createObject(clazz); // name = null, id = 0
+        realm.createObject(clazz, null); // name = null, id =null
         realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
         realm.commitTransaction();
 
@@ -144,7 +139,6 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJso
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
-
         // PrimaryKeyAsNumber
         } else {
             RealmResults results = realm.where(clazz).findAll();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index fbcc2fdcf8..01733ddd9e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -17,10 +17,14 @@
 package io.realm;
 
 import android.content.Context;
+import android.os.Build;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
+import android.text.TextUtils;
 import android.util.Base64;
 
+import com.google.gson.internal.bind.util.ISO8601Utils;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -42,19 +46,23 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnnotationTypes;
+import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
 import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NullTypes;
 import io.realm.entities.OwnerPrimaryKey;
+import io.realm.entities.RandomPrimaryKey;
 import io.realm.exceptions.RealmException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 @RunWith(AndroidJUnit4.class)
 public class RealmJsonTests {
@@ -363,6 +371,220 @@ public void createAllFromJson_jsonArray() throws JSONException {
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
+    @Test
+    public void createFromJson_respectDefaultValues() throws JSONException {
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+
+        // Step 1: Prepare almost empty JSON
+        final JSONObject json = new JSONObject();
+        json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
+
+        // Step 2: Update with almost empty JSONObject
+        realm.beginTransaction();
+        final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
+        realm.commitTransaction();
+
+        // Step 3: Check that default values are applied
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE,
+                managedObj.getFieldIgnored());
+        assertEquals(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE, managedObj.getFieldString());
+        assertFalse(TextUtils.isEmpty(managedObj.getFieldRandomString()));
+        assertEquals(DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE, managedObj.getFieldShort());
+        assertEquals(DefaultValueOfField.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE, managedObj.getFieldLong());
+        assertEquals(DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE, managedObj.getFieldByte());
+        assertEquals(DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE, managedObj.getFieldFloat(), 0f);
+        assertEquals(DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE, managedObj.getFieldDouble(), 0d);
+        assertEquals(DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE, managedObj.isFieldBoolean());
+        assertEquals(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE, managedObj.getFieldBinary()));
+        assertEquals(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldObject().getFieldInt());
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldList().first().getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(2, realm.where(RandomPrimaryKey.class).count());
+    }
+
+    @Test
+    public void createFromJson_defaultValuesAreIgnored() throws JSONException {
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+
+        // Step 1: Prepare JSON
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        final JSONObject json = new JSONObject();
+        json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
+        json.put(DefaultValueOfField.FIELD_IGNORED, fieldIgnoredValue);
+        json.put(DefaultValueOfField.FIELD_STRING, fieldStringValue);
+        json.put(DefaultValueOfField.FIELD_RANDOM_STRING, fieldRandomStringValue);
+        json.put(DefaultValueOfField.FIELD_SHORT, fieldShortValue);
+        json.put(DefaultValueOfField.FIELD_INT, fieldIntValue);
+        json.put(DefaultValueOfField.FIELD_LONG, fieldLongValue);
+        json.put(DefaultValueOfField.FIELD_BYTE, fieldByteValue);
+        json.put(DefaultValueOfField.FIELD_FLOAT, fieldFloatValue);
+        json.put(DefaultValueOfField.FIELD_DOUBLE, fieldDoubleValue);
+        json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
+        json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
+        json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
+        // value for 'fieldObject'
+        final JSONObject fieldObjectJson = new JSONObject();
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk of fieldObject");
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_INT, fieldObjectIntValue);
+        json.put(DefaultValueOfField.FIELD_OBJECT, fieldObjectJson);
+        // value for 'fieldList'
+        final JSONArray fieldListArrayJson = new JSONArray();
+        final JSONObject fieldListItem0Json = new JSONObject();
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk1 of fieldList");
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue);
+        fieldListArrayJson.put(fieldListItem0Json);
+        final JSONObject fieldListItem1Json = new JSONObject();
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk2 of fieldList");
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue + 1);
+        fieldListArrayJson.put(fieldListItem1Json);
+        json.put(DefaultValueOfField.FIELD_LIST, fieldListArrayJson);
+
+        // Step 3: Update with JSONObject
+        realm.beginTransaction();
+        final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
+        realm.commitTransaction();
+
+        // Step 4: Check that properly created
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                managedObj.getFieldIgnored());
+        assertEquals(fieldStringValue, managedObj.getFieldString());
+        assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
+        assertEquals(fieldShortValue, managedObj.getFieldShort());
+        assertEquals(fieldIntValue, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, managedObj.getFieldLong());
+        assertEquals(fieldByteValue, managedObj.getFieldByte());
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
+        assertEquals(fieldDateValue, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertEquals(fieldObjectJson.getString(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldObject().getFieldRandomPrimaryKey());
+        assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
+        assertEquals(2, managedObj.getFieldList().size());
+        assertEquals(fieldListItem0Json.get(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldList().get(0).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue, managedObj.getFieldList().get(0).getFieldInt());
+        assertEquals(fieldListItem1Json.get(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldList().get(1).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue + 1, managedObj.getFieldList().get(1).getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(3, realm.where(RandomPrimaryKey.class).count());
+    }
+
+    @Test
+    public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+
+        // Step 1: Create an object with default values
+        final DefaultValueOfField original;
+        realm.beginTransaction(); {
+            original = realm.createObject(DefaultValueOfField.class, fieldLongPrimaryKeyValue);
+        }
+        realm.commitTransaction();
+
+        // Step 2: Prepare JSON
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        final JSONObject json = new JSONObject();
+        json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
+        json.put(DefaultValueOfField.FIELD_IGNORED, fieldIgnoredValue);
+        json.put(DefaultValueOfField.FIELD_STRING, fieldStringValue);
+        json.put(DefaultValueOfField.FIELD_RANDOM_STRING, fieldRandomStringValue);
+        json.put(DefaultValueOfField.FIELD_SHORT, fieldShortValue);
+        json.put(DefaultValueOfField.FIELD_INT, fieldIntValue);
+        json.put(DefaultValueOfField.FIELD_LONG, fieldLongValue);
+        json.put(DefaultValueOfField.FIELD_BYTE, fieldByteValue);
+        json.put(DefaultValueOfField.FIELD_FLOAT, fieldFloatValue);
+        json.put(DefaultValueOfField.FIELD_DOUBLE, fieldDoubleValue);
+        json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
+        json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
+        json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
+        // value for 'fieldObject'
+        final JSONObject fieldObjectJson = new JSONObject();
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,
+                original.getFieldObject().getFieldRandomPrimaryKey());
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_INT, fieldObjectIntValue);
+        json.put(DefaultValueOfField.FIELD_OBJECT, fieldObjectJson);
+        // value for 'fieldList'
+        final JSONArray fieldListArrayJson = new JSONArray();
+        final JSONObject fieldListItem0Json = new JSONObject(); // to be added
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,  "unique value");
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue);
+        fieldListArrayJson.put(fieldListItem0Json);
+        final JSONObject fieldListItem1Json = new JSONObject(); // to be updated
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,
+                original.getFieldList().first().getFieldRandomPrimaryKey());
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue + 1);
+        fieldListArrayJson.put(fieldListItem1Json);
+        json.put(DefaultValueOfField.FIELD_LIST, fieldListArrayJson);
+
+        // Step 3: Update with JSONObject
+        realm.beginTransaction();
+        final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
+        realm.commitTransaction();
+
+        // Step 4: Check that properly updated
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                managedObj.getFieldIgnored());
+        assertEquals(fieldStringValue, managedObj.getFieldString());
+        assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
+        assertEquals(fieldShortValue, managedObj.getFieldShort());
+        assertEquals(fieldIntValue, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, managedObj.getFieldLong());
+        assertEquals(fieldByteValue, managedObj.getFieldByte());
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
+        assertEquals(fieldDateValue, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
+        assertEquals(2, managedObj.getFieldList().size());
+        assertEquals("unique value", managedObj.getFieldList().get(0).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue, managedObj.getFieldList().get(0).getFieldInt());
+        assertEquals(fieldListItem1Json.get(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldList().get(1).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue + 1, managedObj.getFieldList().get(1).getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(3/* 2 updated + 1 added*/, realm.where(RandomPrimaryKey.class).count());
+    }
+
     // Test if Json object doesn't have the field, then the field should have default value.
     @Test
     public void createObjectFromJson_noValues() throws JSONException {
@@ -396,6 +618,7 @@ public void createObjectFromJson_jsonException() throws JSONException {
         realm.beginTransaction();
         try {
             realm.createObjectFromJson(AllTypes.class, json);
+            fail();
         } catch (RealmException ignored) {
         } finally {
             realm.commitTransaction();
@@ -409,6 +632,7 @@ public void createObjectFromJson_jsonException() throws JSONException {
     @Test
     public void createObjectFromJson_respectIgnoredFields() throws JSONException {
         JSONObject json = new JSONObject();
+        json.put("id", 0);
         json.put("indexString", "Foo");
         json.put("notIndexString", "Bar");
         json.put("ignoreString", "Baz");
@@ -472,12 +696,16 @@ public void createAllFromJson_stringNullClass() {
 
     @Test
     public void createAllFromJson_streamNull() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.createAllFromJson(AllTypes.class, (InputStream) null);
         assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
     public void createObjectFromJson_streamAllSimpleTypes() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "all_simple_types.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -496,6 +724,8 @@ public void createObjectFromJson_streamAllSimpleTypes() throws IOException {
 
     @Test
     public void createObjectFromJson_streamDateAsLong() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "date_as_long.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -509,6 +739,8 @@ public void createObjectFromJson_streamDateAsLong() throws IOException {
 
     @Test
     public void createObjectFromJson_streamDateAsString() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "date_as_string.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -522,6 +754,8 @@ public void createObjectFromJson_streamDateAsString() throws IOException {
 
     @Test
     public void createObjectFromJson_streamDateAsISO8601String() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "date_as_iso8601_string.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -540,6 +774,8 @@ public void createObjectFromJson_streamDateAsISO8601String() throws IOException
 
     @Test
     public void createObjectFromJson_streamChildObject() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "single_child_object.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -552,6 +788,8 @@ public void createObjectFromJson_streamChildObject() throws IOException {
 
     @Test
     public void createObjectFromJson_streamEmptyChildObjectList() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "realmlist_empty.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -564,6 +802,8 @@ public void createObjectFromJson_streamEmptyChildObjectList() throws IOException
 
     @Test
     public void createObjectFromJson_streamChildObjectList() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "realmlist.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -576,6 +816,8 @@ public void createObjectFromJson_streamChildObjectList() throws IOException {
 
     @Test
     public void createAllFromJson_streamArray() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "array.json");
         realm.beginTransaction();
         realm.createAllFromJson(Dog.class, in);
@@ -589,6 +831,8 @@ public void createAllFromJson_streamArray() throws IOException {
     // Test if Json object doesn't have the field, then the field should have default value. Stream version.
     @Test
     public void createObjectFromJson_streamNoValues() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "other_json_object.json");
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, in);
@@ -610,6 +854,8 @@ public void createObjectFromJson_streamNoValues() throws IOException {
 
     @Test
     public void createObjectFromJson_streamNullClass() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "array.json");
         realm.beginTransaction();
         assertNull(realm.createObjectFromJson(null, in));
@@ -619,6 +865,8 @@ public void createObjectFromJson_streamNullClass() throws IOException {
 
     @Test
     public void createObjectFromJson_streamNullJson() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_invalid.json");
         realm.beginTransaction();
         try {
@@ -633,6 +881,8 @@ public void createObjectFromJson_streamNullJson() throws IOException {
 
     @Test
     public void createObjectFromJson_streamNullInputStream() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.beginTransaction();
         assertNull(realm.createObjectFromJson(AnnotationTypes.class, (InputStream) null));
         realm.commitTransaction();
@@ -644,6 +894,8 @@ public void createObjectFromJson_streamNullInputStream() throws IOException {
      */
     @Test
     public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
         Date date = new Date(0);
         obj.setColumnLong(1); // ID
@@ -679,6 +931,8 @@ public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
 
     @Test
     public void createOrUpdateObjectFromJson_streamNullClass() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_primary_key_field_only.json");
         realm.beginTransaction();
         assertNull(realm.createOrUpdateObjectFromJson(null, in));
@@ -688,6 +942,8 @@ public void createOrUpdateObjectFromJson_streamNullClass() throws IOException {
 
     @Test
     public void createOrUpdateObjectFromJson_streamInvalidJson() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
         obj.setColumnLong(1);
         realm.beginTransaction();
@@ -708,6 +964,8 @@ public void createOrUpdateObjectFromJson_streamInvalidJson() throws IOException
 
     @Test
     public void createOrUpdateObjectFromJson_streamNoPrimaryKeyThrows() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         try {
             realm.createOrUpdateObjectFromJson(AllTypes.class, new TestHelper.StubInputStream());
             fail();
@@ -717,6 +975,8 @@ public void createOrUpdateObjectFromJson_streamNoPrimaryKeyThrows() throws IOExc
 
     @Test
     public void createOrUpdateAllFromJson_streamInvalidJSonCurlyBracketThrows() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         try {
             realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{"));
             fail();
@@ -726,6 +986,8 @@ public void createOrUpdateAllFromJson_streamInvalidJSonCurlyBracketThrows() thro
 
     @Test
     public void createOrUpdateObjectFromJson_streamIgnoreUnsetProperties() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
         realm.commitTransaction();
@@ -740,6 +1002,8 @@ public void createOrUpdateObjectFromJson_streamIgnoreUnsetProperties() throws IO
 
     @Test
     public void createOrUpdateObjectFromJson_inputStream() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.beginTransaction();
 
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
@@ -761,9 +1025,11 @@ public void createOrUpdateObjectFromJson_inputStream() throws IOException {
      */
     @Test
     public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, stream);
         realm.commitTransaction();
 
@@ -961,7 +1227,7 @@ public void createOrUpdateObjectFromJson_invalidJsonObject() throws JSONExceptio
     public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
         JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, newObject);
         realm.commitTransaction();
 
@@ -994,6 +1260,8 @@ public void createOrUpdateAllFromJson_jsonNullJson() {
 
     @Test
     public void createOrUpdateAllFromJson_streamNoPrimaryKeyThrows() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         try {
             realm.createOrUpdateAllFromJson(AllTypes.class, new TestHelper.StubInputStream());
             fail();
@@ -1003,6 +1271,8 @@ public void createOrUpdateAllFromJson_streamNoPrimaryKeyThrows() throws IOExcept
 
     @Test
     public void createOrUpdateAllFromJson_streamInvalidJSonBracketThrows() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         try {
             realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("["));
             fail();
@@ -1068,6 +1338,8 @@ public void createOrUpdateAllFromJson_jsonArray() throws JSONException, IOExcept
 
     @Test
     public void createOrUpdateAllFromJson_inputStream() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
         realm.commitTransaction();
@@ -1107,6 +1379,8 @@ public void createAllFromJson_nullTypesJsonWithNulls() throws IOException, JSONE
     // Test creating objects form JSON stream, all nullable fields with null values or non-null values
     @Test
     public void createAllFromJson_nullTypesStreamJSONWithNulls() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.beginTransaction();
         realm.createAllFromJson(NullTypes.class, TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
         realm.commitTransaction();
@@ -1140,7 +1414,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
 
         RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(2, nullTypesRealmResults.size());
-        checkNullableValuesAreNotNull(nullTypesRealmResults.first());
+        checkNullableValuesAreNotNull(nullTypesRealmResults.where().equalTo("id", 1).findFirst());
 
         // Update object with id 1, nullable fields should have null values
         JSONArray array = new JSONArray(json);
@@ -1264,6 +1538,8 @@ public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOExcepti
      */
     @Test
     public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOException, JSONException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "nulltypes_invalid.json"));
         JSONArray array = new JSONArray(json);
 
@@ -1367,7 +1643,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
     public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
         JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createObjectFromJson(OwnerPrimaryKey.class, newObject);
         realm.commitTransaction();
 
@@ -1391,9 +1667,11 @@ public void createObjectFromJson_objectNullClass() throws JSONException {
      */
     @Test
     public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createObjectFromJson(OwnerPrimaryKey.class, stream);
         realm.commitTransaction();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 1230a7c761..7dc7177144 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -120,7 +120,7 @@ public void constructor_unmanaged_null() {
     public void isValid_unmanagedMode() {
         //noinspection MismatchedQueryAndUpdateOfCollection
         RealmList<AllTypes> list = new RealmList<AllTypes>();
-        assertFalse(list.isValid());
+        assertTrue(list.isValid());
     }
 
     @Test
@@ -724,6 +724,7 @@ public void realmMethods_onDeletedLinkView() {
                     case MAX_DATE: results.maxDate(CyclicType.FIELD_DATE); break;
                     case DELETE_ALL_FROM_REALM: results.deleteAllFromRealm(); break;
                     case IS_VALID: continue; // Does not throw
+                    case IS_MANAGED: continue; // Does not throw
                 }
                 fail(method + " should have thrown an Exception.");
             } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
new file mode 100644
index 0000000000..e91ae3ba16
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
@@ -0,0 +1,156 @@
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.log.LogLevel;
+import io.realm.log.Logger;
+import io.realm.log.RealmLog;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmLogTests {
+
+    @Before
+    public void setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+    }
+
+    @Test
+    public void add_remove() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+        RealmLog.fatal("TEST");
+        assertEquals("TEST", testLogger.message);
+        RealmLog.remove(testLogger);
+        RealmLog.fatal("TEST_AGAIN");
+        assertEquals("TEST", testLogger.message);
+    }
+
+    @Test
+    public void set_get_logLevel() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+
+        RealmLog.setLevel(LogLevel.FATAL);
+        assertEquals(LogLevel.FATAL, RealmLog.getLevel());
+        RealmLog.debug("TEST_DEBUG");
+        assertNull(testLogger.message);
+
+        RealmLog.setLevel(LogLevel.DEBUG);
+        RealmLog.debug("TEST_DEBUG");
+        assertEquals("TEST_DEBUG", testLogger.message);
+        RealmLog.fatal("TEST_FATAL");
+        assertEquals("TEST_FATAL", testLogger.message);
+
+        RealmLog.remove(testLogger);
+    }
+
+    @Test
+    public void clear() {
+        TestHelper.TestLogger testLogger1 = new TestHelper.TestLogger();
+        TestHelper.TestLogger testLogger2 = new TestHelper.TestLogger();
+        RealmLog.add(testLogger1);
+        RealmLog.add(testLogger2);
+        RealmLog.fatal("TEST");
+
+        assertEquals("TEST", testLogger1.message);
+        assertEquals("TEST", testLogger2.message);
+
+        RealmLog.clear();
+
+        RealmLog.fatal("TEST_AGAIN");
+        assertEquals("TEST", testLogger1.message);
+        assertEquals("TEST", testLogger2.message);
+
+        RealmLog.registerDefaultLogger();
+    }
+
+    @Test
+    public void throwable_passedToTheJavaLogger() {
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+        Throwable throwable;
+
+        try {
+            throw new RuntimeException("Test exception.");
+        } catch (RuntimeException e) {
+            throwable = e;
+            RealmLog.fatal(e);
+        }
+
+        // Throwable has been passed.
+        assertEquals(throwable, testLogger.throwable);
+        // Message is the stacktrace.
+        assertTrue(testLogger.message.contains("RealmLogTests.java"));
+        RealmLog.remove(testLogger);
+    }
+
+    static class TestOldLogger implements Logger {
+        String message;
+        Throwable throwable;
+
+        @Override
+        public int getMinimumNativeDebugLevel() {
+            return 0;
+        }
+
+        @Override
+        public void trace(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void debug(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void info(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void warn(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void error(Throwable throwable, String message, Object... args) {
+        }
+
+        @Override
+        public void fatal(Throwable throwable, String message, Object... args) {
+            this.throwable = throwable;
+            this.message = message;
+        }
+    }
+
+    @Test
+    public void loggerAdaptor() {
+        TestOldLogger testLogger = new TestOldLogger();
+        RealmLog.add(testLogger);
+        Throwable throwable;
+
+        try {
+            throw new RuntimeException("Test exception.");
+        } catch (RuntimeException e) {
+            throwable = e;
+            RealmLog.fatal(e);
+        }
+
+        // Throwable has been passed.
+        assertEquals(throwable, testLogger.throwable);
+        assertTrue(testLogger.message.contains("RealmLogTests.java"));
+
+        RealmLog.remove(testLogger);
+        RealmLog.fatal("new string");
+
+        // Logger has been removed, nothing should be changed.
+        assertEquals(throwable, testLogger.throwable);
+        assertTrue(testLogger.message.contains("RealmLogTests.java"));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index ccfacdc351..cbba8cc04c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -515,9 +515,9 @@ private void createObjectsWithOldPrimaryKey(final String className, final boolea
             realm.executeTransaction(new DynamicRealm.Transaction() {
                 @Override
                 public void execute(DynamicRealm realm) {
-                    realm.createObject(className).setString(MigrationPrimaryKey.FIELD_PRIMARY, "12");
+                    realm.createObject(className, "12");
                     if (insertNullValue) {
-                        realm.createObject(className).setString(MigrationPrimaryKey.FIELD_PRIMARY, null);
+                        realm.createObject(className, null);
                     }
                 }
             });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index d634c2a2da..95f063b2f2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -17,6 +17,7 @@
 package io.realm;
 
 import android.content.Context;
+import android.os.Build;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
@@ -44,8 +45,11 @@
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeThat;
 
 // tests API methods when using a model class implementing RealmModel instead
 // of extending RealmObject.
@@ -101,8 +105,7 @@ public void createObject() {
         for (int i = 1; i < 43; i++) { // using i = 0 as PK will crash subsequent createObject
                                        // since createObject uses default values
             realm.beginTransaction();
-            AllTypesRealmModel allTypesRealmModel = realm.createObject(AllTypesRealmModel.class);
-            allTypesRealmModel.columnLong = i;
+            realm.createObject(AllTypesRealmModel.class, i);
             realm.commitTransaction();
         }
 
@@ -154,17 +157,21 @@ public void execute(Realm realm) {
         assertEquals(1, realm.where(AllTypesRealmModel.class).count());
 
         AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(obj);
         assertEquals("Foo", obj.columnString);
     }
 
     @Test
     public void createOrUpdateAllFromJson() throws IOException {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesRealmModel.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
         realm.commitTransaction();
 
         assertEquals(1, realm.where(AllTypesRealmModel.class).count());
         AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(obj);
         assertEquals("Bar", obj.columnString);
         assertEquals(2.23F, obj.columnFloat, 0.000000001);
         assertEquals(2.234D, obj.columnDouble, 0.000000001);
@@ -207,12 +214,13 @@ public void dynamicObject() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         AllTypesRealmModel typedObj = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(typedObj);
         DynamicRealmObject dObj = new DynamicRealmObject(typedObj);
 
         realm.beginTransaction();
-        dObj.setLong(AllTypesRealmModel.FIELD_LONG, 42L);
-        assertEquals(42, dObj.getLong(AllTypesRealmModel.FIELD_LONG));
-        assertEquals(42, typedObj.columnLong);
+        dObj.setByte(AllTypesRealmModel.FIELD_BYTE, (byte) 42);
+        assertEquals(42, dObj.getLong(AllTypesRealmModel.FIELD_BYTE));
+        assertEquals(42, typedObj.columnByte);
 
         dObj.setBlob(AllTypesRealmModel.FIELD_BINARY, new byte[]{1, 2, 3});
         Assert.assertArrayEquals(new byte[]{1, 2, 3}, dObj.getBlob(AllTypesRealmModel.FIELD_BINARY));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 7c64ba48cd..0224d6496c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -40,6 +40,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.ConflictingFieldName;
@@ -48,6 +49,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
@@ -523,7 +525,7 @@ public void execute(Realm realm) {
             realm_differentName.close();
         }
 
-        // Check the hash code of the object from a Realm in different folder.
+        // Check the hash code of the object from a Realm in different directory.
         RealmConfiguration realmConfig_differentPath = configFactory.createConfiguration(
                 "anotherDir", realmConfig.getRealmFileName());
         Realm realm_differentPath = Realm.getInstance(realmConfig_differentPath);
@@ -933,7 +935,7 @@ public void classNameConflictsWithFrameworkClass() {
     @Test
     public void isValid_unmanagedObject() {
         AllTypes allTypes = new AllTypes();
-        assertFalse(allTypes.isValid());
+        assertTrue(allTypes.isValid());
     }
 
     @Test
@@ -971,7 +973,7 @@ public void isValid_managedObject() {
     @Test
     public void set_get_nullOnNullableFields() {
         realm.beginTransaction();
-        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
         // 1 String
         nullTypes.setFieldStringNull(null);
         // 2 Bytes
@@ -1024,7 +1026,7 @@ public void get_set_nonNullValueOnNullableFields() {
         final byte[] testBytes = new byte[] {42};
         final Date testDate = newDate(2000, 1, 1);
         realm.beginTransaction();
-        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
         // 1 String
         nullTypes.setFieldStringNull(testString);
         // 2 Bytes
@@ -1075,7 +1077,7 @@ public void get_set_nonNullValueOnNullableFields() {
     public void set_nullValuesToNonNullableFields() {
         try {
             realm.beginTransaction();
-            NullTypes nullTypes = realm.createObject(NullTypes.class);
+            NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
             // 1 String
             try {
                 nullTypes.setFieldStringNotNull(null);
@@ -1144,7 +1146,7 @@ public void set_nullValuesToNonNullableFields() {
     @Test
     public void defaultValuesForNewObject() {
         realm.beginTransaction();
-        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
         realm.commitTransaction();
 
         assertNotNull(nullTypes);
@@ -1227,6 +1229,21 @@ public void isValid() {
         assertFalse(dog.isValid());
     }
 
+    @Test
+    public void isManaged_managedObject() {
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        assertTrue(dog.isManaged());
+    }
+
+    @Test
+    public void isManaged_unmanagedObject() {
+        Dog dog = new Dog();
+        assertFalse(dog.isManaged());
+    }
+
     // Test NaN value on float and double columns
     @Test
     public void float_double_NaN() {
@@ -1557,6 +1574,15 @@ public void setter_nullValueInNullableField() {
         assertNull(realm.where(NullTypes.class).findFirst().getFieldDateNull());
     }
 
+    @Test
+    public void setter_changePrimaryKeyThrows() {
+        realm.beginTransaction();
+        AllJavaTypes allJavaTypes = realm.createObject(AllJavaTypes.class, 42);
+        thrown.expect(RealmException.class);
+        allJavaTypes.setFieldId(111);
+        realm.cancelTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
new file mode 100644
index 0000000000..9facd69f7f
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.HashSet;
+import java.util.Set;
+
+import io.realm.entities.Cat;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmProxyMediatorTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void validateTable_noDuplicateIndexInIndexFields() {
+        RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        CatRealmProxy.CatColumnInfo columnInfo;
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        final Set<Long> indexSet = new HashSet<>();
+        int indexCount = 0;
+
+        indexSet.add(columnInfo.nameIndex);
+        indexCount++;
+        indexSet.add(columnInfo.ageIndex);
+        indexCount++;
+        indexSet.add(columnInfo.heightIndex);
+        indexCount++;
+        indexSet.add(columnInfo.weightIndex);
+        indexCount++;
+        indexSet.add(columnInfo.hasTailIndex);
+        indexCount++;
+        indexSet.add(columnInfo.birthdayIndex);
+        indexCount++;
+        indexSet.add(columnInfo.ownerIndex);
+        indexCount++;
+        indexSet.add(columnInfo.scaredOfDogIndex);
+        indexCount++;
+
+        assertEquals(indexCount, indexSet.size());
+    }
+
+    @Test
+    public void validateTable_noDuplicateIndexInIndicesMap() {
+        RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        CatRealmProxy.CatColumnInfo columnInfo;
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        final Set<Long> indexSet = new HashSet<>();
+        int indexCount = 0;
+
+        // get index for each field and then put into set
+        for (Field field : Cat.class.getDeclaredFields()) {
+            if (Modifier.isStatic(field.getModifiers())) {
+                continue;
+            }
+            indexSet.add(columnInfo.getIndicesMap().get(field.getName()));
+            indexCount++;
+        }
+
+        assertEquals("if no duplicates, size of set equals to field count.",
+                indexCount, indexSet.size());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 75e05b4340..d23e6796c1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -2249,6 +2249,9 @@ public void resultOfTableViewQuery() {
         populateTestRealm();
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 3L).findAll();
+        assertEquals(1, results.size());
+        assertEquals("test data 3", results.first().getColumnString());
+
         final RealmQuery<AllTypes> tableViewQuery = results.where();
         assertEquals("test data 3", tableViewQuery.findAll().first().getColumnString());
         assertEquals("test data 3", tableViewQuery.findFirst().getColumnString());
@@ -2311,7 +2314,7 @@ private void createIsEmptyDataSet(Realm realm) {
         realm.beginTransaction();
 
         AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldLong(1);
+        emptyValues.setFieldId(1);
         emptyValues.setFieldString("");
         emptyValues.setFieldBinary(new byte[0]);
         emptyValues.setFieldObject(emptyValues);
@@ -2319,7 +2322,7 @@ private void createIsEmptyDataSet(Realm realm) {
         realm.copyToRealm(emptyValues);
 
         AllJavaTypes nonEmpty = new AllJavaTypes();
-        nonEmpty.setFieldLong(2);
+        nonEmpty.setFieldId(2);
         nonEmpty.setFieldString("Foo");
         nonEmpty.setFieldBinary(new byte[]{1, 2, 3});
         nonEmpty.setFieldObject(nonEmpty);
@@ -2434,7 +2437,7 @@ private void createIsNotEmptyDataSet(Realm realm) {
         realm.beginTransaction();
 
         AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldLong(1);
+        emptyValues.setFieldId(1);
         emptyValues.setFieldString("");
         emptyValues.setFieldBinary(new byte[0]);
         emptyValues.setFieldObject(emptyValues);
@@ -2442,7 +2445,7 @@ private void createIsNotEmptyDataSet(Realm realm) {
         realm.copyToRealm(emptyValues);
 
         AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldLong(2);
+        notEmpty.setFieldId(2);
         notEmpty.setFieldString("Foo");
         notEmpty.setFieldBinary(new byte[]{1, 2, 3});
         notEmpty.setFieldObject(notEmpty);
@@ -2547,8 +2550,7 @@ public void execute(Realm realm) {
                 // Crash with i == 1000, 500, 100, 89, 85, 84
                 // Doesn't crash for i == 10, 50, 75, 82, 83
                 for (int i = 0; i < 84; i++) {
-                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
-                    obj.setFieldLong(i + 1);
+                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i + 1);
                     obj.setFieldBoolean(i % 2 == 0);
                     obj.setFieldObject(obj);
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index cf2ea4fd8b..cbce2dfd79 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -27,6 +27,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
@@ -37,9 +38,11 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.CyclicType;
+import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
+import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
@@ -1037,4 +1040,79 @@ public void deleteAndDeleteAll() {
 
         assertEquals(0, realm.where(StringOnly.class).findAll().size());
     }
+
+    @Test
+    public void syncQuery_defaultValuesAreIgnored() {
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final DefaultValueOfField obj = new DefaultValueOfField();
+                obj.setFieldIgnored(fieldIgnoredValue);
+                obj.setFieldString(fieldStringValue);
+                obj.setFieldRandomString(fieldRandomStringValue);
+                obj.setFieldShort(fieldShortValue);
+                obj.setFieldInt(fieldIntValue);
+                obj.setFieldLongPrimaryKey(fieldLongPrimaryKeyValue);
+                obj.setFieldLong(fieldLongValue);
+                obj.setFieldByte(fieldByteValue);
+                obj.setFieldFloat(fieldFloatValue);
+                obj.setFieldDouble(fieldDoubleValue);
+                obj.setFieldBoolean(fieldBooleanValue);
+                obj.setFieldDate(fieldDateValue);
+                obj.setFieldBinary(fieldBinaryValue);
+
+                final RandomPrimaryKey fieldObjectValue = new RandomPrimaryKey();
+                fieldObjectValue.setFieldInt(fieldObjectIntValue);
+                obj.setFieldObject(fieldObjectValue);
+
+                final RealmList<RandomPrimaryKey> list = new RealmList<>();
+                final RandomPrimaryKey listItem = new RandomPrimaryKey();
+                listItem.setFieldInt(fieldListIntValue);
+                list.add(listItem);
+                obj.setFieldList(list);
+
+                realm.copyToRealm(obj);
+            }
+        });
+
+        final RealmResults<DefaultValueOfField> result = realm.where(DefaultValueOfField.class)
+                .equalTo(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
+                        fieldLongPrimaryKeyValue).findAll();
+
+        final DefaultValueOfField obj = result.first();
+
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                obj.getFieldIgnored());
+        assertEquals(fieldStringValue, obj.getFieldString());
+        assertEquals(fieldRandomStringValue, obj.getFieldRandomString());
+        assertEquals(fieldShortValue, obj.getFieldShort());
+        assertEquals(fieldIntValue, obj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, obj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, obj.getFieldLong());
+        assertEquals(fieldByteValue, obj.getFieldByte());
+        assertEquals(fieldFloatValue, obj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, obj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, obj.isFieldBoolean());
+        assertEquals(fieldDateValue, obj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, obj.getFieldBinary()));
+        assertEquals(fieldObjectIntValue, obj.getFieldObject().getFieldInt());
+        assertEquals(1, obj.getFieldList().size());
+        assertEquals(fieldListIntValue, obj.getFieldList().first().getFieldInt());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index f73eff9771..5e65a027c3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -17,12 +17,12 @@
 package io.realm;
 
 import android.content.Context;
+import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.SystemClock;
 import android.support.test.InstrumentationRegistry;
-import android.support.test.annotation.UiThreadTest;
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
@@ -32,6 +32,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.After;
+import org.junit.Assume;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -40,7 +41,6 @@
 import org.junit.runner.RunWith;
 
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -65,6 +65,10 @@
 import io.realm.entities.Cat;
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
+import io.realm.entities.DefaultValueConstructor;
+import io.realm.entities.DefaultValueOfField;
+import io.realm.entities.DefaultValueOverwriteNullLink;
+import io.realm.entities.DefaultValueSetter;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
 import io.realm.entities.NoPrimaryKeyNullTypes;
@@ -84,12 +88,14 @@
 import io.realm.entities.PrimaryKeyRequiredAsBoxedLong;
 import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
 import io.realm.entities.PrimaryKeyRequiredAsString;
+import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
-import io.realm.exceptions.RealmError;
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
-import io.realm.internal.log.RealmLog;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.Table;
+import io.realm.log.RealmLog;
 import io.realm.objectid.NullPrimaryKey;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -97,9 +103,12 @@
 import io.realm.util.ExceptionHolder;
 import io.realm.util.RealmThread;
 
+import static io.realm.TestHelper.testNoObjectFound;
+import static io.realm.TestHelper.testOneObjectFound;
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
@@ -175,30 +184,6 @@ private void populateTestRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void getInstance_nullDir() {
-        Realm.getInstance(new RealmConfiguration.Builder((File) null).build());
-    }
-
-    @Test
-    public void getInstance_writeProtectedDir() {
-        File folder = new File("/");
-        thrown.expect(IllegalArgumentException.class);
-        Realm.getInstance(new RealmConfiguration.Builder(folder).build());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void getInstance_nullContextWithCustomDirThrows() {
-        Realm.getInstance(new RealmConfiguration.Builder((Context) null, configFactory.getRoot()).build());
-    }
-
-    @Test
-    public void getInstance_writeProtectedDirWithContext() {
-        File folder = new File("/");
-        thrown.expect(IllegalArgumentException.class);
-        Realm.getInstance(new RealmConfiguration.Builder(context, folder).build());
-    }
-
     @Test
     public void getInstance_writeProtectedFile() throws IOException {
         String REALM_FILE = "readonly.realm";
@@ -208,8 +193,14 @@ public void getInstance_writeProtectedFile() throws IOException {
         assertTrue(realmFile.createNewFile());
         assertTrue(realmFile.setWritable(false));
 
-        thrown.expect(RealmIOException.class);
-        Realm.getInstance(new RealmConfiguration.Builder(folder).name(REALM_FILE).build());
+        try {
+            Realm.getInstance(new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                    .directory(folder)
+                    .name(REALM_FILE)
+                    .build());
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
+        }
     }
 
     @Test
@@ -221,8 +212,11 @@ public void getInstance_writeProtectedFileWithContext() throws IOException {
         assertTrue(realmFile.createNewFile());
         assertTrue(realmFile.setWritable(false));
 
-        thrown.expect(RealmIOException.class);
-        Realm.getInstance(new RealmConfiguration.Builder(context, folder).name(REALM_FILE).build());
+        try {
+            Realm.getInstance(new RealmConfiguration.Builder(context).directory(folder).name(REALM_FILE).build());
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
+        }
     }
 
     @Test
@@ -259,38 +253,6 @@ public void checkIfValid() {
         realm = null;
     }
 
-    @Test
-    @UiThreadTest
-    public void internalRealmChangedHandlersRemoved() {
-        realm.close(); // Clear handler created by testRealm in setUp()
-        assertEquals(0, Realm.getHandlers().size());
-        final String REALM_NAME = "test-internalhandlers";
-        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
-        Realm.deleteRealm(realmConfig);
-
-        // Open and close first instance of a Realm
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(realmConfig);
-            assertFalse(this.realm == realm);
-            assertEquals(1, Realm.getHandlers().size());
-            realm.close();
-
-            // All Realms closed. No handlers should be alive.
-            assertEquals(0, Realm.getHandlers().size());
-
-            // Open instance the 2nd time. Old handler should now be gone
-            realm = Realm.getInstance(realmConfig);
-            assertEquals(1, Realm.getHandlers().size());
-            realm.close();
-
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
     @Test
     public void getInstance() {
         assertNotNull("Realm.getInstance unexpectedly returns null", realm);
@@ -509,7 +471,7 @@ public void nestedTransaction() {
             realm.beginTransaction();
             fail();
         } catch (IllegalStateException e) {
-            assertEquals("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().", e.getMessage());
+            assertTrue(e.getMessage().startsWith("The Realm is already in a write transaction"));
         }
         realm.commitTransaction();
     }
@@ -521,6 +483,7 @@ public void nestedTransaction() {
         METHOD_DELETE_TYPE,
         METHOD_DELETE_ALL,
         METHOD_CREATE_OBJECT,
+        METHOD_CREATE_OBJECT_WITH_PRIMARY_KEY,
         METHOD_COPY_TO_REALM,
         METHOD_COPY_TO_REALM_OR_UPDATE,
         METHOD_CREATE_ALL_FROM_JSON,
@@ -563,6 +526,9 @@ public Boolean call() throws Exception {
                         case METHOD_CREATE_OBJECT:
                             realm.createObject(AllTypes.class);
                             break;
+                        case METHOD_CREATE_OBJECT_WITH_PRIMARY_KEY:
+                            realm.createObject(AllJavaTypes.class, 1L);
+                            break;
                         case METHOD_COPY_TO_REALM:
                             realm.copyToRealm(new AllTypes());
                             break;
@@ -573,13 +539,15 @@ public Boolean call() throws Exception {
                             realm.createAllFromJson(AllTypes.class, "[{}]");
                             break;
                         case METHOD_CREATE_OR_UPDATE_ALL_FROM_JSON:
-                            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "[{\"columnLong\":1}]");
+                            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "[{\"columnLong\":1," +
+                                    " \"columnBoolean\": true}]");
                             break;
                         case METHOD_CREATE_FROM_JSON:
                             realm.createObjectFromJson(AllTypes.class, "{}");
                             break;
                         case METHOD_CREATE_OR_UPDATE_FROM_JSON:
-                            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{\"columnLong\":1}");
+                            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{\"columnLong\":1," +
+                                    " \"columnBoolean\": true}");
                             break;
                         case METHOD_INSERT_COLLECTION:
                             realm.insert(Arrays.asList(new AllTypes(), new AllTypes()));
@@ -663,13 +631,14 @@ public void cancelTransaction() {
 
     @Test
     public void executeTransaction_null() {
+        SharedRealm.VersionID oldVersion = realm.sharedRealm.getVersionID();
         try {
             realm.executeTransaction(null);
             fail("null transaction should throw");
         } catch (IllegalArgumentException ignored) {
-
         }
-        assertFalse(realm.hasChanged());
+        SharedRealm.VersionID newVersion = realm.sharedRealm.getVersionID();
+        assertEquals(oldVersion, newVersion);
     }
 
     @Test
@@ -1015,27 +984,26 @@ public void compactRealm_encryptedEmptyRealm() {
         RealmConfiguration realmConfig = configFactory.createConfiguration("enc.realm", TestHelper.getRandomKey());
         Realm realm = Realm.getInstance(realmConfig);
         realm.close();
-        // TODO: remove try/catch block when compacting encrypted Realms is supported
-        try {
-            assertTrue(Realm.compactRealm(realmConfig));
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
+        assertTrue(Realm.compactRealm(realmConfig));
+        realm = Realm.getInstance(realmConfig);
+        assertFalse(realm.isClosed());
+        assertTrue(realm.isEmpty());
+        realm.close();
     }
 
     @Test
     public void compactRealm_encryptedPopulatedRealm() {
+        final int DATA_SIZE = 100;
         RealmConfiguration realmConfig = configFactory.createConfiguration("enc.realm", TestHelper.getRandomKey());
         Realm realm = Realm.getInstance(realmConfig);
 
-        populateTestRealm(realm, 100);
+        populateTestRealm(realm, DATA_SIZE);
+        realm.close();
+        assertTrue(Realm.compactRealm(realmConfig));
+        realm = Realm.getInstance(realmConfig);
+        assertFalse(realm.isClosed());
+        assertEquals(DATA_SIZE, realm.where(AllTypes.class).count());
         realm.close();
-        // TODO: remove try/catch block when compacting encrypted Realms is supported
-        try {
-            assertTrue(Realm.compactRealm(realmConfig));
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
     }
 
     @Test
@@ -1243,7 +1211,7 @@ public void copyToRealm_convertsNullToDefaultValue() {
     @Test
     public void copyToRealm_primaryKeyIsSetDirectly() {
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class);
+        realm.createObject(OwnerPrimaryKey.class, 0);
         realm.copyToRealm(new OwnerPrimaryKey(1, "Foo"));
         realm.commitTransaction();
         assertEquals(2, realm.where(OwnerPrimaryKey.class).count());
@@ -1323,9 +1291,8 @@ public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
         realm.beginTransaction();
 
         // Child object is managed by Realm
-        CyclicTypePrimaryKey childObj = realm.createObject(CyclicTypePrimaryKey.class);
+        CyclicTypePrimaryKey childObj = realm.createObject(CyclicTypePrimaryKey.class, 1);
         childObj.setName("Child");
-        childObj.setId(1);
 
         // Parent object is an unmanaged object
         CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
@@ -1737,7 +1704,7 @@ public void copyToRealmOrUpdate_objectInOtherThreadThrows() {
         final CountDownLatch bgThreadDoneLatch = new CountDownLatch(1);
 
         realm.beginTransaction();
-        final OwnerPrimaryKey ownerPrimaryKey = realm.createObject(OwnerPrimaryKey.class);
+        final OwnerPrimaryKey ownerPrimaryKey = realm.createObject(OwnerPrimaryKey.class, 0);
         realm.commitTransaction();
 
         new Thread(new Runnable() {
@@ -1845,11 +1812,7 @@ public void writeEncryptedCopyTo() throws Exception {
 
         // Write encrypted copy from a unencrypted Realm
         File destination = new File(encryptedRealmConfig.getPath());
-        try {
-            realm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
-        } catch (Exception e) {
-            fail(e.getMessage());
-        }
+        realm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
 
         Realm encryptedRealm = null;
         try {
@@ -1859,11 +1822,7 @@ public void writeEncryptedCopyTo() throws Exception {
             assertEquals(TEST_DATA_SIZE, encryptedRealm.where(AllTypes.class).count());
 
             destination = new File(reEncryptedRealmConfig.getPath());
-            try {
-                encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
-            } catch (Exception e) {
-                fail(e.getMessage());
-            }
+            encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
 
             // Verify re-encrypted copy
             Realm reEncryptedRealm = null;
@@ -1881,11 +1840,7 @@ public void writeEncryptedCopyTo() throws Exception {
 
             // Write non-encrypted copy from the encrypted version
             destination = new File(decryptedRealmConfig.getPath());
-            try {
-                encryptedRealm.writeEncryptedCopyTo(destination, null);
-            } catch (Exception e) {
-                fail(e.getMessage());
-            }
+            encryptedRealm.writeEncryptedCopyTo(destination, null);
 
             // Verify decrypted Realm and cleanup
             Realm decryptedRealm = null;
@@ -1910,6 +1865,14 @@ public void writeEncryptedCopyTo() throws Exception {
         }
     }
 
+    @Test
+    public void writeEncryptedCopyTo_wrongKeyLength() {
+        byte[]  wrongLengthKey = new byte[42];
+        File destination = new File(configFactory.getRoot(), "wrong_key.realm");
+        thrown.expect(IllegalArgumentException.class);
+        realm.writeEncryptedCopyTo(destination, wrongLengthKey);
+    }
+
     @Test
     public void deleteRealm_failures() {
         final String OTHER_REALM_NAME = "yetAnotherRealm.realm";
@@ -1949,8 +1912,7 @@ public void setter_updateField() throws Exception {
         realm.beginTransaction();
 
         // Create an owner with two dogs
-        OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class);
-        owner.setId(1);
+        OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class, 1);
         owner.setName("Jack");
         Dog rex = realm.createObject(Dog.class);
         rex.setName("Rex");
@@ -1978,7 +1940,9 @@ public void deleteRealm() throws InterruptedException {
         File tempDirRenamed = new File(configFactory.getRoot(), "delete_test_dir_2");
         assertTrue(tempDir.mkdir());
 
-        final RealmConfiguration configuration = new RealmConfiguration.Builder(tempDir).build();
+        final RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(tempDir)
+                .build();
 
         final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
         final CountDownLatch readyToCloseLatch = new CountDownLatch(1);
@@ -2052,79 +2016,26 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
 
         try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (IllegalStateException expected) {}
         try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (IllegalStateException expected) {}
-        try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);       fail(); } catch (IllegalStateException expected) {}
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);   fail(); } catch (IllegalStateException expected) {}
+        }
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
+        }
 
         try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (IllegalStateException expected) {}
         try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (IllegalStateException expected) {}
-        try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);          fail(); } catch (IllegalStateException expected) {}
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);      fail(); } catch (IllegalStateException expected) {}
+        }
         try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (IllegalStateException expected) {}
         try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
-    }
-
-    // TODO: re-introduce this test mocking the ReferenceQueue instead of relying on the GC
-/*    // Check that FinalizerRunnable can free native resources (phantom refs)
-    public void testReferenceCleaning() throws NoSuchFieldException, IllegalAccessException {
-        testRealm.close();
-
-        RealmConfiguration config = new RealmConfiguration.Builder(getContext()).name("myown").build();
-        Realm.deleteRealm(config);
-        testRealm = Realm.getInstance(config);
-
-        // Manipulate field accessibility to facilitate testing
-        Field realmFileReference = BaseRealm.class.getDeclaredField("sharedGroupManager");
-        realmFileReference.setAccessible(true);
-        Field contextField = SharedGroup.class.getDeclaredField("context");
-        contextField.setAccessible(true);
-        Field rowReferencesField = io.realm.internal.Context.class.getDeclaredField("rowReferences");
-        rowReferencesField.setAccessible(true);
-
-        SharedGroupManager realmFile = (SharedGroupManager) realmFileReference.get(testRealm);
-        assertNotNull(realmFile);
-
-        io.realm.internal.Context context = (io.realm.internal.Context) contextField.get(realmFile.getSharedGroup());
-        assertNotNull(context);
-
-        Map<Reference<?>, Integer> rowReferences = (Map<Reference<?>, Integer>) rowReferencesField.get(context);
-        assertNotNull(rowReferences);
-
-        // insert some rows, then give the thread some time to cleanup
-        // we have 8 reference so far let's add more
-        final int numberOfPopulateTest = 1000;
-        final int numberOfObjects = 20;
-        final int totalNumberOfReferences = 8 + numberOfObjects * 2 * numberOfPopulateTest;
-
-        long tic = System.currentTimeMillis();
-        for (int i = 0; i < numberOfPopulateTest; i++) {
-            populateTestRealm(testRealm, numberOfObjects);
-        }
-        long toc = System.currentTimeMillis();
-        Log.d(RealmTest.class.getName(), "Insertion time: " + (toc - tic));
-
-        final int MAX_GC_RETRIES = 5;
-        int numberOfRetries = 0;
-        Log.i("GCing", "Hoping for the best");
-        while (rowReferences.size() > 0 && numberOfRetries < MAX_GC_RETRIES) {
-            SystemClock.sleep(TimeUnit.SECONDS.toMillis(1)); //1s
-            TestHelper.allocGarbage(0);
-            numberOfRetries++;
-            System.gc();
-        }
-        context.cleanNativeReferences();
-
-        // we can't guarantee that all references have been GC'ed but we should detect a decrease
-        boolean isDecreasing = rowReferences.size() < totalNumberOfReferences;
-        if (!isDecreasing) {
-            fail("Native resources are not being closed");
-
-        } else {
-            android.util.Log.d(RealmTest.class.getName(), "References freed : "
-                    + (totalNumberOfReferences - rowReferences.size()) + " out of " + totalNumberOfReferences);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);fail(); } catch (IllegalStateException expected) {}
         }
-    }*/
+    }
 
     @Test
     public void createObject_cannotCreateDynamicRealmObject() {
@@ -2136,12 +2047,18 @@ public void createObject_cannotCreateDynamicRealmObject() {
         }
     }
 
+    @Test(expected = RealmException.class)
+    public void createObject_absentPrimaryKeyThrows() {
+        realm.beginTransaction();
+        realm.createObject(DogPrimaryKey.class);
+    }
+
     @Test
     public void createObjectWithPrimaryKey() {
         realm.beginTransaction();
         AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 42);
         assertEquals(1, realm.where(AllJavaTypes.class).count());
-        assertEquals(42, obj.getFieldLong());
+        assertEquals(42, obj.getFieldId());
     }
 
     @Test
@@ -2302,6 +2219,320 @@ public void createObjectWithPrimaryKey_nullDuplicated() {
         realm.cancelTransaction();
     }
 
+    @Test
+    public void createObject_defaultValueFromModelField() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // create a DefaultValueOfField with non-default primary key value
+                realm.createObject(DefaultValueOfField.class,
+                        DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+            }
+        });
+        final String createdRandomString = DefaultValueOfField.lastRandomStringValue;
+
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_STRING,
+                DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_RANDOM_STRING, createdRandomString);
+        testOneObjectFound(realm, DefaultValueOfField.class,DefaultValueOfField.FIELD_SHORT,
+                DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_INT,
+                DefaultValueOfField.FIELD_INT_DEFAULT_VALUE);
+        // default value for pk must be ignored
+        testNoObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LONG,
+                DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_BYTE,
+                DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_FLOAT,
+                DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_DOUBLE,
+                DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_BOOLEAN,
+                DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_DATE,
+                DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_BINARY,
+                DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+    }
+
+    @Test
+    public void createObject_overwriteNullifiedLinkWithDefaultValue() {
+        final DefaultValueOverwriteNullLink created;
+        realm.beginTransaction();
+        created = realm.createObject(DefaultValueOverwriteNullLink.class);
+        realm.commitTransaction();
+
+        assertEquals(created.getExpectedKeyOfFieldObject(), created.getFieldObject().getFieldRandomPrimaryKey());
+    }
+
+    @Test
+    public void createObject_defaultValueFromModelConstructor() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // create a DefaultValueConstructor with non-default primary key value
+                realm.createObject(DefaultValueConstructor.class,
+                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+            }
+        });
+        final String createdRandomString = DefaultValueConstructor.lastRandomStringValue;
+
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_STRING,
+                DefaultValueConstructor.FIELD_STRING_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_RANDOM_STRING,
+                createdRandomString);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_SHORT,
+                DefaultValueConstructor.FIELD_SHORT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_INT,
+                DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);;
+        // default value for pk must be ignored
+        testNoObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LONG,
+                DefaultValueConstructor.FIELD_LONG_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_BYTE,
+                DefaultValueConstructor.FIELD_BYTE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_FLOAT,
+                DefaultValueConstructor.FIELD_FLOAT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_DOUBLE,
+                DefaultValueConstructor.FIELD_DOUBLE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_BOOLEAN,
+                DefaultValueConstructor.FIELD_BOOLEAN_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_DATE, DefaultValueConstructor.FIELD_DATE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_BINARY,
+                DefaultValueConstructor.FIELD_BINARY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+    }
+
+    @Test
+    public void createObject_defaultValueSetterInConstructor() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // create a DefaultValueSetter with non-default primary key value
+                realm.createObject(DefaultValueSetter.class,
+                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+            }
+        });
+        final String createdRandomString = DefaultValueSetter.lastRandomStringValue;
+
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_STRING,
+                DefaultValueSetter.FIELD_STRING_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_RANDOM_STRING,
+                createdRandomString);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_SHORT,
+                DefaultValueSetter.FIELD_SHORT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_INT,
+                DefaultValueSetter.FIELD_INT_DEFAULT_VALUE);
+        // default value for pk must be ignored
+        testNoObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LONG,
+                DefaultValueSetter.FIELD_LONG_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_BYTE,
+                DefaultValueSetter.FIELD_BYTE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_FLOAT,
+                DefaultValueSetter.FIELD_FLOAT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_DOUBLE,
+                DefaultValueSetter.FIELD_DOUBLE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_BOOLEAN,
+                DefaultValueSetter.FIELD_BOOLEAN_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_DATE,
+                DefaultValueSetter.FIELD_DATE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_BINARY,
+                DefaultValueSetter.FIELD_BINARY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LIST+ "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
+    }
+
+    @Test
+    public void copyToRealm_defaultValuesAreIgnored() {
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        final DefaultValueOfField managedObj;
+        realm.beginTransaction(); {
+            final DefaultValueOfField obj = new DefaultValueOfField();
+            obj.setFieldIgnored(fieldIgnoredValue);
+            obj.setFieldString(fieldStringValue);
+            obj.setFieldRandomString(fieldRandomStringValue);
+            obj.setFieldShort(fieldShortValue);
+            obj.setFieldInt(fieldIntValue);
+            obj.setFieldLongPrimaryKey(fieldLongPrimaryKeyValue);
+            obj.setFieldLong(fieldLongValue);
+            obj.setFieldByte(fieldByteValue);
+            obj.setFieldFloat(fieldFloatValue);
+            obj.setFieldDouble(fieldDoubleValue);
+            obj.setFieldBoolean(fieldBooleanValue);
+            obj.setFieldDate(fieldDateValue);
+            obj.setFieldBinary(fieldBinaryValue);
+
+            final RandomPrimaryKey fieldObjectValue = new RandomPrimaryKey();
+            fieldObjectValue.setFieldInt(fieldObjectIntValue);
+            obj.setFieldObject(fieldObjectValue);
+
+            final RealmList<RandomPrimaryKey> list = new RealmList<>();
+            final RandomPrimaryKey listItem = new RandomPrimaryKey();
+            listItem.setFieldInt(fieldListIntValue);
+            list.add(listItem);
+            obj.setFieldList(list);
+
+            managedObj = realm.copyToRealm(obj);
+        }
+        realm.commitTransaction();
+
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                managedObj.getFieldIgnored());
+        assertEquals(fieldStringValue, managedObj.getFieldString());
+        assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
+        assertEquals(fieldShortValue, managedObj.getFieldShort());
+        assertEquals(fieldIntValue, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, managedObj.getFieldLong());
+        assertEquals(fieldByteValue, managedObj.getFieldByte());
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
+        assertEquals(fieldDateValue, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(fieldListIntValue, managedObj.getFieldList().first().getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(2, realm.where(RandomPrimaryKey.class).count());
+    }
+
+    @Test
+    public void copyFromRealm_defaultValuesAreIgnored() {
+        final DefaultValueOfField managedObj;
+        realm.beginTransaction(); {
+            final DefaultValueOfField obj = new DefaultValueOfField();
+            obj.setFieldIgnored(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified");
+            obj.setFieldString(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified");
+            obj.setFieldRandomString("non-random");
+            obj.setFieldShort((short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1));
+            obj.setFieldInt(DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1);
+            obj.setFieldLongPrimaryKey(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1);
+            obj.setFieldLong(DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1);
+            obj.setFieldByte((byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1));
+            obj.setFieldFloat(DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1);
+            obj.setFieldDouble(DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1);
+            obj.setFieldBoolean(!DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE);
+            obj.setFieldDate(new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1));
+            obj.setFieldBinary(new byte[] {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)});
+
+            final RandomPrimaryKey fieldObjectValue = new RandomPrimaryKey();
+            fieldObjectValue.setFieldInt(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
+            obj.setFieldObject(fieldObjectValue);
+
+            final RealmList<RandomPrimaryKey> list = new RealmList<>();
+            final RandomPrimaryKey listItem = new RandomPrimaryKey();
+            listItem.setFieldInt(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2);
+            list.add(listItem);
+            obj.setFieldList(list);
+
+            managedObj = realm.copyToRealm(obj);
+        }
+        realm.commitTransaction();
+
+        final DefaultValueOfField copy = realm.copyFromRealm(managedObj);
+
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE, copy.getFieldIgnored());
+        assertEquals(managedObj.getFieldString(), copy.getFieldString());
+        assertEquals(managedObj.getFieldRandomString(), copy.getFieldRandomString());
+        assertEquals(managedObj.getFieldShort(), copy.getFieldShort());
+        assertEquals(managedObj.getFieldInt(), copy.getFieldInt());
+        assertEquals(managedObj.getFieldLongPrimaryKey(), copy.getFieldLongPrimaryKey());
+        assertEquals(managedObj.getFieldLong(), copy.getFieldLong());
+        assertEquals(managedObj.getFieldByte(), copy.getFieldByte());
+        assertEquals(managedObj.getFieldFloat(), copy.getFieldFloat(), 0f);
+        assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0d);
+        assertEquals(managedObj.isFieldBoolean(), copy.isFieldBoolean());
+        assertEquals(managedObj.getFieldDate(), copy.getFieldDate());
+        assertTrue(Arrays.equals(managedObj.getFieldBinary(), copy.getFieldBinary()));
+        assertEquals(managedObj.getFieldObject().getFieldInt(), copy.getFieldObject().getFieldInt());
+        assertEquals(1, copy.getFieldList().size());
+        assertEquals(managedObj.getFieldList().first().getFieldInt(), copy.getFieldList().first().getFieldInt());
+    }
+
     // Test close Realm in another thread different from where it is created.
     @Test
     public void close_differentThread() throws InterruptedException {
@@ -3430,22 +3661,135 @@ public void run(Realm realm) {
     }
 
     @Test
-    public void incompatibleLockFile() throws IOException {
-        // Replace .lock file with a corrupted one
-        File lockFile = new File(realmConfig.getPath() + ".lock");
-        assertTrue(lockFile.exists());
-        FileOutputStream fooStream = new FileOutputStream(lockFile, false);
-        fooStream.write("Boom".getBytes());
-        fooStream.close();
+    public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
+        final CatRealmProxy.CatColumnInfo catColumnInfo;
+        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.columnIndices.getColumnInfo(Cat.class);
 
-        try {
-            // This will try to open a second SharedGroup which should fail when the .lock file is corrupt
-            DynamicRealm.getInstance(realm.getConfiguration());
-            fail();
-        } catch (RealmError expected) {
-            assertTrue(expected.getMessage().contains("Info size doesn't match"));
-        } finally {
-            lockFile.delete();
-        }
+        final long nameIndex = catColumnInfo.nameIndex;
+        final AtomicLong nameIndexNew = new AtomicLong(-1L);
+
+        // change column index of "name"
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Table catTable = realm.getSchema().getTable(Cat.CLASS_NAME);
+                final long nameIndex = catTable.getColumnIndex(Cat.FIELD_NAME);
+                catTable.removeColumn(nameIndex);
+                final long newIndex = catTable.addColumn(RealmFieldType.STRING,
+                        Cat.FIELD_NAME, true);
+
+                realm.setVersion(realm.getConfiguration().getSchemaVersion() + 1);
+
+                nameIndexNew.set(newIndex);
+            }
+        });
+        // we need ↓ to update index cache if the schema version was changed in the same thread.
+        realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
+
+        // check if the index was changed
+        assertNotEquals(nameIndex, nameIndexNew);
+
+        // check if index in the ColumnInfo is updated
+        assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
+        assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
+
+        // check by actual get and set
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Cat cat = realm.createObject(Cat.class);
+                cat.setName("pochi");
+            }
+        });
+        //noinspection ConstantConditions
+        assertEquals("pochi", realm.where(Cat.class).findFirst().getName());
+    }
+
+    @Test
+    public void getGlobalInstanceCount() {
+        final CountDownLatch bgDone = new CountDownLatch(1);
+
+        final RealmConfiguration config = configFactory.createConfiguration("globalCountTest");
+        assertEquals(0, Realm.getGlobalInstanceCount(config));
+
+        // Open thread local Realm
+        Realm realm = Realm.getInstance(config);
+        assertEquals(1, Realm.getGlobalInstanceCount(config));
+
+        // Open thread local DynamicRealm
+        DynamicRealm dynRealm = DynamicRealm.getInstance(config);
+        assertEquals(2, Realm.getGlobalInstanceCount(config));
+
+        // Open Realm in another thread
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(config);
+                assertEquals(3, Realm.getGlobalInstanceCount(config));
+                realm.close();
+                assertEquals(2, Realm.getGlobalInstanceCount(config));
+                bgDone.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgDone);
+        dynRealm.close();
+        assertEquals(1, Realm.getGlobalInstanceCount(config));
+        realm.close();
+        assertEquals(0, Realm.getGlobalInstanceCount(config));
+    }
+
+    @Test
+    public void getLocalInstanceCount() {
+        final RealmConfiguration config = configFactory.createConfiguration("localInstanceCount");
+        assertEquals(0, Realm.getLocalInstanceCount(config));
+
+        // Open thread local Realm
+        Realm realm = Realm.getInstance(config);
+        assertEquals(1, Realm.getLocalInstanceCount(config));
+
+        // Open thread local DynamicRealm
+        DynamicRealm dynRealm = DynamicRealm.getInstance(config);
+        assertEquals(2, Realm.getLocalInstanceCount(config));
+
+        dynRealm.close();
+        assertEquals(1, Realm.getLocalInstanceCount(config));
+        realm.close();
+        assertEquals(0, Realm.getLocalInstanceCount(config));
+    }
+
+    @Test
+    public void namedPipeDirForExternalStorage() {
+
+        // test for https://github.com/realm/realm-java/issues/3140
+        realm.close();
+        realm = null;
+
+        final File namedPipeDir = SharedRealm.getTemporaryDirectory();
+        assertTrue(namedPipeDir.isDirectory());
+        TestHelper.deleteRecursively(namedPipeDir);
+        //noinspection ResultOfMethodCallIgnored
+        namedPipeDir.mkdirs();
+
+        final File externalFilesDir = context.getExternalFilesDir(null);
+        final RealmConfiguration config = new RealmConfiguration.Builder()
+                .directory(externalFilesDir)
+                .name("external.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        // test if it works when the namedPipeDir is empty.
+        Realm realmOnExternalStorage = Realm.getInstance(config);
+        realmOnExternalStorage.close();
+
+        assertTrue(namedPipeDir.isDirectory());
+
+        Assume.assumeTrue("SELinux is not enforced on this device.", TestHelper.isSelinuxEnforcing());
+
+        assertEquals(2, namedPipeDir.list().length);
+
+        // test if it works when the namedPipeDir and the named pipe files already exist.
+        realmOnExternalStorage = Realm.getInstance(config);
+        realmOnExternalStorage.close();
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 396e9cdf91..bb2f61f4cb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -153,19 +153,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -179,19 +179,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -205,19 +205,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -231,19 +231,19 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 94d2d2e460..321c5d927c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -18,7 +18,9 @@
 
 import android.content.Context;
 import android.content.res.AssetManager;
+import android.os.Build;
 import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
 import android.util.Log;
 
 import org.junit.Assert;
@@ -37,6 +39,7 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.Date;
+import java.util.Locale;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -56,11 +59,12 @@
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.internal.log.Logger;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLogger;
 import io.realm.rule.TestRealmConfigurationFactory;
 
+import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.fail;
-import static org.junit.Assert.assertEquals;
 
 public class TestHelper {
 
@@ -165,68 +169,22 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     }
 
     /**
-     * Returns a Logger that will fail if it is asked to log a message above a certain level.
+     * Returns a RealmLogger that will fail if it is asked to log a message above a certain level.
      *
      * @param failureLevel {@link Log} level from which the unit test will fail.
-     * @return Logger implementation
+     * @return RealmLogger implementation
      */
-    public static Logger getFailureLogger(final int failureLevel) {
-        return new Logger() {
-
-            private void failIfEqualOrAbove(int logLevel, int failureLevel) {
+    public static RealmLogger getFailureLogger(final int failureLevel) {
+        return new RealmLogger() {
+            private void failIfEqualOrAbove(int logLevel) {
                 if (logLevel >= failureLevel) {
                     fail("Message logged that was above valid level: " + logLevel + " >= " + failureLevel);
                 }
             }
 
             @Override
-            public void v(String message) {
-                failIfEqualOrAbove(Log.VERBOSE, failureLevel);
-            }
-
-            @Override
-            public void v(String message, Throwable t) {
-                failIfEqualOrAbove(Log.VERBOSE, failureLevel);
-            }
-
-            @Override
-            public void d(String message) {
-                failIfEqualOrAbove(Log.DEBUG, failureLevel);
-            }
-
-            @Override
-            public void d(String message, Throwable t) {
-                failIfEqualOrAbove(Log.DEBUG, failureLevel);
-            }
-
-            @Override
-            public void i(String message) {
-                failIfEqualOrAbove(Log.INFO, failureLevel);
-            }
-
-            @Override
-            public void i(String message, Throwable t) {
-                failIfEqualOrAbove(Log.INFO, failureLevel);
-            }
-
-            @Override
-            public void w(String message) {
-                failIfEqualOrAbove(Log.WARN, failureLevel);
-            }
-
-            @Override
-            public void w(String message, Throwable t) {
-                failIfEqualOrAbove(Log.WARN, failureLevel);
-            }
-
-            @Override
-            public void e(String message) {
-                failIfEqualOrAbove(Log.ERROR, failureLevel);
-            }
-
-            @Override
-            public void e(String message, Throwable t) {
-                failIfEqualOrAbove(Log.ERROR, failureLevel);
+            public void log(int level, String tag, Throwable throwable, String message) {
+                failIfEqualOrAbove(level);
             }
         };
     }
@@ -243,64 +201,26 @@ public static String getRandomString(int length) {
     /**
      * Returns a naive logger that can be used to test the values that are sent to the logger.
      */
-    public static class TestLogger implements Logger {
+    public static class TestLogger implements RealmLogger {
 
+        private final int minimumLevel;
         public String message;
         public Throwable throwable;
 
-        @Override
-        public void v(String message) {
-            this.message = message;
-        }
-
-        @Override
-        public void v(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
-        }
-
-        @Override
-        public void d(String message) {
-            this.message = message;
-        }
-
-        @Override
-        public void d(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
+        public TestLogger() {
+            this(LogLevel.DEBUG);
         }
 
-        @Override
-        public void i(String message) {
-            this.message = message;
+        public TestLogger(int minimumLevel) {
+            this.minimumLevel = minimumLevel;
         }
 
         @Override
-        public void i(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
-        }
-
-        @Override
-        public void w(String message) {
-            this.message = message;
-        }
-
-        @Override
-        public void w(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
-        }
-
-        @Override
-        public void e(String message) {
-            this.message = message;
-        }
-
-        @Override
-        public void e(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
+        public void log(int level, String tag, Throwable throwable, String message) {
+            if (minimumLevel <= level) {
+                this.message = message;
+                this.throwable = throwable;
+            }
         }
     }
 
@@ -382,7 +302,9 @@ public static RealmConfiguration createConfiguration(Context context, String nam
      */
     @Deprecated
     public static RealmConfiguration createConfiguration(File dir, String name, byte[] key) {
-        RealmConfiguration.Builder config = new RealmConfiguration.Builder(dir).name(name);
+        RealmConfiguration.Builder config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(dir)
+                .name(name);
         if (key != null) {
             config.encryptionKey(key);
         }
@@ -945,6 +867,64 @@ public static void quitLooperOrFail() {
         }
     }
 
+    public static void testNoObjectFound(
+            Realm realm,
+            Class<? extends RealmModel> clazz,
+            String fieldName, Object value) {
+        testObjectCount(realm, 0L, clazz, fieldName, value);
+    }
+
+    public static void testOneObjectFound(
+            Realm realm,
+            Class<? extends RealmModel> clazz,
+            String fieldName, Object value) {
+        testObjectCount(realm, 1L, clazz, fieldName, value);
+    }
+
+    public static void testObjectCount(
+            Realm realm,
+            long expectedCount,
+            Class<? extends RealmModel> clazz,
+            String fieldName, Object value) {
+        final RealmQuery<? extends RealmModel> query;
+        switch (value.getClass().getSimpleName()) {
+            case "String":
+                query = realm.where(clazz).equalTo(fieldName, (String) value);
+                break;
+            case "Byte":
+                query = realm.where(clazz).equalTo(fieldName, (Byte) value);
+                break;
+            case "Short":
+                query = realm.where(clazz).equalTo(fieldName, (Short) value);
+                break;
+            case "Integer":
+                query = realm.where(clazz).equalTo(fieldName, (Integer) value);
+                break;
+            case "Long":
+                query = realm.where(clazz).equalTo(fieldName, (Long) value);
+                break;
+            case "Float":
+                query = realm.where(clazz).equalTo(fieldName, (Float) value);
+                break;
+            case "Double":
+                query = realm.where(clazz).equalTo(fieldName, (Double) value);
+                break;
+            case "Boolean":
+                query = realm.where(clazz).equalTo(fieldName, (Boolean) value);
+                break;
+            case "Date":
+                query = realm.where(clazz).equalTo(fieldName, (Date) value);
+                break;
+            case "byte[]":
+                query = realm.where(clazz).equalTo(fieldName, (byte[]) value);
+                break;
+            default:
+                throw new AssertionError("unknown type: " + value.getClass().getSimpleName());
+        }
+
+        assertEquals(expectedCount, query.count());
+    }
+
     /**
      * Replaces the current thread executor with a another one for testing.
      * WARNING: This method should only be called before any async tasks have been started.
@@ -1037,4 +1017,50 @@ public void run() {
             throw throwable;
         }
     }
+
+    @SuppressWarnings("WeakerAccess")
+    public static void deleteRecursively(File file) {
+        if (!file.exists()) {
+            return;
+        }
+        if (file.isDirectory()) {
+            for (File f : file.listFiles()) {
+                deleteRecursively(f);
+            }
+        }
+
+        if (!file.delete()) {
+            throw new AssertionError("failed to delete " + file.getAbsolutePath());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    public static boolean isSelinuxEnforcing() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            // SELinux is not enabled for these versions.
+            return false;
+        }
+        try {
+            final Process process = new ProcessBuilder("/system/bin/getenforce").start();
+            try {
+                final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    return reader.readLine().toLowerCase(Locale.ENGLISH).equals("enforcing");
+                } finally {
+                    try {
+                        reader.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            } finally {
+                try {
+                    process.waitFor();
+                } catch (InterruptedException ignored) {
+                }
+            }
+        } catch (IOException e) {
+            return false;
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index b3784cbe05..5ce7dd5cb8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -16,6 +16,7 @@
 package io.realm;
 
 import android.content.Context;
+import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.support.test.InstrumentationRegistry;
@@ -48,12 +49,14 @@
 import io.realm.rule.TestRealmConfigurationFactory;
 import io.realm.util.RealmBackgroundTask;
 
+import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 @RunWith(AndroidJUnit4.class)
 public class TypeBasedNotificationsTests {
@@ -250,6 +253,8 @@ public void onChange(PrimaryKeyAsLong object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson() {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         final Realm realm = looperThread.realm;
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
@@ -356,6 +361,8 @@ public void onChange(AllTypes object) {
     @Test
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
+        assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
+
         final Realm realm = looperThread.realm;
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
index d2d2bc41f9..ea515284b7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
@@ -173,7 +173,7 @@ public void load() {
 
     @Test
     public void isValid() {
-        assertFalse(collection.isValid());
+        assertTrue(collection.isValid());
     }
 
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
index 70f6aab05d..d74ed31181 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
@@ -99,7 +99,8 @@ public void unsupportedMethods_unManagedCollections() {
                     case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
 
                     // Supported methods
-                    case IS_VALID: assertFalse(collection.isValid()); continue;
+                    case IS_VALID: assertTrue(collection.isValid()); continue;
+                    case IS_MANAGED: assertFalse(collection.isManaged()); continue;
                 }
                 fail(method + " should have thrown an exception.");
             } catch (UnsupportedOperationException ignored) {
@@ -119,7 +120,12 @@ public void load() {
 
     @Test
     public void isValid() {
-        assertFalse(collection.isValid());
+        assertTrue(collection.isValid());
+    }
+
+    @Test
+    public void isManaged() {
+        assertFalse(collection.isManaged());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 2a5308d913..515eea403c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -32,6 +32,7 @@
     public static String FIELD_SHORT = "fieldShort";
     public static String FIELD_INT = "fieldInt";
     public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_ID = "fieldId";
     public static String FIELD_BYTE = "fieldByte";
     public static String FIELD_FLOAT = "fieldFloat";
     public static String FIELD_DOUBLE = "fieldDouble";
@@ -46,9 +47,10 @@
 
     @Ignore private String fieldIgnored;
     @Index private String fieldString;
+    @PrimaryKey private long fieldId;
+    private long fieldLong;
     private short fieldShort;
     private int fieldInt;
-    @PrimaryKey private long fieldLong;
     private byte fieldByte;
     private float fieldFloat;
     private double fieldDouble;
@@ -63,6 +65,7 @@ public AllJavaTypes() {
     }
 
     public AllJavaTypes(long fieldLong) {
+        this.fieldId = fieldLong;
         this.fieldLong = fieldLong;
     }
 
@@ -90,6 +93,14 @@ public void setFieldShort(short fieldShort) {
         this.fieldShort = fieldShort;
     }
 
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
     public int getFieldInt() {
         return fieldInt;
     }
@@ -98,12 +109,12 @@ public void setFieldInt(int fieldInt) {
         this.fieldInt = fieldInt;
     }
 
-    public long getFieldLong() {
-        return fieldLong;
+    public long getFieldId() {
+        return fieldId;
     }
 
-    public void setFieldLong(long fieldLong) {
-        this.fieldLong = fieldLong;
+    public void setFieldId(long fieldId) {
+        this.fieldId = fieldId;
     }
 
     public byte getFieldByte() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
index 03e961f055..b9e218f3e2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
@@ -23,6 +23,14 @@
 public class Cat extends RealmObject {
 
     public static final String CLASS_NAME = "Cat";
+    public static final String FIELD_NAME = "name";
+    public static final String FIELD_AGE = "age";
+    public static final String FIELD_HEIGHT = "height";
+    public static final String FIELD_WEIGHT = "weight";
+    public static final String FIELD_HAS_TAIL = "hasTail";
+    public static final String FIELD_BIRTHDAY = "birthday";
+    public static final String FIELD_OWNER = "owner";
+    public static final String FIELD_SCARED_OF_DOG = "scaredOfDog";
 
     private String name;
     private long age;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
index a81d653aad..66ad9a11c8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
@@ -42,7 +42,7 @@ public boolean equals(Object o) {
             return reverseEquals;
         }
         CustomMethods other = (CustomMethods) o;
-        if (isValid() == other.isValid() && other.name.equals(name)) {
+        if (isManaged() == other.isManaged() && other.name.equals(name)) {
             return !reverseEquals;
         } else {
             return reverseEquals;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueConstructor.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueConstructor.java
new file mode 100644
index 0000000000..4aed4562b7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueConstructor.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueConstructor extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+
+    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+
+    static {
+        FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
+        FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
+        FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+    }
+
+    public static String lastRandomStringValue;
+
+    @Ignore private String fieldIgnored;
+    private String fieldString;
+    private String fieldRandomString;
+    private short fieldShort;
+    private int fieldInt;
+    @PrimaryKey private long fieldLongPrimaryKey;
+    private long fieldLong;
+    private byte fieldByte;
+    private float fieldFloat;
+    private double fieldDouble;
+    private boolean fieldBoolean;
+    private Date fieldDate;
+    private byte[] fieldBinary;
+    private RandomPrimaryKey fieldObject;
+    private RealmList<RandomPrimaryKey> fieldList;
+
+    public DefaultValueConstructor() {
+        fieldIgnored = FIELD_IGNORED_DEFAULT_VALUE;
+        fieldString = FIELD_STRING_DEFAULT_VALUE;
+        fieldRandomString = lastRandomStringValue = UUID.randomUUID().toString();
+        fieldShort = FIELD_SHORT_DEFAULT_VALUE;
+        fieldInt = FIELD_INT_DEFAULT_VALUE;
+        fieldLongPrimaryKey = FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE;
+        fieldLong = FIELD_LONG_DEFAULT_VALUE;
+        fieldByte = FIELD_BYTE_DEFAULT_VALUE;
+        fieldFloat = FIELD_FLOAT_DEFAULT_VALUE;
+        fieldDouble = FIELD_DOUBLE_DEFAULT_VALUE;
+        fieldBoolean = FIELD_BOOLEAN_DEFAULT_VALUE;
+        fieldDate = FIELD_DATE_DEFAULT_VALUE;
+        fieldBinary = FIELD_BINARY_DEFAULT_VALUE;
+        fieldObject = FIELD_OBJECT_DEFAULT_VALUE;
+        fieldList = FIELD_LIST_DEFAULT_VALUE;
+    }
+
+    public DefaultValueConstructor(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public String getFieldRandomString() {
+        return fieldRandomString;
+    }
+
+    public void setFieldRandomString(String fieldRandomString) {
+        this.fieldRandomString = fieldRandomString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLongPrimaryKey() {
+        return fieldLongPrimaryKey;
+    }
+
+    public void setFieldLongPrimaryKey(long fieldLongPrimaryKey) {
+        this.fieldLongPrimaryKey = fieldLongPrimaryKey;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public RealmList<RandomPrimaryKey> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
+        this.fieldList = fieldList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
new file mode 100644
index 0000000000..0378e64817
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueOfField extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+
+    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+
+    static {
+        FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
+        FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
+        FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+    }
+
+    public static String lastRandomStringValue;
+
+    @Ignore private String fieldIgnored = FIELD_IGNORED_DEFAULT_VALUE;
+    private String fieldString = FIELD_STRING_DEFAULT_VALUE;
+    private String fieldRandomString = lastRandomStringValue = UUID.randomUUID().toString();
+    private short fieldShort = FIELD_SHORT_DEFAULT_VALUE;
+    private int fieldInt = FIELD_INT_DEFAULT_VALUE;
+    @PrimaryKey private long fieldLongPrimaryKey = FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE;
+    private long fieldLong = FIELD_LONG_DEFAULT_VALUE;
+    private byte fieldByte = FIELD_BYTE_DEFAULT_VALUE;
+    private float fieldFloat = FIELD_FLOAT_DEFAULT_VALUE;
+    private double fieldDouble = FIELD_DOUBLE_DEFAULT_VALUE;
+    private boolean fieldBoolean = FIELD_BOOLEAN_DEFAULT_VALUE;
+    private Date fieldDate = FIELD_DATE_DEFAULT_VALUE;
+    private byte[] fieldBinary = FIELD_BINARY_DEFAULT_VALUE;
+    private RandomPrimaryKey fieldObject = FIELD_OBJECT_DEFAULT_VALUE;
+    private RealmList<RandomPrimaryKey> fieldList = FIELD_LIST_DEFAULT_VALUE;
+
+    public DefaultValueOfField() {
+
+    }
+
+    public DefaultValueOfField(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public String getFieldRandomString() {
+        return fieldRandomString;
+    }
+
+    public void setFieldRandomString(String fieldRandomString) {
+        this.fieldRandomString = fieldRandomString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLongPrimaryKey() {
+        return fieldLongPrimaryKey;
+    }
+
+    public void setFieldLongPrimaryKey(long fieldLongPrimaryKey) {
+        this.fieldLongPrimaryKey = fieldLongPrimaryKey;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public RealmList<RandomPrimaryKey> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
+        this.fieldList = fieldList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOverwriteNullLink.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOverwriteNullLink.java
new file mode 100644
index 0000000000..e6f673de3a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOverwriteNullLink.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueOverwriteNullLink extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOverwriteNullLink";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String EXPECTED_KEY_OF_FIELD_OBJECT = "expectedKeyOfFieldObject";
+
+    private RandomPrimaryKey fieldObject;
+    private String expectedKeyOfFieldObject;
+
+    public DefaultValueOverwriteNullLink() {
+        final RandomPrimaryKey firstDefaultValue = new RandomPrimaryKey();
+        final RandomPrimaryKey secondDefaultValue = new RandomPrimaryKey();
+
+        expectedKeyOfFieldObject = secondDefaultValue.getFieldRandomPrimaryKey();
+
+        fieldObject = firstDefaultValue;
+        fieldObject = null;
+        fieldObject = secondDefaultValue;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public String getExpectedKeyOfFieldObject() {
+        return expectedKeyOfFieldObject;
+    }
+
+    public void setExpectedKeyOfFieldObject(String expectedKeyOfFieldObject) {
+        this.expectedKeyOfFieldObject = expectedKeyOfFieldObject;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueSetter.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueSetter.java
new file mode 100644
index 0000000000..e4583a9dc0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueSetter.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueSetter extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+
+    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+
+    static {
+        FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
+        FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
+        FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+    }
+
+    public static String lastRandomStringValue;
+
+    @Ignore private String fieldIgnored;
+    private String fieldString;
+    private String fieldRandomString;
+    private short fieldShort;
+    private int fieldInt;
+    @PrimaryKey private long fieldLongPrimaryKey;
+    private long fieldLong;
+    private byte fieldByte;
+    private float fieldFloat;
+    private double fieldDouble;
+    private boolean fieldBoolean;
+    private Date fieldDate;
+    private byte[] fieldBinary;
+    private RandomPrimaryKey fieldObject;
+    private RealmList<RandomPrimaryKey> fieldList;
+
+    public DefaultValueSetter() {
+        setFieldIgnored(FIELD_IGNORED_DEFAULT_VALUE);
+        setFieldString(FIELD_STRING_DEFAULT_VALUE);
+        setFieldRandomString(lastRandomStringValue = UUID.randomUUID().toString());
+        setFieldShort(FIELD_SHORT_DEFAULT_VALUE);
+        setFieldInt(FIELD_INT_DEFAULT_VALUE);
+        setFieldLongPrimaryKey(FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        setFieldLong(FIELD_LONG_DEFAULT_VALUE);
+        setFieldByte(FIELD_BYTE_DEFAULT_VALUE);
+        setFieldFloat(FIELD_FLOAT_DEFAULT_VALUE);
+        setFieldDouble(FIELD_DOUBLE_DEFAULT_VALUE);
+        setFieldBoolean(FIELD_BOOLEAN_DEFAULT_VALUE);
+        setFieldDate(FIELD_DATE_DEFAULT_VALUE);
+        setFieldBinary(FIELD_BINARY_DEFAULT_VALUE);
+        setFieldObject(FIELD_OBJECT_DEFAULT_VALUE);
+        setFieldList(FIELD_LIST_DEFAULT_VALUE);
+
+        final RandomPrimaryKey listItem2 = new RandomPrimaryKey();
+        listItem2.setFieldInt(listItem2.getFieldInt() + 1);
+        getFieldList().add(listItem2);
+    }
+
+    public DefaultValueSetter(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public String getFieldRandomString() {
+        return fieldRandomString;
+    }
+
+    public void setFieldRandomString(String fieldRandomString) {
+        this.fieldRandomString = fieldRandomString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLongPrimaryKey() {
+        return fieldLongPrimaryKey;
+    }
+
+    public void setFieldLongPrimaryKey(long fieldLongPrimaryKey) {
+        this.fieldLongPrimaryKey = fieldLongPrimaryKey;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public RealmList<RandomPrimaryKey> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
+        this.fieldList = fieldList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
index 6ad4929040..839681ba72 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
@@ -24,6 +24,7 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsBoxedLong";
     public static final String FIELD_PRIMARY_KEY = "id";
+    public static final String FIELD_NAME = "name";
 
     @PrimaryKey
     private Long id;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
index a7474a743c..95eeb8aa88 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsByte extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsByte";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private byte id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
index 4b12691d84..c54aa7b6fa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsInteger extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsInteger";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private int id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
index 9b803899ad..19fd734383 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsLong extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsLong";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private long id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
index b2a28c2213..092d256dd4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsShort extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsShort";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private short id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
index cb10b36f94..0206a2974c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
@@ -20,12 +20,19 @@
 import io.realm.annotations.PrimaryKey;
 
 public class PrimaryKeyWithNoPrimaryKeyObjectRelation extends RealmObject {
+    public static final String CLASS_NAME = "PrimaryKeyWithNoPrimaryKeyObjectRelation";
+    public static final String FIELD_COLUMN_STRING = "columnString";
+    public static final String FIELD_COLUMN_REALM_OBJECT_NO_PK = "columnRealmObjectNoPK";
+    public static final String FIELD_COLUMN_INT = "columnInt";
+
+    public static final int FIELD_COLUMN_INT_DEFAULT_VALUE = 8;
+
     @PrimaryKey
     private String columnString;
 
     private AllTypes columnRealmObjectNoPK;
 
-    private int columnInt = 8;
+    private int columnInt = FIELD_COLUMN_INT_DEFAULT_VALUE;
 
     public String getColumnString() {
         return columnString;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/RandomPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/RandomPrimaryKey.java
new file mode 100644
index 0000000000..d8d434e1ab
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/RandomPrimaryKey.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.UUID;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class RandomPrimaryKey extends RealmObject {
+
+    public static final String CLASS_NAME = "RandomPrimaryKey";
+    public static String FIELD_RANDOM_PRIMARY_KEY = "fieldRandomPrimaryKey";
+    public static String FIELD_INT = "fieldInt";
+
+
+    public static int FIELD_INT_DEFAULT_VALUE = 1357924;
+
+    @PrimaryKey private String fieldRandomPrimaryKey = UUID.randomUUID().toString();
+    private int fieldInt = FIELD_INT_DEFAULT_VALUE;
+
+    public RandomPrimaryKey() {
+    }
+
+    public String getFieldRandomPrimaryKey() {
+        return fieldRandomPrimaryKey;
+    }
+
+    public void setFieldRandomPrimaryKey(String fieldRandomPrimaryKey) {
+        this.fieldRandomPrimaryKey = fieldRandomPrimaryKey;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
index 6e87305827..4998ef8bb7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
@@ -29,6 +29,7 @@
 public class AllTypesRealmModel implements RealmModel {
     public static final String CLASS_NAME = "AllTypesRealmModel";
     public static final String FIELD_LONG = "columnLong";
+    public static final String FIELD_BYTE = "columnByte";
     public static final String FIELD_DOUBLE = "columnDouble";
     public static final String FIELD_STRING = "columnString";
     public static final String FIELD_BINARY = "columnBinary";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
deleted file mode 100644
index d9e8991f9e..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.test.AndroidTestCase;
-
-import java.io.Closeable;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-import io.realm.TestHelper;
-
-// Tables get detached
-
-public class JNICloseTest extends AndroidTestCase {
-
-    public void testCloseable() {
-
-        String testFile = new File(
-                this.getContext().getFilesDir(),
-                "closeableTest.realm").toString();
-        File f = new File(testFile);
-        if (f.exists()) {
-            boolean result = f.delete();
-            if (!result) {
-                fail();
-            }
-        }
-
-        List<Closeable> resources = new ArrayList<Closeable>();
-
-        SharedGroup sg = new SharedGroup(testFile);
-        resources.add(sg);
-
-        WriteTransaction wt = sg.beginWrite();
-        resources.add(wt);
-        try {
-            Table t = wt.getTable("test");
-            resources.add(t);
-            t.addColumn(RealmFieldType.STRING, "StringColumn");
-
-            t.add("abc");
-            t.add("cba");
-
-            wt.commit();
-
-        } catch(Throwable t) {
-            wt.rollback();
-        } finally {
-            for (Closeable c : resources) {
-                try {
-                    c.close();
-                } catch(java.io.IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    public void testShouldCloseTable() throws Throwable {
-        Table table = new Table();
-        table.close();
-
-        try { table.size();                            fail("Table is closed"); } catch (IllegalStateException e) { }
-        try { table.getColumnCount();                  fail("Table is closed"); } catch (IllegalStateException e) { }
-        try { table.addColumn(RealmFieldType.STRING, "");  fail("Table is closed"); } catch (IllegalStateException e) { }
-
-        // TODO: Test all methods...
-    }
-
-    // TODO: Much more testing needed.
-    // Verify that methods make exceptions when Tables are invalidated.
-    // Verify subtables are invalidated when table is changed/updated in any way.
-    // Check that Group.close works
-
-    public void testShouldCloseGroup() {
-
-        Group group = new Group();
-        group.close();
-
-        try { group.getTable("t");    fail("Group is closed"); } catch (IllegalStateException e) { }
-        try { group.size();                     fail("Group is closed"); } catch (IllegalStateException e) { }
-    }
-
-    /**
-     * Make sure, that it's possible to use the query on a closed table
-     */
-    public void testQueryAccessibleAfterTableClose() throws Throwable{
-        Table table = TestHelper.getTableWithAllColumnTypes();
-        table.addEmptyRows(10);
-        for (long i=0; i<table.size(); i++)
-            table.setLong(5, i, i);
-        TableQuery query = table.where();
-        // Closes the table, it _should_ be allowed to access the query thereafter
-        table.close();
-        table = null;
-        Table table2 = TestHelper.getTableWithAllColumnTypes();
-        table2.addEmptyRows(10);
-        for (int i=0; i<table2.size(); i++)
-            table2.setLong(5, i, 117+i);
-
-        TableView tv = query.findAll();
-        assertEquals(10, tv.size());
-
-        // TODO: add a lot of methods
-    }
-
-    public void testAccessingViewMethodsAfterTableClose() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
-        table.addEmptyRows(10);
-        TableQuery query = table.where();
-        TableView view = query.findAll();
-        //Closes the table, it should be allowed to access the view thereafter (table is ref-counted)
-        table.close();
-
-        // Accessing methods should be ok.
-        view.size();
-        view.getBinaryByteArray(0, 0);
-        view.getBoolean(1, 0);
-        view.getDate(2, 0);
-        view.getDouble(3, 0);
-        view.getFloat(4, 0);
-        view.getLong(5, 0);
-
-        // TODO - add all methods from view
-    }
-
-// TODO: this test is crashing
-/*    public void testShouldThrowWhenAccessingViewAfterTableIsDetached() {
-        final String testFile = "closetest.realm";
-        SharedGroup db;
-        File f = new File(this.getContext().getFilesDir(), testFile);
-        if (f.exists()) {
-            boolean result = f.delete();
-            if (!result) {
-                fail("Could not delete test file");
-            }
-        }
-        db = new SharedGroup(f.toString());
-
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.addColumn(RealmFieldType.INTEGER, "number");
-        TableView view = tbl.where().findAll();
-
-        trans.commit();
-
-        //methods below should throw exception, as table is invalid after commit
-        try { view.size();                       fail(); } catch (IllegalStateException e){}
-        try { view.getBinaryByteArray(0, 0);     fail(); } catch (IllegalStateException e){}
-        try { view.getBoolean(1, 0);             fail(); } catch (IllegalStateException e){}
-        try { view.getDate(2, 0);                fail(); } catch (IllegalStateException e){}
-        try { view.getDouble(3, 0);              fail(); } catch (IllegalStateException e){}
-        try { view.getFloat(4, 0);               fail(); } catch (IllegalStateException e){}
-        try { view.getLong(5, 0);                fail(); } catch (IllegalStateException e){}
-        try { view.getString(7, 0);              fail(); } catch (IllegalStateException e){}
-        // TODO: Add more methods
-
-        db.close();
-        boolean result = f.delete();
-        if (!result) {
-            fail("Could not delete test file");
-        }
-    }*/
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
deleted file mode 100644
index bbfcbbf011..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.test.AndroidTestCase;
-
-import java.io.File;
-import java.util.Arrays;
-
-import io.realm.RealmFieldType;
-
-public class JNIImplicitTransactionsTest extends AndroidTestCase {
-
-    String testFile;
-
-    @Override
-    protected void setUp() throws Exception {
-        testFile = new File(this.getContext().getFilesDir(), "implicit.realm").toString();
-    }
-
-    private void deleteFile() {
-        for (String fileToDelete : Arrays.asList(testFile, testFile + ".lock")) {
-            File f = new File(fileToDelete);
-            if (f.exists()) {
-                boolean result = f.delete();
-                if (!result) {
-                    fail();
-                }
-            }
-        }
-    }
-
-    public void testImplicitTransactions() {
-        deleteFile();
-        SharedGroup sg = new SharedGroup(testFile, true, SharedGroup.Durability.FULL, null); // TODO: try with encryption
-
-        // Create a table
-        WriteTransaction wt = sg.beginWrite();
-        if (!wt.hasTable("test")) {
-            Table table = wt.getTable("test");
-            table.addColumn(RealmFieldType.INTEGER, "integer");
-            table.addEmptyRow();
-        }
-        wt.commit();
-
-        // Add a row in a write transaction and continue with read transaction
-        ImplicitTransaction t = sg.beginImplicitTransaction();
-        Table test = t.getTable("test");
-        assertEquals(1, test.size());
-        t.promoteToWrite();
-        test.addEmptyRow();
-        t.commitAndContinueAsRead();
-
-        // Should throw as this is now a read transaction
-        try {
-            test.addEmptyRow();
-            fail();
-        } catch (IllegalStateException e) {
-            assertNotNull(e);
-        }
-    }
-
-    public void testCannotUseClosedImplicitTransaction() {
-        deleteFile();
-        SharedGroup sg = new SharedGroup(testFile, true, SharedGroup.Durability.FULL, null);
-        WriteTransaction wt = sg.beginWrite();
-        if (!wt.hasTable("test")) {
-            Table table = wt.getTable("test");
-            table.addColumn(RealmFieldType.INTEGER, "integer");
-            table.addEmptyRow();
-        }
-        wt.commit();
-        ImplicitTransaction t = sg.beginImplicitTransaction();
-
-        sg.close();
-        try {
-            t.advanceRead();
-        } catch (IllegalStateException e) {
-            return;
-        }
-
-        fail("It should not be possible to advanceRead on a transaction which SharedGroup is closed");
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
index ba674f6664..95499e8a4a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
@@ -16,19 +16,45 @@
 
 package io.realm.internal;
 
-import junit.framework.TestCase;
+import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNILinkTest extends TestCase {
+import static junit.framework.Assert.assertEquals;
 
-    public void testLinkColumns() {
+@RunWith(AndroidJUnit4.class)
+public class JNILinkTest {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SharedRealm sharedRealm;
 
-        Group group = new Group();
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+    }
 
-        Table table1 = group.getTable("table1");
+    @After
+    public void tearDown() {
+        sharedRealm.cancelTransaction();
+        sharedRealm.close();
+    }
 
-        Table table2 = group.getTable("table2");
+    @Test
+    public void testLinkColumns() {
+        Table table1 = sharedRealm.getTable("table1");
+
+        Table table2 = sharedRealm.getTable("table2");
         table2.addColumn(RealmFieldType.INTEGER, "int");
         table2.addColumn(RealmFieldType.STRING, "string");
 
@@ -39,7 +65,7 @@ public void testLinkColumns() {
         table1.addColumnLink(RealmFieldType.OBJECT, "Link", table2);
 
         table1.addEmptyRow();
-        table1.setLink(0, 0, 1);
+        table1.setLink(0, 0, 1, false);
 
         Table target = table1.getLinkTarget(0);
 
@@ -53,18 +79,16 @@ public void testLinkColumns() {
 
     }
 
+    @Test
     public void testLinkList() {
-
-        Group group = new Group();
-
-        Table table1 = group.getTable("table1");
+        Table table1 = sharedRealm.getTable("table1");
         table1.addColumn(RealmFieldType.INTEGER, "int");
         table1.addColumn(RealmFieldType.STRING, "string");
         table1.add(1, "c");
         table1.add(2, "b");
         table1.add(3, "a");
 
-        Table table2 = group.getTable("table2");
+        Table table2 = sharedRealm.getTable("table2");
 
         table2.addColumnLink(RealmFieldType.LIST, "LinkList", table1);
 
@@ -93,7 +117,5 @@ public void testLinkList() {
 
         assertEquals(links.getUncheckedRow(0).getString(1), "a");
         assertEquals(links.size(), 1);
-
     }
-
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
similarity index 51%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
index e05e3ab8ef..8847528a20 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
@@ -16,22 +16,26 @@
 
 package io.realm.internal;
 
-import junit.framework.TestCase;
+import android.support.test.runner.AndroidJUnit4;
 
-public class JNI_nativeTests extends TestCase {
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-    public void testNativeExceptions() {
-        String expect = "";
-        for (Util.Testcase test : Util.Testcase.values()) {
-            expect = test.expectedResult(0);
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class JNINativeTest {
+
+    @Test
+    public void nativeExceptions() {
+        long maxExceptionNumber = TestUtil.getMaxExceptionNumber();
+        for (long i = 0; i < maxExceptionNumber; i++) {
+            String expect = TestUtil.getExpectedMessage(i);
             try {
-                test.execute(0);
-            } catch (Exception e) {
-                assertEquals(expect, e.toString());
-            } catch (Error e) {
-                assertEquals(expect, e.toString());
+                TestUtil.testThrowExceptions(i);
+            } catch (Throwable throwable) {
+                assertEquals("Exception kind: " + i, expect, throwable.toString());
             }
-
         }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index e661665b39..71f504509d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -44,18 +44,6 @@ void init() {
         assertEquals(6, table.size());
     }
 
-    public void shouldQueryOnSortedView() {
-
-        init();
-
-        TableView sortedView = table.getSortedView(0, Sort.DESCENDING);
-
-        TableView result = sortedView.where().findAll();
-
-        assertEquals(result.size(), table.size());
-
-    }
-
     public void testShouldQuery() {
         init();
         TableQuery query = table.where();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 09973c790b..057b2f3009 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -16,30 +16,47 @@
 
 package io.realm.internal;
 
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Pair;
 
-import java.io.File;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
 import java.util.Date;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Locale;
 
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
-import io.realm.Sort;
 import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNITableTest extends AndroidTestCase {
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
 
-    Table t;
+@RunWith(AndroidJUnit4.class)
+public class JNITableTest {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    Table createTestTable() {
-        Table t = new Table();
-        return t;
-    }
+    private Table t;
 
-    @Override
+    @Before
     public void setUp() {
-        t = createTestTable();
+        t = new Table();
     }
 
-    public void testTableToString() {
+    @Test
+    public void tableToString() {
         Table t = new Table();
 
         t.addColumn(RealmFieldType.STRING, "stringCol");
@@ -53,7 +70,8 @@ public void testTableToString() {
         assertEquals(expected, t.toString());
     }
 
-    public void testRowOperationsOnZeroRow(){
+    @Test
+    public void rowOperationsOnZeroRow(){
 
         Table t = new Table();
         // Remove rows without columns
@@ -67,7 +85,8 @@ public void testRowOperationsOnZeroRow(){
 
     }
 
-    public void testZeroColOperations() {
+    @Test
+    public void zeroColOperations() {
         Table tableZeroCols = new Table();
 
         // Add rows
@@ -83,9 +102,10 @@ public void testZeroColOperations() {
         try { tableZeroCols.renameColumn(10, "newName");    fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
     }
 
-    public void testFindFirstNonExisting() {
+    @Test
+    public void findFirstNonExisting() {
         Table t = TestHelper.getTableWithAllColumnTypes();
-        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
+        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761L), 4.5d, 5.7f, 100, "string");
 
         assertEquals(-1, t.findFirstBoolean(1, false));
         // FIXME: reenable when core implements find_first_timestamp(): assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
@@ -94,7 +114,8 @@ public void testFindFirstNonExisting() {
         assertEquals(-1, t.findFirstLong(5, 50));
     }
 
-    public void testFindFirst() {
+    @Test
+    public void findFirst() {
         final int TEST_SIZE = 10;
         Table t = TestHelper.getTableWithAllColumnTypes();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -121,8 +142,8 @@ public void testFindFirst() {
         } catch (IllegalArgumentException ignored) {}
     }
 
-
-    public void testGetValuesFromNonExistingColumn() {
+    @Test
+    public void getValuesFromNonExistingColumn() {
         Table t = TestHelper.getTableWithAllColumnTypes();
         t.addEmptyRows(10);
 
@@ -155,7 +176,8 @@ public void testGetValuesFromNonExistingColumn() {
         try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
     }
 
-    public void testGetNonExistingColumn() {
+    @Test
+    public void getNonExistingColumn() {
         Table t = new Table();
         t.addColumn(RealmFieldType.INTEGER, "int");
 
@@ -163,143 +185,50 @@ public void testGetNonExistingColumn() {
         try { t.getColumnIndex(null); fail("column name null"); } catch (IllegalArgumentException ignored) { }
     }
 
-
-    public void testGetSortedView() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "");
-        t.addColumn(RealmFieldType.STRING, "");
-        t.addColumn(RealmFieldType.DOUBLE, "");
-
-        t.add(1, "s", 1000d);
-        t.add(3,"sss", 10d);
-        t.add(2, "ss", 100d);
-
-
-        // Check the order is as it is added
-        assertEquals(1, t.getLong(0, 0));
-        assertEquals(3, t.getLong(0, 1));
-        assertEquals(2, t.getLong(0, 2));
-        assertEquals("s", t.getString(1, 0));
-        assertEquals("sss", t.getString(1, 1));
-        assertEquals("ss", t.getString(1, 2));
-        assertEquals(1000d, t.getDouble(2, 0));
-        assertEquals(10d, t.getDouble(2, 1));
-        assertEquals(100d, t.getDouble(2, 2));
-
-        // Get the sorted view on first column
-        TableView v = t.getSortedView(0);
-
-        // Check the new order
-        assertEquals(1, v.getLong(0, 0));
-        assertEquals(2, v.getLong(0, 1));
-        assertEquals(3, v.getLong(0, 2));
-        assertEquals("s", v.getString(1, 0));
-        assertEquals("ss", v.getString(1, 1));
-        assertEquals("sss", v.getString(1, 2));
-        assertEquals(1000d, v.getDouble(2, 0));
-        assertEquals(100d, v.getDouble(2, 1));
-        assertEquals(10d, v.getDouble(2, 2));
-
-        // Get the sorted view on first column descending
-        v = t.getSortedView(0, Sort.DESCENDING);
-
-        // Check the new order
-        assertEquals(3, v.getLong(0, 0));
-        assertEquals(2, v.getLong(0, 1));
-        assertEquals(1, v.getLong(0, 2));
-        assertEquals("sss", v.getString(1, 0));
-        assertEquals("ss", v.getString(1, 1));
-        assertEquals("s", v.getString(1, 2));
-        assertEquals(10d, v.getDouble(2, 0));
-        assertEquals(100d, v.getDouble(2, 1));
-        assertEquals(1000d, v.getDouble(2, 2));
-
-        // Some out of bounds test cases
-        try { t.getSortedView(-1, Sort.DESCENDING);    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSortedView(-100, Sort.DESCENDING);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSortedView(100, Sort.DESCENDING);   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
-    }
-
-    public void testSetNulls() {
+    @Test
+    public void setNulls() {
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "");
         t.addColumn(RealmFieldType.DATE, "");
         t.addColumn(RealmFieldType.BINARY, "");
         t.add("String val", new Date(), new byte[]{1, 2, 3});
 
-        try { t.setString(0, 0, null);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
-        try { t.setDate(1, 0, null);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
+        try { t.setString(0, 0, null, false);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
+        try { t.setDate(1, 0, null, false);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
     }
 
-    public void testAddNegativeEmptyRows() {
+    @Test
+    public void addNegativeEmptyRows() {
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "colName");
 
         try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException ignored) { }
     }
 
-    public void testImmutableInsertNotAllowed() {
-
-        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
-        String TABLENAME = "tableName";
-
-        new File(FILENAME).delete();
-        new File(FILENAME+".lock").delete();
-        SharedGroup group = new SharedGroup(FILENAME);
+    @Test
+    public void getName() {
+        String TABLE_NAME = "tableName";
+        RealmConfiguration configuration = configFactory.createConfiguration();
+        Realm.deleteRealm(configuration);
 
-        // Write transaction must be run so we are sure a db exists with the correct table
-        WriteTransaction wt = group.beginWrite();
+        SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
+        //noinspection TryFinallyCanBeTryWithResources
         try {
-            Table table = wt.getTable(TABLENAME);
-            table.addColumn(RealmFieldType.STRING, "col0");
-            table.add("value0");
-            table.add("value1");
-            table.add("value2");
-
-            wt.commit();
-        } catch (Throwable t) {
-            wt.rollback();
-        }
-
-        ReadTransaction rt = group.beginRead();
-        try {
-            Table table = rt.getTable(TABLENAME);
 
-            try {
-                table.addEmptyRow();
-                fail("Exception expected when inserting in read transaction");
-            } catch (IllegalStateException ignored) {
-            }
+            // Write transaction must be run so we are sure a db exists with the correct table
+            sharedRealm.beginTransaction();
+            sharedRealm.getTable(TABLE_NAME);
+            sharedRealm.commitTransaction();
 
+            Table table = sharedRealm.getTable(TABLE_NAME);
+            assertEquals(TABLE_NAME, table.getName());
         } finally {
-            rt.endRead();
-        }
-    }
-
-    public void testGetName() {
-        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
-        String TABLENAME = "tableName";
-
-        new File(FILENAME).delete();
-        new File(FILENAME+".lock").delete();
-        SharedGroup group = new SharedGroup(FILENAME);
-
-        // Write transaction must be run so we are sure a db exists with the correct table
-        WriteTransaction wt = group.beginWrite();
-        try {
-            wt.getTable(TABLENAME);
-            wt.commit();
-        } catch (Throwable t) {
-            wt.rollback();
+            sharedRealm.close();
         }
-
-        ReadTransaction rt = group.beginRead();
-        Table table = rt.getTable(TABLENAME);
-        assertEquals(TABLENAME, table.getName());
     }
 
-    public void testShouldThrowWhenSetIndexOnWrongRealmFieldType() {
+    @Test
+    public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
         for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
 
             // All types supported addSearchIndex and removeSearchIndex
@@ -334,13 +263,15 @@ public void testShouldThrowWhenSetIndexOnWrongRealmFieldType() {
         }
     }
 
-    public void testColumnName() {
+    @Test
+    public void columnName() {
         Table t = new Table();
         try { t.addColumn(RealmFieldType.STRING, "I am 64 characters.............................................."); fail("Only 63 characters supported"); } catch (IllegalArgumentException ignored) { }
         t.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
     }
 
-    public void testTableNumbers() {
+    @Test
+    public void tableNumbers() {
         Table t = new Table();
         t.addColumn(RealmFieldType.INTEGER, "intCol");
         t.addColumn(RealmFieldType.DOUBLE, "doubleCol");
@@ -370,8 +301,8 @@ public void testTableNumbers() {
         assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2
 
         // Set double and float
-        t.setDouble(1, 2, -2.0d);
-        t.setFloat(2, 2, -3.0f);
+        t.setDouble(1, 2, -2.0d, false);
+        t.setFloat(2, 2, -3.0f, false);
 
         // Get double tests
         assertEquals(-2.0d, t.getDouble(1, 2));
@@ -386,7 +317,8 @@ public void testTableNumbers() {
         assertEquals(3000.0f, t.getFloat(2, 5));
     }
 
-    public void testMaximumDate() {
+    @Test
+    public void maximumDate() {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -399,7 +331,8 @@ public void testMaximumDate() {
 
     }
 
-    public void testMinimumDate() {
+    @Test
+    public void minimumDate() {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -413,7 +346,8 @@ public void testMinimumDate() {
     }
 
     // testing the migration of a string column to be nullable.
-    public void testConvertToNullable() {
+    @Test
+    public void convertToNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
         for (RealmFieldType columnType : columnTypes) {
@@ -426,26 +360,26 @@ public void testConvertToNullable() {
                     table.addColumn(RealmFieldType.BOOLEAN, "bool");
                     table.addEmptyRow();
                     if (columnType == RealmFieldType.BOOLEAN) {
-                        table.setBoolean(colIndex, 0, true);
+                        table.setBoolean(colIndex, 0, true, false);
                     } else if (columnType == RealmFieldType.DATE) {
-                        table.setDate(colIndex, 0, new Date(0));
+                        table.setDate(colIndex, 0, new Date(0), false);
                     } else if (columnType == RealmFieldType.DOUBLE) {
-                        table.setDouble(colIndex, 0, 1.0);
+                        table.setDouble(colIndex, 0, 1.0, false);
                     } else if (columnType == RealmFieldType.FLOAT) {
-                        table.setFloat(colIndex, 0, 1.0f);
+                        table.setFloat(colIndex, 0, 1.0f, false);
                     } else if (columnType == RealmFieldType.INTEGER) {
-                        table.setLong(colIndex, 0, 1);
+                        table.setLong(colIndex, 0, 1, false);
                     } else if (columnType == RealmFieldType.BINARY) {
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0});
+                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
                     } else if (columnType == RealmFieldType.STRING) {
-                        table.setString(colIndex, 0, "Foo");
+                        table.setString(colIndex, 0, "Foo", false);
                     }
                     try {
                         table.addEmptyRow();
                         if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 1, null);
+                            table.setBinaryByteArray(colIndex, 1, null, false);
                         } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 1, null);
+                            table.setString(colIndex, 1, null, false);
                         } else {
                             table.getCheckedRow(1).setNull(colIndex);
                         }
@@ -467,9 +401,9 @@ public void testConvertToNullable() {
 
                     table.addEmptyRow();
                     if (columnType == RealmFieldType.BINARY) {
-                        table.setBinaryByteArray(colIndex, 0, null);
+                        table.setBinaryByteArray(colIndex, 0, null, false);
                     } else if (columnType == RealmFieldType.STRING) {
-                        table.setString(colIndex, 0, null);
+                        table.setString(colIndex, 0, null, false);
                     } else {
                         table.getCheckedRow(0).setNull(colIndex);
                     }
@@ -488,7 +422,8 @@ public void testConvertToNullable() {
         }
     }
 
-    public void testConvertToNotNullable() {
+    @Test
+    public void convertToNotNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
         for (RealmFieldType columnType : columnTypes) {
@@ -501,25 +436,25 @@ public void testConvertToNotNullable() {
                     table.addColumn(RealmFieldType.BOOLEAN, "bool");
                     table.addEmptyRow();
                     if (columnType == RealmFieldType.BOOLEAN)
-                        table.setBoolean(colIndex, 0, true);
+                        table.setBoolean(colIndex, 0, true, false);
                     else if (columnType == RealmFieldType.DATE)
-                        table.setDate(colIndex, 0, new Date(1));
+                        table.setDate(colIndex, 0, new Date(1), false);
                     else if (columnType == RealmFieldType.DOUBLE)
-                        table.setDouble(colIndex, 0, 1.0);
+                        table.setDouble(colIndex, 0, 1.0, false);
                     else if (columnType == RealmFieldType.FLOAT)
-                        table.setFloat(colIndex, 0, 1.0f);
+                        table.setFloat(colIndex, 0, 1.0f, false);
                     else if (columnType == RealmFieldType.INTEGER)
-                        table.setLong(colIndex, 0, 1);
+                        table.setLong(colIndex, 0, 1, false);
                     else if (columnType == RealmFieldType.BINARY)
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0});
+                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
                     else if (columnType == RealmFieldType.STRING)
-                        table.setString(colIndex, 0, "Foo");
+                        table.setString(colIndex, 0, "Foo", false);
                     try {
                         table.addEmptyRow();
                         if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 1, null);
+                            table.setBinaryByteArray(colIndex, 1, null, false);
                         } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 1, null);
+                            table.setString(colIndex, 1, null, false);
                         } else {
                             table.getCheckedRow(1).setNull(colIndex);
                         }
@@ -541,9 +476,9 @@ else if (columnType == RealmFieldType.STRING)
                     table.addEmptyRow();
                     try {
                         if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 0, null);
+                            table.setBinaryByteArray(colIndex, 0, null, false);
                         } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 0, null);
+                            table.setString(colIndex, 0, null, false);
                         } else {
                             table.getCheckedRow(0).setNull(colIndex);
                         }
@@ -579,7 +514,8 @@ else if (columnType == RealmFieldType.INTEGER)
     }
 
     // add column and read back if it is nullable or not
-    public void testIsNullable() {
+    @Test
+    public void isNullable() {
         Table table = new Table();
         table.addColumn(RealmFieldType.STRING, "string1", Table.NOT_NULLABLE);
         table.addColumn(RealmFieldType.STRING, "string2", Table.NULLABLE);
@@ -587,4 +523,423 @@ public void testIsNullable() {
         assertFalse(table.isColumnNullable(0));
         assertTrue(table.isColumnNullable(1));
     }
+
+    @Test
+    public void defaultValue_setAndGet() {
+        // t is not used in this test
+        t = null;
+        final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            sharedRealm.beginTransaction();
+            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            sharedRealm.commitTransaction();
+
+            List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
+                    new Pair<RealmFieldType, Object>(RealmFieldType.STRING, "string value"),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, 100L),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, true),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[]{123}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date(123456)),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234f),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, Math.PI),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, 0L)
+                    // currently, LIST does not support default value
+                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+            );
+
+            for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
+                final RealmFieldType type = columnInfo.first;
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table.addColumnLink(type, type.name().toLowerCase(Locale.ENGLISH) + "Col", table);
+                } else {
+                    table.addColumn(type, type.name().toLowerCase(Locale.ENGLISH) + "Col");
+                }
+            }
+
+            sharedRealm.beginTransaction();
+            table.addEmptyRow();
+
+            ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value = columnInfo.second;
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value, true);
+                        assertEquals(value, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value, true);
+                        assertEquals(value, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value, true);
+                        assertEquals(value, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value, true);
+                        assertTrue(Arrays.equals((byte[]) value, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value, true);
+                        assertEquals(value, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value, true);
+                        assertEquals(value, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value, true);
+                        assertEquals(value, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value, true);
+                        assertEquals(value, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // check if the value can be read after committing transaction
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value = columnInfo.second;
+
+                switch (type) {
+                    case STRING:
+                        assertEquals(value, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        assertEquals(value, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        assertEquals(value, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        assertTrue(Arrays.equals((byte[]) value, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        assertEquals(value, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        assertEquals(value, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        assertEquals(value, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        assertEquals(value, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+
+        } finally {
+            sharedRealm.close();
+        }
+    }
+
+    @Test
+    public void defaultValue_setMultipleTimes() {
+        // t is not used in this test
+        t = null;
+        final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            sharedRealm.beginTransaction();
+            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            sharedRealm.commitTransaction();
+
+            List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
+                    new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
+                    // currently, LIST does not support default value
+                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+            );
+
+            for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
+                final RealmFieldType type = columnInfo.first;
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table.addColumnLink(type, type.name().toLowerCase(Locale.ENGLISH) + "Col", table);
+                } else {
+                    table.addColumn(type, type.name().toLowerCase(Locale.ENGLISH) + "Col");
+                }
+            }
+
+            sharedRealm.beginTransaction();
+            table.addEmptyRow();
+            table.addEmptyRow(); // for link field update
+
+            ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value1 = ((Object[]) columnInfo.second)[0];
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value1, true);
+                        table.setString(columnIndex, 0, (String) value2, true);
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value1, true);
+                        table.setLong(columnIndex, 0, (long) value2, true);
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value1, true);
+                        table.setBoolean(columnIndex, 0, (boolean) value2, true);
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value1, true);
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value2, true);
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value1, true);
+                        table.setDate(columnIndex, 0, (Date) value2, true);
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value1, true);
+                        table.setFloat(columnIndex, 0, (float) value2, true);
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value1, true);
+                        table.setDouble(columnIndex, 0, (double) value2, true);
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value1, true);
+                        table.setLink(columnIndex, 0, (long) value2, true);
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // check if the value can be read after committing transaction
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+        } finally {
+            sharedRealm.close();
+        }
+    }
+
+    @Test
+    public void defaultValue_overwrittenByNonDefault() {
+        // t is not used in this test
+        t = null;
+        final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            sharedRealm.beginTransaction();
+            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            sharedRealm.commitTransaction();
+
+            List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
+                    new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
+                    // currently, LIST does not support default value
+                    //new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+            );
+
+            for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
+                final RealmFieldType type = columnInfo.first;
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table.addColumnLink(type, type.name().toLowerCase(Locale.ENGLISH) + "Col", table);
+                } else {
+                    table.addColumn(type, type.name().toLowerCase(Locale.ENGLISH) + "Col");
+                }
+            }
+
+            sharedRealm.beginTransaction();
+            table.addEmptyRow();
+            table.addEmptyRow(); // for link field update
+
+            // set as default
+            ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value1 = ((Object[]) columnInfo.second)[0];
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value1, true);
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value1, true);
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value1, true);
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value1, true);
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value1, true);
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value1, true);
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value1, true);
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value1, true);
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // update as non default
+            sharedRealm.beginTransaction();
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        table.setString(columnIndex, 0, (String) value2, false);
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        table.setLong(columnIndex, 0, (long) value2, false);
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        table.setBoolean(columnIndex, 0, (boolean) value2, false);
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        table.setBinaryByteArray(columnIndex, 0, (byte[]) value2, false);
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        table.setDate(columnIndex, 0, (Date) value2, false);
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        table.setFloat(columnIndex, 0, (float) value2, false);
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        table.setDouble(columnIndex, 0, (double) value2, false);
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        table.setLink(columnIndex, 0, (long) value2, false);
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+            sharedRealm.commitTransaction();
+
+            // check if the value was overwritten
+            it = columnInfoList.listIterator();
+            for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
+                Pair<RealmFieldType, Object> columnInfo = it.next();
+                final RealmFieldType type = columnInfo.first;
+                final Object value2 = ((Object[]) columnInfo.second)[1];
+
+                switch (type) {
+                    case STRING:
+                        assertEquals(value2, table.getString(columnIndex, 0));
+                        break;
+                    case INTEGER:
+                        assertEquals(value2, table.getLong(columnIndex, 0));
+                        break;
+                    case BOOLEAN:
+                        assertEquals(value2, table.getBoolean(columnIndex, 0));
+                        break;
+                    case BINARY:
+                        assertTrue(Arrays.equals((byte[]) value2, table.getBinaryByteArray(columnIndex, 0)));
+                        break;
+                    case DATE:
+                        assertEquals(value2, table.getDate(columnIndex, 0));
+                        break;
+                    case FLOAT:
+                        assertEquals(value2, table.getFloat(columnIndex, 0));
+                        break;
+                    case DOUBLE:
+                        assertEquals(value2, table.getDouble(columnIndex, 0));
+                        break;
+                    case OBJECT:
+                        assertEquals(value2, table.getLink(columnIndex, 0));
+                        break;
+                    default:
+                        throw new RuntimeException("unexpected field type: " + type);
+                }
+            }
+        } finally {
+            sharedRealm.close();
+        }
+    }
 }
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
new file mode 100644
index 0000000000..47ed416aaa
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import io.realm.Realm;
+import io.realm.RealmFieldType;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class JNITableViewTest {
+    static {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getTargetContext());
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private static final String TABLE_NAME = Table.TABLE_PREFIX + "JNITableViewTest";
+    private static final int ROW_COUNT = 10;
+
+    private static final List<RealmFieldType> FIELDS = Arrays.asList(
+            RealmFieldType.INTEGER,
+            RealmFieldType.BOOLEAN,
+            RealmFieldType.STRING,
+            RealmFieldType.BINARY,
+            RealmFieldType.DATE,
+            RealmFieldType.FLOAT,
+            RealmFieldType.DOUBLE);
+    private static final long INTEGER_COLUMN_INDEX = 0;
+    private static final long STRING_COLUMN_INDEX = 2;
+
+    private SharedRealm sharedRealm;
+
+    private Table table;
+
+    @Before
+    public void setUp() {
+        sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
+        sharedRealm.beginTransaction();
+        try {
+            table = sharedRealm.getTable(TABLE_NAME);
+
+            for (RealmFieldType field : FIELDS) {
+                final long index = table.addColumn(field, field.name().toLowerCase(Locale.ENGLISH) + "Column");
+                table.convertColumnToNullable(index);
+            }
+
+            for (int i = 0; i < ROW_COUNT; i++) {
+                table.add(i, true, "abcd", new byte[]{123, -123}, new Date(12345), 1.234f, 3.446d);
+            }
+        } finally {
+            sharedRealm.commitTransaction();
+        }
+    }
+
+    @Test
+    public void setNull() {
+        TableQuery query = table.where();
+        for (int i = 0; i < ROW_COUNT; i++) {
+            if (isOdd(i)) {
+                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
+            }
+        }
+        final TableView oddRows = query.findAll();
+
+        sharedRealm.beginTransaction();
+        for (int i = 0; i < oddRows.size(); i++) {
+            oddRows.setNull(STRING_COLUMN_INDEX, i, false);
+        }
+        sharedRealm.commitTransaction();
+
+        // check if TableView#setNull() worked as expected
+        for (int i = 0; i < table.size(); i++) {
+            assertEquals("index: " + i, isOdd(i), table.isNull(STRING_COLUMN_INDEX, i));
+        }
+    }
+
+    @Test
+    public void isNull() {
+
+        sharedRealm.beginTransaction();
+        for (int i = 0; i < table.size(); i++) {
+            if (isOdd(i)) {
+                table.setNull(STRING_COLUMN_INDEX, i, false);
+            }
+        }
+        sharedRealm.commitTransaction();
+
+        TableQuery query = table.where();
+        for (int i = 0; i < ROW_COUNT; i++) {
+            if (isOdd(i)) {
+                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
+            }
+        }
+        final TableView oddRows = query.findAll();
+        for (int i = 0; i < oddRows.size(); i++) {
+            assertEquals("index: " + i, true, oddRows.isNull(STRING_COLUMN_INDEX, i));
+        }
+
+        query = table.where();
+        for (int i = 0; i < ROW_COUNT; i++) {
+            if (isEven(i)) {
+                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
+            }
+        }
+        final TableView evenRows = query.findAll();
+        for (int i = 0; i < evenRows.size(); i++) {
+            assertEquals("index: " + i, false, evenRows.isNull(STRING_COLUMN_INDEX, i));
+        }
+    }
+
+    private static boolean isEven(int i) {
+        return i % 2 == 0;
+    }
+    private static boolean isOdd(int i) {
+        return i % 2 == 1;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
deleted file mode 100644
index f5f2908f07..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ /dev/null
@@ -1,462 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-import io.realm.Realm;
-import io.realm.RealmFieldType;
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmPrimaryKeyConstraintException;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@RunWith(AndroidJUnit4.class)
-public class JNITransactions {
-
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-
-    private String testFile;
-    private android.content.Context context;
-
-    @Before
-    public void setUp() throws Exception {
-        testFile = new File(
-                configFactory.getRoot(),
-                System.currentTimeMillis() + "_transact.realm").getAbsolutePath();
-        context = InstrumentationRegistry.getInstrumentation().getContext();
-        RealmCore.loadLibrary(context);
-    }
-
-    private Table getTableWithStringPrimaryKey() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        WriteTransaction trans = db.beginWrite();
-        Table t = trans.getTable("TestTable");
-        t.addColumn(RealmFieldType.STRING, "colName", true);
-        t.setPrimaryKey("colName");
-        return t;
-    }
-
-    private Table getTableWithIntegerPrimaryKey() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        WriteTransaction trans = db.beginWrite();
-        Table t = trans.getTable("TestTable");
-        t.addColumn(RealmFieldType.INTEGER, "colName");
-        t.setPrimaryKey("colName");
-        return t;
-    }
-
-    protected void writeOneTransaction(SharedGroup db, long rows) {
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.addColumn(RealmFieldType.INTEGER, "number");
-
-
-        for (long row=0; row < rows; row++)
-            tbl.add("Hi", 1);
-        assertEquals(rows, tbl.size());
-        trans.commit();
-
-        // must throw exception as table is invalid now.
-        try {
-            assertEquals(1, tbl.size());
-            fail();
-        } catch (IllegalStateException e) {
-            assertNotNull(e);
-        }
-
-    }
-
-    protected void checkRead(SharedGroup db, int rows) {
-        // Read transaction
-        ReadTransaction trans = db.beginRead();
-        Table tbl = trans.getTable("EmployeeTable");
-        assertEquals(true, tbl.isValid());
-        assertEquals(rows, tbl.size());
-        trans.endRead();
-    }
-
-    // TODO: tests should be done both for all Durability options
-
-    @Test
-    public void mustWriteAndReadEmpty() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 0);
-        checkRead(db, 0);
-    }
-
-    @Test
-    public void mustWriteCommit() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 10);
-        checkRead(db, 10);
-    }
-
-    @Test
-    public void shouldThrowExceptionAfterClosedReadTransaction() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 10);
-        ReadTransaction rt = db.beginRead();
-
-        try {
-            Table tbl = rt.getTable("EmployeeTable");
-            rt.endRead();
-            try {
-                tbl.getColumnCount(); //Should throw exception, the table is invalid when transaction has been closed
-                fail();
-            } catch (IllegalStateException ignored) {
-            }
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    @Test
-    public void shouldThrowExceptionAfterClosedReadTransactionWhenWriting() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 10);
-        ReadTransaction rt = db.beginRead();
-
-        try {
-            Table tbl = rt.getTable("EmployeeTable");
-            rt.endRead();
-            try {
-                tbl.addColumn(RealmFieldType.STRING, "newString"); //Should throw exception, as adding a column is not allowed in read transaction
-                fail();
-            } catch (IllegalStateException e) {
-                //assertNotNull(e);
-            }
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    @Test
-    public void shouldThrowExceptionWhenWritingInReadTrans() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        ReadTransaction rt = db.beginRead();
-
-        try {
-            try {
-                rt.getTable("newTable");  //Should throw exception, as this method creates a new table, if the table does not exists, thereby making it a mutable operation
-                fail();
-            } catch (IllegalStateException e) {
-                assertNotNull(e);
-            }
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    @Test
-    public void onlyOneCommit() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        WriteTransaction trans = db.beginWrite();
-
-        try {
-            Table tbl = trans.getTable("EmployeeTable");
-            tbl.addColumn(RealmFieldType.STRING, "name");
-            trans.commit();
-            try {
-                trans.commit(); // should throw
-                fail();
-            } catch (IllegalStateException e){
-                assertNotNull(e);
-            }
-
-        } catch (Throwable t){
-            trans.rollback();
-        }
-    }
-
-    @Test
-    public void mustRollback() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 1);
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-
-        tbl.add("Hello", 1);
-        assertEquals(2, tbl.size());
-        trans.rollback();
-
-        checkRead(db, 1); // Only 1 row now.
-    }
-
-    @Test
-    public void mustAllowDoubleCommitAndRollback() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        {
-            WriteTransaction trans = db.beginWrite();
-            Table tbl = trans.getTable("EmployeeTable");
-            tbl.addColumn(RealmFieldType.STRING, "name");
-            tbl.addColumn(RealmFieldType.INTEGER, "number");
-
-            // allow commit before any changes
-            assertEquals(0, tbl.size());
-            tbl.add("Hello", 1);
-            trans.commit();
-        }
-        {
-            WriteTransaction trans = db.beginWrite();
-            Table tbl = trans.getTable("EmployeeTable");
-            // allow double rollback
-            tbl.add("Hello", 2);
-            assertEquals(2, tbl.size());
-            trans.rollback();
-            trans.rollback();
-            trans.rollback();
-            trans.rollback();
-        }
-        {
-            ReadTransaction trans = db.beginRead();
-            Table tbl = trans.getTable("EmployeeTable");
-            assertEquals(1, tbl.size());
-            trans.endRead();
-        }
-    }
-
-    // TODO:
-    // Test: exception at all mutable methods in TableBase, TableView,
-    // Test: above in custom Typed Tables
-    // TableQuery.... in ReadTransactions
-
-    @Test
-    public void mustFailOnWriteInReadTransactions() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-
-        writeOneTransaction(db, 1);
-
-        ReadTransaction t = db.beginRead();
-        Table table = t.getTable("EmployeeTable");
-
-        try { table.addEmptyRow();                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.addEmptyRows(1);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.clear();                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.optimize();                     fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.remove(0);                      fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.removeLast();                   fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setBinaryByteArray(0,0,null);   fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setBoolean(0,0,false);          fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setDate(0,0,new Date(0));       fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.addSearchIndex(0);              fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setLong(0,0,0);                 fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setString(0,0,"");              fail();} catch (IllegalStateException e) {assertNotNull(e);}
-
-        TableQuery q = table.where();
-        try { q.remove();                           fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { q.remove(0,0);                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
-
-        TableView v = q.findAll();
-        try { v.clear();                            fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.remove(0);                          fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.removeLast();                       fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setBinaryByteArray(0, 0, null);     fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setBoolean(0, 0, false);            fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setDate(0, 0, new Date());          fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setLong(0, 0, 0);                   fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setString(0,0,"");                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
-
-        t.endRead();
-    }
-
-    // Test that primary key constraints are actually removed
-    @Test
-    public void removingPrimaryKeyRemovesConstraint() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.addColumn(RealmFieldType.INTEGER, "number");
-        tbl.setPrimaryKey("name");
-
-        tbl.add("Foo", 42);
-        try {
-            tbl.add("Foo", 41);
-        } catch (RealmPrimaryKeyConstraintException e1) {
-            // Primary key check worked, now remove it and try again.
-            tbl.setPrimaryKey("");
-            try {
-                tbl.add("Foo", 41);
-                return;
-            } catch (RealmException e2) {
-                fail("Primary key not removed");
-            }
-        }
-
-        fail("Primary key not enforced.");
-    }
-
-    // Test that primary key constraints are actually removed
-    @Test
-    public void removingPrimaryKeyRemovesConstraint_typeSetters() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.setPrimaryKey("name");
-
-        // Create first entry with name "foo"
-        tbl.setString(0, tbl.addEmptyRow(), "Foo");
-
-        long rowIndex = tbl.addEmptyRow();
-        try {
-            tbl.setString(0, rowIndex, "Foo"); // Try to create 2nd entry with name Foo
-        } catch (RealmPrimaryKeyConstraintException e1) {
-            tbl.setPrimaryKey(""); // Primary key check worked, now remove it and try again.
-            try {
-                tbl.setString(0, rowIndex, "Foo");
-                return;
-            } catch (RealmException e2) {
-                fail("Primary key not removed");
-            }
-        }
-
-        fail("Primary key not enforced.");
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
-        Table t = getTableWithStringPrimaryKey();
-        try {
-            t.addEmptyRowWithPrimaryKey(42);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyNullString() {
-        Table t = getTableWithStringPrimaryKey();
-        t.addEmptyRowWithPrimaryKey(null);
-        assertEquals(1, t.size());
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
-        Table t = getTableWithIntegerPrimaryKey();
-        try {
-            t.addEmptyRowWithPrimaryKey("Foo");
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyString() {
-        Table t = getTableWithStringPrimaryKey();
-        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
-        assertEquals(1, t.size());
-        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyLong() {
-        Table t = getTableWithIntegerPrimaryKey();
-        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
-        assertEquals(1, t.size());
-        assertEquals(42, t.getUncheckedRow(rowIndex).getLong(0));
-    }
-
-    @Test
-    public void firstPrimaryKeyTableMigration() throws IOException {
-        configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
-                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
-        ImplicitTransaction tr = db.beginImplicitTransaction();
-        Table t = tr.getTable("class_AnnotationTypes");
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
-        assertTrue(t.hasPrimaryKey());
-        assertEquals(RealmFieldType.STRING, tr.getTable("pk").getColumnType(0));
-        db.close();
-    }
-
-    @Test
-    public void secondPrimaryKeyTableMigration() throws IOException {
-        configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
-                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
-        ImplicitTransaction tr = db.beginImplicitTransaction();
-        Table t = tr.getTable("class_AnnotationTypes");
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
-        assertTrue(t.hasPrimaryKey());
-        assertEquals("AnnotationTypes", tr.getTable("pk").getString(0, 0));
-        db.close();
-    }
-
-    // See https://github.com/realm/realm-java/issues/1775 .
-    // Before 0.84.2, pk table added prefix "class_" to every class's name.
-    // After 0.84.2, the pk table should be migrated automatically to remove the "class_".
-    // In 0.84.2, the class names in pk table has been renamed to some incorrect names like "Thclass", "Mclass",
-    // "NClass", "Meclass" and etc..
-    // The 0841_pk_migration.realm is made to produce the issue.
-    @Test
-    public void primaryKeyTableMigratedWithRightName() throws IOException {
-        List<String> tableNames = Arrays.asList(
-                "ChatList", "Drafts", "Member", "Message", "Notifs", "NotifyLink", "PopularPost",
-                "Post", "Tags", "Threads", "User");
-
-        configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
-                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
-
-        ImplicitTransaction tr = db.beginImplicitTransaction();
-        // To trigger migratePrimaryKeyTableIfNeeded.
-        tr.getTable("class_ChatList").getPrimaryKey();
-
-        Table table =  tr.getTable("pk");
-        for (int i = 0; i < table.size(); i++) {
-            UncheckedRow row = table.getUncheckedRow(i);
-            // io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
-            assertTrue(tableNames.contains(row.getString(0)));
-        }
-        db.close();
-    }
-
-    // Test if toString() returns a correct PrimaryKey field description from a Table
-    public void testTableToStringWithPrimaryKey() {
-        Table t = getTableWithStringPrimaryKey();
-        t.addColumn(RealmFieldType.INTEGER, "intCol");
-        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
-
-        t.add("s1", 1, true);
-        t.add("s2", 2, false);
-
-        String expected = "The Table has 'colName' field as a PrimaryKey, and contains 3 columns: colName, intCol, boolCol. And 2 rows.";
-        assertEquals(expected, t.toString());
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 9a3d5669e7..661e6c1a6d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -131,7 +131,7 @@ public void testSetBinary() {
 
         byte[] arr2 = new byte[] {1,2,3, 4, 5};
 
-        view.setBinaryByteArray(0, 0, arr2);
+        view.setBinaryByteArray(0, 0, arr2, false);
 
         MoreAsserts.assertEquals(arr2, view.getBinaryByteArray(0, 0));
     }
@@ -372,7 +372,7 @@ public void testViewShouldInvalidate() {
         assertEquals(1, view.size());
 
         // access view after change in value is ok
-        t.setLong(0, 0, 3);
+        t.setLong(0, 0, 3, false);
         accessingViewOk(view);
 
         // access view after additions to table must fail
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
index 6b5aa39009..1ee36c4c23 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
@@ -59,27 +59,4 @@ public void testPivotTable(){
         try { t.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
         try { t.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
     }
-
-
-    public void testPivotTableView(){
-
-        TableView view = t.getSortedView(colIndexAge);
-
-        Table resultCount = view.pivot(colIndexSex, colIndexAge, PivotType.COUNT);
-        assertEquals(2, resultCount.size());
-        assertEquals(25000, resultCount.getLong(1, 0));
-        assertEquals(25000, resultCount.getLong(1, 1));
-
-        Table resultMin = view.pivot(colIndexSex, colIndexAge, PivotType.MIN);
-        assertEquals(20, resultMin.getLong(1, 0));
-        assertEquals(21, resultMin.getLong(1, 1));
-
-        Table resultMax = view.pivot(colIndexSex, colIndexAge, PivotType.MAX);
-        assertEquals(38, resultMax.getLong(1, 0));
-        assertEquals(39, resultMax.getLong(1, 1));
-
-
-        try { view.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
-        try { view.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
-    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
new file mode 100644
index 0000000000..3ba437ac44
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmError;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertFalse;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class PrimaryKeyTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private android.content.Context context;
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+
+    @Before
+    public void setUp() throws Exception {
+        config = configFactory.createConfiguration();
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            sharedRealm.close();
+        }
+    }
+
+    private Table getTableWithStringPrimaryKey() {
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        Table t = sharedRealm.getTable("TestTable");
+        long column = t.addColumn(RealmFieldType.STRING, "colName", true);
+        t.addSearchIndex(column);
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
+    private Table getTableWithIntegerPrimaryKey() {
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        Table t = sharedRealm.getTable("TestTable");
+        long column = t.addColumn(RealmFieldType.INTEGER, "colName");
+        t.addSearchIndex(column);
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
+    // Test that primary key constraints are actually removed
+    @Test
+    public void removingPrimaryKeyRemovesConstraint_typeSetters() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("removeConstraints").build();
+        SharedRealm sharedRealm = SharedRealm.getInstance(config);
+
+        sharedRealm.beginTransaction();
+        Table tbl = sharedRealm.getTable("EmployeeTable");
+        tbl.addColumn(RealmFieldType.STRING, "name");
+        tbl.setPrimaryKey("name");
+
+        // Create first entry with name "Foo"
+        tbl.setString(0, tbl.addEmptyRow(), "Foo", false);
+
+        long rowIndex = tbl.addEmptyRow();
+        try {
+            tbl.setString(0, rowIndex, "Foo", false); // Try to create 2nd entry with name Foo
+        } catch (RealmPrimaryKeyConstraintException e1) {
+            tbl.setPrimaryKey(""); // Primary key check worked, now remove it and try again.
+            try {
+                tbl.setString(0, rowIndex, "Foo", false);
+                return;
+            } catch (RealmException e2) {
+                fail("Primary key not removed");
+            }
+        }
+
+        fail("Primary key not enforced.");
+        sharedRealm.close();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
+        Table t = getTableWithStringPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey(42);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyNullString() {
+        Table t = getTableWithStringPrimaryKey();
+        t.addEmptyRowWithPrimaryKey(null);
+        assertEquals(1, t.size());
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
+        Table t = getTableWithIntegerPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey("Foo");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyString() {
+        Table t = getTableWithStringPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
+        assertEquals(1, t.size());
+        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void addEmptyRowWithPrimaryKeyLong() {
+        Table t = getTableWithIntegerPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
+        assertEquals(1, t.size());
+        assertEquals(42L, t.getUncheckedRow(rowIndex).getLong(0));
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
+        configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
+        sharedRealm.commitTransaction();
+        Table t = sharedRealm.getTable("class_AnnotationTypes");
+        assertTrue(t.hasPrimaryKey());
+        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals(RealmFieldType.STRING, sharedRealm.getTable("pk").getColumnType(0));
+    }
+
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_second() throws IOException {
+        configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
+        sharedRealm.commitTransaction();
+        Table t = sharedRealm.getTable("class_AnnotationTypes");
+        assertTrue(t.hasPrimaryKey());
+        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals("AnnotationTypes", sharedRealm.getTable("pk").getString(0, 0));
+    }
+
+    // See https://github.com/realm/realm-java/issues/1775 .
+    // Before 0.84.2, pk table added prefix "class_" to every class's name.
+    // After 0.84.2, the pk table should be migrated automatically to remove the "class_".
+    // In 0.84.2, the class names in pk table has been renamed to some incorrect names like "Thclass", "Mclass",
+    // "NClass", "Meclass" and etc..
+    // The 0841_pk_migration.realm is made to produce the issue.
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName() throws IOException {
+        List<String> tableNames = Arrays.asList(
+                "ChatList", "Drafts", "Member", "Message", "Notifs", "NotifyLink", "PopularPost",
+                "Post", "Tags", "Threads", "User");
+
+        configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
+        sharedRealm.commitTransaction();
+
+        Table table = sharedRealm.getTable("pk");
+        for (int i = 0; i < table.size(); i++) {
+            UncheckedRow row = table.getUncheckedRow(i);
+            // io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
+            assertTrue(tableNames.contains(row.getString(0)));
+        }
+    }
+
+    // PK table's column 'pk_table' needs search index in order to use set_string_unique.
+    // See https://github.com/realm/realm-java/pull/3488
+    @Test
+    public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        Table table = sharedRealm.getTable("TestTable");
+        long column = table.addColumn(RealmFieldType.INTEGER, "PKColumn");
+        table.addSearchIndex(column);
+        table.setPrimaryKey(column);
+        sharedRealm.commitTransaction();
+
+        assertEquals(table.getPrimaryKey(), table.getColumnIndex("PKColumn"));
+        // Now we have a pk table with search index.
+
+        sharedRealm.beginTransaction();
+        Table pkTable = sharedRealm.getTable("pk");
+        long classColumn = pkTable.getColumnIndex("pk_table");
+        pkTable.removeSearchIndex(classColumn);
+
+        // Try to add a pk for another table
+        Table table2 = sharedRealm.getTable("TestTable2");
+        long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
+        table2.addSearchIndex(column2);
+        try {
+            table2.setPrimaryKey(column2);
+        } catch (RealmError ignored) {
+            // Column has no search index
+        }
+
+        assertFalse(pkTable.hasSearchIndex(classColumn));
+
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
+        assertTrue(pkTable.hasSearchIndex(classColumn));
+        // Now it works.
+        table2.addSearchIndex(column2);
+        sharedRealm.cancelTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
new file mode 100644
index 0000000000..9dab44e638
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import io.realm.RealmConfiguration;
+import io.realm.exceptions.RealmError;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class SharedRealmTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+
+    @Before
+    public void setUp() {
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.close();
+    }
+
+    @Test
+    public void getVersionID() {
+        SharedRealm.VersionID versionID1 = sharedRealm.getVersionID();
+        sharedRealm.beginTransaction();
+        sharedRealm.commitTransaction();
+        SharedRealm.VersionID versionID2 = sharedRealm.getVersionID();
+        assertFalse(versionID1.equals(versionID2));
+    }
+
+    @Test
+    public void hasTable() {
+        assertFalse(sharedRealm.hasTable("MyTable"));
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("MyTable");
+        sharedRealm.commitTransaction();
+        assertTrue(sharedRealm.hasTable("MyTable"));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void getTable_createNotInTransactionThrows() {
+        sharedRealm.getTable("NON-EXISTING");
+    }
+
+    @Test
+    public void getTable() {
+        assertFalse(sharedRealm.hasTable("MyTable"));
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("MyTable");
+        sharedRealm.commitTransaction();
+        assertTrue(sharedRealm.hasTable("MyTable"));
+
+        // Table is existing, no need transaction to create it
+        sharedRealm.getTable("MyTable");
+    }
+
+    @Test
+    public void isInTransaction() {
+        assertFalse(sharedRealm.isInTransaction());
+        sharedRealm.beginTransaction();
+        assertTrue(sharedRealm.isInTransaction());
+        sharedRealm.cancelTransaction();
+        assertFalse(sharedRealm.isInTransaction());
+    }
+
+    @Test
+    public void removeTable() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("TableToRemove");
+        assertTrue(sharedRealm.hasTable("TableToRemove"));
+        sharedRealm.removeTable("TableToRemove");
+        assertFalse(sharedRealm.hasTable("TableToRemove"));
+        sharedRealm.commitTransaction();
+    }
+
+    @Test
+    public void removeTable_notInTransactionThrows() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("TableToRemove");
+        sharedRealm.commitTransaction();
+        thrown.expect(IllegalStateException.class);
+        sharedRealm.removeTable("TableToRemove");
+    }
+
+    @Test
+    public void removeTable_tableNotExist() {
+        sharedRealm.beginTransaction();
+        assertFalse(sharedRealm.hasTable("TableToRemove"));
+        thrown.expect(RealmError.class);
+        sharedRealm.removeTable("TableToRemove");
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void renameTable() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("OldTable");
+        assertTrue(sharedRealm.hasTable("OldTable"));
+        sharedRealm.renameTable("OldTable", "NewTable");
+        assertFalse(sharedRealm.hasTable("OldTable"));
+        assertTrue(sharedRealm.hasTable("NewTable"));
+        sharedRealm.commitTransaction();
+    }
+
+    @Test
+    public void renameTable_notInTransactionThrows() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("OldTable");
+        sharedRealm.commitTransaction();
+        thrown.expect(IllegalStateException.class);
+        sharedRealm.renameTable("OldTable", "NewTable");
+    }
+
+    @Test
+    public void renameTable_tableNotExist() {
+        sharedRealm.beginTransaction();
+        assertFalse(sharedRealm.hasTable("TableToRemove"));
+        thrown.expect(RealmError.class);
+        sharedRealm.renameTable("TableToRemove", "newName");
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void beginTransaction_SchemaVersionListener() {
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
+
+        sharedRealm.close();
+        sharedRealm = SharedRealm.getInstance(config, null, new SharedRealm.SchemaVersionListener() {
+            @Override
+            public void onSchemaVersionChanged(long currentVersion) {
+                listenerCalled.set(true);
+                schemaVersionFromListener.set(currentVersion);
+            }
+        });
+
+        final long before = sharedRealm.getSchemaVersion();
+
+        sharedRealm.beginTransaction();
+        try {
+            // listener is not called if there was no schema change
+            assertFalse(listenerCalled.get());
+
+            // change the schema version
+            sharedRealm.setSchemaVersion(before + 1);
+        } finally {
+            sharedRealm.commitTransaction();
+        }
+
+        // listener is not yet called
+        assertFalse(listenerCalled.get());
+
+        sharedRealm.beginTransaction();
+        try {
+            assertTrue(listenerCalled.get());
+            assertEquals(before + 1, schemaVersionFromListener.get());
+        } finally {
+            sharedRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void refresh_SchemaVersionListener() {
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
+
+        sharedRealm.close();
+        sharedRealm = SharedRealm.getInstance(config, null, new SharedRealm.SchemaVersionListener() {
+            @Override
+            public void onSchemaVersionChanged(long currentVersion) {
+                listenerCalled.set(true);
+                schemaVersionFromListener.set(currentVersion);
+            }
+        });
+
+        final long before = sharedRealm.getSchemaVersion();
+
+        sharedRealm.refresh();
+        // listener is not called if there was no schema change
+        assertFalse(listenerCalled.get());
+
+        sharedRealm.beginTransaction();
+        try {
+            // change the schema version
+            sharedRealm.setSchemaVersion(before + 1);
+        } finally {
+            sharedRealm.commitTransaction();
+        }
+
+        // listener is not yet called
+        assertFalse(listenerCalled.get());
+
+        sharedRealm.refresh();
+        assertTrue(listenerCalled.get());
+        assertEquals(before + 1, schemaVersionFromListener.get());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 7930566faf..cb8a1c62a8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.res.AssetManager;
+import android.support.test.InstrumentationRegistry;
 
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.Description;
@@ -70,6 +71,7 @@ public void evaluate() throws Throwable {
     @Override
     protected void before() throws Throwable {
         super.before();
+        Realm.init(InstrumentationRegistry.getTargetContext());
     }
 
     @Override
@@ -88,13 +90,14 @@ protected void after() {
                 throw e;
             }
         } finally {
-            // This will delete the temp folder.
+            // This will delete the temp directory.
             super.after();
         }
     }
 
     public RealmConfiguration createConfiguration() {
-        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configuration = new RealmConfiguration.Builder()
+                .directory(getRoot())
                 .build();
 
         configurations.add(configuration);
@@ -104,7 +107,8 @@ public RealmConfiguration createConfiguration() {
     public RealmConfiguration createConfiguration(String subDir, String name) {
         final File folder = new File(getRoot(), subDir);
         assertTrue(folder.mkdirs());
-        RealmConfiguration configuration = new RealmConfiguration.Builder(folder)
+        RealmConfiguration configuration = new RealmConfiguration.Builder()
+                .directory(folder)
                 .name(name)
                 .build();
 
@@ -113,7 +117,8 @@ public RealmConfiguration createConfiguration(String subDir, String name) {
     }
 
     public RealmConfiguration createConfiguration(String name) {
-        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configuration = new RealmConfiguration.Builder()
+                .directory(getRoot())
                 .name(name)
                 .build();
 
@@ -122,7 +127,8 @@ public RealmConfiguration createConfiguration(String name) {
     }
 
     public RealmConfiguration createConfiguration(String name, byte[] key) {
-        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configuration = new RealmConfiguration.Builder()
+                .directory(getRoot())
                 .name(name)
                 .encryptionKey(key)
                 .build();
@@ -132,14 +138,15 @@ public RealmConfiguration createConfiguration(String name, byte[] key) {
     }
 
     public RealmConfiguration.Builder createConfigurationBuilder() {
-        return new RealmConfiguration.Builder(getRoot());
+        return new RealmConfiguration.Builder().directory(getRoot());
     }
 
     // Copies a Realm file from assets to temp dir
     public void copyRealmFromAssets(Context context, String realmPath, String newName)
             throws IOException {
         // Delete the existing file before copy
-        RealmConfiguration configToDelete = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configToDelete = new RealmConfiguration.Builder()
+                .directory(getRoot())
                 .name(newName)
                 .build();
         Realm.deleteRealm(configToDelete);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
index a29895fffb..7a841817d0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -24,6 +24,7 @@
 import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
+import android.util.Log;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -79,6 +80,12 @@ public RemoteProcessService() {
         thiz = this;
     }
 
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        Realm.init(this);
+    }
+
     @Override
     public IBinder onBind(Intent intent) {
         return messenger.getBinder();
@@ -121,7 +128,7 @@ private static String currentLine() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder(thiz).build());
+            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder().build());
             int expected = 1;
             long got = thiz.testRealm.where(AllTypes.class).count();
             if (expected == got) {
@@ -137,7 +144,7 @@ void run() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder(thiz).build());
+            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder().build());
             thiz.testRealm.close();
             response(null);
             Runtime.getRuntime().exit(0);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
new file mode 100644
index 0000000000..a9646a0bea
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -0,0 +1,89 @@
+package io.realm;
+
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+
+import io.realm.internal.network.AuthenticateRequest;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.objectserver.Token;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+
+@RunWith(AndroidJUnit4.class)
+public class AuthenticateRequestTests {
+
+    @Before
+    public void setUp() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+    }
+
+    // Tests based on the schemas described here: https://github.com/realm/realm-sync-services/blob/master/doc/index.apib
+
+    @Test
+    public void realmLogin() throws URISyntaxException, JSONException {
+        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
+        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.value() + "/default"));
+
+        JSONObject obj = new JSONObject(request.toJson());
+        assertEquals("/" + t.value() + "/default", obj.get("path"));
+        assertEquals(t.value(), obj.get("data"));
+        assertEquals("realm", obj.get("provider"));
+    }
+
+    @Test
+    public void userLogin() throws URISyntaxException, JSONException {
+        AuthenticateRequest request = AuthenticateRequest.userLogin(SyncCredentials.facebook("foo"));
+
+        JSONObject obj = new JSONObject(request.toJson());
+        assertFalse(obj.has("path"));
+        assertEquals("foo", obj.get("data"));
+        assertEquals("facebook", obj.get("provider"));
+    }
+
+    @Test
+    public void userRefresh() throws URISyntaxException, JSONException {
+        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
+        AuthenticateRequest request = AuthenticateRequest.userRefresh(t);
+
+        JSONObject obj = new JSONObject(request.toJson());
+        assertFalse(obj.has("path"));
+        assertEquals(t.value(), obj.get("data"));
+        assertEquals("realm", obj.get("provider"));
+    }
+
+
+    @Test
+    public void errorsNotWrapped() {
+        AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createErrorResponse(ErrorCode.ACCESS_DENIED));
+        SyncManager.setAuthServerImpl(authServer);
+
+        try {
+            SyncUser.login(SyncCredentials.facebook("foo"), "http://foo.bar/auth");
+            fail();
+        } catch (ObjectServerError e) {
+            assertEquals(ErrorCode.ACCESS_DENIED, e.getErrorCode());
+        } finally {
+            // Reset the auth server implementation for other tests.
+            SyncManager.setAuthServerImpl(originalAuthServer);
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
new file mode 100644
index 0000000000..eaac178bb9
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/CredentialsTests.java
@@ -0,0 +1,139 @@
+package io.realm;
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class CredentialsTests {
+
+    // See https://github.com/realm/realm-sync-services/blob/master/doc/index.apib for a description of the fields
+    // needed by each identity provider.
+
+    @Test
+    public void getUserInfo_isUnmodifiable() {
+        SyncCredentials creds = SyncCredentials.custom("foo", "bar", null);
+        Map<java.lang.String, Object> userInfo = creds.getUserInfo();
+        try {
+            userInfo.put("boom", null);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+    @Test
+    public void facebook() {
+        SyncCredentials creds = SyncCredentials.facebook("foo");
+
+        assertEquals(SyncCredentials.IdentityProvider.FACEBOOK, creds.getIdentityProvider());
+        assertEquals("foo", creds.getUserIdentifier());
+        assertTrue(creds.getUserInfo().isEmpty());
+    }
+
+    @Test
+    public void google() {
+        SyncCredentials creds = SyncCredentials.google("foo");
+
+        assertEquals(SyncCredentials.IdentityProvider.GOOGLE, creds.getIdentityProvider());
+        assertEquals("foo", creds.getUserIdentifier());
+        assertTrue(creds.getUserInfo().isEmpty());
+    }
+
+    @Test
+    public void facebook_invalidInput() {
+        String[] invalidInput = { null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.facebook(input);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void usernamePassword() {
+        SyncCredentials creds = SyncCredentials.usernamePassword("foo", "bar", true);
+        assertEquals("foo", creds.getUserIdentifier());
+        Map<String, Object> userInfo = creds.getUserInfo();
+
+        assertEquals(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, creds.getIdentityProvider());
+        assertEquals("bar", userInfo.get("password"));
+        assertTrue((Boolean) userInfo.get("register"));
+    }
+
+    // Only validate username. All passwords are allowed
+    @Test
+    public void usernamePassword_invalidUserName() {
+        String[] invalidInput = { null, ""};
+        for (String input : invalidInput) {
+            try {
+                SyncCredentials.usernamePassword(input, "bar", true);
+                fail(input + " should have failed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void custom_invalidUserName() {
+        Map<String, Object> userInfo = new HashMap<>();
+        userInfo.put("custom", "property");
+        for (String username : new String[]{null, ""}) {
+            try {
+                SyncCredentials.custom("facebook", username, userInfo);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void custom() {
+        Map<java.lang.String, Object> userInfo = new HashMap<String, Object>();
+        userInfo.put("custom", "property");
+        SyncCredentials creds = SyncCredentials.custom("customProvider", "foo", userInfo);
+
+        assertEquals("foo", creds.getUserIdentifier());
+        assertEquals("customProvider", creds.getIdentityProvider());
+        assertEquals(1, creds.getUserInfo().size());
+        assertEquals("property", creds.getUserInfo().get("custom"));
+    }
+
+    @Test
+    public void custom_invalidProvider() {
+        Map<String, Object> userInfo = new HashMap<>();
+        userInfo.put("custom", "property");
+
+        for (String provider : new String[]{null, ""}) {
+            try {
+                SyncCredentials.custom(null, "foo", userInfo);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
new file mode 100644
index 0000000000..d9dd20f801
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.StringOnly;
+import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.util.SyncTestUtils;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SchemaTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SyncConfiguration config;
+
+    @Before
+    public void setUp() {
+        SyncUser user = SyncTestUtils.createTestUser();
+        config = new SyncConfiguration.Builder(user, "realm://objectserver.realm.io/~/default").build();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        Realm.deleteRealm(config);
+    }
+
+    @Test
+    public void getInstance() {
+        Realm realm = Realm.getInstance(config);
+        assertFalse(realm.isClosed());
+        realm.close();
+        assertTrue(realm.isClosed());
+    }
+
+    @Test
+    public void createObject() {
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        assertTrue(realm.getSchema().contains("StringOnly"));
+        StringOnly stringOnly= realm.createObject(StringOnly.class);
+        stringOnly.setChars("TEST");
+        realm.commitTransaction();
+        assertEquals(1, realm.where(StringOnly.class).count());
+        realm.close();
+    }
+
+    @Test
+    public void disallow_removeClass() {
+        Realm realm = Realm.getInstance(config);
+        String className = "StringOnly";
+        realm.beginTransaction();
+        assertTrue(realm.getSchema().contains(className));
+        try {
+            realm.getSchema().remove(className);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    @Test
+    public void allow_createClass() {
+        Realm realm = Realm.getInstance(config);
+        String className = "Dogplace";
+        realm.beginTransaction();
+        realm.getSchema().create("Dogplace");
+        realm.commitTransaction();
+        assertTrue(realm.getSchema().contains(className));
+        realm.close();
+    }
+
+    @Test
+    public void disallow_renameClass() {
+        Realm realm = Realm.getInstance(config);
+        String className = "StringOnly";
+        realm.beginTransaction();
+        try {
+            realm.getSchema().rename(className, "Dogplace");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            assertTrue(realm.getSchema().contains(className));
+            realm.close();
+        }
+    }
+
+    @Test
+    public void disallow_removeField() {
+        Realm realm = Realm.getInstance(config);
+        String className = "StringOnly";
+        String fieldName = "chars";
+        realm.beginTransaction();
+        assertTrue(realm.getSchema().get(className).hasField(fieldName));
+        try {
+            realm.getSchema().get(className).removeField(fieldName);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    @Test
+    public void allow_addField() {
+        String className = "StringOnly";
+        Realm realm = Realm.getInstance(config);
+
+        realm.beginTransaction();
+        realm.getSchema().get(className).addField("foo", String.class);
+        realm.commitTransaction();
+
+        assertTrue(realm.getSchema().get(className).hasField("foo"));
+
+        realm.close();
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
new file mode 100644
index 0000000000..66a072e05f
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.OkHttpAuthenticationServer;
+import io.realm.internal.objectserver.ObjectServerSession;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+@RunWith(AndroidJUnit4.class)
+public class SessionTests {
+
+    private static String REALM_URI = "realm://objectserver.realm.io/~/default";
+
+    private Context context;
+    private AuthenticationServer authServer;
+    private SyncConfiguration configuration;
+    private SyncUser user;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getContext();
+        user = createTestUser();
+        authServer = new OkHttpAuthenticationServer();
+        configuration = new SyncConfiguration.Builder(user, REALM_URI).build();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void get_syncValues() {
+        ObjectServerSession internalSession = new ObjectServerSession(
+                configuration,
+                authServer,
+                configuration.getUser().getSyncUser(),
+                configuration.getSyncPolicy(),
+                configuration.getErrorHandler()
+        );
+        SyncSession session = new SyncSession(internalSession);
+
+        assertEquals("realm://objectserver.realm.io/JohnDoe/default", session.getServerUrl().toString());
+        assertEquals(user, session.getUser());
+        assertEquals(configuration, session.getConfiguration());
+        assertNull(session.getState());
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
new file mode 100644
index 0000000000..a95159a505
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.entities.StringOnly;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncConfigurationTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final TemporaryFolder tempFolder = new TemporaryFolder();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Context context;
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getContext();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    @Test
+    public void user() {
+//        new SyncConfiguration.Builder(context);
+        // Check that user can be added
+        // That the default local path is correct
+    }
+
+    @Test
+    public void user_invalidUserThrows() {
+        try {
+            new SyncConfiguration.Builder(null, "realm://ros.realm.io/default");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        SyncUser user = createTestUser(0); // Create user that has expired credentials
+        try {
+            new SyncConfiguration.Builder(user, "realm://ros.realm.io/default");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void serverUrl_setsFolderAndFileName() {
+        SyncUser user = createTestUser();
+        String[][] validUrls = {
+                // <URL>, <Folder>, <FileName>
+                { "realm://objectserver.realm.io/~/default", "realm-object-server/" + user.getIdentity(), "default" },
+                { "realm://objectserver.realm.io/~/sub/default", "realm-object-server/" + user.getIdentity() + "/sub", "default" }
+        };
+
+        for (String[] validUrl : validUrls) {
+            String serverUrl  = validUrl[0];
+            String expectedFolder = validUrl[1];
+            String expectedFileName = validUrl[2];
+
+            SyncConfiguration config = new SyncConfiguration.Builder(user, serverUrl).build();
+
+            assertEquals(new File(context.getFilesDir(), expectedFolder), config.getRealmDirectory());
+            assertEquals(expectedFileName, config.getRealmFileName());
+        }
+    }
+
+    @Test
+    public void serverUrl_invalidUrlThrows() {
+        String[] invalidUrls = {
+            null,
+// TODO Should these two fail?
+//            "objectserver.realm.io/~/default", // Missing protocol. TODO Should we just default to one?
+//            "/~/default", // Missing server
+            "realm://objectserver.realm.io/~/default.realm", // Ending with .realm
+            "realm://objectserver.realm.io/~/default.realm.lock", // Ending with .realm.lock
+            "realm://objectserver.realm.io/~/default.realm.management", // Ending with .realm.management
+            "realm://objectserver.realm.io/<~>/default.realm", // Invalid chars <>
+            "realm://objectserver.realm.io/~/default.realm/", // Ending with /
+            "realm://objectserver.realm.io/~/Αθήνα", // Non-ascii
+            "realm://objectserver.realm.io/~/foo/../bar", // .. is not allowed
+            "realm://objectserver.realm.io/~/foo/./bar", // . is not allowed
+            "http://objectserver.realm.io/~/default", // wrong scheme
+        };
+
+        for (String invalidUrl : invalidUrls) {
+            try {
+                new SyncConfiguration.Builder(createTestUser(), invalidUrl);
+                fail(invalidUrl + " should have failed.");
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    private String makeServerUrl(int len) {
+        StringBuilder builder = new StringBuilder("realm://objectserver.realm.io/~/");
+        for (int i = 0; i < len; i++) {
+            builder.append('A');
+        }
+        return builder.toString();
+    }
+
+    @Test
+    public void serverUrl_length() {
+        int[] lengths = {1, SyncConfiguration.MAX_FILE_NAME_LENGTH - 1,
+                SyncConfiguration.MAX_FILE_NAME_LENGTH, SyncConfiguration.MAX_FILE_NAME_LENGTH + 1, 1000};
+
+        for (int len : lengths) {
+            SyncConfiguration config = new SyncConfiguration.Builder(createTestUser(), makeServerUrl(len)).build();
+            assertTrue("Length: " + len, config.getRealmFileName().length() <= SyncConfiguration.MAX_FILE_NAME_LENGTH);
+            assertTrue("Length: " + len, config.getPath().length() <= SyncConfiguration.MAX_FULL_PATH_LENGTH);
+        }
+    }
+
+    @Test
+    public void serverUrl_invalidChars() {
+        SyncConfiguration.Builder builder = new SyncConfiguration.Builder(createTestUser(), "realm://objectserver.realm.io/~/?");
+        SyncConfiguration config = builder.build();
+        assertFalse(config.getRealmFileName().contains("?"));
+    }
+
+    @Test
+    public void serverUrl_port() {
+        Map<String, Integer> urlPort = new HashMap<String, Integer>();
+        urlPort.put("realm://objectserver.realm.io/~/default", -1); // default port - handled by sync client
+        urlPort.put("realms://objectserver.realm.io/~/default", -1); // default port - handled by sync client
+        urlPort.put("realm://objectserver.realm.io:8080/~/default", 8080);
+        urlPort.put("realms://objectserver.realm.io:2443/~/default", 2443);
+
+        for (String url : urlPort.keySet()) {
+            SyncConfiguration config = new SyncConfiguration.Builder(createTestUser(), url).build();
+            assertEquals(urlPort.get(url).intValue(), config.getServerUrl().getPort());
+        }
+    }
+
+    @Test
+    public void errorHandler() {
+        SyncConfiguration.Builder builder = new SyncConfiguration.Builder(createTestUser(), "realm://objectserver.realm.io/default");
+        SyncSession.ErrorHandler errorHandler = new SyncSession.ErrorHandler() {
+            @Override
+            public void onError(SyncSession session, ObjectServerError error) {
+
+            }
+        };
+        SyncConfiguration config = builder.errorHandler(errorHandler).build();
+        assertEquals(errorHandler, config.getErrorHandler());
+    }
+
+    @Test
+    public void errorHandler_fromSyncManager() {
+        // Set default error handler
+        SyncSession.ErrorHandler errorHandler = new SyncSession.ErrorHandler() {
+            @Override
+            public void onError(SyncSession session, ObjectServerError error) {
+
+            }
+        };
+        SyncManager.setDefaultSessionErrorHandler(errorHandler);
+
+        // Create configuration using the default handler
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+        assertEquals(errorHandler, config.getErrorHandler());
+        SyncManager.setDefaultSessionErrorHandler(null);
+    }
+
+
+    @Test
+    public void errorHandler_nullThrows() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration.Builder builder = new SyncConfiguration.Builder(user, url);
+
+        try {
+            builder.errorHandler(null);
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void equals() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .build();
+        assertTrue(config.equals(config));
+    }
+
+    @Test
+    public void equals_same() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user, url).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, url).build();
+
+        assertTrue(config1.equals(config2));
+    }
+
+    @Test
+    public void equals_not() {
+        SyncUser user = createTestUser();
+        String url1 = "realm://objectserver.realm.io/default1";
+        String url2 = "realm://objectserver.realm.io/default2";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user, url1).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, url2).build();
+        assertFalse(config1.equals(config2));
+    }
+
+    @Test
+    public void hashCode_equal() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .build();
+
+        assertEquals(config.hashCode(), config.hashCode());
+    }
+
+    @Test
+    public void hashCode_notEquals() {
+        SyncUser user = createTestUser();
+        String url1 = "realm://objectserver.realm.io/default1";
+        String url2 = "realm://objectserver.realm.io/default2";
+        SyncConfiguration config1 = new SyncConfiguration.Builder(user, url1).build();
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, url2).build();
+        assertNotEquals(config1.hashCode(), config2.hashCode());
+    }
+
+    @Test
+    public void get_syncSpecificValues() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+        assertTrue(user.equals(config.getUser()));
+        assertEquals("realm://objectserver.realm.io/default", config.getServerUrl().toString());
+        assertFalse(config.shouldDeleteRealmOnLogout());
+        assertTrue(config.isSyncConfiguration());
+    }
+
+    @Test
+    public void encryption() {
+       SyncUser user = createTestUser();
+       String url = "realm://objectserver.realm.io/default";
+       SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+               .encryptionKey(TestHelper.getRandomKey())
+               .build();
+       assertNotNull(config.getEncryptionKey());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void encryption_invalid_null() {
+       SyncUser user = createTestUser();
+       String url = "realm://objectserver.realm.io/default";
+
+       new SyncConfiguration.Builder(user, url).encryptionKey(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void encryption_invalid_wrong_length() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        new SyncConfiguration.Builder(user, url).encryptionKey(new byte[]{1, 2, 3});
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void directory_null() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        new SyncConfiguration.Builder(user, url).directory(null);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void directory_writeProtectedDir() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        File dir = new File("/");
+        new SyncConfiguration.Builder(user, url).directory(dir);
+    }
+
+    @Test
+    public void directory_dirIsAFile() throws IOException {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        File dir = configFactory.getRoot();
+        File file = new File(dir, "dummyfile");
+        assertTrue(file.createNewFile());
+        thrown.expect(IllegalArgumentException.class);
+        new SyncConfiguration.Builder(user, url).directory(file);
+        file.delete(); // clean up
+    }
+
+    /* FIXME: deleteRealmOnLogout is not supported by now
+    @Test
+    public void deleteOnLogout() {
+        User user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .deleteRealmOnLogout()
+                .build();
+        assertTrue(config.shouldDeleteRealmOnLogout());
+    }
+    */
+
+    @Test
+    public void initialData() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        StringOnly stringOnly = realm.createObject(StringOnly.class);
+                        stringOnly.setChars("TEST 42");
+                    }
+                })
+                .build();
+
+        assertNotNull(config.getInitialDataTransaction());
+
+        // open the first time - initialData must be triggered
+        Realm realm1 = Realm.getInstance(config);
+        RealmResults<StringOnly> results = realm1.where(StringOnly.class).findAll();
+        assertEquals(1, results.size());
+        assertEquals("TEST 42", results.first().getChars());
+        realm1.close();
+
+        // open the second time - initialData must not be triggered
+        Realm realm2 = Realm.getInstance(config);
+        assertEquals(1, realm2.where(StringOnly.class).count());
+        realm2.close();
+    }
+
+    @Test
+    public void defaultRxFactory() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+
+        assertNotNull(config.getRxFactory());
+    }
+
+    @Test
+    public void toString_nonEmpty() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+
+        String configStr = config.toString();
+        assertTrue(configStr != null && !configStr.isEmpty());
+    }
+
+    // FIXME: This test can be removed when https://github.com/realm/realm-core/issues/2345 is resolved
+    @Test(expected = UnsupportedOperationException.class)
+    public void compact_NotAllowed() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url).build();
+
+        Realm.compactRealm(config);
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
new file mode 100644
index 0000000000..510bfca5aa
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.Collection;
+import java.util.Set;
+
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncManagerTests {
+
+    private UserStore userStore;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @Before
+    public void setUp() {
+        userStore = new UserStore() {
+            @Override
+            public void put(SyncUser user) {}
+
+            @Override
+            public SyncUser get() {
+                return null;
+            }
+
+            @Override
+            public void remove() {}
+
+            @Override
+            public Collection<SyncUser> allUsers() {
+                return null;
+            }
+
+        };
+    }
+
+    @Test
+    public void init() {
+        // Realm.init() calls SyncManager.init() which will start a thread for the sync client
+        boolean found = false;
+        Set<Thread> threads = Thread.getAllStackTraces().keySet();
+        for (Thread thread : threads) {
+            if (thread.getName().equals("RealmSyncClient")) {
+                found = true;
+                break;
+            }
+        }
+        assertTrue(found);
+    }
+
+    @Test
+    public void set_userStore() {
+        SyncManager.setUserStore(userStore);
+        assertTrue(userStore.equals(SyncManager.getUserStore()));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void set_userStore_null() {
+        SyncManager.setUserStore(null);
+    }
+
+    @Test
+    public void authListener() {
+        SyncUser user = createTestUser();
+        final int[] counter = {0, 0};
+
+        AuthenticationListener authenticationListener = new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                counter[0]++;
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                counter[1]++;
+            }
+        };
+
+        SyncManager.addAuthenticationListener(authenticationListener);
+        SyncManager.notifyUserLoggedIn(user);
+        SyncManager.notifyUserLoggedOut(user);
+        assertEquals(1, counter[0]);
+        assertEquals(1, counter[1]);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void authListener_null() {
+        SyncManager.addAuthenticationListener(null);
+    }
+
+    @Test
+    public void authListener_remove() {
+        SyncUser user = createTestUser();
+        final int[] counter = {0, 0};
+
+        AuthenticationListener authenticationListener = new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                counter[0]++;
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                counter[1]++;
+            }
+        };
+
+        SyncManager.addAuthenticationListener(authenticationListener);
+
+        SyncManager.removeAuthenticationListener(authenticationListener);
+
+        SyncManager.notifyUserLoggedIn(user);
+        SyncManager.notifyUserLoggedOut(user);
+
+        // no listener to update counters
+        assertEquals(0, counter[0]);
+        assertEquals(0, counter[1]);
+    }
+
+    @Test
+    public void session() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .build();
+
+        SyncSession session = SyncManager.getSession(config);
+        assertEquals(user, session.getUser()); // see also SessionTests
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
new file mode 100644
index 0000000000..18a8eb9aea
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.Collection;
+import java.util.UUID;
+
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.rule.RunInLooperThread;
+import io.realm.util.SyncTestUtils;
+
+import static io.realm.util.SyncTestUtils.createTestUser;
+import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncUserTests {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @BeforeClass
+    public static void initUserStore() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
+        UserStore userStore = new RealmFileUserStore(InstrumentationRegistry.getTargetContext().getFilesDir().getPath());
+        SyncManager.setUserStore(userStore);
+    }
+
+    @After
+    public void tearDown() {
+        RealmFileUserStore.nativeResetForTesting();
+    }
+
+    @Test
+    public void toAndFromJson() {
+        SyncUser user1 = createTestUser();
+        SyncUser user2 = SyncUser.fromJson(user1.toJson());
+        assertEquals(user1, user2);
+    }
+
+    // Tests that the UserStore does not return users that have expired
+    @Test
+    public void currentUser_returnsNullIfUserExpired() {
+        // Add an expired user to the user store
+        UserStore userStore = SyncManager.getUserStore();
+        userStore.put(SyncTestUtils.createTestUser(Long.MIN_VALUE));
+
+        // Invalid users should not be returned when asking the for the current user
+        assertNull(SyncUser.currentUser());
+    }
+
+    @Test
+    public void currentUser_throwsIfMultipleUsersLoggedIn() {
+        AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        SyncManager.setAuthServerImpl(authServer);
+        try {
+            // 1. Login two random users
+            when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenAnswer(new Answer<AuthenticateResponse>() {
+                @Override
+                public AuthenticateResponse answer(InvocationOnMock invocationOnMock) throws Throwable {
+                    return getNewRandomUser();
+                }
+            });
+            SyncUser.login(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
+            SyncUser.login(SyncCredentials.facebook("foo"), "http:/test.realm.io/auth");
+
+            // 2. Verify currentUser() now throws
+            try {
+                SyncUser.currentUser();
+                fail();
+            } catch (IllegalStateException ignore) {
+            }
+        } finally {
+            SyncManager.setAuthServerImpl(originalAuthServer);
+        }
+
+    }
+
+    private AuthenticateResponse getNewRandomUser() {
+        String identity = UUID.randomUUID().toString();
+        String userTokenValue = UUID.randomUUID().toString();
+        return SyncTestUtils.createLoginResponse(userTokenValue, identity, Long.MAX_VALUE);
+    }
+
+    // Test that current user is cleared if it is logged out
+    @Test
+    public void currentUser_clearedOnLogout() {
+        // Add 1 valid user to the user store
+        SyncUser user = SyncTestUtils.createTestUser(Long.MAX_VALUE);
+        UserStore userStore = SyncManager.getUserStore();
+        userStore.put(user);
+
+        SyncUser savedUser = SyncUser.currentUser();
+        assertEquals(user, savedUser);
+        assertNotNull(savedUser);
+        savedUser.logout();
+        assertNull(SyncUser.currentUser());
+    }
+
+    // `all()` returns an empty list if no users are logged in
+    @Test
+    public void all_empty() {
+        Collection<SyncUser> users = SyncUser.all();
+        assertTrue(users.isEmpty());
+    }
+
+    // `all()` returns only valid users. Invalid users are filtered.
+    @Test
+    public void all_validUsers() {
+        // Add 1 expired user and 1 valid user to the user store
+        UserStore userStore = SyncManager.getUserStore();
+        userStore.put(SyncTestUtils.createTestUser(Long.MIN_VALUE));
+        userStore.put(SyncTestUtils.createTestUser(Long.MAX_VALUE));
+
+        Collection<SyncUser> users = SyncUser.all();
+        assertEquals(1, users.size());
+        assertTrue(users.iterator().next().isValid());
+    }
+
+    // Tests that the user store returns the last user to login
+    /* FIXME: This test fails because of wrong JSON string.
+    @Test
+    public void currentUser_returnsUserAfterLogin() {
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        when(authServer.loginUser(any(Credentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
+
+        User user = User.login(Credentials.facebook("foo"), "http://bar.com/auth");
+        assertEquals(user, User.currentUser());
+    }
+    */
+
+    @Test
+    public void getManagementRealm() {
+        SyncUser user = SyncTestUtils.createTestUser();
+        Realm managementRealm = user.getManagementRealm();
+        assertNotNull(managementRealm);
+        managementRealm.close();
+    }
+
+    @Test
+    public void getManagementRealm_enforceTLS() throws URISyntaxException {
+        // Non TLS
+        SyncUser user = SyncTestUtils.createTestUser("http://objectserver.realm.io/auth");
+        Realm managementRealm = user.getManagementRealm();
+        SyncConfiguration config = (SyncConfiguration) managementRealm.getConfiguration();
+        assertEquals(new URI("realm://objectserver.realm.io/" + user.getIdentity() + "/__management"), config.getServerUrl());
+        managementRealm.close();
+
+        // TLS
+        user = SyncTestUtils.createTestUser("https://objectserver.realm.io/auth");
+        managementRealm = user.getManagementRealm();
+        config = (SyncConfiguration) managementRealm.getConfiguration();
+        assertEquals(new URI("realms://objectserver.realm.io/" + user.getIdentity() + "/__management"), config.getServerUrl());
+        managementRealm.close();
+    }
+
+    @Test
+    public void toString_returnDescription() {
+        SyncUser user = SyncTestUtils.createTestUser("http://objectserver.realm.io/auth");
+        String str = user.toString();
+        assertTrue(str != null && !str.isEmpty());
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
new file mode 100644
index 0000000000..ef3ead5f2f
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.UUID;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.SyncUser;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.objectserver.ObjectServerUser;
+import io.realm.internal.objectserver.Token;
+
+public class SyncTestUtils {
+
+    public static String USER_TOKEN = UUID.randomUUID().toString();
+    public static String REALM_TOKEN = UUID.randomUUID().toString();
+    public static String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
+
+    public static SyncUser createRandomTestUser() {
+        return createTestUser(UUID.randomUUID().toString(), UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE);
+    }
+
+    public static SyncUser createTestUser() {
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+    }
+
+    public static SyncUser createTestUser(long expires) {
+        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_AUTH_URL, expires);
+    }
+
+    public static SyncUser createTestUser(String authUrl) {
+        return createTestUser(USER_TOKEN, REALM_TOKEN, authUrl, Long.MAX_VALUE);
+    }
+
+    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String authUrl, long expires) {
+        Token userToken = new Token(userTokenValue, "JohnDoe", null, expires, null);
+        Token accessToken = new Token(realmTokenValue, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
+        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
+
+        JSONObject obj = new JSONObject();
+        try {
+            JSONArray realmList = new JSONArray();
+            JSONObject realmDesc = new JSONObject();
+            realmDesc.put("uri", "realm://objectserver.realm.io/default");
+            realmDesc.put("description", desc.toJson());
+            realmList.put(realmDesc);
+
+            obj.put("authUrl", authUrl);
+            obj.put("userToken", userToken.toJson());
+            obj.put("realms", realmList);
+            return SyncUser.fromJson(obj.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static AuthenticateResponse createLoginResponse(long expires) {
+        return createLoginResponse(USER_TOKEN, "JohnDoe", expires);
+    }
+
+    public static AuthenticateResponse createLoginResponse(String userTokenValue, String userIdentity, long expires) {
+        try {
+            Token userToken = new Token(userTokenValue, userIdentity, null, expires, null);
+            JSONObject response = new JSONObject();
+            response.put("refresh_token", userToken.toJson());
+            return AuthenticateResponse.from(response.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static AuthenticateResponse createRefreshResponse() {
+        try {
+            Token userToken = new Token(USER_TOKEN, "JohnDoe", null, Long.MAX_VALUE, null);
+            JSONObject response = new JSONObject();
+            response.put("refresh_token", userToken.toJson());
+            return AuthenticateResponse.from(response.toString());
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static AuthenticateResponse createErrorResponse(ErrorCode code) {
+        return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmAllocBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmAllocBenchmarks.java
new file mode 100644
index 0000000000..f9f5a62a6b
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmAllocBenchmarks.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmQuery;
+import io.realm.RealmResults;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+
+@RunWith(SpannerRunner.class)
+public class RealmAllocBenchmarks {
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+
+    @BeforeExperiment
+    public void before() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class).getColumnRealmList().add(realm.createObject(Dog.class));
+        realm.commitTransaction();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void createObjects(long reps) {
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        for (long i = 0; i < reps; i++) {
+            results.first();
+        }
+    }
+
+    @Benchmark
+    public void createQueries(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.where(AllTypes.class);
+        }
+    }
+    @Benchmark
+    public void createRealmResults(long reps) {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+        for (long i = 0; i < reps; i++) {
+            query.findAll();
+        }
+    }
+
+    @Benchmark
+    public void createRealmLists(long reps) {
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        for (long i = 0; i < reps; i++) {
+            //noinspection ConstantConditions
+            allTypes.getColumnRealmList();
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
index dd23f1f917..cf307a1b5b 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
@@ -43,8 +43,9 @@
 
     @BeforeExperiment
     public void before() {
-        coldConfig = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).name("cold").build();
-        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        coldConfig = new RealmConfiguration.Builder().name("cold").build();
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(coldConfig);
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
index e26c003cd4..30719457ff 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
@@ -42,7 +42,8 @@
 
     @BeforeExperiment
     public void before() {
-        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
         realm.executeTransaction(new Realm.Transaction() {
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
index 73df749ab6..68719a222f 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
@@ -16,8 +16,6 @@
 
 package io.realm.benchmarks;
 
-import android.support.test.InstrumentationRegistry;
-
 import org.junit.runner.RunWith;
 
 import dk.ilios.spanner.AfterExperiment;
@@ -42,7 +40,7 @@
 
     @BeforeExperiment
     public void before() {
-        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
         realm.beginTransaction();
@@ -56,12 +54,26 @@ public void after() {
     }
 
     @Benchmark
-    public void writeString(long reps) {
+    public void writeShortString(long reps) {
         for (long i = 0; i < reps; i++) {
             writeObject.setColumnString("Foo");
         }
     }
 
+    @Benchmark
+    public void writeMediumString(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnString("ABCDEFHIJKLMNOPQ");
+        }
+    }
+
+    @Benchmark
+    public void writeLongString(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnString("ABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQ");
+        }
+    }
+
     @Benchmark
     public void writeLong(long reps) {
         for (long i = 0; i < reps; i++) {
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
index 9117d55d0a..8487c9d668 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
@@ -45,7 +45,7 @@
 
     @BeforeExperiment
     public void before() {
-        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
         realm.beginTransaction();
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
index 5a25e95ee0..f4cee113b9 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
@@ -45,7 +45,8 @@
 
     @BeforeExperiment
     public void before() {
-        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
         realm.beginTransaction();
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
index 47a1136b30..da65aab166 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
@@ -31,13 +31,13 @@
 public class BenchmarkConfig {
 
     public static SpannerConfig getConfiguration(String className) {
-        // Document folder is located at: /sdcard/realm-benchmarks
+        // Document directory is located at: /sdcard/realm-benchmarks
         // Benchmarks results should be saved in <documentFolder>/results/<className>.json
         // Baseline data should be found in <documentFolder>/baselines/<className>.json
         // Custom CSV files should be found in <documentFolder>/csv/<className>.csv
         File externalDocuments = new File(Environment.getExternalStorageDirectory(), "realm-benchmarks");
         if (!externalDocuments.exists() && !externalDocuments.mkdir()) {
-            throw new RuntimeException("Could not create benchmark folder: " + externalDocuments);
+            throw new RuntimeException("Could not create benchmark directory: " + externalDocuments);
         }
         File resultsDir = new File(externalDocuments, "results");
         File baselineDir = new File(externalDocuments, "baselines");
diff --git a/realm/realm-library/src/main/AndroidManifest.xml b/realm/realm-library/src/main/AndroidManifest.xml
index 6c57d744f5..a5dc325ad0 100644
--- a/realm/realm-library/src/main/AndroidManifest.xml
+++ b/realm/realm-library/src/main/AndroidManifest.xml
@@ -1,5 +1,2 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm" >
-
-</manifest>
\ No newline at end of file
+<manifest package="io.realm" />
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
new file mode 100644
index 0000000000..19883ffcd3
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -0,0 +1,188 @@
+cmake_minimum_required(VERSION 3.6.0)
+
+# find javah
+find_package(Java COMPONENTS Development)
+if (NOT Java_Development_FOUND)
+    if (DEFINED ENV{JAVA_HOME} AND EXISTS "$ENV{JAVA_HOME}/bin/javah")
+      set(Java_JAVAH_EXECUTABLE "$ENV{JAVA_HOME}/bin/javah")
+    elseif (EXISTS "/usr/bin/javah")
+      set(Java_JAVAH_EXECUTABLE "/usr/bin/javah")
+    else()
+      message(FATAL_ERROR "Cannot find javah")
+    endif()
+endif()
+include (UseJava)
+
+set(CMAKE_VERBOSE_MAKEFILE ON)
+# Generate compile_commands.json
+set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
+
+# Setup lcache
+if(NDK_LCACHE)
+    set(CMAKE_CXX_CREATE_SHARED_LIBRARY "${NDK_LCACHE} ${CMAKE_CXX_CREATE_SHARED_LIBRARY}")
+endif()
+
+# Set flag build_SYNC
+if (REALM_FLAVOR STREQUAL base)
+    set(build_SYNC OFF)
+else()
+    set(build_SYNC ON)
+endif()
+
+# Generate JNI header files. Each build has its own JNI header in its build_dir/jni_include.
+string(TOLOWER ${CMAKE_BUILD_TYPE} build_type_FOLDER)
+set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/${REALM_FLAVOR}/${build_type_FOLDER}/)
+set(classes_LIST
+    io.realm.internal.Table io.realm.internal.TableView io.realm.internal.CheckedRow
+    io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
+    io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
+    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.RealmSchema
+    io.realm.RealmObjectSchema io.realm.internal.NativeObjectReference
+)
+# /./ is the workaround for the problem that AS cannot find the jni headers.
+# See https://github.com/googlesamples/android-ndk/issues/319
+set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
+if (build_SYNC)
+    list(APPEND classes_LIST
+        io.realm.SyncManager io.realm.internal.objectserver.ObjectServerSession io.realm.RealmFileUserStore)
+endif()
+create_javah(TARGET jni_headers
+    CLASSES ${classes_LIST}
+
+    CLASSPATH ${classes_PATH}
+    OUTPUT_DIR ${jni_headers_PATH}
+    DEPENDS ${classes_PATH}
+)
+
+# TODO: Ideally the debug build should link with core's debug build. But core dbg lib has
+# some compile options problems with arm, especially with macro REALM_DEBUG. Link to core
+# dbg for debug build when that gets solved.
+# We always link to the non-dbg version of core libs for now.
+# This means only JNI part has debugging symbols with debug build.
+# Debugging with core source code will also be done though anther approach -- compiling the core
+# with cmake inside android project.
+# Configure import realm core lib
+set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-${ANDROID_ABI}.a)
+# Workaround for old core's funny ABI nicknames
+if (NOT EXISTS ${core_lib_PATH})
+    if (ARMEABI)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm.a)
+    elseif (ARMEABI_V7A)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm-v7a.a)
+    elseif (ARM64_V8A)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm64.a)
+    else()
+        message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
+    endif()
+endif()
+
+add_library(lib_realm_core STATIC IMPORTED)
+set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH})
+
+# Sync static library
+set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
+# Workaround for old core's funny ABI nicknames
+if (NOT EXISTS ${sync_lib_PATH})
+    if (ARMEABI)
+        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
+    elseif (ARMEABI_V7A)
+        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
+    elseif (ARM64_V8A)
+        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
+    else()
+        message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
+    endif()
+endif()
+add_library(lib_realm_sync STATIC IMPORTED)
+set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH})
+
+# build application's shared lib
+include_directories(${REALM_CORE_DIST_DIR}/include
+    ${CMAKE_SOURCE_DIR}
+    ${jni_headers_PATH}
+    ${CMAKE_SOURCE_DIR}/object-store/src)
+
+set(ANDROID_STL "gnustl_static")
+set(ANDROID_NO_UNDEFINED OFF)
+set(ANDROID_SO_UNDEFINED ON)
+
+if (ARMEABI)
+    set(ABI_CXX_FLAGS "-mthumb")
+elseif (ARMEABI_V7A)
+    set(ABI_CXX_FLAGS "-mthumb -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16")
+endif()
+
+#FIXME uninitialized is reported by query_expression.hpp:1070
+#      d.init(ValueBase::m_from_link_list, ValueBase::m_values, D{});
+#FIXME maybe-uninitialized is reported by table_view.cpp:272:15:
+#     'best.m_nanoseconds' was declared here
+set(WARNING_CXX_FLAGS "-Wall -Wextra -pedantic -Wno-long-long -Wno-variadic-macros \
+-Wno-missing-field-initializers -Wmissing-declarations -Wno-error=uninitialized -Wno-error=maybe-uninitialized")
+set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DREALM_HAVE_EPOLL -DPIC -pthread -fvisibility=hidden -std=c++14 -fsigned-char")
+if (build_SYNC)
+    set(REALM_COMMON_CXX_FLAGS "${REALM_COMMON_CXX_FLAGS} -DREALM_ENABLE_SYNC=1")
+endif()
+# There might be an issue with -Os of ndk gcc 4.9. It will hang the encryption related tests.
+# And this issue doesn't seem to impact the core compiling.
+set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG")
+#-ggdb doesn't play well with -flto
+set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
+
+# Set link flags
+set(REALM_LINKER_FLAGS "")
+if (build_SYNC)
+    set(REALM_LINKER_FLAGS "${REALM_LINKER_FLAGS} -lz")
+endif()
+set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${REALM_LINKER_FLAGS}")
+
+# JNI source files
+file(GLOB jni_SRC
+    "*.cpp"
+    "jni_util/*.cpp"
+    "jni_impl/android_logger.cpp"
+)
+# Those source file are only needed for sync.
+if (NOT build_SYNC)
+    list(REMOVE_ITEM jni_SRC
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncManager.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_internal_objectserver_ObjectServerSession.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_RealmFileUserStore.cpp)
+endif()
+
+# Object Store source files
+file(GLOB objectstore_SRC
+    "object-store/src/*.cpp"
+    "object-store/src/impl/*.cpp"
+    "object-store/src/impl/epoll/*.cpp"
+    "object-store/src/util/*.cpp"
+    "object-store/src/impl/epoll/*.cpp"
+    "object-store/src/util/android/*.cpp")
+
+# Sync needed Object Store files
+if (build_SYNC)
+    file(GLOB objectstore_sync_SRC
+        "object-store/src/sync/*.cpp"
+        "object-store/src/sync/impl/*.cpp")
+endif()
+
+add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC} ${objectstore_sync_SRC})
+add_dependencies(realm-jni jni_headers)
+# -latomic is not set by default for mips. See https://code.google.com/p/android/issues/detail?id=182094
+if (build_SYNC)
+# FIXME: The order matters! lib_realm_sync needs to be in front of lib_realm_core!! Find out why!!
+target_link_libraries(realm-jni log android atomic lib_realm_sync lib_realm_core)
+else()
+target_link_libraries(realm-jni log android atomic lib_realm_core)
+endif()
+
+# Strip the release so files and backup the unstripped versions
+if (CMAKE_BUILD_TYPE STREQUAL "Release")
+    set(unstripped_SO_DIR
+        "${CMAKE_SOURCE_DIR}/../../../build/outputs/jniLibs-unstripped/${REALM_FLAVOR}/${ANDROID_ABI}")
+    add_custom_command(TARGET realm-jni
+        POST_BUILD
+        COMMAND ${CMAKE_COMMAND} -E make_directory ${unstripped_SO_DIR}
+        COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:realm-jni> ${unstripped_SO_DIR}
+        COMMAND ${CMAKE_STRIP} $<TARGET_FILE:realm-jni>)
+endif()
diff --git a/realm/realm-library/src/main/cpp/android.toolchain.cmake b/realm/realm-library/src/main/cpp/android.toolchain.cmake
new file mode 100644
index 0000000000..86046dfa45
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/android.toolchain.cmake
@@ -0,0 +1,1703 @@
+# Copyright (c) 2010-2011, Ethan Rublee
+# Copyright (c) 2011-2014, Andrey Kamaev
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1.  Redistributions of source code must retain the above copyright notice,
+#     this list of conditions and the following disclaimer.
+#
+# 2.  Redistributions in binary form must reproduce the above copyright notice,
+#     this list of conditions and the following disclaimer in the documentation
+#     and/or other materials provided with the distribution.
+#
+# 3.  Neither the name of the copyright holder nor the names of its
+#     contributors may be used to endorse or promote products derived from this
+#     software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+# ------------------------------------------------------------------------------
+#  Android CMake toolchain file, for use with the Android NDK r5-r10d
+#  Requires cmake 2.6.3 or newer (2.8.9 or newer is recommended).
+#  See home page: https://github.com/taka-no-me/android-cmake
+#
+#  Usage Linux:
+#   $ export ANDROID_NDK=/absolute/path/to/the/android-ndk
+#   $ mkdir build && cd build
+#   $ cmake -DCMAKE_TOOLCHAIN_FILE=path/to/the/android.toolchain.cmake ..
+#   $ make -j8
+#
+#  Usage Windows:
+#     You need native port of make to build your project.
+#     Android NDK r7 (and newer) already has make.exe on board.
+#     For older NDK you have to install it separately.
+#     For example, this one: http://gnuwin32.sourceforge.net/packages/make.htm
+#
+#   $ SET ANDROID_NDK=C:\absolute\path\to\the\android-ndk
+#   $ mkdir build && cd build
+#   $ cmake.exe -G"MinGW Makefiles"
+#       -DCMAKE_TOOLCHAIN_FILE=path\to\the\android.toolchain.cmake
+#       -DCMAKE_MAKE_PROGRAM="%ANDROID_NDK%\prebuilt\windows\bin\make.exe" ..
+#   $ cmake.exe --build .
+#
+#
+#  Options (can be set as cmake parameters: -D<option_name>=<value>):
+#    ANDROID_NDK=/opt/android-ndk - path to the NDK root.
+#      Can be set as environment variable. Can be set only at first cmake run.
+#
+#    ANDROID_ABI=armeabi-v7a - specifies the target Application Binary
+#      Interface (ABI). This option nearly matches to the APP_ABI variable
+#      used by ndk-build tool from Android NDK.
+#
+#      Possible targets are:
+#        "armeabi" - ARMv5TE based CPU with software floating point operations
+#        "armeabi-v7a" - ARMv7 based devices with hardware FPU instructions
+#            this ABI target is used by default
+#        "armeabi-v7a with NEON" - same as armeabi-v7a, but
+#            sets NEON as floating-point unit
+#        "armeabi-v7a with VFPV3" - same as armeabi-v7a, but
+#            sets VFPV3 as floating-point unit (has 32 registers instead of 16)
+#        "armeabi-v6 with VFP" - tuned for ARMv6 processors having VFP
+#        "x86" - IA-32 instruction set
+#        "mips" - MIPS32 instruction set
+#
+#      64-bit ABIs for NDK r10 and newer:
+#        "arm64-v8a" - ARMv8 AArch64 instruction set
+#        "x86_64" - Intel64 instruction set (r1)
+#        "mips64" - MIPS64 instruction set (r6)
+#
+#    ANDROID_NATIVE_API_LEVEL=android-9 - level of Android API compile for.
+#      Option is read-only when standalone toolchain is used.
+#      Note: building for "android-L" requires explicit configuration.
+#
+#    ANDROID_TOOLCHAIN_NAME=arm-linux-androideabi-4.9 - the name of compiler
+#      toolchain to be used. The list of possible values depends on the NDK
+#      version. For NDK r10c the possible values are:
+#
+#        * aarch64-linux-android-4.9
+#        * aarch64-linux-android-clang3.4
+#        * aarch64-linux-android-clang3.5
+#        * arm-linux-androideabi-4.6
+#        * arm-linux-androideabi-4.8
+#        * arm-linux-androideabi-4.9 (default)
+#        * arm-linux-androideabi-clang3.4
+#        * arm-linux-androideabi-clang3.5
+#        * mips64el-linux-android-4.9
+#        * mips64el-linux-android-clang3.4
+#        * mips64el-linux-android-clang3.5
+#        * mipsel-linux-android-4.6
+#        * mipsel-linux-android-4.8
+#        * mipsel-linux-android-4.9
+#        * mipsel-linux-android-clang3.4
+#        * mipsel-linux-android-clang3.5
+#        * x86-4.6
+#        * x86-4.8
+#        * x86-4.9
+#        * x86-clang3.4
+#        * x86-clang3.5
+#        * x86_64-4.9
+#        * x86_64-clang3.4
+#        * x86_64-clang3.5
+#
+#    ANDROID_FORCE_ARM_BUILD=OFF - set ON to generate 32-bit ARM instructions
+#      instead of Thumb. Is not available for "armeabi-v6 with VFP"
+#      (is forced to be ON) ABI.
+#
+#    ANDROID_NO_UNDEFINED=ON - set ON to show all undefined symbols as linker
+#      errors even if they are not used.
+#
+#    ANDROID_SO_UNDEFINED=OFF - set ON to allow undefined symbols in shared
+#      libraries. Automatically turned for NDK r5x and r6x due to GLESv2
+#      problems.
+#
+#    ANDROID_STL=gnustl_static - specify the runtime to use.
+#
+#      Possible values are:
+#        none           -> Do not configure the runtime.
+#        system         -> Use the default minimal system C++ runtime library.
+#                          Implies -fno-rtti -fno-exceptions.
+#                          Is not available for standalone toolchain.
+#        system_re      -> Use the default minimal system C++ runtime library.
+#                          Implies -frtti -fexceptions.
+#                          Is not available for standalone toolchain.
+#        gabi++_static  -> Use the GAbi++ runtime as a static library.
+#                          Implies -frtti -fno-exceptions.
+#                          Available for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        gabi++_shared  -> Use the GAbi++ runtime as a shared library.
+#                          Implies -frtti -fno-exceptions.
+#                          Available for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        stlport_static -> Use the STLport runtime as a static library.
+#                          Implies -fno-rtti -fno-exceptions for NDK before r7.
+#                          Implies -frtti -fno-exceptions for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        stlport_shared -> Use the STLport runtime as a shared library.
+#                          Implies -fno-rtti -fno-exceptions for NDK before r7.
+#                          Implies -frtti -fno-exceptions for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        gnustl_static  -> Use the GNU STL as a static library.
+#                          Implies -frtti -fexceptions.
+#        gnustl_shared  -> Use the GNU STL as a shared library.
+#                          Implies -frtti -fno-exceptions.
+#                          Available for NDK r7b and newer.
+#                          Silently degrades to gnustl_static if not available.
+#
+#    ANDROID_STL_FORCE_FEATURES=ON - turn rtti and exceptions support based on
+#      chosen runtime. If disabled, then the user is responsible for settings
+#      these options.
+#
+#  What?:
+#    android-cmake toolchain searches for NDK/toolchain in the following order:
+#      ANDROID_NDK - cmake parameter
+#      ANDROID_NDK - environment variable
+#      ANDROID_STANDALONE_TOOLCHAIN - cmake parameter
+#      ANDROID_STANDALONE_TOOLCHAIN - environment variable
+#      ANDROID_NDK - default locations
+#      ANDROID_STANDALONE_TOOLCHAIN - default locations
+#
+#    Make sure to do the following in your scripts:
+#      SET( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${my_cxx_flags}" )
+#      SET( CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${my_cxx_flags}" )
+#    The flags will be prepopulated with critical flags, so don't loose them.
+#    Also be aware that toolchain also sets configuration-specific compiler
+#    flags and linker flags.
+#
+#    ANDROID and BUILD_ANDROID will be set to true, you may test any of these
+#    variables to make necessary Android-specific configuration changes.
+#
+#    Also ARMEABI or ARMEABI_V7A or X86 or MIPS or ARM64_V8A or X86_64 or MIPS64
+#    will be set true, mutually exclusive. NEON option will be set true
+#    if VFP is set to NEON.
+#
+# ------------------------------------------------------------------------------
+
+# FIXME:
+# This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
+# because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
+# JNI build currently (lack of lto linking support.). Two modifications are made to avoid warnings
+# with CMake 3.6 -- disable CMAKE_FORCE_CXX_COMPILER & CMAKE_FORCE_C_COMPILER.
+# This file should be removed and use the one from Android SDK cmake package when it supports lto.
+
+cmake_minimum_required( VERSION 2.6.3 )
+
+if( DEFINED CMAKE_CROSSCOMPILING )
+ # subsequent toolchain loading is not really needed
+ return()
+endif()
+
+if( CMAKE_TOOLCHAIN_FILE )
+ # touch toolchain variable to suppress "unused variable" warning
+endif()
+
+# inherit settings in recursive loads
+get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
+if( _CMAKE_IN_TRY_COMPILE )
+ include( "${CMAKE_CURRENT_SOURCE_DIR}/../android.toolchain.config.cmake" OPTIONAL )
+endif()
+
+# this one is important
+if( CMAKE_VERSION VERSION_GREATER "3.0.99" )
+ set( CMAKE_SYSTEM_NAME Android )
+else()
+ set( CMAKE_SYSTEM_NAME Linux )
+endif()
+
+# this one not so much
+set( CMAKE_SYSTEM_VERSION 1 )
+
+# rpath makes low sense for Android
+set( CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG "" )
+set( CMAKE_SKIP_RPATH TRUE CACHE BOOL "If set, runtime paths are not added when using shared libraries." )
+
+# NDK search paths
+set( ANDROID_SUPPORTED_NDK_VERSIONS ${ANDROID_EXTRA_NDK_VERSIONS} -r10d -r10c -r10b -r10 -r9d -r9c -r9b -r9 -r8e -r8d -r8c -r8b -r8 -r7c -r7b -r7 -r6b -r6 -r5c -r5b -r5 "" )
+if( NOT DEFINED ANDROID_NDK_SEARCH_PATHS )
+ if( CMAKE_HOST_WIN32 )
+  file( TO_CMAKE_PATH "$ENV{PROGRAMFILES}" ANDROID_NDK_SEARCH_PATHS )
+  set( ANDROID_NDK_SEARCH_PATHS "${ANDROID_NDK_SEARCH_PATHS}" "$ENV{SystemDrive}/NVPACK" )
+ else()
+  file( TO_CMAKE_PATH "$ENV{HOME}" ANDROID_NDK_SEARCH_PATHS )
+  set( ANDROID_NDK_SEARCH_PATHS /opt "${ANDROID_NDK_SEARCH_PATHS}/NVPACK" )
+ endif()
+endif()
+if( NOT DEFINED ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH )
+ set( ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH /opt/android-toolchain )
+endif()
+
+# known ABIs
+set( ANDROID_SUPPORTED_ABIS_arm "armeabi-v7a;armeabi;armeabi-v7a with NEON;armeabi-v7a with VFPV3;armeabi-v6 with VFP" )
+set( ANDROID_SUPPORTED_ABIS_arm64 "arm64-v8a" )
+set( ANDROID_SUPPORTED_ABIS_x86 "x86" )
+set( ANDROID_SUPPORTED_ABIS_x86_64 "x86_64" )
+set( ANDROID_SUPPORTED_ABIS_mips "mips" )
+set( ANDROID_SUPPORTED_ABIS_mips64 "mips64" )
+
+# API level defaults
+set( ANDROID_DEFAULT_NDK_API_LEVEL 9 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_arm64 21 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_x86 9 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_x86_64 21 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_mips 9 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_mips64 21 )
+
+
+macro( __LIST_FILTER listvar regex )
+  if( ${listvar} )
+    foreach( __val ${${listvar}} )
+      if( __val MATCHES "${regex}" )
+        list( REMOVE_ITEM ${listvar} "${__val}" )
+      endif()
+    endforeach()
+  endif()
+endmacro()
+
+macro( __INIT_VARIABLE var_name )
+  set( __test_path 0 )
+  foreach( __var ${ARGN} )
+    if( __var STREQUAL "PATH" )
+      set( __test_path 1 )
+      break()
+    endif()
+  endforeach()
+
+  if( __test_path AND NOT EXISTS "${${var_name}}" )
+    unset( ${var_name} CACHE )
+  endif()
+
+  if( " ${${var_name}}" STREQUAL " " )
+    set( __values 0 )
+    foreach( __var ${ARGN} )
+      if( __var STREQUAL "VALUES" )
+        set( __values 1 )
+      elseif( NOT __var STREQUAL "PATH" )
+        if( __var MATCHES "^ENV_.*$" )
+          string( REPLACE "ENV_" "" __var "${__var}" )
+          set( __value "$ENV{${__var}}" )
+        elseif( DEFINED ${__var} )
+          set( __value "${${__var}}" )
+        elseif( __values )
+          set( __value "${__var}" )
+        else()
+          set( __value "" )
+        endif()
+
+        if( NOT " ${__value}" STREQUAL " " AND (NOT __test_path OR EXISTS "${__value}") )
+          set( ${var_name} "${__value}" )
+          break()
+        endif()
+      endif()
+    endforeach()
+    unset( __value )
+    unset( __values )
+  endif()
+
+  if( __test_path )
+    file( TO_CMAKE_PATH "${${var_name}}" ${var_name} )
+  endif()
+  unset( __test_path )
+endmacro()
+
+macro( __DETECT_NATIVE_API_LEVEL _var _path )
+  set( __ndkApiLevelRegex "^[\t ]*#define[\t ]+__ANDROID_API__[\t ]+([0-9]+)[\t ]*.*$" )
+  file( STRINGS ${_path} __apiFileContent REGEX "${__ndkApiLevelRegex}" )
+  if( NOT __apiFileContent )
+    message( SEND_ERROR "Could not get Android native API level. Probably you have specified invalid level value, or your copy of NDK/toolchain is broken." )
+  endif()
+  string( REGEX REPLACE "${__ndkApiLevelRegex}" "\\1" ${_var} "${__apiFileContent}" )
+  unset( __apiFileContent )
+  unset( __ndkApiLevelRegex )
+endmacro()
+
+macro( __DETECT_TOOLCHAIN_MACHINE_NAME _var _root )
+ if( EXISTS "${_root}" )
+    file( GLOB __gccExePath RELATIVE "${_root}/bin/" "${_root}/bin/*-gcc${TOOL_OS_SUFFIX}" )
+    __LIST_FILTER( __gccExePath "^[.].*" )
+    list( LENGTH __gccExePath __gccExePathsCount )
+    if( NOT __gccExePathsCount EQUAL 1  AND NOT _CMAKE_IN_TRY_COMPILE )
+      message( WARNING "Could not determine machine name for compiler from ${_root}" )
+      set( ${_var} "" )
+    else()
+      get_filename_component( __gccExeName "${__gccExePath}" NAME_WE )
+      string( REPLACE "-gcc" "" ${_var} "${__gccExeName}" )
+    endif()
+    unset( __gccExePath )
+    unset( __gccExePathsCount )
+    unset( __gccExeName )
+  else()
+    set( ${_var} "" )
+  endif()
+endmacro()
+
+
+# fight against cygwin
+set( ANDROID_FORBID_SYGWIN TRUE CACHE BOOL "Prevent cmake from working under cygwin and using cygwin tools")
+mark_as_advanced( ANDROID_FORBID_SYGWIN )
+if( ANDROID_FORBID_SYGWIN )
+ if( CYGWIN )
+  message( FATAL_ERROR "Android NDK and android-cmake toolchain are not welcome Cygwin. It is unlikely that this cmake toolchain will work under cygwin. But if you want to try then you can set cmake variable ANDROID_FORBID_SYGWIN to FALSE and rerun cmake." )
+ endif()
+
+ if( CMAKE_HOST_WIN32 )
+  # remove cygwin from PATH
+  set( __new_path "$ENV{PATH}")
+  __LIST_FILTER( __new_path "cygwin" )
+  set(ENV{PATH} "${__new_path}")
+  unset(__new_path)
+ endif()
+endif()
+
+
+# detect current host platform
+if( NOT DEFINED ANDROID_NDK_HOST_X64 AND (CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "amd64|x86_64|AMD64" OR CMAKE_HOST_APPLE) )
+ set( ANDROID_NDK_HOST_X64 1 CACHE BOOL "Try to use 64-bit compiler toolchain" )
+ mark_as_advanced( ANDROID_NDK_HOST_X64 )
+endif()
+
+set( TOOL_OS_SUFFIX "" )
+if( CMAKE_HOST_APPLE )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME "darwin-x86_64" )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME2 "darwin-x86" )
+elseif( CMAKE_HOST_WIN32 )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME "windows-x86_64" )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME2 "windows" )
+ set( TOOL_OS_SUFFIX ".exe" )
+elseif( CMAKE_HOST_UNIX )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME "linux-x86_64" )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME2 "linux-x86" )
+else()
+ message( FATAL_ERROR "Cross-compilation on your platform is not supported by this cmake toolchain" )
+endif()
+
+if( NOT ANDROID_NDK_HOST_X64 )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME ${ANDROID_NDK_HOST_SYSTEM_NAME2} )
+endif()
+
+# see if we have path to Android NDK
+if( NOT ANDROID_NDK AND NOT ANDROID_STANDALONE_TOOLCHAIN )
+  __INIT_VARIABLE( ANDROID_NDK PATH ENV_ANDROID_NDK )
+endif()
+if( NOT ANDROID_NDK )
+ # see if we have path to Android standalone toolchain
+ __INIT_VARIABLE( ANDROID_STANDALONE_TOOLCHAIN PATH ENV_ANDROID_STANDALONE_TOOLCHAIN )
+
+ if( NOT ANDROID_STANDALONE_TOOLCHAIN )
+  #try to find Android NDK in one of the the default locations
+  set( __ndkSearchPaths )
+  foreach( __ndkSearchPath ${ANDROID_NDK_SEARCH_PATHS} )
+   foreach( suffix ${ANDROID_SUPPORTED_NDK_VERSIONS} )
+    list( APPEND __ndkSearchPaths "${__ndkSearchPath}/android-ndk${suffix}" )
+   endforeach()
+  endforeach()
+  __INIT_VARIABLE( ANDROID_NDK PATH VALUES ${__ndkSearchPaths} )
+  unset( __ndkSearchPaths )
+
+  if( ANDROID_NDK )
+   message( STATUS "Using default path for Android NDK: ${ANDROID_NDK}" )
+   message( STATUS "  If you prefer to use a different location, please define a cmake or environment variable: ANDROID_NDK" )
+  else()
+   #try to find Android standalone toolchain in one of the the default locations
+   __INIT_VARIABLE( ANDROID_STANDALONE_TOOLCHAIN PATH ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH )
+
+   if( ANDROID_STANDALONE_TOOLCHAIN )
+    message( STATUS "Using default path for standalone toolchain ${ANDROID_STANDALONE_TOOLCHAIN}" )
+    message( STATUS "  If you prefer to use a different location, please define the variable: ANDROID_STANDALONE_TOOLCHAIN" )
+   endif( ANDROID_STANDALONE_TOOLCHAIN )
+  endif( ANDROID_NDK )
+ endif( NOT ANDROID_STANDALONE_TOOLCHAIN )
+endif( NOT ANDROID_NDK )
+
+# remember found paths
+if( ANDROID_NDK )
+ get_filename_component( ANDROID_NDK "${ANDROID_NDK}" ABSOLUTE )
+ set( ANDROID_NDK "${ANDROID_NDK}" CACHE INTERNAL "Path of the Android NDK" FORCE )
+ set( BUILD_WITH_ANDROID_NDK True )
+ if( EXISTS "${ANDROID_NDK}/RELEASE.TXT" )
+  file( STRINGS "${ANDROID_NDK}/RELEASE.TXT" ANDROID_NDK_RELEASE_FULL LIMIT_COUNT 1 REGEX "r[0-9]+[a-z]?" )
+  string( REGEX MATCH "r([0-9]+)([a-z]?)" ANDROID_NDK_RELEASE "${ANDROID_NDK_RELEASE_FULL}" )
+ else()
+  set( ANDROID_NDK_RELEASE "r1x" )
+  set( ANDROID_NDK_RELEASE_FULL "unreleased" )
+ endif()
+ string( REGEX REPLACE "r([0-9]+)([a-z]?)" "\\1*1000" ANDROID_NDK_RELEASE_NUM "${ANDROID_NDK_RELEASE}" )
+ string( FIND " abcdefghijklmnopqastuvwxyz" "${CMAKE_MATCH_2}" __ndkReleaseLetterNum )
+ math( EXPR ANDROID_NDK_RELEASE_NUM "${ANDROID_NDK_RELEASE_NUM}+${__ndkReleaseLetterNum}" )
+elseif( ANDROID_STANDALONE_TOOLCHAIN )
+ get_filename_component( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" ABSOLUTE )
+ # try to detect change
+ if( CMAKE_AR )
+  string( LENGTH "${ANDROID_STANDALONE_TOOLCHAIN}" __length )
+  string( SUBSTRING "${CMAKE_AR}" 0 ${__length} __androidStandaloneToolchainPreviousPath )
+  if( NOT __androidStandaloneToolchainPreviousPath STREQUAL ANDROID_STANDALONE_TOOLCHAIN )
+   message( FATAL_ERROR "It is not possible to change path to the Android standalone toolchain on subsequent run." )
+  endif()
+  unset( __androidStandaloneToolchainPreviousPath )
+  unset( __length )
+ endif()
+ set( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" CACHE INTERNAL "Path of the Android standalone toolchain" FORCE )
+ set( BUILD_WITH_STANDALONE_TOOLCHAIN True )
+else()
+ list(GET ANDROID_NDK_SEARCH_PATHS 0 ANDROID_NDK_SEARCH_PATH)
+ message( FATAL_ERROR "Could not find neither Android NDK nor Android standalone toolchain.
+    You should either set an environment variable:
+      export ANDROID_NDK=~/my-android-ndk
+    or
+      export ANDROID_STANDALONE_TOOLCHAIN=~/my-android-toolchain
+    or put the toolchain or NDK in the default path:
+      sudo ln -s ~/my-android-ndk ${ANDROID_NDK_SEARCH_PATH}/android-ndk
+      sudo ln -s ~/my-android-toolchain ${ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH}" )
+endif()
+
+# android NDK layout
+if( BUILD_WITH_ANDROID_NDK )
+ if( NOT DEFINED ANDROID_NDK_LAYOUT )
+  # try to automatically detect the layout
+  if( EXISTS "${ANDROID_NDK}/RELEASE.TXT")
+   set( ANDROID_NDK_LAYOUT "RELEASE" )
+  elseif( EXISTS "${ANDROID_NDK}/../../linux-x86/toolchain/" )
+   set( ANDROID_NDK_LAYOUT "LINARO" )
+  elseif( EXISTS "${ANDROID_NDK}/../../gcc/" )
+   set( ANDROID_NDK_LAYOUT "ANDROID" )
+  endif()
+ endif()
+ set( ANDROID_NDK_LAYOUT "${ANDROID_NDK_LAYOUT}" CACHE STRING "The inner layout of NDK" )
+ mark_as_advanced( ANDROID_NDK_LAYOUT )
+ if( ANDROID_NDK_LAYOUT STREQUAL "LINARO" )
+  set( ANDROID_NDK_HOST_SYSTEM_NAME ${ANDROID_NDK_HOST_SYSTEM_NAME2} ) # only 32-bit at the moment
+  set( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK}/../../${ANDROID_NDK_HOST_SYSTEM_NAME}/toolchain" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH  "" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH2 "" )
+ elseif( ANDROID_NDK_LAYOUT STREQUAL "ANDROID" )
+  set( ANDROID_NDK_HOST_SYSTEM_NAME ${ANDROID_NDK_HOST_SYSTEM_NAME2} ) # only 32-bit at the moment
+  set( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK}/../../gcc/${ANDROID_NDK_HOST_SYSTEM_NAME}/arm" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH  "" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH2 "" )
+ else() # ANDROID_NDK_LAYOUT STREQUAL "RELEASE"
+  set( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK}/toolchains" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH  "/prebuilt/${ANDROID_NDK_HOST_SYSTEM_NAME}" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH2 "/prebuilt/${ANDROID_NDK_HOST_SYSTEM_NAME2}" )
+ endif()
+ get_filename_component( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK_TOOLCHAINS_PATH}" ABSOLUTE )
+
+ # try to detect change of NDK
+ if( CMAKE_AR )
+  string( LENGTH "${ANDROID_NDK_TOOLCHAINS_PATH}" __length )
+  string( SUBSTRING "${CMAKE_AR}" 0 ${__length} __androidNdkPreviousPath )
+  if( NOT __androidNdkPreviousPath STREQUAL ANDROID_NDK_TOOLCHAINS_PATH )
+   message( FATAL_ERROR "It is not possible to change the path to the NDK on subsequent CMake run. You must remove all generated files from your build folder first.
+   " )
+  endif()
+  unset( __androidNdkPreviousPath )
+  unset( __length )
+ endif()
+endif()
+
+
+# get all the details about standalone toolchain
+if( BUILD_WITH_STANDALONE_TOOLCHAIN )
+ __DETECT_NATIVE_API_LEVEL( ANDROID_SUPPORTED_NATIVE_API_LEVELS "${ANDROID_STANDALONE_TOOLCHAIN}/sysroot/usr/include/android/api-level.h" )
+ set( ANDROID_STANDALONE_TOOLCHAIN_API_LEVEL ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
+ set( __availableToolchains "standalone" )
+ __DETECT_TOOLCHAIN_MACHINE_NAME( __availableToolchainMachines "${ANDROID_STANDALONE_TOOLCHAIN}" )
+ if( NOT __availableToolchainMachines )
+  message( FATAL_ERROR "Could not determine machine name of your toolchain. Probably your Android standalone toolchain is broken." )
+ endif()
+ if( __availableToolchainMachines MATCHES x86_64 )
+  set( __availableToolchainArchs "x86_64" )
+ elseif( __availableToolchainMachines MATCHES i686 )
+  set( __availableToolchainArchs "x86" )
+ elseif( __availableToolchainMachines MATCHES aarch64 )
+  set( __availableToolchainArchs "arm64" )
+ elseif( __availableToolchainMachines MATCHES arm )
+  set( __availableToolchainArchs "arm" )
+ elseif( __availableToolchainMachines MATCHES mips64el )
+  set( __availableToolchainArchs "mips64" )
+ elseif( __availableToolchainMachines MATCHES mipsel )
+  set( __availableToolchainArchs "mips" )
+ endif()
+ execute_process( COMMAND "${ANDROID_STANDALONE_TOOLCHAIN}/bin/${__availableToolchainMachines}-gcc${TOOL_OS_SUFFIX}" -dumpversion
+                  OUTPUT_VARIABLE __availableToolchainCompilerVersions OUTPUT_STRIP_TRAILING_WHITESPACE )
+ string( REGEX MATCH "[0-9]+[.][0-9]+([.][0-9]+)?" __availableToolchainCompilerVersions "${__availableToolchainCompilerVersions}" )
+ if( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/bin/clang${TOOL_OS_SUFFIX}" )
+  list( APPEND __availableToolchains "standalone-clang" )
+  list( APPEND __availableToolchainMachines ${__availableToolchainMachines} )
+  list( APPEND __availableToolchainArchs ${__availableToolchainArchs} )
+  list( APPEND __availableToolchainCompilerVersions ${__availableToolchainCompilerVersions} )
+ endif()
+endif()
+
+macro( __GLOB_NDK_TOOLCHAINS __availableToolchainsVar __availableToolchainsLst __toolchain_subpath )
+ foreach( __toolchain ${${__availableToolchainsLst}} )
+  if( "${__toolchain}" MATCHES "-clang3[.][0-9]$" AND NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/${__toolchain}${__toolchain_subpath}" )
+   SET( __toolchainVersionRegex "^TOOLCHAIN_VERSION[\t ]+:=[\t ]+(.*)$" )
+   FILE( STRINGS "${ANDROID_NDK_TOOLCHAINS_PATH}/${__toolchain}/setup.mk" __toolchainVersionStr REGEX "${__toolchainVersionRegex}" )
+   if( __toolchainVersionStr )
+    string( REGEX REPLACE "${__toolchainVersionRegex}" "\\1" __toolchainVersionStr "${__toolchainVersionStr}" )
+    string( REGEX REPLACE "-clang3[.][0-9]$" "-${__toolchainVersionStr}" __gcc_toolchain "${__toolchain}" )
+   else()
+    string( REGEX REPLACE "-clang3[.][0-9]$" "-4.6" __gcc_toolchain "${__toolchain}" )
+   endif()
+   unset( __toolchainVersionStr )
+   unset( __toolchainVersionRegex )
+  else()
+   set( __gcc_toolchain "${__toolchain}" )
+  endif()
+  __DETECT_TOOLCHAIN_MACHINE_NAME( __machine "${ANDROID_NDK_TOOLCHAINS_PATH}/${__gcc_toolchain}${__toolchain_subpath}" )
+  if( __machine )
+   string( REGEX MATCH "[0-9]+[.][0-9]+([.][0-9x]+)?$" __version "${__gcc_toolchain}" )
+   if( __machine MATCHES x86_64 )
+    set( __arch "x86_64" )
+   elseif( __machine MATCHES i686 )
+    set( __arch "x86" )
+   elseif( __machine MATCHES aarch64 )
+    set( __arch "arm64" )
+   elseif( __machine MATCHES arm )
+    set( __arch "arm" )
+   elseif( __machine MATCHES mips64el )
+    set( __arch "mips64" )
+   elseif( __machine MATCHES mipsel )
+    set( __arch "mips" )
+   else()
+    set( __arch "" )
+   endif()
+   #message("machine: !${__machine}!\narch: !${__arch}!\nversion: !${__version}!\ntoolchain: !${__toolchain}!\n")
+   if (__arch)
+    list( APPEND __availableToolchainMachines "${__machine}" )
+    list( APPEND __availableToolchainArchs "${__arch}" )
+    list( APPEND __availableToolchainCompilerVersions "${__version}" )
+    list( APPEND ${__availableToolchainsVar} "${__toolchain}" )
+   endif()
+  endif()
+  unset( __gcc_toolchain )
+ endforeach()
+endmacro()
+
+# get all the details about NDK
+if( BUILD_WITH_ANDROID_NDK )
+ file( GLOB ANDROID_SUPPORTED_NATIVE_API_LEVELS RELATIVE "${ANDROID_NDK}/platforms" "${ANDROID_NDK}/platforms/android-*" )
+ string( REPLACE "android-" "" ANDROID_SUPPORTED_NATIVE_API_LEVELS "${ANDROID_SUPPORTED_NATIVE_API_LEVELS}" )
+ set( __availableToolchains "" )
+ set( __availableToolchainMachines "" )
+ set( __availableToolchainArchs "" )
+ set( __availableToolchainCompilerVersions "" )
+ if( ANDROID_TOOLCHAIN_NAME AND EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_TOOLCHAIN_NAME}/" )
+  # do not go through all toolchains if we know the name
+  set( __availableToolchainsLst "${ANDROID_TOOLCHAIN_NAME}" )
+  __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+  if( NOT __availableToolchains AND NOT ANDROID_NDK_TOOLCHAINS_SUBPATH STREQUAL ANDROID_NDK_TOOLCHAINS_SUBPATH2 )
+   __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH2}" )
+   if( __availableToolchains )
+    set( ANDROID_NDK_TOOLCHAINS_SUBPATH ${ANDROID_NDK_TOOLCHAINS_SUBPATH2} )
+   endif()
+  endif()
+ endif()
+ if( NOT __availableToolchains )
+  file( GLOB __availableToolchainsLst RELATIVE "${ANDROID_NDK_TOOLCHAINS_PATH}" "${ANDROID_NDK_TOOLCHAINS_PATH}/*" )
+  if( __availableToolchainsLst )
+   list(SORT __availableToolchainsLst) # we need clang to go after gcc
+  endif()
+  __LIST_FILTER( __availableToolchainsLst "^[.]" )
+  __LIST_FILTER( __availableToolchainsLst "llvm" )
+  __LIST_FILTER( __availableToolchainsLst "renderscript" )
+  __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+  if( NOT __availableToolchains AND NOT ANDROID_NDK_TOOLCHAINS_SUBPATH STREQUAL ANDROID_NDK_TOOLCHAINS_SUBPATH2 )
+   __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH2}" )
+   if( __availableToolchains )
+    set( ANDROID_NDK_TOOLCHAINS_SUBPATH ${ANDROID_NDK_TOOLCHAINS_SUBPATH2} )
+   endif()
+  endif()
+ endif()
+ if( NOT __availableToolchains )
+  message( FATAL_ERROR "Could not find any working toolchain in the NDK. Probably your Android NDK is broken." )
+ endif()
+endif()
+
+# build list of available ABIs
+set( ANDROID_SUPPORTED_ABIS "" )
+set( __uniqToolchainArchNames ${__availableToolchainArchs} )
+list( REMOVE_DUPLICATES __uniqToolchainArchNames )
+list( SORT __uniqToolchainArchNames )
+foreach( __arch ${__uniqToolchainArchNames} )
+ list( APPEND ANDROID_SUPPORTED_ABIS ${ANDROID_SUPPORTED_ABIS_${__arch}} )
+endforeach()
+unset( __uniqToolchainArchNames )
+if( NOT ANDROID_SUPPORTED_ABIS )
+ message( FATAL_ERROR "No one of known Android ABIs is supported by this cmake toolchain." )
+endif()
+
+# choose target ABI
+__INIT_VARIABLE( ANDROID_ABI VALUES ${ANDROID_SUPPORTED_ABIS} )
+# verify that target ABI is supported
+list( FIND ANDROID_SUPPORTED_ABIS "${ANDROID_ABI}" __androidAbiIdx )
+if( __androidAbiIdx EQUAL -1 )
+ string( REPLACE ";" "\", \"" PRINTABLE_ANDROID_SUPPORTED_ABIS  "${ANDROID_SUPPORTED_ABIS}" )
+ message( FATAL_ERROR "Specified ANDROID_ABI = \"${ANDROID_ABI}\" is not supported by this cmake toolchain or your NDK/toolchain.
+   Supported values are: \"${PRINTABLE_ANDROID_SUPPORTED_ABIS}\"
+   " )
+endif()
+unset( __androidAbiIdx )
+
+# set target ABI options
+if( ANDROID_ABI STREQUAL "x86" )
+ set( X86 true )
+ set( ANDROID_NDK_ABI_NAME "x86" )
+ set( ANDROID_ARCH_NAME "x86" )
+ set( ANDROID_LLVM_TRIPLE "i686-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "i686" )
+elseif( ANDROID_ABI STREQUAL "x86_64" )
+ set( X86 true )
+ set( X86_64 true )
+ set( ANDROID_NDK_ABI_NAME "x86_64" )
+ set( ANDROID_ARCH_NAME "x86_64" )
+ set( CMAKE_SYSTEM_PROCESSOR "x86_64" )
+ set( ANDROID_LLVM_TRIPLE "x86_64-none-linux-android" )
+elseif( ANDROID_ABI STREQUAL "mips64" )
+ set( MIPS64 true )
+ set( ANDROID_NDK_ABI_NAME "mips64" )
+ set( ANDROID_ARCH_NAME "mips64" )
+ set( ANDROID_LLVM_TRIPLE "mips64el-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "mips64" )
+elseif( ANDROID_ABI STREQUAL "mips" )
+ set( MIPS true )
+ set( ANDROID_NDK_ABI_NAME "mips" )
+ set( ANDROID_ARCH_NAME "mips" )
+ set( ANDROID_LLVM_TRIPLE "mipsel-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "mips" )
+elseif( ANDROID_ABI STREQUAL "arm64-v8a" )
+ set( ARM64_V8A true )
+ set( ANDROID_NDK_ABI_NAME "arm64-v8a" )
+ set( ANDROID_ARCH_NAME "arm64" )
+ set( ANDROID_LLVM_TRIPLE "aarch64-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "aarch64" )
+ set( VFPV3 true )
+ set( NEON true )
+elseif( ANDROID_ABI STREQUAL "armeabi" )
+ set( ARMEABI true )
+ set( ANDROID_NDK_ABI_NAME "armeabi" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv5te-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv5te" )
+elseif( ANDROID_ABI STREQUAL "armeabi-v6 with VFP" )
+ set( ARMEABI_V6 true )
+ set( ANDROID_NDK_ABI_NAME "armeabi" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv5te-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv6" )
+ # need always fallback to older platform
+ set( ARMEABI true )
+elseif( ANDROID_ABI STREQUAL "armeabi-v7a")
+ set( ARMEABI_V7A true )
+ set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
+elseif( ANDROID_ABI STREQUAL "armeabi-v7a with VFPV3" )
+ set( ARMEABI_V7A true )
+ set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
+ set( VFPV3 true )
+elseif( ANDROID_ABI STREQUAL "armeabi-v7a with NEON" )
+ set( ARMEABI_V7A true )
+ set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
+ set( VFPV3 true )
+ set( NEON true )
+else()
+ message( SEND_ERROR "Unknown ANDROID_ABI=\"${ANDROID_ABI}\" is specified." )
+endif()
+
+if( CMAKE_BINARY_DIR AND EXISTS "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeSystem.cmake" )
+ # really dirty hack
+ # it is not possible to change CMAKE_SYSTEM_PROCESSOR after the first run...
+ file( APPEND "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeSystem.cmake" "SET(CMAKE_SYSTEM_PROCESSOR \"${CMAKE_SYSTEM_PROCESSOR}\")\n" )
+endif()
+
+if( ANDROID_ARCH_NAME STREQUAL "arm" AND NOT ARMEABI_V6 )
+ __INIT_VARIABLE( ANDROID_FORCE_ARM_BUILD VALUES OFF )
+ set( ANDROID_FORCE_ARM_BUILD ${ANDROID_FORCE_ARM_BUILD} CACHE BOOL "Use 32-bit ARM instructions instead of Thumb-1" FORCE )
+ mark_as_advanced( ANDROID_FORCE_ARM_BUILD )
+else()
+ unset( ANDROID_FORCE_ARM_BUILD CACHE )
+endif()
+
+# choose toolchain
+if( ANDROID_TOOLCHAIN_NAME )
+ list( FIND __availableToolchains "${ANDROID_TOOLCHAIN_NAME}" __toolchainIdx )
+ if( __toolchainIdx EQUAL -1 )
+  list( SORT __availableToolchains )
+  string( REPLACE ";" "\n  * " toolchains_list "${__availableToolchains}" )
+  set( toolchains_list "  * ${toolchains_list}")
+  message( FATAL_ERROR "Specified toolchain \"${ANDROID_TOOLCHAIN_NAME}\" is missing in your NDK or broken. Please verify that your NDK is working or select another compiler toolchain.
+To configure the toolchain set CMake variable ANDROID_TOOLCHAIN_NAME to one of the following values:\n${toolchains_list}\n" )
+ endif()
+ list( GET __availableToolchainArchs ${__toolchainIdx} __toolchainArch )
+ if( NOT __toolchainArch STREQUAL ANDROID_ARCH_NAME )
+  message( SEND_ERROR "Selected toolchain \"${ANDROID_TOOLCHAIN_NAME}\" is not able to compile binaries for the \"${ANDROID_ARCH_NAME}\" platform." )
+ endif()
+else()
+ set( __toolchainIdx -1 )
+ set( __applicableToolchains "" )
+ set( __toolchainMaxVersion "0.0.0" )
+ list( LENGTH __availableToolchains __availableToolchainsCount )
+ math( EXPR __availableToolchainsCount "${__availableToolchainsCount}-1" )
+ foreach( __idx RANGE ${__availableToolchainsCount} )
+  list( GET __availableToolchainArchs ${__idx} __toolchainArch )
+  if( __toolchainArch STREQUAL ANDROID_ARCH_NAME )
+   list( GET __availableToolchainCompilerVersions ${__idx} __toolchainVersion )
+   string( REPLACE "x" "99" __toolchainVersion "${__toolchainVersion}")
+   if( __toolchainVersion VERSION_GREATER __toolchainMaxVersion )
+    set( __toolchainMaxVersion "${__toolchainVersion}" )
+    set( __toolchainIdx ${__idx} )
+   endif()
+  endif()
+ endforeach()
+ unset( __availableToolchainsCount )
+ unset( __toolchainMaxVersion )
+ unset( __toolchainVersion )
+endif()
+unset( __toolchainArch )
+if( __toolchainIdx EQUAL -1 )
+ message( FATAL_ERROR "No one of available compiler toolchains is able to compile for ${ANDROID_ARCH_NAME} platform." )
+endif()
+list( GET __availableToolchains ${__toolchainIdx} ANDROID_TOOLCHAIN_NAME )
+list( GET __availableToolchainMachines ${__toolchainIdx} ANDROID_TOOLCHAIN_MACHINE_NAME )
+list( GET __availableToolchainCompilerVersions ${__toolchainIdx} ANDROID_COMPILER_VERSION )
+
+unset( __toolchainIdx )
+unset( __availableToolchains )
+unset( __availableToolchainMachines )
+unset( __availableToolchainArchs )
+unset( __availableToolchainCompilerVersions )
+
+# choose native API level
+__INIT_VARIABLE( ANDROID_NATIVE_API_LEVEL ENV_ANDROID_NATIVE_API_LEVEL ANDROID_API_LEVEL ENV_ANDROID_API_LEVEL ANDROID_STANDALONE_TOOLCHAIN_API_LEVEL ANDROID_DEFAULT_NDK_API_LEVEL_${ANDROID_ARCH_NAME} ANDROID_DEFAULT_NDK_API_LEVEL )
+string( REPLACE "android-" "" ANDROID_NATIVE_API_LEVEL "${ANDROID_NATIVE_API_LEVEL}" )
+string( STRIP "${ANDROID_NATIVE_API_LEVEL}" ANDROID_NATIVE_API_LEVEL )
+# adjust API level
+set( __real_api_level ${ANDROID_DEFAULT_NDK_API_LEVEL_${ANDROID_ARCH_NAME}} )
+foreach( __level ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
+ if( (__level LESS ANDROID_NATIVE_API_LEVEL OR __level STREQUAL ANDROID_NATIVE_API_LEVEL) AND NOT __level LESS __real_api_level )
+  set( __real_api_level ${__level} )
+ endif()
+endforeach()
+if( __real_api_level AND NOT ANDROID_NATIVE_API_LEVEL STREQUAL __real_api_level )
+ message( STATUS "Adjusting Android API level 'android-${ANDROID_NATIVE_API_LEVEL}' to 'android-${__real_api_level}'")
+ set( ANDROID_NATIVE_API_LEVEL ${__real_api_level} )
+endif()
+unset(__real_api_level)
+# validate
+list( FIND ANDROID_SUPPORTED_NATIVE_API_LEVELS "${ANDROID_NATIVE_API_LEVEL}" __levelIdx )
+if( __levelIdx EQUAL -1 )
+ message( SEND_ERROR "Specified Android native API level 'android-${ANDROID_NATIVE_API_LEVEL}' is not supported by your NDK/toolchain." )
+else()
+ if( BUILD_WITH_ANDROID_NDK )
+  __DETECT_NATIVE_API_LEVEL( __realApiLevel "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}/usr/include/android/api-level.h" )
+  if( NOT __realApiLevel EQUAL ANDROID_NATIVE_API_LEVEL AND NOT __realApiLevel GREATER 9000 )
+   message( SEND_ERROR "Specified Android API level (${ANDROID_NATIVE_API_LEVEL}) does not match to the level found (${__realApiLevel}). Probably your copy of NDK is broken." )
+  endif()
+  unset( __realApiLevel )
+ endif()
+ set( ANDROID_NATIVE_API_LEVEL "${ANDROID_NATIVE_API_LEVEL}" CACHE STRING "Android API level for native code" FORCE )
+ set( CMAKE_ANDROID_API ${ANDROID_NATIVE_API_LEVEL} )
+ if( CMAKE_VERSION VERSION_GREATER "2.8" )
+  list( SORT ANDROID_SUPPORTED_NATIVE_API_LEVELS )
+  set_property( CACHE ANDROID_NATIVE_API_LEVEL PROPERTY STRINGS ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
+ endif()
+endif()
+unset( __levelIdx )
+
+
+# remember target ABI
+set( ANDROID_ABI "${ANDROID_ABI}" CACHE STRING "The target ABI for Android. If arm, then armeabi-v7a is recommended for hardware floating point." FORCE )
+if( CMAKE_VERSION VERSION_GREATER "2.8" )
+ list( SORT ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_NAME} )
+ set_property( CACHE ANDROID_ABI PROPERTY STRINGS ${ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_NAME}} )
+endif()
+
+
+# runtime choice (STL, rtti, exceptions)
+if( NOT ANDROID_STL )
+  set( ANDROID_STL gnustl_static )
+endif()
+set( ANDROID_STL "${ANDROID_STL}" CACHE STRING "C++ runtime" )
+set( ANDROID_STL_FORCE_FEATURES ON CACHE BOOL "automatically configure rtti and exceptions support based on C++ runtime" )
+mark_as_advanced( ANDROID_STL ANDROID_STL_FORCE_FEATURES )
+
+if( BUILD_WITH_ANDROID_NDK )
+ if( NOT "${ANDROID_STL}" MATCHES "^(none|system|system_re|gabi\\+\\+_static|gabi\\+\\+_shared|stlport_static|stlport_shared|gnustl_static|gnustl_shared)$")
+  message( FATAL_ERROR "ANDROID_STL is set to invalid value \"${ANDROID_STL}\".
+The possible values are:
+  none           -> Do not configure the runtime.
+  system         -> Use the default minimal system C++ runtime library.
+  system_re      -> Same as system but with rtti and exceptions.
+  gabi++_static  -> Use the GAbi++ runtime as a static library.
+  gabi++_shared  -> Use the GAbi++ runtime as a shared library.
+  stlport_static -> Use the STLport runtime as a static library.
+  stlport_shared -> Use the STLport runtime as a shared library.
+  gnustl_static  -> (default) Use the GNU STL as a static library.
+  gnustl_shared  -> Use the GNU STL as a shared library.
+" )
+ endif()
+elseif( BUILD_WITH_STANDALONE_TOOLCHAIN )
+ if( NOT "${ANDROID_STL}" MATCHES "^(none|gnustl_static|gnustl_shared)$")
+  message( FATAL_ERROR "ANDROID_STL is set to invalid value \"${ANDROID_STL}\".
+The possible values are:
+  none           -> Do not configure the runtime.
+  gnustl_static  -> (default) Use the GNU STL as a static library.
+  gnustl_shared  -> Use the GNU STL as a shared library.
+" )
+ endif()
+endif()
+
+unset( ANDROID_RTTI )
+unset( ANDROID_EXCEPTIONS )
+unset( ANDROID_STL_INCLUDE_DIRS )
+unset( __libstl )
+unset( __libsupcxx )
+
+if( NOT _CMAKE_IN_TRY_COMPILE AND ANDROID_NDK_RELEASE STREQUAL "r7b" AND ARMEABI_V7A AND NOT VFPV3 AND ANDROID_STL MATCHES "gnustl" )
+ message( WARNING  "The GNU STL armeabi-v7a binaries from NDK r7b can crash non-NEON devices. The files provided with NDK r7b were not configured properly, resulting in crashes on Tegra2-based devices and others when trying to use certain floating-point functions (e.g., cosf, sinf, expf).
+You are strongly recommended to switch to another NDK release.
+" )
+endif()
+
+if( NOT _CMAKE_IN_TRY_COMPILE AND X86 AND ANDROID_STL MATCHES "gnustl" AND ANDROID_NDK_RELEASE STREQUAL "r6" )
+  message( WARNING  "The x86 system header file from NDK r6 has incorrect definition for ptrdiff_t. You are recommended to upgrade to a newer NDK release or manually patch the header:
+See https://android.googlesource.com/platform/development.git f907f4f9d4e56ccc8093df6fee54454b8bcab6c2
+  diff --git a/ndk/platforms/android-9/arch-x86/include/machine/_types.h b/ndk/platforms/android-9/arch-x86/include/machine/_types.h
+  index 5e28c64..65892a1 100644
+  --- a/ndk/platforms/android-9/arch-x86/include/machine/_types.h
+  +++ b/ndk/platforms/android-9/arch-x86/include/machine/_types.h
+  @@ -51,7 +51,11 @@ typedef long int       ssize_t;
+   #endif
+   #ifndef _PTRDIFF_T
+   #define _PTRDIFF_T
+  -typedef long           ptrdiff_t;
+  +#  ifdef __ANDROID__
+  +     typedef int            ptrdiff_t;
+  +#  else
+  +     typedef long           ptrdiff_t;
+  +#  endif
+   #endif
+" )
+endif()
+
+
+# setup paths and STL for standalone toolchain
+if( BUILD_WITH_STANDALONE_TOOLCHAIN )
+ set( ANDROID_TOOLCHAIN_ROOT "${ANDROID_STANDALONE_TOOLCHAIN}" )
+ set( ANDROID_CLANG_TOOLCHAIN_ROOT "${ANDROID_STANDALONE_TOOLCHAIN}" )
+ set( ANDROID_SYSROOT "${ANDROID_STANDALONE_TOOLCHAIN}/sysroot" )
+
+ if( NOT ANDROID_STL STREQUAL "none" )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_STANDALONE_TOOLCHAIN}/include/c++/${ANDROID_COMPILER_VERSION}" )
+  if( NOT EXISTS "${ANDROID_STL_INCLUDE_DIRS}" )
+   # old location ( pre r8c )
+   set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/include/c++/${ANDROID_COMPILER_VERSION}" )
+  endif()
+  if( ARMEABI_V7A AND EXISTS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/${CMAKE_SYSTEM_PROCESSOR}/bits" )
+   list( APPEND ANDROID_STL_INCLUDE_DIRS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/${CMAKE_SYSTEM_PROCESSOR}" )
+  elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/thumb/bits" )
+   list( APPEND ANDROID_STL_INCLUDE_DIRS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/thumb" )
+  else()
+   list( APPEND ANDROID_STL_INCLUDE_DIRS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}" )
+  endif()
+  # always search static GNU STL to get the location of libsupc++.a
+  if( ARMEABI_V7A AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb" )
+  elseif( ARMEABI_V7A AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}" )
+  elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb" )
+  elseif( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib" )
+  endif()
+  if( __libstl )
+   set( __libsupcxx "${__libstl}/libsupc++.a" )
+   set( __libstl    "${__libstl}/libstdc++.a" )
+  endif()
+  if( NOT EXISTS "${__libsupcxx}" )
+   message( FATAL_ERROR "The required libstdsupc++.a is missing in your standalone toolchain.
+ Usually it happens because of bug in make-standalone-toolchain.sh script from NDK r7, r7b and r7c.
+ You need to either upgrade to newer NDK or manually copy
+     $ANDROID_NDK/sources/cxx-stl/gnu-libstdc++/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a
+ to
+     ${__libsupcxx}
+   " )
+  endif()
+  if( ANDROID_STL STREQUAL "gnustl_shared" )
+   if( ARMEABI_V7A AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
+    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
+   elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
+    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
+   elseif( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
+    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
+   endif()
+  endif()
+ endif()
+endif()
+
+# clang
+if( "${ANDROID_TOOLCHAIN_NAME}" STREQUAL "standalone-clang" )
+ set( ANDROID_COMPILER_IS_CLANG 1 )
+ execute_process( COMMAND "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/clang${TOOL_OS_SUFFIX}" --version OUTPUT_VARIABLE ANDROID_CLANG_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE )
+ string( REGEX MATCH "[0-9]+[.][0-9]+" ANDROID_CLANG_VERSION "${ANDROID_CLANG_VERSION}")
+elseif( "${ANDROID_TOOLCHAIN_NAME}" MATCHES "-clang3[.][0-9]?$" )
+ string( REGEX MATCH "3[.][0-9]$" ANDROID_CLANG_VERSION "${ANDROID_TOOLCHAIN_NAME}")
+ string( REGEX REPLACE "-clang${ANDROID_CLANG_VERSION}$" "-${ANDROID_COMPILER_VERSION}" ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
+ if( NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}/bin/clang${TOOL_OS_SUFFIX}" )
+  message( FATAL_ERROR "Could not find the Clang compiler driver" )
+ endif()
+ set( ANDROID_COMPILER_IS_CLANG 1 )
+ set( ANDROID_CLANG_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+else()
+ set( ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
+ unset( ANDROID_COMPILER_IS_CLANG CACHE )
+endif()
+
+string( REPLACE "." "" _clang_name "clang${ANDROID_CLANG_VERSION}" )
+if( NOT EXISTS "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}" )
+ set( _clang_name "clang" )
+endif()
+
+
+# setup paths and STL for NDK
+if( BUILD_WITH_ANDROID_NDK )
+ set( ANDROID_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+ set( ANDROID_SYSROOT "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}" )
+
+ if( ANDROID_STL STREQUAL "none" )
+  # do nothing
+ elseif( ANDROID_STL STREQUAL "system" )
+  set( ANDROID_RTTI             OFF )
+  set( ANDROID_EXCEPTIONS       OFF )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
+ elseif( ANDROID_STL STREQUAL "system_re" )
+  set( ANDROID_RTTI             ON )
+  set( ANDROID_EXCEPTIONS       ON )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
+ elseif( ANDROID_STL MATCHES "gabi" )
+  if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+   message( FATAL_ERROR "gabi++ is not available in your NDK. You have to upgrade to NDK r7 or newer to use gabi++.")
+  endif()
+  set( ANDROID_RTTI             ON )
+  set( ANDROID_EXCEPTIONS       OFF )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/gabi++/include" )
+  set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/gabi++/libs/${ANDROID_NDK_ABI_NAME}/libgabi++_static.a" )
+ elseif( ANDROID_STL MATCHES "stlport" )
+  if( NOT ANDROID_NDK_RELEASE_NUM LESS 8004 ) # before r8d
+   set( ANDROID_EXCEPTIONS       ON )
+  else()
+   set( ANDROID_EXCEPTIONS       OFF )
+  endif()
+  if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+   set( ANDROID_RTTI            OFF )
+  else()
+   set( ANDROID_RTTI            ON )
+  endif()
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/stlport/stlport" )
+  set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/stlport/libs/${ANDROID_NDK_ABI_NAME}/libstlport_static.a" )
+ elseif( ANDROID_STL MATCHES "gnustl" )
+  set( ANDROID_EXCEPTIONS       ON )
+  set( ANDROID_RTTI             ON )
+  if( EXISTS "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
+   if( ARMEABI_V7A AND ANDROID_COMPILER_VERSION VERSION_EQUAL "4.7" AND ANDROID_NDK_RELEASE STREQUAL "r8d" )
+    # gnustl binary for 4.7 compiler is buggy :(
+    # TODO: look for right fix
+    set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/4.6" )
+   else()
+    set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
+   endif()
+  else()
+   set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++" )
+  endif()
+  set( ANDROID_STL_INCLUDE_DIRS "${__libstl}/include" "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/include" "${__libstl}/include/backward" )
+  if( EXISTS "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
+   set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
+  else()
+   set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libstdc++.a" )
+  endif()
+ else()
+  message( FATAL_ERROR "Unknown runtime: ${ANDROID_STL}" )
+ endif()
+ # find libsupc++.a - rtti & exceptions
+ if( ANDROID_STL STREQUAL "system_re" OR ANDROID_STL MATCHES "gnustl" )
+  set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r8b or newer
+  if( NOT EXISTS "${__libsupcxx}" )
+   set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r7-r8
+  endif()
+  if( NOT EXISTS "${__libsupcxx}" ) # before r7
+   if( ARMEABI_V7A )
+    if( ANDROID_FORCE_ARM_BUILD )
+     set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libsupc++.a" )
+    else()
+     set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb/libsupc++.a" )
+    endif()
+   elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD )
+    set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libsupc++.a" )
+   else()
+    set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libsupc++.a" )
+   endif()
+  endif()
+  if( NOT EXISTS "${__libsupcxx}")
+   message( ERROR "Could not find libsupc++.a for a chosen platform. Either your NDK is not supported or is broken.")
+  endif()
+ endif()
+endif()
+
+
+# case of shared STL linkage
+if( ANDROID_STL MATCHES "shared" AND DEFINED __libstl )
+ string( REPLACE "_static.a" "_shared.so" __libstl "${__libstl}" )
+ # TODO: check if .so file exists before the renaming
+endif()
+
+
+# ccache support
+__INIT_VARIABLE( _ndk_ccache NDK_CCACHE ENV_NDK_CCACHE )
+if( _ndk_ccache )
+ if( DEFINED NDK_CCACHE AND NOT EXISTS NDK_CCACHE )
+  unset( NDK_CCACHE CACHE )
+ endif()
+ find_program( NDK_CCACHE "${_ndk_ccache}" DOC "The path to ccache binary")
+else()
+ unset( NDK_CCACHE CACHE )
+endif()
+unset( _ndk_ccache )
+
+
+# setup the cross-compiler
+if( NOT CMAKE_C_COMPILER )
+ if( NDK_CCACHE AND NOT ANDROID_SYSROOT MATCHES "[ ;\"]" )
+  set( CMAKE_C_COMPILER   "${NDK_CCACHE}" CACHE PATH "ccache as C compiler" )
+  set( CMAKE_CXX_COMPILER "${NDK_CCACHE}" CACHE PATH "ccache as C++ compiler" )
+  if( ANDROID_COMPILER_IS_CLANG )
+   set( CMAKE_C_COMPILER_ARG1   "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}"   CACHE PATH "C compiler")
+   set( CMAKE_CXX_COMPILER_ARG1 "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}++${TOOL_OS_SUFFIX}" CACHE PATH "C++ compiler")
+  else()
+   set( CMAKE_C_COMPILER_ARG1   "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc${TOOL_OS_SUFFIX}" CACHE PATH "C compiler")
+   set( CMAKE_CXX_COMPILER_ARG1 "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-g++${TOOL_OS_SUFFIX}" CACHE PATH "C++ compiler")
+  endif()
+ else()
+  if( ANDROID_COMPILER_IS_CLANG )
+   set( CMAKE_C_COMPILER   "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}"   CACHE PATH "C compiler")
+   set( CMAKE_CXX_COMPILER "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}++${TOOL_OS_SUFFIX}" CACHE PATH "C++ compiler")
+  else()
+   set( CMAKE_C_COMPILER   "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc${TOOL_OS_SUFFIX}"    CACHE PATH "C compiler" )
+   set( CMAKE_CXX_COMPILER "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-g++${TOOL_OS_SUFFIX}"    CACHE PATH "C++ compiler" )
+  endif()
+ endif()
+ set( CMAKE_ASM_COMPILER "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc${TOOL_OS_SUFFIX}"     CACHE PATH "assembler" )
+ set( CMAKE_STRIP        "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-strip${TOOL_OS_SUFFIX}"   CACHE PATH "strip" )
+ if( EXISTS "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc-ar${TOOL_OS_SUFFIX}" )
+  # Use gcc-ar if we have it for better LTO support.
+  set( CMAKE_AR           "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc-ar${TOOL_OS_SUFFIX}"      CACHE PATH "archive" )
+ else()
+  set( CMAKE_AR           "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-ar${TOOL_OS_SUFFIX}"      CACHE PATH "archive" )
+ endif()
+ set( CMAKE_LINKER       "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-ld${TOOL_OS_SUFFIX}"      CACHE PATH "linker" )
+ set( CMAKE_NM           "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-nm${TOOL_OS_SUFFIX}"      CACHE PATH "nm" )
+ set( CMAKE_OBJCOPY      "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-objcopy${TOOL_OS_SUFFIX}" CACHE PATH "objcopy" )
+ set( CMAKE_OBJDUMP      "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-objdump${TOOL_OS_SUFFIX}" CACHE PATH "objdump" )
+ set( CMAKE_RANLIB       "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-ranlib${TOOL_OS_SUFFIX}"  CACHE PATH "ranlib" )
+endif()
+
+set( _CMAKE_TOOLCHAIN_PREFIX "${ANDROID_TOOLCHAIN_MACHINE_NAME}-" )
+if( CMAKE_VERSION VERSION_LESS 2.8.5 )
+ set( CMAKE_ASM_COMPILER_ARG1 "-c" )
+endif()
+if( APPLE )
+ find_program( CMAKE_INSTALL_NAME_TOOL NAMES install_name_tool )
+ if( NOT CMAKE_INSTALL_NAME_TOOL )
+  message( FATAL_ERROR "Could not find install_name_tool, please check your installation." )
+ endif()
+ mark_as_advanced( CMAKE_INSTALL_NAME_TOOL )
+endif()
+
+# Force set compilers because standard identification works badly for us
+include( CMakeForceCompiler )
+# CMAKE_FORCE_C_COMPILER( "${CMAKE_C_COMPILER}" GNU )
+if( ANDROID_COMPILER_IS_CLANG )
+ set( CMAKE_C_COMPILER_ID Clang )
+endif()
+set( CMAKE_C_PLATFORM_ID Linux )
+if( X86_64 OR MIPS64 OR ARM64_V8A )
+ set( CMAKE_C_SIZEOF_DATA_PTR 8 )
+else()
+ set( CMAKE_C_SIZEOF_DATA_PTR 4 )
+endif()
+set( CMAKE_C_HAS_ISYSROOT 1 )
+set( CMAKE_C_COMPILER_ABI ELF )
+# CMAKE_FORCE_CXX_COMPILER( "${CMAKE_CXX_COMPILER}" GNU )
+if( ANDROID_COMPILER_IS_CLANG )
+ set( CMAKE_CXX_COMPILER_ID Clang)
+endif()
+set( CMAKE_CXX_PLATFORM_ID Linux )
+set( CMAKE_CXX_SIZEOF_DATA_PTR ${CMAKE_C_SIZEOF_DATA_PTR} )
+set( CMAKE_CXX_HAS_ISYSROOT 1 )
+set( CMAKE_CXX_COMPILER_ABI ELF )
+set( CMAKE_CXX_SOURCE_FILE_EXTENSIONS cc cp cxx cpp CPP c++ C )
+# force ASM compiler (required for CMake < 2.8.5)
+set( CMAKE_ASM_COMPILER_ID_RUN TRUE )
+set( CMAKE_ASM_COMPILER_ID GNU )
+set( CMAKE_ASM_COMPILER_WORKS TRUE )
+set( CMAKE_ASM_COMPILER_FORCED TRUE )
+set( CMAKE_COMPILER_IS_GNUASM 1)
+set( CMAKE_ASM_SOURCE_FILE_EXTENSIONS s S asm )
+
+foreach( lang C CXX ASM )
+ if( ANDROID_COMPILER_IS_CLANG )
+  set( CMAKE_${lang}_COMPILER_VERSION ${ANDROID_CLANG_VERSION} )
+ else()
+  set( CMAKE_${lang}_COMPILER_VERSION ${ANDROID_COMPILER_VERSION} )
+ endif()
+endforeach()
+
+# flags and definitions
+remove_definitions( -DANDROID )
+add_definitions( -DANDROID )
+
+if( ANDROID_SYSROOT MATCHES "[ ;\"]" )
+ if( CMAKE_HOST_WIN32 )
+  # try to convert path to 8.3 form
+  file( WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/cvt83.cmd" "@echo %~s1" )
+  execute_process( COMMAND "$ENV{ComSpec}" /c "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/cvt83.cmd" "${ANDROID_SYSROOT}"
+                   OUTPUT_VARIABLE __path OUTPUT_STRIP_TRAILING_WHITESPACE
+                   RESULT_VARIABLE __result ERROR_QUIET )
+  if( __result EQUAL 0 )
+   file( TO_CMAKE_PATH "${__path}" ANDROID_SYSROOT )
+   set( ANDROID_CXX_FLAGS "--sysroot=${ANDROID_SYSROOT}" )
+  else()
+   set( ANDROID_CXX_FLAGS "--sysroot=\"${ANDROID_SYSROOT}\"" )
+  endif()
+ else()
+  set( ANDROID_CXX_FLAGS "'--sysroot=${ANDROID_SYSROOT}'" )
+ endif()
+ if( NOT _CMAKE_IN_TRY_COMPILE )
+  # quotes can break try_compile and compiler identification
+  message(WARNING "Path to your Android NDK (or toolchain) has non-alphanumeric symbols.\nThe build might be broken.\n")
+ endif()
+else()
+ set( ANDROID_CXX_FLAGS "--sysroot=${ANDROID_SYSROOT}" )
+endif()
+
+# NDK flags
+if (ARM64_V8A )
+ set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS} -funwind-tables" )
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer -fstrict-aliasing" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer -fno-strict-aliasing" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE} -funswitch-loops -finline-limit=300" )
+ endif()
+elseif( ARMEABI OR ARMEABI_V7A)
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funwind-tables" )
+ if( NOT ANDROID_FORCE_ARM_BUILD AND NOT ARMEABI_V6 )
+  set( ANDROID_CXX_FLAGS_RELEASE "-mthumb -fomit-frame-pointer -fno-strict-aliasing" )
+  set( ANDROID_CXX_FLAGS_DEBUG   "-marm -fno-omit-frame-pointer -fno-strict-aliasing" )
+  if( NOT ANDROID_COMPILER_IS_CLANG )
+   set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -finline-limit=64" )
+  endif()
+ else()
+  # always compile ARMEABI_V6 in arm mode; otherwise there is no difference from ARMEABI
+  set( ANDROID_CXX_FLAGS_RELEASE "-marm -fomit-frame-pointer -fstrict-aliasing" )
+  set( ANDROID_CXX_FLAGS_DEBUG   "-marm -fno-omit-frame-pointer -fno-strict-aliasing" )
+  if( NOT ANDROID_COMPILER_IS_CLANG )
+   set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funswitch-loops -finline-limit=300" )
+  endif()
+ endif()
+elseif( X86 OR X86_64 )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funwind-tables" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funswitch-loops -finline-limit=300" )
+ endif()
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer -fstrict-aliasing" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer -fno-strict-aliasing" )
+elseif( MIPS OR MIPS64 )
+ set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS} -fno-strict-aliasing -finline-functions -funwind-tables -fmessage-length=0" )
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -fno-inline-functions-called-once -fgcse-after-reload -frerun-cse-after-loop -frename-registers" )
+  set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE} -funswitch-loops -finline-limit=300" )
+ endif()
+elseif()
+ set( ANDROID_CXX_FLAGS_RELEASE "" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "" )
+endif()
+
+set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -fsigned-char" ) # good/necessary when porting desktop libraries
+
+if( NOT X86 AND NOT ANDROID_COMPILER_IS_CLANG )
+ set( ANDROID_CXX_FLAGS "-Wno-psabi ${ANDROID_CXX_FLAGS}" )
+endif()
+
+if( NOT ANDROID_COMPILER_VERSION VERSION_LESS "4.6" )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -no-canonical-prefixes" ) # see https://android-review.googlesource.com/#/c/47564/
+endif()
+
+# ABI-specific flags
+if( ARMEABI_V7A )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -march=armv7-a -mfloat-abi=softfp" )
+ if( NEON )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -mfpu=neon" )
+ elseif( VFPV3 )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -mfpu=vfpv3" )
+ else()
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -mfpu=vfpv3-d16" )
+ endif()
+elseif( ARMEABI_V6 )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -march=armv6 -mfloat-abi=softfp -mfpu=vfp" ) # vfp == vfpv2
+elseif( ARMEABI )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -march=armv5te -mtune=xscale -msoft-float" )
+endif()
+
+if( ANDROID_STL MATCHES "gnustl" AND (EXISTS "${__libstl}" OR EXISTS "${__libsupcxx}") )
+ set( CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_CREATE_SHARED_MODULE  "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_LINK_EXECUTABLE       "<CMAKE_C_COMPILER> <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" )
+else()
+ set( CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_CXX_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_CREATE_SHARED_MODULE  "<CMAKE_CXX_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_LINK_EXECUTABLE       "<CMAKE_CXX_COMPILER> <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" )
+endif()
+
+# STL
+if( EXISTS "${__libstl}" OR EXISTS "${__libsupcxx}" )
+ if( EXISTS "${__libstl}" )
+  set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} \"${__libstl}\"" )
+  set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} \"${__libstl}\"" )
+  set( CMAKE_CXX_LINK_EXECUTABLE       "${CMAKE_CXX_LINK_EXECUTABLE} \"${__libstl}\"" )
+ endif()
+ if( EXISTS "${__libsupcxx}" )
+  set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} \"${__libsupcxx}\"" )
+  set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} \"${__libsupcxx}\"" )
+  set( CMAKE_CXX_LINK_EXECUTABLE       "${CMAKE_CXX_LINK_EXECUTABLE} \"${__libsupcxx}\"" )
+  # C objects:
+  set( CMAKE_C_CREATE_SHARED_LIBRARY "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_C_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_C_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+  set( CMAKE_C_CREATE_SHARED_MODULE  "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_C_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_C_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+  set( CMAKE_C_LINK_EXECUTABLE       "<CMAKE_C_COMPILER> <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" )
+  set( CMAKE_C_CREATE_SHARED_LIBRARY "${CMAKE_C_CREATE_SHARED_LIBRARY} \"${__libsupcxx}\"" )
+  set( CMAKE_C_CREATE_SHARED_MODULE  "${CMAKE_C_CREATE_SHARED_MODULE} \"${__libsupcxx}\"" )
+  set( CMAKE_C_LINK_EXECUTABLE       "${CMAKE_C_LINK_EXECUTABLE} \"${__libsupcxx}\"" )
+ endif()
+ if( ANDROID_STL MATCHES "gnustl" )
+  if( NOT EXISTS "${ANDROID_LIBM_PATH}" )
+   set( ANDROID_LIBM_PATH -lm )
+  endif()
+  set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} ${ANDROID_LIBM_PATH}" )
+  set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} ${ANDROID_LIBM_PATH}" )
+  set( CMAKE_CXX_LINK_EXECUTABLE       "${CMAKE_CXX_LINK_EXECUTABLE} ${ANDROID_LIBM_PATH}" )
+ endif()
+endif()
+
+# variables controlling optional build flags
+if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+ # libGLESv2.so in NDK's prior to r7 refers to missing external symbols.
+ # So this flag option is required for all projects using OpenGL from native.
+ __INIT_VARIABLE( ANDROID_SO_UNDEFINED                      VALUES ON )
+else()
+ __INIT_VARIABLE( ANDROID_SO_UNDEFINED                      VALUES OFF )
+endif()
+__INIT_VARIABLE( ANDROID_NO_UNDEFINED                       VALUES ON )
+__INIT_VARIABLE( ANDROID_FUNCTION_LEVEL_LINKING             VALUES ON )
+__INIT_VARIABLE( ANDROID_GOLD_LINKER                        VALUES ON )
+__INIT_VARIABLE( ANDROID_NOEXECSTACK                        VALUES ON )
+__INIT_VARIABLE( ANDROID_RELRO                              VALUES ON )
+
+set( ANDROID_NO_UNDEFINED           ${ANDROID_NO_UNDEFINED}           CACHE BOOL "Show all undefined symbols as linker errors" )
+set( ANDROID_SO_UNDEFINED           ${ANDROID_SO_UNDEFINED}           CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
+set( ANDROID_FUNCTION_LEVEL_LINKING ${ANDROID_FUNCTION_LEVEL_LINKING} CACHE BOOL "Put each function in separate section and enable garbage collection of unused input sections at link time" )
+set( ANDROID_GOLD_LINKER            ${ANDROID_GOLD_LINKER}            CACHE BOOL "Enables gold linker" )
+set( ANDROID_NOEXECSTACK            ${ANDROID_NOEXECSTACK}            CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
+set( ANDROID_RELRO                  ${ANDROID_RELRO}                  CACHE BOOL "Enables RELRO - a memory corruption mitigation technique" )
+mark_as_advanced( ANDROID_NO_UNDEFINED ANDROID_SO_UNDEFINED ANDROID_FUNCTION_LEVEL_LINKING ANDROID_GOLD_LINKER ANDROID_NOEXECSTACK ANDROID_RELRO )
+
+# linker flags
+set( ANDROID_LINKER_FLAGS "" )
+
+if( ARMEABI_V7A )
+ # this is *required* to use the following linker flags that routes around
+ # a CPU bug in some Cortex-A8 implementations:
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--fix-cortex-a8" )
+endif()
+
+if( ANDROID_NO_UNDEFINED )
+ if( MIPS )
+  # there is some sysroot-related problem in mips linker...
+  if( NOT ANDROID_SYSROOT MATCHES "[ ;\"]" )
+   set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--no-undefined -Wl,-rpath-link,${ANDROID_SYSROOT}/usr/lib" )
+  endif()
+ else()
+  set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--no-undefined" )
+ endif()
+endif()
+
+if( ANDROID_SO_UNDEFINED )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,-allow-shlib-undefined" )
+endif()
+
+if( ANDROID_FUNCTION_LEVEL_LINKING )
+ set( ANDROID_CXX_FLAGS    "${ANDROID_CXX_FLAGS} -fdata-sections -ffunction-sections" )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--gc-sections" )
+endif()
+
+if( ANDROID_COMPILER_VERSION VERSION_EQUAL "4.6" )
+ if( ANDROID_GOLD_LINKER AND (CMAKE_HOST_UNIX OR ANDROID_NDK_RELEASE_NUM GREATER 8002) AND (ARMEABI OR ARMEABI_V7A OR X86) )
+  set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -fuse-ld=gold" )
+ elseif( ANDROID_NDK_RELEASE_NUM GREATER 8002 ) # after r8b
+  set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -fuse-ld=bfd" )
+ elseif( ANDROID_NDK_RELEASE STREQUAL "r8b" AND ARMEABI AND NOT _CMAKE_IN_TRY_COMPILE )
+  message( WARNING "The default bfd linker from arm GCC 4.6 toolchain can fail with 'unresolvable R_ARM_THM_CALL relocation' error message. See https://code.google.com/p/android/issues/detail?id=35342
+  On Linux and OS X host platform you can workaround this problem using gold linker (default).
+  Rerun cmake with -DANDROID_GOLD_LINKER=ON option in case of problems.
+" )
+ endif()
+endif() # version 4.6
+
+if( ANDROID_NOEXECSTACK )
+ if( ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS    "${ANDROID_CXX_FLAGS} -Xclang -mnoexecstack" )
+ else()
+  set( ANDROID_CXX_FLAGS    "${ANDROID_CXX_FLAGS} -Wa,--noexecstack" )
+ endif()
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,-z,noexecstack" )
+endif()
+
+if( ANDROID_RELRO )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,-z,relro -Wl,-z,now" )
+endif()
+
+if( ANDROID_COMPILER_IS_CLANG )
+ set( ANDROID_CXX_FLAGS "-target ${ANDROID_LLVM_TRIPLE} -Qunused-arguments ${ANDROID_CXX_FLAGS}" )
+ if( BUILD_WITH_ANDROID_NDK )
+  set( ANDROID_CXX_FLAGS "-gcc-toolchain ${ANDROID_TOOLCHAIN_ROOT} ${ANDROID_CXX_FLAGS}" )
+ endif()
+endif()
+
+# cache flags
+set( CMAKE_CXX_FLAGS           ""                                  CACHE STRING "c++ flags" )
+set( CMAKE_C_FLAGS             ""                                  CACHE STRING "c flags" )
+set( CMAKE_CXX_FLAGS_RELEASE   "-O3 -DNDEBUG"                      CACHE STRING "c++ Release flags" )
+set( CMAKE_C_FLAGS_RELEASE     "-O3 -DNDEBUG"                      CACHE STRING "c Release flags" )
+set( CMAKE_CXX_FLAGS_DEBUG     "-O0 -g -DDEBUG -D_DEBUG"           CACHE STRING "c++ Debug flags" )
+set( CMAKE_C_FLAGS_DEBUG       "-O0 -g -DDEBUG -D_DEBUG"           CACHE STRING "c Debug flags" )
+set( CMAKE_SHARED_LINKER_FLAGS "-Wl,--build-id"                    CACHE STRING "shared linker flags" )
+set( CMAKE_MODULE_LINKER_FLAGS "-Wl,--build-id"                    CACHE STRING "module linker flags" )
+set( CMAKE_EXE_LINKER_FLAGS    "-Wl,--build-id -Wl,-z,nocopyreloc" CACHE STRING "executable linker flags" )
+
+# put flags to cache (for debug purpose only)
+set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS}"         CACHE INTERNAL "Android specific c/c++ flags" )
+set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE}" CACHE INTERNAL "Android specific c/c++ Release flags" )
+set( ANDROID_CXX_FLAGS_DEBUG   "${ANDROID_CXX_FLAGS_DEBUG}"   CACHE INTERNAL "Android specific c/c++ Debug flags" )
+set( ANDROID_LINKER_FLAGS      "${ANDROID_LINKER_FLAGS}"      CACHE INTERNAL "Android specific c/c++ linker flags" )
+
+# finish flags
+set( CMAKE_CXX_FLAGS           "${ANDROID_CXX_FLAGS} ${CMAKE_CXX_FLAGS}" )
+set( CMAKE_C_FLAGS             "${ANDROID_CXX_FLAGS} ${CMAKE_C_FLAGS}" )
+set( CMAKE_CXX_FLAGS_RELEASE   "${ANDROID_CXX_FLAGS_RELEASE} ${CMAKE_CXX_FLAGS_RELEASE}" )
+set( CMAKE_C_FLAGS_RELEASE     "${ANDROID_CXX_FLAGS_RELEASE} ${CMAKE_C_FLAGS_RELEASE}" )
+set( CMAKE_CXX_FLAGS_DEBUG     "${ANDROID_CXX_FLAGS_DEBUG} ${CMAKE_CXX_FLAGS_DEBUG}" )
+set( CMAKE_C_FLAGS_DEBUG       "${ANDROID_CXX_FLAGS_DEBUG} ${CMAKE_C_FLAGS_DEBUG}" )
+set( CMAKE_SHARED_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} ${CMAKE_SHARED_LINKER_FLAGS}" )
+set( CMAKE_MODULE_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} ${CMAKE_MODULE_LINKER_FLAGS}" )
+set( CMAKE_EXE_LINKER_FLAGS    "${ANDROID_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS}" )
+
+if( MIPS AND BUILD_WITH_ANDROID_NDK AND ANDROID_NDK_RELEASE STREQUAL "r8" )
+ set( CMAKE_SHARED_LINKER_FLAGS "-Wl,-T,${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}/mipself.xsc ${CMAKE_SHARED_LINKER_FLAGS}" )
+ set( CMAKE_MODULE_LINKER_FLAGS "-Wl,-T,${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}/mipself.xsc ${CMAKE_MODULE_LINKER_FLAGS}" )
+ set( CMAKE_EXE_LINKER_FLAGS    "-Wl,-T,${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}/mipself.x ${CMAKE_EXE_LINKER_FLAGS}" )
+endif()
+
+# pie/pic
+if( NOT (ANDROID_NATIVE_API_LEVEL LESS 16) AND (NOT DEFINED ANDROID_APP_PIE OR ANDROID_APP_PIE) AND (CMAKE_VERSION VERSION_GREATER 2.8.8) )
+ set( CMAKE_POSITION_INDEPENDENT_CODE TRUE )
+ set( CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fPIE -pie")
+else()
+ set( CMAKE_POSITION_INDEPENDENT_CODE FALSE )
+ set( CMAKE_CXX_FLAGS "-fpic ${CMAKE_CXX_FLAGS}" )
+ set( CMAKE_C_FLAGS   "-fpic ${CMAKE_C_FLAGS}" )
+endif()
+
+# configure rtti
+if( DEFINED ANDROID_RTTI AND ANDROID_STL_FORCE_FEATURES )
+ if( ANDROID_RTTI )
+  set( CMAKE_CXX_FLAGS "-frtti ${CMAKE_CXX_FLAGS}" )
+ else()
+  set( CMAKE_CXX_FLAGS "-fno-rtti ${CMAKE_CXX_FLAGS}" )
+ endif()
+endif()
+
+# configure exceptios
+if( DEFINED ANDROID_EXCEPTIONS AND ANDROID_STL_FORCE_FEATURES )
+ if( ANDROID_EXCEPTIONS )
+  set( CMAKE_CXX_FLAGS "-fexceptions ${CMAKE_CXX_FLAGS}" )
+  set( CMAKE_C_FLAGS "-fexceptions ${CMAKE_C_FLAGS}" )
+ else()
+  set( CMAKE_CXX_FLAGS "-fno-exceptions ${CMAKE_CXX_FLAGS}" )
+  set( CMAKE_C_FLAGS "-fno-exceptions ${CMAKE_C_FLAGS}" )
+ endif()
+endif()
+
+# global includes and link directories
+include_directories( SYSTEM "${ANDROID_SYSROOT}/usr/include" ${ANDROID_STL_INCLUDE_DIRS} )
+get_filename_component(__android_install_path "${CMAKE_INSTALL_PREFIX}/libs/${ANDROID_NDK_ABI_NAME}" ABSOLUTE) # avoid CMP0015 policy warning
+link_directories( "${__android_install_path}" )
+
+# detect if need link crtbegin_so.o explicitly
+if( NOT DEFINED ANDROID_EXPLICIT_CRT_LINK )
+ set( __cmd "${CMAKE_CXX_CREATE_SHARED_LIBRARY}" )
+ string( REPLACE "<CMAKE_CXX_COMPILER>" "${CMAKE_CXX_COMPILER} ${CMAKE_CXX_COMPILER_ARG1}" __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_C_COMPILER>"   "${CMAKE_C_COMPILER} ${CMAKE_C_COMPILER_ARG1}"   __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_SHARED_LIBRARY_CXX_FLAGS>" "${CMAKE_CXX_FLAGS}" __cmd "${__cmd}" )
+ string( REPLACE "<LANGUAGE_COMPILE_FLAGS>" "" __cmd "${__cmd}" )
+ string( REPLACE "<LINK_FLAGS>" "${CMAKE_SHARED_LINKER_FLAGS}" __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS>" "-shared" __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG>" "" __cmd "${__cmd}" )
+ string( REPLACE "<TARGET_SONAME>" "" __cmd "${__cmd}" )
+ string( REPLACE "<TARGET>" "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/toolchain_crtlink_test.so" __cmd "${__cmd}" )
+ string( REPLACE "<OBJECTS>" "\"${ANDROID_SYSROOT}/usr/lib/crtbegin_so.o\"" __cmd "${__cmd}" )
+ string( REPLACE "<LINK_LIBRARIES>" "" __cmd "${__cmd}" )
+ separate_arguments( __cmd )
+ foreach( __var ANDROID_NDK ANDROID_NDK_TOOLCHAINS_PATH ANDROID_STANDALONE_TOOLCHAIN )
+  if( ${__var} )
+   set( __tmp "${${__var}}" )
+   separate_arguments( __tmp )
+   string( REPLACE "${__tmp}" "${${__var}}" __cmd "${__cmd}")
+  endif()
+ endforeach()
+ string( REPLACE "'" "" __cmd "${__cmd}" )
+ string( REPLACE "\"" "" __cmd "${__cmd}" )
+ execute_process( COMMAND ${__cmd} RESULT_VARIABLE __cmd_result OUTPUT_QUIET ERROR_QUIET )
+ if( __cmd_result EQUAL 0 )
+  set( ANDROID_EXPLICIT_CRT_LINK ON )
+ else()
+  set( ANDROID_EXPLICIT_CRT_LINK OFF )
+ endif()
+endif()
+
+if( ANDROID_EXPLICIT_CRT_LINK )
+ set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} \"${ANDROID_SYSROOT}/usr/lib/crtbegin_so.o\"" )
+ set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} \"${ANDROID_SYSROOT}/usr/lib/crtbegin_so.o\"" )
+endif()
+
+# setup output directories
+set( CMAKE_INSTALL_PREFIX "${ANDROID_TOOLCHAIN_ROOT}/user" CACHE STRING "path for installing" )
+
+if( DEFINED LIBRARY_OUTPUT_PATH_ROOT
+      OR EXISTS "${CMAKE_SOURCE_DIR}/AndroidManifest.xml"
+      OR (EXISTS "${CMAKE_SOURCE_DIR}/../AndroidManifest.xml" AND EXISTS "${CMAKE_SOURCE_DIR}/../jni/") )
+  set( LIBRARY_OUTPUT_PATH_ROOT ${CMAKE_SOURCE_DIR} CACHE PATH "Root for binaries output, set this to change where Android libs are installed to" )
+  if( NOT _CMAKE_IN_TRY_COMPILE )
+    if( EXISTS "${CMAKE_SOURCE_DIR}/jni/CMakeLists.txt" )
+      set( EXECUTABLE_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/bin/${ANDROID_NDK_ABI_NAME}" CACHE PATH "Output directory for applications" )
+    else()
+      set( EXECUTABLE_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/bin" CACHE PATH "Output directory for applications" )
+    endif()
+    set( LIBRARY_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME}" CACHE PATH "Output directory for Android libs" )
+  endif()
+endif()
+
+# copy shaed stl library to build directory
+if( NOT _CMAKE_IN_TRY_COMPILE AND __libstl MATCHES "[.]so$" AND DEFINED LIBRARY_OUTPUT_PATH )
+  get_filename_component( __libstlname "${__libstl}" NAME )
+  execute_process( COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${__libstl}" "${LIBRARY_OUTPUT_PATH}/${__libstlname}" RESULT_VARIABLE __fileCopyProcess )
+  if( NOT __fileCopyProcess EQUAL 0 OR NOT EXISTS "${LIBRARY_OUTPUT_PATH}/${__libstlname}")
+    message( SEND_ERROR "Failed copying of ${__libstl} to the ${LIBRARY_OUTPUT_PATH}/${__libstlname}" )
+  endif()
+  unset( __fileCopyProcess )
+  unset( __libstlname )
+endif()
+
+
+# set these global flags for cmake client scripts to change behavior
+set( ANDROID True )
+set( BUILD_ANDROID True )
+
+# where is the target environment
+set( CMAKE_FIND_ROOT_PATH "${ANDROID_TOOLCHAIN_ROOT}/bin" "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}" "${ANDROID_SYSROOT}" "${CMAKE_INSTALL_PREFIX}" "${CMAKE_INSTALL_PREFIX}/share" )
+
+# only search for libraries and includes in the ndk toolchain
+set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY )
+set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
+set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )
+
+
+# macro to find packages on the host OS
+macro( find_host_package )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER )
+ if( CMAKE_HOST_WIN32 )
+  SET( WIN32 1 )
+  SET( UNIX )
+ elseif( CMAKE_HOST_APPLE )
+  SET( APPLE 1 )
+  SET( UNIX )
+ endif()
+ find_package( ${ARGN} )
+ SET( WIN32 )
+ SET( APPLE )
+ SET( UNIX 1 )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )
+endmacro()
+
+
+# macro to find programs on the host OS
+macro( find_host_program )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER )
+ if( CMAKE_HOST_WIN32 )
+  SET( WIN32 1 )
+  SET( UNIX )
+ elseif( CMAKE_HOST_APPLE )
+  SET( APPLE 1 )
+  SET( UNIX )
+ endif()
+ find_program( ${ARGN} )
+ SET( WIN32 )
+ SET( APPLE )
+ SET( UNIX 1 )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )
+endmacro()
+
+
+# export toolchain settings for the try_compile() command
+if( NOT _CMAKE_IN_TRY_COMPILE )
+ set( __toolchain_config "")
+ foreach( __var NDK_CCACHE  LIBRARY_OUTPUT_PATH_ROOT  ANDROID_FORBID_SYGWIN
+                ANDROID_NDK_HOST_X64
+                ANDROID_NDK
+                ANDROID_NDK_LAYOUT
+                ANDROID_STANDALONE_TOOLCHAIN
+                ANDROID_TOOLCHAIN_NAME
+                ANDROID_ABI
+                ANDROID_NATIVE_API_LEVEL
+                ANDROID_STL
+                ANDROID_STL_FORCE_FEATURES
+                ANDROID_FORCE_ARM_BUILD
+                ANDROID_NO_UNDEFINED
+                ANDROID_SO_UNDEFINED
+                ANDROID_FUNCTION_LEVEL_LINKING
+                ANDROID_GOLD_LINKER
+                ANDROID_NOEXECSTACK
+                ANDROID_RELRO
+                ANDROID_LIBM_PATH
+                ANDROID_EXPLICIT_CRT_LINK
+                ANDROID_APP_PIE
+                )
+  if( DEFINED ${__var} )
+   if( ${__var} MATCHES " ")
+    set( __toolchain_config "${__toolchain_config}set( ${__var} \"${${__var}}\" CACHE INTERNAL \"\" )\n" )
+   else()
+    set( __toolchain_config "${__toolchain_config}set( ${__var} ${${__var}} CACHE INTERNAL \"\" )\n" )
+   endif()
+  endif()
+ endforeach()
+ file( WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/android.toolchain.config.cmake" "${__toolchain_config}" )
+ unset( __toolchain_config )
+endif()
+
+
+# force cmake to produce / instead of \ in build commands for Ninja generator
+if( CMAKE_GENERATOR MATCHES "Ninja" AND CMAKE_HOST_WIN32 )
+ # it is a bad hack after all
+ # CMake generates Ninja makefiles with UNIX paths only if it thinks that we are going to build with MinGW
+ set( CMAKE_COMPILER_IS_MINGW TRUE ) # tell CMake that we are MinGW
+ set( CMAKE_CROSSCOMPILING TRUE )    # stop recursion
+ enable_language( C )
+ enable_language( CXX )
+ # unset( CMAKE_COMPILER_IS_MINGW ) # can't unset because CMake does not convert back-slashes in response files without it
+ unset( MINGW )
+endif()
+
+# Variables need by cmAndroidGradleBuild to generate android_gradle_build.json
+set(CMAKE_ANDROID_ARCH_ABI ${ANDROID_ABI})
+
+
+# Variables controlling behavior or set by cmake toolchain:
+#   ANDROID_ABI : "armeabi-v7a" (default), "armeabi", "armeabi-v7a with NEON", "armeabi-v7a with VFPV3", "armeabi-v6 with VFP", "x86", "mips", "arm64-v8a", "x86_64", "mips64"
+#   ANDROID_NATIVE_API_LEVEL : 3,4,5,8,9,14,15,16,17,18,19,21 (depends on NDK version)
+#   ANDROID_STL : gnustl_static/gnustl_shared/stlport_static/stlport_shared/gabi++_static/gabi++_shared/system_re/system/none
+#   ANDROID_FORBID_SYGWIN : ON/OFF
+#   ANDROID_NO_UNDEFINED : ON/OFF
+#   ANDROID_SO_UNDEFINED : OFF/ON  (default depends on NDK version)
+#   ANDROID_FUNCTION_LEVEL_LINKING : ON/OFF
+#   ANDROID_GOLD_LINKER : ON/OFF
+#   ANDROID_NOEXECSTACK : ON/OFF
+#   ANDROID_RELRO : ON/OFF
+#   ANDROID_FORCE_ARM_BUILD : ON/OFF
+#   ANDROID_STL_FORCE_FEATURES : ON/OFF
+#   ANDROID_LIBM_PATH : path to libm.so (set to something like $(TOP)/out/target/product/<product_name>/obj/lib/libm.so) to workaround unresolved `sincos`
+# Can be set only at the first run:
+#   ANDROID_NDK : path to your NDK install
+#   NDK_CCACHE : path to your ccache executable
+#   ANDROID_TOOLCHAIN_NAME : the NDK name of compiler toolchain
+#   ANDROID_NDK_HOST_X64 : try to use x86_64 toolchain (default for x64 host systems)
+#   ANDROID_NDK_LAYOUT : the inner NDK structure (RELEASE, LINARO, ANDROID)
+#   LIBRARY_OUTPUT_PATH_ROOT : <any valid path>
+#   ANDROID_STANDALONE_TOOLCHAIN
+#
+# Primary read-only variables:
+#   ANDROID : always TRUE
+#   ARMEABI : TRUE for arm v6 and older devices
+#   ARMEABI_V6 : TRUE for arm v6
+#   ARMEABI_V7A : TRUE for arm v7a
+#   ARM64_V8A : TRUE for arm64-v8a
+#   NEON : TRUE if NEON unit is enabled
+#   VFPV3 : TRUE if VFP version 3 is enabled
+#   X86 : TRUE if configured for x86
+#   X86_64 : TRUE if configured for x86_64
+#   MIPS : TRUE if configured for mips
+#   MIPS64 : TRUE if configured for mips64
+#   BUILD_WITH_ANDROID_NDK : TRUE if NDK is used
+#   BUILD_WITH_STANDALONE_TOOLCHAIN : TRUE if standalone toolchain is used
+#   ANDROID_NDK_HOST_SYSTEM_NAME : "windows", "linux-x86" or "darwin-x86" depending on host platform
+#   ANDROID_NDK_ABI_NAME : "armeabi", "armeabi-v7a", "x86", "mips", "arm64-v8a", "x86_64", "mips64" depending on ANDROID_ABI
+#   ANDROID_NDK_RELEASE : from r5 to r10d; set only for NDK
+#   ANDROID_NDK_RELEASE_NUM : numeric ANDROID_NDK_RELEASE version (1000*major+minor)
+#   ANDROID_ARCH_NAME : "arm", "x86", "mips", "arm64", "x86_64", "mips64" depending on ANDROID_ABI
+#   ANDROID_SYSROOT : path to the compiler sysroot
+#   TOOL_OS_SUFFIX : "" or ".exe" depending on host platform
+#   ANDROID_COMPILER_IS_CLANG : TRUE if clang compiler is used
+#
+# Secondary (less stable) read-only variables:
+#   ANDROID_COMPILER_VERSION : GCC version used (not Clang version)
+#   ANDROID_CLANG_VERSION : version of clang compiler if clang is used
+#   ANDROID_CXX_FLAGS : C/C++ compiler flags required by Android platform
+#   ANDROID_SUPPORTED_ABIS : list of currently allowed values for ANDROID_ABI
+#   ANDROID_TOOLCHAIN_MACHINE_NAME : "arm-linux-androideabi", "arm-eabi" or "i686-android-linux"
+#   ANDROID_TOOLCHAIN_ROOT : path to the top level of toolchain (standalone or placed inside NDK)
+#   ANDROID_CLANG_TOOLCHAIN_ROOT : path to clang tools
+#   ANDROID_SUPPORTED_NATIVE_API_LEVELS : list of native API levels found inside NDK
+#   ANDROID_STL_INCLUDE_DIRS : stl include paths
+#   ANDROID_RTTI : if rtti is enabled by the runtime
+#   ANDROID_EXCEPTIONS : if exceptions are enabled by the runtime
+#   ANDROID_GCC_TOOLCHAIN_NAME : read-only, differs from ANDROID_TOOLCHAIN_NAME only if clang is used
+#
+# Defaults:
+#   ANDROID_DEFAULT_NDK_API_LEVEL
+#   ANDROID_DEFAULT_NDK_API_LEVEL_${ARCH}
+#   ANDROID_NDK_SEARCH_PATHS
+#   ANDROID_SUPPORTED_ABIS_${ARCH}
+#   ANDROID_SUPPORTED_NDK_VERSIONS
diff --git a/realm/realm-library/src/main/cpp/io_realm_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
new file mode 100644
index 0000000000..b107982b07
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_Property.h"
+
+#include <stdexcept>
+#include <object-store/src/property.hpp>
+#include <object-store/src/object_store.hpp>
+
+#include "util.hpp"
+
+using namespace realm;
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(JNIEnv *env, jclass, jstring name_,
+                                                                     jint type, jboolean is_primary, jboolean is_indexed,
+                                                                     jboolean is_nullable) {
+    TR_ENTER()
+    try {
+        JStringAccessor str(env, name_);
+        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
+        std::unique_ptr<Property> property(new Property(str, p_type, "", "", to_bool(is_primary), to_bool(is_indexed), to_bool(is_nullable)));
+        if (to_bool(is_indexed) && !property->is_indexable()) {
+            throw std::invalid_argument(
+                    "This field cannot be indexed - Only String/byte/short/int/long/boolean/Date fields are supported.");
+        }
+        if (to_bool(is_primary) && p_type != PropertyType::Int && p_type != PropertyType::String) {
+            std::string typ = property->type_string();
+            throw std::invalid_argument("Invalid primary key type: " + typ);
+        }
+        return reinterpret_cast<jlong>(property.release());
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(JNIEnv *env, jclass,
+                                                                                     jstring name_, jint type,
+                                                                                     jstring linkedToName_) {
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, name_);
+        JStringAccessor link_name(env, linkedToName_);
+        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
+        bool is_nullable = (p_type == PropertyType::Object);
+        std::unique_ptr<Property> property(new Property(name, p_type, link_name, "", false, false, is_nullable));
+        return reinterpret_cast<jlong>(property.release());
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_Property_nativeClose(JNIEnv *env, jclass, jlong property_ptr) {
+    TR_ENTER_PTR(property_ptr)
+    try {
+        Property *property = reinterpret_cast<Property *>(property_ptr);
+        delete property;
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
new file mode 100644
index 0000000000..8c86146d45
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include <jni_util/log.hpp>
+#include "io_realm_RealmFileUserStore.h"
+#include "sync/sync_manager.hpp"
+#include "sync/sync_user.hpp"
+#include "util.hpp"
+
+using namespace realm;
+
+static const char* ERR_NO_LOGGED_IN_USER = "No user logged in yet.";
+static const char* ERR_COULD_NOT_ALLOCATE_MEMORY = "Could not allocate memory to return all users.";
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_RealmFileUserStore_nativeGetCurrentUser (JNIEnv *env, jclass)
+{
+    TR_ENTER()
+    try {
+        const std::shared_ptr<SyncUser> &user = SyncManager::shared().get_current_user();
+        if (user) {
+            return to_jstring(env, user->refresh_token().data());
+        } else {
+            return nullptr;
+        }
+    } CATCH_STD()
+    return nullptr;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser (JNIEnv *env, jclass, jstring identity, jstring jsonToken, jstring url)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor user_identity(env, identity); // throws
+        JStringAccessor user_json_token(env, jsonToken); // throws
+        JStringAccessor auth_url(env, url); // throws
+
+        SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmFileUserStore_nativeLogoutCurrentUser (JNIEnv *env, jclass)
+{
+    TR_ENTER()
+    try {
+        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_current_user();
+        if (user) {
+            user->log_out();
+        } else {
+            throw std::runtime_error(ERR_NO_LOGGED_IN_USER);
+        }
+    } CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmFileUserStore_nativeConfigureMetaDataSystem (JNIEnv *env, jclass, jstring baseFile)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor base_file_path(env, baseFile); // throws
+        SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
+    } CATCH_STD()
+}
+
+JNIEXPORT jobjectArray JNICALL
+Java_io_realm_RealmFileUserStore_nativeGetAllUsers (JNIEnv *env, jclass)
+{
+    TR_ENTER()
+    std::vector<std::shared_ptr<SyncUser>> all_users = SyncManager::shared().all_logged_in_users();
+    if (!all_users.empty()) {
+        size_t len = all_users.size();
+        jobjectArray users_token = env->NewObjectArray(len, java_lang_string, 0);
+        if (users_token == nullptr) {
+            ThrowException(env, OutOfMemory, ERR_COULD_NOT_ALLOCATE_MEMORY);
+            return nullptr;
+        }
+        for (int i = 0; i < len; ++i) {
+            env->SetObjectArrayElement(users_token, i, to_jstring(env, all_users[i]->refresh_token().data()));
+        }
+
+        return users_token;
+    }
+    return nullptr;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmFileUserStore_nativeResetForTesting (JNIEnv *, jclass)
+{
+    TR_ENTER();
+    SyncManager::shared().reset_for_testing();
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
new file mode 100644
index 0000000000..a2227dacad
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_RealmObjectSchema.h"
+
+#include <object-store/src/object_schema.hpp>
+#include <object-store/src/property.hpp>
+
+#include "util.hpp"
+using namespace realm;
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv *env, jclass, jstring className_) {
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, className_);
+        ObjectSchema *object_schema = new ObjectSchema();
+        object_schema->name = name;
+        return reinterpret_cast<jlong>(object_schema);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv *env, jclass, jlong native_ptr) {
+    TR_ENTER_PTR(native_ptr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
+        delete object_schema;
+    }
+    CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv *env, jclass, jlong native_ptr, jlong property_ptr) {
+    TR_ENTER_PTR(native_ptr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
+        Property* property = reinterpret_cast<Property*>(property_ptr);
+        object_schema->persisted_properties.push_back(*property);
+        if (property->is_primary) {
+            object_schema->primary_key = property->name;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
+        auto name = object_schema->name;
+        return to_jstring(env, name);
+    }
+    CATCH_STD()
+
+    return NULL;
+}
+
+JNIEXPORT jlongArray JNICALL
+Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
+        size_t size = object_schema->persisted_properties.size();
+        jlongArray native_ptr_array = env->NewLongArray(static_cast<jsize>(size));
+        jlong* tmp = new jlong[size];
+        auto it = object_schema->persisted_properties.begin();
+        size_t index = 0;
+        while (it != object_schema->persisted_properties.end()) {
+            Property property = *it;
+            tmp[index] = reinterpret_cast<jlong>(new Property(std::move(property)));
+            ++index;
+            ++it;
+        }
+        env->SetLongArrayRegion(native_ptr_array, 0, static_cast<jsize>(size), tmp);
+        delete tmp;
+        return native_ptr_array;
+    }
+    CATCH_STD()
+
+    return NULL;
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
new file mode 100644
index 0000000000..9c6f1992e3
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_RealmSchema.h"
+
+#include <object-store/src/schema.hpp>
+#include <object-store/src/object_schema.hpp>
+#include <object-store/src/property.hpp>
+
+#include "util.hpp"
+using namespace realm;
+
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv *env, jclass, jlongArray objectSchemaPtrs_) {
+    TR_ENTER()
+    try {
+        std::vector<ObjectSchema> object_schemas;
+        JniLongArray array(env, objectSchemaPtrs_);
+        for (jsize i = 0; i < array.len(); ++i) {
+            ObjectSchema object_schema = *reinterpret_cast<ObjectSchema*>(array[i]);
+            object_schemas.push_back(std::move(object_schema));
+        }
+        auto *schema = new Schema(object_schemas);
+        return reinterpret_cast<jlong>(schema);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_RealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    Schema* schema = reinterpret_cast<Schema*>(nativePtr);
+    delete schema;
+}
+
+JNIEXPORT jlongArray JNICALL
+Java_io_realm_RealmSchema_nativeGetAll(JNIEnv *env, jclass, jlong nativePtr) {
+    TR_ENTER_PTR(nativePtr)
+    try {
+        Schema* schema = reinterpret_cast<Schema*>(nativePtr);
+        size_t size = schema->size();
+        jlongArray native_ptr_array = env->NewLongArray(static_cast<jsize>(size));
+        jlong* tmp = new jlong[size];
+        auto it = schema->begin();
+        size_t index = 0;
+        while (it != schema->end()) {
+            auto object_schema = *it;
+            tmp[index] = reinterpret_cast<jlong>(new ObjectSchema(std::move(object_schema)));
+            ++index;
+            ++it;
+        }
+        env->SetLongArrayRegion(native_ptr_array, 0, static_cast<jsize>(size), tmp);
+        delete tmp;
+        return native_ptr_array;
+    }
+    CATCH_STD()
+    return NULL;
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
new file mode 100644
index 0000000000..e7da1e400c
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <chrono>
+#include <functional>
+#include <mutex>
+#include <vector>
+
+#include <realm/group_shared.hpp>
+#include <realm/sync/history.hpp>
+#include <realm/sync/client.hpp>
+
+#include "objectserver_shared.hpp"
+
+#include "io_realm_SyncManager.h"
+
+#include "jni_util/log.hpp"
+
+using namespace realm;
+using namespace realm::sync;
+using namespace realm::jni_util;
+
+std::unique_ptr<Client> sync_client;
+
+static jclass sync_manager = nullptr;
+static jmethodID sync_manager_notify_error_handler = nullptr;
+
+static void error_handler(int error_code, std::string message)
+{
+    JNIEnv* env;
+    if (g_vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        throw std::runtime_error("JVM is not attached to this thread. Called in error_handler.");
+    }
+
+    env->CallStaticVoidMethod(sync_manager,
+                              sync_manager_notify_error_handler, error_code, env->NewStringUTF(message.c_str()));
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncClient
+    (JNIEnv *env, jclass sync_manager_class)
+{
+    TR_ENTER()
+    if (sync_client) return;
+
+    try {
+        sync::Client::Config config;
+        config.logger = &CoreLoggerBridge::shared();
+        sync_client = std::make_unique<Client>(std::move(config)); // Throws
+
+        // This function should only be called once, so below is safe.
+        sync_manager = reinterpret_cast<jclass>(env->NewGlobalRef(sync_manager_class));
+        sync_manager_notify_error_handler = env->GetStaticMethodID(sync_manager,
+                                                                   "notifyErrorHandler", "(ILjava/lang/String;)V");
+        sync_client->set_error_handler(error_handler);
+    } CATCH_STD()
+}
+
+// Create the thread from java side to avoid some strange errors when native throws.
+JNIEXPORT void JNICALL
+Java_io_realm_SyncManager_nativeRunClient(JNIEnv *env, jclass)
+{
+    try {
+        sync_client->run();
+    } CATCH_STD()
+}
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
similarity index 99%
rename from realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index e9116d021b..b419a697f6 100644
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -147,7 +147,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv* env, jclass obj, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
         return 0;
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
similarity index 93%
rename from realm/realm-jni/src/io_realm_internal_LinkView.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
index a2aaee63f6..119cdf30fb 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
@@ -19,12 +19,7 @@
 
 using namespace realm;
 
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
-  (JNIEnv*, jclass, jlong nativeLinkViewPtr)
-{
-    LangBindHelper::unbind_linklist_ptr(*LV(nativeLinkViewPtr));
-}
-
+static void finalize_link_view(jlong ptr);
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
@@ -44,16 +39,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
 
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
+  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong linkViewIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, pos)) {
+    if (!ROW_INDEX_VALID(env, *lv, linkViewIndex)) {
         return -1;
     }
     try {
         LinkViewRef lvr = *lv;
-        return lvr->get( S(pos) ).get_index();
+        return lvr->get(S(linkViewIndex)).get_index();
     } CATCH_STD()
     return 0;
 }
@@ -248,3 +243,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
         return lvr->remove_target_row( S(pos) );
     } CATCH_STD()
 }
+
+static void finalize_link_view(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    LangBindHelper::unbind_linklist_ptr(*LV(ptr));
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetFinalizerPtr
+  (JNIEnv *, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_link_view);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp
new file mode 100644
index 0000000000..ab5de83fc5
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_NativeObjectReference.cpp
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_NativeObjectReference.h"
+
+typedef void (*FinalizeFunc)(jlong);
+
+JNIEXPORT void JNICALL Java_io_realm_internal_NativeObjectReference_nativeCleanUp
+(JNIEnv *, jclass, jlong finalizer_ptr, jlong native_ptr) {
+    FinalizeFunc finalize_func = reinterpret_cast<FinalizeFunc>(finalizer_ptr);
+    finalize_func(native_ptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
new file mode 100644
index 0000000000..6c78f94da9
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -0,0 +1,442 @@
+#include "io_realm_internal_SharedRealm.h"
+#ifdef REALM_ENABLE_SYNC
+#include "object-store/src/sync/sync_manager.hpp"
+#include "object-store/src/sync/sync_config.hpp"
+#endif
+
+#include "object_store.hpp"
+#include "shared_realm.hpp"
+
+#include "java_binding_context.hpp"
+#include "util.hpp"
+#if REALM_ENABLE_SYNC
+#include "sync/sync_manager.hpp"
+#endif
+
+using namespace realm;
+using namespace realm::_impl;
+
+static_assert(SchemaMode::Automatic ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC), "");
+static_assert(SchemaMode::ReadOnly ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY), "");
+static_assert(SchemaMode::ResetFile ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_RESET_FILE), "");
+static_assert(SchemaMode::Additive ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_ADDITIVE), "");
+static_assert(SchemaMode::Manual ==
+              static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL), "");
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv *env, jclass, jstring temporary_directory_path)
+{
+    TR_ENTER()
+
+    try {
+        JStringAccessor path(env, temporary_directory_path); // throws
+        realm::set_temporary_directory(std::string(path)); // throws
+    } CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstring realm_path, jbyteArray key,
+        jbyte schema_mode, jboolean in_memory, jboolean cache, jboolean disable_format_upgrade,
+        jboolean auto_change_notification, jstring sync_server_url, jstring sync_user_token)
+{
+    TR_ENTER()
+
+    try {
+        JStringAccessor path(env, realm_path); // throws
+        JniByteArray key_array(env, key);
+        Realm::Config *config = new Realm::Config();
+        config->path = path;
+        config->encryption_key = key_array;
+        config->schema_mode = static_cast<SchemaMode>(schema_mode);
+        config->in_memory = in_memory;
+        config->cache = cache;
+        config->disable_format_upgrade = disable_format_upgrade;
+        config->automatic_change_notifications = auto_change_notification;
+#if REALM_ENABLE_SYNC
+        if (sync_server_url) {
+            config->force_sync_history = true;
+        }
+#endif
+        return reinterpret_cast<jlong>(config);
+    } CATCH_STD()
+
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv*, jclass, jlong config_ptr)
+{
+    TR_ENTER_PTR(config_ptr)
+
+    auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
+    delete config;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv *env, jclass, jlong config_ptr, jobject notifier)
+{
+    TR_ENTER_PTR(config_ptr)
+
+    auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
+    try {
+        auto shared_realm = Realm::get_shared_realm(*config);
+        shared_realm->m_binding_context = JavaBindingContext::create(env, notifier);
+        // advance_read needs to be handled by Java because of async query.
+        shared_realm->set_auto_refresh(false);
+        return reinterpret_cast<jlong>(new SharedRealm(std::move(shared_realm)));
+    } CATCH_STD()
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv*, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto ptr = reinterpret_cast<SharedRealm*>(shared_realm_ptr);
+    delete ptr;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->begin_transaction();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCommitTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->commit_transaction();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCancelTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->cancel_transaction();
+    } CATCH_STD()
+}
+
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv*, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return static_cast<jboolean>(shared_realm->is_in_transaction());
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv *env, jclass , jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return reinterpret_cast<jlong>(&shared_realm->read_group());
+    } CATCH_STD()
+
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        if (!shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Cannot set schema version when the realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return;
+        }
+
+        ObjectStore::set_schema_version(shared_realm->read_group(), static_cast<uint64_t>(version));
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jboolean>(ObjectStore::is_empty(shared_realm->read_group()));
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRefresh__J(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->refresh();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRefresh__JJJ(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version,
+        jlong index)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    SharedGroup::VersionID version_id(static_cast<SharedGroup::version_type>(version),
+                                     static_cast<uint32_t>(index));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        auto& shared_group = rf::get_shared_group(*shared_realm);
+        LangBindHelper::advance_read(shared_group, version_id);
+    } CATCH_STD()
+}
+
+JNIEXPORT jlongArray JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        SharedGroup::VersionID version_id = rf::get_shared_group(*shared_realm).get_version_of_current_transaction();
+
+        jlong version_array[2];
+        version_array[0] = static_cast<jlong>(version_id.version);
+        version_array[1] = static_cast<jlong>(version_id.index);
+
+        jlongArray version_data = env->NewLongArray(2);
+        if (version_data == NULL) {
+            ThrowException(env, OutOfMemory, "Could not allocate memory to return versionID.");
+            return NULL;
+        }
+        env->SetLongArrayRegion(version_data, 0, 2, version_array);
+
+        return version_data;
+    } CATCH_STD ()
+
+    return NULL;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv*, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return static_cast<jboolean>(shared_realm->is_closed());
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    try {
+        JStringAccessor name(env, table_name); // throws
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        if (!shared_realm->read_group().has_table(name) && !shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Class " << name << " doesn't exist and the shared Realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return static_cast<jlong>(NULL);
+        }
+        Table* pTable = LangBindHelper::get_or_add_table(shared_realm->read_group(), name);
+        return reinterpret_cast<jlong>(pTable);
+    } CATCH_STD()
+
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv *env, jclass, jlong shared_realm_ptr, jint index)
+{
+
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return to_jstring(env, shared_realm->read_group().get_table_name(static_cast<size_t>(index)));
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeHasTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor name(env, table_name);
+        return static_cast<jboolean>(shared_realm->read_group().has_table(name));
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv *env, jclass, jlong shared_realm_ptr,
+        jstring old_table_name, jstring new_table_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor old_name(env, old_table_name);
+        if (!shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Class " << old_name << " cannot be removed when the realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return;
+        }
+        JStringAccessor new_name(env, new_table_name);
+        shared_realm->read_group().rename_table(old_name, new_name);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor name(env, table_name);
+        if (!shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Class " << name << " cannot be removed when the realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return;
+        }
+        shared_realm->read_group().remove_table(name);
+    } CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jlong>(shared_realm->read_group().size());
+    } CATCH_STD()
+
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring path,
+        jbyteArray key)
+{
+    TR_ENTER_PTR(shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor path_str(env, path);
+        JniByteArray key_buffer(env, key);
+        shared_realm->write_copy(path_str, key_buffer);
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        return static_cast<jboolean>(rf::get_shared_group(*shared_realm).wait_for_change());
+    } CATCH_STD()
+
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        rf::get_shared_group(*shared_realm).wait_for_change_release();
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeCompact(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jboolean>(shared_realm->compact());
+    } CATCH_STD()
+
+    return JNI_FALSE;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetSnapshotVersion(JNIEnv *env, jclass, jlong sharedRealmPtr)
+{
+    TR_ENTER_PTR(sharedRealmPtr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(sharedRealmPtr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        auto& shared_group = rf::get_shared_group(*shared_realm);
+        return LangBindHelper::get_version_of_latest_snapshot(shared_group);
+    } CATCH_STD ()
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv *env, jclass, jlong nativePtr,
+                                                      jlong nativeSchemaPtr, jlong version) {
+    TR_ENTER()
+    try {
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
+        auto *schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
+        shared_realm->update_schema(*schema, static_cast<uint64_t>(version));
+    }
+    CATCH_STD()
+}
+
+
diff --git a/realm/realm-jni/src/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
similarity index 91%
rename from realm/realm-jni/src/io_realm_internal_Table.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index c62da6716e..9c697bdca5 100644
--- a/realm/realm-jni/src/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -18,12 +18,13 @@
 
 #include "util.hpp"
 #include "io_realm_internal_Table.h"
-#include "java_lang_List_Util.hpp"
 #include "tablebase_tpl.hpp"
 
 using namespace std;
 using namespace realm;
 
+static void finalize_table(jlong ptr);
+
 inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type) {
     if (!(column_type == type_String ||
                 column_type == type_Int ||
@@ -393,13 +394,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
     } CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
-  (JNIEnv *, jobject, jlong nativeTablePtr)
-{
-    //If the spec is shared, it is a subtable, and this method will return false
-    return !TBL(nativeTablePtr)->has_shared_type();
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize(
     JNIEnv* env, jobject, jlong nativeTablePtr)
 {
@@ -623,61 +617,77 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
     return 0;
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNull
+        (JNIEnv*, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+{
+    return TBL(nativeTablePtr)->is_null( S(columnIndex), S(rowIndex)) ? JNI_TRUE : JNI_FALSE;  // noexcept
+}
 
 // ----------------- Set cell
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex)
+  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
         return;
     try {
-        TBL(nativeTablePtr)->set_link( S(columnIndex), S(rowIndex), S(targetRowIndex));
+        TBL(nativeTablePtr)->set_link( S(columnIndex), S(rowIndex), S(targetRowIndex), B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value, jboolean isDefault)
+{
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
+        return;
+    try {
+        TBL(nativeTablePtr)->set_int( S(columnIndex), S(rowIndex), value, B(isDefault));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
+                                                 jlong rowIndex, jlong value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
         return;
     try {
-        TBL(nativeTablePtr)->set_int( S(columnIndex), S(rowIndex), value);
+        TBL(nativeTablePtr)->set_int_unique( S(columnIndex), S(rowIndex), value);
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
         return;
     try {
-        TBL(nativeTablePtr)->set_bool( S(columnIndex), S(rowIndex), value == JNI_TRUE ? true : false);
+        TBL(nativeTablePtr)->set_bool( S(columnIndex), S(rowIndex), B(value), B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
         return;
     try {
-        TBL(nativeTablePtr)->set_float( S(columnIndex), S(rowIndex), value);
+        TBL(nativeTablePtr)->set_float( S(columnIndex), S(rowIndex), value, B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
         return;
     try {
-        TBL(nativeTablePtr)->set_double( S(columnIndex), S(rowIndex), value);
+        TBL(nativeTablePtr)->set_double( S(columnIndex), S(rowIndex), value, B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
         return;
@@ -688,17 +698,37 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
             }
         }
         JStringAccessor value2(env, value); // throws
-        TBL(nativeTablePtr)->set_string( S(columnIndex), S(rowIndex), value2);
+        TBL(nativeTablePtr)->set_string( S(columnIndex), S(rowIndex), value2, B(isDefault));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
+                                                   jlong rowIndex, jstring value)
+{
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
+        return;
+    try {
+        if (value == NULL) {
+            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+                return;
+            }
+            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), null{});
+        } else {
+            JStringAccessor value2(env, value); // throws
+            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
+        }
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return;
     try {
-        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
+        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue),
+                                            B(isDefault));
     } CATCH_STD()
 }
 
@@ -715,25 +745,38 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteBuffer(
 */
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray, jboolean isDefault)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
         return;
     try {
-        if (dataArray == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+        if (dataArray == NULL && !TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
                 return;
-            }
-            TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), BinaryData());
-        }
-        else {
-            tbl_nativeDoByteArray(&Table::set_binary, TBL(nativeTablePtr), env, columnIndex, rowIndex, dataArray);
         }
+
+        JniByteArray byteAccessor(env, dataArray);
+        TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), byteAccessor, B(isDefault));
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
-    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean isDefault)
+{
+    Table* pTable = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+        return;
+    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex))
+        return;
+    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
+        return;
+    try {
+        pTable->set_null(S(columnIndex), S(rowIndex), B(isDefault));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Table_nativeSetNullUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
+                                                 jlong rowIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
@@ -743,10 +786,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
     if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex))
         return;
     try {
-        pTable->set_null(S(columnIndex), S(rowIndex));
+        pTable->set_null_unique(S(columnIndex), S(rowIndex));
     } CATCH_STD()
 }
 
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
   (JNIEnv* env, jobject, jlong nativeTablePtr, jlong index)
 {
@@ -1272,31 +1316,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jboolean ascending)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
-        return 0;
-    int colType = pTable->get_column_type( S(columnIndex) );
-    switch (colType) {
-        case type_Int:
-        case type_Bool:
-        case type_String:
-        case type_Double:
-        case type_Float:
-        case type_Timestamp:
-            try {
-                TableView* pTableView = new TableView( pTable->get_sorted_view(S(columnIndex), ascending != 0 ? true : false) );
-                return reinterpret_cast<jlong>(pTableView);
-            } CATCH_STD()
-        default:
-            ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
-            return 0;
-    }
-    return 0;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
    JNIEnv *env, jobject, jlong nativeTablePtr, jlongArray columnIndices, jbooleanArray ascending)
 {
@@ -1351,16 +1370,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return;
-    try {
-        TBL(nativeTablePtr)->optimize();
-    } CATCH_STD()
-}
-
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(
     JNIEnv *env, jobject, jlong nativeTablePtr)
 {
@@ -1394,15 +1403,9 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(
     JNIEnv*, jobject, jlong nativeTablePtr)
-{
-    return TBL(nativeTablePtr)->is_attached();  // noexcept
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose(
-    JNIEnv*, jclass, jlong nativeTablePtr)
 {
     TR_ENTER_PTR(nativeTablePtr)
-    LangBindHelper::unbind_table_ptr(TBL(nativeTablePtr));
+    return TBL(nativeTablePtr)->is_attached();  // noexcept
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv *env, jobject)
@@ -1495,7 +1498,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
                 // No primary key is currently set
                 if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
                     row_index = pk_table->add_empty_row();
-                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index, table_name);
+                    pk_table->set_string_unique(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index, table_name);
                     pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
                 }
             }
@@ -1528,17 +1531,23 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
 // - All Realms created by Cocoa and used by Realm-android up to 0.84.1
 // - All Realms created by Realm-Android 0.84.1 and below
 // See https://github.com/realm/realm-java/issues/1703
+//
+// 3> PK table's column 'pk_table' needs search index in order to use set_string_unique.
+// This affects:
+// - All Realms created by Cocoa and used by Realm-java before 2.0.0
+// See https://github.com/realm/realm-java/pull/3488
 
 // This methods converts the old (wrong) table format (string, integer) to the right (string,string) format and strips
 // any class names in the col[0] of their "class_" prefix
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
-    (JNIEnv*, jobject, jlong groupNativePtr, jlong privateKeyTableNativePtr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
+    (JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
 {
     const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
     const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
 
-    Group* group = G(groupNativePtr);
+    auto group = reinterpret_cast<Group*>(groupNativePtr);
     Table* pk_table = TBL(privateKeyTableNativePtr);
+    jboolean changed = JNI_FALSE;
 
     // Fix wrong types (string, int) -> (string, string)
     if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
@@ -1559,6 +1568,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
         // The column index for the renamed column will then be the same as the deleted old column
         pk_table->remove_column(FIELD_COLUMN_INDEX);
         pk_table->rename_column(pk_table->get_column_index(tmp_col_name), StringData("pk_property"));
+        changed = JNI_TRUE;
     }
 
     // If needed remove "class_" prefix from class names
@@ -1570,12 +1580,49 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
             std::string str(table_name.substr(TABLE_PREFIX.length()));
             StringData sd(str);
             pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, sd);
+            changed = JNI_TRUE;
+        }
+    }
+
+    // From realm-java 2.0.0, pk table's class column requires a search index.
+    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
+        pk_table->add_search_index(CLASS_COLUMN_INDEX);
+        changed = JNI_TRUE;
+    }
+    return changed;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv *, jclass, jlong primaryKeyTableNativePtr)
+{
+
+    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
+    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
+
+    Table* pk_table = TBL(primaryKeyTableNativePtr);
+
+    // Fix wrong types (string, int) -> (string, string)
+    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
+        return JNI_TRUE;
+    }
+
+    // If needed remove "class_" prefix from class names
+    size_t number_of_rows = pk_table->size();
+    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
+        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
+        if (table_name.begins_with(TABLE_PREFIX)) {
+            return JNI_TRUE;
         }
     }
+    // From realm-java 2.0.0, pk table's class column requires a search index.
+    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
+        return JNI_TRUE;
+    }
+    return JNI_FALSE;
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
-  (JNIEnv *, jobject, jlong thisTablePtr, jlong otherTablePtr)
+  (JNIEnv*, jobject, jlong thisTablePtr, jlong otherTablePtr)
 {
     return *TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor();
 }
@@ -1587,7 +1634,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
     bool valid = (TBL(nativeTablePtr) != NULL);
     if (valid) {
         if (!TBL(nativeTablePtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
             return 0;
         }
     }
@@ -1596,3 +1643,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
     } CATCH_STD()
     return 0;
 }
+
+static void finalize_table(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    LangBindHelper::unbind_table_ptr(TBL(ptr));
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetFinalizerPtr
+  (JNIEnv *, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_table);
+}
+
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
similarity index 90%
rename from realm/realm-jni/src/io_realm_internal_TableQuery.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index b1913cb615..690bb7b3d2 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -16,7 +16,8 @@
 
 #include <realm.hpp>
 #include <realm/group_shared.hpp>
-#include <realm/commit_log.hpp>
+#include <shared_realm.hpp>
+#include <object_store.hpp>
 #include "util.hpp"
 #include "io_realm_internal_TableQuery.h"
 
@@ -30,6 +31,8 @@ using namespace realm;
 #define QUERY_VALID(env, pQuery)                    (true)
 #endif
 
+static void finalize_table_query(jlong ptr);
+
 inline bool query_valid(JNIEnv* env, Query* pQuery)
 {
     return TABLE_VALID(env, pQuery->get_table().get());
@@ -45,11 +48,6 @@ const char* ERR_IMPORT_CLOSED_REALM = "Can not import results from a closed Real
 const char* ERR_SORT_NOT_SUPPORTED = "Sort is not supported on binary data, object references and RealmList";
 //-------------------------------------------------------
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose(JNIEnv *, jclass, jlong nativeQueryPtr) {
-    TR_ENTER_PTR(nativeQueryPtr)
-    delete Q(nativeQueryPtr);
-}
-
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
 (JNIEnv *env, jobject, jlong nativeQueryPtr)
 {
@@ -84,7 +82,7 @@ static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray
     return table_ref;
 }
 
-static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
+static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
 {
     TR_ENTER()
     TableRef table = query.get()->get_table();
@@ -96,13 +94,14 @@ static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedGroupPtr, std::uniqu
     TableView tableView(query->find_all(S(start), S(end), S(limit)));
 
     // handover the result
-    std::unique_ptr<SharedGroup::Handover<TableView>> handover = SG(
-            bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+    using rf = realm::_impl::RealmFriend;
+    auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
     return reinterpret_cast<jlong>(handover.release());
 }
 
 static jlong getDistinctViewWithHandover
-        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong columnIndex)
+        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong columnIndex)
 {
         TableRef table = query->get_table();
         if (!QUERY_VALID(env, query.get()) ||
@@ -114,11 +113,14 @@ static jlong getDistinctViewWithHandover
             case type_Int:
             case type_Timestamp:
             case type_String: {
-                TableView tableView(table->get_distinct_view(S(columnIndex)) );
+                TableView tableView(query->find_all());
+                tableView.distinct(S(columnIndex));
 
                 // handover the result
-                std::unique_ptr<SharedGroup::Handover<TableView>> handover = SG(
-                        bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+                auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+                using rf = realm::_impl::RealmFriend;
+                auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(
+                        tableView, MutableSourcePayload::Move);
                 return reinterpret_cast<jlong>(handover.release());
             }
             default:
@@ -129,7 +131,7 @@ static jlong getDistinctViewWithHandover
 }
 
 static jlong findAllSortedWithHandover
-        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
 {
         TableRef table =  query->get_table();
 
@@ -161,72 +163,75 @@ static jlong findAllSortedWithHandover
         }
 
         // handover the result
-        std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+        using rf = realm::_impl::RealmFriend;
+        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
         return reinterpret_cast<jlong>(handover.release());
 }
 
 static jlong findAllMultiSortedWithHandover
-        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
 {
-        JniLongArray long_arr(env, columnIndices);
-        JniBooleanArray bool_arr(env, ascending);
-        jsize arr_len = long_arr.len();
-        jsize asc_len = bool_arr.len();
+    JniLongArray long_arr(env, columnIndices);
+    JniBooleanArray bool_arr(env, ascending);
+    jsize arr_len = long_arr.len();
+    jsize asc_len = bool_arr.len();
 
-        if (arr_len == 0) {
-            ThrowException(env, IllegalArgument, "You must provide at least one field name.");
-            return 0;
-        }
-        if (asc_len == 0) {
-            ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
-            return 0;
-        }
-        if (arr_len != asc_len) {
-            ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
-            return 0;
-        }
+    if (arr_len == 0) {
+        ThrowException(env, IllegalArgument, "You must provide at least one field name.");
+        return 0;
+    }
+    if (asc_len == 0) {
+        ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
+        return 0;
+    }
+    if (arr_len != asc_len) {
+        ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
+        return 0;
+    }
 
-        TableRef table = query->get_table();
+    TableRef table = query->get_table();
 
-        if (!QUERY_VALID(env, query.get()) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
-            return 0;
-        }
+    if (!QUERY_VALID(env, query.get()) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
+        return 0;
+    }
 
-        // run the query
-        TableView tableView( query->find_all(S(start), S(end), S(limit)) );
+    // run the query
+    TableView tableView( query->find_all(S(start), S(end), S(limit)) );
 
-        // sorting the results
-        std::vector<std::vector<size_t>> indices;
-        std::vector<bool> ascendings;
-        for (int i = 0; i < arr_len; ++i) {
-            if (!COL_INDEX_VALID(env, &tableView, long_arr[i])) {
-                return -1;
-            }
-            int colType = tableView.get_column_type( S(long_arr[i]) );
-            switch (colType) {
-                case type_Bool:
-                case type_Int:
-                case type_Float:
-                case type_Double:
-                case type_String:
-                case type_Timestamp:
-                    indices.push_back(std::vector<size_t> { S(long_arr[i]) });
-                    ascendings.push_back( B(bool_arr[i]) );
-                    break;
-                default:
-                    ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
-                    return 0;
-            }
+    // sorting the results
+    std::vector<std::vector<size_t>> indices;
+    std::vector<bool> ascendings;
+    for (int i = 0; i < arr_len; ++i) {
+        if (!COL_INDEX_VALID(env, &tableView, long_arr[i])) {
+            return -1;
         }
+        int colType = tableView.get_column_type( S(long_arr[i]) );
+        switch (colType) {
+            case type_Bool:
+            case type_Int:
+            case type_Float:
+            case type_Double:
+            case type_String:
+            case type_Timestamp:
+                indices.push_back(std::vector<size_t> { S(long_arr[i]) });
+                ascendings.push_back( B(bool_arr[i]) );
+                break;
+            default:
+                ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
+                return 0;
+        }
+    }
 
-        tableView.sort(SortDescriptor(*table, indices, ascendings));
+    tableView.sort(SortDescriptor(*table, indices, ascendings));
 
-        // handover the result
-        std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
-        return reinterpret_cast<jlong>(handover.release());
+    // handover the result
+    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+    using rf = realm::_impl::RealmFriend;
+    auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
+    return reinterpret_cast<jlong>(handover.release());
 }
 
-
 template <typename coretype, typename cpptype, typename javatype>
 Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value) {
     return tbl->column<coretype>(size_t(columnIndex)) == cpptype(value);
@@ -1066,9 +1071,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
     return -1;
 }
 
-// Returns a pointer to query on the worker SharedGroup or throw a BadVersion if the SharedGroup version required
+// Returns a pointer to query on the worker SharedRealm or throw a BadVersion if the SharedRealm version required
 // for the handover is no longer available.
-static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
+static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedRealmPtr, jlong queryPtr, bool advanceToLatestVersion)
 {
     SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, queryPtr);
     std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
@@ -1076,19 +1081,13 @@ static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlon
     // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
     // cases this means that the version in the Handover object is invalid and Realm Core will throw a
     // BadVersion as result.
-    realm::SharedGroup* sg = SG(bgSharedGroupPtr);
-    if (sg->get_transact_stage() != SharedGroup::transact_Reading) {
-        // if the SharedGroup is not in Read Transaction, we position it at the same version as the handover
-        sg->begin_read(handoverQuery->version);
-    } else if (sg->get_version_of_current_transaction() != handoverQuery->version) {
-        sg->end_read();
-        sg->begin_read(handoverQuery->version);
-    }
-
-    std::unique_ptr<Query> query = sg->import_from_handover(std::move(handoverQuery));
+    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+    using rf = realm::_impl::RealmFriend;
+    rf::read_group_to(*sharedRealm, handoverQuery->version);
+    auto query = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
 
     if (advanceToLatestVersion) {
-        LangBindHelper::advance_read(*sg);
+        sharedRealm->refresh();
     }
 
     return query;
@@ -1096,11 +1095,11 @@ static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlon
 
 // queryPtr would be owned and released by this function
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
-    JNIEnv* env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong fromTableRow)
+    JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong fromTableRow)
 {
     TR_ENTER()
     try {
-        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, false); // throws
+        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, false); // throws
         TableRef table = query->get_table();
 
         if (!QUERY_VALID(env, query.get())) {
@@ -1120,8 +1119,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
         } else {
             // handover the result
             Row row = (*table)[r];
-            std::unique_ptr<SharedGroup::Handover<Row>> handover = SG(
-                    bgSharedGroupPtr)->export_for_handover(row);
+            auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+            using rf = realm::_impl::RealmFriend;
+            auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(row);
             return reinterpret_cast<jlong>(handover.release());
         }
 
@@ -1148,12 +1148,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
 
 // queryPtr would be owned and released by this function
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv* env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
+  (JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
   {
       TR_ENTER()
       try {
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-          return findAllWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+          return findAllWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit);
       } CATCH_STD()
       return 0;
   }
@@ -1165,7 +1165,7 @@ enum query_type {QUERY_TYPE_FIND_ALL = 0, QUERY_TYPE_DISTINCT = 4, QUERY_TYPE_FI
 
 // batch update of async queries
 JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-        (JNIEnv *env, jclass, jlong bgSharedGroupPtr,
+        (JNIEnv *env, jclass, jlong bgSharedRealmPtr,
          jlongArray  handover_queries_array /*list of handover queries*/,
          jobjectArray  query_param_matrix /*type & params of the query to be updated*/,
          jobjectArray  multi_sorted_indices_matrix,
@@ -1188,37 +1188,37 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
         // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
         // cases this means that the version in the Handover object is invalid and Realm Core will throw a
         // BadVersion as result.
-        realm::SharedGroup* sg = SG(bgSharedGroupPtr);
-        if (sg->get_transact_stage() != SharedGroup::transact_Reading) {
-            sg->begin_read(handoverQuery->version);
-        } else if (sg->get_version_of_current_transaction() != handoverQuery->version) {
-            sg->end_read();
-            sg->begin_read(handoverQuery->version);
-        }
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+        using rf = realm::_impl::RealmFriend;
+        rf::read_group_to(*sharedRealm, handoverQuery->version);
 
         std::vector<std::unique_ptr<Query>> queries(number_of_queries);
 
         // import the first query
-        queries[0] = sg->import_from_handover(std::move(handoverQuery));
+        queries[0] = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
 
         // import the rest of the queries
         for (size_t i = 1; i < number_of_queries; ++i) {
             std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(HO(Query, handover_queries_pointer_array[i]));
-            queries[i] = sg->import_from_handover(std::move(handoverQuery));
+            using rf = realm::_impl::RealmFriend;
+            queries[i] = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
         }
 
         // Step2: Bring the queries into the latest shared group version
-        LangBindHelper::advance_read(*sg);
+        sharedRealm->refresh();
 
         // Step3: Run & export the queries against the latest shared group
         for (size_t i = 0; i < number_of_queries; ++i) {
-            JniLongArray query_param_array(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
+            // Delete the local ref since we might have a long loop
+            JniLocalRef<jlongArray> local_ref(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
+            JniLongArray query_param_array(env, local_ref);
+
             switch (query_param_array[0]) { // 0, index of the type of query, the next indicies are parameters
                 case QUERY_TYPE_FIND_ALL: {// nativeFindAllWithHandover
                     exported_handover_tableview_array[i] =
                             findAllWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*start*/,
                                      query_param_array[2]/*end*/,
@@ -1229,7 +1229,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
                     exported_handover_tableview_array[i] =
                             getDistinctViewWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*columnIndex*/);
                     break;
@@ -1238,7 +1238,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
                     exported_handover_tableview_array[i] =
                             findAllSortedWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*start*/,
                                      query_param_array[2]/*end*/,
@@ -1255,7 +1255,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
                     exported_handover_tableview_array[i] =
                             findAllMultiSortedWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*start*/,
                                      query_param_array[2]/*end*/,
@@ -1285,35 +1285,35 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
 
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-        (JNIEnv *env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong columnIndex)
+        (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong columnIndex)
 {
     TR_ENTER()
     try {
-        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-        return getDistinctViewWithHandover(env, bgSharedGroupPtr, std::move(query), columnIndex);
+        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+        return getDistinctViewWithHandover(env, bgSharedRealmPtr, std::move(query), columnIndex);
     } CATCH_STD()
     return 0;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+  (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
   {
       TR_ENTER()
       try {
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-          return findAllSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit, columnIndex, ascending);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+          return findAllSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit, columnIndex, ascending);
       } CATCH_STD()
       return 0;
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+  (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
   {
       TR_ENTER()
       try {
-          // import the handover query pointer using the background SharedGroup
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-          return findAllMultiSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit,columnIndices, ascending);
+          // import the handover query pointer using the background SharedRealm
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+          return findAllMultiSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit,columnIndices, ascending);
       } CATCH_STD()
       return 0;
   }
@@ -1610,15 +1610,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery))
         return 0;
     try {
-        return pQuery->remove(S(start), S(end), S(limit));
+        return pQuery->remove();
     } CATCH_STD()
     return 0;
 }
@@ -1714,9 +1712,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTa
     std::unique_ptr<SharedGroup::Handover<TableView>> handoverTableView(handoverTableViewPtr);
     try {
         // import_from_handover will free (delete) the handover
-        if (SG(callerSharedGrpPtr)->is_attached()) {
-            std::unique_ptr<TableView> tableView = SG(callerSharedGrpPtr)->import_from_handover(
-                    std::move(handoverTableView));
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
+        if (!sharedRealm->is_closed()) {
+            using rf = realm::_impl::RealmFriend;
+            auto tableView = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverTableView));
             return reinterpret_cast<jlong>(tableView.release());
         } else {
             ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
@@ -1734,9 +1733,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRo
 
       try {
           // import_from_handover will free (delete) the handover
-          if (SG(callerSharedGrpPtr)->is_attached()) {
-              std::unique_ptr<Row> row = SG(callerSharedGrpPtr)->import_from_handover(
-                      std::move(handoverRow));
+          auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
+          if (!sharedRealm->is_closed()) {
+              using rf = realm::_impl::RealmFriend;
+              auto row = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverRow));
               return reinterpret_cast<jlong>(row.release());
           } else {
               ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
@@ -1746,22 +1746,24 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRo
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
-   (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong nativeQueryPtr)
+   (JNIEnv* env, jobject, jlong bgSharedRealmPtr, jlong nativeQueryPtr)
 {
     TR_ENTER_PTR(nativeQueryPtr)
     Query* pQuery = Q(nativeQueryPtr);
     if (!QUERY_VALID(env, pQuery))
         return 0;
     try {
-        std::unique_ptr<SharedGroup::Handover<Query> > handoverQueryPtr = SG(bgSharedGroupPtr)->export_for_handover(*pQuery, ConstSourcePayload::Copy);
-        return reinterpret_cast<jlong>(handoverQueryPtr.release());
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+        using rf = realm::_impl::RealmFriend;
+        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(*pQuery, ConstSourcePayload::Copy);
+        return reinterpret_cast<jlong>(handover.release());
     } CATCH_STD()
     return 0;
 }
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv *, jclass, jlong nativeHandoverQuery)
+  (JNIEnv*, jclass, jlong nativeHandoverQuery)
   {
     TR_ENTER_PTR(nativeHandoverQuery)
     delete HO(Query, nativeHandoverQuery);
@@ -1907,3 +1909,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
         }
     } CATCH_STD()
 }
+
+static void finalize_table_query(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete Q(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetFinalizerPtr
+  (JNIEnv *, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_table_query);
+}
+
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
similarity index 97%
rename from realm/realm-jni/src/io_realm_internal_TableView.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
index ba1bfc78b2..563054f643 100644
--- a/realm/realm-jni/src/io_realm_internal_TableView.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
@@ -25,11 +25,13 @@ using namespace realm;
 // if you disable the validation, please remember to call sync_in_needed() 
 #define VIEW_VALID_AND_IN_SYNC(env, ptr) view_valid_and_in_sync(env, ptr)
 
+static void finalize_table_view(jlong ptr);
+
 inline bool view_valid_and_in_sync(JNIEnv* env, jlong nativeViewPtr) {
     bool valid = (TV(nativeViewPtr) != NULL);
     if (valid) {
         if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
             return false;
         }
         // depends_on_deleted_linklist() will return true if and only if the current TableView was created from a
@@ -148,15 +150,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClose(
-    JNIEnv*, jclass, jlong nativeViewPtr)
-{
-    if (nativeViewPtr == 0)
-        return;
-
-    delete TV(nativeViewPtr);
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSize(
     JNIEnv* env, jobject, jlong nativeViewPtr)
 {
@@ -317,6 +310,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
     return TV(nativeViewPtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNull
+        (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
+{
+    try {
+        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
+            return 0;
+        return TV(nativeViewPtr)->get_parent().is_null( S(columnIndex), TV(nativeViewPtr)->get_source_ndx(S(rowIndex))) ? JNI_TRUE : JNI_FALSE;  // noexcept
+    } CATCH_STD()
+    return 0;
+}
+
 // Setters
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong(
@@ -397,7 +401,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
             return;
-        tbl_nativeDoByteArray(&TableView::set_binary, TV(nativeViewPtr), env, columnIndex, rowIndex, byteArray);
+
+        JniByteArray bytesAccessor(env, byteArray);
+        TV(nativeViewPtr)->set_binary(S(columnIndex), S(rowIndex), bytesAccessor);
     } CATCH_STD()
 }
 
@@ -616,9 +622,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString(
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_String))
             return 0;
         JStringAccessor value2(env, value); // throws
-        TR("nativeFindAllString(col %" PRId64 ", string '%s') ", S64(columnIndex), StringData(value2).data())
         TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_string( S(columnIndex), value2) );
-        TR("-- resultview size=%" PRId64 ".", S64(pResultView->size()))
         return reinterpret_cast<jlong>(pResultView);
     } CATCH_STD()
     return 0;
@@ -951,7 +955,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded(
     bool valid = (TV(nativeViewPtr) != NULL);
     if (valid) {
         if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
             return 0;
         }
     }
@@ -974,3 +978,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
     } CATCH_STD()
     return -1;
 }
+
+static void finalize_table_view(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete TV(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetFinalizerPtr
+  (JNIEnv *, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_table_view);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
new file mode 100644
index 0000000000..a5b34275c4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
@@ -0,0 +1,85 @@
+#include "io_realm_internal_TestUtil.h"
+#include "util.hpp"
+
+static jstring throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw);
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_TestUtil_getMaxExceptionNumber(JNIEnv*, jclass)
+{
+    return ExceptionKindMax;
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_internal_TestUtil_getExpectedMessage(JNIEnv *env, jclass, jlong exception_kind)
+{
+    return throwOrGetExpectedMessage(env, exception_kind, false);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_TestUtil_testThrowExceptions(JNIEnv *env, jclass, jlong exception_kind)
+{
+    throwOrGetExpectedMessage(env, exception_kind, true);
+}
+
+static jstring
+throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw)
+{
+    std::string expect;
+
+    switch (ExceptionKind(testcase)) {
+        case ClassNotFound:
+            expect = "java.lang.ClassNotFoundException: Class 'parm1' could not be located.";
+            if (should_throw)
+                ThrowException(env, ClassNotFound, "parm1", "parm2");
+            break;
+        case IllegalArgument:
+            expect = "java.lang.IllegalArgumentException: Illegal Argument: parm1";
+            if (should_throw)
+                ThrowException(env, IllegalArgument, "parm1", "parm2");
+            break;
+        case IndexOutOfBounds:
+            expect = "java.lang.ArrayIndexOutOfBoundsException: parm1";
+            if (should_throw)
+                ThrowException(env, IndexOutOfBounds, "parm1", "parm2");
+            break;
+        case UnsupportedOperation:
+            expect = "java.lang.UnsupportedOperationException: parm1";
+            if (should_throw)
+                ThrowException(env, UnsupportedOperation, "parm1", "parm2");
+            break;
+        case OutOfMemory:
+            expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
+            if (should_throw)
+                ThrowException(env, OutOfMemory, "parm1", "parm2");
+            break;
+        case FatalError:
+            expect = "io.realm.exceptions.RealmError: Unrecoverable error. parm1";
+            if (should_throw)
+                ThrowException(env, FatalError, "parm1", "parm2");
+            break;
+        case RuntimeError:
+            expect = "java.lang.RuntimeException: parm1";
+            if (should_throw)
+                ThrowException(env, RuntimeError, "parm1", "parm2");
+            break;
+        case BadVersion:
+            expect = "io.realm.internal.async.BadVersionException: parm1";
+            if (should_throw)
+                ThrowException(env, BadVersion, "parm1", "parm2");
+            break;
+        case IllegalState:
+            expect = "java.lang.IllegalStateException: parm1";
+            if (should_throw)
+                ThrowException(env, IllegalState, "parm1");
+            break;
+        // FIXME: This is difficult to test right now. Need to refactor the test.
+        // See https://github.com/realm/realm-java/issues/3348
+        // case RealmFileError:
+        default:
+            break;
+    }
+    if (should_throw) {
+        return NULL;
+    }
+    return to_jstring(env, expect);
+}
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
similarity index 95%
rename from realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index 908ef25fe4..b55fdc68e2 100644
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -19,8 +19,10 @@
 
 using namespace realm;
 
+static void finalize_unchecked_row(jlong ptr);
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong nativeRowPtr)
+  (JNIEnv*, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
@@ -184,7 +186,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv* env, jclass, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
@@ -328,15 +330,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
-  (JNIEnv *, jclass, jlong nativeRowPtr)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    delete ROW(nativeRowPtr);
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
-  (JNIEnv *, jobject, jlong nativeRowPtr)
+  (JNIEnv*, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     return ROW(nativeRowPtr)->is_attached();
@@ -350,7 +345,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
-  (JNIEnv *, jobject, jlong nativeRowPtr, jlong columnIndex) {
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex) {
     TR_ENTER_PTR(nativeRowPtr)
     return ROW(nativeRowPtr)->is_null(columnIndex);
 }
@@ -366,3 +361,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
         ROW(nativeRowPtr)->set_null(columnIndex);
     } CATCH_STD()
 }
+
+static void finalize_unchecked_row(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete ROW(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFinalizerPtr
+  (JNIEnv *, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_unchecked_row);
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
new file mode 100644
index 0000000000..03bb3284a0
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <realm/string_data.hpp>
+#include <realm/unicode.hpp>
+
+#include "mem_usage.hpp"
+#include "util.hpp"
+
+using std::string;
+
+//#define USE_VLD
+#if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
+    #include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
+#endif
+
+const string TABLE_PREFIX("class_");
+
+
+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
+{
+    JNIEnv* env;
+    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return JNI_ERR;
+    }
+    else {
+        g_vm = vm;
+        // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
+        java_lang_long        = GetClass(env, "java/lang/Long");
+        java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
+        java_lang_float       = GetClass(env, "java/lang/Float");
+        java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
+        java_lang_double      = GetClass(env, "java/lang/Double");
+        java_lang_string      = GetClass(env, "java/lang/String");
+        java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
+    }
+
+    return JNI_VERSION_1_6;
+}
+
+JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
+{
+    JNIEnv* env;
+    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return;
+    }
+    else {
+        env->DeleteGlobalRef(java_lang_long);
+        env->DeleteGlobalRef(java_lang_float);
+        env->DeleteGlobalRef(java_lang_double);
+        env->DeleteGlobalRef(java_lang_string);
+    }
+}
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
+{
+    return GetMemUsage();
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
+    JNIEnv* env, jclass)
+{
+    realm::StringData sd(TABLE_PREFIX);
+    return to_jstring(env, sd);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
new file mode 100644
index 0000000000..ea0ebecc4a
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include "io_realm_internal_objectserver_ObjectServerSession.h"
+#include "objectserver_shared.hpp"
+#include "util.hpp"
+#include <realm/group_shared.hpp>
+#include <realm/replication.hpp>
+
+#include <realm/sync/history.hpp>
+#include <realm/sync/client.hpp>
+#include <realm/util/logger.hpp>
+#include <mutex>
+#include <thread>
+#include <vector>
+#include <chrono>
+#include <functional>
+#include <android/log.h>
+
+using namespace std;
+using namespace realm;
+using namespace sync;
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeCreateSession
+  (JNIEnv *env, jobject obj, jstring localRealmPath)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_path(env, localRealmPath);
+        JniSession* jni_session = new JniSession(env, local_path, obj);
+        return reinterpret_cast<jlong>(jni_session);
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeBind
+  (JNIEnv *env, jobject, jlong sessionPointer, jstring remoteUrl, jstring accessToken)
+{
+    TR_ENTER()
+    try {
+        auto *session_wrapper = reinterpret_cast<JniSession*>(sessionPointer);
+
+        const char *token_tmp = env->GetStringUTFChars(accessToken, NULL);
+        std::string access_token(token_tmp);
+        env->ReleaseStringUTFChars(accessToken, token_tmp);
+
+        JStringAccessor url_tmp(env, remoteUrl); // throws
+        StringData remote_url = StringData(url_tmp);
+
+        // Bind the local Realm to the remote one
+        session_wrapper->get_session()->bind(remote_url, access_token);
+    } CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeUnbind
+  (JNIEnv *env, jobject, jlong sessionPointer)
+{
+    TR_ENTER()
+    JniSession* session = SS(sessionPointer);
+    session->close(env);
+    delete session; // TODO Can we avoid killing the session here?
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeRefresh
+  (JNIEnv *env, jobject, jlong sessionPointer, jstring accessToken)
+{
+    TR_ENTER()
+    try {
+        JniSession* session_wrapper = SS(sessionPointer);
+
+        JStringAccessor token_tmp(env, accessToken); // throws
+        StringData access_token = StringData(token_tmp);
+
+        session_wrapper->get_session()->refresh(access_token);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_objectserver_ObjectServerSession_nativeNotifyCommitHappened
+  (JNIEnv *env, jobject, jlong sessionPointer, jlong version)
+{
+    TR_ENTER()
+    try {
+        JniSession* session_wrapper = SS(sessionPointer);
+        session_wrapper->get_session()->nonsync_transact_notify(version);
+    } CATCH_STD()
+}
+
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
new file mode 100644
index 0000000000..45aa8a72c2
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_log_RealmLog.cpp
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_log_RealmLog.h"
+#include "jni_util/log.hpp"
+#include "util.hpp"
+
+using namespace realm::util;
+using namespace realm::jni_util;
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeAddLogger(JNIEnv *env, jclass, jobject java_logger)
+{
+    try {
+        Log::shared().add_java_logger(env, java_logger);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeRemoveLogger(JNIEnv *env, jclass, jobject java_logger)
+{
+    try {
+        Log::shared().remove_java_logger(env, java_logger);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeClearLoggers(JNIEnv *env, jclass)
+{
+    try {
+        Log::shared().clear_loggers();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeRegisterDefaultLogger(JNIEnv *env, jclass)
+{
+    try {
+        Log::shared().register_default_logger();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeLog(JNIEnv *env, jclass, jint level, jstring tag, jthrowable throwable,
+                                     jstring message)
+{
+    try {
+        JStringAccessor tag_accessor(env, tag);
+        JStringAccessor message_accessor(env, message);
+        Log::shared().log(static_cast<Log::Level>(level), std::string(tag_accessor).c_str(), throwable,
+                          std::string(message_accessor).c_str());
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_log_RealmLog_nativeSetLogLevel(JNIEnv *env, jclass, jint level)
+{
+    try {
+        Log::shared().set_level(static_cast<Log::Level>(level));
+    } CATCH_STD()
+}
+
+JNIEXPORT jint JNICALL
+Java_io_realm_log_RealmLog_nativeGetLogLevel(JNIEnv *env, jclass)
+{
+    try {
+        return static_cast<jint>(Log::shared().get_level());
+    } CATCH_STD()
+
+    return static_cast<jint>(Log::Level::all);
+}
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
new file mode 100644
index 0000000000..b8954caeb6
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_binding_context.hpp"
+
+#include "util/format.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+JavaBindingContext::JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
+    : m_local_jni_env(concrete_context.jni_env)
+{
+    jint ret = m_local_jni_env->GetJavaVM(&m_jvm);
+    if (ret != 0) {
+        throw std::runtime_error(util::format("Failed to get Java vm. Error: %d", ret));
+    }
+    if (concrete_context.java_notifier) {
+        m_java_notifier = m_local_jni_env->NewWeakGlobalRef(concrete_context.java_notifier);
+        jclass cls = m_local_jni_env->GetObjectClass(m_java_notifier);
+        m_notify_by_other_method = m_local_jni_env->GetMethodID(cls, "notifyCommitByOtherThread", "()V");
+    } else {
+        m_java_notifier = nullptr;
+    }
+}
+
+JavaBindingContext::~JavaBindingContext()
+{
+    if (m_java_notifier) {
+        // Always try to attach here since this may be called in the finalizer/phantom thread where m_local_jni_env
+        // should not be used on. No need to call DetachCurrentThread since this thread should always be created by
+        // JVM.
+        JNIEnv *env;
+        m_jvm->AttachCurrentThread(&env, nullptr);
+        env->DeleteWeakGlobalRef(m_java_notifier);
+    }
+}
+
+void JavaBindingContext::changes_available()
+{
+    jobject notifier = m_local_jni_env->NewLocalRef(m_java_notifier);
+    if (notifier) {
+        m_local_jni_env->CallVoidMethod(m_java_notifier, m_notify_by_other_method);
+        m_local_jni_env->DeleteLocalRef(notifier);
+    }
+}
+
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
new file mode 100644
index 0000000000..a058691b3e
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JAVA_BINDING_CONTEXT_HPP
+#define JAVA_BINDING_CONTEXT_HPP
+
+#include <jni.h>
+#include <memory>
+
+#include "binding_context.hpp"
+
+namespace realm {
+
+namespace _impl {
+
+// Binding context which will be called from OS.
+class JavaBindingContext final : public BindingContext {
+private:
+    struct ConcreteJavaBindContext {
+        JNIEnv* jni_env;
+        jobject java_notifier;
+        explicit ConcreteJavaBindContext(JNIEnv* env, jobject notifier)
+            :jni_env(env), java_notifier(notifier) { }
+    };
+
+    // The JNIEnv for the thread which creates the Realm. This should only be used on the current thread.
+    JNIEnv* m_local_jni_env;
+    // All methods should be called from the thread which creates the realm except the destructor which might be
+    // called from finalizer/phantom daemon. So we need a jvm pointer to create JNIEnv there if needed.
+    JavaVM* m_jvm;
+    // A weak global ref to the implementation of RealmNotifier
+    // Java should hold a strong ref to it as long as the SharedRealm lives
+    jobject m_java_notifier;
+    // Method IDs from RealmNotifier implementation. Cache them as member vars.
+    jmethodID m_notify_by_other_method;
+
+public:
+    virtual ~JavaBindingContext();
+    virtual void changes_available();
+
+    explicit JavaBindingContext(const ConcreteJavaBindContext&);
+    JavaBindingContext(const JavaBindingContext&) = delete;
+    JavaBindingContext& operator=(const JavaBindingContext&) = delete;
+    JavaBindingContext(JavaBindingContext&&) = delete;
+    JavaBindingContext& operator=(JavaBindingContext&&) = delete;
+
+    static inline std::unique_ptr<JavaBindingContext> create(JNIEnv* env, jobject notifier)
+    {
+        return std::make_unique<JavaBindingContext>(ConcreteJavaBindContext{env, notifier});
+    };
+};
+
+} // namespace _impl
+
+} // namespace realm
+
+#endif
+
diff --git a/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp b/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
new file mode 100644
index 0000000000..b50ff1902a
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_impl/android_logger.cpp
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cstring>
+
+#include "util/format.hpp"
+
+#include "android_logger.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::jni_impl;
+using namespace realm::util;
+
+std::shared_ptr<AndroidLogger> AndroidLogger::shared()
+{
+    // Private constructor, make_shared is not available.
+    static std::shared_ptr<AndroidLogger> android_logger(new AndroidLogger());
+    return android_logger;
+}
+
+void AndroidLogger::log(Log::Level level, const char* tag, jthrowable, const char* message) {
+    android_LogPriority android_log_priority;
+    switch (level) {
+        case Log::Level::trace:
+            android_log_priority = ANDROID_LOG_VERBOSE;
+            break;
+        case Log::Level::debug:
+            android_log_priority = ANDROID_LOG_DEBUG;
+            break;
+        case Log::Level::info:
+            android_log_priority = ANDROID_LOG_INFO;
+            break;
+        case Log::Level::warn:
+            android_log_priority = ANDROID_LOG_WARN;
+            break;
+        case Log::Level::error:
+            android_log_priority = ANDROID_LOG_ERROR;
+            break;
+        case Log::Level::fatal:
+            android_log_priority = ANDROID_LOG_FATAL;
+            break;
+        default:// Cannot get here.
+            throw std::invalid_argument(format("Invalid log level: %1.", level));
+    }
+    if (message) {
+        print(android_log_priority, tag, message);
+    }
+}
+
+void AndroidLogger::print(android_LogPriority priority, const char* tag, const char* log_string)
+{
+    size_t log_size = strlen(log_string);
+
+    if (log_size > LOG_ENTRY_MAX_LENGTH) {
+        size_t start = 0;
+
+        while (start < log_size) {
+            size_t count = log_size - start > LOG_ENTRY_MAX_LENGTH ? LOG_ENTRY_MAX_LENGTH : log_size - start;
+            std::string tmp_str(log_string, start, count);
+            __android_log_write(priority, tag, tmp_str.c_str());
+            start += count;
+        }
+    } else {
+        __android_log_write(priority, tag, log_string);
+    }
+}
+
+namespace realm {
+namespace jni_util {
+
+std::shared_ptr<JniLogger> get_default_logger()
+{
+    return std::static_pointer_cast<JniLogger>(AndroidLogger::shared());
+}
+
+}
+}
+
+
diff --git a/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp b/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
new file mode 100644
index 0000000000..6b90c0f6c6
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_impl/android_logger.hpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_ANDROID_LOGGER_HPP
+#define REALM_JNI_IMPL_ANDROID_LOGGER_HPP
+
+#include <android/log.h>
+#include "jni_util/log.hpp"
+
+namespace realm {
+namespace jni_impl {
+
+//Default logger implementation for Android.
+class AndroidLogger : public realm::jni_util::JniLogger {
+public:
+    static std::shared_ptr<AndroidLogger> shared();
+
+protected:
+    void log(realm::jni_util::Log::Level level, const char* tag, jthrowable throwable, const char* message) override;
+
+private:
+    AndroidLogger() {};
+    static void print(android_LogPriority priority, const char* tag, const char* log_string);
+    static const size_t LOG_ENTRY_MAX_LENGTH = 4000;
+};
+
+}
+}
+
+#endif // REALM_JNI_IMPL_ANDROID_LOGGER_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
new file mode 100644
index 0000000000..2e9ed01ae0
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+
+#include "jni_util/log.hpp"
+#include "util/format.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::util;
+
+const char* CoreLoggerBridge::TAG = "REALM_CORE";
+const char* Log::REALM_JNI_TAG = "REALM_JNI";
+Log::Level Log::s_level = Log::Level::warn;
+
+// Native wrapper for Java RealmLogger class
+class JavaLogger : public JniLogger {
+public:
+    JavaLogger(JNIEnv* env, jobject java_logger);
+    ~JavaLogger();
+
+    bool is_same_object(JNIEnv* env, jobject java_logger);
+
+protected:
+    void log(Log::Level level, const char* tag, jthrowable throwable, const char* message) override;
+
+private:
+    JavaVM* m_jvm;
+    // Global ref of the logger object.
+    jobject m_java_logger;
+    jmethodID m_log_method;
+
+    inline JNIEnv* get_current_env() noexcept
+    {
+        JNIEnv *env;
+        if (m_jvm->GetEnv((void **)&env, JNI_VERSION_1_6) != JNI_OK) {
+            m_jvm->AttachCurrentThread(&env, nullptr); // Should never fail
+        }
+        return env;
+    }
+};
+
+JniLogger::JniLogger()
+    :m_is_java_logger(false)
+{
+}
+
+JniLogger::JniLogger(bool is_java_logger)
+    :m_is_java_logger(is_java_logger)
+{
+}
+
+JavaLogger::JavaLogger(JNIEnv* env, jobject java_logger)
+    :JniLogger(true)
+{
+    jint ret = env->GetJavaVM(&m_jvm);
+    if (ret != 0) {
+        throw std::runtime_error(util::format("Failed to get Java vm. Error: %d", ret));
+    }
+    m_java_logger = env->NewGlobalRef(java_logger);
+    jclass cls = env->GetObjectClass(m_java_logger);
+    m_log_method = env->GetMethodID(cls, "log", "(ILjava/lang/String;Ljava/lang/Throwable;Ljava/lang/String;)V");
+}
+
+JavaLogger::~JavaLogger()
+{
+    get_current_env()->DeleteGlobalRef(m_java_logger);
+}
+
+void JavaLogger::log(Log::Level level, const char* tag, jthrowable throwable, const char* message)
+{
+    JNIEnv *env = get_current_env();
+
+    // NOTE: If a Java exception has been thrown in native code, the below call will trigger an JNI exception
+    // "JNI called with pending exception". This is something that should be avoided when printing log in JNI -- Always
+    // print log before calling env->ThrowNew. Doing env->ExceptionCheck() here creates overhead for normal cases.
+    env->CallVoidMethod(m_java_logger, m_log_method, level, env->NewStringUTF(tag),
+            throwable, env->NewStringUTF(message));
+}
+
+bool JavaLogger::is_same_object(JNIEnv* env, jobject java_logger)
+{
+    return env->IsSameObject(m_java_logger, java_logger);
+}
+
+Log::Log()
+    : m_loggers()
+{
+    add_logger(get_default_logger());
+}
+
+Log& Log::shared()
+{
+    static Log log;
+    return log;
+}
+
+void Log::add_java_logger(JNIEnv* env, const jobject java_logger)
+{
+    std::shared_ptr<JniLogger> logger = std::make_shared<JavaLogger>(env, java_logger);
+    add_logger(logger);
+}
+
+void Log::remove_java_logger(JNIEnv* env, const jobject java_logger)
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) {
+        return obj->m_is_java_logger && std::static_pointer_cast<JavaLogger>(obj)->is_same_object(env, java_logger);
+    }), m_loggers.end());
+}
+
+void Log::add_logger(std::shared_ptr<JniLogger> logger)
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    if (std::find(m_loggers.begin(), m_loggers.end(), logger) == m_loggers.end()) {
+        m_loggers.push_back(logger);
+    }
+}
+
+void Log::remove_logger(std::shared_ptr<JniLogger> logger)
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+
+    m_loggers.erase(std::remove_if(m_loggers.begin(), m_loggers.end(), [&](const auto& obj) {
+        return obj == logger;
+    }), m_loggers.end());
+}
+
+void Log::register_default_logger() {
+    add_logger(get_default_logger());
+}
+
+void Log::clear_loggers()
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    m_loggers.clear();
+}
+
+void Log::set_level(Level level)
+{
+    s_level = level;
+}
+
+void Log::log(Level level, const char* tag, jthrowable throwable, const char* message)
+{
+    if (s_level <= level) {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        for (auto& logger : m_loggers) {
+            logger->log(level, tag, throwable, message);
+        }
+    }
+}
+
+void CoreLoggerBridge::do_log(realm::util::Logger::Level level, std::string msg)
+{
+    // Ignore the level threshold from the root logger.
+    Log::Level jni_level;
+    switch (level) {
+        case Level::trace: jni_level = Log::trace; break;
+        case Level::debug: // Fall through. Map to same level debug.
+        case Level::detail: jni_level = Log::debug; break;
+        case Level::info: jni_level = Log::info; break;
+        case Level::warn: jni_level = Log::warn; break;
+        case Level::error: jni_level = Log::error; break;
+        case Level::fatal: jni_level = Log::fatal; break;
+        case Level::all: // Fall through.
+        case Level::off: // Fall through.
+            throw std::invalid_argument(format("Invalid log level."));
+    }
+    Log::shared().log(jni_level, TAG, msg.c_str());
+}
+
+CoreLoggerBridge& CoreLoggerBridge::shared()
+{
+    static CoreLoggerBridge log_bridge;
+    return log_bridge;
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.hpp b/realm/realm-library/src/main/cpp/jni_util/log.hpp
new file mode 100644
index 0000000000..ad29c6ede7
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/log.hpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_LOG_HPP
+#define REALM_JNI_UTIL_LOG_HPP
+
+#include <jni.h>
+
+#include <memory>
+#include <mutex>
+#include <string>
+#include <vector>
+
+#include "io_realm_log_LogLevel.h"
+
+#include "realm/util/logger.hpp"
+#include "util/format.hpp"
+
+#define TR_ENTER() \
+    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) { \
+        realm::jni_util::Log::t(" --> %1", __FUNCTION__); \
+    }
+#define TR_ENTER_PTR(ptr) \
+    if (realm::jni_util::Log::s_level <= realm::jni_util::Log::trace) { \
+        realm::jni_util::Log::t(" --> %1 %2", __FUNCTION__, static_cast<int64_t>(ptr)); \
+    }
+
+namespace realm {
+
+namespace jni_util {
+
+class JniLogger;
+
+// This is built for Realm logging, bother for Java and native side.
+// Multiple loggers can be registered. All registered loggers will receive the same log events.
+class Log {
+public:
+    enum Level {
+        all = io_realm_log_LogLevel_ALL,
+        trace = io_realm_log_LogLevel_TRACE,
+        debug = io_realm_log_LogLevel_DEBUG,
+        info = io_realm_log_LogLevel_INFO,
+        warn = io_realm_log_LogLevel_WARN,
+        error = io_realm_log_LogLevel_ERROR,
+        fatal = io_realm_log_LogLevel_FATAL,
+        off = io_realm_log_LogLevel_OFF
+    };
+
+    // Add & Remove a Java RealmLogger. A Java logger needs to be implemented from io.realm.log.RealmLogger interface.
+    void add_java_logger(JNIEnv* env, const jobject java_logger);
+    void remove_java_logger(JNIEnv* env, const jobject java_logger);
+
+    void add_logger(std::shared_ptr<JniLogger> logger);
+    void remove_logger(std::shared_ptr<JniLogger> logger);
+
+    // Remove all custom loggers, but keep the default logger.
+    void clear_loggers();
+
+    // Add the default logger if it has been removed before.
+    void register_default_logger();
+
+    void set_level(Level level);
+    inline Level get_level() {
+        return s_level;
+    };
+
+    void log(Level level, const char* tag, jthrowable throwable, const char* message);
+
+    inline void log(Level level, const char* tag, const char* message)
+    {
+        log(level, tag, nullptr, message);
+    }
+
+    // Helper functions for logging with REALM_JNI tag.
+    inline static void t(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void d(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void i(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void w(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void e(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+    inline static void f(const char* message)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, message);
+    }
+
+    template<typename... Args>
+    inline static void t(const char* fmt, Args&&... args)
+    {
+        shared().log(trace, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void d(const char* fmt, Args&&... args)
+    {
+        shared().log(debug, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void i(const char* fmt, Args&&... args)
+    {
+        shared().log(info, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void w(const char* fmt, Args&&... args)
+    {
+        shared().log(warn, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void e(const char* fmt, Args&&... args)
+    {
+        shared().log(error, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+    template<typename... Args>
+    inline static void f(const char* fmt, Args&&... args) {
+        shared().log(fatal, REALM_JNI_TAG, nullptr, _impl::format(fmt, {_impl::Printable(args)...}).c_str());
+    }
+
+    // Get the shared Log instance.
+    static Log& shared();
+
+    // public & static for reading faster. For TR_ENTER check.
+    // Accessing to this var won't be thread safe and it is not necessary to be. Changing log level concurrently
+    // won't be a critical issue for commons cases.
+    static Level s_level;
+private:
+    Log();
+
+    std::vector<std::shared_ptr<JniLogger>> m_loggers;
+    std::mutex m_mutex;
+    // Log tag for generic Realm JNI.
+    static const char* REALM_JNI_TAG;
+
+};
+
+// Base Logger class.
+class JniLogger {
+protected:
+    JniLogger();
+    // Used by JavaLogger.
+    JniLogger(bool is_java_logger);
+    // Indicate if this is a wrapper for Java RealmLogger class. See JavaLogger
+    bool m_is_java_logger;
+
+protected:
+    // Overwrite this method to handle the log event.
+    // throwable is the Throwable passed from Java which could be null.
+    virtual void log(Log::Level level, const char* tag, jthrowable throwable, const char* message) = 0;
+    friend class Log;
+};
+
+// Implement this function to return the default logger which will be registered during initialization.
+extern std::shared_ptr<JniLogger> get_default_logger();
+
+class CoreLoggerBridge : public realm::util::RootLogger {
+public:
+    void do_log(Logger::Level, std::string msg) override;
+    static CoreLoggerBridge& shared();
+
+private:
+    CoreLoggerBridge() {};
+    // Log tag for Realm core & sync.
+    static const char* TAG;
+};
+
+} // namespace jni_util
+} // namespace realm
+
+#endif // REALM_JNI_UTIL_LOG_HPP
diff --git a/realm/realm-jni/src/mem_usage.cpp b/realm/realm-library/src/main/cpp/mem_usage.cpp
similarity index 100%
rename from realm/realm-jni/src/mem_usage.cpp
rename to realm/realm-library/src/main/cpp/mem_usage.cpp
diff --git a/realm/realm-jni/src/mem_usage.hpp b/realm/realm-library/src/main/cpp/mem_usage.hpp
similarity index 100%
rename from realm/realm-jni/src/mem_usage.hpp
rename to realm/realm-library/src/main/cpp/mem_usage.hpp
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
new file mode 160000
index 0000000000..300a2d6f28
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -0,0 +1 @@
+Subproject commit 300a2d6f284391540dcfd346893de49fa15e1771
diff --git a/realm/realm-library/src/main/cpp/objectserver_shared.hpp b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
new file mode 100644
index 0000000000..bd78254ba4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef REALM_OBJECTSERVER_SHARED_HPP
+#define REALM_OBJECTSERVER_SHARED_HPP
+
+#include <jni.h>
+#include <string>
+#include <thread>
+
+#include <realm/sync/history.hpp>
+#include <realm/sync/client.hpp>
+#include <realm/util/logger.hpp>
+
+#include <impl/realm_coordinator.hpp>
+#include <sync/sync_manager.hpp>
+
+#include "util.hpp"
+
+
+// Wrapper class for realm::Session. This allows us to manage the C++ session and callback lifecycle correctly.
+// TODO Use OS SyncSession instead
+class JniSession {
+
+public:
+    JniSession(const JniSession&) = delete;
+    JniSession& operator=(const JniSession&) = delete;
+    JniSession(JniSession&&) = delete;
+    JniSession& operator=(JniSession&&) = delete;
+
+    JniSession(JNIEnv* env, std::string local_realm_path, jobject java_session_obj)
+    {
+        extern std::unique_ptr<realm::sync::Client> sync_client;
+        // Get the coordinator for the given path, or null if there is none
+        m_sync_session = new realm::sync::Session(*sync_client, local_realm_path);
+        m_java_session_ref = env->NewGlobalRef(java_session_obj);
+        jobject global_obj_ref_tmp(m_java_session_ref);
+        auto sync_transact_callback = [local_realm_path](realm::VersionID, realm::VersionID) {
+            auto coordinator = realm::_impl::RealmCoordinator::get_existing_coordinator(
+                    realm::StringData(local_realm_path));
+            if (coordinator) {
+                coordinator->wake_up_notifier_worker();
+            }
+        };
+        auto error_handler = [&, global_obj_ref_tmp](int error_code, std::string message) {
+            JNIEnv *local_env;
+            g_vm->AttachCurrentThread(&local_env, nullptr);
+            jclass java_session_class = local_env->GetObjectClass(global_obj_ref_tmp);
+            jmethodID notify_error_handler = local_env->GetMethodID(java_session_class,
+                                                                       "notifySessionError", "(ILjava/lang/String;)V");
+            local_env->CallVoidMethod(global_obj_ref_tmp,
+                                      notify_error_handler, error_code, env->NewStringUTF(message.c_str()));
+        };
+        m_sync_session->set_sync_transact_callback(sync_transact_callback);
+        m_sync_session->set_error_handler(std::move(error_handler));
+    }
+
+    inline realm::sync::Session* get_session() const noexcept
+    {
+        return m_sync_session;
+    }
+
+    // Call this just before destroying the object to release JNI resources.
+    inline void close(JNIEnv* env)
+    {
+        env->DeleteGlobalRef(m_java_session_ref);
+    }
+
+    ~JniSession()
+    {
+        delete m_sync_session;
+    }
+
+private:
+    realm::sync::Session* m_sync_session;
+    jobject m_java_session_ref;
+};
+
+#endif // REALM_OBJECTSERVER_SHARED_HPP
diff --git a/realm/realm-jni/src/tablebase_tpl.hpp b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
similarity index 65%
rename from realm/realm-jni/src/tablebase_tpl.hpp
rename to realm/realm-library/src/main/cpp/tablebase_tpl.hpp
index a9ca249173..bf7ea21178 100644
--- a/realm/realm-jni/src/tablebase_tpl.hpp
+++ b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
@@ -41,26 +41,4 @@ jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex
     }
 }
 
-template <class M, class T>
-void tbl_nativeDoByteArray(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
-{
-    jbyte* bytePtr = env->GetByteArrayElements(dataArray, NULL);
-    if (!bytePtr) {
-        ThrowException(env, IllegalArgument, "doByteArray");
-        return;
-    }
-    size_t dataLen = S(env->GetArrayLength(dataArray));
-    (pTable->*doBinary)( S(columnIndex), S(rowIndex), realm::BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
-    env->ReleaseByteArrayElements(dataArray, bytePtr, 0);
-}
-
-
-template <class M, class T>
-void tbl_nativeDoBinary(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jobject byteBuffer)
-{
-    realm::BinaryData bin;
-    if (GetBinaryData(env, byteBuffer, bin))
-        (pTable->*doBinary)( S(columnIndex), S(rowIndex), bin);
-}
-
 #endif // REALM_JNI_TABLEBASE_TPL_HPP
diff --git a/realm/realm-jni/src/utf8.hpp b/realm/realm-library/src/main/cpp/utf8.hpp
similarity index 100%
rename from realm/realm-jni/src/utf8.hpp
rename to realm/realm-library/src/main/cpp/utf8.hpp
diff --git a/realm/realm-jni/src/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
similarity index 80%
rename from realm/realm-jni/src/util.cpp
rename to realm/realm-library/src/main/cpp/util.cpp
index 6d8a7dd58a..4e0b767e59 100644
--- a/realm/realm-jni/src/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -23,18 +23,27 @@
 
 #include "util.hpp"
 #include "io_realm_internal_Util.h"
+#include "io_realm_internal_SharedRealm.h"
+#include "shared_realm.hpp"
 
 using namespace std;
 using namespace realm;
 using namespace realm::util;
+using namespace realm::jni_util;
 
 // Caching classes and constructors for boxed types.
+JavaVM* g_vm;
 jclass java_lang_long;
 jmethodID java_lang_long_init;
 jclass java_lang_float;
 jmethodID java_lang_float_init;
 jclass java_lang_double;
+jclass java_lang_string;
 jmethodID java_lang_double_init;
+jclass session_class_ref;
+jmethodID session_error_handler;
+
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
 void ConvertException(JNIEnv* env, const char *file, int line)
 {
@@ -48,7 +57,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
     }
     catch (CrossTableLinkTarget& e) {
         ss << e.what() << " in " << file << " line " << line;
-        ThrowException(env, CrossTableLink, ss.str());
+        ThrowException(env, IllegalState, ss.str());
     }
     catch (SharedGroup::BadVersion& e) {
         ss << e.what() << " in " << file << " line " << line;
@@ -58,10 +67,21 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
-    catch (File::AccessError& e) {
-        ss << e.what() << " path: " << e.get_path() << " in " << file << " line " << line;
+    catch (RealmFileException& e) {
+        ss << e.what() << " (" <<  e.underlying() <<  ") in " << file << " line " << line;
+        ThrowRealmFileException(env, ss.str(), e.kind());
+    }
+    catch (InvalidTransactionException& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, IllegalState, ss.str());
+    }
+    catch (InvalidEncryptionKeyException& e) {
+        ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
+    catch (std::logic_error e) {
+        ThrowException(env, IllegalState, e.what());
+    }
     catch (exception& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, FatalError, ss.str());
@@ -79,7 +99,7 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
     string message;
     jclass jExceptionClass = NULL;
 
-    TR_ERR("jni: ThrowingException %d, %s, %s.", exception, classStr.c_str(), itemStr.c_str())
+    Log::e("jni: ThrowingException %1, %2, %3.", exception, classStr.c_str(), itemStr.c_str());
 
     switch (exception) {
         case ClassNotFound:
@@ -87,41 +107,11 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             message = "Class '" + classStr + "' could not be located.";
             break;
 
-        case NoSuchField:
-            jExceptionClass = env->FindClass("java/lang/NoSuchFieldException");
-            message = "Field '" + itemStr + "' could not be located in class io.realm." + classStr;
-            break;
-
-        case NoSuchMethod:
-            jExceptionClass = env->FindClass("java/lang/NoSuchMethodException");
-            message = "Method '" + itemStr + "' could not be located in class io.realm." + classStr;
-            break;
-
         case IllegalArgument:
             jExceptionClass = env->FindClass("java/lang/IllegalArgumentException");
             message = "Illegal Argument: " + classStr;
             break;
 
-        case TableInvalid:
-            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
-            message = "Illegal State: " + classStr;
-            break;
-
-        case IOFailed:
-            jExceptionClass = env->FindClass("io/realm/exceptions/RealmIOException");
-            message = "Failed to open " + classStr + ". " + itemStr;
-            break;
-
-        case FileNotFound:
-            jExceptionClass = env->FindClass("io/realm/exceptions/RealmIOException");
-            message = "File not found: " + classStr + ".";
-            break;
-
-        case FileAccessError:
-            jExceptionClass = env->FindClass("io/realm/exceptions/RealmIOException");
-            message = "Failed to access: " + classStr + ". " + itemStr;
-            break;
-
         case IndexOutOfBounds:
             jExceptionClass = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
             message = classStr;
@@ -147,38 +137,66 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             message = classStr;
             break;
 
-        case RowInvalid:
-            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
-            message = "Illegal State: " + classStr;
-            break;
-
-        case CrossTableLink:
-            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
-            message = "This class is referenced by other classes. Remove those fields first before removing this class.";
-            break;
-
         case BadVersion:
             jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
             message = classStr;
             break;
 
-        case LockFileError:
-            jExceptionClass = env->FindClass("io/realm/exceptions/IncompatibleLockFileException");
+        case IllegalState:
+            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
             message = classStr;
             break;
 
+        // Should never get here.
+        case ExceptionKindMax:
+        default:
+            break;
     }
     if (jExceptionClass != NULL) {
+        Log::e("Exception has been throw: %1", message.c_str());
         env->ThrowNew(jExceptionClass, message.c_str());
-        TR_ERR("Exception has been throw: %s", message.c_str())
     }
     else {
-        TR_ERR("ERROR: Couldn't throw exception.")
+        Log::e("ERROR: Couldn't throw exception.");
     }
 
     env->DeleteLocalRef(jExceptionClass);
 }
 
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind)
+{
+    jclass cls = env->FindClass("io/realm/exceptions/RealmFileException");
+
+    jmethodID constructor = env->GetMethodID(cls, "<init>", "(BLjava/lang/String;)V");
+    // Initial value to suppress gcc warning.
+    jbyte kind_code;
+    switch (kind) {
+        case realm::RealmFileException::Kind::AccessError:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_ACCESS_ERROR;
+            break;
+        case realm::RealmFileException::Kind::PermissionDenied:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_PERMISSION_DENIED;
+            break;
+        case realm::RealmFileException::Kind::Exists:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_EXISTS;
+            break;
+        case realm::RealmFileException::Kind::NotFound:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_NOT_FOUND;
+            break;
+        case realm::RealmFileException::Kind::IncompatibleLockFile:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE;
+            break;
+        case realm::RealmFileException::Kind::FormatUpgradeRequired:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED;
+            break;
+    }
+    jstring jstr = env->NewStringUTF(message.c_str());
+    jobject exception = env->NewObject(cls, constructor, kind_code, jstr);
+    env->Throw(reinterpret_cast<jthrowable>(exception));
+    env->DeleteLocalRef(cls);
+    env->DeleteLocalRef(exception);
+}
+
 jclass GetClass(JNIEnv* env, const char* classStr)
 {
     jclass localRefClass = env->FindClass(classStr);
@@ -390,7 +408,8 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         size_t error_code;
         buf_size = Xcode::find_utf8_buf_size(begin, end, error_code);
     }
-    m_data.reset(new char[buf_size]);  // throws
+    char* tmp_char_array = new char[buf_size]; // throws
+    m_data.reset(tmp_char_array);
     {
         const jchar* in_begin = chars.data();
         const jchar* in_end   = in_begin + chars.size();
@@ -404,6 +423,8 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
             throw invalid_argument(string_to_hex("in_begin != in_end when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         m_size = out_begin - m_data.get();
+        // FIXME: Does this help on string issues? Or does it only help lldb?
+        std::memset(tmp_char_array + m_size, 0, buf_size - m_size);
     }
 }
 
diff --git a/realm/realm-jni/src/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
similarity index 79%
rename from realm/realm-jni/src/util.hpp
rename to realm/realm-library/src/main/cpp/util.hpp
index 4f0a6e01a3..98cce1fd3a 100644
--- a/realm/realm-jni/src/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -24,19 +24,21 @@
 #include <jni.h>
 
 // Used by logging
-#define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 
 #include <realm.hpp>
-#include <realm/util/meta.hpp>
-#include <realm/util/safe_int_ops.hpp>
 #include <realm/lang_bind_helper.hpp>
 #include <realm/timestamp.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/sync/client.hpp>
+
+#include <util/format.hpp>
 
 #include "io_realm_internal_Util.h"
 
+#include "jni_util/log.hpp"
 
-#define TRACE               1       // disable for performance
 #define CHECK_PARAMETERS    1       // Check all parameters in API and throw exceptions in java if invalid
 
 #ifdef __cplusplus
@@ -56,29 +58,6 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
 #define STRINGIZE(x) STRINGIZE_DETAIL(x)
 
 // Exception handling
-
-#define CATCH_FILE(fileName) \
-    catch (InvalidDatabase&) { \
-        ThrowException(env, IllegalArgument, "Invalid format of Realm file."); \
-    } \
-    catch (util::File::PermissionDenied& e) { \
-        ThrowException(env, IOFailed, string(fileName), \
-                std::string(e.what()) + " path: " + e.get_path()); \
-    } \
-    catch (util::File::NotFound& e) { \
-        ThrowException(env, FileNotFound, string(fileName), \
-                std::string(e.what()) + " path: " + e.get_path());    \
-    } \
-    catch (util::File::AccessError& e) { \
-        ThrowException(env, FileAccessError, string(fileName), \
-                std::string(e.what()) + " path: " + e.get_path()); \
-    } \
-    catch (realm::IncompatibleLockFile& e) { \
-        ThrowException(env, LockFileError, std::string(e.what())); \
-    } \
-
-
-
 #define CATCH_STD() \
     catch (...) { \
         ConvertException(env, __FILE__, __LINE__); \
@@ -93,8 +72,6 @@ std::string num_to_string(T pNumber)
 }
 
 
-#define MAX_JLONG  0x7FFFFFFFFFFFFFFFLL
-#define MIN_JLONG -0x8000000000000000LL
 #define MAX_JINT   0x7FFFFFFFL
 #define MAX_JSIZE  MAX_JINT
 
@@ -107,32 +84,28 @@ std::string num_to_string(T pNumber)
 #define TV(x)   reinterpret_cast<realm::TableView*>(x)
 #define LV(x)   reinterpret_cast<realm::LinkViewRef*>(x)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
-#define G(x)    reinterpret_cast<realm::Group*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
-#define SG(ptr) reinterpret_cast<realm::SharedGroup*>(ptr)
-#define CH(ptr) reinterpret_cast<realm::Replication*>(ptr)
 #define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover <T>* >(ptr)
+#define SC(ptr) reinterpret_cast<realm::sync::Client*>(ptr)
+#define SS(ptr) reinterpret_cast<JniSession*>(ptr)
 
 // Exception handling
 enum ExceptionKind {
+    // FIXME: This is not something should be exposed to java, ClassNotFound is something we should
+    // crash hard in native code and fix it.
     ClassNotFound = 0,
-    NoSuchField = 1,
-    NoSuchMethod = 2,
-    IllegalArgument = 3,
-    IOFailed = 4,
-    FileNotFound = 5,
-    FileAccessError = 6,
-    IndexOutOfBounds = 7,
-    TableInvalid = 8,
-    UnsupportedOperation = 9,
-    OutOfMemory = 10,
-    FatalError = 11,
-    RuntimeError = 12,
-    RowInvalid = 13,
-    CrossTableLink = 15,
-    BadVersion = 16,
-    LockFileError = 17
-// NOTE!!!!: Please also add test cases to Util.java when introducing a new exception kind.
+    IllegalArgument,
+    IndexOutOfBounds,
+    UnsupportedOperation,
+    OutOfMemory,
+    FatalError,
+    RuntimeError,
+    BadVersion,
+    IllegalState,
+    RealmFileError,
+    // NOTE!!!!: Please also add test cases to io_realm_internal_TestUtil when introducing a
+    // new exception kind.
+    ExceptionKindMax // Always keep this as the last one!
 };
 
 void ConvertException(JNIEnv* env, const char *file, int line);
@@ -143,35 +116,6 @@ void ThrowNullValueException(JNIEnv* env, realm::Table *table, size_t col_ndx);
 jclass GetClass(JNIEnv* env, const char* classStr);
 
 
-// Debug trace
-extern int trace_level;
-extern const char* log_tag;
-
-#if TRACE
-  #if defined(ANDROID)
-    #include <android/log.h>
-    #define LOG_DEBUG ANDROID_LOG_DEBUG
-    #define TR_ENTER() if (trace_level >= 1) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, " --> %s", __FUNCTION__); } else {}
-    #define TR_ENTER_PTR(ptr) if (trace_level >= 1) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, " --> %s %" PRId64, __FUNCTION__, static_cast<int64_t>(ptr)); } else {}
-    #define TR(...) if (trace_level >= 2) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, __VA_ARGS__); } else {}
-    #define TR_ERR(...) if (trace_level >= 0) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, __VA_ARGS__); } else {}
-    #define TR_LEAVE() if (trace_level >= 3) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, " <-- %s", __FUNCTION__); } else {}
-  #else // ANDROID
-    #define TR_ENTER()
-    #define TR_ENTER_PTR(ptr)
-    #define TR(...)
-    #define TR_ERR(...)
-    #define TR_LEAVE()
-  #endif
-#else // TRACE - these macros must be empty
-  #define TR_ENTER()
-  #define TR_ENTER_PTR(ptr)
-  #define TR(...)
-  #define TR_ERR(...)
-  #define TR_LEAVE()
-#endif
-
-
 // Check parameters
 
 #define TABLE_VALID(env,ptr)    TableIsValid(env, ptr)
@@ -197,7 +141,7 @@ extern const char* log_tag;
 #define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      TblIndexAndTypeValid(env, ptr, col, row, type)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) TblIndexAndTypeInsertValid(env, ptr, col, row, type)
 
-#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     RowColIndexAndTypeValid(env, ptr, col, type)
+#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)     RowColIndexAndTypeValid(env, ptr, col, type)
 #define ROW_AND_COL_INDEX_VALID(env,ptr,col)                    RowColIndexValid(env, ptr, col)
 
 #else
@@ -243,8 +187,8 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
 
     }
     if (!valid) {
-        TR_ERR("Table %p is no longer attached!", VOID_PTR(objPtr))
-        ThrowException(env, TableInvalid, "Table is no longer valid to operate on.");
+        realm::jni_util::Log::e("Table %1 is no longer attached!", VOID_PTR(objPtr));
+        ThrowException(env, IllegalState, "Table is no longer valid to operate on.");
     }
     return valid;
 }
@@ -253,8 +197,8 @@ inline bool RowIsValid(JNIEnv* env, realm::Row* rowPtr)
 {
     bool valid = (rowPtr != NULL && rowPtr->is_attached());
     if (!valid) {
-        TR_ERR("Row %p is no longer attached!", VOID_PTR(rowPtr))
-        ThrowException(env, RowInvalid, "Object is no longer valid to operate on. Was it deleted by another thread?");
+        realm::jni_util::Log::e("Row %1 is no longer attached!", VOID_PTR(rowPtr));
+        ThrowException(env, IllegalState, "Object is no longer valid to operate on. Was it deleted by another thread?");
     }
     return valid;
 }
@@ -267,29 +211,30 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
     if (endIndex == -1)
         endIndex = maxIndex;
     if (startIndex < 0) {
-        TR_ERR("startIndex %" PRId64 " < 0 - invalid!", S64(startIndex))
+        realm::jni_util::Log::e("startIndex %1 < 0 - invalid!", S64(startIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
         return false;
     }
     if (realm::util::int_greater_than(startIndex, maxIndex)) {
-        TR_ERR("startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
+        realm::jni_util::Log::e("startIndex %1 > %2 - invalid!", S64(startIndex), S64(maxIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex > available rows.");
         return false;
     }
 
     if (realm::util::int_greater_than(endIndex, maxIndex)) {
-        TR_ERR("endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
+        realm::jni_util::Log::e("endIndex %1 > %2 - invalid!", S64(endIndex), S64(maxIndex));
         ThrowException(env, IndexOutOfBounds, "endIndex > available rows.");
         return false;
     }
     if (startIndex > endIndex) {
-        TR_ERR("startIndex %" PRId64 " > endIndex %" PRId64 " - invalid!", S64(startIndex), S64(endIndex))
+        realm::jni_util::Log::e(
+                "startIndex %1 > endIndex %2 - invalid!", S64(startIndex), S64(endIndex));
         ThrowException(env, IndexOutOfBounds, "startIndex > endIndex.");
         return false;
     }
 
     if (range != -1 && range < 0) {
-        TR_ERR("range %" PRId64 " < 0 - invalid!", S64(range))
+        realm::jni_util::Log::e("range %1 < 0 - invalid!", S64(range));
         ThrowException(env, IndexOutOfBounds, "range < 0.");
         return false;
     }
@@ -309,7 +254,7 @@ inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset=fal
         size -= 1;
     bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
-        TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
+        realm::jni_util::Log::e("rowIndex %1 > %2 - invalid!", S64(rowIndex), S64(size));
         ThrowException(env, IndexOutOfBounds,
             "rowIndex > available rows: " +
             num_to_string(rowIndex) + " > " + num_to_string(size));
@@ -336,7 +281,8 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
     }
     bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
-        TR_ERR("columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
+        realm::jni_util::Log::e(
+                "columnIndex %1 > %2 - invalid!", S64(columnIndex), S64(pTable->get_column_count()));
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
     }
     return !colErr;
@@ -378,7 +324,7 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
         return false;
     bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
     if (rowErr) {
-        TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
+        realm::jni_util::Log::e("rowIndex %1 > %2 - invalid!", S64(rowIndex), S64(pTable->size()));
         ThrowException(env, IndexOutOfBounds,
             "rowIndex " + num_to_string(rowIndex) +
             " > available rows " + num_to_string(pTable->size()) + ".");
@@ -392,7 +338,7 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColTy
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
     if (colType != expectColType) {
-        TR_ERR("Expected columnType %d, but got %d.", expectColType, pTable->get_column_type(col))
+        realm::jni_util::Log::e("Expected columnType %1, but got %2.", expectColType, pTable->get_column_type(col));
         ThrowException(env, IllegalArgument, "ColumnType invalid.");
         return false;
     }
@@ -408,7 +354,8 @@ inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    TR_ERR("Expected columnType %d or %d, but got %d", realm::type_Link, realm::type_LinkList, colType)
+    realm::jni_util::Log::e(
+            "Expected columnType %1 or %2, but got %3", realm::type_Link, realm::type_LinkList, colType);
     ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
     return false;
 }
@@ -431,7 +378,7 @@ inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    TR_ERR("Expected nullable column type")
+    realm::jni_util::Log::e("Expected nullable column type");
     ThrowException(env, IllegalArgument, "This field is not nullable.");
     return false;
 }
@@ -455,6 +402,8 @@ inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnInd
         && TypeIsLinkLike(env, pTable, columnIndex);
 }
 
+// FIXME Usually this is called after TBL_AND_INDEX_AND_TYPE_VALID which will validate Table as well.
+// Try to avoid duplicated checks to improve performance.
 template <class T>
 inline bool TblColIndexAndNullable(JNIEnv* env, T* pTable, jlong columnIndex) {
     return TableIsValid(env, pTable)
@@ -520,45 +469,18 @@ class JStringAccessor {
         }
     }
 
-private:
-    bool m_is_null;
-    std::unique_ptr<char[]> m_data;
-    std::size_t m_size;
-};
-
-class KeyBuffer {
-public:
-    KeyBuffer(JNIEnv* env, jbyteArray arr)
-    : m_env(env)
-    , m_array(arr)
-    , m_ptr(0)
+    operator std::string() const noexcept
     {
-#ifdef REALM_ENABLE_ENCRYPTION
-        if (arr) {
-            if (env->GetArrayLength(m_array) != 64)
-                ThrowException(env, UnsupportedOperation, "Encryption key must be exactly 64 bytes.");
-            m_ptr = env->GetByteArrayElements(m_array, NULL);
+        if (m_is_null) {
+            return std::string();
         }
-#else
-        if (arr)
-            ThrowException(env, UnsupportedOperation,
-                           "Encryption was disabled in the native library at compile time.");
-#endif
-    }
-
-    const char *data() const {
-        return reinterpret_cast<const char *>(m_ptr);
-    }
-
-    ~KeyBuffer() {
-        if (m_ptr)
-            m_env->ReleaseByteArrayElements(m_array, m_ptr, JNI_ABORT);
+        return std::string(m_data.get(), m_size);
     }
 
 private:
-    JNIEnv* m_env;
-    jbyteArray m_array;
-    jbyte* m_ptr;
+    bool m_is_null;
+    std::unique_ptr<char[]> m_data;
+    std::size_t m_size;
 };
 
 class JniLongArray {
@@ -614,6 +536,10 @@ class JniByteArray {
         , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
         , m_array(javaArray == NULL ? NULL : env->GetByteArrayElements(javaArray, NULL))
         , m_releaseMode(JNI_ABORT) {
+        if (m_javaArray != nullptr && m_array == nullptr) {
+            // javaArray is not null but GetByteArrayElements returns null, something is really wrong.
+            throw std::runtime_error(realm::util::format("GetByteArrayElements failed on byte array %x", m_javaArray));
+        }
     }
 
     ~JniByteArray()
@@ -638,6 +564,20 @@ class JniByteArray {
         return m_array[index];
     }
 
+    inline operator realm::BinaryData() const noexcept {
+        return realm::BinaryData(reinterpret_cast<const char *>(m_array), m_arrayLength);
+    }
+
+    inline operator std::vector<char>() const noexcept {
+        if (m_array == nullptr) {
+            return {};
+        }
+
+        std::vector<char> v(m_arrayLength);
+        std::copy_n(m_array, v.size(), v.begin());
+        return v;
+    }
+
     inline void updateOnRelease() noexcept
     {
         m_releaseMode = 0;
@@ -696,13 +636,42 @@ class JniBooleanArray {
     jint                m_releaseMode;
 };
 
+// Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
+// DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
+// program returns to Java from native. But if the LocaRef is created in a loop, consider to use this class to wrap it
+// because the size of local reference table is relative small (512 on Android).
+template <typename T>
+class JniLocalRef {
+public:
+    JniLocalRef(JNIEnv* env, T obj) : m_jobject(obj), m_env(env) {};
+    ~JniLocalRef()
+    {
+        m_env->DeleteLocalRef(m_jobject);
+    }
+
+    inline operator T() const noexcept
+    {
+            return m_jobject;
+    }
+
+private:
+    T m_jobject;
+    JNIEnv* m_env;
+};
+
+extern JavaVM* g_vm;
 extern jclass java_lang_long;
 extern jmethodID java_lang_long_init;
 extern jclass java_lang_float;
 extern jmethodID java_lang_float_init;
 extern jclass java_lang_double;
+extern jclass java_lang_string;
 extern jmethodID java_lang_double_init;
 
+// FIXME Move to own library
+extern jclass session_class_ref;
+extern jmethodID session_error_handler;
+
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
     return env->NewObject(java_lang_long, java_lang_long_init, value);
@@ -738,4 +707,8 @@ inline realm::Timestamp from_milliseconds(jlong milliseconds)
 
 extern const std::string TABLE_PREFIX;
 
+static inline bool to_bool(jboolean b) {
+    return b == JNI_TRUE;
+}
+
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
new file mode 100644
index 0000000000..b0f1c194ae
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import io.realm.internal.HandlerControllerConstants;
+import io.realm.internal.RealmNotifier;
+import io.realm.internal.async.QueryUpdateTask;
+import io.realm.log.RealmLog;
+
+/**
+ * Implementation of {@link RealmNotifier} for Android based on {@link Handler}.
+ */
+class AndroidNotifier implements RealmNotifier {
+    private Handler handler;
+
+    public AndroidNotifier(HandlerController handlerController) {
+        if (isAutoRefreshAvailable()) {
+            handler = new Handler(handlerController);
+        }
+    }
+
+    // Called by Java when transaction committed to send LOCAL_COMMIT to current thread's handler.
+    @Override
+    public void notifyCommitByLocalThread() {
+        if (handler == null) {
+            return;
+        }
+
+        // Force any updates on the current thread to the front the queue. Doing this is mostly
+        // relevant on the UI thread where it could otherwise process a motion event before the
+        // REALM_CHANGED event. This could in turn cause a UI component like ListView to crash. See
+        // https://github.com/realm/realm-android-adapters/issues/11 for such a case.
+        // Other Looper threads could process similar events. For that reason all looper threads will
+        // prioritize local commits.
+        //
+        // If a user is doing commits inside a RealmChangeListener this can cause the Looper thread to get
+        // event starved as it only starts handling Realm events instead. This is an acceptable risk as
+        // that behaviour indicate a user bug. Previously this would be hidden as the UI would still
+        // be responsive.
+        Message msg = Message.obtain();
+        msg.what = HandlerControllerConstants.LOCAL_COMMIT;
+        if (!handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
+            handler.removeMessages(HandlerControllerConstants.REALM_CHANGED);
+            handler.sendMessageAtFrontOfQueue(msg);
+        }
+    }
+
+    // This is called by OS when other thread/process changes the Realm.
+    // This is getting called on the same thread which created the Realm.
+    // |---------------------------------------------------------------+--------------+------------------------------------------------|
+    // | Thread A                                                      | Thread B     | Daemon Thread                                  |
+    // |---------------------------------------------------------------+--------------+------------------------------------------------|
+    // |                                                               | Make changes |                                                |
+    // |                                                               |              | Detect and notify thread A through JNI ALooper |
+    // | Call OS's Realm::notify() from OS's ALooper callback          |              |                                                |
+    // | Realm::notify() calls JavaBindingContext:change_available()   |              |                                                |
+    // | change_available calls into this method to send REALM_CHANGED |              |                                                |
+    // |---------------------------------------------------------------+--------------+------------------------------------------------|
+    @Override
+    public void notifyCommitByOtherThread() {
+        if (handler == null) {
+            return;
+        }
+
+        // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
+        // as the target thread consumes messages at the same time. In this case it is not a problem as worst
+        // case we end up with two REALM_CHANGED messages in the queue.
+        boolean messageHandled = true;
+        if (!handler.hasMessages(HandlerControllerConstants.REALM_CHANGED) &&
+                !handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
+            messageHandled = handler.sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
+        }
+        if (!messageHandled) {
+            RealmLog.warn("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
+                    "to prevent this.");
+        }
+    }
+
+    @Override
+    public void post(Runnable runnable) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.post(runnable);
+        }
+    }
+
+    @Override
+    public boolean isValid() {
+        return handler != null;
+    }
+
+    @Override
+    public void close() {
+        if (handler != null) {
+            handler.removeCallbacksAndMessages(null);
+            handler = null;
+        }
+    }
+
+    @Override
+    public void completeAsyncResults(QueryUpdateTask.Result result) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result).sendToTarget();
+        }
+    }
+
+    @Override
+    public void completeAsyncObject(QueryUpdateTask.Result result) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT, result).sendToTarget();
+        }
+    }
+
+    @Override
+    public void throwBackgroundException(Throwable throwable) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(
+                    HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(throwable)).sendToTarget();
+        }
+    }
+
+    @Override
+    public void completeUpdateAsyncQueries(QueryUpdateTask.Result result) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES, result).sendToTarget();
+        }
+    }
+
+    private static boolean isAutoRefreshAvailable() {
+        return (Looper.myLooper() != null && !isIntentServiceThread());
+    }
+
+    private static boolean isIntentServiceThread() {
+        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
+        // so use the thread name as a heuristic:
+        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
+        String threadName = Thread.currentThread().getName();
+        return threadName != null && threadName.startsWith("IntentService[");
+    }
+
+    // For testing purpose only. Should be removed ideally.
+    public void setHandler(Handler handler) {
+        this.handler = handler;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index e1775d8dd6..c61b2cefae 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -16,32 +16,30 @@
 
 package io.realm;
 
+import android.content.Context;
 import android.os.Handler;
 import android.os.Looper;
-import android.os.Message;
-
-import com.getkeepsafe.relinker.BuildConfig;
 
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SharedGroupManager;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
-import io.realm.internal.android.DebugAndroidLogger;
-import io.realm.internal.android.ReleaseAndroidLogger;
+import io.realm.internal.Util;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
+import io.realm.internal.ObjectServerFacade;
 import rx.Observable;
 
 /**
@@ -62,30 +60,34 @@
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
 
-    // Map between a Handler and the canonical path to a Realm file
-    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
+    
+    volatile static Context applicationContext;
 
     // Thread pool for all async operations (Query & transaction)
     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
     final long threadId;
     protected RealmConfiguration configuration;
-    protected SharedGroupManager sharedGroupManager;
+    protected SharedRealm sharedRealm;
+
     RealmSchema schema;
-    Handler handler;
     HandlerController handlerController;
 
-    static {
-        //noinspection ConstantConditions
-        RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
-    }
 
     protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
-        this.sharedGroupManager = new SharedGroupManager(configuration);
-        this.schema = new RealmSchema(this, sharedGroupManager.getTransaction());
+
         this.handlerController = new HandlerController(this);
+        this.sharedRealm = SharedRealm.getInstance(configuration, new AndroidNotifier(this.handlerController),
+                !(this instanceof Realm) ? null :
+                new SharedRealm.SchemaVersionListener() {
+                    @Override
+                    public void onSchemaVersionChanged(long currentVersion) {
+                        RealmCache.updateSchemaCache((Realm) BaseRealm.this);
+                    }
+                });
+        this.schema = new RealmSchema(this);
 
         if (handlerController.isAutoRefreshAvailable()) {
             setAutoRefresh(true);
@@ -106,12 +108,6 @@ protected BaseRealm(RealmConfiguration configuration) {
     public void setAutoRefresh(boolean autoRefresh) {
         checkIfValid();
         handlerController.checkCanBeAutoRefreshed();
-        if (autoRefresh && !handlerController.isAutoRefreshEnabled()) { // Switch it on
-            handler = new Handler(handlerController);
-            handlers.put(handler, configuration.getPath());
-        } else if (!autoRefresh && handlerController.isAutoRefreshEnabled() && handler != null) { // Switch it off
-            removeHandler();
-        }
         handlerController.setAutoRefresh(autoRefresh);
     }
 
@@ -131,7 +127,7 @@ public boolean isAutoRefresh() {
      */
     public boolean isInTransaction() {
         checkIfValid();
-        return !sharedGroupManager.isImmutable();
+        return sharedRealm.isInTransaction();
     }
 
     protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
@@ -201,21 +197,9 @@ public void removeAllChangeListeners() {
     // WARNING: If this method is used after calling any async method, the old handler will still be used.
     //          package private, for test purpose only
     void setHandler(Handler handler) {
-        // remove the old one
-        handlers.remove(this.handler);
-        handlers.put(handler, configuration.getPath());
-        this.handler = handler;
+        ((AndroidNotifier)sharedRealm.realmNotifier).setHandler(handler);
     }
 
-    /**
-     * Removes and stops the current thread handler as gracefully as possible.
-     */
-    protected void removeHandler() {
-        handlers.remove(handler);
-        // Warning: This only clears the Looper queue. Handler.Callback is not removed.
-        handler.removeCallbacksAndMessages(null);
-        this.handler = null;
-    }
 
     /**
      * Writes a compacted copy of the Realm to the given destination File.
@@ -226,9 +210,10 @@ protected void removeHandler() {
      * the last transaction was committed.
      *
      * @param destination file to save the Realm to.
-     * @throws java.io.IOException if any write operation fails.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file or writing to the
+     * destination file.
      */
-    public void writeCopyTo(File destination) throws java.io.IOException {
+    public void writeCopyTo(File destination) {
         writeEncryptedCopyTo(destination, null);
     }
 
@@ -243,15 +228,16 @@ public void writeCopyTo(File destination) throws java.io.IOException {
      *
      * @param destination file to save the Realm to.
      * @param key a 64-byte encryption key.
-     * @throws java.io.IOException if any write operation fails.
      * @throws IllegalArgumentException if destination argument is null.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file or writing to the
+     * destination file.
      */
-    public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IOException {
+    public void writeEncryptedCopyTo(File destination, byte[] key) {
         if (destination == null) {
             throw new IllegalArgumentException("The destination argument cannot be null");
         }
         checkIfValid();
-        sharedGroupManager.copyToFile(destination, key);
+        sharedRealm.writeCopy(destination, key);
     }
 
     /**
@@ -262,6 +248,8 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IO
      * @return {@code true} if the Realm was updated to the latest version, {@code false} if it was
      * cancelled by calling stopWaitForChange.
      * @throws IllegalStateException if calling this from within a transaction or from a Looper thread.
+     * @throws RealmMigrationNeededException on typed {@link Realm} if the latest version contains
+     * incompatible schema changes.
      */
     public boolean waitForChange() {
         checkIfValid();
@@ -271,10 +259,10 @@ public boolean waitForChange() {
         if (Looper.myLooper() != null) {
             throw new IllegalStateException("Cannot wait for changes inside a Looper thread. Use RealmChangeListeners instead.");
         }
-        boolean hasChanged = sharedGroupManager.getSharedGroup().waitForChange();
+        boolean hasChanged = sharedRealm.waitForChange();
         if (hasChanged) {
             // Since this Realm instance has been waiting for change, advance realm & refresh realm.
-            sharedGroupManager.advanceRead();
+            sharedRealm.refresh();
             handlerController.refreshSynchronousTableViews();
         }
         return hasChanged;
@@ -294,10 +282,10 @@ public void stopWaitForChange() {
             @Override
             public void onCall() {
                 // Check if the Realm instance has been closed
-                if (sharedGroupManager == null || !sharedGroupManager.isOpen() || sharedGroupManager.getSharedGroup().isClosed()) {
+                if (sharedRealm == null || sharedRealm.isClosed()) {
                     throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
                 }
-                sharedGroupManager.getSharedGroup().stopWaitForChange();
+                sharedRealm.stopWaitForChange();
             }
         });
     }
@@ -331,10 +319,13 @@ public void onCall() {
      * <p>
      * Notice: it is not possible to nest transactions. If you start a transaction within a transaction an exception is
      * thrown.
+     *
+     * @throws RealmMigrationNeededException on typed {@link Realm} if the latest version contains
+     * incompatible schema changes.
      */
     public void beginTransaction() {
         checkIfValid();
-        sharedGroupManager.promoteToWrite();
+        sharedRealm.beginTransaction();
     }
 
     /**
@@ -344,81 +335,25 @@ public void beginTransaction() {
      * changes from this commit.
      */
     public void commitTransaction() {
-        commitTransaction(true, true);
+        commitTransaction(true);
     }
 
     /**
-     * Commits an async transaction. This will not trigger any REALM_CHANGED events. Caller is responsible for handling
-     * that.
-     */
-    void commitAsyncTransaction() {
-        commitTransaction(false, false);
-    }
-
-    /**
-     * Commits transaction, runs the given runnable and then sends notifications. The runnable is useful to meet some
-     * timing conditions like the async transaction. In async transaction, the background Realm has to be closed before
-     * other threads see the changes to majoyly avoid the flaky tests.
+     * Commits transaction and sends notifications to local thread.
      *
-     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change listeners.
+     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change
+     *                          listeners.
      */
-    void commitTransaction(boolean notifyLocalThread, boolean notifyOtherThreads) {
+    void commitTransaction(boolean notifyLocalThread) {
         checkIfValid();
-        sharedGroupManager.commitAndContinueAsRead();
-
-        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
-            Handler handler = handlerIntegerEntry.getKey();
-            String realmPath = handlerIntegerEntry.getValue();
-
-            // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
-            // file will make a commit in order to create the schema. Users should not be notified about that.
-            if (!notifyLocalThread && handler.equals(this.handler)) {
-                continue;
-            }
-
-            // Sometimes we don't want to notify other threads about changes because we need a custom message, e.g. when
-            // doing async transactions.
-            if (!notifyOtherThreads && !handler.equals(this.handler)) {
-                continue;
-            }
-
-            // For all other threads, use the Handler
-            // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
-            // as the target thread consumes messages at the same time. In this case it is not a problem as worst
-            // case we end up with two REALM_CHANGED messages in the queue.
-            Looper looper = handler.getLooper();
-            if (realmPath.equals(configuration.getPath())  // It's the right realm
-                    && looper.getThread().isAlive()) {     // The receiving thread is alive
-
-                boolean messageHandled = true;
-                if (looper == Looper.myLooper()) {
-                    // Force any updates on the current thread to the front the queue. Doing this is mostly
-                    // relevant on the UI thread where it could otherwise process a motion event before the
-                    // REALM_CHANGED event. This could in turn cause a UI component like ListView to crash. See
-                    // https://github.com/realm/realm-android-adapters/issues/11 for such a case.
-                    // Other Looper threads could process similar events. For that reason all looper threads will
-                    // prioritize local commits.
-                    //
-                    // If a user is doing commits inside a RealmChangeListener this can cause the Looper thread to get
-                    // event starved as it only starts handling Realm events instead. This is an acceptable risk as
-                    // that behaviour indicate a user bug. Previously this would be hidden as the UI would still
-                    // be responsive.
-                    Message msg = Message.obtain();
-                    msg.what = HandlerControllerConstants.LOCAL_COMMIT;
-                    if (!handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
-                        handler.removeMessages(HandlerControllerConstants.REALM_CHANGED);
-                        messageHandled = handler.sendMessageAtFrontOfQueue(msg);
-                    }
-                } else {
-                    if (!handler.hasMessages(HandlerControllerConstants.REALM_CHANGED)) {
-                        messageHandled = handler.sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
-                    }
-                }
-                if (!messageHandled) {
-                    RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
-                            "to prevent this.");
-                }
-            }
+        sharedRealm.commitTransaction();
+        ObjectServerFacade.getFacade(configuration.isSyncConfiguration())
+                .notifyCommit(configuration, sharedRealm.getLastSnapshotVersion());
+
+        // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
+        // file will make a commit in order to create the schema. Users should not be notified about that.
+        if (notifyLocalThread) {
+            sharedRealm.realmNotifier.notifyCommitByLocalThread();
         }
     }
 
@@ -432,15 +367,14 @@ void commitTransaction(boolean notifyLocalThread, boolean notifyOtherThreads) {
      */
     public void cancelTransaction() {
         checkIfValid();
-        sharedGroupManager.rollbackAndContinueAsRead();
+        sharedRealm.cancelTransaction();
     }
 
     /**
      * Checks if a Realm's underlying resources are still available or not getting accessed from the wrong thread.
      */
     protected void checkIfValid() {
-        // Check if the Realm instance has been closed
-        if (sharedGroupManager == null || !sharedGroupManager.isOpen()) {
+        if (sharedRealm == null || sharedRealm.isClosed()) {
             throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
         }
 
@@ -450,6 +384,12 @@ protected void checkIfValid() {
         }
     }
 
+    protected void checkIfInTransaction() {
+        if (!sharedRealm.isInTransaction()) {
+            throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
+        }
+    }
+
     /**
      * Check if the Realm is valid and in a transaction.
      */
@@ -459,6 +399,16 @@ protected void checkIfValidAndInTransaction() {
         }
     }
 
+    /**
+     * Check if the Realm is not built with a SyncRealmConfiguration
+     */
+    void checkNotInSync() {
+        if (configuration.isSyncConfiguration()) {
+            throw new IllegalArgumentException("You cannot perform changes to a schema. " +
+                    "Please update app and restart.");
+        }
+    }
+
     /**
      * Returns the canonical path to where this Realm is persisted on disk.
      *
@@ -484,11 +434,7 @@ public RealmConfiguration getConfiguration() {
      * @return the schema version for the Realm file backing this Realm.
      */
     public long getVersion() {
-        if (!sharedGroupManager.hasTable(Table.METADATA_TABLE_NAME)) {
-            return UNVERSIONED;
-        }
-        Table metadataTable = sharedGroupManager.getTable(Table.METADATA_TABLE_NAME);
-        return metadataTable.getLong(0, 0);
+        return sharedRealm.getSchemaVersion();
     }
 
     /**
@@ -512,12 +458,12 @@ public void close() {
      * Closes the Realm instances and all its resources without checking the {@link RealmCache}.
      */
     void doClose() {
-        if (sharedGroupManager != null) {
-            sharedGroupManager.close();
-            sharedGroupManager = null;
+        if (sharedRealm != null) {
+            sharedRealm.close();
+            sharedRealm = null;
         }
-        if (handler != null) {
-            removeHandler();
+        if (schema != null) {
+            schema.close();
         }
     }
 
@@ -532,7 +478,7 @@ public boolean isClosed() {
             throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
         }
 
-        return sharedGroupManager == null || !sharedGroupManager.isOpen();
+        return sharedRealm == null || sharedRealm.isClosed();
     }
 
     /**
@@ -542,26 +488,12 @@ public boolean isClosed() {
      */
     public boolean isEmpty() {
         checkIfValid();
-        return sharedGroupManager.getTransaction().isObjectTablesEmpty();
-    }
-
-    boolean hasChanged() {
-        return sharedGroupManager.hasChanged();
+        return sharedRealm.isEmpty();
     }
 
     // package protected so unit tests can access it
     void setVersion(long version) {
-        Table metadataTable = sharedGroupManager.getTable(Table.METADATA_TABLE_NAME);
-        if (metadataTable.getColumnCount() == 0) {
-            metadataTable.addColumn(RealmFieldType.INTEGER, "version");
-            metadataTable.addEmptyRow();
-        }
-        metadataTable.setLong(0, 0, version);
-    }
-
-    // Return all handlers registered for this Realm
-    static Map<Handler, String> getHandlers() {
-        return handlers;
+        sharedRealm.setSchemaVersion(version);
     }
 
     /**
@@ -573,40 +505,37 @@ public RealmSchema getSchema() {
         return schema;
     }
 
-    <E extends RealmModel> E get(Class<E> clazz, long rowIndex) {
+    <E extends RealmModel> E get(Class<E> clazz, long rowIndex, boolean acceptDefaultValue, List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         UncheckedRow row = table.getUncheckedRow(rowIndex);
-        E result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
+        E result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
+                acceptDefaultValue, excludeFields);
         RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setRow$realm(row);
-        proxy.realmGet$proxyState().setRealm$realm(this);
         proxy.realmGet$proxyState().setTableVersion$realm();
-
         return result;
     }
 
     // Used by RealmList/RealmResults
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
     <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
-        Table table;
+        final boolean isDynamicRealmObject = dynamicClassName != null;
+        final Table table = isDynamicRealmObject ? schema.getTable(dynamicClassName) : schema.getTable(clazz);
+
         E result;
-        if (dynamicClassName != null) {
-            table = schema.getTable(dynamicClassName);
+        if (isDynamicRealmObject) {
             @SuppressWarnings("unchecked")
-            E dynamicObj = (E) new DynamicRealmObject();
+            E dynamicObj = (E) new DynamicRealmObject(this,
+                    (rowIndex != Table.NO_MATCH) ? table.getCheckedRow(rowIndex) : InvalidRow.INSTANCE);
             result = dynamicObj;
         } else {
-            table = schema.getTable(clazz);
-            result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
+            result = configuration.getSchemaMediator().newInstance(clazz, this,
+                    (rowIndex != Table.NO_MATCH) ? table.getUncheckedRow(rowIndex) : InvalidRow.INSTANCE,
+                    schema.getColumnInfo(clazz), false, Collections.<String> emptyList());
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setRealm$realm(this);
         if (rowIndex != Table.NO_MATCH) {
-            proxy.realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
             proxy.realmGet$proxyState().setTableVersion$realm();
-        } else {
-            proxy.realmGet$proxyState().setRow$realm(InvalidRow.INSTANCE);
         }
 
         return result;
@@ -624,36 +553,11 @@ public void deleteAll() {
         }
     }
 
-    static private boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
-        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-
-        List<File> filesToDelete = Arrays.asList(
-                new File(rootFolder, realmFileName),
-                new File(rootFolder, realmFileName + ".lock"),
-                // Old core log file naming styles
-                new File(rootFolder, realmFileName + ".log_a"),
-                new File(rootFolder, realmFileName + ".log_b"),
-                new File(rootFolder, realmFileName + ".log"),
-                new File(canonicalPath));
-        for (File fileToDelete : filesToDelete) {
-            if (fileToDelete.exists()) {
-                boolean deleteResult = fileToDelete.delete();
-                if (!deleteResult) {
-                    realmDeleted.set(false);
-                    RealmLog.w("Could not delete the file " + fileToDelete);
-                }
-            }
-        }
-        return realmDeleted.get();
-    }
-
     /**
      * Deletes the Realm file defined by the given configuration.
      */
     static boolean deleteRealm(final RealmConfiguration configuration) {
-        final String management = ".management";
         final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-
         RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
             @Override
             public void onResult(int count) {
@@ -663,25 +567,11 @@ public void onResult(int count) {
                 }
 
                 String canonicalPath = configuration.getPath();
-                File realmFolder = configuration.getRealmFolder();
+                File realmFolder = configuration.getRealmDirectory();
                 String realmFileName = configuration.getRealmFileName();
-                File managementFolder = new File(realmFolder, realmFileName + management);
-
-                // delete files in management folder and the folder
-                // there is no subfolders in the management folder
-                File[] files = managementFolder.listFiles();
-                if (files != null) {
-                    for (File file : files) {
-                        realmDeleted.set(realmDeleted.get() && file.delete());
-                    }
-                }
-                realmDeleted.set(realmDeleted.get() && managementFolder.delete());
-
-                // delete specific files in root folder
-                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
+                realmDeleted.set(Util.deleteRealm(canonicalPath, realmFolder, realmFileName));
             }
         });
-
         return realmDeleted.get();
     }
 
@@ -693,11 +583,10 @@ public void onResult(int count) {
      * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
-        if (configuration.getEncryptionKey() != null) {
-            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
-        }
-
-        return SharedGroupManager.compact(configuration);
+        SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
+        Boolean result = sharedRealm.compact();
+        sharedRealm.close();
+        return result;
     }
 
     /**
@@ -706,15 +595,17 @@ static boolean compactRealm(final RealmConfiguration configuration) {
      * @param configuration configuration for the Realm that should be migrated.
      * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
      * @param callback callback for specific Realm type behaviors.
+     * @param cause which triggers this migration.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
     protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
-                                       final MigrationCallback callback) throws FileNotFoundException {
+                                       final MigrationCallback callback, final RealmMigrationNeededException cause)
+            throws FileNotFoundException {
         if (configuration == null) {
             throw new IllegalArgumentException("RealmConfiguration must be provided");
         }
         if (migration == null && configuration.getMigration() == null) {
-            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided");
+            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
         }
 
         final AtomicBoolean fileNotFound = new AtomicBoolean(false);
@@ -762,12 +653,17 @@ public void onResult(int count) {
         }
     }
 
+    // Return true if this Realm can receive notifications.
+    boolean hasValidNotifier() {
+        return sharedRealm.realmNotifier != null && sharedRealm.realmNotifier.isValid();
+    }
+
     @Override
     protected void finalize() throws Throwable {
-        if (sharedGroupManager != null && sharedGroupManager.isOpen()) {
-            RealmLog.w("Remember to call close() on all Realm instances. " +
-                    "Realm " + configuration.getPath() + " is being finalized without being closed, " +
-                    "this can lead to running out of native memory."
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            RealmLog.warn("Remember to call close() on all Realm instances. " +
+                    "Realm %s is being finalized without being closed, " +
+                    "this can lead to running out of native memory.", configuration.getPath()
             );
         }
         super.finalize();
@@ -778,4 +674,56 @@ protected void finalize() throws Throwable {
         void migrationComplete();
     }
 
+    public static final class RealmObjectContext {
+        private BaseRealm realm;
+        private Row row;
+        private ColumnInfo columnInfo;
+        private boolean acceptDefaultValue;
+        private List<String> excludeFields;
+
+        public void set(BaseRealm realm, Row row, ColumnInfo columnInfo,
+                        boolean acceptDefaultValue, List<String> excludeFields) {
+            this.realm = realm;
+            this.row = row;
+            this.columnInfo = columnInfo;
+            this.acceptDefaultValue = acceptDefaultValue;
+            this.excludeFields = excludeFields;
+        }
+
+        public BaseRealm getRealm() {
+            return realm;
+        }
+
+        public Row getRow() {
+            return row;
+        }
+
+        public ColumnInfo getColumnInfo() {
+            return columnInfo;
+        }
+
+        public boolean getAcceptDefaultValue() {
+            return acceptDefaultValue;
+        }
+
+        public List<String> getExcludeFields() {
+            return excludeFields;
+        }
+
+        public void clear() {
+            realm = null;
+            row = null;
+            columnInfo = null;
+            acceptDefaultValue = false;
+            excludeFields = null;
+        }
+    }
+    static final class ThreadLocalRealmObjectContext extends ThreadLocal<RealmObjectContext> {
+        @Override
+        protected RealmObjectContext initialValue() {
+            return new RealmObjectContext();
+        }
+    }
+
+    public static final ThreadLocalRealmObjectContext objectContext = new ThreadLocalRealmObjectContext();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 474e070020..6df8fea533 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -19,9 +19,9 @@
 import android.app.IntentService;
 
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.internal.Table;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -44,7 +44,7 @@
  * @see Realm
  * @see RealmSchema
  */
-public final class DynamicRealm extends BaseRealm {
+public class DynamicRealm extends BaseRealm {
 
     private DynamicRealm(RealmConfiguration configuration) {
         super(configuration);
@@ -57,7 +57,7 @@ private DynamicRealm(RealmConfiguration configuration) {
      *
      * @return the DynamicRealm defined by the configuration.
      * @see RealmConfiguration for details on how to configure a Realm.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if {@code configuration} argument is {@code null}.
      */
     public static DynamicRealm getInstance(RealmConfiguration configuration) {
@@ -77,6 +77,11 @@ public static DynamicRealm getInstance(RealmConfiguration configuration) {
     public DynamicRealmObject createObject(String className) {
         checkIfValid();
         Table table = schema.getTable(className);
+        // Check and throw the exception earlier for a better exception message.
+        if (table.hasPrimaryKey()) {
+            throw new RealmException(String.format("'%s' has a primary key, use" +
+                    " 'createObject(String, Object)' instead.", className));
+        }
         long rowIndex = table.addEmptyRow();
         return get(DynamicRealmObject.class, className, rowIndex);
     }
@@ -90,13 +95,12 @@ public DynamicRealmObject createObject(String className) {
      * @throws RealmException if object could not be created due to the primary key being invalid.
      * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
-     *                                  expectd value.
+     *                                  expected value.
      */
     public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
         Table table = schema.getTable(className);
         long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        DynamicRealmObject dynamicRealmObject = new DynamicRealmObject(this, table.getCheckedRow(index));
-        return dynamicRealmObject;
+        return new DynamicRealmObject(this, table.getCheckedRow(index));
     }
 
     /**
@@ -109,7 +113,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      */
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
-        if (!sharedGroupManager.hasTable(Table.TABLE_PREFIX + className)) {
+        if (!sharedRealm.hasTable(Table.TABLE_PREFIX + className)) {
             throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
@@ -144,6 +148,7 @@ public void addChangeListener(RealmChangeListener<DynamicRealm> listener) {
      */
     public void delete(String className) {
         checkIfValid();
+        checkIfInTransaction();
         schema.getTable(className).clear();
     }
 
@@ -168,7 +173,7 @@ public void executeTransaction(Transaction transaction) {
             if (isInTransaction()) {
                 cancelTransaction();
             } else {
-                RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
             }
             throw e;
         }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 6f277ceb9b..619b92ca60 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -19,6 +19,7 @@
 import java.util.Date;
 import java.util.Locale;
 
+import io.realm.exceptions.RealmException;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
@@ -31,7 +32,8 @@
  * Class that wraps a normal RealmObject in order to allow dynamic access instead of a typed interface.
  * Using a DynamicRealmObject is slower than using the regular RealmObject class.
  */
-public final class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
+@SuppressWarnings("WeakerAccess")
+public class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
 
     private final ProxyState proxyState = new ProxyState(this);
 
@@ -49,29 +51,36 @@ public DynamicRealmObject(RealmModel obj) {
             throw new IllegalArgumentException("The object is already a DynamicRealmObject: " + obj);
         }
 
-        if (!RealmObject.isValid(obj)) {
+        if (!RealmObject.isManaged(obj)) {
             throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
-                    "is an unmanaged object or it was deleted.");
+                    "is an unmanaged object.");
+        }
+
+        if (!RealmObject.isValid(obj)) {
+            throw new IllegalArgumentException("A valid object managed by Realm must be provided. " +
+                    "This object was deleted.");
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) obj;
         Row row = proxy.realmGet$proxyState().getRow$realm();
         proxyState.setRealm$realm(proxy.realmGet$proxyState().getRealm$realm());
         proxyState.setRow$realm(((UncheckedRow) row).convertToChecked());
+        proxyState.setConstructionFinished();
     }
 
-    // Create a dynamic object. Only used internally
-    DynamicRealmObject() {
-
-    }
-
+    // row must not be an instance of UncheckedRow
     DynamicRealmObject(BaseRealm realm, Row row) {
         proxyState.setRealm$realm(realm);
-        proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
+        proxyState.setRow$realm(row);
+        proxyState.setConstructionFinished();
     }
 
-    DynamicRealmObject(String className) {
+    // row must not be an instance of UncheckedRow
+    DynamicRealmObject(String className, BaseRealm realm, Row row) {
         proxyState.setClassName(className);
+        proxyState.setRealm$realm(realm);
+        proxyState.setRow$realm(row);
+        proxyState.setConstructionFinished();
     }
 
     /**
@@ -115,8 +124,12 @@ public DynamicRealmObject(RealmModel obj) {
      */
     public boolean getBoolean(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.BOOLEAN);
-        return proxyState.getRow$realm().getBoolean(columnIndex);
+        try {
+            return proxyState.getRow$realm().getBoolean(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.BOOLEAN);
+            throw e;
+        }
     }
 
     /**
@@ -162,8 +175,12 @@ public short getShort(String fieldName) {
      */
     public long getLong(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.INTEGER);
-        return proxyState.getRow$realm().getLong(columnIndex);
+        try {
+            return proxyState.getRow$realm().getLong(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.INTEGER);
+            throw e;
+        }
     }
 
     /**
@@ -194,8 +211,12 @@ public byte getByte(String fieldName) {
      */
     public float getFloat(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.FLOAT);
-        return proxyState.getRow$realm().getFloat(columnIndex);
+        try {
+            return proxyState.getRow$realm().getFloat(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.FLOAT);
+            throw e;
+        }
     }
 
     /**
@@ -211,8 +232,12 @@ public float getFloat(String fieldName) {
      */
     public double getDouble(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.DOUBLE);
-        return proxyState.getRow$realm().getDouble(columnIndex);
+        try {
+            return proxyState.getRow$realm().getDouble(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.DOUBLE);
+            throw e;
+        }
     }
 
     /**
@@ -224,8 +249,12 @@ public double getDouble(String fieldName) {
      */
     public byte[] getBlob(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.BINARY);
-        return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
+        try {
+            return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.BINARY);
+            throw e;
+        }
     }
 
     /**
@@ -237,8 +266,12 @@ public double getDouble(String fieldName) {
      */
     public String getString(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.STRING);
-        return proxyState.getRow$realm().getString(columnIndex);
+        try {
+            return proxyState.getRow$realm().getString(columnIndex);
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.STRING);
+            throw e;
+        }
     }
 
     /**
@@ -286,10 +319,14 @@ public DynamicRealmObject getObject(String fieldName) {
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
-        LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
-        String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
-        return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
+        try {
+            LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
+            String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
+            return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
+            throw e;
+        }
     }
 
     /**
@@ -358,6 +395,7 @@ public boolean hasField(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or if the input value cannot be converted
      * to the appropriate input type.
      * @throws NumberFormatException if a String based number cannot be converted properly.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     @SuppressWarnings("unchecked")
     public void set(String fieldName, Object value) {
@@ -440,8 +478,10 @@ public void setBoolean(String fieldName, boolean value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setShort(String fieldName, short value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -452,8 +492,10 @@ public void setShort(String fieldName, short value) {
      * @param fieldName field name to update.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setInt(String fieldName, int value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -464,8 +506,10 @@ public void setInt(String fieldName, int value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setLong(String fieldName, long value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -476,8 +520,10 @@ public void setLong(String fieldName, long value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setByte(String fieldName, byte value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -512,8 +558,10 @@ public void setDouble(String fieldName, double value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a String field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setString(String fieldName, String value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setString(columnIndex, value);
     }
@@ -627,6 +675,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
      *
      * @param fieldName field name.
      * @throws IllegalArgumentException if field name doesn't exist, or the field isn't nullable.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -634,6 +683,7 @@ public void setNull(String fieldName) {
         if (type == RealmFieldType.OBJECT) {
             proxyState.getRow$realm().nullifyLink(columnIndex);
         } else {
+            checkIsPrimaryKey(fieldName);
             proxyState.getRow$realm().setNull(columnIndex);
         }
     }
@@ -666,7 +716,7 @@ private void checkFieldType(String fieldName, long columnIndex, RealmFieldType e
                 expectedIndefiniteVowel = "n";
             }
             String columnTypeIndefiniteVowel = "";
-            if (expectedType == RealmFieldType.INTEGER || expectedType == RealmFieldType.OBJECT) {
+            if (columnType == RealmFieldType.INTEGER || columnType == RealmFieldType.OBJECT) {
                 columnTypeIndefiniteVowel = "n";
             }
             throw new IllegalArgumentException(String.format("'%s' is not a%s '%s', but a%s '%s'.",
@@ -789,4 +839,13 @@ public String toString() {
     public ProxyState realmGet$proxyState() {
         return proxyState;
     }
+
+    // Checks if the given field is primary key field. Throws if it is a PK field.
+    private void checkIsPrimaryKey(String fieldName) {
+        RealmObjectSchema objectSchema = proxyState.getRealm$realm().getSchema().getSchemaForClass(getType());
+        if (objectSchema.hasPrimaryKey() && objectSchema.getPrimaryKey().equals(fieldName)) {
+            throw new IllegalArgumentException(String.format(
+                    "Primary key field '%s' cannot be changed after object was created.", fieldName));
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 0663ba24d9..071dcc6b77 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -37,10 +37,13 @@
 import io.realm.internal.IdentitySet;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.async.BadVersionException;
 import io.realm.internal.async.QueryUpdateTask;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
+
+import static io.realm.internal.HandlerControllerConstants.LOCAL_COMMIT;
+import static io.realm.internal.HandlerControllerConstants.REALM_CHANGED;
 
 /**
  * Centralises all Handler callbacks, including updating async queries and refreshing the Realm.
@@ -108,14 +111,14 @@ public boolean handleMessage(Message message) {
         // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
         // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
         // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
-        // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
-        if (realm.sharedGroupManager != null) {
+        // longer exists. `sharedRealm` will only be null if a Realm is really closed.
+        if (realm.sharedRealm != null) {
             QueryUpdateTask.Result result;
             switch (message.what) {
 
-                case HandlerControllerConstants.LOCAL_COMMIT:
-                case HandlerControllerConstants.REALM_CHANGED:
-                    realmChanged(message.what == HandlerControllerConstants.LOCAL_COMMIT);
+                case LOCAL_COMMIT:
+                case REALM_CHANGED:
+                    realmChanged(message.what == LOCAL_COMMIT);
                     break;
 
                 case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
@@ -157,7 +160,7 @@ public boolean handleMessage(Message message) {
      */
     public void handleAsyncTransactionCompleted(Runnable onSuccess) {
         // Same reason as handleMessage()
-        if (realm.sharedGroupManager != null) {
+        if (realm.sharedRealm != null) {
             if (onSuccess != null) {
                 pendingOnSuccessAsyncTransactionCallbacks.add(onSuccess);
             }
@@ -274,7 +277,8 @@ private void updateAsyncEmptyRealmObject() {
                                 .addObject(next.getKey(),
                                         next.getValue().handoverQueryPointer(),
                                         next.getValue().getArgument())
-                                .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT)
+                                .sendToNotifier(realm.sharedRealm.realmNotifier,
+                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
                                 .build());
 
             } else {
@@ -381,9 +385,9 @@ private void updateAsyncQueries() {
             // try to cancel any pending update since we're submitting a new one anyway
             updateAsyncQueriesTask.cancel(true);
             Realm.asyncTaskExecutor.getQueue().remove(updateAsyncQueriesTask);
-            RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates");
+            RealmLog.trace("REALM_CHANGED realm: %s cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates", HandlerController.this);
         }
-        RealmLog.d("REALM_CHANGED realm:"+ HandlerController.this + " updating async queries, total: " + asyncRealmResults.size());
+        RealmLog.trace("REALM_CHANGED realm: %s updating async queries, total: %d", HandlerController.this, asyncRealmResults.size());
         // prepare a QueryUpdateTask to current async queries in this thread
         QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
                 .realmConfiguration(realm.getConfiguration());
@@ -415,20 +419,21 @@ private void updateAsyncQueries() {
         }
         if (realmResultsQueryStep != null) {
             QueryUpdateTask queryUpdateTask = realmResultsQueryStep
-                    .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES)
+                    .sendToNotifier(realm.sharedRealm.realmNotifier,
+                            QueryUpdateTask.NotifyEvent.COMPLETE_UPDATE_ASYNC_QUERIES)
                     .build();
             updateAsyncQueriesTask = Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
         }
     }
 
     private void realmChanged(boolean localCommit) {
-        RealmLog.d((localCommit ? "LOCAL_COMMIT" : "REALM_CHANGED") + " : realm:" + HandlerController.this);
+        RealmLog.debug("%s : %s", (localCommit ? "LOCAL_COMMIT" : "REALM_CHANGED"), HandlerController.this);
         deleteWeakReferences();
         boolean threadContainsAsyncQueries = threadContainsAsyncQueries();
 
         // Mixing local transactions and async queries has unavoidable race conditions
         if (localCommit && threadContainsAsyncQueries) {
-            RealmLog.w("Mixing asynchronous queries with local writes should be avoided. " +
+            RealmLog.warn("Mixing asynchronous queries with local writes should be avoided. " +
                     "Realm will convert any async queries to synchronous in order to remain consistent. Use " +
                     "asynchronous writes instead. You can read more here: " +
                     "https://realm.io/docs/java/latest/#asynchronous-transactions");
@@ -442,7 +447,7 @@ private void realmChanged(boolean localCommit) {
             // localCommit && threadContainsAsyncQueries (this is the case the warning above is about)
             // localCommit && !threadContainsAsyncQueries
             // !localCommit && !threadContainsAsyncQueries
-            realm.sharedGroupManager.advanceRead();
+            realm.sharedRealm.refresh();
 
             List<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>();
             collectAsyncRealmResultsCallbacks(resultsToBeNotified);
@@ -459,23 +464,25 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
             RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
             if (realmResults == null) {
                 asyncRealmResults.remove(weakRealmResults);
-                RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] realm:"+ HandlerController.this + " RealmResults GC'd ignore results");
-
+                RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] realm: %s RealmResults GC'd ignore results",
+                        weakRealmResults, HandlerController.this);
             } else {
-                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                 int compare = callerVersionID.compareTo(result.versionID);
                 if (compare == 0) {
                     // if the RealmResults is empty (has not completed yet) then use the value
                     // otherwise a task (grouped update) has already updated this RealmResults
                     if (!realmResults.isLoaded()) {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " same versions, using results (RealmResults is not loaded)");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s same versions, using results (RealmResults is not loaded)",
+                                weakRealmResults, HandlerController.this);
                         // swap pointer
                         realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                         // notify callbacks
                         realmResults.syncIfNeeded();
                         realmResults.notifyChangeListeners(false);
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " ignoring result the RealmResults (is already loaded)");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s ignoring result the RealmResults (is already loaded)",
+                                weakRealmResults, HandlerController.this);
                     }
 
                 } else if (compare > 0) {
@@ -490,7 +497,7 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
 
                     if (!realmResults.isLoaded()) { // UC2
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS " + weakRealmResults + "] , realm:"+ HandlerController.this + " caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s ] , %s caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version", weakRealmResults, HandlerController.this);
 
                         RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
                         QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
@@ -498,14 +505,15 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                                 .add(weakRealmResults,
                                         query.handoverQueryPointer(),
                                         query.getArgument())
-                                .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS)
+                                .sendToNotifier(realm.sharedRealm.realmNotifier,
+                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS)
                                 .build();
 
                         Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
 
                     } else {
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " caller is more advanced & RealmResults is loaded ignore the outdated result");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , %s caller is more advanced & RealmResults is loaded ignore the outdated result", weakRealmResults, HandlerController.this);
                     }
 
                 } else {
@@ -513,20 +521,20 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                     // no need to rerun the query, since we're going to receive the update signal
                     // & batch update all async queries including this one
                     // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
-                    RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
+                    RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , %s caller thread behind worker thread, ignore results (a batch update will update everything including this query)", weakRealmResults, HandlerController.this);
                 }
             }
         }
     }
 
     private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
-        SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+        SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
         int compare = callerVersionID.compareTo(result.versionID);
         if (compare > 0) {
             // if the caller thread is more advanced than the worker thread, it means it did a local commit.
             // This should also have put a REALM_CHANGED event on the Looper queue, so ignoring this result should
             // be safe as all async queries will be rerun when processing the REALM_CHANGED event.
-            RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, Looper will updates queries");
+            RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is more advanced, Looper will updates queries", HandlerController.this);
 
         } else {
             // We're behind or on the same version as the worker thread
@@ -537,12 +545,12 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 // imperative TV, they will not rerun if the SharedGroup advance
 
                 // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
-                RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " caller is behind  advance_read");
+                RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is behind advance_read", HandlerController.this);
                 // refresh the Realm to the version provided by the worker thread
                 // (advanceRead to the latest version may cause a version mismatch error) preventing us
                 // from importing correctly the handover table view
                 try {
-                    realm.sharedGroupManager.advanceRead(result.versionID);
+                    realm.sharedRealm.refresh(result.versionID);
                 } catch (BadVersionException e) {
                     // The version comparison above should have ensured that that the Caller version is less than the
                     // Worker version. In that case it should always be safe to advance_read.
@@ -567,7 +575,7 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                     realmResults.syncIfNeeded();
                     resultsToBeNotified.add(realmResults);
 
-                    RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
+                    RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES updating RealmResults %s", HandlerController.this, weakRealmResults);
                 }
             }
             collectSyncRealmResultsCallbacks(resultsToBeNotified);
@@ -601,7 +609,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
             RealmObjectProxy proxy = realmObjectWeakReference.get();
 
             if (proxy != null) {
-                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                 int compare = callerVersionID.compareTo(result.versionID);
                 // we always query on the same version
                 // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
@@ -619,13 +627,15 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                     // the caller has advanced we need to
                     // retry against the current version of the caller if it's still empty
                     if (RealmObject.isValid(proxy)) { // already completed & has a valid pointer no need to re-run
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
-                                + " RealmObject is already loaded, just notify it.");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s], realm: %s. " +
+                                "RealmObject is already loaded, just notify it",
+                                realm, HandlerController.this);
                         proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT " + proxy + "] , realm:" + HandlerController.this
-                                + " RealmObject is not loaded yet. Rerun the query.");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s, realm: %s. " +
+                                "RealmObject is not loaded yet. Rerun the query.",
+                                proxy, HandlerController.this);
                         Object value = realmObjects.get(realmObjectWeakReference);
                         RealmQuery<? extends RealmModel> realmQuery;
                         if (value == null || value == NO_REALM_QUERY) { // this is a retry of an empty RealmObject
@@ -640,7 +650,8 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                                 .addObject(realmObjectWeakReference,
                                         realmQuery.handoverQueryPointer(),
                                         realmQuery.getArgument())
-                                .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT)
+                                .sendToNotifier(realm.sharedRealm.realmNotifier,
+                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
                                 .build();
 
                         Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index 29376bff76..724ec56cf5 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -34,6 +34,13 @@
      */
     E first();
 
+    /**
+     * Gets the first object from the collection. If the collection is empty, the provided default will be used instead.
+     *
+     * @return the first object or the provided default.
+     */
+    E first(E defaultValue);
+
     /**
      * Gets the last object from the collection.
      *
@@ -42,6 +49,13 @@
      */
     E last();
 
+    /**
+     * Gets the last object from the collection. If the collection is empty, the provided default will be used instead.
+     *
+     * @return the last object or the provided default.
+     */
+    E last(E defaultValue);
+
     /**
      * Sorts a collection based on the provided field in ascending order.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/Property.java b/realm/realm-library/src/main/java/io/realm/Property.java
new file mode 100644
index 0000000000..ef9069c81a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/Property.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+/**
+ * Class for handling properties/fields.
+ */
+
+class Property {
+    public static final boolean PRIMARY_KEY = true;
+    public static final boolean REQUIRED    = true;
+    public static final boolean INDEXED     = true;
+
+    private final long nativePtr;
+
+    public Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), isPrimary, isIndexed, !isRequired);
+    }
+
+    public Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        String linkedToName = linkedTo.getClassName();
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedToName);
+    }
+
+    protected Property(long nativePtr) {
+        this.nativePtr = nativePtr;
+    }
+
+    protected long getNativePtr() {
+        return nativePtr;
+    }
+
+    public void close() {
+        if (nativePtr != 0) {
+            nativeClose(nativePtr);
+        }
+    }
+
+    private static native long nativeCreateProperty(String name, int type, boolean isPrimary, boolean isIndexed, boolean isNullable);
+    private static native long nativeCreateProperty(String name, int type, String linkedToName);
+    private static native void nativeClose(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 96049817d8..af3d807c7a 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -20,11 +20,10 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
-import io.realm.internal.InvalidRow;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * This implements {@code RealmObjectProxy} interface, to eliminate copying logic between
@@ -35,8 +34,13 @@
     private String className;
     private Class<? extends RealmModel> clazzName;
 
+    // true only while executing the constructor of the enclosing proxy object
+    private boolean underConstruction = true;
+
     private Row row;
     private BaseRealm realm;
+    private boolean acceptDefaultValue;
+    private List<String> excludeFields;
 
     private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
     private Future<Long> pendingQuery;
@@ -87,6 +91,22 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
         this.row = row;
     }
 
+    public boolean getAcceptDefaultValue$realm() {
+        return acceptDefaultValue;
+    }
+
+    public void setAcceptDefaultValue$realm(boolean acceptDefaultValue) {
+        this.acceptDefaultValue = acceptDefaultValue;
+    }
+
+    public List<String> getExcludeFields$realm() {
+        return excludeFields;
+    }
+
+    public void setExcludeFields$realm(List<String> excludeFields) {
+        this.excludeFields = excludeFields;
+    }
+
     public Object getPendingQuery$realm() {
         return pendingQuery;
     }
@@ -114,7 +134,7 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
                 isCompleted = true;
             }
         } catch (Exception e) {
-            RealmLog.d(e.getMessage());
+            RealmLog.debug(e);
             return false;
         }
         return true;
@@ -132,7 +152,7 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
 
         } else if (!isCompleted || row == Row.EMPTY_ROW) {
             isCompleted = true;
-            long nativeRowPointer = TableQuery.nativeImportHandoverRowIntoSharedGroup(handoverRowPointer, realm.sharedGroupManager.getNativePointer());
+            long nativeRowPointer = TableQuery.importHandoverRow(handoverRowPointer, realm.sharedRealm);
             Table table = getTable();
             this.row = table.getUncheckedRowByPointer(nativeRowPointer);
         }// else: already loaded query no need to import again the pointer
@@ -178,6 +198,16 @@ public void setClassName(String className) {
         this.className = className;
     }
 
+    public boolean isUnderConstruction() {
+        return underConstruction;
+    }
+
+    public void setConstructionFinished() {
+        underConstruction = false;
+        // only used while construction.
+        excludeFields = null;
+    }
+
     private Table getTable () {
         if (className != null) {
             return getRealm$realm().schema.getTable(className);
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index b0bca8a249..81c4bdebf1 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -18,8 +18,8 @@
 
 import android.annotation.TargetApi;
 import android.app.IntentService;
+import android.content.Context;
 import android.os.Build;
-import android.os.Looper;
 import android.util.JsonReader;
 
 import org.json.JSONArray;
@@ -35,25 +35,28 @@
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
-import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
 
-import io.realm.RealmObject;
-import io.realm.RealmQuery;
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.ObjectServerFacade;
+import io.realm.internal.RealmCore;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
-import io.realm.internal.log.RealmLog;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -119,7 +122,7 @@
  * @see <a href="http://en.wikipedia.org/wiki/ACID">ACID</a>
  * @see <a href="https://github.com/realm/realm-java/tree/master/examples">Examples using Realm</a>
  */
-public final class Realm extends BaseRealm {
+public class Realm extends BaseRealm {
 
     public static final String DEFAULT_REALM_NAME = RealmConfiguration.DEFAULT_REALM_NAME;
 
@@ -143,6 +146,52 @@
         return configuration.getRxFactory().from(this);
     }
 
+    /**
+     * Initializes the Realm library and creates a default configuration that is ready to use. It is required to call
+     * this method before interacting with any other of the Realm API's.
+     *
+     * A good place is in an {@link android.app.Application} subclass:
+     * <pre>
+     * {@code
+     * public class MyApplication extends Application {
+     *   \@Override
+     *   public void onCreate() {
+     *     super.onCreate();
+     *     Realm.init(this);
+     *   }
+     * }
+     * }
+     * </pre>
+     *
+     * Remember to register it in the {@code AndroidManifest.xml} file:
+     * <pre>
+     * {@code
+     * <?xml version="1.0" encoding="utf-8"?>
+     * <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="io.realm.example">
+     * <application android:name=".MyApplication">
+     *   // ...
+     * </application>
+     * </manifest>
+     * }
+     * </pre>
+     *
+     * @param context the Application Context.
+     * @throws IllegalArgumentException if a {@code null} context is provided.
+     * @see #getDefaultInstance()
+     */
+    public static synchronized void init(Context context) {
+        if (BaseRealm.applicationContext == null) {
+            if (context == null) {
+                throw new IllegalArgumentException("Non-null context required.");
+            }
+            RealmCore.loadLibrary(context);
+            defaultConfiguration = new RealmConfiguration.Builder(context).build();
+            ObjectServerFacade.getSyncFacadeIfPossible().init(context);
+            BaseRealm.applicationContext = context.getApplicationContext();
+            SharedRealm.initialize(new File(context.getFilesDir(), ".realm.temp"));
+        }
+    }
+
     /**
      * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
      * by {@link #setDefaultConfiguration(RealmConfiguration)}
@@ -151,11 +200,11 @@
      * @throws java.lang.NullPointerException if no default configuration has been defined.
      * @throws RealmMigrationNeededException if no migration has been provided by the default configuration and the
      *         RealmObject classes or version has has changed so a migration is required.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      */
     public static Realm getDefaultInstance() {
         if (defaultConfiguration == null) {
-            throw new NullPointerException("No default RealmConfiguration was found. Call setDefaultConfiguration() first");
+            throw new IllegalStateException("Call `Realm.init(Context)` before calling this method.");
         }
         return RealmCache.createRealmOrGetFromCache(defaultConfiguration, Realm.class);
     }
@@ -167,7 +216,7 @@ public static Realm getDefaultInstance() {
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException if no migration has been provided by the configuration and the RealmObject
      *         classes or version has has changed so a migration is required.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
      * @see RealmConfiguration for details on how to configure a Realm.
      */
@@ -204,35 +253,37 @@ public static void removeDefaultConfiguration() {
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
      * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param columnIndices if this is not  {@code null}, the {@link BaseRealm#schema#columnIndices} will be
-     *                      initialized to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from
-     *                      the Realm file.
+     * @param globalCacheArray if this is not {@code null} and contains an entry for current schema version,
+     *                         the {@link BaseRealm#schema#columnIndices} will be initialized with the copy of
+     *                         the entry. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated
+     *                         from the Realm file.
      * @return a {@link Realm} instance.
      */
-    static Realm createInstance(RealmConfiguration configuration, ColumnIndices columnIndices) {
+    static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
         try {
-            return createAndValidate(configuration, columnIndices);
+            return createAndValidate(configuration, globalCacheArray);
 
         } catch (RealmMigrationNeededException e) {
             if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
                 deleteRealm(configuration);
             } else {
                 try {
-                    migrateRealm(configuration);
+                    migrateRealm(configuration, e);
                 } catch (FileNotFoundException fileNotFoundException) {
                     // Should never happen
-                    throw new RealmIOException(fileNotFoundException);
+                    throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
                 }
             }
 
-            return createAndValidate(configuration, columnIndices);
+            return createAndValidate(configuration, globalCacheArray);
         }
     }
 
-    static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices columnIndices) {
+    static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
         Realm realm = new Realm(configuration);
         long currentVersion = realm.getVersion();
         long requiredVersion = configuration.getSchemaVersion();
+        final ColumnIndices columnIndices = RealmCache.findColumnIndices(globalCacheArray, requiredVersion);
         if (currentVersion != UNVERSIONED && currentVersion < requiredVersion && columnIndices == null) {
             realm.doClose();
             throw new RealmMigrationNeededException(configuration.getPath(), String.format("Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
@@ -251,7 +302,8 @@ static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices c
                 throw e;
             }
         } else {
-            realm.schema.columnIndices = columnIndices;
+            // copy global cache as a Realm local indices cache
+            realm.schema.columnIndices = columnIndices.clone();
         }
 
         return realm;
@@ -261,37 +313,71 @@ static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices c
     private static void initializeRealm(Realm realm) {
         long version = realm.getVersion();
         boolean commitNeeded = false;
+        boolean syncAvailable = realm.configuration.isSyncConfiguration();
+
         try {
-            realm.beginTransaction();
-            if (version == UNVERSIONED) {
-                commitNeeded = true;
-                realm.setVersion(realm.configuration.getSchemaVersion());
+            if (!syncAvailable) {
+                realm.beginTransaction();
+                if (version == UNVERSIONED) {
+                    commitNeeded = true;
+                    realm.setVersion(realm.configuration.getSchemaVersion());
+                }
             }
 
             RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
             final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap;
             columnInfoMap = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            ArrayList<RealmObjectSchema> realmObjectSchemas = new ArrayList<>();
+            RealmSchema realmSchemaCache = new RealmSchema();
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Create and validate table
-                if (version == UNVERSIONED) {
-                    mediator.createTable(modelClass, realm.sharedGroupManager.getTransaction());
+                if (version == UNVERSIONED && !syncAvailable) {
+                    mediator.createTable(modelClass, realm.sharedRealm);
+                }
+                if (syncAvailable) {
+                    RealmObjectSchema realmObjectSchema = mediator.createRealmObjectSchema(modelClass, realmSchemaCache);
+                    realmObjectSchemas.add(realmObjectSchema);
+                } else {
+                    columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
+                }
+            }
+            if (syncAvailable) {
+                RealmSchema schema = new RealmSchema(realmObjectSchemas);
+                // Assumption: when SyncConfiguration then additive schema update mode
+                realm.sharedRealm.updateSchema(schema, version);
+                for (Class<? extends RealmModel> modelClass : modelClasses) {
+                    columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
                 }
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedGroupManager.getTransaction()));
             }
-            realm.schema.columnIndices = new ColumnIndices(columnInfoMap);
+            realm.schema.columnIndices = new ColumnIndices(
+                    (version == UNVERSIONED) ? realm.configuration.getSchemaVersion() : version,
+                    columnInfoMap);
 
             if (version == UNVERSIONED) {
                 final Transaction transaction = realm.getConfiguration().getInitialDataTransaction();
                 if (transaction != null) {
-                    transaction.execute(realm);
+                    if (syncAvailable) {
+                        realm.executeTransaction(transaction);
+                        realm.executeTransaction(new Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.setVersion(realm.configuration.getSchemaVersion());
+                            }
+                        });
+                    } else {
+                        transaction.execute(realm);
+                    }
                 }
+
             }
         } finally {
-            if (commitNeeded) {
-                realm.commitTransaction(false, true);
-            } else {
-                realm.cancelTransaction();
+            if (!syncAvailable) {
+                if (commitNeeded) {
+                    realm.commitTransaction(false);
+                } else {
+                    realm.cancelTransaction();
+                }
             }
         }
     }
@@ -299,18 +385,20 @@ private static void initializeRealm(Realm realm) {
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
      * <p>
-     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject}
-     * field will be set to the default value for that type.
+     * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
+     * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
      * @param json an array where each JSONObject must map to the specified class.
      * @throws RealmException if mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, JSONArray json) {
         if (clazz == null || json == null) {
             return;
         }
+        checkIfValid();
 
         for (int i = 0; i < json.length(); i++) {
             try {
@@ -330,8 +418,9 @@ private static void initializeRealm(Realm realm) {
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json array with object data.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if unable to map JSON.
      * @see #createAllFromJson(Class, org.json.JSONArray)
      */
@@ -339,6 +428,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null) {
             return;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
         for (int i = 0; i < json.length(); i++) {
             try {
@@ -351,13 +441,14 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
-     * will be set to the default value for that type.
+     * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
+     * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
      * @param json the JSON array as a String where each object can map to the specified class.
      * @throws RealmException if mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
@@ -383,15 +474,17 @@ private static void initializeRealm(Realm realm) {
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with an array of JSON objects.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if unable to create a JSON array from the json string.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @see #createAllFromJson(Class, String)
      */
     public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
             return;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         JSONArray arr;
@@ -406,13 +499,16 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with {@code null} value will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
-     * will be set to the default value for that type.
+     * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
+     * JSON object the {@link RealmObject} field will be set to the default value for that type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of Realm objects created.
      * @param inputStream the JSON array as a InputStream. All objects in the array must be of the specified class.
      * @throws RealmException if mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws IOException if something was wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
@@ -420,6 +516,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || inputStream == null) {
             return;
         }
+        checkIfValid();
 
         JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
         try {
@@ -439,11 +536,14 @@ private static void initializeRealm(Realm realm) {
      * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated.
      * If a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned
      * the default value for the field type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the InputStream with a list of object data in JSON format.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if unable to read JSON.
      * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
      */
@@ -452,6 +552,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || in == null) {
             return;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         // As we need the primary key value we have to first parse the entire input stream as in the general
@@ -474,20 +575,22 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
-     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
-     * be set to the default value for that type.
+     * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
+     * object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
      * @return created object or {@code null} if no JSON data was provided.
      * @throws RealmException if the mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, JSONObject json) {
         if (clazz == null || json == null) {
             return null;
         }
+        checkIfValid();
 
         try {
             return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
@@ -505,8 +608,9 @@ private static void initializeRealm(Realm realm) {
      * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json {@link org.json.JSONObject} with object data.
      * @return created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if JSON data cannot be mapped.
      * @see #createObjectFromJson(Class, org.json.JSONObject)
      */
@@ -514,6 +618,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null) {
             return null;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
         try {
             E realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
@@ -525,14 +630,15 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
-     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
-     * be set to the default value for that type.
+     * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
+     * object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
      * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if mapping to json failed.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
@@ -559,8 +665,9 @@ private static void initializeRealm(Realm realm) {
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if JSON object cannot be mapped from the string parameter.
      * @see #createObjectFromJson(Class, String)
      */
@@ -568,6 +675,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         JSONObject obj;
@@ -582,14 +690,17 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with {@code null} value will map to the default value for the data type in Realm and unknown properties will
-     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
-     * be set to the default value for that type.
+     * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
+     * object the {@link RealmObject} field will be set to the default value for that type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
      * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if the mapping from JSON failed.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws IOException if something went wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
@@ -597,6 +708,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || inputStream == null) {
             return null;
         }
+        checkIfValid();
         E realmObject;
         Table table = schema.getTable(clazz);
         if (table.hasPrimaryKey()) {
@@ -632,12 +744,15 @@ private static void initializeRealm(Realm realm) {
      * {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If a new
      * {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
      * default value for the field type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the {@link InputStream} with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if failure to read JSON.
      * @see #createObjectFromJson(Class, java.io.InputStream)
      */
@@ -646,6 +761,7 @@ private static void initializeRealm(Realm realm) {
         if (clazz == null || in == null) {
             return null;
         }
+        checkIfValid();
         checkHasPrimaryKey(clazz);
 
         // As we need the primary key value we have to first parse the entire input stream as in the general
@@ -670,16 +786,42 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Instantiates and adds a new object to the Realm.
+     * <p>
+     * This method is only available for model classes with no @PrimaryKey annotation.
+     * If you like to create an object that has a primary key, use {@link #createObject(Class, Object)}
+     * or {@link #copyToRealm(RealmModel)} instead.
      *
      * @param clazz the Class of the object to create.
      * @return the new object.
-     * @throws RealmException if an object cannot be created.
+     * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
+     * @see #createObject(Class, Object)
      */
     public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
+        return createObjectInternal(clazz, true, Collections.<String> emptyList());
+    }
+
+    /**
+     * Same as {@link #createObject(Class)} but this does not check the thread.
+     *
+     * @param clazz the Class of the object to create.
+     * @param acceptDefaultValue if {@code true}, default value of the object will be applied and
+     *                           if {@code false}, it will be ignored.
+     * @return the new object.
+     * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
+     */
+    // called from proxy classes
+    <E extends RealmModel> E createObjectInternal(Class<E> clazz,
+                                                            boolean acceptDefaultValue,
+                                                            List<String> excludeFields) {
         Table table = schema.getTable(clazz);
+        // Check and throw the exception earlier for a better exception message.
+        if (table.hasPrimaryKey()) {
+            throw new RealmException(String.format("'%s' has a primary key, use" +
+                    " 'createObject(Class<E>, Object)' instead.", Table.tableNameToClassName(table.getName())));
+        }
         long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex);
+        return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
     }
 
     /**
@@ -687,19 +829,40 @@ private Scanner getFullStringScanner(InputStream in) {
      * <p>
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
+     * The default value for primary key provided by the model class will be ignored.
      *
      * @param clazz the Class of the object to create.
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException if the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model class does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expected value.
      */
     public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
+        checkIfValid();
+        return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String> emptyList());
+    }
+
+    /**
+     * Same as {@link #createObject(Class, Object)} but this does not check the thread.
+     *
+     * @param clazz the Class of the object to create.
+     * @param primaryKeyValue value for the primary key field.
+     * @param acceptDefaultValue if {@code true}, default value of the object will be applied and
+     *                           if {@code false}, it will be ignored.
+     * @return the new object.
+     * @throws RealmException if object could not be created due to the primary key being invalid.
+     * @throws IllegalStateException if the model class does not have an primary key defined.
+     * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     */
+    // called from proxy classes
+    <E extends RealmModel> E createObjectInternal(Class<E> clazz, Object primaryKeyValue,
+                                                            boolean acceptDefaultValue,
+                                                            List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return get(clazz, rowIndex);
+        return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
     }
 
     /**
@@ -831,7 +994,7 @@ public void insert(RealmModel object) {
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
-        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>();
+        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>();
         configuration.getSchemaMediator().insert(this, object, cache);
     }
 
@@ -900,7 +1063,7 @@ public void insertOrUpdate(RealmModel object) {
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
-        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>();
+        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>();
         configuration.getSchemaMediator().insertOrUpdate(this, object, cache);
     }
 
@@ -997,7 +1160,7 @@ public void insertOrUpdate(RealmModel object) {
      * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using 
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
      *
@@ -1018,9 +1181,9 @@ public void insertOrUpdate(RealmModel object) {
      * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
      * <p>
-     * *WARNING*: Any changes to copied objects can be merged back into Realm using 
-     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed. 
-     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being 
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using
+     * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
+     * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being
      * reached. This can also potentially override changes made by other threads.
      *
      * @param realmObject {@link RealmObject} to copy.
@@ -1078,6 +1241,7 @@ public void addChangeListener(RealmChangeListener<Realm> listener) {
      *
      * @param transaction the {@link io.realm.Realm.Transaction} to execute.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.
+     * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.
      */
     public void executeTransaction(Transaction transaction) {
         if (transaction == null) {
@@ -1092,7 +1256,7 @@ public void executeTransaction(Transaction transaction) {
             if (isInTransaction()) {
                 cancelTransaction();
             } else {
-                RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
             }
             throw e;
         }
@@ -1163,12 +1327,12 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
 
         // If the user provided a Callback then we make sure, the current Realm has a Handler
         // we can use to deliver the result
-        if ((onSuccess != null || onError != null)  && handler == null) {
+        if ((onSuccess != null || onError != null)  && !hasValidNotifier()) {
             throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
                     " and you provided a callback, we need a Handler to invoke your callback");
         }
 
-        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // We need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the transaction
         final RealmConfiguration realmConfiguration = getConfiguration();
 
@@ -1187,10 +1351,10 @@ public void run() {
                     transaction.execute(bgRealm);
 
                     if (!Thread.currentThread().isInterrupted()) {
-                        bgRealm.commitAsyncTransaction();
-                        // The bgRealm needs to be closed before posting the REALM_CHANGED event to the caller's handler
-                        // to avoid currency problems. This is currently guaranteed by posting
-                        // handleAsyncTransactionCompleted below.
+                        // No need to send change notification to the work thread.
+                        bgRealm.commitTransaction(false);
+                        // The bgRealm needs to be closed before post event to caller's handler to avoid concurrency
+                        // problem. This is currently guaranteed by posting handleAsyncTransactionCompleted below.
                         bgRealm.close();
                         transactionCommitted = true;
                     }
@@ -1201,20 +1365,18 @@ public void run() {
                         if (bgRealm.isInTransaction()) {
                             bgRealm.cancelTransaction();
                         } else if (exception[0] != null) {
-                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                            RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
                         }
                         bgRealm.close();
                     }
 
                     final Throwable backgroundException = exception[0];
                     // Send response as the final step to ensure the bg thread quit before others get the response!
-                    if (handler != null
-                            && !Thread.currentThread().isInterrupted()
-                            && handler.getLooper().getThread().isAlive()) {
+                    if (hasValidNotifier() && !Thread.currentThread().isInterrupted()) {
 
                         if (transactionCommitted) {
                             // This will be treated like a special REALM_CHANGED event
-                            handler.post(new Runnable() {
+                            sharedRealm.realmNotifier.post(new Runnable() {
                                 @Override
                                 public void run() {
                                     handlerController.handleAsyncTransactionCompleted(onSuccess != null ? new Runnable() {
@@ -1230,14 +1392,14 @@ public void run() {
                         // Send errors directly to the looper, so they don't get intercepted by the HandlerController.
                         if (backgroundException != null) {
                             if (onError != null) {
-                                handler.post(new Runnable() {
+                                sharedRealm.realmNotifier.post(new Runnable() {
                                     @Override
                                     public void run() {
                                         onError.onError(backgroundException);
                                     }
                                 });
                             } else {
-                                handler.post(new Runnable() {
+                                sharedRealm.realmNotifier.post(new Runnable() {
                                     @Override
                                     public void run() {
                                         if (backgroundException instanceof RuntimeException) {
@@ -1271,7 +1433,7 @@ public void run() {
             }
         });
 
-        return new RealmAsyncTask(pendingTransaction);
+        return new RealmAsyncTaskImpl(pendingTransaction, asyncTaskExecutor);
     }
 
     /**
@@ -1319,8 +1481,8 @@ private void checkMaxDepth(int maxDepth) {
         if (realmObject == null) {
             throw new IllegalArgumentException("Null objects cannot be copied from Realm.");
         }
-        if (!RealmObject.isValid(realmObject)) {
-            throw new IllegalArgumentException("RealmObject is not valid, so it cannot be copied.");
+        if (!(RealmObject.isManaged(realmObject) && RealmObject.isValid(realmObject))) {
+            throw new IllegalArgumentException("Only valid managed objects can be copied from Realm.");
         }
         if (realmObject instanceof DynamicRealmObject) {
             throw new IllegalArgumentException("DynamicRealmObject cannot be copied from Realm.");
@@ -1335,7 +1497,23 @@ private void checkMaxDepth(int maxDepth) {
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
     public static void migrateRealm(RealmConfiguration configuration) throws FileNotFoundException {
-        migrateRealm(configuration, null);
+        migrateRealm(configuration, (RealmMigration) null);
+    }
+
+    /**
+     * Called when migration needed in the Realm initialization.
+     *
+     * @param configuration {@link RealmConfiguration}
+     * @param cause which triggers this migration.
+     * @throws FileNotFoundException if the Realm file doesn't exist.
+     */
+    private static void migrateRealm(final RealmConfiguration configuration, final RealmMigrationNeededException cause)
+            throws FileNotFoundException {
+        BaseRealm.migrateRealm(configuration, null, new MigrationCallback() {
+            @Override
+            public void migrationComplete() {
+            }
+        }, cause);
     }
 
     /**
@@ -1352,7 +1530,7 @@ public static void migrateRealm(RealmConfiguration configuration, RealmMigration
             @Override
             public void migrationComplete() {
             }
-        });
+        }, null);
     }
 
     /**
@@ -1377,26 +1555,59 @@ public static boolean deleteRealm(RealmConfiguration configuration) {
      *
      * @param configuration a {@link RealmConfiguration} pointing to a Realm file.
      * @return {@code true} if successful, {@code false} if any file operation failed.
-     * @throws IllegalArgumentException if the realm file is encrypted. Compacting an encrypted Realm file is not
-     *                                  supported yet.
+     * @throws UnsupportedOperationException if Realm is synchronized.
      */
     public static boolean compactRealm(RealmConfiguration configuration) {
-        return BaseRealm.compactRealm(configuration);
-    }
-
-    // Get the canonical path for a given file
-    static String getCanonicalPath(File realmFile) {
-        try {
-            return realmFile.getCanonicalPath();
-        } catch (IOException e) {
-            throw new RealmIOException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
+        // FIXME: remove this restriction when https://github.com/realm/realm-core/issues/2345 is resolved
+        if (configuration.isSyncConfiguration()) {
+            throw new UnsupportedOperationException("Compacting is not supported yet on synced Realms. See https://github.com/realm/realm-core/issues/2345");
         }
+        return BaseRealm.compactRealm(configuration);
     }
 
     Table getTable(Class<? extends RealmModel> clazz) {
         return schema.getTable(clazz);
     }
 
+    /**
+     * Updates own schema cache.
+     *
+     * @param globalCacheArray global cache of column indices. If it contains an entry for current
+     *                         schema version, this method only copies the indices information in the entry.
+     * @return newly created indices information for current schema version. Or {@code null} if
+     *          {@code globalCacheArray} already contains the entry for current schema version.
+     */
+    ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
+        final long currentSchemaVersion = sharedRealm.getSchemaVersion();
+        final long cacheSchemaVersion = schema.columnIndices.getSchemaVersion();
+        if (currentSchemaVersion == cacheSchemaVersion) {
+            return null;
+        }
+
+        ColumnIndices createdGlobalCache = null;
+        final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
+        ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
+                currentSchemaVersion);
+        if (cacheForCurrentVersion == null) {
+            // not found in global cache. create it.
+            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
+            final Map<Class<? extends RealmModel>, ColumnInfo> map;
+            map = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            try {
+                for (Class<? extends RealmModel> clazz : modelClasses) {
+                    final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
+                    map.put(clazz, columnInfo);
+                }
+            } catch (RealmMigrationNeededException e) {
+                throw e;
+            }
+
+            cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
+        }
+        schema.columnIndices.copyFrom(cacheForCurrentVersion, mediator);
+        return createdGlobalCache;
+    }
+
     /**
      * Returns the default Realm module. This module contains all Realm classes in the current project, but not those
      * from library or project dependencies. Realm classes in these should be exposed using their own module.
@@ -1425,6 +1636,35 @@ public static Object getDefaultModule() {
         }
     }
 
+    /**
+     * Returns the current number of open Realm instances across all threads that are using this configuration.
+     * This includes both dynamic and normal Realms.
+     *
+     * @param configuration the {@link io.realm.RealmConfiguration} for the Realm.
+     * @return number of open Realm instances across all threads.
+     */
+    public static int getGlobalInstanceCount(RealmConfiguration configuration) {
+        final AtomicInteger globalCount = new AtomicInteger(0);
+        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                globalCount.set(count);
+            }
+        });
+        return globalCount.get();
+    }
+
+    /**
+     * Returns the current number of open Realm instances on the thread calling this method. This include both
+     * dynamic and normal Realms.
+     *
+     * @param configuration the {@link io.realm.RealmConfiguration} for the Realm.
+     * @return number of open Realm instances across all threads.
+     */
+    public static int getLocalInstanceCount(RealmConfiguration configuration) {
+        return RealmCache.getLocalThreadCount(configuration);
+    }
+
     /**
      * Encapsulates a Realm transaction.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index aa53c0ce8e..28fceabc74 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -16,8 +16,6 @@
 
 package io.realm;
 
-import java.util.concurrent.Future;
-
 /**
  * Represents a pending asynchronous Realm transaction.
  * <p>
@@ -25,39 +23,18 @@
  * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
  * caller's thread callback).
  */
-public final class RealmAsyncTask {
-    private final Future<?> pendingQuery;
-    private volatile boolean isCancelled = false;
-
-    RealmAsyncTask(Future<?> pendingQuery) {
-        this.pendingQuery = pendingQuery;
-    }
+public interface RealmAsyncTask {
 
     /**
      * Attempts to cancel execution of this transaction (if it hasn't already completed or previously cancelled).
      */
-    public void cancel() {
-        pendingQuery.cancel(true);
-        isCancelled = true;
-
-        // From "Java Threads": By Scott Oaks & Henry Wong
-        // cancelled tasks are never executed, but may
-        // accumulate in work queues, which may causes a memory leak
-        // if the task hold references (to an enclosing class for example)
-        // we can use purge() but one caveat applies: if a second thread attempts to add
-        // something to the pool (using the execute() method) at the same time the
-        // first thread is attempting to purge the queue the attempt to purge
-        // the queue fails and the cancelled object remain in the queue.
-        // A better way to cancel objects with thread pools is to use the remove()
-        Realm.asyncTaskExecutor.getQueue().remove(pendingQuery);
-    }
+    void cancel();
 
     /**
      * Checks whether an attempt to cancel the transaction was performed.
      *
      * @return {@code true} if {@link #cancel()} has already been called, {@code false} otherwise.
      */
-    public boolean isCancelled() {
-        return isCancelled;
-    }
+    boolean isCancelled();
 }
+
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 824f7fb7ed..980218b28f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -24,9 +24,12 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.internal.ColumnIndices;
-import io.realm.internal.log.RealmLog;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.Table;
+import io.realm.log.RealmLog;
+import io.realm.internal.ObjectServerFacade;
 
 /**
  * To cache {@link Realm}, {@link DynamicRealm} instances and related resources.
@@ -74,7 +77,8 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
 
     // Column indices are cached to speed up opening typed Realm. If a Realm instance is created in one thread, creating
     // Realm instances in other threads doesn't have to initialize the column indices again.
-    private ColumnIndices typedColumnIndices;
+    private static final int MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY = 4;
+    private final ColumnIndices[] typedColumnIndicesArray = new ColumnIndices[MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY];
 
     // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
     // are not allowed and an exception will be thrown when trying to add it to the cache map.
@@ -116,6 +120,19 @@ private RealmCache(RealmConfiguration config) {
 
         RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realmClass));
 
+        if (refAndCount.globalCount == 0) {
+            SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
+            if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
+                sharedRealm.beginTransaction();
+                if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
+                    sharedRealm.commitTransaction();
+                } else {
+                    sharedRealm.cancelTransaction();
+                }
+            }
+            sharedRealm.close();
+        }
+
         if (refAndCount.localRealm.get() == null) {
             // Create a new local Realm instance
             BaseRealm realm;
@@ -123,7 +140,7 @@ private RealmCache(RealmConfiguration config) {
 
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
-                realm = Realm.createInstance(configuration, cache.typedColumnIndices);
+                realm = Realm.createInstance(configuration, cache.typedColumnIndicesArray);
             } else if (realmClass == DynamicRealm.class) {
                 realm = DynamicRealm.createInstance(configuration);
             } else {
@@ -143,7 +160,9 @@ private RealmCache(RealmConfiguration config) {
         Integer refCount = refAndCount.localCount.get();
         if (refCount == 0) {
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
-                cache.typedColumnIndices = refAndCount.localRealm.get().schema.columnIndices;
+                final BaseRealm realm = refAndCount.localRealm.get();
+                // store a copy of local ColumnIndices as a global cache.
+                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.columnIndices.clone());
             }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
@@ -152,6 +171,11 @@ private RealmCache(RealmConfiguration config) {
 
         @SuppressWarnings("unchecked")
         E realm = (E) refAndCount.localRealm.get();
+
+        // Notify SyncPolicy that the Realm has been opened for the first time
+        if (refAndCount.globalCount == 1) {
+            ObjectServerFacade.getFacade(configuration.isSyncConfiguration()).realmOpened(configuration);
+        }
         return realm;
     }
 
@@ -176,7 +200,7 @@ static synchronized void release(BaseRealm realm) {
         }
 
         if (refCount <= 0) {
-            RealmLog.w("Realm " + canonicalPath + " has been closed already.");
+            RealmLog.warn("%s has been closed already.", canonicalPath);
             return;
         }
 
@@ -200,20 +224,24 @@ static synchronized void release(BaseRealm realm) {
             // Clear the column indices cache if needed
             if (realm instanceof Realm && refAndCount.globalCount == 0) {
                 // All typed Realm instances of this file are cleared from cache
-                cache.typedColumnIndices = null;
+                Arrays.fill(cache.typedColumnIndicesArray, null);
             }
 
             int totalRefCount = 0;
             for (RealmCacheType type : RealmCacheType.values()) {
                 totalRefCount += cache.refAndCountMap.get(type).globalCount;
             }
+
+            // No more local reference to this Realm in current thread, close the instance.
+            realm.doClose();
+
             // No more instance of typed Realm and dynamic Realm. Remove the configuration from cache.
             if (totalRefCount == 0) {
                 cachesMap.remove(canonicalPath);
+                ObjectServerFacade.getFacade(realm.getConfiguration().isSyncConfiguration())
+                        .realmClosed(realm.getConfiguration());
             }
 
-            // No more local reference to this Realm in current thread, close the instance.
-            realm.doClose();
         } else {
             refAndCount.localCount.set(refCount);
         }
@@ -274,8 +302,32 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
         callback.onResult(totalRefCount);
     }
 
+    /**
+     * Updates the schema cache in the typed Realm for {@code pathOfRealm}.
+     *
+     * @param realm the instance that contains the schema cache to be updated.
+     */
+    static synchronized void updateSchemaCache(Realm realm) {
+        final RealmCache cache = cachesMap.get(realm.getPath());
+        if (cache == null) {
+            // Called during initialization. just skip it.
+            return;
+        }
+        final RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.TYPED_REALM);
+        if (refAndCount.localRealm.get() == null) {
+            // Called during initialization. just skip it.
+            // We can reach here if the DynamicRealm instance is initialized first.
+            return;
+        }
+        final ColumnIndices[] globalCacheArray = cache.typedColumnIndicesArray;
+        final ColumnIndices createdCacheEntry = realm.updateSchemaCache(globalCacheArray);
+        if (createdCacheEntry != null) {
+            RealmCache.storeColumnIndices(globalCacheArray, createdCacheEntry);
+        }
+    }
+
    /**
-     * Runs the callback function with synchronization on {@class RealmCache}.
+     * Runs the callback function with synchronization on {@link RealmCache}.
      *
      * @param callback the callback will be executed.
      */
@@ -288,11 +340,12 @@ static synchronized void invokeWithLock(Callback0 callback) {
      * Copy is performed only at the first time when there is no Realm database file.
      *
      * @param configuration configuration object for Realm instance.
-     * @throws IOException if copying the file fails.
+     * @throws RealmFileException if copying the file fails.
      */
     private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
+        IOException exceptionWhenClose = null;
         if (configuration.hasAssetFile()) {
-            File realmFile = new File(configuration.getRealmFolder(), configuration.getRealmFileName());
+            File realmFile = new File(configuration.getRealmDirectory(), configuration.getRealmFileName());
             if (realmFile.exists()) {
                 return;
             }
@@ -302,7 +355,8 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
             try {
                 inputStream = configuration.getAssetFile();
                 if (inputStream == null) {
-                    throw new RealmIOException("Invalid input stream to asset file.");
+                    throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                            "Invalid input stream to asset file.");
                 }
 
                 outputStream = new FileOutputStream(realmFile);
@@ -312,23 +366,93 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
                     outputStream.write(buf, 0, bytesRead);
                 }
             } catch (IOException e) {
-                throw new RealmIOException("Could not resolve the path to the Realm asset file.", e);
+                throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                        "Could not resolve the path to the Realm asset file.", e);
             } finally {
                 if (inputStream != null) {
                     try {
                         inputStream.close();
                     } catch (IOException e) {
-                        // Ignore this exception because any significant errors should already have been handled
+                        exceptionWhenClose = e;
                     }
                 }
                 if (outputStream != null) {
                     try {
                         outputStream.close();
                     } catch (IOException e) {
-                        throw new RealmIOException("Invalid output stream to " + realmFile.getPath(), e);
+                        // Ignore this one if there was an exception when close inputStream.
+                        if (exceptionWhenClose == null) {
+                            exceptionWhenClose = e;
+                        }
                     }
                 }
             }
+
+            // No other exception has been thrown, only the exception when close. So, throw it.
+            if (exceptionWhenClose != null) {
+                throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR, exceptionWhenClose);
+            }
+        }
+    }
+
+    static int getLocalThreadCount(RealmConfiguration configuration) {
+        RealmCache cache = cachesMap.get(configuration.getPath());
+        if (cache == null) {
+            return 0;
+        } else {
+            int totalRefCount = 0;
+            for (RealmCacheType type : RealmCacheType.values()) {
+                Integer localCount = cache.refAndCountMap.get(type).localCount.get();
+                totalRefCount += (localCount != null) ? localCount : 0;
+            }
+            return totalRefCount;
+        }
+    }
+
+    /**
+     * Finds an entry for specified schema version in the array.
+     *
+     * @param array target array of schema cache.
+     * @param schemaVersion requested version of the schema.
+     * @return {@link ColumnIndices} instance for specified schema version. {@code null} if not found.
+     */
+    public static ColumnIndices findColumnIndices(ColumnIndices[] array, long schemaVersion) {
+        for (int i = array.length - 1; 0 <= i; i--) {
+            final ColumnIndices candidate = array[i];
+            if (candidate != null && candidate.getSchemaVersion() == schemaVersion) {
+                return candidate;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Stores the schema cache to the array.
+     * <p>
+     * If the {@code array} has an empty slot ({@code == null}), this method stores
+     * the {@code columnIndices} to it. Otherwise, the entry of the oldest schema version is
+     * replaced.
+     *
+     * @param array target array.
+     * @param columnIndices the item to be stored into the {@code array}.
+     * @return the index in the {@code array} where the {@code columnIndices} was stored.
+     */
+    private static int storeColumnIndices(ColumnIndices[] array, ColumnIndices columnIndices) {
+        long oldestSchemaVersion = Long.MAX_VALUE;
+        int candidateIndex = -1;
+        for (int i = array.length - 1; 0 <= i; i--) {
+            if (array[i] == null) {
+                array[i] = columnIndices;
+                return i;
+            }
+
+            ColumnIndices target = array[i];
+            if (target.getSchemaVersion() <= oldestSchemaVersion) {
+                oldestSchemaVersion = target.getSchemaVersion();
+                candidateIndex = i;
+            }
         }
+        array[candidateIndex] = columnIndices;
+        return candidateIndex;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 6278272dc2..722d1253d3 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -139,13 +139,28 @@
     boolean load();
 
     /**
-     * Checks if the collection is still valid to use e.g. the {@link io.realm.Realm} instance hasn't
-     * been closed.
+     * Checks if the collection is still valid to use, i.e., the {@link io.realm.Realm} instance hasn't been closed. It
+     * will always return {@code true} for an unmanaged collection.
      *
-     * @return {@code true} if still valid to use, {@code false} otherwise.
+     * @return {@code true} if it is still valid to use or an unmanaged collection, {@code false} otherwise.
      */
     boolean isValid();
 
+    /**
+     * Checks if the collection is managed by Realm. A managed collection is just a wrapper around the data in the
+     * underlying Realm file. On Looper threads, a managed collection will be live-updated so it always points to the
+     * latest data. Managed collections are thread confined so that they cannot be accessed from other threads than the
+     * one that created them.
+     * <p>
+     *
+     * If this method returns {@code false}, the collection is unmanaged. An unmanaged collection is just a normal java
+     * collection, so it will not be live updated.
+     * <p>
+     *
+     * @return {@code true} if this is a managed {@link RealmCollection}, {@code false} otherwise.
+     */
+    boolean isManaged();
+
     /**
      * Tests whether this {@code Collection} contains the specified object. Returns
      * {@code true} if and only if at least one element {@code elem} in this
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 4f7a8c031a..7cd6d6fcd4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -22,7 +22,6 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
@@ -32,9 +31,10 @@
 
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
 import io.realm.rx.RealmObservableFactory;
@@ -60,7 +60,7 @@
  * <li>It has its schema version set to 0.</li>
  * </ul>
  */
-public final class RealmConfiguration {
+public class RealmConfiguration {
 
     public static final String DEFAULT_REALM_NAME = "default.realm";
     public static final int KEY_LENGTH = 64;
@@ -84,7 +84,7 @@
         }
     }
 
-    private final File realmFolder;
+    private final File realmDirectory;
     private final String realmFileName;
     private final String canonicalPath;
     private final String assetFilePath;
@@ -92,30 +92,41 @@
     private final long schemaVersion;
     private final RealmMigration migration;
     private final boolean deleteRealmIfMigrationNeeded;
-    private final SharedGroup.Durability durability;
+    private final SharedRealm.Durability durability;
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
-    private final WeakReference<Context> contextWeakRef;
-
-    private RealmConfiguration(Builder builder) {
-        this.realmFolder = builder.folder;
-        this.realmFileName = builder.fileName;
-        this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
-        this.assetFilePath = builder.assetFilePath;
-        this.key = builder.key;
-        this.schemaVersion = builder.schemaVersion;
-        this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
-        this.migration = builder.migration;
-        this.durability = builder.durability;
-        this.schemaMediator = createSchemaMediator(builder);
-        this.rxObservableFactory = builder.rxFactory;
-        this.initialDataTransaction = builder.initialDataTransaction;
-        this.contextWeakRef = builder.contextWeakRef;
+
+    // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
+    // subsets of them.
+    protected RealmConfiguration(File realmDirectory,
+                              String realmFileName,
+                              String canonicalPath,
+                              String assetFilePath,
+                              byte[] key,
+                              long schemaVersion,
+                              RealmMigration migration,
+                              boolean deleteRealmIfMigrationNeeded,
+                              SharedRealm.Durability durability,
+                              RealmProxyMediator schemaMediator,
+                              RxObservableFactory rxObservableFactory,
+                              Realm.Transaction initialDataTransaction) {
+        this.realmDirectory = realmDirectory;
+        this.realmFileName = realmFileName;
+        this.canonicalPath = canonicalPath;
+        this.assetFilePath = assetFilePath;
+        this.key = key;
+        this.schemaVersion = schemaVersion;
+        this.migration = migration;
+        this.deleteRealmIfMigrationNeeded = deleteRealmIfMigrationNeeded;
+        this.durability = durability;
+        this.schemaMediator = schemaMediator;
+        this.rxObservableFactory = rxObservableFactory;
+        this.initialDataTransaction = initialDataTransaction;
     }
 
-    public File getRealmFolder() {
-        return realmFolder;
+    public File getRealmDirectory() {
+        return realmDirectory;
     }
 
     public String getRealmFileName() {
@@ -138,7 +149,7 @@ public boolean shouldDeleteRealmIfMigrationNeeded() {
         return deleteRealmIfMigrationNeeded;
     }
 
-    public SharedGroup.Durability getDurability() {
+    public SharedRealm.Durability getDurability() {
         return durability;
     }
 
@@ -176,12 +187,7 @@ boolean hasAssetFile() {
      * @throws IOException if copying the file fails.
      */
     InputStream getAssetFile() throws IOException {
-        Context context = contextWeakRef.get();
-        if (context != null) {
-            return context.getAssets().open(assetFilePath);
-        } else {
-            throw new IllegalArgumentException("Context should not be null. Use Application Context instead of Activity Context.");
-        }
+        return BaseRealm.applicationContext.getAssets().open(assetFilePath);
     }
 
     /**
@@ -222,7 +228,7 @@ public boolean equals(Object obj) {
 
         if (schemaVersion != that.schemaVersion) return false;
         if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) return false;
-        if (!realmFolder.equals(that.realmFolder)) return false;
+        if (!realmDirectory.equals(that.realmDirectory)) return false;
         if (!realmFileName.equals(that.realmFileName)) return false;
         if (!canonicalPath.equals(that.canonicalPath)) return false;
         if (!Arrays.equals(key, that.key)) return false;
@@ -231,12 +237,15 @@ public boolean equals(Object obj) {
         //noinspection SimplifiableIfStatement
         if (rxObservableFactory != null ? !rxObservableFactory.equals(that.rxObservableFactory) : that.rxObservableFactory != null) return false;
         if (initialDataTransaction != null ? !initialDataTransaction.equals(that.initialDataTransaction) : that.initialDataTransaction != null) return false;
+
         return schemaMediator.equals(that.schemaMediator);
     }
 
+
+
     @Override
     public int hashCode() {
-        int result = realmFolder.hashCode();
+        int result = realmDirectory.hashCode();
         result = 31 * result + realmFileName.hashCode();
         result = 31 * result + canonicalPath.hashCode();
         result = 31 * result + (key != null ? Arrays.hashCode(key) : 0);
@@ -252,10 +261,8 @@ public int hashCode() {
     }
 
     // Creates the mediator that defines the current schema
-    private RealmProxyMediator createSchemaMediator(Builder builder) {
-
-        Set<Object> modules = builder.modules;
-        Set<Class<? extends RealmModel>> debugSchema = builder.debugSchema;
+    protected static RealmProxyMediator createSchemaMediator(Set<Object> modules,
+                                                             Set<Class<? extends RealmModel>> debugSchema) {
 
         // If using debug schema, use special mediator
         if (debugSchema.size() > 0) {
@@ -304,7 +311,7 @@ private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleC
     public String toString() {
         //noinspection StringBufferReplaceableByString
         StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.append("realmFolder: ").append(realmFolder.toString());
+        stringBuilder.append("realmDirectory: ").append(realmDirectory.toString());
         stringBuilder.append("\n");
         stringBuilder.append("realmFileName : ").append(realmFileName);
         stringBuilder.append("\n");
@@ -330,7 +337,7 @@ public String toString() {
      *
      * @return {@code true} if RxJava dependency exist, {@code false} otherwise.
      */
-    private static synchronized boolean isRxJavaAvailable() {
+    static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
             try {
                 Class.forName("rx.Observable");
@@ -342,96 +349,75 @@ private static synchronized boolean isRxJavaAvailable() {
         return rxJavaAvailable;
     }
 
+    // Get the canonical path for a given file
+    protected static String getCanonicalPath(File realmFile) {
+        try {
+            return realmFile.getCanonicalPath();
+        } catch (IOException e) {
+            throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                    "Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath(),
+                    e);
+        }
+    }
+
+    // Check if this configuration is a SyncConfiguration instance.
+    boolean isSyncConfiguration() {
+        return false;
+    }
+
     /**
      * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
      */
-    public static final class Builder {
-        private File folder;
+    public static class Builder {
+         // IMPORTANT: When adding any new methods to this class also add them to SyncConfiguration.
+        private File directory;
         private String fileName;
         private String assetFilePath;
         private byte[] key;
         private long schemaVersion;
         private RealmMigration migration;
         private boolean deleteRealmIfMigrationNeeded;
-        private SharedGroup.Durability durability;
+        private SharedRealm.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
-        private WeakReference<Context> contextWeakRef;
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
 
-        /**
-         * Creates an instance of the Builder for the RealmConfiguration.
-         * The Realm file will be saved in the provided folder.
-         *
-         * @param folder the folder to save Realm file in. Folder must be writable.
-         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
-         * @deprecated Please use {@link #Builder(Context, File)} instead.
-         */
-        @Deprecated
-        public Builder(File folder) {
-            RealmCore.loadLibrary();
-            initializeBuilder(folder);
-        }
-
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
          * <p>
          * This will use the app's own internal directory for storing the Realm file. This does not require any
          * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
          * change depending on vendor implementations of Android.
-         *
-         * @param context the Android application context.
          */
-        public Builder(Context context) {
-            if (context == null) {
-                throw new IllegalArgumentException("A non-null Context must be provided");
-            }
-            RealmCore.loadLibrary(context);
-            initializeBuilder(context.getFilesDir());
+        public Builder() {
+            this(BaseRealm.applicationContext);
         }
 
-        /**
-         * Creates an instance of the Builder for the RealmConfiguration.
-         * <p>
-         * The Realm file will be saved in the provided folder, and it might require additional permissions.
-         *
-         * @param context the Android application context.
-         * @param folder the folder to save Realm file in. Folder must be writable.
-         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
-         */
-        public Builder(Context context, File folder) {
+        Builder(Context context) {
             if (context == null) {
-                throw new IllegalArgumentException("A non-null Context must be provided");
+                throw new IllegalStateException("Call `Realm.init(Context)` before creating a RealmConfiguration");
             }
             RealmCore.loadLibrary(context);
-            initializeBuilder(folder);
+            initializeBuilder(context);
         }
 
         // Setup builder in its initial state
-        private void initializeBuilder(File folder) {
-            if (folder == null || !folder.isDirectory()) {
-                throw new IllegalArgumentException(("An existing folder must be provided. " +
-                        "Yours was " + (folder != null ? folder.getAbsolutePath() : "null")));
-            }
-            if (!folder.canWrite()) {
-                throw new IllegalArgumentException("Folder is not writable: " + folder.getAbsolutePath());
-            }
-
-            this.folder = folder;
+        private void initializeBuilder(Context context) {
+            this.directory = context.getFilesDir();
             this.fileName = Realm.DEFAULT_REALM_NAME;
             this.key = null;
             this.schemaVersion = 0;
             this.migration = null;
             this.deleteRealmIfMigrationNeeded = false;
-            this.durability = SharedGroup.Durability.FULL;
+            this.durability = SharedRealm.Durability.FULL;
             if (DEFAULT_MODULE != null) {
                 this.modules.add(DEFAULT_MODULE);
             }
         }
 
         /**
-         * Sets the filename for the Realm.
+         * Sets the filename for the Realm file.
          */
         public Builder name(String filename) {
             if (filename == null || filename.isEmpty()) {
@@ -442,8 +428,33 @@ public Builder name(String filename) {
             return this;
         }
 
+        /**
+         * Specify the directory where the Realm file will be saved. The default value is {@code context.getFiles()}.
+         * If the directory does not exist, it will be created.
+         *
+         * @param directory the directory to save the Realm file in. Directory must be writable.
+         * @throws IllegalArgumentException if {@code directory} is null, not writable or a file.
+         */
+        public Builder directory(File directory) {
+            if (directory == null) {
+                throw new IllegalArgumentException("Non-null 'dir' required.");
+            }
+            if (directory.isFile()) {
+                throw new IllegalArgumentException("'dir' is a file, not a directory: " + directory.getAbsolutePath() + ".");
+            }
+            if (!directory.exists() && !directory.mkdirs()) {
+                throw new IllegalArgumentException("Could not create the specified directory: " + directory.getAbsolutePath() + ".");
+            }
+            if (!directory.canWrite()) {
+                throw new IllegalArgumentException("Realm directory is not writable: " + directory.getAbsolutePath() + ".");
+            }
+            this.directory = directory;
+            return this;
+        }
+
         /**
          * Sets the 64 bit key used to encrypt and decrypt the Realm file.
+         * Sets the {@value io.realm.RealmConfiguration#KEY_LENGTH} bytes key used to encrypt and decrypt the Realm file.
          */
         public Builder encryptionKey(byte[] key) {
             if (key == null) {
@@ -493,11 +504,11 @@ public Builder migration(RealmMigration migration) {
          * with the new Realm schema.
          *
          * <p>This cannot be configured to have an asset file at the same time by calling
-         * {@link #assetFile(Context, String)} as the provided asset file will be deleted in migrations.
+         * {@link #assetFile(String)} as the provided asset file will be deleted in migrations.
          *
          * <p><b>WARNING!</b> This will result in loss of data.
          *
-         * @throws IllegalStateException if configured to use an asset file by calling {@link #assetFile(Context, String)} previously.
+         * @throws IllegalStateException if configured to use an asset file by calling {@link #assetFile(String)} previously.
          */
         public Builder deleteRealmIfMigrationNeeded() {
             if (this.assetFilePath != null && this.assetFilePath.length() != 0) {
@@ -521,7 +532,7 @@ public Builder inMemory() {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
 
-            this.durability = SharedGroup.Durability.MEM_ONLY;
+            this.durability = SharedRealm.Durability.MEM_ONLY;
 
             return this;
         }
@@ -587,25 +598,20 @@ public Builder initialData(Realm.Transaction transaction) {
          * <p>
          * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
          *
-         * @param context Android application context.
          * @param assetFile path to the asset database file.
          * @throws IllegalStateException if this is configured to clear its schema by calling {@link #deleteRealmIfMigrationNeeded()}.
          */
-        public Builder assetFile(Context context, final String assetFile) {
-            if (context == null) {
-                throw new IllegalArgumentException("A non-null Context must be provided");
-            }
+        public Builder assetFile(final String assetFile) {
             if (TextUtils.isEmpty(assetFile)) {
                 throw new IllegalArgumentException("A non-empty asset file path must be provided");
             }
-            if (durability == SharedGroup.Durability.MEM_ONLY) {
+            if (durability == SharedRealm.Durability.MEM_ONLY) {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
             if (this.deleteRealmIfMigrationNeeded) {
                 throw new IllegalStateException("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().");
             }
 
-            this.contextWeakRef = new WeakReference<>(context);
             this.assetFilePath = assetFile;
 
             return this;
@@ -646,7 +652,20 @@ public RealmConfiguration build() {
             if (rxFactory == null && isRxJavaAvailable()) {
                 rxFactory = new RealmObservableFactory();
             }
-            return new RealmConfiguration(this);
+
+            return new RealmConfiguration(directory,
+                    fileName,
+                    getCanonicalPath(new File(directory, fileName)),
+                    assetFilePath,
+                    key,
+                    schemaVersion,
+                    migration,
+                    deleteRealmIfMigrationNeeded,
+                    durability,
+                    createSchemaMediator(modules, debugSchema),
+                    rxFactory,
+                    initialDataTransaction
+            );
         }
 
         private void checkModule(Object module) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index d6397ef789..1fcb3fedef 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -49,7 +49,7 @@
  * @param <E> the class of objects in list.
  */
 
-public final class RealmList<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
+public class RealmList<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
     private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
     private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
@@ -114,19 +114,26 @@ public RealmList(E... objects) {
     }
 
     /**
-     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e., the {@link io.realm.Realm}
-     * instance hasn't been closed.
-     *
-     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an unmanaged list.
+     * {@inheritDoc}
      */
     public boolean isValid() {
+        if (realm == null) {
+            return true;
+        }
         //noinspection SimplifiableIfStatement
-        if (realm == null || realm.isClosed()) {
+        if (realm.isClosed()) {
             return false;
         }
         return isAttached();
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isManaged() {
+        return realm != null;
+    }
+
     private boolean isAttached() {
         return view != null && view.isAttached();
     }
@@ -449,30 +456,62 @@ public E get(int location) {
      * {@inheritDoc}
      */
     public E first() {
+        return firstImpl(true, null);
+    }
+
+    /**
+    * {@inheritDoc}
+    */
+    public E first(E defaultValue) {
+        return firstImpl(false, defaultValue);
+    }
+
+    private E firstImpl(boolean shouldThrow, E defaultValue) {
         if (managedMode) {
             checkValidView();
             if (!view.isEmpty()) {
                 return get(0);
             }
-        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+        } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
             return unmanagedList.get(0);
         }
-        throw new IndexOutOfBoundsException("The list is empty.");
+        
+        if (shouldThrow) {
+            throw new IndexOutOfBoundsException("The list is empty.");
+        } else {
+            return defaultValue;
+        }
     }
 
     /**
      * {@inheritDoc}
      */
     public E last() {
+        return lastImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public E last(E defaultValue) {
+        return lastImpl(false, defaultValue);
+    }
+
+    private E lastImpl(boolean shouldThrow, E defaultValue) {
         if (managedMode) {
             checkValidView();
             if (!view.isEmpty()) {
                 return get((int) view.size() - 1);
             }
-        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+        } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
             return unmanagedList.get(unmanagedList.size() - 1);
         }
-        throw new IndexOutOfBoundsException("The list is empty.");
+
+        if (shouldThrow) {
+            throw new IndexOutOfBoundsException("The list is empty.");
+        } else {
+            return defaultValue;
+        }
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index b621f26571..ed03ec6e4b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -114,7 +114,7 @@ public final void deleteFromRealm() {
 
     /**
      * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * {@link io.realm.Realm} been closed. It will always return {@code true} for unmanaged objects.
      * <p>
      * Note that this can be used to check the validity of certain conditions such as being {@code null}
      * when observed.
@@ -126,7 +126,7 @@ public final void deleteFromRealm() {
      * }
      * </pre>
      *
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
+     * @return {@code true} if the object is still accessible or an unmanaged object, {@code false} otherwise.
      * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
     public final boolean isValid() {
@@ -135,10 +135,10 @@ public final boolean isValid() {
 
     /**
      * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * {@link io.realm.Realm} been closed. It will always return {@code true} for unmanaged objects.
      *
      * @param object RealmObject to check validity for.
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
+     * @return {@code true} if the object is still accessible or an unmanaged object, {@code false} otherwise.
      */
     public static <E extends RealmModel> boolean isValid(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -146,7 +146,7 @@ public final boolean isValid() {
             Row row = proxy.realmGet$proxyState().getRow$realm();
             return row != null && row.isAttached();
         } else {
-            return false;
+            return true;
         }
     }
 
@@ -241,6 +241,52 @@ public final boolean isLoaded() {
         }
     }
 
+    /**
+     * Checks if this object is managed by Realm. A managed object is just a wrapper around the data in the underlying
+     * Realm file. On Looper threads, a managed object will be live-updated so it always points to the latest data. It
+     * is possible to register a change listener using {@link #addChangeListener(RealmChangeListener)} to be notified
+     * when changes happen. Managed objects are thread confined so that they cannot be accessed from other threads than
+     * the one that created them.
+     * <p>
+     *
+     * If this method returns {@code false}, the object is unmanaged. An unmanaged object is just a normal Java object,
+     * so it can be parsed freely across threads, but the data in the object is not connected to the underlying Realm,
+     * so it will not be live updated.
+     * <p>
+     *
+     * It is possible to create a managed object from an unmanaged object by using
+     * {@link Realm#copyToRealm(RealmModel)}. An unmanaged object can be created from a managed object by using
+     * {@link Realm#copyFromRealm(RealmModel)}.
+     *
+     * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
+     */
+    public boolean isManaged() {
+        return isManaged(this);
+    }
+
+    /**
+     * Checks if this object is managed by Realm. A managed object is just a wrapper around the data in the underlying
+     * Realm file. On Looper threads, a managed object will be live-updated so it always points to the latest data. It
+     * is possible to register a change listener using {@link #addChangeListener(RealmModel, RealmChangeListener)} to be
+     * notified when changes happen. Managed objects are thread confined so that they cannot be accessed from other threads
+     * than the one that created them.
+     * <p>
+     *
+     * If this method returns {@code false}, the object is unmanaged. An unmanaged object is just a normal Java object,
+     * so it can be parsed freely across threads, but the data in the object is not connected to the underlying Realm,
+     * so it will not be live updated.
+     * <p>
+     *
+     * It is possible to create a managed object from an unmanaged object by using
+     * {@link Realm#copyToRealm(RealmModel)}. An unmanaged object can be created from a managed object by using
+     * {@link Realm#copyFromRealm(RealmModel)}.
+     *
+     * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
+     */
+    public static <E extends RealmModel> boolean isManaged(E object) {
+        return object instanceof RealmObjectProxy;
+    }
+
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index ac48a48f19..e4d8115237 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -16,11 +16,6 @@
 
 package io.realm;
 
-import io.realm.annotations.Required;
-import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
@@ -29,13 +24,17 @@
 import java.util.Map;
 import java.util.Set;
 
+import io.realm.annotations.Required;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+
 /**
  * Class for interacting with the schema for a given RealmObject class. This makes it possible to
  * add, delete or change the fields for given class.
  *
  * @see io.realm.RealmMigration
  */
-public final class RealmObjectSchema {
+public class RealmObjectSchema {
 
     private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
     static {
@@ -68,8 +67,8 @@
 
     private final BaseRealm realm;
     final Table table;
-    private final ImplicitTransaction transaction;
     private final Map<String, Long> columnIndices;
+    private final long nativePtr;
 
     /**
      * Creates a schema object for a given Realm class.
@@ -80,9 +79,49 @@
      */
     RealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
         this.realm = realm;
-        this.transaction = realm.sharedGroupManager.getTransaction();
         this.table = table;
         this.columnIndices = columnIndices;
+        this.nativePtr = 0;
+    }
+
+    /**
+     * Creates a schema object using object store. This constructor is intended to be used by
+     * the validation of schema, object schemas and prorperties through the object store. Even though the constructor
+     * is public, there is never a purpose which justifies calling it!
+     *
+     * @param className name of the class
+     */
+    RealmObjectSchema(String className) {
+        this.realm = null;
+        this.table = null;
+        this.columnIndices = null;
+        this.nativePtr = nativeCreateRealmObjectSchema(className);
+    }
+
+    protected RealmObjectSchema(long nativePtr) {
+        this.realm = null;
+        this.table = null;
+        this.columnIndices = null;
+        this.nativePtr = nativePtr;
+    }
+
+    /**
+     * Closes/frees native resource. Even though the method is public, there is never a purpose which justifies calling
+     * it!
+     */
+    public void close() {
+        if (nativePtr != 0) {
+            Set<Property> properties = getProperties();
+            for (Property property : properties) {
+                property.close();
+            }
+            nativeClose(nativePtr);
+        }
+    }
+
+
+    protected long getNativePtr() {
+        return nativePtr;
     }
 
     /**
@@ -96,7 +135,11 @@
      * @return the name of the RealmObject class represented by this schema.
      */
     public String getClassName() {
-        return table.getName().substring(Table.TABLE_PREFIX.length());
+        if (realm == null) {
+            return nativeGetClassName(nativePtr);
+        } else {
+            return table.getName().substring(Table.TABLE_PREFIX.length());
+        }
     }
 
     /**
@@ -108,13 +151,13 @@ public String getClassName() {
      * @see RealmSchema#rename(String, String)
      */
     public RealmObjectSchema setClassName(String className) {
+        realm.checkNotInSync(); // renaming a table is not permitted
         checkEmpty(className);
         String internalTableName = Table.TABLE_PREFIX + className;
-        //FIXME : when core implements class name length check, please remove.
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
             throw new IllegalArgumentException("Class name is to long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
         }
-        if (transaction.hasTable(internalTableName)) {
+        if (realm.sharedRealm.hasTable(internalTableName)) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
         // in case this table has a primary key, we need to transfer it after renaming the table.
@@ -125,13 +168,13 @@ public RealmObjectSchema setClassName(String className) {
             pkField = getPrimaryKey();
             table.setPrimaryKey(null);
         }
-        transaction.renameTable(table.getName(), internalTableName);
+        realm.sharedRealm.renameTable(table.getName(), internalTableName);
         if (pkField != null && !pkField.isEmpty()) {
             try {
                 table.setPrimaryKey(pkField);
             } catch (Exception e) {
                 // revert the table name back when something goes wrong
-                transaction.renameTable(table.getName(), oldTableName);
+                realm.sharedRealm.renameTable(table.getName(), oldTableName);
                 throw e;
             }
         }
@@ -192,7 +235,7 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
     public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
         checkLegalName(fieldName);
         checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, transaction.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
         return this;
     }
 
@@ -207,10 +250,38 @@ public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema
     public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
         checkLegalName(fieldName);
         checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, transaction.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Adds a property to an object schema. This method should only be used by proxy classes to set up a schema.
+     *
+     * @param property the property to add.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the method is called after opening a Realm.
+     */
+    protected RealmObjectSchema add(Property property) {
+        if (realm != null && nativePtr == 0) {
+            throw new IllegalArgumentException("Don't use this method.");
+        }
+        nativeAddProperty(nativePtr, property.getNativePtr());
         return this;
     }
 
+    private Set<Property> getProperties() {
+        if (realm == null) {
+            long[] ptrs = nativeGetProperties(nativePtr);
+            Set<Property> properties = new LinkedHashSet<>(ptrs.length);
+            for (int i = 0; i < ptrs.length; i++) {
+                properties.add(new Property(ptrs[i]));
+            }
+            return properties;
+        } else {
+            throw new IllegalArgumentException("Not possible");
+        }
+    }
+
     /**
      * Removes a field from the class.
      *
@@ -219,6 +290,7 @@ public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema o
      * @throws IllegalArgumentException if field name doesn't exist.
      */
     public RealmObjectSchema removeField(String fieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
         checkLegalName(fieldName);
         if (!hasField(fieldName)) {
             throw new IllegalStateException(fieldName + " does not exist.");
@@ -240,6 +312,7 @@ public RealmObjectSchema removeField(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
      */
     public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
         checkLegalName(currentFieldName);
         checkFieldExists(currentFieldName);
         checkLegalName(newFieldName);
@@ -305,6 +378,7 @@ public boolean hasIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
      */
     public RealmObjectSchema removeIndex(String fieldName) {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         checkLegalName(fieldName);
         checkFieldExists(fieldName);
         long columnIndex = getColumnIndex(fieldName);
@@ -347,6 +421,7 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
      */
     public RealmObjectSchema removePrimaryKey() {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         if (!table.hasPrimaryKey()) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
@@ -778,4 +853,10 @@ public int size() {
             throw new UnsupportedOperationException();
         }
     }
+
+    static native long nativeCreateRealmObjectSchema(String className);
+    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
+    static native long[] nativeGetProperties(long nativePtr);
+    static native void nativeClose(long nativePtr);
+    static native String nativeGetClassName(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index afbe21db21..b9f6cc31c5 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -17,10 +17,9 @@
 package io.realm;
 
 
-import android.os.Handler;
-
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.Locale;
@@ -28,11 +27,11 @@
 import java.util.concurrent.Future;
 
 import io.realm.annotations.Required;
-import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.TableQuery;
@@ -40,7 +39,7 @@
 import io.realm.internal.async.ArgumentsHolder;
 import io.realm.internal.async.BadVersionException;
 import io.realm.internal.async.QueryUpdateTask;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
@@ -60,14 +59,14 @@
  * @see Realm#where(Class)
  * @see RealmResults#where()
  */
-public final class RealmQuery<E extends RealmModel> {
+public class RealmQuery<E extends RealmModel> {
 
     private BaseRealm realm;
     private Class<E> clazz;
     private String className;
     private TableOrView table;
     private RealmObjectSchema schema;
-    private LinkView view;
+    private LinkView linkView;
     private TableQuery query;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
@@ -138,7 +137,7 @@ private RealmQuery(Realm realm, Class<E> clazz) {
         this.clazz = clazz;
         this.schema = realm.schema.getSchemaForClass(clazz);
         this.table = schema.table;
-        this.view = null;
+        this.linkView = null;
         this.query = table.where();
     }
 
@@ -146,18 +145,18 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
         this.schema = realm.schema.getSchemaForClass(clazz);
-        this.table = queryResults.getTable();
-        this.view = null;
-        this.query = queryResults.getTable().where();
+        this.table = queryResults.getTableOrView();
+        this.linkView = null;
+        this.query = this.table.where();
     }
 
-    private RealmQuery(BaseRealm realm, LinkView view, Class<E> clazz) {
+    private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.query = view.where();
-        this.view = view;
         this.schema = realm.schema.getSchemaForClass(clazz);
         this.table = schema.table;
+        this.linkView = linkView;
+        this.query = linkView.where();
     }
 
     private RealmQuery(BaseRealm realm, String className) {
@@ -173,16 +172,16 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
         this.className = className;
         this.schema = realm.schema.getSchemaForClass(className);
         this.table = schema.table;
-        this.query = queryResults.getTable().where();
+        this.query = queryResults.getTableOrView().where();
     }
 
-    private RealmQuery(BaseRealm realm, LinkView view, String className) {
+    private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
         this.realm = realm;
         this.className = className;
-        this.query = view.where();
-        this.view = view;
         this.schema = realm.schema.getSchemaForClass(className);
         this.table = schema.table;
+        this.linkView = linkView;
+        this.query = linkView.where();
     }
 
     /**
@@ -196,8 +195,8 @@ public boolean isValid() {
             return false;
         }
 
-        if (view != null) {
-            return view.isAttached();
+        if (linkView != null) {
+            return linkView.isAttached();
         }
         return table != null && table.getTable().isValid();
     }
@@ -1362,16 +1361,16 @@ public boolean isValid() {
     public RealmResults<E> distinctAsync(String fieldName) {
         checkQueryIsNotReused();
         final long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
         // save query arguments (for future update)
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_DISTINCT);
         argumentsHolder.columnIndex = columnIndex;
 
-        // we need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the query
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
@@ -1391,35 +1390,30 @@ public boolean isValid() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
-
-                        long handoverTableViewPointer = query.
-                                findDistinctWithHandover(sharedGroup.getNativePointer(),
-                                        sharedGroup.getNativeReplicationPointer(),
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
+
+                        long handoverTableViewPointer = TableQuery.
+                                findDistinctWithHandover(sharedRealm,
                                         handoverQueryPointer,
                                         columnIndex);
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                         return handoverTableViewPointer;
                     } catch (Throwable e) {
-                        RealmLog.e(e.getMessage(), e);
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                        RealmLog.error(e);
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm != null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1671,15 +1665,15 @@ public long count() {
      */
     public RealmResults<E> findAllAsync() {
         checkQueryIsNotReused();
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
         // save query arguments (for future update)
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL);
 
-        // we need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the query
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
@@ -1699,40 +1693,37 @@ public long count() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                         // Run the query & handover the table view for the caller thread
                         // Note: the handoverQueryPointer contains the versionID needed by the SG in order
                         // to import it.
-                        long handoverTableViewPointer = query.findAllWithHandover(sharedGroup.getNativePointer(), sharedGroup.getNativeReplicationPointer(), handoverQueryPointer);
+                        long handoverTableViewPointer = TableQuery.findAllWithHandover(sharedRealm,
+                                handoverQueryPointer);
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                         return handoverTableViewPointer;
 
                     } catch (BadVersionException e) {
                         // In some rare race conditions, this can happen. In that case, just ignore the error.
-                        RealmLog.d("findAllAsync handover could not complete due to a BadVersionException. " +
+                        RealmLog.debug("findAllAsync handover could not complete due to a BadVersionException. " +
                                 "Retry is scheduled by a REALM_CHANGED event.");
 
                     } catch (Throwable e) {
-                        RealmLog.e(e.getMessage(), e);
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                        RealmLog.error(e);
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm != null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1794,12 +1785,12 @@ public Long call() throws Exception {
         argumentsHolder.sortOrder = sortOrder;
         argumentsHolder.columnIndex = columnIndex;
 
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-        // we need to use the same configuration to open a background SharedGroup to perform the query
+        // we need to use the same configuration to open a background SharedRealm to perform the query
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
         RealmResults<E> realmResults;
@@ -1817,40 +1808,37 @@ public Long call() throws Exception {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                         long columnIndex = getColumnIndexForSort(fieldName);
 
                         // run the query & handover the table view for the caller thread
-                        long handoverTableViewPointer = query.findAllSortedWithHandover(sharedGroup.getNativePointer(),
-                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, columnIndex, sortOrder);
+                        long handoverTableViewPointer = TableQuery.findAllSortedWithHandover(sharedRealm,
+                                 handoverQueryPointer, columnIndex, sortOrder);
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                         return handoverTableViewPointer;
                     } catch (BadVersionException e) {
                         // In some rare race conditions, this can happen. In that case, just ignore the error.
-                        RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
+                        RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                 "Retry is scheduled by a REALM_CHANGED event.");
 
                     } catch (Throwable e) {
-                        RealmLog.e(e.getMessage(), e);
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                        RealmLog.error(e);
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
 
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm!= null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1957,12 +1945,12 @@ private boolean isDynamicQuery() {
             return findAllSortedAsync(fieldNames[0], sortOrders[0]);
 
         } else {
-            final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+            final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
             // Handover the query (to be used by a worker thread)
-            final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+            final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-            // We need to use the same configuration to open a background SharedGroup to perform the query
+            // We need to use the same configuration to open a background SharedRealm to perform the query
             final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
             final long indices[] = new long[fieldNames.length];
@@ -1992,38 +1980,34 @@ private boolean isDynamicQuery() {
                 @Override
                 public Long call() throws Exception {
                     if (!Thread.currentThread().isInterrupted()) {
-                        SharedGroup sharedGroup = null;
+                        SharedRealm sharedRealm = null;
 
                         try {
-                            sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                    SharedGroup.IMPLICIT_TRANSACTION,
-                                    realmConfiguration.getDurability(),
-                                    realmConfiguration.getEncryptionKey());
+                            sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                             // run the query & handover the table view for the caller thread
-                            long handoverTableViewPointer = query.findAllMultiSortedWithHandover(sharedGroup.getNativePointer(),
-                                    sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, indices, sortOrders);
+                            long handoverTableViewPointer = TableQuery.findAllMultiSortedWithHandover(sharedRealm,
+                                    handoverQueryPointer, indices, sortOrders);
 
                             QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                             result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                            result.versionID = sharedGroup.getVersion();
-                            closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                    weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
+                            result.versionID = sharedRealm.getVersionID();
+                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                    weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                             return handoverTableViewPointer;
                         } catch (BadVersionException e) {
                             // In some rare race conditions, this can happen. In that case, just ignore the error.
-                            RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
+                            RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                     "Retry is scheduled by a REALM_CHANGED event.");
 
                         } catch (Throwable e) {
-                            RealmLog.e(e.getMessage(), e);
-                            closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                    weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                            RealmLog.error(e);
+                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                    weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                         } finally {
-                            if (sharedGroup != null && !sharedGroup.isClosed()) {
-                                sharedGroup.close();
+                            if (sharedRealm != null && !sharedRealm.isClosed()) {
+                                sharedRealm.close();
                             }
                         }
                     } else {
@@ -2081,9 +2065,9 @@ public Long call() throws Exception {
      */
     public E findFirst() {
         checkQueryIsNotReused();
-        long sourceRowIndex = getSourceRowIndexForFirstObject();
-        if (sourceRowIndex >= 0) {
-            E realmObject = realm.get(clazz, className, sourceRowIndex);
+        long tableRowIndex = getSourceRowIndexForFirstObject();
+        if (tableRowIndex >= 0) {
+            E realmObject = realm.get(clazz, className, tableRowIndex);
             return realmObject;
         } else {
             return null;
@@ -2103,10 +2087,10 @@ public E findFirst() {
      */
     public E findFirstAsync() {
         checkQueryIsNotReused();
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
         // save query arguments (for future update)
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_FIRST);
@@ -2118,30 +2102,26 @@ public E findFirstAsync() {
         final E result;
         if (isDynamicQuery()) {
             //noinspection unchecked
-            result = (E) new DynamicRealmObject(className);
+            result = (E) new DynamicRealmObject(className, realm, Row.EMPTY_ROW);
         } else {
-            result = realm.getConfiguration().getSchemaMediator().newInstance(clazz, realm.getSchema().getColumnInfo(clazz));
+            result = realm.getConfiguration().getSchemaMediator().newInstance(
+                    clazz, realm, Row.EMPTY_ROW, realm.getSchema().getColumnInfo(clazz),
+                    false, Collections.<String>emptyList());
         }
 
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
+        final RealmObjectProxy proxy = (RealmObjectProxy) result;
         final WeakReference<RealmObjectProxy> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(proxy, this);
-        proxy.realmGet$proxyState().setRealm$realm(realm);
-        proxy.realmGet$proxyState().setRow$realm(Row.EMPTY_ROW);
 
         final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
-                        long handoverRowPointer = query.findWithHandover(sharedGroup.getNativePointer(),
-                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer);
+                        long handoverRowPointer = TableQuery.findWithHandover(sharedRealm, handoverQueryPointer);
                         if (handoverRowPointer == 0) { // empty row
                             realm.handlerController.addToEmptyAsyncRealmObject(realmObjectWeakReference, RealmQuery.this);
                             realm.handlerController.removeFromAsyncRealmObject(realmObjectWeakReference);
@@ -2149,21 +2129,20 @@ public Long call() throws Exception {
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmObjectResponse();
                         result.updatedRow.put(realmObjectWeakReference, handoverRowPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT, result);
 
                         return handoverRowPointer;
 
                     } catch (Throwable e) {
-                        RealmLog.e(e.getMessage(), e);
+                        RealmLog.error(e);
                         // handler can't throw a checked exception need to wrap it into unchecked Exception
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm != null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -2192,23 +2171,39 @@ private void checkSortParameters(String fieldNames[], final Sort[] sortOrders) {
         }
     }
 
-    private WeakReference<Handler> getWeakReferenceHandler() {
-        if (realm.handler == null) {
+    private WeakReference<RealmNotifier> getWeakReferenceNotifier() {
+        if (realm.sharedRealm.realmNotifier == null || !realm.sharedRealm.realmNotifier.isValid()) {
             throw new IllegalStateException("Your Realm is opened from a thread without a Looper." +
                     " Async queries need a Handler to send results of your query");
         }
-        return new WeakReference<Handler>(realm.handler); // use caller Realm's Looper
+        return new WeakReference<RealmNotifier>(realm.sharedRealm.realmNotifier); // use caller Realm's Looper
     }
 
     // The shared group needs to be closed before sending the message to other threads to avoid timing problems.
     // eg.: The other thread wants to delete Realm when getting notified.
-    private void closeSharedGroupAndSendMessageToHandler(SharedGroup sharedGroup, WeakReference<Handler> weakHandler, int what, Object obj) {
-        if (sharedGroup != null) {
-            sharedGroup.close();
-        }
-        Handler handler = weakHandler.get();
-        if (handler != null && handler.getLooper().getThread().isAlive()) {
-            handler.obtainMessage(what, obj).sendToTarget();
+    private void closeSharedRealmAndSendEventToNotifier(SharedRealm sharedRealm,
+                                                         WeakReference<RealmNotifier> weakNotifier,
+                                                        QueryUpdateTask.NotifyEvent event, Object obj) {
+        if (sharedRealm != null) {
+            sharedRealm.close();
+        }
+
+        RealmNotifier notifier = weakNotifier.get();
+        if (notifier!= null) {
+            switch (event) {
+                case COMPLETE_ASYNC_RESULTS:
+                    notifier.completeAsyncResults((QueryUpdateTask.Result)obj);
+                    break;
+                case COMPLETE_ASYNC_OBJECT:
+                    notifier.completeAsyncObject((QueryUpdateTask.Result)obj);
+                    break;
+                case THROW_BACKGROUND_EXCEPTION:
+                    notifier.throwBackgroundException((Throwable)obj);
+                    break;
+                default:
+                    // Should not get here.
+                    throw new IllegalStateException(String.format("%s is not handled here.", event));
+            }
         }
     }
 
@@ -2223,19 +2218,9 @@ private void checkQueryIsNotReused() {
     }
 
     private long getSourceRowIndexForFirstObject() {
-        long rowIndex = this.query.find();
-        if (rowIndex < 0) {
-            return rowIndex;
-        }
-        if (this.view != null) {
-            return view.getTargetRowIndex(rowIndex);
-        } else if (table instanceof TableView){
-            return ((TableView) table).getSourceRowIndex(rowIndex);
-        } else {
-            return rowIndex;
-        }
+        long tableRowIndex = this.query.find();
+        return tableRowIndex;
     }
-
     // Get the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
     // or it belongs to the child object.
     private long getColumnIndexForSort(String fieldName) {
@@ -2264,6 +2249,6 @@ public ArgumentsHolder getArgument() {
      * @return the exported handover pointer for this RealmQuery.
      */
     long handoverQueryPointer() {
-        return query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        return query.handoverQuery(realm.sharedRealm);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index e09d96904e..6311d45e47 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -38,7 +38,7 @@
 import io.realm.internal.TableQuery;
 import io.realm.internal.TableView;
 import io.realm.internal.async.BadVersionException;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -68,11 +68,11 @@
  * @see RealmQuery#findAll()
  * @see io.realm.Realm#executeTransaction(Realm.Transaction)
  */
-public final class RealmResults<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
+public class RealmResults<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
     private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by RealmResults.";
 
-    BaseRealm realm;
+    final BaseRealm realm;
     Class<E> classSpec;   // Return type
     String className;     // Class name used by DynamicRealmObjects
     private TableOrView table = null;
@@ -146,7 +146,7 @@ private RealmResults(BaseRealm realm, TableOrView table, String className) {
         this.currentTableViewVersion = table.syncIfNeeded();
     }
 
-    TableOrView getTable() {
+    TableOrView getTableOrView() {
         if (table == null) {
             return realm.schema.getTable(classSpec);
         } else {
@@ -158,7 +158,17 @@ TableOrView getTable() {
      * {@inheritDoc}
      */
     public boolean isValid() {
-        return realm != null && !realm.isClosed();
+        return !realm.isClosed();
+    }
+
+    /**
+     * A {@link RealmResults} is always a managed collection.
+     *
+     * @return {@code true}.
+     * @see RealmCollection#isManaged()
+     */
+    public boolean isManaged() {
+        return true;
     }
 
     /**
@@ -167,7 +177,6 @@ public boolean isValid() {
     @Override
     public RealmQuery<E> where() {
         realm.checkIfValid();
-
         return RealmQuery.createQueryFromResult(this);
     }
 
@@ -201,7 +210,7 @@ public boolean contains(Object object) {
     public E get(int location) {
         E obj;
         realm.checkIfValid();
-        TableOrView table = getTable();
+        TableOrView table = getTableOrView();
         if (table instanceof TableView) {
             obj = realm.get(classSpec, className, ((TableView) table).getSourceRowIndex(location));
         } else {
@@ -216,10 +225,26 @@ public E get(int location) {
      */
     @Override
     public E first() {
-        if (size() > 0) {
+        return firstImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E first(E defaultValue) {
+        return firstImpl(false, defaultValue);
+    }
+
+    private E firstImpl(boolean shouldThrow, E defaultValue) {
+        if (!isEmpty()) {
             return get(0);
         } else {
-            throw new IndexOutOfBoundsException("No results were found.");
+            if (shouldThrow) {
+                throw new IndexOutOfBoundsException("No results were found.");
+            } else {
+                return defaultValue;
+            }
         }
     }
 
@@ -228,11 +253,27 @@ public E first() {
      */
     @Override
     public E last() {
-        int size = size();
-        if (size > 0) {
-            return get(size - 1);
+        return lastImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E last(E defaultValue) {
+        return lastImpl(false, defaultValue);
+        
+    }
+
+    private E lastImpl(boolean shouldThrow, E defaultValue) {
+        if (!isEmpty()) {
+            return get(size() - 1);
         } else {
-            throw new IndexOutOfBoundsException("No results were found.");
+            if (shouldThrow) {
+                throw new IndexOutOfBoundsException("No results were found.");
+            } else {
+                return defaultValue;
+            }
         }
     }
 
@@ -242,7 +283,7 @@ public E last() {
     @Override
     public void deleteFromRealm(int location) {
         realm.checkIfValid();
-        TableOrView table = getTable();
+        TableOrView table = getTableOrView();
         table.remove(location);
     }
 
@@ -253,7 +294,7 @@ public void deleteFromRealm(int location) {
     public boolean deleteAllFromRealm() {
         realm.checkIfValid();
         if (size() > 0) {
-            TableOrView table = getTable();
+            TableOrView table = getTableOrView();
             table.clear();
             return true;
         } else {
@@ -372,7 +413,7 @@ public int size() {
         if (!isLoaded()) {
             return 0;
         } else {
-            long size = getTable().size();
+            long size = getTableOrView().size();
             return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
         }
     }
@@ -499,7 +540,7 @@ public double average(String fieldName) {
         realm.checkIfValid();
         long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
 
-        TableOrView tableOrView = getTable();
+        TableOrView tableOrView = getTableOrView();
         if (tableOrView instanceof Table) {
             this.table = ((Table) tableOrView).getDistinctView(columnIndex);
         } else {
@@ -608,7 +649,7 @@ public boolean retainAll(Collection<?> collection) {
     public boolean deleteLastFromRealm() {
         realm.checkIfValid();
         if (size() > 0) {
-            TableOrView table = getTable();
+            TableOrView table = getTableOrView();
             table.removeLast();
             return true;
         } else {
@@ -638,7 +679,7 @@ void syncIfNeeded() {
     @Override
     public boolean deleteFirstFromRealm() {
         if (size() > 0) {
-            TableOrView table = getTable();
+            TableOrView table = getTableOrView();
             table.removeFirst();
             return true;
         } else {
@@ -837,7 +878,7 @@ public void set(E object) {
      */
     void swapTableViewPointer(long handoverTableViewPointer) {
         try {
-            table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedGroupManager.getNativePointer());
+            table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedRealm);
             asyncQueryCompleted = true;
         } catch (BadVersionException e) {
             throw new IllegalStateException("Caller and Worker Realm should have been at the same version");
@@ -903,11 +944,11 @@ private boolean onAsyncQueryCompleted() {
             // this may fail with BadVersionException if the caller and/or the worker thread
             // are not in sync. COMPLETED_ASYNC_REALM_RESULTS will be fired by the worker thread
             // this should handle more complex use cases like retry, ignore etc
-            table = query.importHandoverTableView(tvHandover, realm.sharedGroupManager.getNativePointer());
+            table = query.importHandoverTableView(tvHandover, realm.sharedRealm);
             asyncQueryCompleted = true;
             notifyChangeListeners(true);
         } catch (Exception e) {
-            RealmLog.d(e.getMessage());
+            RealmLog.debug(e.getMessage());
             return false;
         }
         return true;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index f2c723ad31..7713b75854 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
@@ -23,7 +24,6 @@
 
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.Table;
 import io.realm.internal.Util;
 
@@ -35,7 +35,7 @@
  *
  * @see io.realm.RealmMigration
  */
-public final class RealmSchema {
+public class RealmSchema {
 
     private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
     private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
@@ -49,16 +49,52 @@
     // Caches Class Strings to their Schema object
     private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
 
-    private final ImplicitTransaction transaction;
     private final BaseRealm realm;
+    private long nativePtr;
     ColumnIndices columnIndices; // Cached field look up
 
     /**
      * Creates a wrapper to easily manipulate the current schema of a Realm.
      */
-    RealmSchema(BaseRealm realm, ImplicitTransaction transaction) {
+    RealmSchema(BaseRealm realm) {
         this.realm = realm;
-        this.transaction = transaction;
+        this.nativePtr = 0;
+    }
+
+    /**
+     * Creates a wrappor to easily manipulate Object Store schemas. This constructor should only be called by
+     * proxy classes during validation of schema.
+     */
+    RealmSchema() {
+        // This is the case where the schema is created from the proxy classes.
+        // dynamicClassToSchema is used to keep track of which model classes have been processed.
+        this.realm = null;
+        this.nativePtr = 0;
+        // TODO: create a Object Store realm::Schema object and store the native pointer
+    }
+
+
+    RealmSchema(ArrayList<RealmObjectSchema> realmObjectSchemas) {
+        long list[] = new long[realmObjectSchemas.size()];
+        for (int i = 0; i < realmObjectSchemas.size(); i++) {
+            list[i] = realmObjectSchemas.get(i).getNativePtr();
+        }
+        this.nativePtr = nativeCreateFromList(list);
+        this.realm = null;
+    }
+
+    public long getNativePtr() {
+        return this.nativePtr;
+    }
+
+    public void close() {
+        if (nativePtr != 0) {
+            Set<RealmObjectSchema> schemas = getAll();
+            for (RealmObjectSchema schema : schemas) {
+                schema.close();
+            }
+            nativeClose(nativePtr);
+        }
     }
 
     /**
@@ -70,13 +106,21 @@
      */
     public RealmObjectSchema get(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
-        String internalClassName = TABLE_PREFIX + className;
-        if (transaction.hasTable(internalClassName)) {
-            Table table = transaction.getTable(internalClassName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            return new RealmObjectSchema(realm, table, columnIndices);
+        if (realm == null) {
+            if (contains(className)) {
+                return dynamicClassToSchema.get(className);
+            } else {
+                return null;
+            }
         } else {
-            return null;
+            String internalClassName = TABLE_PREFIX + className;
+            if (realm.sharedRealm.hasTable(internalClassName)) {
+                Table table = realm.sharedRealm.getTable(internalClassName);
+                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+                return new RealmObjectSchema(realm, table, columnIndices);
+            } else {
+                return null;
+            }
         }
     }
 
@@ -86,18 +130,27 @@ public RealmObjectSchema get(String className) {
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
     public Set<RealmObjectSchema> getAll() {
-        int tableCount = (int) transaction.size();
-        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
-        for (int i = 0; i < tableCount; i++) {
-            String tableName = transaction.getTableName(i);
-            if (Table.isMetaTable(tableName)) {
-                continue;
+        if (realm == null) {
+            long[] ptrs = nativeGetAll(nativePtr);
+            Set<RealmObjectSchema> schemas = new LinkedHashSet<>(ptrs.length);
+            for (int i = 0; i < ptrs.length; i++) {
+                schemas.add(new RealmObjectSchema(ptrs[i]));
             }
-            Table table = transaction.getTable(tableName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+            return schemas;
+        } else {
+            int tableCount = (int) realm.sharedRealm.size();
+            Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+            for (int i = 0; i < tableCount; i++) {
+                String tableName = realm.sharedRealm.getTableName(i);
+                if (!Table.isModelTable(tableName)) {
+                    continue;
+                }
+                Table table = realm.sharedRealm.getTable(tableName);
+                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+                schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+            }
+            return schemas;
         }
-        return schemas;
     }
 
     /**
@@ -107,17 +160,24 @@ public RealmObjectSchema get(String className) {
      * @return a Realm schema object for that class.
      */
     public RealmObjectSchema create(String className) {
+        // adding a class is always permitted
         checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = TABLE_PREFIX + className;
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
-        }
-        if (transaction.hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
+        if (realm == null) {
+            RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
+            dynamicClassToSchema.put(className, realmObjectSchema);
+            return realmObjectSchema;
+        } else {
+            String internalTableName = TABLE_PREFIX + className;
+            if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+                throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
+            }
+            if (realm.sharedRealm.hasTable(internalTableName)) {
+                throw new IllegalArgumentException("Class already exists: " + className);
+            }
+            Table table = realm.sharedRealm.getTable(internalTableName);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            return new RealmObjectSchema(realm, table, columnIndices);
         }
-        Table table = transaction.getTable(internalTableName);
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
     }
 
     /**
@@ -127,6 +187,7 @@ public RealmObjectSchema create(String className) {
      * @param className name of the class to remove.
      */
     public void remove(String className) {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         checkEmpty(className, EMPTY_STRING_MSG);
         String internalTableName = TABLE_PREFIX + className;
         checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
@@ -134,7 +195,7 @@ public void remove(String className) {
         if (table.hasPrimaryKey()) {
             table.setPrimaryKey(null);
         }
-        transaction.removeTable(internalTableName);
+        realm.sharedRealm.removeTable(internalTableName);
     }
 
     /**
@@ -145,12 +206,13 @@ public void remove(String className) {
      * @return a schema object for renamed class.
      */
     public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        realm.checkNotInSync(); // destructive modifications are not permitted
         checkEmpty(oldClassName, "Class names cannot be empty or null");
         checkEmpty(newClassName, "Class names cannot be empty or null");
         String oldInternalName = TABLE_PREFIX + oldClassName;
         String newInternalName = TABLE_PREFIX + newClassName;
         checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
-        if (transaction.hasTable(newInternalName)) {
+        if (realm.sharedRealm.hasTable(newInternalName)) {
             throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
         }
 
@@ -162,8 +224,8 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
             oldTable.setPrimaryKey(null);
         }
 
-        transaction.renameTable(oldInternalName, newInternalName);
-        Table table = transaction.getTable(newInternalName);
+        realm.sharedRealm.renameTable(oldInternalName, newInternalName);
+        Table table = realm.sharedRealm.getTable(newInternalName);
 
         // Set the primary key for the new class if necessary
         if (pkField != null) {
@@ -181,7 +243,11 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
     public boolean contains(String className) {
-        return transaction.hasTable(Table.TABLE_PREFIX + className);
+        if (realm == null) {
+            return dynamicClassToSchema.containsKey(className);
+        } else {
+            return realm.sharedRealm.hasTable(Table.TABLE_PREFIX + className);
+        }
     }
 
     private void checkEmpty(String str, String error) {
@@ -192,7 +258,7 @@ private void checkEmpty(String str, String error) {
 
     private void checkHasTable(String className, String errorMsg) {
         String internalTableName = TABLE_PREFIX + className;
-        if (!transaction.hasTable(internalTableName)) {
+        if (!realm.sharedRealm.hasTable(internalTableName)) {
             throw new IllegalArgumentException(errorMsg);
         }
     }
@@ -209,10 +275,10 @@ Table getTable(String className) {
         className = Table.TABLE_PREFIX + className;
         Table table = dynamicClassToTable.get(className);
         if (table == null) {
-            if (!transaction.hasTable(className)) {
+            if (!realm.sharedRealm.hasTable(className)) {
                 throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
             }
-            table = transaction.getTable(className);
+            table = realm.sharedRealm.getTable(className);
             dynamicClassToTable.put(className, table);
         }
         return table;
@@ -227,7 +293,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
                 table = classToTable.get(originalClass);
             }
             if (table == null) {
-                table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass));
+                table = realm.sharedRealm.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass));
                 classToTable.put(originalClass, table);
             }
             if (isProxyClass(originalClass, clazz)) {
@@ -268,10 +334,10 @@ RealmObjectSchema getSchemaForClass(String className) {
         className = Table.TABLE_PREFIX + className;
         RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
         if (dynamicSchema == null) {
-            if (!transaction.hasTable(className)) {
+            if (!realm.sharedRealm.hasTable(className)) {
                 throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
             }
-            Table table = transaction.getTable(className);
+            Table table = realm.sharedRealm.getTable(className);
             RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
             dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
             dynamicClassToSchema.put(className, dynamicSchema);
@@ -279,11 +345,11 @@ RealmObjectSchema getSchemaForClass(String className) {
         return dynamicSchema;
     }
 
-    void setColumnIndices(ColumnIndices columnIndices) {
-        this.columnIndices = columnIndices;
-    }
-
     static String getSchemaForTable(Table table) {
         return table.getName().substring(Table.TABLE_PREFIX.length());
     }
+
+    static native long nativeCreateFromList(long[] objectSchemaPtrs);
+    static native void nativeClose(long nativePtr);
+    static native long[] nativeGetAll(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
new file mode 100644
index 0000000000..07b63b39c8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.exceptions;
+
+import io.realm.internal.Keep;
+import io.realm.internal.SharedRealm;
+
+/**
+ * Class for reporting problems when accessing the Realm related files.
+ */
+@Keep
+public class RealmFileException extends RuntimeException {
+    /**
+     * The specific kind of this {@link RealmFileException}.
+     */
+    @Keep
+    public enum Kind {
+        /**
+         * Thrown for any I/O related exception scenarios when a Realm is opened.
+         */
+        ACCESS_ERROR,
+        /**
+         * Thrown if the user does not have permission to open or create the specified file in the specified access
+         * mode when the Realm is opened.
+         */
+        PERMISSION_DENIED,
+        /**
+         * Thrown if the destination file exists but it is not supposed to.
+         */
+        EXISTS,
+        /**
+         * Thrown if the relevant file cannot be found.
+         */
+        NOT_FOUND,
+        /**
+         * Thrown if the database file is currently open in another process which cannot share with the current process
+         * due to an architecture mismatch.
+         */
+        INCOMPATIBLE_LOCK_FILE,
+        /**
+         * Thrown if the file needs to be upgraded to a new format, but upgrades have been explicitly disabled.
+         */
+        FORMAT_UPGRADE_REQUIRED;
+
+        // Created from byte values by JNI.
+        static Kind getKind(byte value) {
+            switch (value) {
+                case SharedRealm.FILE_EXCEPTION_KIND_ACCESS_ERROR:
+                    return ACCESS_ERROR;
+                case SharedRealm.FILE_EXCEPTION_KIND_PERMISSION_DENIED:
+                    return PERMISSION_DENIED;
+                case SharedRealm.FILE_EXCEPTION_KIND_EXISTS:
+                    return EXISTS;
+                case SharedRealm.FILE_EXCEPTION_KIND_NOT_FOUND:
+                    return NOT_FOUND;
+                case SharedRealm.FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE:
+                    return INCOMPATIBLE_LOCK_FILE;
+                case SharedRealm.FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED:
+                    return FORMAT_UPGRADE_REQUIRED;
+                default:
+                    throw new RuntimeException("Unknown value for RealmFileException kind.");
+            }
+        }
+    }
+
+    private final Kind kind;
+
+    // Called by JNI
+    @SuppressWarnings("unused")
+    public RealmFileException(byte value, String message) {
+        super(message);
+        kind = Kind.getKind(value);
+    }
+
+    public RealmFileException(Kind kind, String message) {
+        super(message);
+        this.kind = kind;
+    }
+
+    public RealmFileException(Kind kind, Throwable cause) {
+        super(cause);
+        this.kind = kind;
+    }
+
+    public RealmFileException(Kind kind, String message, Throwable cause) {
+        super(message, cause);
+        this.kind = kind;
+    }
+
+    /**
+     * Gets the {@link #kind} of this exception.
+     *
+     * @return the {@link #kind} of this exception.
+     */
+    public Kind getKind() {
+        return kind;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s Kind: %s.", super.toString(), kind);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 42c89a20c1..75acb7df6b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -27,9 +27,9 @@
  */
 public class CheckedRow extends UncheckedRow {
 
-    // Used if created from other row. This keeps a strong reference to avoid GC'ing the original object, and it's
+    // Used if created from other row. This keeps a strong reference to avoid GC'ing the original object, and its
     // underlying native data.
-    @SuppressWarnings("unused")
+    @SuppressWarnings({"unused", "FieldCanBeLocal"})
     private UncheckedRow originalRow;
 
     private CheckedRow(Context context, Table parent, long nativePtr) {
@@ -37,7 +37,7 @@ private CheckedRow(Context context, Table parent, long nativePtr) {
     }
 
     private CheckedRow(UncheckedRow row) {
-        super(row.context, row.parent, row.nativePointer);
+        super(row);
         this.originalRow = row;
     }
 
@@ -51,9 +51,7 @@ private CheckedRow(UncheckedRow row) {
      */
     public static CheckedRow get(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
-        CheckedRow row = new CheckedRow(context, table, nativeRowPointer);
-        context.addReference(NativeObjectReference.TYPE_ROW, row);
-        return row;
+        return new CheckedRow(context, table, nativeRowPointer);
     }
 
     /**
@@ -65,11 +63,8 @@ public static CheckedRow get(Context context, Table table, long index) {
      * @return a checked instance of {@link Row} for the {@link LinkView} and index specified.
      */
     public static CheckedRow get(Context context, LinkView linkView, long index) {
-        long nativeRowPointer = linkView.nativeGetRow(linkView.nativePointer, index);
-        CheckedRow row = new CheckedRow(context, linkView.getTargetTable(),
-                nativeRowPointer);
-        context.addReference(NativeObjectReference.TYPE_ROW, row);
-        return row;
+        long nativeRowPointer = linkView.nativeGetRow(linkView.getNativePtr(), index);
+        return new CheckedRow(context, linkView.getTargetTable(), nativeRowPointer);
     }
 
     /**
@@ -77,7 +72,7 @@ public static CheckedRow get(Context context, LinkView linkView, long index) {
      *
      * @return an checked instance of {@link Row}.
      */
-    public static CheckedRow getFromRow(UncheckedRow row) {
+    static CheckedRow getFromRow(UncheckedRow row) {
         return new CheckedRow(row);
     }
 
@@ -124,7 +119,7 @@ public void setNull(long columnIndex) {
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 97e2934c3c..0e89e649ed 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -16,6 +16,7 @@
 
 package io.realm.internal;
 
+import java.util.HashMap;
 import java.util.Map;
 
 import io.realm.RealmModel;
@@ -23,14 +24,19 @@
 /**
  * Utility class used to cache the mapping between object field names and their column indices.
  */
-public class ColumnIndices {
+public final class ColumnIndices implements Cloneable {
+    private long schemaVersion;
+    private Map<Class<? extends RealmModel>, ColumnInfo> classes;
 
-    private final Map<Class<? extends RealmModel>, ColumnInfo> classes;
-
-    public ColumnIndices(Map<Class<? extends RealmModel>, ColumnInfo> classes) {
+    public ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes) {
+        this.schemaVersion = schemaVersion;
         this.classes = classes;
     }
 
+    public long getSchemaVersion() {
+        return schemaVersion;
+    }
+
     /**
      * Returns {@link ColumnInfo} for the given class or {@code null} if no mapping exists.
      */
@@ -50,4 +56,35 @@ public long getColumnIndex(Class<? extends RealmModel> clazz, String fieldName)
             return -1;
         }
     }
+
+    @Override
+    public ColumnIndices clone() {
+        try {
+            final ColumnIndices clone = (ColumnIndices) super.clone();
+            clone.classes = duplicateColumnInfoMap();
+            return clone;
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private Map<Class<? extends RealmModel>, ColumnInfo> duplicateColumnInfoMap() {
+        final Map<Class<? extends RealmModel>, ColumnInfo> copy = new HashMap<>();
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+            copy.put(entry.getKey(), entry.getValue().clone());
+        }
+        return copy;
+    }
+
+    public void copyFrom(ColumnIndices other, RealmProxyMediator mediator) {
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+            final ColumnInfo otherColumnInfo = other.getColumnInfo(entry.getKey());
+            if (otherColumnInfo == null) {
+                throw new IllegalStateException("Failed to copy ColumnIndices cache: "
+                        + Table.tableNameToClassName(mediator.getTableName(entry.getKey())));
+            }
+            entry.getValue().copyColumnInfoFrom(otherColumnInfo);
+        }
+        this.schemaVersion = other.schemaVersion;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index 1bd57372f8..3846930296 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -16,12 +16,11 @@
 
 package io.realm.internal;
 
-import java.util.Collections;
 import java.util.Map;
 
 import io.realm.exceptions.RealmMigrationNeededException;
 
-public class ColumnInfo {
+public abstract class ColumnInfo implements Cloneable {
     private Map<String, Long> indicesMap;
 
     protected final long getValidColumnIndex(String realmPath, Table table,
@@ -34,11 +33,40 @@ protected final long getValidColumnIndex(String realmPath, Table table,
         return columnIndex;
     }
 
-    protected final void setIndicesMap(Map<String, Long> indicesMap) {
-        this.indicesMap = Collections.unmodifiableMap(indicesMap);
-    }
-
+    /**
+     * Returns a map from column name to column index.
+     *
+     * @return a map from column name to column index. Do not modify returned map because it may be
+     * shared among other {@link ColumnInfo} instances.
+     */
     public Map<String, Long> getIndicesMap() {
         return indicesMap;
     }
+
+    protected final void setIndicesMap(Map<String, Long> indicesMap) {
+        this.indicesMap = indicesMap;
+    }
+
+    /**
+     * Copies the column index value from other {@link ColumnInfo} object.
+     *
+     * @param other The class of {@code other} must be exactly the same as this instance.
+     *              It must not be {@code null}.
+     * @throws IllegalArgumentException if {@code other} has different class than this.
+     */
+    public abstract void copyColumnInfoFrom(ColumnInfo other);
+
+    /**
+     * Returns a shallow copy of this instance.
+     *
+     * @return shallow copy.
+     */
+    @Override
+    public ColumnInfo clone() {
+        try {
+            return (ColumnInfo) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    };
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Context.java b/realm/realm-library/src/main/java/io/realm/internal/Context.java
index 8d241d0043..9dc084e83f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Context.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Context.java
@@ -17,135 +17,24 @@
 package io.realm.internal;
 
 import java.lang.ref.ReferenceQueue;
-import java.util.ArrayList;
-import java.util.List;
 
+// Currently we free native objects in two threads, the SharedGroup is freed in the caller thread, others are freed in
+// RealmFinalizingDaemon thread. And the destruction in both threads are locked by the corresponding context.
+// The purpose of locking on Context is:
+// Destruction of SharedGroup (and hence Group and Table) is currently not thread-safe with respect to destruction of
+// other accessors, you have to ensure mutual exclusion. This is also illustrated by the use of locks in the test
+// test_destructor_thread_safety.cpp. Explicit call of SharedGroup::close() or Table::detach() is also not thread-safe
+// with respect to destruction of other accessors.
 public class Context {
+    private final static ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
+    private final static Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
 
-    // Pool to hold the phantom references.
-    // The size of array for storing phantom references will never decrease. Instead, we use another array to hold the
-    // index of the free slot. When adding the reference, pick the last index from freeIndexList and put the reference
-    // to the corresponding slot. When removing the reference, simply add the index to the end of freeIndexList without
-    // setting the corresponding slot to null for efficiency reasons. The reference will be freed finally when the slot
-    // gets overwritten or the whole context gets freed.
-    private static class ReferencesPool {
-        ArrayList<NativeObjectReference> pool = new ArrayList<NativeObjectReference>();
-        ArrayList<Integer> freeIndexList = new ArrayList<Integer>();
-
-        void add(NativeObjectReference ref) {
-            if (pool.size() <= ref.refIndex) {
-                pool.add(ref);
-            } else {
-                pool.set(ref.refIndex, ref);
-            }
-        }
-
-        Integer getFreeIndex() {
-            Integer index;
-            int freeIndexListSize = freeIndexList.size();
-            if (freeIndexListSize == 0) {
-                index = pool.size();
-            } else {
-                index = freeIndexList.remove(freeIndexListSize - 1);
-            }
-            return index;
-        }
-    }
-
-    // Each group of related Realm objects will have a Context object in the root.
-    // The root can be a table, a group, or a shared group.
-    // The Context object is used to store a list of native pointers 
-    // whose disposal need to be handed over from the garbage 
-    // collection thread to the users thread.
-
-    private List<Long> abandonedTables = new ArrayList<Long>();
-    private List<Long> abandonedTableViews = new ArrayList<Long>();
-    private List<Long> abandonedQueries = new ArrayList<Long>();
-
-    private ReferencesPool referencesPool = new ReferencesPool();
-    private ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
-
-    private boolean isFinalized = false;
-
-    public synchronized void addReference(int type, NativeObject referent) {
-        referencesPool.add(new NativeObjectReference(type, referent, referenceQueue, referencesPool.getFreeIndex()));
-    }
-
-    public synchronized void executeDelayedDisposal() {
-        for (int i = 0; i < abandonedTables.size(); i++) {
-            long nativePointer = abandonedTables.get(i);
-            Table.nativeClose(nativePointer);
-        }
-        abandonedTables.clear();
-
-        for (int i = 0; i < abandonedTableViews.size(); i++) {
-            long nativePointer = abandonedTableViews.get(i);
-            TableView.nativeClose(nativePointer);
-        }
-        abandonedTableViews.clear();
-
-        for (int i = 0; i < abandonedQueries.size(); i++) {
-            long nativePointer = abandonedQueries.get(i);
-            TableQuery.nativeClose(nativePointer);
-        }
-        abandonedQueries.clear();
-
-        cleanNativeReferences();
-    }
-
-    private void cleanNativeReferences() {
-        NativeObjectReference reference = (NativeObjectReference) referenceQueue.poll();
-        while (reference != null) {
-            // Dealloc the native resources
-            reference.cleanup();
-            // Inline referencesPool.remove() to make it faster.
-            // referencesPool.pool.set(index, null); is not really needed. Make it faster by not
-            // setting the slot to null.
-            referencesPool.freeIndexList.add(reference.refIndex);
-            reference = (NativeObjectReference) referenceQueue.poll();
-        }
-    }
-
-    public void asyncDisposeTable(long nativePointer, boolean isRoot) {
-        if (isRoot || isFinalized) {
-            Table.nativeClose(nativePointer);
-        }
-        else {
-            abandonedTables.add(nativePointer);
-        }
-    }
-
-    public void asyncDisposeTableView(long nativePointer) {
-        if (isFinalized) {
-            TableView.nativeClose(nativePointer);
-        }
-        else {
-            abandonedTableViews.add(nativePointer);
-        }
-    }
-
-    public void asyncDisposeQuery(long nativePointer) {
-        if (isFinalized) {
-            TableQuery.nativeClose(nativePointer);
-        }
-        else {
-            abandonedQueries.add(nativePointer);
-        }
-    }
-
-    public void asyncDisposeGroup(long nativePointer) {
-        Group.nativeClose(nativePointer);
-    }
-
-    public void asyncDisposeSharedGroup(long nativePointer) {
-        SharedGroup.nativeClose(nativePointer);
+    static {
+        finalizingThread.setName("RealmFinalizingDaemon");
+        finalizingThread.start();
     }
 
-    protected void finalize() throws Throwable {
-        synchronized (this) {
-            isFinalized = true;
-        }
-        executeDelayedDisposal();
-        super.finalize();
+    void addReference(NativeObject referent) {
+        new NativeObjectReference(this, referent, referenceQueue);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java b/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java
new file mode 100644
index 0000000000..2e8db788c3
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/FinalizerRunnable.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+
+import java.lang.ref.ReferenceQueue;
+
+import io.realm.log.RealmLog;
+
+// Running in the FinalizingDaemon thread to free native objects.
+class FinalizerRunnable implements Runnable {
+    private final ReferenceQueue<NativeObject>  referenceQueue;
+
+    FinalizerRunnable(ReferenceQueue<NativeObject> referenceQueue) {
+        this.referenceQueue = referenceQueue;
+    }
+
+    @Override
+    public void run() {
+        while (true) {
+            try {
+                NativeObjectReference reference = (NativeObjectReference) referenceQueue.remove();
+                reference.cleanup();
+            } catch (InterruptedException e) {
+                // Restore the interrupted status
+                Thread.currentThread().interrupt();
+
+                RealmLog.fatal("The FinalizerRunnable thread has been interrupted." +
+                        " Native resources cannot be freed anymore");
+                break;
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Group.java b/realm/realm-library/src/main/java/io/realm/internal/Group.java
deleted file mode 100644
index d02022fdec..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/Group.java
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/**
- * This class is used to serialize tables to either disk or memory. It consists of a collection of tables.
- */
-public class Group implements Closeable {
-
-    // Below values must match the values in realm::group::OpenMode in C++
-    public static final int MODE_READONLY = 0; // Open in read-only mode. Fail if the file does not already exist.
-    public static final int MODE_READWRITE = 1; // Open in read/write mode. Create the file if it doesn't exist.
-    public static final int MODE_READWRITE_NOCREATE = 2; // Open in read/write mode. Fail if the file does not already exist.
-
-    protected long nativePtr;
-    protected boolean immutable;
-    private final Context context;
-
-    private void checkNativePtrNotZero() {
-        if (this.nativePtr == 0)
-            // FIXME: It is wrong to assume that a null pointer means 'out
-            // of memory'. An out of memory condition in
-            // createNative() must be handled by having createNative()
-            // throw OutOfMemoryError.
-            throw new OutOfMemoryError("Out of native memory.");
-    }
-
-    public Group() {
-        this.immutable = false;
-        this.context = new Context();
-        this.nativePtr = createNative();
-        checkNativePtrNotZero();
-    }
-
-    public Group(String filepath, int mode) {
-        this.immutable = (mode == MODE_READONLY);
-        this.context = new Context();
-        this.nativePtr = createNative(filepath, mode);
-        checkNativePtrNotZero();
-    }
-
-    public Group(String filepath) {
-        this(filepath, MODE_READONLY);
-    }
-
-    public Group(File file) {
-        this(file.getAbsolutePath(), file.canWrite() ? MODE_READWRITE : MODE_READONLY);
-    }
-
-    public Group(byte[] data) {
-        this.immutable = false;
-        this.context = new Context();
-        if (data != null) {
-            this.nativePtr = createNative(data);
-            checkNativePtrNotZero();
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    public Group(ByteBuffer buffer) {
-        this.immutable = false;
-        this.context = new Context();
-        if (buffer != null) {
-            this.nativePtr = createNative(buffer);
-            checkNativePtrNotZero();
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    Group(Context context, long nativePointer, boolean immutable) {
-        this.context = context;
-        this.nativePtr = nativePointer;
-        this.immutable = immutable;
-    }
-
-    // If close() is called, no penalty is paid for delayed disposal
-    // via the context
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-                nativePtr = 0;
-            }
-        }
-    }
-
-    /**
-     * Checks if a group has been closed and can no longer be used.
-     *
-     * @return {@code true} if closed, {@code false} otherwise.
-     */
-    boolean isClosed() {
-        return nativePtr == 0;
-    }
-
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeGroup(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
-    }
-
-    private void verifyGroupIsValid() {
-        if (nativePtr == 0) {
-            throw new IllegalStateException("Illegal to call methods on a closed Group.");
-        }
-    }
-
-    public long size() {
-        verifyGroupIsValid();
-        return nativeSize(nativePtr);
-    }
-
-    public boolean isEmpty(){
-        return size() == 0;
-    }
-
-    /**
-     * Checks whether {@link Table} exists in the Group.
-     *
-     * @param name the name of the {@link Table}.
-     * @return {@code true} if the table exists, otherwise {@code false}.
-     */
-    public boolean hasTable(String name) {
-        verifyGroupIsValid();
-        return name != null && nativeHasTable(nativePtr, name);
-    }
-
-    public String getTableName(int index) {
-        verifyGroupIsValid();
-        long cnt = size();
-        if (index < 0 || index >= cnt) {
-            throw new IndexOutOfBoundsException(
-                    "Table index argument is out of range. possible range is [0, "
-                    + (cnt - 1) + "]");
-        }
-        return nativeGetTableName(nativePtr, index);
-    }
-
-    /**
-     * Removes a table from the group and delete all data.
-     */
-    public void removeTable(String name) {
-        nativeRemoveTable(nativePtr, name);
-    }
-
-    native void nativeRemoveTable(long nativeGroupPtr, String tableName);
-
-    /**
-     * Renames a table
-     */
-    public void renameTable(String oldName, String newName) {
-        nativeRenameTable(nativePtr, oldName, newName);
-    }
-
-    native void nativeRenameTable(long nativeGroupPtr, String oldName, String newName);
-
-    /**
-     * Returns a table with the specified name.
-     *
-     * @param name the name of the {@link Table}.
-     * @return the {@link Table} if it exists, otherwise create it.
-     */
-    public Table getTable(String name) {
-        verifyGroupIsValid();
-        if (name == null || name.isEmpty()) {
-            throw new IllegalArgumentException("Invalid name. Name must be a non-empty String.");
-        }
-        if (immutable && !hasTable(name)) {
-            throw new IllegalStateException("Requested table is not in this Realm. " +
-                    "Creating it requires a transaction: " + name);
-        }
-
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeTablePointer = nativeGetTableNativePtr(nativePtr, name);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this, nativeTablePointer);
-        } catch (RuntimeException e) {
-            Table.nativeClose(nativeTablePointer);
-            throw e;
-        }
-    }
-
-    /**
-     * Serializes the group to the specific file on the disk using encryption.
-     *
-     * @param file a File object representing the file.
-     * @param key A 64 bytes long byte array containing the key to the encrypted Realm file. Can be null if encryption
-     *            is not required.
-     * @throws IOException.
-     */
-    public void writeToFile(File file, byte[] key) throws IOException {
-        verifyGroupIsValid();
-        if (file.isFile() && file.exists()) {
-            throw new IllegalArgumentException("The destination file must not exist");
-        }
-        if (key != null && key.length != 64) {
-            throw new IllegalArgumentException("Realm AES keys must be 64 bytes long");
-        }
-
-        nativeWriteToFile(nativePtr, file.getAbsolutePath(), key);
-    }
-
-    /**
-     * Serializes the group to a memory buffer. The byte[] is owned by the JVM.
-     *
-     * @return the binary array of the serialized group.
-     */
-    public byte[] writeToMem() {
-        verifyGroupIsValid();
-        return nativeWriteToMem(nativePtr);
-    }
-
-    /*
-     * Checks if the Group contains any objects. It only checks for "class_" tables or non-metadata tables, e.g. this
-     * return true if the "pk" table contained information.
-     *
-     * @return {@code true} if empty, @{code false} otherwise.
-     */
-    public boolean isObjectTablesEmpty() {
-        return nativeIsEmpty(nativePtr);
-    }
-
-/*
- * TODO: Find a way to release the malloc'ed native memory automatically
-
-    public ByteBuffer writeToByteBuffer() {
-        verifyGroupIsValid();
-        return nativeWriteToByteBuffer(nativePtr);
-    }
-
-    protected native ByteBuffer nativeWriteToByteBuffer(long nativeGroupPtr);
-*/
-
-    public void commit() {
-        verifyGroupIsValid();
-        nativeCommit(nativePtr);
-    }
-
-    public String toJson() {
-        return nativeToJson(nativePtr);
-    }
-
-    public String toString() {
-        return nativeToString(nativePtr);
-    }
-
-
-    protected native long createNative();
-    protected native long createNative(String filepath, int value);
-    protected native long createNative(byte[] data);
-    protected native long createNative(ByteBuffer buffer);
-    protected static native void nativeClose(long nativeGroupPtr);
-    protected native long nativeSize(long nativeGroupPtr);
-    protected native String nativeGetTableName(long nativeGroupPtr, int index);
-    protected native boolean nativeHasTable(long nativeGroupPtr, String name);
-    protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray) throws IOException;
-    protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
-    protected native byte[] nativeWriteToMem(long nativeGroupPtr);
-    protected native String nativeToJson(long nativeGroupPtr);
-    protected native void nativeCommit(long nativeGroupPtr);
-    protected native String nativeToString(long nativeGroupPtr);
-    protected native boolean nativeIsEmpty(long nativeGroupPtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
deleted file mode 100644
index cd6a3c62eb..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import io.realm.internal.async.BadVersionException;
-
-public class ImplicitTransaction extends Group {
-
-    private final SharedGroup parent;
-
-    public ImplicitTransaction(Context context, SharedGroup sharedGroup, long nativePtr) {
-        super(context, nativePtr, true);
-        parent = sharedGroup;
-    }
-
-    /**
-     * Positions the shared group to the latest version.
-     */
-    public void advanceRead() {
-        assertNotClosed();
-        parent.advanceRead();
-    }
-
-    /**
-     * Positions the shared group at the specified version.
-     *
-     * @param versionID version of the shared group.
-     */
-    public void advanceRead(SharedGroup.VersionID versionID) throws BadVersionException {
-        assertNotClosed();
-        parent.advanceRead(versionID);
-    }
-
-    public void promoteToWrite() {
-        assertNotClosed();
-        if (!immutable) {
-            throw new IllegalStateException("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().");
-        }
-        immutable = false;
-        parent.promoteToWrite();
-    }
-
-    public void commitAndContinueAsRead() {
-        assertNotClosed();
-        if (immutable) {
-            throw new IllegalStateException("Not inside a transaction.");
-        }
-        parent.commitAndContinueAsRead();
-        immutable = true;
-    }
-
-    public void endRead() {
-        assertNotClosed();
-        parent.endRead();
-    }
-
-    public void rollbackAndContinueAsRead() {
-        assertNotClosed();
-        if (immutable) {
-            throw new IllegalStateException("Not inside a transaction.");
-        }
-        parent.rollbackAndContinueAsRead();
-        immutable = true;
-    }
-
-    private void assertNotClosed() {
-        if (isClosed() || parent.isClosed()) {
-            throw new IllegalStateException("Cannot use ImplicitTransaction after it or its parent has been closed.");
-        }
-    }
-
-    /**
-     * Returns the absolute path to the Realm file backing this transaction.
-     */
-    public String getPath() {
-        return parent.getPath();
-    }
-
-    protected void finalize() {} // Nullify the actions of Group.finalize()
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Keep.java b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
index 45f86dc70a..598ebccc48 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Keep.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
@@ -24,7 +24,7 @@
 /**
  * This annotation is used to mark the classes to be kept by ProGuard/DexGuard.
  * The ProGuard configuration must have '-keep class io.realm.internal.Keep'
- * and '-keep @io.realm.internal.Keep class *'.
+ * and '-keep,includedescriptorclasses @io.realm.internal.Keep class * { *; }'.
  */
 @Retention(RetentionPolicy.CLASS)
 @Target(ElementType.TYPE)
diff --git a/realm/realm-library/src/main/java/io/realm/internal/KeepMember.java b/realm/realm-library/src/main/java/io/realm/internal/KeepMember.java
new file mode 100644
index 0000000000..e1308a9f21
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/KeepMember.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to mark the fields and methods to be kept by ProGuard/DexGuard.
+ * The ProGuard configuration must have '-keep class io.realm.internal.KeepMember'
+ * and '-keep,includedescriptorclasses @io.realm.internal.KeepMember class * { @io.realm.internal.KeepMember *; }'.
+ * This annotation must be added to class as well to work.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
+public @interface KeepMember {
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index 2a92a7ba92..f6718b4083 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -21,20 +21,32 @@
 /**
  * The LinkView class represents a core {@link RealmFieldType#LIST}.
  */
-public class LinkView extends NativeObject {
+public class LinkView implements NativeObject {
 
     private final Context context;
     final Table parent;
     final long columnIndexInParent;
+    private final long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
     public LinkView(Context context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
         this.context = context;
         this.parent = parent;
         this.columnIndexInParent = columnIndexInParent;
-        this.nativePointer = nativeLinkViewPtr;
+        this.nativePtr = nativeLinkViewPtr;
 
-        context.executeDelayedDisposal();
-        context.addReference(NativeObjectReference.TYPE_LINK_VIEW, this);
+        context.addReference(this);
+    }
+
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
     }
 
     /**
@@ -62,67 +74,63 @@ public CheckedRow getCheckedRow(long index) {
         return CheckedRow.get(context, this, index);
     }
 
-    public long getTargetRowIndex(long pos) {
-        return nativeGetTargetRowIndex(nativePointer, pos);
+    /**
+     * Returns the row index in the underlying table.
+     */
+    public long getTargetRowIndex(long linkViewIndex) {
+        return nativeGetTargetRowIndex(nativePtr, linkViewIndex);
     }
 
     public void add(long rowIndex) {
         checkImmutable();
-        nativeAdd(nativePointer, rowIndex);
+        nativeAdd(nativePtr, rowIndex);
     }
 
     public void insert(long pos, long rowIndex) {
         checkImmutable();
-        nativeInsert(nativePointer, pos, rowIndex);
+        nativeInsert(nativePtr, pos, rowIndex);
     }
 
     public void set(long pos, long rowIndex) {
         checkImmutable();
-        nativeSet(nativePointer, pos, rowIndex);
+        nativeSet(nativePtr, pos, rowIndex);
     }
 
     public void move(long oldPos, long newPos) {
         checkImmutable();
-        nativeMove(nativePointer, oldPos, newPos);
+        nativeMove(nativePtr, oldPos, newPos);
     }
 
     public void remove(long pos) {
         checkImmutable();
-        nativeRemove(nativePointer, pos);
+        nativeRemove(nativePtr, pos);
     }
 
     public void clear() {
         checkImmutable();
-        nativeClear(nativePointer);
+        nativeClear(nativePtr);
     }
 
     public boolean contains(long tableRowIndex) {
-        long index = nativeFind(nativePointer, tableRowIndex);
+        long index = nativeFind(nativePtr, tableRowIndex);
         return (index != TableOrView.NO_MATCH);
     }
 
     public long size() {
-        return nativeSize(nativePointer);
+        return nativeSize(nativePtr);
     }
 
     public boolean isEmpty() {
-        return nativeIsEmpty(nativePointer);
+        return nativeIsEmpty(nativePtr);
     }
 
     public TableQuery where() {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        this.context.executeDelayedDisposal();
-        long nativeQueryPtr = nativeWhere(nativePointer);
-        try {
-            return new TableQuery(this.context, this.parent, nativeQueryPtr);
-        } catch (RuntimeException e) {
-            TableQuery.nativeClose(nativeQueryPtr);
-            throw e;
-        }
+        long nativeQueryPtr = nativeWhere(nativePtr);
+        return new TableQuery(this.context, this.parent, nativeQueryPtr);
     }
 
     public boolean isAttached() {
-        return nativeIsAttached(nativePointer);
+        return nativeIsAttached(nativePtr);
     }
 
     /**
@@ -137,7 +145,7 @@ public Table getTable() {
      */
     public void removeAllTargetRows() {
         checkImmutable();
-        nativeRemoveAllTargetRows(nativePointer);
+        nativeRemoveAllTargetRows(nativePtr);
     }
 
     /**
@@ -145,20 +153,13 @@ public void removeAllTargetRows() {
      */
     public void removeTargetRow(int index) {
         checkImmutable();
-        nativeRemoveTargetRow(nativePointer, index);
+        nativeRemoveTargetRow(nativePtr, index);
     }
 
     public Table getTargetTable() {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeTablePointer = nativeGetTargetTable(nativePointer);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this.parent, nativeTablePointer);
-        } catch (RuntimeException e) {
-            Table.nativeClose(nativeTablePointer);
-            throw e;
-        }
+        long nativeTablePointer = nativeGetTargetTable(nativePtr);
+        Table table = new Table(this.parent, nativeTablePointer);
+        return table;
     }
 
     private void checkImmutable() {
@@ -167,9 +168,8 @@ private void checkImmutable() {
         }
     }
 
-    public static native void nativeClose(long nativeLinkViewPtr);
     native long nativeGetRow(long nativeLinkViewPtr, long pos);
-    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
+    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long linkViewIndex);
     public static native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
     private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
     private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
@@ -184,4 +184,5 @@ private void checkImmutable() {
     private native void nativeRemoveTargetRow(long nativeLinkViewPtr, long rowIndex);
     private native void nativeRemoveAllTargetRows(long nativeLinkViewPtr);
     private native long nativeGetTargetTable(long nativeLinkViewPtr);
+    private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
index cad7f390cc..ce326dbf9b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
@@ -19,8 +19,21 @@
 /**
  * This abstract class represents a native object from core.
  * It specifies the operations common to all such objects.
- * All Java classes wrapping a core class should extend NativeObject.
+ * All Java classes wrapping a core class should implement NativeObject.
  */
-public abstract class NativeObject {
-    long nativePointer;
+interface NativeObject {
+    /**
+     * Gets the pointer of a native object.
+     *
+     * @return the native pointer.
+     */
+    long getNativePtr();
+
+    /**
+     * Gets the function pointer which points to the function to free the native object.
+     * The function should be defined like: {@code typedef void (*FinalizeFunc)(jlong ptr)}.
+     *
+     * @return the function pointer for freeing the native resource.
+     */
+    long getNativeFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
index 2427e0a020..e07a4275e3 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
@@ -22,44 +22,75 @@
 /**
  * This class is used for holding the reference to the native pointers present in NativeObjects.
  * This is required as phantom references cannot access the original objects for this value.
+ * The phantom references will be stored in a double linked list to avoid the reference itself gets GCed. When the
+ * referent get GCed, the reference will be added to the ReferenceQueue. Loop in the daemon thread will retrieve the
+ * phantom reference from the ReferenceQueue then dealloc the referent and remove the reference from the double linked
+ * list. See {@link FinalizerRunnable} for more implementation details.
  */
-public final class NativeObjectReference extends PhantomReference<NativeObject> {
+final class NativeObjectReference extends PhantomReference<NativeObject> {
 
-    // Using int here instead of enum to make it faster since the cleanup needs to be called
-    // in a loop to dealloc every native reference.
-    public static final int TYPE_LINK_VIEW = 0;
-    public static final int TYPE_ROW = 1;
+    // Linked list to keep the reference of the PhantomReference
+    private static class ReferencePool {
+        NativeObjectReference head;
+
+        synchronized void add(NativeObjectReference ref) {
+            ref.prev = null;
+            ref.next = head;
+            if (head != null) {
+                head.prev = ref;
+            }
+            head = ref;
+        }
+
+        synchronized void remove(NativeObjectReference ref) {
+            NativeObjectReference next = ref.next;
+            NativeObjectReference prev = ref.prev;
+            ref.next = null;
+            ref.prev = null;
+            if (prev != null) {
+                prev.next = next;
+            } else {
+                head = next;
+            }
+            if (next != null) {
+                next.prev = prev;
+            }
+        }
+    }
 
     // The pointer to the native object to be handled
-    final long nativePointer;
-    final int type;
-    // Use boxed type to avoid box/un-box when access the freeIndexList
-    final Integer refIndex;
+    private final long nativePtr;
+    // The pointer to the native finalize function
+    private final long nativeFinalizerPtr;
+    private final Context context;
+    private NativeObjectReference prev;
+    private NativeObjectReference next;
 
-    NativeObjectReference(int type,
+    private static ReferencePool referencePool = new ReferencePool();
+
+    NativeObjectReference(Context context,
                           NativeObject referent,
-                          ReferenceQueue<? super NativeObject> referenceQueue,
-                          Integer index) {
+                          ReferenceQueue<? super NativeObject> referenceQueue) {
         super(referent, referenceQueue);
-        this.type = type;
-        this.nativePointer = referent.nativePointer;
-        refIndex = index;
+        this.nativePtr = referent.getNativePtr();
+        this.nativeFinalizerPtr = referent.getNativeFinalizerPtr();
+        this.context = context;
+        referencePool.add(this);
     }
 
     /**
      * To dealloc native resources.
      */
     void cleanup() {
-        switch (type) {
-            case TYPE_LINK_VIEW:
-                LinkView.nativeClose(nativePointer);
-                break;
-            case TYPE_ROW:
-                UncheckedRow.nativeClose(nativePointer);
-                break;
-            default:
-                // Cannot get here.
-                throw new IllegalStateException("Unknown native reference type " + type + ".");
+        synchronized (context) {
+            nativeCleanUp(nativeFinalizerPtr, nativePtr);
         }
+        // Remove the PhantomReference from the pool to free it.
+        referencePool.remove(this);
     }
+
+    /**
+     *  Calls the native finalizer function to free the given native pointer.
+     */
+    private static native void nativeCleanUp(long nativeFinalizer, long nativePointer);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
new file mode 100644
index 0000000000..8bb11bf554
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.content.Context;
+
+import io.realm.RealmConfiguration;
+import io.realm.exceptions.RealmException;
+
+/**
+ * Class acting as an mediator between the basic Realm APIs and the Object Server APIs.
+ * This breaks the cyclic dependency between ObjectServer and Realm code.
+ */
+public class ObjectServerFacade {
+
+    private final static ObjectServerFacade nonSyncFacade = new ObjectServerFacade();
+    private static ObjectServerFacade syncFacade = null;
+
+    static {
+        //noinspection TryWithIdenticalCatches
+        try {
+            Class syncFacadeClass = Class.forName("io.realm.internal.objectserver.SyncObjectServerFacade");
+            syncFacade = (ObjectServerFacade) syncFacadeClass.newInstance();
+        } catch (ClassNotFoundException ignored) {
+        } catch (InstantiationException e) {
+            throw new RealmException("Failed to init SyncObjectServerFacade", e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Failed to init SyncObjectServerFacade", e);
+        }
+    }
+
+    /**
+     * Initialize the Object Server library
+     * @param context
+     */
+    public void init(Context context) {
+    }
+
+    /**
+     * Notify the session for this configuration that a local commit was made.
+     */
+    public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
+    }
+
+    /**
+     * The first instance of this Realm was opened.
+     */
+    public void realmClosed(RealmConfiguration configuration) {
+    }
+
+    /**
+     * The last instance of this Realm was closed.
+     */
+    public void realmOpened(RealmConfiguration configuration) {
+    }
+
+    public String[] getUserAndServerUrl(RealmConfiguration config) {
+        return new String[2];
+    }
+
+    public static ObjectServerFacade getFacade(boolean needSyncFacade) {
+        if (needSyncFacade) {
+            return syncFacade;
+        }
+        return nonSyncFacade;
+    }
+
+    // Returns a SyncObjectServerFacade instance if the class exists. Otherwise returns a non-sync one.
+    public static ObjectServerFacade getSyncFacadeIfPossible() {
+        if (syncFacade != null) {
+            return syncFacade;
+        }
+        return nonSyncFacade;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
index b89e49e9d3..496aa18734 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
@@ -21,9 +21,13 @@
 import com.getkeepsafe.relinker.ReLinker;
 
 import java.io.File;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.util.Locale;
 
+import io.realm.BuildConfig;
+
 /**
  * Utility methods for Realm Core.
  */
@@ -41,36 +45,6 @@ public static boolean osIsWindows() {
         return (os.contains("win"));
     }
 
-    /**
-     * Loads the .so file. This method is useful for static blocks as it does not rely on access to a Context.
-     *
-     * Although loadLibrary is synchronized internally from AOSP 4.3, for compatibility reasons,
-     * KEEP synchronized here for old devices!
-     */
-    public static synchronized void loadLibrary() {
-        if (libraryIsLoaded) {
-            // The java native should ensure only load the lib once, but we met some problems before.
-            // So keep the flag.
-            return;
-        }
-
-        if (osIsWindows()) {
-            loadLibraryWindows();
-        }
-        else {
-            String jnilib;
-            String debug = System.getenv("REALM_JAVA_DEBUG");
-            if (debug == null || debug.isEmpty()) {
-                jnilib = "realm-jni";
-            }
-            else {
-                jnilib = "realm-jni-dbg";
-            }
-            System.loadLibrary(jnilib);
-        }
-        libraryIsLoaded = true;
-    }
-
     /**
      * Loads the .so file. Typically, the .so file is installed and can be found by System.loadLibrary() but
      * can be damaged or missing. This happens for the Android installer, especially when apps are installed
@@ -84,7 +58,7 @@ public static synchronized void loadLibrary(Context context) {
         if (libraryIsLoaded) {
             return;
         }
-        ReLinker.loadLibrary(context, "realm-jni");
+        ReLinker.loadLibrary(context, "realm-jni", BuildConfig.VERSION_NAME);
         libraryIsLoaded = true;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
new file mode 100644
index 0000000000..aaf97b6b5d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.internal.async.QueryUpdateTask;
+
+/**
+ * This interface needs to be implemented by Java and pass to Realm Object Store in order to get notifications when
+ * other thread/process changes the Realm file.
+ */
+@Keep
+public interface RealmNotifier {
+    /**
+     * This is called from Java when the changes have been made on the same thread.
+     */
+    void notifyCommitByLocalThread();
+
+    /**
+     * This is called in Realm Object Store's JavaBindingContext::changes_available.
+     * This is getting called on the same thread which created this Realm when the same Realm file has been changed by
+     * other thread. The changes on the same thread should not trigger this call.
+     */
+    @SuppressWarnings("unused") // called from java_binding_context.cpp
+    void notifyCommitByOtherThread();
+
+    /**
+     * Post a runnable to be run in the next event loop on the thread which creates the corresponding Realm.
+     *
+     * @param runnable to be posted.
+     */
+    void post(Runnable runnable);
+
+    /**
+     * Is the current notifier valid? eg. Notifier created on non-looper thread cannot be notified.
+     *
+     * @return {@code true} if the thread which owns this notifier can be notified. Otherwise {@code false}
+     */
+    boolean isValid();
+
+    /**
+     * Called when close SharedRealm to clean up any event left in to queue.
+     */
+    void close();
+
+    // FIXME: These are for decoupling handler from async query. Async query needs refactor to either adapt the OS or
+    //        abstract the logic from Android handlers.
+    void completeAsyncResults(QueryUpdateTask.Result result);
+    void completeAsyncObject(QueryUpdateTask.Result result);
+    void throwBackgroundException(Throwable throwable);
+    void completeUpdateAsyncQueries(QueryUpdateTask.Result result);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 0b1256a1ed..bd72e4f7b8 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -29,6 +29,8 @@
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmException;
 
 /**
@@ -42,22 +44,35 @@
  */
 public abstract class RealmProxyMediator {
 
+    /**
+     * Create a object schema for the given RealmObject class.
+     *
+     * @param clazz the {@link RealmObject} model class to create object schema for.
+     * @param realmSchema the {@link RealmSchema} to associate the object schema with.
+     * @return The object schema.
+     */
+    public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
+
     /**
      * Creates the backing table in Realm for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} model class to create backing table for.
-     * @param transaction the read transaction for the Realm to create table in.
+     * @param sharedRealm the wrapper object of underlying native database.
      */
-    public abstract Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction);
+    public abstract Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm);
 
     /**
      * Validates the backing table in Realm for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} model class to validate.
-     * @param transaction the read transaction for the Realm to validate against.
+     * @param sharedRealm the wrapper object of underlying native database to validate against.
+     * @param allowExtraColumns if {@code} false, {@link io.realm.exceptions.RealmMigrationNeededException}
+     *                          is thrown when the column count it more than expected.
      * @return the field indices map.
      */
-    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction);
+    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
+                                             SharedRealm sharedRealm,
+                                             boolean allowExtraColumns);
 
     /**
      * Returns a map of non-obfuscated object field names to their internal Realm name.
@@ -81,10 +96,19 @@
      * Creates a new instance of an {@link RealmObjectProxy} for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} to create {@link RealmObjectProxy} for.
-     * @param columnInfo the {@link ColumnInfo} object for the RealmObject class of {@code E}.
+     * @param acceptDefaultValue {@code true} to accept the values set in the constructor, {@code false} otherwise.
+     * @param excludeFields the column names whose default value will be ignored if the {@code acceptDefaultValue}
+     *                       is {@code true}. Only {@link io.realm.RealmModel} and {@link io.realm.RealmList}
+     *                       column will respect this.
+     *                       No effects if the {@code acceptDefaultValue} is {@code false}.
      * @return created {@link RealmObjectProxy} object.
      */
-    public abstract <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo);
+    public abstract <E extends RealmModel> E newInstance(Class<E> clazz,
+                                                         Object baseRealm,
+                                                         Row row,
+                                                         ColumnInfo columnInfo,
+                                                         boolean acceptDefaultValue,
+                                                         List<String> excludeFields);
 
     /**
      * Returns the list of RealmObject classes that can be saved in this Realm.
@@ -153,7 +177,7 @@
      * @param clazz the type of {@link RealmObject}
      * @param realm the reference to {@link Realm} where to create the object.
      * @param json the JSON data
-     * @param update {@code true} if Realm should try to update a existing object. This requires that the RealmObject 
+     * @param update {@code true} if Realm should try to update a existing object. This requires that the RealmObject
      *               class has a @PrimaryKey.
      * @return RealmObject that has been created or updated.
      * @throws JSONException if the JSON mapping doesn't match the expected class.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
deleted file mode 100644
index da20dd4114..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.io.Closeable;
-import java.io.IOError;
-import java.util.concurrent.TimeUnit;
-
-import io.realm.exceptions.IncompatibleLockFileException;
-import io.realm.exceptions.RealmError;
-import io.realm.exceptions.RealmIOException;
-import io.realm.internal.async.BadVersionException;
-import io.realm.internal.log.RealmLog;
-
-public class SharedGroup implements Closeable {
-
-    // Keep these public so we can ask users to experiment with these values if needed.
-    // Should be locked down as soon as possible.
-    public static long[] INCREMENTAL_BACKOFF_MS = new long[] {1, 10, 20, 50, 100, 200, 400}; // Will keep re-using last value until LIMIT is hit
-    public static long INCREMENTAL_BACKOFF_LIMIT_MS = 3000;
-
-    public static final boolean IMPLICIT_TRANSACTION = true;
-    public static final boolean EXPLICIT_TRANSACTION = false;
-
-    private static final boolean CREATE_FILE_YES = false;
-    private static final boolean CREATE_FILE_NO = true;
-    private static final boolean ENABLE_REPLICATION = true;
-    private static final boolean DISABLE_REPLICATION = false;
-
-    private final String path;
-    private long nativePtr;
-    private long nativeReplicationPtr;
-    private boolean implicitTransactionsEnabled = false;
-    private boolean activeTransaction;
-    private final Context context;
-
-    public enum Durability {
-        FULL(0),
-        MEM_ONLY(1);
-        //ASYNC(2); // TODO: re-enable when possible
-
-        final int value;
-
-        Durability(int value) {
-            this.value = value;
-        }
-    }
-
-    // TODO Only used by Unit tests. Remove?
-    public SharedGroup(String databaseFile) {
-        context = new Context();
-        path = databaseFile;
-        nativePtr = nativeCreate(databaseFile, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, null);
-        checkNativePtrNotZero();
-    }
-
-    public SharedGroup(String canonicalPath, boolean enableImplicitTransactions, Durability durability, byte[] key) {
-        if (enableImplicitTransactions) {
-            nativeReplicationPtr = nativeCreateReplication(canonicalPath, key);
-            nativePtr = openSharedGroupOrFail(durability, key);
-            implicitTransactionsEnabled = true;
-        } else {
-            nativePtr = nativeCreate(canonicalPath, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, key);
-        }
-        context = new Context();
-        path = canonicalPath;
-        checkNativePtrNotZero();
-    }
-
-    private long openSharedGroupOrFail(Durability durability, byte[] key) {
-        // We have anecdotal evidence that on some versions of Android it is possible for two versions of an app
-        // to exist in two processes during an app upgrade. This is problematic since the lock file might not be
-        // compatible across two versions of Android. See https://github.com/realm/realm-java/issues/2459. If this
-        // happens we assume the overlap is really small so instead of failing outright we retry using incremental
-        // backoff.
-        int i = 0;
-        final long start = System.nanoTime();
-        RuntimeException lastError = null;
-        while (TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS) < INCREMENTAL_BACKOFF_LIMIT_MS) {
-            try {
-                long nativePtr = createNativeWithImplicitTransactions(nativeReplicationPtr, durability.value, key);
-                if (i > 0) {
-                    RealmLog.w("IncompatibleLockFile was detected. Error was resolved after " + i + " retries");
-                }
-                return nativePtr;
-            } catch (IncompatibleLockFileException e) {
-                i++;
-                lastError = e;
-                try {
-                    Thread.sleep(getSleepTime(i));
-                    RealmLog.d("Waiting for another process to release the Realm file: " + path);
-                } catch (InterruptedException ignored) {
-                    RealmLog.d("Waiting for Realm to open interrupted: " + path);
-                }
-            }
-        }
-
-        throw new RealmError("Could not open the Realm file: " + lastError.getMessage());
-    }
-
-    // Returns the time to sleep before retrying opening the SharedGroup.
-    private static long getSleepTime(int tries) {
-        if (INCREMENTAL_BACKOFF_MS == null) {
-            return 0;
-        } else {
-            if (tries > INCREMENTAL_BACKOFF_MS.length) {
-                return INCREMENTAL_BACKOFF_MS[INCREMENTAL_BACKOFF_MS.length - 1];
-            } else {
-                return INCREMENTAL_BACKOFF_MS[tries - 1];
-            }
-        }
-    }
-
-    // TODO Only used by Unit tests. Remove?
-    public SharedGroup(String canonicalPath, Durability durability, byte[] key) {
-        path = canonicalPath;
-        context = new Context();
-        nativePtr = nativeCreate(canonicalPath, durability.value, false, false, key);
-        checkNativePtrNotZero();
-    }
-
-    void advanceRead() {
-        nativeAdvanceRead(nativePtr);
-    }
-
-    void advanceRead(VersionID versionID) throws BadVersionException {
-        nativeAdvanceReadToVersion(nativePtr, versionID.version, versionID.index);
-    }
-
-    void promoteToWrite() {
-        nativePromoteToWrite(nativePtr);
-    }
-
-    void commitAndContinueAsRead() {
-        nativeCommitAndContinueAsRead(nativePtr);
-    }
-
-    void rollbackAndContinueAsRead() {
-        nativeRollbackAndContinueAsRead(nativePtr);
-    }
-
-    public ImplicitTransaction beginImplicitTransaction() {
-        if (activeTransaction) {
-            throw new IllegalStateException(
-                    "Can't beginImplicitTransaction() during another active transaction");
-        }
-        long nativeGroupPtr = nativeBeginImplicit(nativePtr);
-        ImplicitTransaction transaction = new ImplicitTransaction(context, this, nativeGroupPtr);
-        activeTransaction = true;
-        return transaction;
-    }
-
-    public WriteTransaction beginWrite() {
-        if (activeTransaction)
-            throw new IllegalStateException(
-                    "Can't beginWrite() during another active transaction");
-        // FIXME: throw from nativeMethod in case of error
-
-        long nativeWritePtr = nativeBeginWrite(nativePtr);
-        try {
-            // Copy context reference from parent
-            WriteTransaction t = new WriteTransaction(context, this, nativeWritePtr);
-            activeTransaction = true;
-            return t;
-        } catch (RuntimeException e) {
-            Group.nativeClose(nativeWritePtr);
-            throw e;
-        }
-    }
-
-    public ReadTransaction beginRead() {
-        if (activeTransaction)
-            throw new IllegalStateException("Can't beginRead() during another active transaction");
-        // FIXME: throw from nativeMethod in case of error
-
-        long nativeReadPtr = nativeBeginRead(nativePtr);
-        try {
-            // Copy context reference from parent
-            ReadTransaction t = new ReadTransaction(context, this, nativeReadPtr);
-            activeTransaction = true;
-            return t;
-        } catch (RuntimeException e) {
-            Group.nativeClose(nativeReadPtr);
-            throw e;
-        }
-    }
-
-    void endRead() {
-        if (isClosed())
-            throw new IllegalStateException("Can't endRead() on closed group. " +
-                    "ReadTransaction is invalid.");
-        nativeEndRead(nativePtr);
-        activeTransaction = false;
-    }
-
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-                nativePtr = 0;
-                if (implicitTransactionsEnabled && nativeReplicationPtr != 0) {
-                    nativeCloseReplication(nativeReplicationPtr);
-                    nativeReplicationPtr = 0;
-                }
-            }
-        }
-    }
-
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeSharedGroup(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-                if (implicitTransactionsEnabled && nativeReplicationPtr != 0) {
-                    nativeCloseReplication(nativeReplicationPtr);
-                    nativeReplicationPtr = 0;
-                }
-            }
-        }
-    }
-
-    void commit() {
-        if (isClosed())
-            throw new IllegalStateException(
-                    "Can't commit() on closed group. WriteTransaction is invalid.");
-        nativeCommit(nativePtr);
-        activeTransaction = false;
-    }
-
-    void rollback() {
-        if (isClosed())
-            throw new IllegalStateException(
-                    "Can't rollback() on closed group. WriteTransaction is invalid.");
-        nativeRollback(nativePtr);
-        activeTransaction = false;
-    }
-
-    public boolean isClosed() {
-        return nativePtr == 0;
-    }
-
-    public boolean hasChanged() {
-        return nativeHasChanged(nativePtr);
-    }
-
-    public void reserve(long bytes) {
-        nativeReserve(nativePtr, bytes);
-    }
-
-    /**
-     * Compacts a shared group. This will block access to the shared group until done.
-     *
-     * @return {@code true} if compaction succeeded, {@code false} otherwise.
-     * @throws RuntimeException if using this within either a read or or write transaction.
-     */
-    public boolean compact() {
-        return nativeCompact(nativePtr);
-    }
-
-    /**
-     * Returns the absolute path to the file backing this SharedGroup.
-     *
-     * @return the canonical path to the Realm file.
-     */
-    public String getPath() {
-        return path;
-    }
-
-    private void checkNativePtrNotZero() {
-        if (this.nativePtr == 0) {
-            throw new IOError(new RealmIOException("Realm could not be opened"));
-        }
-    }
-
-    public long getNativePointer () {
-        return nativePtr;
-    }
-
-    public long getNativeReplicationPointer () {
-        return nativeReplicationPtr;
-    }
-
-    public VersionID getVersion () {
-        long[] versionId = nativeGetVersionID (nativePtr);
-        return new VersionID (versionId[0], versionId[1]);
-
-    }
-
-    public static class VersionID implements Comparable<VersionID> {
-        final long version;
-        final long index;
-
-        VersionID(long version, long index) {
-            this.version = version;
-            this.index = index;
-        }
-
-        @Override
-        public int compareTo(VersionID another) {
-            if (version > another.version) {
-                return 1;
-            } else if (version < another.version) {
-                return -1;
-            } else {
-                return 0;
-            }
-        }
-
-        @Override
-        public String toString() {
-            return "VersionID{" +
-                    "version=" + version +
-                    ", index=" + index +
-                    '}';
-        }
-
-        @Override
-        public boolean equals(Object object) {
-            if (this == object) return true;
-            if (object == null || getClass() != object.getClass()) return false;
-            if (!super.equals(object)) return false;
-
-            VersionID versionID = (VersionID) object;
-            return (version == versionID.version && index == versionID.index);
-        }
-
-        @Override
-        public int hashCode() {
-            int result = super.hashCode();
-            result = 31 * result + (int) (version ^ (version >>> 32));
-            result = 31 * result + (int) (index ^ (index >>> 32));
-            return result;
-        }
-    }
-
-    /**
-     * Waits for change committed by {@link SharedGroup} in other Thread.
-     *
-     * @return {@code true} if successfully detects change, {@code false} no change has been detected otherwise.
-     */
-    public boolean waitForChange() {
-        return nativeWaitForChange(nativePtr);
-    }
-
-    /**
-     * Stops waiting for change.
-     */
-    public void stopWaitForChange() {
-        nativeStopWaitForChange(nativePtr);
-    }
-
-    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr,
-                                                             int durability, byte[] key);
-    private native long nativeCreateReplication(String databaseFile, byte[] key);
-    private native void nativeCommitAndContinueAsRead(long nativePtr);
-    private native long nativeBeginImplicit(long nativePtr);
-
-    private native void nativeReserve(long nativePtr, long bytes);
-    private native boolean nativeHasChanged(long nativePtr);
-    private native long nativeBeginRead(long nativePtr);
-    private native void nativeEndRead(long nativePtr);
-    private native long nativeBeginWrite(long nativePtr);
-    private native void nativeCommit(long nativePtr);
-    private native void nativeRollback(long nativePtr);
-    private native long nativeCreate(String databaseFile,
-                                     int durabilityValue,
-                                     boolean dontCreateFile,
-                                     boolean enableReplication,
-                                     byte[] key);
-    private native boolean nativeCompact(long nativePtr);
-    protected static native void nativeClose(long nativePtr);
-    private native void nativeCloseReplication(long nativeReplicationPtr);
-    private native void nativeRollbackAndContinueAsRead(long nativePtr);
-    private native long[] nativeGetVersionID (long nativePtr);
-    private native boolean nativeWaitForChange(long nativePtr);
-    private native void nativeStopWaitForChange(long nativePtr);
-    private native void nativeAdvanceRead(long nativePtr);
-    private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index) throws BadVersionException;
-    private native void nativePromoteToWrite(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
deleted file mode 100644
index 7eac1c3ef1..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-
-import io.realm.RealmConfiguration;
-import io.realm.internal.async.BadVersionException;
-import io.realm.internal.log.RealmLog;
-
-/**
- * This class wraps access to a given Realm file on a single thread including its {@link SharedGroup} and
- * {@link ImplicitTransaction}. By nature this means that this class is not thread safe and should only be used from the
- * thread that created it.
- *
- * Realm is a MVCC database (Multiversion concurrency control), which means that multiple versions of the data might
- * exist in the same file. By default the file is always opened on the latest version and it is possible to advance to
- * the latest version by calling {@link #advanceRead()}.
- */
-public class SharedGroupManager implements Closeable {
-
-    private SharedGroup sharedGroup;
-    private ImplicitTransaction transaction;
-
-    /**
-     * Creates a new instance of the FileWrapper for the given configuration on this thread.
-     */
-    public SharedGroupManager(RealmConfiguration configuration) {
-        this.sharedGroup = new SharedGroup(
-                configuration.getPath(),
-                SharedGroup.IMPLICIT_TRANSACTION,
-                configuration.getDurability(),
-                configuration.getEncryptionKey());
-        this.transaction = sharedGroup.beginImplicitTransaction();
-    }
-
-    /**
-     * Closes the underlying {@link SharedGroup} and free any native resources.
-     */
-    @Override
-    public void close() {
-        sharedGroup.close();
-        sharedGroup = null;
-        transaction = null;
-    }
-
-    /**
-     * Checks if the Realm file is accessible.
-     *
-     * @return {@code true} if the file is open and data can be accessed, {@code false} otherwise.
-     */
-    public boolean isOpen() {
-        return sharedGroup != null;
-    }
-
-    /**
-     * Advances the Realm file to the latest version.
-     */
-    public void advanceRead() {
-        transaction.advanceRead();
-    }
-
-    /**
-     * Advances the Realm file to the given version.
-     */
-    public void advanceRead(SharedGroup.VersionID version) throws BadVersionException {
-        transaction.advanceRead(version);
-    }
-
-
-    // Public because of migrations. Gets the full table name. Prefix will not be added.
-    // TODO Remove when new Migration API is introduced.
-    public Table getTable(String tableName) {
-        return transaction.getTable(tableName);
-    }
-
-    /**
-     * Checks if a Realm file can be advanced to a newer version.
-     */
-    public boolean hasChanged() {
-        return sharedGroup.hasChanged();
-    }
-
-    /**
-     * Returns the version for the SharedGroup.
-     */
-    public SharedGroup.VersionID getVersion() {
-        return sharedGroup.getVersion();
-    }
-
-    /**
-     * Makes the file writable. This will block all other threads and processes from making it writable as well.
-     */
-    public void promoteToWrite() {
-        transaction.promoteToWrite();
-    }
-
-    /**
-     * Commits any pending changes to the file and return to read-only mode.
-     */
-    public void commitAndContinueAsRead() {
-        transaction.commitAndContinueAsRead();
-    }
-
-    /**
-     * Rollbacks any changes to the file since it was made writable and continue in read-only mode.
-     */
-    public void rollbackAndContinueAsRead() {
-        transaction.rollbackAndContinueAsRead();
-    }
-
-    /**
-     * Checks if a given table exists.
-     *
-     * @return {code true} if the table exists. {@code false} otherwise.
-     */
-    public boolean hasTable(String tableName) {
-        return transaction.hasTable(tableName);
-    }
-
-    /**
-     * Writes a copy of this Realm file to another location.
-     */
-    public void copyToFile(File destination, byte[] key) throws IOException {
-        transaction.writeToFile(destination, key);
-    }
-
-    /**
-     * Returns a reference to current {@link SharedGroup}.
-     */
-    public SharedGroup getSharedGroup() {
-        return sharedGroup;
-    }
-
-    /**
-     * Returns a reference to the current {@link ImplicitTransaction}.
-     */
-    public ImplicitTransaction getTransaction() {
-        return transaction;
-    }
-
-    /**
-     * Returns if the Realm is currently not in a transaction.
-     */
-    public boolean isImmutable() {
-        return transaction.immutable;
-    }
-
-    /**
-     * Compacts a Realm file. It cannot be open when calling this method.
-     * Returns true if compaction succeeded, false otherwise.
-     */
-    public static boolean compact(RealmConfiguration configuration) {
-        SharedGroup sharedGroup = null;
-        boolean result = false;
-        try {
-            sharedGroup = new SharedGroup(
-                    configuration.getPath(),
-                    SharedGroup.IMPLICIT_TRANSACTION,
-                    SharedGroup.Durability.FULL,
-                    configuration.getEncryptionKey());
-            result = sharedGroup.compact();
-        } catch (Exception e) {
-            RealmLog.i(e.getMessage());
-            return false;
-        } finally {
-            if (sharedGroup != null) {
-                sharedGroup.close();
-            }
-        }
-        return result;
-    }
-
-    public long getNativePointer() {
-        return sharedGroup.getNativePointer();
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
new file mode 100644
index 0000000000..e7ad6c0417
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.io.Closeable;
+import java.io.File;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmSchema;
+import io.realm.internal.async.BadVersionException;
+
+public final class SharedRealm implements Closeable {
+
+    // Const value for RealmFileException conversion
+    public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
+    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 1;
+    public static final byte FILE_EXCEPTION_KIND_EXISTS = 2;
+    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 3;
+    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 4;
+    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 5;
+
+    public static void initialize(File tempDirectory) {
+        if (SharedRealm.temporaryDirectory != null) {
+            // already initialized
+            return;
+        }
+        if (tempDirectory == null) {
+            throw new IllegalArgumentException("'tempDirectory' must not be null.");
+        }
+
+        String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
+        if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
+            throw new IOException("failed to create temporary directory: " + temporaryDirectoryPath);
+        }
+
+        if (!temporaryDirectoryPath.endsWith("/")) {
+            temporaryDirectoryPath += "/";
+        }
+        nativeInit(temporaryDirectoryPath);
+        SharedRealm.temporaryDirectory = tempDirectory;
+    }
+
+    public static File getTemporaryDirectory() {
+        return temporaryDirectory;
+    }
+
+    private volatile static File temporaryDirectory;
+
+    public enum Durability {
+        FULL(0),
+        MEM_ONLY(1);
+
+        final int value;
+
+        Durability(int value) {
+            this.value = value;
+        }
+    }
+
+    // Public for static checking in JNI
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_READONLY = 1;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_RESET_FILE = 2;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_ADDITIVE = 3;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_MANUAL = 4;
+    @SuppressWarnings("WeakerAccess")
+    public enum SchemaMode {
+        SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
+        SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
+        SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
+        SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
+        SCHEMA_MODE_MANUAL(SCHEMA_MODE_VALUE_MANUAL);
+
+        final byte value;
+        SchemaMode(byte value) {
+            this .value = value;
+        }
+
+        public byte getNativeValue() {
+            return value;
+        }
+    }
+
+    // JNI will only hold a weak global ref to this.
+    public final RealmNotifier realmNotifier;
+    public final ObjectServerFacade objectServerFacade;
+
+    public static class VersionID implements Comparable<VersionID> {
+        public final long version;
+        public final long index;
+
+        VersionID(long version, long index) {
+            this.version = version;
+            this.index = index;
+        }
+
+        @Override
+        public int compareTo(@SuppressWarnings("NullableProblems") VersionID another) {
+            if (another == null) {
+                throw new IllegalArgumentException("Version cannot be compared to a null value.");
+            }
+            if (version > another.version) {
+                return 1;
+            } else if (version < another.version) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "VersionID{" +
+                    "version=" + version +
+                    ", index=" + index +
+                    '}';
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object == null || getClass() != object.getClass()) {
+                return false;
+            }
+
+            VersionID versionID = (VersionID) object;
+            return (version == versionID.version && index == versionID.index);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode();
+            result = 31 * result + (int) (version ^ (version >>> 32));
+            result = 31 * result + (int) (index ^ (index >>> 32));
+            return result;
+        }
+    }
+
+    public interface SchemaVersionListener {
+        void onSchemaVersionChanged(long currentVersion);
+    }
+
+    private long nativePtr;
+    private RealmConfiguration configuration;
+    final Context context;
+    private long lastSchemaVersion;
+    private final SchemaVersionListener schemaChangeListener;
+
+    private SharedRealm(long nativePtr, RealmConfiguration configuration, RealmNotifier notifier,
+                        SchemaVersionListener schemaVersionListener) {
+        this.nativePtr = nativePtr;
+        this.configuration = configuration;
+        this.realmNotifier = notifier;
+        this.schemaChangeListener = schemaVersionListener;
+        context = new Context();
+        this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
+        objectServerFacade = null;
+    }
+
+    public static SharedRealm getInstance(RealmConfiguration config) {
+        return getInstance(config, null, null);
+    }
+
+    public static SharedRealm getInstance(RealmConfiguration config, RealmNotifier realmNotifier,
+                                          SchemaVersionListener schemaVersionListener) {
+        String[] userAndServer = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
+        String rosServerUrl = userAndServer[0];
+        String rosUserToken = userAndServer[1];
+        boolean enable_caching = false; // Handled in Java currently
+        boolean disableFormatUpgrade = false; // TODO Double negatives :/
+        boolean autoChangeNotifications = true;
+        long nativeConfigPtr = nativeCreateConfig(
+                config.getPath(),
+                config.getEncryptionKey(),
+                rosServerUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
+                config.getDurability() == Durability.MEM_ONLY,
+                enable_caching,
+                disableFormatUpgrade,
+                autoChangeNotifications,
+                rosServerUrl,
+                rosUserToken);
+        try {
+            return new SharedRealm(
+                    nativeGetSharedRealm(nativeConfigPtr, realmNotifier),
+                    config,
+                    realmNotifier,
+                    schemaVersionListener);
+        } finally {
+            nativeCloseConfig(nativeConfigPtr);
+        }
+    }
+
+    long getNativePtr() {
+        return nativePtr;
+    }
+
+    public void beginTransaction() {
+        nativeBeginTransaction(nativePtr);
+        invokeSchemaChangeListenerIfSchemaChanged();
+    }
+
+    public void commitTransaction() {
+        nativeCommitTransaction(nativePtr);
+    }
+
+    public void cancelTransaction() {
+        nativeCancelTransaction(nativePtr);
+    }
+
+    public boolean isInTransaction() {
+        return nativeIsInTransaction(nativePtr);
+    }
+
+    public void setSchemaVersion(long schemaVersion) {
+        nativeSetVersion(nativePtr, schemaVersion);
+    }
+
+    public long getSchemaVersion() {
+        return nativeGetVersion(nativePtr);
+    }
+
+    // FIXME: This should be removed, migratePrimaryKeyTableIfNeeded is using it which should be in Object Store instead?
+    long getGroupNative() {
+        return nativeReadGroup(nativePtr);
+    }
+
+    public boolean hasTable(String name) {
+        return nativeHasTable(nativePtr, name);
+    }
+
+    public Table getTable(String name) {
+        return new Table(this, nativeGetTable(nativePtr, name));
+    }
+
+    public void renameTable(String oldName, String newName) {
+        nativeRenameTable(nativePtr, oldName, newName);
+    }
+
+    public void removeTable(String name) {
+        nativeRemoveTable(nativePtr, name);
+    }
+
+    public String getTableName(int index) {
+        return nativeGetTableName(nativePtr, index);
+    }
+
+    public long size() {
+        return nativeSize(nativePtr);
+    }
+
+    public String getPath() {
+        return configuration.getPath();
+    }
+
+    public boolean isEmpty() {
+        return nativeIsEmpty(nativePtr);
+    }
+
+    public void refresh() {
+        nativeRefresh(nativePtr);
+        invokeSchemaChangeListenerIfSchemaChanged();
+    }
+
+    public void refresh(SharedRealm.VersionID version) throws BadVersionException {
+        // FIXME: This will have a different behaviour compared to refresh to the latest version.
+        // In the JNI this will just advance read the corresponding SharedGroup to the specific version without notifier
+        // or transact log observer involved. Before we use notification & fine grained notification from OS, it is not
+        // a problem.
+        nativeRefresh(nativePtr, version.version, version.index);
+        invokeSchemaChangeListenerIfSchemaChanged();
+    }
+
+    public SharedRealm.VersionID getVersionID() {
+        long[] versionId = nativeGetVersionID (nativePtr);
+        return new SharedRealm.VersionID(versionId[0], versionId[1]);
+    }
+
+    public long getLastSnapshotVersion() {
+        return nativeGetSnapshotVersion(nativePtr);
+    }
+
+    public boolean isClosed() {
+        return nativePtr == 0 || nativeIsClosed(nativePtr);
+    }
+
+    public void writeCopy(File file, byte[] key) {
+        if (file.isFile() && file.exists()) {
+            throw new IllegalArgumentException("The destination file must not exist");
+        }
+        nativeWriteCopy(nativePtr, file.getAbsolutePath(), key);
+    }
+
+    public boolean waitForChange() {
+        return nativeWaitForChange(nativePtr);
+    }
+
+    public void stopWaitForChange() {
+        nativeStopWaitForChange(nativePtr);
+    }
+
+    public boolean compact() {
+        return nativeCompact(nativePtr);
+    }
+
+    public void updateSchema(RealmSchema schema, long version) {
+        nativeUpdateSchema(nativePtr, schema.getNativePtr(), version);
+    }
+
+    @Override
+    public void close() {
+        if (realmNotifier != null) {
+            realmNotifier.close();
+        }
+        synchronized (context) {
+            if (nativePtr != 0) {
+                nativeCloseSharedRealm(nativePtr);
+                nativePtr = 0;
+            }
+        }
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        synchronized (context) {
+            close();
+            // FIXME: Below is the original implementation of SharedGroup.finalize().
+            // And actually Context.asyncDisposeSharedGroup will simply call nativeClose which is not asyc at all.
+            // IMO since this implemented Closeable already, it makes no sense to implement finalize.
+            // Just keep the logic the same for now and make nativeClose private. Rethink about this when cleaning
+            // up finalizers.
+            //context.asyncDisposeSharedRealm(nativePtr);
+        }
+        super.finalize();
+    }
+
+    public void invokeSchemaChangeListenerIfSchemaChanged() {
+        if (schemaChangeListener == null) {
+            return;
+        }
+
+        final long before = lastSchemaVersion;
+        final long current = getSchemaVersion();
+        if (current != before) {
+            lastSchemaVersion = current;
+            schemaChangeListener.onSchemaVersionChanged(current);
+        }
+    }
+
+    private static native void nativeInit(String temporaryDirectoryPath);
+    private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
+                                                  boolean cache, boolean disableFormatUpgrade,
+                                                  boolean autoChangeNotification,
+                                                  String syncServerURL, String syncUserToken);
+    private static native void nativeCloseConfig(long nativeConfigPtr);
+    private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
+    private static native void nativeCloseSharedRealm(long nativeSharedRealmPtr);
+    private static native boolean nativeIsClosed(long nativeSharedRealmPtr);
+    private static native void nativeBeginTransaction(long nativeSharedRealmPtr);
+    private static native void nativeCommitTransaction(long nativeSharedRealmPtr);
+    private static native void nativeCancelTransaction(long nativeSharedRealmPtr);
+    private static native boolean nativeIsInTransaction(long nativeSharedRealmPtr);
+    private static native long nativeGetVersion(long nativeSharedRealmPtr);
+    private static native long nativeGetSnapshotVersion(long nativeSharedRealmPtr);
+    private static native void nativeSetVersion(long nativeSharedRealmPtr, long version);
+    private static native long nativeReadGroup(long nativeSharedRealmPtr);
+    private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
+    private static native void nativeRefresh(long nativeSharedRealmPtr);
+    private static native void nativeRefresh(long nativeSharedRealmPtr, long version, long index);
+    private static native long[]  nativeGetVersionID(long nativeSharedRealmPtr);
+    private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
+    private static native String nativeGetTableName(long nativeSharedRealmPtr, int index);
+    private static native boolean nativeHasTable(long nativeSharedRealmPtr, String tableName);
+    private static native void nativeRenameTable(long nativeSharedRealmPtr, String oldTableName, String newTableName);
+    private static native void nativeRemoveTable(long nativeSharedRealmPtr, String tableName);
+    private static native long nativeSize(long nativeSharedRealmPtr);
+    private static native void nativeWriteCopy(long nativeSharedRealmPtr, String path, byte[] key);
+    private static native boolean nativeWaitForChange(long nativeSharedRealmPtr);
+    private static native void nativeStopWaitForChange(long nativeSharedRealmPtr);
+    private static native boolean nativeCompact(long nativeSharedRealmPtr);
+    private static native void nativeUpdateSchema(long nativePtr, long nativeSchemaPtr, long version);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 84b8696654..b5c210ba29 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -16,15 +16,11 @@
 
 package io.realm.internal;
 
-import java.io.Closeable;
 import java.util.Date;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.RealmFieldType;
-import io.realm.Sort;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
-import io.realm.internal.log.RealmLog;
 
 
 /**
@@ -32,14 +28,11 @@
  * (define/insert/delete/update) a table has. All the native communications to the Realm C++ library are also handled by
  * this class.
  */
-public class Table implements TableOrView, TableSchema, Closeable {
+public class Table implements TableOrView, TableSchema, NativeObject {
 
     public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
     public static final String TABLE_PREFIX = Util.getTablePrefix();
     public static final long INFINITE = -1;
-    public static final String STRING_DEFAULT_VALUE = "";
-    public static final long INTEGER_DEFAULT_VALUE = 0;
-    public static final String METADATA_TABLE_NAME = "metadata";
     public static final boolean NULLABLE = true;
     public static final boolean NOT_NULLABLE = false;
 
@@ -51,25 +44,16 @@
     private static final long NO_PRIMARY_KEY = -2;
 
     protected long nativePtr;
-    protected final Object parent;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     private final Context context;
+    private final SharedRealm sharedRealm;
     private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
-    // test:
-    protected int tableNo;
-    private static final boolean DEBUG = false;
-    static AtomicInteger tableCount = new AtomicInteger(0);
-
-    static {
-        RealmCore.loadLibrary();
-    }
-
     /**
      * Constructs a Table base object. It can be used to register columns in this table. Registering into table is
      * allowed only for empty tables. It creates a native reference of the object and keeps a reference to it.
      */
     public Table() {
-        this.parent = null; // No parent in free-standing table
         this.context = new Context();
         // Native methods work will be initialized here. Generated classes will
         // have nothing to do with the native functions. Generated Java Table
@@ -78,59 +62,38 @@ public Table() {
         if (nativePtr == 0) {
             throw new java.lang.OutOfMemoryError("Out of native memory.");
         }
-        if (DEBUG) {
-            tableNo = tableCount.incrementAndGet();
-            RealmLog.d("====== New Tablebase " + tableNo + " : ptr = " + nativePtr);
-        }
+        this.sharedRealm = null;
+        context.addReference(this);
     }
 
-    Table(Context context, Object parent, long nativePointer) {
-        this.context = context;
-        this.parent  = parent;
-        this.nativePtr = nativePointer;
-        if (DEBUG) {
-            tableNo = tableCount.incrementAndGet();
-            RealmLog.d("===== New Tablebase(ptr) " + tableNo + " : ptr = " + nativePtr);
-        }
+    Table(Table parent, long nativePointer) {
+        this(parent.sharedRealm, nativePointer);
     }
 
-    @Override
-    public Table getTable() {
-        return this;
+    Table(SharedRealm sharedRealm, long nativePointer) {
+        this.context = sharedRealm.context;
+        this.sharedRealm = sharedRealm;
+        this.nativePtr = nativePointer;
+        context.addReference(this);
     }
 
-    public long getNativeTablePointer() {
+    @Override
+    public long getNativePtr() {
         return nativePtr;
     }
 
-    // If close() is called, no penalty is paid for delayed disposal
-    // via the context
     @Override
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-                if (DEBUG) {
-                    tableCount.decrementAndGet();
-                    RealmLog.d("==== CLOSE " + tableNo + " ptr= " + nativePtr + " remaining " + tableCount.get());
-                }
-                nativePtr = 0;
-            }
-        }
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
     }
 
     @Override
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                boolean isRoot = (parent == null);
-                context.asyncDisposeTable(nativePtr, isRoot);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
-        if (DEBUG) {
-            RealmLog.d("==== FINALIZE " + tableNo + "...");
-        }
+    public Table getTable() {
+        return this;
+    }
+
+    public long getNativeTablePointer() {
+        return nativePtr;
     }
 
     /*
@@ -139,7 +102,6 @@ protected void finalize() {
      * You can no longer perform any actions on the table, and if done anyway, an exception is thrown.
      * The only method you can call is 'isValid()'.
      */
-
     public boolean isValid() {
         return nativePtr != 0 && nativeIsValid(nativePtr);
     }
@@ -227,8 +189,8 @@ public void removeColumn(long columnIndex) {
      *
      * @param columnIndex the column index to be renamed.
      * @param newName a new name replacing the old column name.
-     * @throws {@link IllegalArgumentException} if {@code newFieldName} is an empty string, or exceeds field name length limit.
-     * @throws {@link IllegalStateException} if a PrimaryKey column name could not be found in the meta table, but {@link #getPrimaryKey()} returns an index.
+     * @throws IllegalArgumentException if {@code newFieldName} is an empty string, or exceeds field name length limit.
+     * @throws IllegalStateException if a PrimaryKey column name could not be found in the meta table, but {@link #getPrimaryKey()} returns an index.
      */
     @Override
     public void renameColumn(long columnIndex, String newName) {
@@ -247,9 +209,13 @@ public void renameColumn(long columnIndex, String newName) {
             try {
                 String className = tableNameToClassName(getName());
                 Table pkTable = getPrimaryKeyTable();
+                if (pkTable == null) {
+                    throw new IllegalStateException(
+                            "Table is not created from a SharedRealm, primary key is not available");
+                }
                 long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
                 if (pkRowIndex != NO_MATCH) {
-                    pkTable.setString(PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName);
+                    nativeSetString(pkTable.nativePtr, PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName, false);
                 } else {
                     throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
                 }
@@ -398,50 +364,62 @@ public void moveLastOver(long rowIndex) {
         nativeMoveLastOver(nativePtr, rowIndex);
     }
 
+    /**
+     * Add an empty row to the table which doesn't have a primary key defined.
+     * <p>
+     * NOTE: To add a table with a primary key defined, use {@link #addEmptyRowWithPrimaryKey(Object)} instead. This
+     * won't check if this table has a primary key.
+     *
+     * @return row index.
+     */
     public long addEmptyRow() {
         checkImmutable();
-        if (hasPrimaryKey()) {
-            long primaryKeyColumnIndex = getPrimaryKey();
-            RealmFieldType type = getColumnType(primaryKeyColumnIndex);
-            switch (type) {
-                case STRING:
-                    if (findFirstString(primaryKeyColumnIndex, STRING_DEFAULT_VALUE) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException(STRING_DEFAULT_VALUE);
-                    }
-                    break;
-                case INTEGER:
-                    if (findFirstLong(primaryKeyColumnIndex, INTEGER_DEFAULT_VALUE) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException(INTEGER_DEFAULT_VALUE);
-                    }
-                    break;
-                default:
-                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
-            }
-        }
-
         return nativeAddEmptyRow(nativePtr, 1);
     }
 
+    /**
+     * Add an empty row to the table and set the primary key with the given value. Equivalent to call
+     * {@link #addEmptyRowWithPrimaryKey(Object, boolean)} with {@code validation = true}.
+     *
+     * @param primaryKeyValue the primary key value
+     * @return the row index.
+     */
     public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
-        checkImmutable();
-        checkHasPrimaryKey();
+        return addEmptyRowWithPrimaryKey(primaryKeyValue, true);
+    }
+
+    /**
+     * Add an empty row to the table and set the primary key with the given value.
+     *
+     * @param primaryKeyValue the primary key value.
+     * @param validation set to {@code false} to skip all validations. This is currently used by bulk insert which
+     *                     has its own validations.
+     * @return the row index.
+     */
+    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation) {
+        if (validation) {
+            checkImmutable();
+            checkHasPrimaryKey();
+        }
 
         long primaryKeyColumnIndex = getPrimaryKey();
         RealmFieldType type = getColumnType(primaryKeyColumnIndex);
         long rowIndex;
-        UncheckedRow row;
 
         // Add with primary key initially set
         if (primaryKeyValue == null) {
             switch (type) {
                 case STRING:
                 case INTEGER:
-                    if (findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
+                    if (validation && findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException("null");
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    row = getUncheckedRow(rowIndex);
-                    row.setNull(primaryKeyColumnIndex);
+                    if (type == RealmFieldType.STRING) {
+                        nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, null);
+                    } else {
+                        nativeSetNullUnique(nativePtr, primaryKeyColumnIndex, rowIndex);
+                    }
                     break;
 
                 default:
@@ -454,12 +432,11 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     if (!(primaryKeyValue instanceof String)) {
                         throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
                     }
-                    if (findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
+                    if (validation && findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException(primaryKeyValue);
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    row = getUncheckedRow(rowIndex);
-                    row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
+                    nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, (String) primaryKeyValue);
                     break;
 
                 case INTEGER:
@@ -469,12 +446,11 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     } catch (RuntimeException e) {
                         throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
                     }
-                    if (findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
+                    if (validation && findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException(pkValue);
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    row = getUncheckedRow(rowIndex);
-                    row.setLong(primaryKeyColumnIndex, pkValue);
+                    nativeSetLongUnique(nativePtr, primaryKeyColumnIndex, rowIndex, pkValue);
                     break;
 
                 default:
@@ -484,6 +460,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
         return rowIndex;
     }
 
+    @SuppressWarnings("WeakerAccess")
     public long addEmptyRows(long rows) {
         checkImmutable();
         if (rows < 1) {
@@ -503,6 +480,9 @@ public long addEmptyRows(long rows) {
      *
      * @param values values.
      * @return the row index of the appended row.
+     * @deprecated Remove this functions since it doesn't seem to be useful. And this function does deal with tables
+     * withprimary key defined well. Primary key has to be set with `setXxxUnique` as the first thing to do after row
+     * added.
      */
     protected long add(Object... values) {
         long rowIndex = addEmptyRow();
@@ -541,43 +521,43 @@ protected long add(Object... values) {
             Object value = values[(int)columnIndex];
             switch (colTypes[(int)columnIndex]) {
             case BOOLEAN:
-                nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
+                nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value, false);
                 break;
             case INTEGER:
                 if (value == null) {
                     checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-                    nativeSetNull(nativePtr, columnIndex, rowIndex);
+                    nativeSetNull(nativePtr, columnIndex, rowIndex, false);
                 } else {
                     long intValue = ((Number) value).longValue();
                     checkIntValueIsLegal(columnIndex, rowIndex, intValue);
-                    nativeSetLong(nativePtr, columnIndex, rowIndex, intValue);
+                    nativeSetLong(nativePtr, columnIndex, rowIndex, intValue, false);
                 }
                 break;
             case FLOAT:
-                nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value);
+                nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value, false);
                 break;
             case DOUBLE:
-                nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value);
+                nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value, false);
                 break;
             case STRING:
                 if (value == null) {
                     checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-                    nativeSetNull(nativePtr, columnIndex, rowIndex);
+                    nativeSetNull(nativePtr, columnIndex, rowIndex, false);
                 } else {
                     String stringValue = (String) value;
                     checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
-                    nativeSetString(nativePtr, columnIndex, rowIndex, (String) value);
+                    nativeSetString(nativePtr, columnIndex, rowIndex, (String) value, false);
                 }
                 break;
             case DATE:
                 if (value == null)
                     throw new IllegalArgumentException("Null Date is not allowed.");
-                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime());
+                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime(), false);
                 break;
             case BINARY:
                 if (value == null)
                     throw new IllegalArgumentException("Null Array is not allowed");
-                nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
+                nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value, false);
                 break;
             case UNSUPPORTED_MIXED:
             case UNSUPPORTED_TABLE:
@@ -592,48 +572,6 @@ private boolean isPrimaryKeyColumn(long columnIndex) {
         return columnIndex == getPrimaryKey();
     }
 
-    /**
-     * Returns a view sorted by the specified column and order.
-     *
-     * @param columnIndex the column index.
-     * @param sortOrder the sort order.
-     * @return a sorted view.
-     */
-    public TableView getSortedView(long columnIndex, Sort sortOrder){
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeGetSortedView(nativePtr, columnIndex, sortOrder.getValue());
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
-    }
-
-    /**
-     * Returns a view sorted by the specified column by the default order.
-     *
-     * @param columnIndex the column index.
-     * @return a sorted view.
-     */
-    public TableView getSortedView(long columnIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeGetSortedView(nativePtr, columnIndex, true);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    public TableView getSortedView(long columnIndices[], Sort sortOrders[]) {
-        context.executeDelayedDisposal();
-        boolean[] nativeSortOrder = new boolean[sortOrders.length];
-        for (int i = 0; i < sortOrders.length; i++) {
-            nativeSortOrder[i] = sortOrders[i].getValue();
-        }
-        long nativeViewPtr = nativeGetSortedViewMulti(nativePtr, columnIndices, nativeSortOrder);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
     /**
      * Returns the column index for the primary key.
      *
@@ -667,7 +605,7 @@ public long getPrimaryKey() {
      * @param columnIndex the index of column in the table.
      * @return {@code true} if column is a primary key, {@code false} otherwise.
      */
-    public boolean isPrimaryKey(long columnIndex) {
+    private boolean isPrimaryKey(long columnIndex) {
         return columnIndex >= 0 && columnIndex == getPrimaryKey();
     }
 
@@ -768,43 +706,26 @@ public String getString(long columnIndex, long rowIndex) {
         return nativeGetString(nativePtr, columnIndex, rowIndex);
     }
 
-    /**
-     * Gets the value of a (binary) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index value of the cell row.
-     * @return value of the particular cell.
-     */
-    /*
-    @Override
-    public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex) {
-        return nativeGetByteBuffer(nativePtr, columnIndex, rowIndex);
-    }
-
-    protected native ByteBuffer nativeGetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex);
-     */
-
     @Override
     public byte[] getBinaryByteArray(long columnIndex, long rowIndex) {
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
     public long getLink(long columnIndex, long rowIndex) {
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
     public Table getLinkTarget(long columnIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeTablePointer = nativeGetLinkTarget(nativePtr, columnIndex);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this.parent, nativeTablePointer);
-        }
-        catch (RuntimeException e) {
-            Table.nativeClose(nativeTablePointer);
-            throw e;
-        }
+        // Copy context reference from parent
+        Table table = new Table(this.sharedRealm, nativeTablePointer);
+        return table;
+    }
+
+    @Override
+    public boolean isNull(long columnIndex, long rowIndex) {
+        return nativeIsNull(nativePtr, columnIndex, rowIndex);
     }
 
     /**
@@ -847,36 +768,36 @@ public CheckedRow getCheckedRow(long index) {
     //
 
     @Override
-    public void setLong(long columnIndex, long rowIndex, long value) {
+    public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
         checkIntValueIsLegal(columnIndex, rowIndex, value);
-        nativeSetLong(nativePtr, columnIndex, rowIndex, value);
+        nativeSetLong(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setBoolean(long columnIndex, long rowIndex, boolean value) {
+    public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault) {
         checkImmutable();
-        nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
+        nativeSetBoolean(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setFloat(long columnIndex, long rowIndex, float value) {
+    public void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault) {
         checkImmutable();
-        nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
+        nativeSetFloat(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setDouble(long columnIndex, long rowIndex, double value) {
+    public void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault) {
         checkImmutable();
-        nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
+        nativeSetDouble(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
     @Override
-    public void setDate(long columnIndex, long rowIndex, Date date) {
+    public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault) {
         if (date == null)
             throw new IllegalArgumentException("Null Date is not allowed.");
         checkImmutable();
-        nativeSetTimestamp(nativePtr, columnIndex, rowIndex, date.getTime());
+        nativeSetTimestamp(nativePtr, columnIndex, rowIndex, date.getTime(), isDefault);
     }
 
     /**
@@ -887,50 +808,33 @@ public void setDate(long columnIndex, long rowIndex, Date date) {
      * @param value a String value to set in the cell.
      */
     @Override
-    public void setString(long columnIndex, long rowIndex, String value) {
+    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault) {
         checkImmutable();
         if (value == null) {
             checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-            nativeSetNull(nativePtr, columnIndex, rowIndex);
+            nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
         } else {
             checkStringValueIsLegal(columnIndex, rowIndex, value);
-            nativeSetString(nativePtr, columnIndex, rowIndex, value);
+            nativeSetString(nativePtr, columnIndex, rowIndex, value, isDefault);
         }
     }
 
-    /**
-     * Sets the value for a (binary) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the ByteBuffer must be allocated with {@code ByteBuffer.allocateDirect(len)}.
-     */
-
-    /*
     @Override
-    public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data) {
-        if (immutable) throwImmutable();
-        if (data == null)
-            throw new IllegalArgumentException("Null array");
-        if (data.isDirect())
-            nativeSetByteBuffer(nativePtr, columnIndex, rowIndex, data);
-        else
-            throw new RuntimeException("Currently ByteBuffer must be allocateDirect()."); // FIXME: support other than allocateDirect
+    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault) {
+        checkImmutable();
+        nativeSetByteArray(nativePtr, columnIndex, rowIndex, data, isDefault);
     }
 
-    protected native void nativeSetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex, ByteBuffer data);
-     */
-
-
     @Override
-    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data) {
+    public void setLink(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
-        nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
+        nativeSetLink(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
-    public void setLink(long columnIndex, long rowIndex, long value) {
+    public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
         checkImmutable();
-        nativeSetLink(nativePtr, columnIndex, rowIndex, value);
+        checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
+        nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
     }
 
     public void addSearchIndex(long columnIndex) {
@@ -948,7 +852,7 @@ public void removeSearchIndex(long columnIndex) {
      *
      * @param columnName the name of the field that will function primary key. "" or {@code null} will remove any
      *                   previous set magic key.
-     * @throws {@link io.realm.exceptions.RealmException} if it is not possible to set the primary key due to the column
+     * @throws io.realm.exceptions.RealmException if it is not possible to set the primary key due to the column
      * not having distinct values (i.e. violating the primary key constraint).
      */
     public void setPrimaryKey(String columnName) {
@@ -964,17 +868,15 @@ public void setPrimaryKey(long columnIndex) {
     }
 
     private Table getPrimaryKeyTable() {
-        Group group = getTableGroup();
-        if (group == null) {
+        if (sharedRealm == null) {
             return null;
         }
-
-        Table pkTable = group.getTable(PRIMARY_KEY_TABLE_NAME);
+        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
         if (pkTable.getColumnCount() == 0) {
-            pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
+            checkImmutable();
+            long columnIndex = pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
+            pkTable.addSearchIndex(columnIndex);
             pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
-        } else {
-            migratePrimaryKeyTableIfNeeded(group, pkTable);
         }
 
         return pkTable;
@@ -996,41 +898,44 @@ private void invalidateCachedPrimaryKeyIndex() {
      * This will remove the prefix "class_" from all table names in the pk_column
      * Any database created on Realm-Java 0.84.1 and below will have this error.
      */
-    private void migratePrimaryKeyTableIfNeeded(Group group, Table pkTable) {
-        nativeMigratePrimaryKeyTableIfNeeded(group.nativePtr, pkTable.nativePtr);
+    public static boolean migratePrimaryKeyTableIfNeeded(SharedRealm sharedRealm) {
+        if (sharedRealm == null || !sharedRealm.isInTransaction()) {
+            throwImmutable();
+        }
+        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
+            return false;
+        }
+        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
+        return nativeMigratePrimaryKeyTableIfNeeded(sharedRealm.getGroupNative(), pkTable.nativePtr);
     }
 
-    // Recursively look at parents until either a Group or null is found
-    Group getTableGroup() {
-        if (parent instanceof Group)  {
-            return (Group) parent;
-        } else if (parent instanceof Table) {
-            return ((Table) parent).getTableGroup();
-        } else {
-            return null; // Free table
+    public static boolean primaryKeyTableNeedsMigration(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
+            return false;
         }
+        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
+        return nativePrimaryKeyTableNeedsMigration(pkTable.nativePtr);
     }
 
     public boolean hasSearchIndex(long columnIndex) {
         return nativeHasSearchIndex(nativePtr, columnIndex);
     }
 
+    @Override
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
 
     boolean isImmutable() {
-        if (!(parent instanceof Table)) {
-            return parent != null && ((Group) parent).immutable;
-        } else {
-            return ((Table)parent).isImmutable();
-        }
+        return sharedRealm != null && !sharedRealm.isInTransaction();
     }
 
+    // This checking should be moved to SharedRealm level
     void checkImmutable() {
         if (isImmutable()) {
             throwImmutable();
@@ -1149,16 +1054,9 @@ public long count(long columnIndex, String value) {
 
     @Override
     public TableQuery where() {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeQueryPtr = nativeWhere(nativePtr);
-        try {
-            // Copy context reference from parent
-            return new TableQuery(this.context, this, nativeQueryPtr);
-        } catch (RuntimeException e) {
-            TableQuery.nativeClose(nativeQueryPtr);
-            throw e;
-        }
+        // Copy context reference from parent
+        return new TableQuery(this.context, this, nativeQueryPtr);
     }
 
     /**
@@ -1222,66 +1120,32 @@ public long findFirstNull(long columnIndex) {
 
     @Override
     public TableView findAllLong(long columnIndex, long value) {
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllInt(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     @Override
     public TableView findAllBoolean(long columnIndex, boolean value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllBool(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     @Override
     public TableView findAllFloat(long columnIndex, float value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllFloat(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     @Override
     public TableView findAllDouble(long columnIndex, double value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllDouble(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     @Override
     public TableView findAllString(long columnIndex, String value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllString(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     // Experimental feature
@@ -1308,15 +1172,8 @@ public Table pivot(long stringCol, long intCol, PivotType pivotType) {
     //
 
     public TableView getDistinctView(long columnIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        this.context.executeDelayedDisposal();
         long nativeViewPtr = nativeGetDistinctView(nativePtr, columnIndex);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     /**
@@ -1328,13 +1185,6 @@ public String getName() {
         return nativeGetName(nativePtr);
     }
 
-
-    // Optimize
-    public void optimize() {
-        checkImmutable();
-        nativeOptimize(nativePtr);
-    }
-
     @Override
     public String toJson() {
         return nativeToJson(nativePtr);
@@ -1351,7 +1201,7 @@ public String toString() {
         }
         if (hasPrimaryKey()) {
             String pkFieldName = getColumnName(getPrimaryKey());
-            stringBuilder.append("has \'" + pkFieldName + "\' field as a PrimaryKey, and ");
+            stringBuilder.append("has \'").append(pkFieldName).append("\' field as a PrimaryKey, and ");
         }
         stringBuilder.append("contains ");
         stringBuilder.append(columnCount);
@@ -1377,7 +1227,7 @@ public long syncIfNeeded() {
         throw new RuntimeException("Not supported for tables");
     }
 
-    private void throwImmutable() {
+    private static void throwImmutable() {
         throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
     }
 
@@ -1395,10 +1245,10 @@ public boolean hasSameSchema(Table table) {
     }
 
     /**
-     * Checks if a given table name is a meta-table, i.e. a table used by Realm to track its internal state.
+     * Checks if a given table name is a name for a model table.
      */
-    public static boolean isMetaTable(String tableName) {
-        return (tableName.equals(METADATA_TABLE_NAME) || tableName.equals(PRIMARY_KEY_TABLE_NAME));
+    public static boolean isModelTable(String tableName) {
+        return tableName.startsWith(TABLE_PREFIX);
     }
 
     /**
@@ -1420,9 +1270,7 @@ public static String tableNameToClassName(String tableName) {
     }
 
     protected native long createNative();
-    static native void nativeClose(long nativeTablePtr);
     private native boolean nativeIsValid(long nativeTablePtr);
-    private native boolean nativeIsRootTable(long nativeTablePtr);
     private native long nativeAddColumn(long nativeTablePtr, int type, String name, boolean isNullable);
     private native long nativeAddColumnLink(long nativeTablePtr, int type, String name, long targetTablePtr);
     private native void nativeRenameColumn(long nativeTablePtr, long columnIndex, String name);
@@ -1440,7 +1288,6 @@ public static String tableNameToClassName(String tableName) {
     private native void nativeRemoveLast(long nativeTablePtr);
     private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
     public static native long nativeAddEmptyRow(long nativeTablePtr, long rows);
-    private native long nativeGetSortedView(long nativeTableViewPtr, long columnIndex, boolean ascending);
     private native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
     private native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
     private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
@@ -1452,18 +1299,24 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
     public static native long nativeGetLinkView(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeGetLinkTarget(long nativePtr, long columnIndex);
+    private native boolean nativeIsNull(long nativePtr, long columnIndex, long rowIndex);
     native long nativeGetRowPtr(long nativePtr, long index);
-    public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-    public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
-    public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
-    public static native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-    public static native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
-    public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-    public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
-    public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
+    public static native void nativeSetLongUnique(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value, boolean isDefault);
+    public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value, boolean isDefault);
+    public static native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value, boolean isDefault);
+    public static native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue, boolean isDefault);
+    public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value, boolean isDefault);
+    public static native void nativeSetStringUnique(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex, boolean isDefault);
+    // Use nativeSetStringUnique(null) for String column!
+    public static native void nativeSetNullUnique(long nativeTablePtr, long columnIndex, long rowIndex);
+    public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data, boolean isDefault);
+    public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
     private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
-    private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
+    private static native boolean nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
+    private static native boolean nativePrimaryKeyTableNeedsMigration(long primaryKeyTableNativePtr);
     private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
     private native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
     private native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
@@ -1499,15 +1352,16 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
+    // FIXME: Disabled in cpp code, see comments there
+    // private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
     private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
     private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
     private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long resultPtr);
     private native long nativeGetDistinctView(long nativePtr, long columnIndex);
     private native String nativeGetName(long nativeTablePtr);
-    private native void nativeOptimize(long nativeTablePtr);
     private native String nativeToJson(long nativeTablePtr);
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
     private native long nativeVersion(long nativeTablePtr);
+    private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 9157aa37ed..58404ee5bf 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -37,8 +37,6 @@
      */
     Table getTable();
 
-    void close();
-
     /**
      * Returns the number of entries of the table/view.
      *
@@ -153,7 +151,7 @@
      * @param rowIndex
      * @param value
      */
-    void setLong(long columnIndex, long rowIndex, long value);
+    void setLong(long columnIndex, long rowIndex, long value, boolean isDefault);
 
     /**
      * Sets the boolean value of a cell identified by the columnIndex and the rowIndex of that cell.
@@ -162,7 +160,7 @@
      * @param rowIndex
      * @param value
      */
-    void setBoolean(long columnIndex, long rowIndex, boolean value);
+    void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault);
 
     /**
      * Sets the float value of a cell identified by the columnIndex and the rowIndex of that cell.
@@ -171,7 +169,7 @@
      * @param rowIndex
      * @param value
      */
-    void setFloat(long columnIndex, long rowIndex, float value);
+    void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault);
 
     /**
      * Sets the double value of a cell identified by the columnIndex and the rowIndex of that cell.
@@ -180,7 +178,7 @@
      * @param rowIndex
      * @param value
      */
-    void setDouble(long columnIndex, long rowIndex, double value);
+    void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault);
 
     /**
      * Sets the string value of a particular cell of the table/view identified by the columnIndex and the rowIndex of
@@ -190,7 +188,7 @@
      * @param rowIndex
      * @param value
      */
-    void setString(long columnIndex, long rowIndex, String value);
+    void setString(long columnIndex, long rowIndex, String value, boolean isDefault);
 
     /**
      * Sets the binary value for a particular cell identified by the rowIndex and columnIndex of the cell.
@@ -201,9 +199,9 @@
      */
     //void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data);
 
-    void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data);
+    void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault);
 
-    void setDate(long columnIndex, long rowIndex, Date date);
+    void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault);
 
     boolean isNullLink(long columnIndex, long rowIndex);
 
@@ -216,7 +214,11 @@
      * @param rowIndex
      * @param value
      */
-    void setLink(long columnIndex, long rowIndex, long value);
+    void setLink(long columnIndex, long rowIndex, long value, boolean isDefault);
+
+    void setNull(long columnIndex, long rowIndex, boolean isDefault);
+
+    boolean isNull(long columnIndex, long rowIndex);
 
     long sumLong(long columnIndex);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 7d550ea226..d8c6433681 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -16,17 +16,17 @@
 
 package io.realm.internal;
 
-import java.io.Closeable;
 import java.util.Date;
 
 import io.realm.Case;
 import io.realm.Sort;
 import io.realm.internal.async.BadVersionException;
 
-public class TableQuery implements Closeable {
+public class TableQuery implements NativeObject {
     protected boolean DEBUG = false;
 
     protected long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     protected final Table table;
     // Don't convert this into local variable and don't remove this.
     // Core requests Query to hold the TableView reference which it is built from.
@@ -48,6 +48,7 @@ public TableQuery(Context context, Table table, long nativeQueryPtr) {
         this.table = table;
         this.nativePtr = nativeQueryPtr;
         this.origin = null;
+        context.addReference(this);
     }
 
     public TableQuery(Context context, Table table, long nativeQueryPtr, TableOrView origin) {
@@ -58,28 +59,17 @@ public TableQuery(Context context, Table table, long nativeQueryPtr, TableOrView
         this.table = table;
         this.nativePtr = nativeQueryPtr;
         this.origin = origin;
+        context.addReference(this);
     }
 
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-
-                if (DEBUG)
-                    System.err.println("++++ Query CLOSE, ptr= " + nativePtr);
-
-                nativePtr = 0;
-            }
-        }
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
     }
 
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeQuery(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
     }
 
     /**
@@ -420,11 +410,15 @@ public TableQuery isNotEmpty(long[] columnIndices) {
 
     // Searching methods.
 
+    @Deprecated // Doesn't seem to be used
     public long find(long fromTableRow) {
         validateQuery();
         return nativeFind(nativePtr, fromTableRow);
     }
 
+    /**
+     * Returns the table row index for the first element matching the query.
+     */
     public long find() {
         validateQuery();
         return nativeFind(nativePtr, 0);
@@ -433,106 +427,87 @@ public long find() {
     /**
      * Performs a find query then handover the resulted Row (ready to be imported by another thread/shared_group).
      *
-     * @param bgSharedGroupPtr current shared_group from which to operate the query.
-     * @param nativeReplicationPtr replication pointer associated with the shared_group.
+     * @param sharedRealm current {@link SharedRealm }from which to operate the query.
      * @param ptrQuery query to run the the find against.
      * @return pointer to the handover result (table_view).
      */
-    public long findWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery) {
-        validateQuery();
+    public static long findWithHandover(SharedRealm sharedRealm, long ptrQuery) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeFindWithHandover(bgSharedGroupPtr, ptrQuery, 0);
+        return nativeFindWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0);
     }
 
     public TableView findAll(long start, long end, long limit) {
         validateQuery();
 
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAll(nativePtr, start, end, limit);
-        try {
-            return new TableView(this.context, this.table, nativeViewPtr, this);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.table, nativeViewPtr, this);
     }
 
     public TableView findAll() {
         validateQuery();
 
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAll(nativePtr, 0, Table.INFINITE, Table.INFINITE);
-        try {
-            return new TableView(this.context, this.table, nativeViewPtr, this);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.table, nativeViewPtr, this);
     }
 
     // handover find* methods
     // this will use a background SharedGroup to import the query (using the handover object)
     // run the query, and return the table view to the caller SharedGroup using the handover object.
-    public long findAllWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeFindAllWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE);
+    public static long findAllWithHandover(SharedRealm sharedRealm, long ptrQuery) throws BadVersionException {
+        return nativeFindAllWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    public long findDistinctWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery, long columnIndex) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeGetDistinctViewWithHandover(bgSharedGroupPtr, ptrQuery, columnIndex);
+    public static long findDistinctWithHandover(SharedRealm sharedRealm, long ptrQuery, long columnIndex) throws BadVersionException {
+        return nativeGetDistinctViewWithHandover(sharedRealm.getNativePtr(), ptrQuery, columnIndex);
     }
 
-    public long findAllSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long columnIndex, Sort sortOrder) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeFindAllSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
+    public static long findAllSortedWithHandover(SharedRealm sharedRealm, long ptrQuery, long columnIndex, Sort sortOrder) throws BadVersionException {
+        return nativeFindAllSortedWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
     }
 
-    public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long[] columnIndices, Sort[] sortOrders) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
+    public static long findAllMultiSortedWithHandover(SharedRealm sharedRealm, long ptrQuery, long[] columnIndices, Sort[] sortOrders) throws BadVersionException {
         boolean[] ascendings = getNativeSortOrderValues(sortOrders);
-        return nativeFindAllMultiSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
+        return nativeFindAllMultiSortedWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
     }
 
+    public static long[] batchUpdateQueries(SharedRealm sharedRealm, long[] handoverQueries, long[][] parameters,
+                                            long[][] queriesParameters, boolean[][] multiSortOrder)
+            throws BadVersionException {
+        return nativeBatchUpdateQueries(sharedRealm.getNativePtr(), handoverQueries, parameters, queriesParameters,
+                multiSortOrder);
+    }
     /**
      * Imports a TableView from a worker thread to the caller thread.
      *
      * @param handoverPtr pointer to the handover object
-     * @param callerSharedGroupPtr pointer to the SharedGroup on the caller thread.
+     * @param sharedRealm the SharedRealm on the caller thread.
      * @return the TableView on the caller thread.
      * @throws BadVersionException if the worker thread and caller thread are not at the same version.
      */
-    public TableView importHandoverTableView(long handoverPtr, long callerSharedGroupPtr) throws BadVersionException {
-        long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, callerSharedGroupPtr);
-        try {
-            return new TableView(this.context, this.table, nativeTvPtr);
-        } catch (RuntimeException e) {
-            if (nativeTvPtr != 0) {
-                TableView.nativeClose(nativeTvPtr);
-            }
-            throw e;
-        }
+    public TableView importHandoverTableView(long handoverPtr, SharedRealm sharedRealm) throws BadVersionException {
+        long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, sharedRealm.getNativePtr());
+        return new TableView(this.context, this.table, nativeTvPtr);
+    }
+
+    /**
+     * Imports a row from a worker thread to the caller thread.
+     *
+     * @param handoverRowPtr pointer to the handover row object
+     * @param sharedRealm the SharedRealm on the caller thread.
+     * @return the row pointer on the caller thread.
+     */
+    public static long importHandoverRow(long handoverRowPtr, SharedRealm sharedRealm) {
+        return nativeImportHandoverRowIntoSharedGroup(handoverRowPtr, sharedRealm.getNativePtr());
     }
 
     /**
      * Handovers the query, so it can be used by other SharedGroup (in different thread)
      *
-     * @param callerSharedGroupPtr native pointer to the SharedGroup holding the query
+     * @param sharedRealm the SharedGroup holding the query
      * @return native pointer to the handover query
      */
-    public long handoverQuery(long callerSharedGroupPtr) {
-        return nativeHandoverQuery(callerSharedGroupPtr, nativePtr);
+    public long handoverQuery(SharedRealm sharedRealm) {
+        return nativeHandoverQuery(sharedRealm.getNativePtr(), nativePtr);
     }
 
     //
@@ -715,17 +690,10 @@ public long count() {
         return nativeCount(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    // Deletion.
-    public long remove(long start, long end) {
-        validateQuery();
-        if (table.isImmutable()) throwImmutable();
-        return nativeRemove(nativePtr, start, end, Table.INFINITE);
-    }
-
     public long remove() {
         validateQuery();
         if (table.isImmutable()) throwImmutable();
-        return nativeRemove(nativePtr, 0, Table.INFINITE, Table.INFINITE);
+        return nativeRemove(nativePtr);
     }
 
     /**
@@ -743,7 +711,6 @@ private void throwImmutable() {
         throw new IllegalStateException("Mutable method call during read transaction.");
     }
 
-    protected static native void nativeClose(long nativeQueryPtr);
     private native String nativeValidateQuery(long nativeQueryPtr);
     private native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
     private native void nativeGroup(long nativeQueryPtr);
@@ -806,15 +773,16 @@ private void throwImmutable() {
     private native void nativeIsNull(long nativePtr, long columnIndices[]);
     private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
-    private native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
-    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedGroupPtr) throws BadVersionException;
-    private native long nativeHandoverQuery(long callerSharedGroupPtr, long nativeQueryPtr);
-    public static native long nativeFindAllSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending) throws BadVersionException;
-    public static native long nativeFindAllWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit) throws BadVersionException;
-    public static native long nativeGetDistinctViewWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long columnIndex) throws BadVersionException;
-    public static native long nativeFindWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long fromTableRow);
-    public static native long nativeFindAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending) throws BadVersionException;
-    public static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedGroupPtr);
+    private native long nativeRemove(long nativeQueryPtr);
+    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedRealmPtr) throws BadVersionException;
+    private native long nativeHandoverQuery(long callerSharedRealmPtr, long nativeQueryPtr);
+    private static native long nativeFindAllSortedWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending) throws BadVersionException;
+    private static native long nativeFindAllWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit) throws BadVersionException;
+    private  static native long nativeGetDistinctViewWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long columnIndex) throws BadVersionException;
+    private static native long nativeFindWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long fromTableRow);
+    private static native long nativeFindAllMultiSortedWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending) throws BadVersionException;
+    private static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedRealmPtr);
     public static native void nativeCloseQueryHandover(long nativePtr);
-    public static native long[] nativeBatchUpdateQueries(long bgSharedGroupPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder) throws BadVersionException;
+    private static native long[] nativeBatchUpdateQueries(long bgSharedRealmPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder) throws BadVersionException;
+    private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index df97a3fb06..9c352f08bc 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -16,13 +16,11 @@
 
 package io.realm.internal;
 
-import java.io.Closeable;
 import java.util.Date;
 import java.util.List;
 
 import io.realm.RealmFieldType;
 import io.realm.Sort;
-import io.realm.internal.log.RealmLog;
 
 /**
  * This class represents a view of a particular table. We can think of a tableview as a subset of a table. It contains
@@ -31,14 +29,19 @@
  * The view doesn't copy data from the table, but contains merely a list of row-references into the original table
  * with the real data.
  */
-public class TableView implements TableOrView, Closeable {
-    private static final boolean DEBUG = false; //true;
+public class TableView implements TableOrView, NativeObject {
     // Don't convert this into local variable and don't remove this.
     // Core requests TableView to hold the Query reference.
     @SuppressWarnings({"unused"})
     private final TableQuery query; // the query which created this TableView
     private long version; // Last seen version number. Call refresh() to update this.
 
+    protected long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    protected final Table parent;
+    private final Context context;
+
+
     /**
      * Creates a TableView. This constructor is used if the TableView is created from a table.
      *
@@ -51,6 +54,7 @@ protected TableView(Context context, Table parent, long nativePtr) {
         this.parent = parent;
         this.nativePtr = nativePtr;
         this.query = null;
+        context.addReference(this);
     }
 
     /**
@@ -67,35 +71,22 @@ protected TableView(Context context, Table parent, long nativePtr, TableQuery qu
         this.parent = parent;
         this.nativePtr = nativePtr;
         this.query = query;
+        context.addReference(this);
     }
 
     @Override
-    public Table getTable() {
-        return parent;
+    public long getNativePtr() {
+        return nativePtr;
     }
 
     @Override
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-
-                if (DEBUG) {
-                    RealmLog.d("==== TableView CLOSE, ptr= " + nativePtr);
-                }
-                nativePtr = 0;
-            }
-        }
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
     }
 
     @Override
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeTableView(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
+    public Table getTable() {
+        return parent;
     }
 
     /**
@@ -270,6 +261,11 @@ public long getLink(long columnIndex, long rowIndex){
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
+    public boolean isNull(long columnIndex, long rowIndex) {
+        return nativeIsNull(nativePtr, columnIndex, rowIndex);
+    }
+
     // Methods for setting values.
 
     /**
@@ -280,7 +276,7 @@ public long getLink(long columnIndex, long rowIndex){
      * @param value the value.
      */
     @Override
-    public void setLong(long columnIndex, long rowIndex, long value){
+    public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLong(nativePtr, columnIndex, rowIndex, value);
     }
@@ -293,7 +289,7 @@ public void setLong(long columnIndex, long rowIndex, long value){
      * @param value the value.
      */
     @Override
-    public void setBoolean(long columnIndex, long rowIndex, boolean value){
+    public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
     }
@@ -306,7 +302,7 @@ public void setBoolean(long columnIndex, long rowIndex, boolean value){
      * @param value the value.
      */
     @Override
-    public void setFloat(long columnIndex, long rowIndex, float value){
+    public void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
     }
@@ -319,7 +315,7 @@ public void setFloat(long columnIndex, long rowIndex, float value){
      * @param value the value.
      */
     @Override
-    public void setDouble(long columnIndex, long rowIndex, double value){
+    public void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
     }
@@ -332,7 +328,7 @@ public void setDouble(long columnIndex, long rowIndex, double value){
      * @param value the value.
      */
     @Override
-    public void setDate(long columnIndex, long rowIndex, Date value){
+    public void setDate(long columnIndex, long rowIndex, Date value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetTimestampValue(nativePtr, columnIndex, rowIndex, value.getTime());
     }
@@ -345,7 +341,7 @@ public void setDate(long columnIndex, long rowIndex, Date value){
      * @param value the value.
      */
     @Override
-    public void setString(long columnIndex, long rowIndex, String value){
+    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetString(nativePtr, columnIndex, rowIndex, value);
     }
@@ -368,20 +364,29 @@ public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data
     */
 
     @Override
-    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data){
+    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    public void setLink(long columnIndex, long rowIndex, long value){
+    @Override
+    public void setLink(long columnIndex, long rowIndex, long value, boolean isDefault){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
     }
 
+    @Override
+    public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
+        if (parent.isImmutable()) throwImmutable();
+        getTable().setNull(columnIndex, getSourceRowIndex(rowIndex), isDefault);
+    }
+
+    @Override
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
+    @Override
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
@@ -470,67 +475,32 @@ public long upperBoundLong(long columnIndex, long value) {
 
     @Override
     public TableView findAllLong(long columnIndex, long value){
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllInt(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.parent, nativeViewPtr);
     }
 
     @Override
     public TableView findAllBoolean(long columnIndex, boolean value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllBool(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.parent, nativeViewPtr);
     }
 
     @Override
     public TableView findAllFloat(long columnIndex, float value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllFloat(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.parent, nativeViewPtr);
     }
 
     @Override
     public TableView findAllDouble(long columnIndex, double value) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllDouble(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.parent, nativeViewPtr);
     }
 
     @Override
     public TableView findAllString(long columnIndex, String value){
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllString(nativePtr, columnIndex, value);
-        try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
+        return new TableView(this.context, this.parent, nativeViewPtr);
     }
 
     //
@@ -697,15 +667,8 @@ public String toString() {
 
     @Override
     public TableQuery where() {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        this.context.executeDelayedDisposal();
         long nativeQueryPtr = nativeWhere(nativePtr);
-        try {
-            return new TableQuery(this.context, this.parent, nativeQueryPtr, this);
-        } catch (RuntimeException e) {
-            TableQuery.nativeClose(nativeQueryPtr);
-            throw e;
-        }
+        return new TableQuery(this.context, this.parent, nativeQueryPtr, this);
     }
 
     /**
@@ -724,10 +687,6 @@ private void throwImmutable() {
         throw new IllegalStateException("Realm data can only be changed inside a write transaction.");
     }
 
-    protected long nativePtr;
-    protected final Table parent;
-    private final Context context;
-
     @Override
     public long count(long columnIndex, String value) {
         // TODO: implement
@@ -760,8 +719,6 @@ public Table pivot(long stringCol, long intCol, PivotType pivotType){
      * @throws UnsupportedOperationException if a column is not indexed.
      */
     public void distinct(long columnIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        this.context.executeDelayedDisposal();
         nativeDistinct(nativePtr, columnIndex);
     }
 
@@ -775,8 +732,6 @@ public void distinct(long columnIndex) {
      * @throws IllegalArgumentException if a column is unsupported type, or is not indexed.
      */
     public void distinct(List<Long> columnIndexes) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        this.context.executeDelayedDisposal();
         long[] indexes = new long[columnIndexes.size()];
         for (int i = 0; i < columnIndexes.size(); i++) {
             indexes[i] = columnIndexes.get(i);
@@ -790,7 +745,6 @@ public long syncIfNeeded() {
         return version;
     }
 
-    static native void nativeClose(long nativeViewPtr);
     private native long nativeSize(long nativeViewPtr);
     private native long nativeGetSourceRowIndex(long nativeViewPtr, long rowIndex);
     private native long nativeGetColumnCount(long nativeViewPtr);
@@ -805,6 +759,7 @@ public long syncIfNeeded() {
     private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native boolean nativeIsNull(long nativePtr, long columnIndex, long rowIndex);
     private native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
     private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
     private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
@@ -854,4 +809,5 @@ public long syncIfNeeded() {
     private native long nativeSyncIfNeeded(long nativeTablePtr);
     private native void nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
     private native long nativeSync(long nativeTablePtr);
+    private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
new file mode 100644
index 0000000000..275cecfb04
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+class TestUtil {
+
+    public native static long getMaxExceptionNumber();
+    public native static String getExpectedMessage(long exceptionKind);
+    public native static void testThrowExceptions(long exceptionKind);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index d2d012f466..b5b963f072 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -24,22 +24,42 @@
  * Wrapper around a Row in Realm Core.
  *
  * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the annotation
- * processor and {@link RealmProxyMediator#validateTable(Class, ImplicitTransaction)} which is called before the typed
+ * processor and {@link RealmProxyMediator#validateTable(Class, SharedRealm)} which is called before the typed
  * API can be used.
  *
  * For low-level access to Row data where error checking is required, use {@link CheckedRow}.
  */
-public class UncheckedRow extends NativeObject implements Row {
+public class UncheckedRow implements NativeObject, Row {
 
     final Context context; // This is only kept because for now it's needed by the constructor of LinkView
-    final Table parent;
+    private final Table parent;
+    private final long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
-    protected UncheckedRow(Context context, Table parent, long nativePtr) {
+    UncheckedRow(Context context, Table parent, long nativePtr) {
         this.context = context;
         this.parent = parent;
-        this.nativePointer = nativePtr;
+        this.nativePtr = nativePtr;
+        context.addReference(this);
+    }
+
+    // This is called by the CheckedRow constructor. The caller should hold a reference to the
+    // source UncheckedRow since the native destruction is handled by the source UncheckedRow.
+    UncheckedRow(UncheckedRow row) {
+        this.context = row.context;
+        this.parent = row.parent;
+        this.nativePtr = row.nativePtr;
+        // The destruction is handled by the source UncheckedRow. No need to add to the ref pool.
+    }
 
-        context.executeDelayedDisposal();
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
     }
 
     /**
@@ -50,11 +70,9 @@ protected UncheckedRow(Context context, Table parent, long nativePtr) {
      * @param index the index of the row.
      * @return an instance of Row for the table and index specified.
      */
-    public static UncheckedRow getByRowIndex(Context context, Table table, long index) {
+    static UncheckedRow getByRowIndex(Context context, Table table, long index) {
         long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
-        UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
-        context.addReference(NativeObjectReference.TYPE_ROW, row);
-        return row;
+        return new UncheckedRow(context, table, nativeRowPointer);
     }
 
     /**
@@ -65,10 +83,8 @@ public static UncheckedRow getByRowIndex(Context context, Table table, long inde
      * @param nativeRowPointer pointer of a row.
      * @return an instance of Row for the table and row specified.
      */
-    public static UncheckedRow getByRowPointer(Context context, Table table, long nativeRowPointer) {
-        UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
-        context.addReference(NativeObjectReference.TYPE_ROW, row);
-        return row;
+    static UncheckedRow getByRowPointer(Context context, Table table, long nativeRowPointer) {
+        return new UncheckedRow(context, table, nativeRowPointer);
     }
 
     /**
@@ -79,22 +95,19 @@ public static UncheckedRow getByRowPointer(Context context, Table table, long na
      * @param index the index of the row.
      * @return an instance of Row for the LinkView and index specified.
      */
-    public static UncheckedRow getByRowIndex(Context context, LinkView linkView, long index) {
-        long nativeRowPointer = linkView.nativeGetRow(linkView.nativePointer, index);
-        UncheckedRow row = new UncheckedRow(context, linkView.getTargetTable(),
-                nativeRowPointer);
-        context.addReference(NativeObjectReference.TYPE_ROW, row);
-        return row;
+    static UncheckedRow getByRowIndex(Context context, LinkView linkView, long index) {
+        long nativeRowPointer = linkView.nativeGetRow(linkView.getNativePtr(), index);
+        return new UncheckedRow(context, linkView.getTargetTable(), nativeRowPointer);
     }
 
     @Override
     public long getColumnCount() {
-        return nativeGetColumnCount(nativePointer);
+        return nativeGetColumnCount(nativePtr);
     }
 
     @Override
     public String getColumnName(long columnIndex) {
-        return nativeGetColumnName(nativePointer, columnIndex);
+        return nativeGetColumnName(nativePtr, columnIndex);
     }
 
 
@@ -103,12 +116,12 @@ public long getColumnIndex(String columnName) {
         if (columnName == null) {
             throw new IllegalArgumentException("Column name can not be null.");
         }
-        return nativeGetColumnIndex(nativePointer, columnName);
+        return nativeGetColumnIndex(nativePtr, columnName);
     }
 
     @Override
     public RealmFieldType getColumnType(long columnIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePointer, columnIndex));
+        return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
     }
 
     // Getters
@@ -120,57 +133,57 @@ public Table getTable() {
 
     @Override
     public long getIndex() {
-        return nativeGetIndex(nativePointer);
+        return nativeGetIndex(nativePtr);
     }
 
     @Override
     public long getLong(long columnIndex) {
-        return nativeGetLong(nativePointer, columnIndex);
+        return nativeGetLong(nativePtr, columnIndex);
     }
 
     @Override
     public boolean getBoolean(long columnIndex) {
-        return nativeGetBoolean(nativePointer, columnIndex);
+        return nativeGetBoolean(nativePtr, columnIndex);
     }
 
     @Override
     public float getFloat(long columnIndex) {
-        return nativeGetFloat(nativePointer, columnIndex);
+        return nativeGetFloat(nativePtr, columnIndex);
     }
 
     @Override
     public double getDouble(long columnIndex) {
-        return nativeGetDouble(nativePointer, columnIndex);
+        return nativeGetDouble(nativePtr, columnIndex);
     }
 
     @Override
     public Date getDate(long columnIndex) {
-        return new Date(nativeGetTimestamp(nativePointer, columnIndex));
+        return new Date(nativeGetTimestamp(nativePtr, columnIndex));
     }
 
     @Override
     public String getString(long columnIndex) {
-        return nativeGetString(nativePointer, columnIndex);
+        return nativeGetString(nativePtr, columnIndex);
     }
 
     @Override
     public byte[] getBinaryByteArray(long columnIndex) {
-        return nativeGetByteArray(nativePointer, columnIndex);
+        return nativeGetByteArray(nativePtr, columnIndex);
     }
 
     @Override
     public long getLink(long columnIndex) {
-        return nativeGetLink(nativePointer, columnIndex);
+        return nativeGetLink(nativePtr, columnIndex);
     }
 
     @Override
     public boolean isNullLink(long columnIndex) {
-        return nativeIsNullLink(nativePointer, columnIndex);
+        return nativeIsNullLink(nativePtr, columnIndex);
     }
 
     @Override
     public LinkView getLinkList(long columnIndex) {
-        long nativeLinkViewPtr = nativeGetLinkView(nativePointer, columnIndex);
+        long nativeLinkViewPtr = nativeGetLinkView(nativePtr, columnIndex);
         return new LinkView(context, parent, columnIndex, nativeLinkViewPtr);
     }
 
@@ -180,25 +193,25 @@ public LinkView getLinkList(long columnIndex) {
     public void setLong(long columnIndex, long value) {
         parent.checkImmutable();
         getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
-        nativeSetLong(nativePointer, columnIndex, value);
+        nativeSetLong(nativePtr, columnIndex, value);
     }
 
     @Override
     public void setBoolean(long columnIndex, boolean value) {
         parent.checkImmutable();
-        nativeSetBoolean(nativePointer, columnIndex, value);
+        nativeSetBoolean(nativePtr, columnIndex, value);
     }
 
     @Override
     public void setFloat(long columnIndex, float value) {
         parent.checkImmutable();
-        nativeSetFloat(nativePointer, columnIndex, value);
+        nativeSetFloat(nativePtr, columnIndex, value);
     }
 
     @Override
     public void setDouble(long columnIndex, double value) {
         parent.checkImmutable();
-        nativeSetDouble(nativePointer, columnIndex, value);
+        nativeSetDouble(nativePtr, columnIndex, value);
     }
 
     @Override
@@ -208,7 +221,7 @@ public void setDate(long columnIndex, Date date) {
             throw new IllegalArgumentException("Null Date is not allowed.");
         }
         long timestamp = date.getTime();
-        nativeSetTimestamp(nativePointer, columnIndex, timestamp);
+        nativeSetTimestamp(nativePtr, columnIndex, timestamp);
     }
 
     /**
@@ -222,34 +235,34 @@ public void setString(long columnIndex, String value) {
         parent.checkImmutable();
         if (value == null) {
             getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
-            nativeSetNull(nativePointer, columnIndex);
+            nativeSetNull(nativePtr, columnIndex);
         } else {
             getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
-            nativeSetString(nativePointer, columnIndex, value);
+            nativeSetString(nativePtr, columnIndex, value);
         }
     }
 
     @Override
     public void setBinaryByteArray(long columnIndex, byte[] data) {
         parent.checkImmutable();
-        nativeSetByteArray(nativePointer, columnIndex, data);
+        nativeSetByteArray(nativePtr, columnIndex, data);
     }
 
     @Override
     public void setLink(long columnIndex, long value) {
         parent.checkImmutable();
-        nativeSetLink(nativePointer, columnIndex, value);
+        nativeSetLink(nativePtr, columnIndex, value);
     }
 
     @Override
     public void nullifyLink(long columnIndex) {
         parent.checkImmutable();
-        nativeNullifyLink(nativePointer, columnIndex);
+        nativeNullifyLink(nativePtr, columnIndex);
     }
 
     @Override
     public boolean isNull(long columnIndex) {
-        return nativeIsNull(nativePointer, columnIndex);
+        return nativeIsNull(nativePtr, columnIndex);
     }
 
     /**
@@ -261,7 +274,7 @@ public boolean isNull(long columnIndex) {
     public void setNull(long columnIndex) {
         parent.checkImmutable();
         getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
-        nativeSetNull(nativePointer, columnIndex);
+        nativeSetNull(nativePtr, columnIndex);
     }
 
     /**
@@ -275,12 +288,12 @@ public CheckedRow convertToChecked() {
 
     @Override
     public boolean isAttached() {
-        return nativePointer != 0 && nativeIsAttached(nativePointer);
+        return nativePtr != 0 && nativeIsAttached(nativePtr);
     }
 
     @Override
     public boolean hasColumn(String fieldName) {
-        return nativeHasColumn(nativePointer, fieldName);
+        return nativeHasColumn(nativePtr, fieldName);
     }
 
     protected native long nativeGetColumnCount(long nativeTablePtr);
@@ -296,7 +309,7 @@ public boolean hasColumn(String fieldName) {
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
@@ -307,9 +320,9 @@ public boolean hasColumn(String fieldName) {
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
-    static native void nativeClose(long nativeRowPtr);
     protected native boolean nativeIsAttached(long nativeRowPtr);
     protected native boolean nativeHasColumn(long nativeRowPtr, String columnName);
     protected native boolean nativeIsNull(long nativeRowPtr, long columnIndex);
     protected native void nativeSetNull(long nativeRowPtr, long columnIndex);
+    private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 8d24bfe3b1..d262452289 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -16,28 +16,26 @@
 
 package io.realm.internal;
 
+import android.os.Build;
+
+import java.io.File;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import io.realm.RealmModel;
 import io.realm.RealmObject;
+import io.realm.log.RealmLog;
 
 public class Util {
 
-    static {
-        // Any internal class with static native methods that uses Realm Core must load the Realm Core library
-        // themselves as it otherwise might not have been loaded.
-        RealmCore.loadLibrary();
-    }
-
     public static long getNativeMemUsage() {
         return nativeGetMemUsage();
     }
     static native long nativeGetMemUsage();
 
-    // Set to level=1 to get some trace from JNI native part.
-    public static void setDebugLevel(int level) {
-        nativeSetDebugLevel(level);
-    }
-    static native void nativeSetDebugLevel(int level);
-
     // Called by JNI. Do not remove
     static void javaPrint(String txt) {
         System.out.print(txt);
@@ -48,43 +46,6 @@ public static String getTablePrefix() {
     }
     static native String nativeGetTablePrefix();
 
-
-    // Testcases run in nativeCode
-    public enum Testcase {
-        Exception_ClassNotFound(0),
-        Exception_NoSuchField(1),
-        Exception_NoSuchMethod(2),
-        Exception_IllegalArgument(3),
-        Exception_IOFailed(4),
-        Exception_FileNotFound(5),
-        Exception_FileAccessError(6),
-        Exception_IndexOutOfBounds(7),
-        Exception_TableInvalid(8),
-        Exception_UnsupportedOperation(9),
-        Exception_OutOfMemory(10),
-        Exception_FatalError(11),
-        Exception_RuntimeError(12),
-        Exception_RowInvalid(13),
-        Exception_EncryptionNotSupported(14),
-        Exception_CrossTableLink(15),
-        Exception_BadVersion(16),
-        Exception_IncompatibleLockFile(17);
-
-        private final int nativeTestcase;
-        Testcase(int nativeValue) {
-            this.nativeTestcase = nativeValue;
-        }
-
-        public String expectedResult(long parm1) {
-            return nativeTestcase(nativeTestcase, false, parm1);
-        }
-        public String execute(long parm1) {
-            return nativeTestcase(nativeTestcase, true, parm1);
-        }
-    }
-
-    static native String nativeTestcase(int testcase, boolean dotest, long parm1);
-
     /**
      * Normalizes a input class to it's original RealmObject class so it is transparent whether or not the input class
      * was a RealmProxy class.
@@ -101,4 +62,81 @@ public String execute(long parm1) {
 
         return clazz;
     }
+
+    //-----------------------------------------------------------------------
+    /**
+     * <p>Gets the stack trace from a Throwable as a String.</p>
+     *
+     * <p>The result of this method vary by JDK version as this method
+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
+     * On JDK1.3 and earlier, the cause exception will not be shown
+     * unless the specified throwable alters printStackTrace.</p>
+     *
+     * @param throwable  the <code>Throwable</code> to be examined
+     * @return the stack trace as generated by the exception's
+     *  <code>printStackTrace(PrintWriter)</code> method
+     *
+     * Credit: https://commons.apache.org/proper/commons-lang/apidocs/src-html/org/apache/commons/lang3/exception/ExceptionUtils.html
+     */
+     public static String getStackTrace(final Throwable throwable) {
+        final StringWriter sw = new StringWriter();
+        final PrintWriter pw = new PrintWriter(sw, true);
+        throwable.printStackTrace(pw);
+        return sw.getBuffer().toString();
+     }
+
+    // Credit: http://stackoverflow.com/questions/2799097/how-can-i-detect-when-an-android-application-is-running-in-the-emulator
+    public static boolean isEmulator() {
+        return Build.FINGERPRINT.startsWith("generic")
+                || Build.FINGERPRINT.startsWith("unknown")
+                || Build.MODEL.contains("google_sdk")
+                || Build.MODEL.contains("Emulator")
+                || Build.MODEL.contains("Android SDK built for x86")
+                || Build.MANUFACTURER.contains("Genymotion")
+                || (Build.BRAND.startsWith("generic") && Build.DEVICE.startsWith("generic"))
+                || "google_sdk".equals(Build.PRODUCT);
+    }
+
+    public static boolean deleteRealm(String canonicalPath, File realmFolder, String realmFileName) {
+        boolean realmDeleted = true;
+        final String management = ".management";
+        File managementFolder = new File(realmFolder, realmFileName + management);
+
+        // delete files in management directory and the directory
+        // there is no subfolders in the management directory
+        File[] files = managementFolder.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                realmDeleted = realmDeleted && file.delete();
+            }
+        }
+        realmDeleted = realmDeleted && managementFolder.delete();
+
+        // delete specific files in root directory
+        return realmDeleted && deletes(canonicalPath, realmFolder, realmFileName);
+    }
+
+    private static boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
+        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
+
+        List<File> filesToDelete = Arrays.asList(
+                new File(rootFolder, realmFileName),
+                new File(rootFolder, realmFileName + ".lock"),
+                // Old core log file naming styles
+                new File(rootFolder, realmFileName + ".log_a"),
+                new File(rootFolder, realmFileName + ".log_b"),
+                new File(rootFolder, realmFileName + ".log"),
+                new File(canonicalPath));
+        for (File fileToDelete : filesToDelete) {
+            if (fileToDelete.exists()) {
+                boolean deleteResult = fileToDelete.delete();
+                if (!deleteResult) {
+                    realmDeleted.set(false);
+                    RealmLog.warn("Could not delete the file %s", fileToDelete);
+                }
+            }
+        }
+        return realmDeleted.get();
+    }
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java
deleted file mode 100644
index af3fae4a20..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-public class WriteTransaction extends Group {
-
-    private final SharedGroup db;
-    private boolean committed;
-
-    public void commit() {
-        if (!committed) {
-            db.commit();
-            committed = true;
-        }
-        else {
-            throw new IllegalStateException("You can only commit once after a WriteTransaction has been made.");
-        }
-    }
-
-    public void rollback() {
-        db.rollback();
-    }
-
-    @Override
-    public void close() {
-        if (!committed) {
-            rollback();
-        }
-    }
-
-    WriteTransaction(Context context,SharedGroup db, long nativePtr) {
-        super(context, nativePtr, false);    // Group is mutable
-        this.db = db;
-        committed = false;
-    }
-
-    protected void finalize() {} // Nullify the actions of Group.finalize()
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
deleted file mode 100644
index 196b0450b3..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.android;
-
-import android.util.Log;
-
-import io.realm.internal.log.Logger;
-import io.realm.internal.log.RealmLog;
-
-public class AndroidLogger implements Logger {
-
-    private static final int LOG_ENTRY_MAX_LENGTH = 4000;
-    private int minimumLogLevel = RealmLog.VERBOSE;
-    private String logTag = "REALM";
-
-    /**
-     * Manually sets a logging tag.
-     *
-     * @param tag Logging tag to use for all subsequent logging calls.
-     */
-    public void setTag(String tag) {
-        logTag = tag;
-    }
-
-    /**
-     * Overrides the provided logger behavior and only log if log entry has a level equal or higher.
-     *
-     * @param logLevel the minimum log level to report.
-     */
-    public void setMinimumLogLevel(int logLevel) {
-        minimumLogLevel = logLevel;
-    }
-
-    // Inspired by https://github.com/JakeWharton/timber/blob/master/timber/src/main/java/timber/log/Timber.java
-    private void log(int logLevel, String message, Throwable t) {
-        if (logLevel < minimumLogLevel) {
-            return;
-        }
-        if (message == null || message.length() == 0) {
-            if (t != null) {
-                message = Log.getStackTraceString(t);
-            } else {
-                return; // Don't log if message is null and there is no throwable
-            }
-        } else if (t != null) {
-            message += "\n" + Log.getStackTraceString(t);
-        }
-
-       if (message.length() < 4000) {
-            Log.println(logLevel, logTag, message);
-        } else {
-           logMessageIgnoringLimit(logLevel, logTag, message);
-        }
-    }
-
-    /**
-     * Inspired by:
-     * http://stackoverflow.com/questions/8888654/android-set-max-length-of-logcat-messages
-     * https://github.com/jakubkrolewski/timber/blob/feature/logging_long_messages/timber/src/main/java/timber/log/Timber.java
-     */
-    private void logMessageIgnoringLimit(int logLevel, String tag, String message) {
-        while (message.length() != 0) {
-            int nextNewLineIndex = message.indexOf('\n');
-            int chunkLength = nextNewLineIndex != -1 ? nextNewLineIndex : message.length();
-            chunkLength = Math.min(chunkLength, LOG_ENTRY_MAX_LENGTH);
-            String messageChunk = message.substring(0, chunkLength);
-            Log.println(logLevel, tag, messageChunk);
-
-            if (nextNewLineIndex != -1 && nextNewLineIndex == chunkLength) {
-                // Don't print out the \n twice.
-                message = message.substring(chunkLength + 1);
-            } else {
-                message = message.substring(chunkLength);
-            }
-        }
-    }
-
-    @Override
-    public void v(String message) {
-        log(RealmLog.VERBOSE, message, null);
-    }
-
-    @Override
-    public void v(String message, Throwable t) {
-        log(RealmLog.VERBOSE, message, t);
-    }
-
-    @Override
-    public void d(String message) {
-        log(RealmLog.DEBUG, message, null);
-    }
-
-    @Override
-    public void d(String message, Throwable t) {
-        log(RealmLog.DEBUG, message, t);
-    }
-
-    @Override
-    public void i(String message) {
-        log(RealmLog.INFO, message, null);
-    }
-
-    @Override
-    public void i(String message, Throwable t) {
-        log(RealmLog.INFO, message, t);
-    }
-
-    @Override
-    public void w(String message) {
-        log(RealmLog.WARN, message, null);
-    }
-
-    @Override
-    public void w(String message, Throwable t) {
-        log(RealmLog.WARN, message, t);
-    }
-
-    @Override
-    public void e(String message) {
-        log(RealmLog.ERROR, message, null);
-    }
-
-    @Override
-    public void e(String message, Throwable t) {
-        log(RealmLog.ERROR, message, t);
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
index a7be9d941b..b711d45de9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -16,8 +16,6 @@
 
 package io.realm.internal.async;
 
-import android.os.Handler;
-
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
@@ -26,17 +24,25 @@
 import io.realm.RealmConfiguration;
 import io.realm.RealmModel;
 import io.realm.RealmResults;
-import io.realm.internal.HandlerControllerConstants;
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * Manages the update of async queries.
  */
 public class QueryUpdateTask implements Runnable {
+
+    public enum NotifyEvent {
+        COMPLETE_ASYNC_RESULTS,
+        COMPLETE_ASYNC_OBJECT,
+        COMPLETE_UPDATE_ASYNC_QUERIES,
+        THROW_BACKGROUND_EXCEPTION,
+    }
+
     // true if updating RealmResults, false if updating RealmObject, can't mix both
     // the builder pattern will prevent this.
     private final static int MODE_UPDATE_REALM_RESULTS = 0;
@@ -46,21 +52,21 @@
     private RealmConfiguration realmConfiguration;
     private List<Builder.QueryEntry> realmResultsEntries;
     private Builder.QueryEntry realmObjectEntry;
-    private WeakReference<Handler> callerHandler;
-    private int message;
+    private WeakReference<RealmNotifier> callerNotifier;
+    private NotifyEvent event;
 
     private QueryUpdateTask (int mode,
                              RealmConfiguration realmConfiguration,
                              List<Builder.QueryEntry> listOfRealmResults,
                              Builder.QueryEntry realmObject,
-                             WeakReference<Handler> handler,
-                             int message) {
+                             WeakReference<RealmNotifier> notifier,
+                             NotifyEvent event) {
         this.updateMode = mode;
         this.realmConfiguration = realmConfiguration;
         this.realmResultsEntries = listOfRealmResults;
         this.realmObjectEntry = realmObject;
-        this.callerHandler = handler;
-        this.message = message;
+        this.callerNotifier = notifier;
+        this.event = event;
     }
 
     public static Builder.RealmConfigurationStep newBuilder() {
@@ -69,53 +75,62 @@ private QueryUpdateTask (int mode,
 
     @Override
     public void run() {
-        SharedGroup sharedGroup = null;
+        SharedRealm sharedRealm = null;
         try {
-            sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                    SharedGroup.IMPLICIT_TRANSACTION,
-                    realmConfiguration.getDurability(),
-                    realmConfiguration.getEncryptionKey());
+            sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
             Result result;
             boolean updateSuccessful;
             if (updateMode == MODE_UPDATE_REALM_RESULTS) {
                 result = Result.newRealmResultsResponse();
                 AlignedQueriesParameters alignedParameters = prepareQueriesParameters();
-                long[] handoverTableViewPointer = TableQuery.nativeBatchUpdateQueries(sharedGroup.getNativePointer(),
+                long[] handoverTableViewPointer = TableQuery.batchUpdateQueries(sharedRealm,
                         alignedParameters.handoverQueries,
                         alignedParameters.queriesParameters,
                         alignedParameters.multiSortColumnIndices,
                         alignedParameters.multiSortOrder);
                 swapPointers(result, handoverTableViewPointer);
                 updateSuccessful = true;
-                result.versionID = sharedGroup.getVersion();
+                result.versionID = sharedRealm.getVersionID();
 
             } else {
                 result = Result.newRealmObjectResponse();
-                updateSuccessful = updateRealmObjectQuery(sharedGroup, result);
-                result.versionID = sharedGroup.getVersion();
+                updateSuccessful = updateRealmObjectQuery(sharedRealm, result);
+                result.versionID = sharedRealm.getVersionID();
             }
 
-            Handler handler = callerHandler.get();
-            if (updateSuccessful && !isTaskCancelled() && isAliveHandler(handler)) {
-                handler.obtainMessage(message, result).sendToTarget();
+            RealmNotifier notifier = callerNotifier.get();
+            if (updateSuccessful && !isTaskCancelled() && notifier != null) {
+                switch (event) {
+                    case COMPLETE_ASYNC_RESULTS:
+                        notifier.completeAsyncResults(result);
+                        break;
+                    case COMPLETE_ASYNC_OBJECT:
+                        notifier.completeAsyncObject(result);
+                        break;
+                    case COMPLETE_UPDATE_ASYNC_QUERIES:
+                        notifier.completeUpdateAsyncQueries(result);
+                        break;
+                    default:
+                        throw new IllegalStateException(String.format("%s is not handled here.", event));
+                }
             }
 
         } catch (BadVersionException e) {
             // In some rare race conditions, this can happen. In that case, just ignore the error.
-            RealmLog.d("Query update task could not complete due to a BadVersionException. " +
+            RealmLog.debug("Query update task could not complete due to a BadVersionException. " +
                     "Retry is scheduled by a REALM_CHANGED event.");
 
         } catch (Throwable e) {
-            RealmLog.e(e.getMessage(), e);
-            Handler handler = callerHandler.get();
-            if (handler != null && handler.getLooper().getThread().isAlive()) {
-                handler.obtainMessage(HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e)).sendToTarget();
+            RealmLog.error(e);
+            RealmNotifier notifier = callerNotifier.get();
+            if (notifier!= null) {
+                notifier.throwBackgroundException(e);
             }
 
         } finally {
-            if (sharedGroup != null) {
-                sharedGroup.close();
+            if (sharedRealm != null) {
+                sharedRealm.close();
             }
         }
     }
@@ -184,13 +199,12 @@ private void swapPointers(Result result, long[] handoverTableViewPointer) {
         }
     }
 
-    private boolean updateRealmObjectQuery(SharedGroup sharedGroup, Result result) {
+    private boolean updateRealmObjectQuery(SharedRealm sharedRealm, Result result) {
         if (!isTaskCancelled()) {
             switch (realmObjectEntry.queryArguments.type) {
                 case ArgumentsHolder.TYPE_FIND_FIRST: {
-                    long handoverRowPointer = TableQuery.
-                            nativeFindWithHandover(sharedGroup.getNativePointer(),
-                                    realmObjectEntry.handoverQueryPointer, 0);
+                    long handoverRowPointer = TableQuery.findWithHandover(sharedRealm,
+                                    realmObjectEntry.handoverQueryPointer);
                     result.updatedRow.put(realmObjectEntry.element, handoverRowPointer);
                     break;
                 }
@@ -209,15 +223,11 @@ private boolean isTaskCancelled() {
         return Thread.currentThread().isInterrupted();
     }
 
-    private boolean isAliveHandler(Handler handler) {
-        return handler != null && handler.getLooper().getThread().isAlive();
-    }
-
     // result of the async query
     public static class Result {
         public IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long> updatedTableViews;
         public IdentityHashMap<WeakReference<RealmObjectProxy>, Long> updatedRow;
-        public SharedGroup.VersionID versionID;
+        public SharedRealm.VersionID versionID;
 
         public static Result newRealmResultsResponse() {
             Result result = new Result();
@@ -245,13 +255,13 @@ public static Result newRealmObjectResponse() {
          .realmConfiguration(null, null)
          .add(null, 0, null)
          .add(null, 0, null)
-         .sendToHandler(null, 0)
+         .sendToNotifier(null, 0)
          .build();
 
      QueryUpdateTask task2 = QueryUpdateTask.newBuilder()
          .realmConfiguration(null, null)
          .addObject(null, 0, null)
-         .sendToHandler(null, 0)
+         .sendToNotifier(null, 0)
          .build();
      */
     public static class Builder {
@@ -272,11 +282,11 @@ HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
             RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weakReference,
                                           long handoverQueryPointer,
                                           ArgumentsHolder queryArguments);
-            BuilderStep sendToHandler(Handler handler, int message);
+            BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event);
         }
 
         public interface HandlerStep {
-            BuilderStep sendToHandler (Handler handler, int message);
+            BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event);
         }
 
         public interface BuilderStep {
@@ -287,8 +297,8 @@ RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weak
             private RealmConfiguration realmConfiguration;
             private List<QueryEntry> realmResultsEntries;
             private QueryEntry realmObjectEntry;
-            private WeakReference<Handler> callerHandler;
-            private int message;
+            private WeakReference<RealmNotifier> callerNotifier;
+            private NotifyEvent event;
 
             @Override
             public UpdateQueryStep realmConfiguration(RealmConfiguration realmConfiguration) {
@@ -317,9 +327,9 @@ public HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
             }
 
             @Override
-            public BuilderStep sendToHandler(Handler handler, int message) {
-                this.callerHandler = new WeakReference<Handler>(handler);
-                this.message = message;
+            public BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event) {
+                this.callerNotifier = new WeakReference<RealmNotifier>(notifier);
+                this.event = event;
                 return this;
             }
 
@@ -330,8 +340,8 @@ public QueryUpdateTask build() {
                         realmConfiguration,
                         realmResultsEntries,
                         realmObjectEntry,
-                        callerHandler,
-                        message);
+                        callerNotifier,
+                        event);
             }
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
new file mode 100644
index 0000000000..d523c9ae28
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmAsyncTaskImpl.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import io.realm.RealmAsyncTask;
+
+public final class RealmAsyncTaskImpl implements RealmAsyncTask {
+    private final Future<?> pendingTask;
+    private final ThreadPoolExecutor service;
+    private volatile boolean isCancelled = false;
+
+    public RealmAsyncTaskImpl(Future<?> pendingTask, ThreadPoolExecutor service) {
+        this.pendingTask = pendingTask;
+        this.service = service;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void cancel() {
+        pendingTask.cancel(true);
+        isCancelled = true;
+
+        // From "Java Threads": By Scott Oaks & Henry Wong
+        // cancelled tasks are never executed, but may
+        // accumulate in work queues, which may causes a memory leak
+        // if the task hold references (to an enclosing class for example)
+        // we can use purge() but one caveat applies: if a second thread attempts to add
+        // something to the pool (using the execute() method) at the same time the
+        // first thread is attempting to purge the queue the attempt to purge
+        // the queue fails and the cancelled object remain in the queue.
+        // A better way to cancel objects with thread pools is to use the remove()
+        service.getQueue().remove(pendingTask);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isCancelled() {
+        return isCancelled;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 482cbdc1b6..7f251618a2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -92,6 +92,16 @@ private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
         return super.submit(new BgPriorityCallable<T>(task));
     }
 
+    /**
+     * Submits a runnable for executing a network request.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public Future<?> submitNetworkRequest(Runnable task) {
+        return super.submit(new BgPriorityRunnable(task));
+    }
+
     /**
      * Method invoked prior to executing the given Runnable to pause execution of the thread.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
deleted file mode 100644
index 5c1ef9f3d4..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.log;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-/**
- * Logger implementation for Realm. This can be used to transparently change logging behavior between Android and Java.
- *
- * This class supports adding multiple logger implementations.
- */
-public final class RealmLog {
-
-    // Log levels
-    public static final int VERBOSE = 2;
-    public static final int DEBUG = 3;
-    public static final int INFO = 4;
-    public static final int WARN = 5;
-    public static final int ERROR = 6;
-    public static final int ASSERT = 7;
-    public static final int NONE = 8;
-
-    private static final List<Logger> LOGGERS = new CopyOnWriteArrayList<Logger>();
-
-    /**
-     * Adds a logger implementation.
-     *
-     * @param logger the reference to a {@link Logger} implementation.
-     */
-    public static void add(Logger logger) {
-        if (logger == null) {
-            throw new IllegalArgumentException("A non-null logger has to be provided");
-        }
-        LOGGERS.add(logger);
-    }
-
-    /**
-     * Removes a current logger implementation.
-     *
-     * @param logger.
-     */
-    public static void remove(Logger logger) {
-        if (logger == null) {
-            throw new IllegalArgumentException("A non-null logger has to be provided");
-        }
-        LOGGERS.remove(logger);
-    }
-
-    public static void v(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).v(message);
-        }
-    }
-
-    public static void v(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).v(message, t);
-        }
-    }
-
-    public static void d(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).d(message);
-        }
-    }
-
-    public static void d(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).d(message, t);
-        }
-    }
-
-    public static void i(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).i(message);
-        }
-    }
-
-    public static void i(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).i(message, t);
-        }
-    }
-
-    public static void w(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).w(message);
-        }
-    }
-
-    public static void w(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).w(message, null);
-        }
-    }
-
-    public static void e(String message)  {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).e(message);
-        }
-    }
-
-    public static void e(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).v(message, t);
-        }
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 662f8f732f..0800ae230b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -31,10 +31,13 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.Util;
 
@@ -58,15 +61,22 @@ public CompositeMediator(RealmProxyMediator... mediators) {
     }
 
     @Override
-    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.createTable(clazz, transaction);
+        return mediator.createRealmObjectSchema(clazz, schema);
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.validateTable(clazz, transaction);
+        return mediator.createTable(clazz, sharedRealm);
+    }
+
+    @Override
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
+                                    boolean allowExtraColumns) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.validateTable(clazz, sharedRealm, allowExtraColumns);
     }
 
     @Override
@@ -82,9 +92,14 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz,
+                                                Object baseRealm,
+                                                Row row,
+                                                ColumnInfo columnInfo,
+                                                boolean acceptDefaultValue,
+                                                List<String> excludeFields) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.newInstance(clazz, columnInfo);
+        return mediator.newInstance(clazz, baseRealm, row, columnInfo, acceptDefaultValue, excludeFields);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index 8d233a3e91..3374d337be 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -31,10 +31,13 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.Util;
 
@@ -73,15 +76,21 @@ public RealmProxyMediator getOriginalMediator() {
     }
 
     @Override
-    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
         checkSchemaHasClass(clazz);
-        return originalMediator.createTable(clazz, transaction);
+        return originalMediator.createRealmObjectSchema(clazz, schema);
+    }
+    @Override
+    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.createTable(clazz, sharedRealm);
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
+                                    boolean allowExtraColumns) {
         checkSchemaHasClass(clazz);
-        return originalMediator.validateTable(clazz, transaction);
+        return originalMediator.validateTable(clazz, sharedRealm, allowExtraColumns);
     }
 
     @Override
@@ -97,9 +106,14 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz,
+                                                Object baseRealm,
+                                                Row row,
+                                                ColumnInfo columnInfo,
+                                                boolean acceptDefaultValue,
+                                                List<String> excludeFields) {
         checkSchemaHasClass(clazz);
-        return originalMediator.newInstance(clazz, columnInfo);
+        return originalMediator.newInstance(clazz, baseRealm, row, columnInfo, acceptDefaultValue, excludeFields);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
new file mode 100644
index 0000000000..d39f536486
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+import android.util.Log;
+
+import static android.util.Log.getStackTraceString;
+
+/**
+ * Logger implementation outputting to Android LogCat.
+ * Androids {@link Log}levels are mapped to Realm {@link LogLevel}s using the following table:
+ *
+ * <table summary="Comparison of Realm and Android log levels">
+ * <tr>
+ *     <td>{@link LogLevel#ALL}</td><td>{@link Log#VERBOSE}</td>
+ *     <td>{@link LogLevel#TRACE}</td><td>{@link Log#VERBOSE}</td>
+ *     <td>{@link LogLevel#DEBUG}</td><td>{@link Log#DEBUG}</td>
+ *     <td>{@link LogLevel#INFO}</td><td>{@link Log#INFO}</td>
+ *     <td>{@link LogLevel#WARN}</td><td>{@link Log#WARN}</td>
+ *     <td>{@link LogLevel#ERROR}</td><td>{@link Log#ERROR}</td>
+ *     <td>{@link LogLevel#FATAL}</td><td>{@link Log#ERROR}</td>
+ *     <td>{@link LogLevel#OFF}</td><td>Not supported. Remove the logger instead.</td>
+ * </tr>
+ * </table>
+ *
+ * @deprecated The new {@link RealmLogger} for Android is implemented in native code. This class will be removed in a
+ * future release.
+ */
+public class AndroidLogger implements Logger {
+
+    private static final int LOG_ENTRY_MAX_LENGTH = 4000;
+    private final int minimumLogLevel;
+    private volatile String logTag = "REALM";
+
+    /**
+     * Creates an logger that outputs to logcat.
+     *
+     * @param androidLogLevel Android log level
+     */
+    public AndroidLogger(int androidLogLevel) {
+        if (androidLogLevel < Log.VERBOSE || androidLogLevel > Log.ASSERT) {
+            throw new IllegalArgumentException("Unknown android log level: " + androidLogLevel);
+        }
+        minimumLogLevel = androidLogLevel;
+    }
+
+    /**
+     * Sets the logging tag used when outputting to LogCat. The default value is "REALM".
+     *
+     * @param tag Logging tag to use for all subsequent logging calls.
+     */
+    public void setTag(String tag) {
+        logTag = tag;
+    }
+
+    @Override
+    public int getMinimumNativeDebugLevel() {
+        // Map Android log level to Realms log levels
+        switch (minimumLogLevel) {
+            case Log.VERBOSE:   return LogLevel.TRACE;
+            case Log.DEBUG:     return LogLevel.DEBUG;
+            case Log.INFO:      return LogLevel.INFO;
+            case Log.WARN:      return LogLevel.WARN;
+            case Log.ERROR:     return LogLevel.ERROR;
+            case Log.ASSERT:    return LogLevel.FATAL;
+            default:
+                throw new IllegalStateException("Unknown log level: " + minimumLogLevel);
+        }
+    }
+
+    // Inspired by https://github.com/JakeWharton/timber/blob/master/timber/src/main/java/timber/log/Timber.java
+    private void log(int androidLogLevel, Throwable t, String message, Object... args) {
+        if (androidLogLevel < minimumLogLevel) {
+            return;
+        }
+        if (message == null) {
+            if (t == null) {
+                return; // Ignore event if message is null and there's no throwable.
+            }
+            message = getStackTraceString(t);
+        } else {
+            if (args != null && args.length > 0) {
+                message = String.format(message, args);
+            }
+            if (t != null) {
+                message += "\n" + getStackTraceString(t);
+            }
+        }
+
+        // Message fit one line. Just print and exit
+        if (message.length() < LOG_ENTRY_MAX_LENGTH) {
+            Log.println(androidLogLevel, logTag, message);
+            return;
+        }
+
+        // Message does not fit one line.
+        // Split by line, then ensure each line can fit into Log's maximum length.
+        for (int i = 0, length = message.length(); i < length; i++) {
+            int newline = message.indexOf('\n', i);
+            newline = newline != -1 ? newline : length;
+            do {
+                int end = Math.min(newline, i + LOG_ENTRY_MAX_LENGTH);
+                String part = message.substring(i, end);
+                Log.println(androidLogLevel, logTag, part);
+                i = end;
+            } while (i < newline);
+        }
+    }
+
+    @Override
+    public void trace(Throwable throwable, String message, Object... args) {
+        log(Log.VERBOSE, throwable, message, args);
+    }
+
+    @Override
+    public void debug(Throwable throwable, String message, Object... args) {
+        log(Log.DEBUG, throwable, message, args);
+    }
+
+    @Override
+    public void info(Throwable throwable, String message, Object... args) {
+        log(Log.INFO, throwable, message, args);
+    }
+
+    @Override
+    public void warn(Throwable throwable, String message, Object... args) {
+        log(Log.WARN, throwable, message, args);
+    }
+
+    @Override
+    public void error(Throwable throwable, String message, Object... args) {
+        log(Log.ERROR, throwable, message, args);
+    }
+
+    @Override
+    public void fatal(Throwable throwable, String message, Object... args) {
+        log(Log.ASSERT, throwable, message, args);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/log/LogLevel.java b/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
new file mode 100644
index 0000000000..2811a67b93
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+/**
+ * The Log levels defined and used by Realm when logging events in the API.
+ *
+ * Realm uses the log levels defined by Log4J:
+ * https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html
+ *
+ * @see RealmLog#add(RealmLogger)
+ */
+public class LogLevel {
+
+    /**
+     * The ALL has the lowest possible rank and is intended to turn on all logging.
+     */
+    public static final int ALL = 1;
+
+    /**
+     * The TRACE level designates finer-grained informational events than DEBUG.
+     */
+    public static final int TRACE = 2;
+
+    /**
+     * The DEBUG level designates fine-grained informational events that are mostly useful to debug an application.
+     */
+    public static final int DEBUG = 3;
+
+    /**
+     * The INFO level designates informational messages that highlight the progress of the application at
+     * coarse-grained level.
+     */
+    public static final int INFO = 4;
+
+    /**
+     * The WARN level designates potentially harmful situations.
+     */
+    public static final int WARN = 5;
+
+    /**
+     * The ERROR level designates error events that might still allow the application to continue running.
+     */
+    public static final int ERROR = 6;
+
+    /**
+     * The FATAL level designates very severe error events that will presumably lead the application to abort.
+     */
+    public static final int FATAL = 7;
+
+    /**
+     * The OFF has the highest possible rank and is intended to turn off logging.
+     */
+    public static final int OFF = 8;
+}
+
+
diff --git a/realm/realm-library/src/main/java/io/realm/log/Logger.java b/realm/realm-library/src/main/java/io/realm/log/Logger.java
new file mode 100644
index 0000000000..6e36fed33f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/Logger.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+/**
+ * Interface for custom loggers that can be registered at {@link RealmLog#add(Logger)}.
+ * The different log levels are described in {@link LogLevel}.
+ * @deprecated Use {@link RealmLogger} instead.
+ */
+public interface Logger {
+
+    /**
+     * Defines which {@link LogLevel} events this logger cares about from the native components.
+     * <p>
+     * If multiple loggers are registered, the minimum value among all loggers is used.
+     * <p>
+     * Note that sending log events from the native layer is relatively expensive, so only set this value to events
+     * that are truly useful.
+     *
+     * @return the minimum {@link LogLevel} native events this logger cares about.
+     */
+    int getMinimumNativeDebugLevel();
+
+    /**
+     * Handles a {@link LogLevel#TRACE} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void trace(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles a {@link LogLevel#DEBUG} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void debug(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles an {@link LogLevel#INFO} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void info(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles a {@link LogLevel#WARN} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void warn(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles an {@link LogLevel#ERROR} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void error(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles a {@link LogLevel#FATAL} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void fatal(Throwable throwable, String message, Object... args);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
new file mode 100644
index 0000000000..e16d1be4b6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -0,0 +1,381 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+import android.util.Log;
+
+import java.util.IdentityHashMap;
+import java.util.Map;
+
+/**
+ * Global logger used by all Realm components.
+ * Custom loggers can be added by registering classes implementing {@link RealmLogger}.
+ */
+public final class RealmLog {
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private static String REALM_JAVA_TAG = "REALM_JAVA";
+
+    /**
+     * To convert the old {@link Logger} to the new {@link RealmLogger}.
+     */
+    private static class LoggerAdapter implements RealmLogger {
+        private Logger logger;
+        private static final Map<Logger, LoggerAdapter> loggerMap = new IdentityHashMap<Logger, LoggerAdapter>();
+
+        LoggerAdapter(Logger logger) {
+            this.logger = logger;
+            if (loggerMap.containsKey(logger)) {
+                throw new IllegalStateException(String.format("Logger %s exists in the map!", logger.toString()));
+            }
+            loggerMap.put(logger, this);
+        }
+
+        static RealmLogger removeLogger(Logger logger) {
+            return loggerMap.remove(logger);
+        }
+
+        static void clear() {
+            loggerMap.clear();
+        }
+
+        @Override
+        public void log(int level, String tag, Throwable throwable, String message) {
+            switch (level) {
+                case LogLevel.TRACE:
+                    logger.trace(throwable, message);
+                    break;
+                case LogLevel.INFO:
+                    logger.info(throwable, message);
+                    break;
+                case LogLevel.DEBUG:
+                    logger.debug(throwable, message);
+                    break;
+                case LogLevel.WARN:
+                    logger.warn(throwable, message);
+                    break;
+                case LogLevel.ERROR:
+                    logger.error(throwable, message);
+                    break;
+                case LogLevel.FATAL:
+                    logger.fatal(throwable, message);
+                    break;
+                default:
+                    throw new IllegalArgumentException("Level: " + level + " cannot be logged.");
+            }
+        }
+    }
+
+    /**
+     * Adds a logger implementation that will be notified on log events.
+     *
+     * @param logger the reference to a {@link RealmLogger} implementation.
+     */
+    public static void add(RealmLogger logger) {
+        if (logger == null) {
+            throw new IllegalArgumentException("A non-null logger has to be provided");
+        }
+        nativeAddLogger(logger);
+    }
+
+    /**
+     * Adds a logger implementation that will be notified on log events.
+     *
+     * @param logger the reference to a {@link Logger} implementation.
+     * @deprecated use {@link #add(RealmLogger)} instead.
+     */
+    public static void add(Logger logger) {
+        synchronized (LoggerAdapter.class) {
+            add(new LoggerAdapter(logger));
+        }
+    }
+
+    /**
+     * Sets the current {@link LogLevel}. Setting this will affect all registered loggers.
+     *
+     * @param level see {@link LogLevel}.
+     */
+    public static void setLevel(int level) {
+        nativeSetLogLevel(level);
+    }
+
+    /**
+     * Get the current {@link LogLevel}.
+     *
+     * @return the current {@link LogLevel}.
+     */
+    public static int getLevel() {
+        return nativeGetLogLevel();
+    }
+
+    /**
+     * Removes the given logger if it is currently added.
+     *
+     * @return {@code true} if the logger was removed, {@code false} otherwise.
+     */
+    public static boolean remove(RealmLogger logger) {
+        if (logger == null) {
+            throw new IllegalArgumentException("A non-null logger has to be provided");
+        }
+        nativeRemoveLogger(logger);
+        return true;
+    }
+
+    /**
+     * Removes the given logger if it is currently added.
+     *
+     * @return {@code true} if the logger was removed, {@code false} otherwise.
+     * @deprecated use {@link #remove(RealmLogger)} instead.
+     */
+    public static boolean remove(Logger logger) {
+        synchronized (LoggerAdapter.class) {
+            if (logger == null) {
+                throw new IllegalArgumentException("A non-null logger has to be provided");
+            }
+            RealmLogger adaptor = LoggerAdapter.removeLogger(logger);
+            if (adaptor != null) {
+                nativeRemoveLogger(adaptor);
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Removes all loggers. The default native logger will be removed as well. Use {@link #registerDefaultLogger()} to
+     * add it back.
+     */
+    public static void clear() {
+        synchronized (LoggerAdapter.class) {
+            nativeClearLoggers();
+            LoggerAdapter.clear();
+        }
+    }
+
+    /**
+     * Adds default native logger if it has been removed before. If the default logger has been registered already,
+     * it won't be added again. The default logger on Android will log to logcat.
+     */
+    public static void registerDefaultLogger() {
+        nativeRegisterDefaultLogger();
+    }
+
+    /**
+     * Logs a {@link LogLevel#TRACE} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void trace(Throwable throwable) {
+        trace(throwable, null);
+    }
+
+    /**
+     * Logs a {@link LogLevel#TRACE} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void trace(String message, Object... args) {
+        trace(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#TRACE} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void trace(Throwable throwable, String message, Object... args) {
+        log(LogLevel.TRACE, throwable, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#DEBUG} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void debug(Throwable throwable) {
+        debug(throwable, null);
+    }
+
+    /**
+     * Logs a {@link LogLevel#DEBUG} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void debug(String message, Object... args) {
+        debug(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#DEBUG} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void debug(Throwable throwable, String message, Object... args) {
+        log(LogLevel.DEBUG, throwable, message, args);
+    }
+
+    /**
+     * Logs an {@link LogLevel#INFO} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void info(Throwable throwable) {
+        info(throwable, null);
+    }
+
+    /**
+     * Logs an {@link LogLevel#INFO} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void info(String message, Object... args) {
+        info(null, message, args);
+    }
+
+    /**
+     * Logs an {@link LogLevel#INFO} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void info(Throwable throwable, String message, Object... args) {
+        log(LogLevel.INFO, throwable, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#WARN} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void warn(Throwable throwable) {
+        warn(throwable, null);
+    }
+
+    /**
+     * Logs a {@link LogLevel#WARN} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void warn(String message, Object... args) {
+        warn(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#WARN} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void warn(Throwable throwable, String message, Object... args) {
+        log(LogLevel.WARN, throwable, message, args);
+    }
+
+    /**
+     * Logs an {@link LogLevel#ERROR} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void error(Throwable throwable) {
+        error(throwable, null);
+    }
+
+    /**
+     * Logs an {@link LogLevel#ERROR} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void error(String message, Object... args) {
+        error(null, message, args);
+    }
+
+    /**
+     * Logs an {@link LogLevel#ERROR} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void error(Throwable throwable, String message, Object... args) {
+        log(LogLevel.ERROR, throwable, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#FATAL} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void fatal(Throwable throwable) {
+        fatal(throwable, null);
+    }
+
+    /**
+     * Logs an {@link LogLevel#FATAL} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void fatal(String message, Object... args) {
+        fatal(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#FATAL} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void fatal(Throwable throwable, String message, Object... args) {
+        log(LogLevel.FATAL, throwable, message, args);
+    }
+
+    // Format the message, parse the stacktrace of given throwable and pass them to nativeLog.
+    private static void log(int level, Throwable throwable, String message, Object... args) {
+        StringBuilder stringBuilder = new StringBuilder();
+        if (args != null && args.length > 0) {
+            message = String.format(message, args);
+        }
+        if (throwable != null) {
+            stringBuilder.append(Log.getStackTraceString(throwable));
+        }
+        if (message != null) {
+            if (throwable != null) {
+                stringBuilder.append("\n");
+            }
+            stringBuilder.append(message);
+        }
+        nativeLog(level,REALM_JAVA_TAG, throwable, stringBuilder.toString());
+    }
+
+    private static native void nativeAddLogger(RealmLogger logger);
+    private static native void nativeRemoveLogger(RealmLogger logger);
+    private static native void nativeClearLoggers();
+    private static native void nativeRegisterDefaultLogger();
+    private static native void nativeLog(int level, String tag, Throwable throwable, String message);
+    private static native void nativeSetLogLevel(int level);
+    private static native int nativeGetLogLevel();
+}
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java b/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
new file mode 100644
index 0000000000..5c7b0e4f08
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+import io.realm.internal.Keep;
+
+/**
+ * Interface for custom loggers that can be registered at {@link RealmLog#add(RealmLogger)}.
+ * The different log levels are described in {@link LogLevel}.
+ */
+@Keep // This interface is used as a parameter type of a native method in SharedRealm.java
+public interface RealmLogger {
+
+    /**
+     * Handles a log event.
+     *
+     * @param level for this log event. It can only be a value between {@link LogLevel#TRACE} and
+     * {@link LogLevel#FATAL}
+     * @param tag for this log event.
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     */
+    void log(int level, String tag, Throwable throwable, String message);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 285388bbc8..7c89ecd45a 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -322,10 +322,12 @@ public void releaseReference(K object) {
             Integer count = references.get(object);
             if (count == null) {
                 throw new IllegalStateException("Object does not have any references: " + object);
-            } else if (count > 0) {
+            } else if (count > 1) {
                 references.put(object, count - 1);
-            } else {
+            } else if (count == 1) {
                 references.remove(object);
+            } else {
+                throw new IllegalStateException("Invalid reference count: " + count);
             }
         }
     }
diff --git a/realm/realm-library/src/objectServer/AndroidManifest.xml b/realm/realm-library/src/objectServer/AndroidManifest.xml
new file mode 100644
index 0000000000..0a7a9b5299
--- /dev/null
+++ b/realm/realm-library/src/objectServer/AndroidManifest.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm" >
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <uses-permission android:name="android.permission.INTERNET" />
+
+</manifest>
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/IncompatibleLockFileException.java b/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
similarity index 52%
rename from realm/realm-library/src/main/java/io/realm/exceptions/IncompatibleLockFileException.java
rename to realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
index d1135bef12..c769a7d693 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/IncompatibleLockFileException.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/AuthenticationListener.java
@@ -14,22 +14,27 @@
  * limitations under the License.
  */
 
-package io.realm.exceptions;
+package io.realm;
 
-import io.realm.internal.Keep;
+import io.realm.annotations.Beta;
 
 /**
- * Triggered from the JNI level when there was something wrong with the lock file.
- * This can happen if two different versions of Realm tries to access the same file concurrently.
+ * @Beta
+ * Interface describing events related to Users and their authentication
  */
-@Keep
-public class IncompatibleLockFileException extends RealmIOException {
+@Beta
+public interface AuthenticationListener {
+    /**
+     * A user was logged into the Object Server
+     *
+     * @param user {@link SyncUser} that is now logged in.
+     */
+    void loggedIn(SyncUser user);
 
-    public IncompatibleLockFileException(String detailMessage) {
-        super(detailMessage);
-    }
-
-    public IncompatibleLockFileException(String detailMessage, Throwable exception) {
-        super(detailMessage, exception);
-    }
+    /**
+     * A user was successfully logged out from the Object Server.
+     *
+     * @param user {@link SyncUser} that was successfully logged out.
+     */
+    void loggedOut(SyncUser user);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
new file mode 100644
index 0000000000..17e0365396
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * This class enumerate all potential errors related to using the Object Server or synchronizing data.
+ */
+@Beta
+public enum ErrorCode {
+
+    // See https://github.com/realm/realm-sync/blob/master/doc/protocol.md
+
+    // Realm Java errors (0-49)
+    UNKNOWN(-1),                                // Catch-all
+    IO_EXCEPTION(0, Category.RECOVERABLE),      // Some IO error while either contacting the server or reading the response
+    JSON_EXCEPTION(1),                          // JSON input could not be parsed correctly
+
+    // Realm Object Server errors (100 - 199)
+    // Connection level and protocol errors.
+    CONNECTION_CLOSED(100),          // Connection closed (no error)
+    OTHER_ERROR(101),                // Other connection level error
+    UNKNOWN_MESSAGE(102),            // Unknown type of input message
+    BAD_SYNTAX(103),                 // Bad syntax in input message head
+    LIMITS_EXCEEDED(104),            // Limits exceeded in input message
+    WRONG_PROTOCOL_VERSION(105),     // Wrong protocol version (CLIENT)
+    BAD_SESSION_IDENT(106),          // Bad session identifier in input message
+    REUSE_OF_SESSION_IDENT(107),     // Overlapping reuse of session identifier (BIND)
+    BOUND_IN_OTHER_SESSION(108),     // Client file bound in other session (IDENT)
+    BAD_MESSAGE_ORDER(109),          // Bad input message order
+
+    // Session level errors (200 - 299)
+    SESSION_CLOSED(200, Category.RECOVERABLE),      // Session closed (no error)
+    OTHER_SESSION_ERROR(201, Category.RECOVERABLE), // Other session level error
+    TOKEN_EXPIRED(202, Category.RECOVERABLE),       // Access token expired
+
+    // Session fatal: Auth wrong. Cannot be fixed without a new User/SyncConfiguration.
+    BAD_AUTHENTICATION(203),                        // Bad user authentication (BIND, REFRESH)
+    ILLEGAL_REALM_PATH(204),                        // Illegal Realm path (BIND)
+    NO_SUCH_PATH(205),                              // No such Realm (BIND)
+    PERMISSION_DENIED(206),                         // Permission denied (BIND, REFRESH)
+
+    // Fatal: Wrong server/client versions. Trying to sync incompatible files or the file was corrupted.
+    BAD_SERVER_FILE_IDENT(207),                     // Bad server file identifier (IDENT)
+    BAD_CLIENT_FILE_IDENT(208),                     // Bad client file identifier (IDENT)
+    BAD_SERVER_VERSION(209),                        // Bad server version (IDENT, UPLOAD)
+    BAD_CLIENT_VERSION(210),                        // Bad client version (IDENT, UPLOAD)
+    DIVERGING_HISTORIES(211),                       // Diverging histories (IDENT)
+    BAD_CHANGESET(212),                             // Bad changeset (UPLOAD)
+
+    // 300 - 599 Reserved for Standard HTTP error codes
+
+    // Realm Authentication Server response errors (600 - 699)
+    INVALID_PARAMETERS(601),
+    MISSING_PARAMETERS(602),
+    INVALID_CREDENTIALS(611),
+    UNKNOWN_ACCOUNT(612),
+    EXISTING_ACCOUNT(613),
+    ACCESS_DENIED(614),
+    EXPIRED_REFRESH_TOKEN(615);
+
+    private final int code;
+    private final Category category;
+
+    ErrorCode(int errorCode) {
+        this(errorCode, Category.FATAL);
+    }
+
+    ErrorCode(int errorCode, Category category) {
+        this.code = errorCode;
+        this.category = category;
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + "(" + code + ")";
+    }
+
+    /**
+     * Returns the numerical value for this error code.
+     *
+     * @return the error code as an unique {@code int} value.
+     */
+    public int intValue() {
+        return code;
+    }
+
+    /**
+     * Returns the getCategory of the error.
+     * <p>
+     * Errors come in 2 categories: FATAL, RECOVERABLE
+     * <p>
+     * FATAL: The session cannot be recovered and needs to be re-created. A likely cause is that the User does not
+     * have access to this Realm. Check that the {@link SyncConfiguration} is correct. Any fatal error will cause
+     * the session to be become {@link SessionState#STOPPED}.
+     * <p>
+     * RECOVERABLE: Temporary error. The session becomes {@link SessionState#UNBOUND}, but will automatically try to
+     * recover as soon as possible.
+     * <p>
+     *
+     * @return the severity of the error.
+     */
+    public Category getCategory() {
+        return category;
+    }
+
+    public static ErrorCode fromInt(int errorCode) {
+        ErrorCode[] errorCodes = values();
+        for (int i = 0; i < errorCodes.length; i++) {
+            ErrorCode error = errorCodes[i];
+            if (error.intValue() == errorCode) {
+                return error;
+            }
+        }
+        throw new IllegalArgumentException("Unknown error code: " + errorCode);
+    }
+
+public enum Category {
+        FATAL,          // Abort session as soon as possible
+        RECOVERABLE    // Still possible to recover the session by either rebinding or providing the required information.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
new file mode 100644
index 0000000000..9e8abe33a4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Keep;
+
+/**
+ * @Beta
+ * Internal initializer class for the Object Server.
+ * Use to keep the `SyncManager` free from Android dependencies
+ */
+@SuppressWarnings("unused")
+@Keep
+@Beta
+class ObjectServer {
+
+    public static void init(Context context) {
+        // Setup AppID
+        String appId = "unknown";
+        try {
+            PackageInfo pi = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+            appId = pi.packageName;
+        } catch (Exception ignore) {
+        }
+
+        // Configure default UserStore
+        UserStore userStore = new RealmFileUserStore(context.getFilesDir().getPath());
+
+        SyncManager.init(appId, userStore);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
new file mode 100644
index 0000000000..56109037f8
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Util;
+
+/**
+ * @Beta
+ * This class is a wrapper for all errors happening when communicating with the Realm Object Server.
+ * This include both exceptions and protocol errors.
+ *
+ * Only {@link #getErrorCode()} is guaranteed to contain a value. If the error was caused by an underlying exception
+ * {@link #getErrorMessage()} is {@code null} and {@link #getException()} is set, while if the error was a protocol error
+ * {@link #getErrorMessage()} is set and {@link #getException()} is null.
+ *
+ * @see ErrorCode for a list of possible errors.
+ */
+@Beta
+public class ObjectServerError extends RuntimeException {
+
+    private final ErrorCode error;
+    private final String errorMessage;
+    private final Throwable exception;
+
+    /**
+     * Create an error caused by an error in the protocol when communicating with the Object Server.
+     *
+     * @param errorCode error code for this type of error.
+     * @param errorMessage detailed error message.
+     */
+    public ObjectServerError(ErrorCode errorCode, String errorMessage) {
+        this(errorCode, errorMessage, (Throwable) null);
+    }
+
+    /**
+     * Create an error caused by an an exception when communicating with the Object Server.
+     *
+     * @param errorCode error code for this type of error.
+     * @param exception underlying exception causing this error.
+     */
+    public ObjectServerError(ErrorCode errorCode, Throwable exception) {
+        this(errorCode, null, exception);
+    }
+
+    /**
+     * Generic error happening that could happen anywhere.
+     *
+     * @param errorCode error code for this type of error.
+     * @param errorMessage detailed error message.
+     * @param exception underlying exception if the error was caused by this.
+     */
+    public ObjectServerError(ErrorCode errorCode, String errorMessage, Throwable exception) {
+        this.error = errorCode;
+        this.errorMessage = errorMessage;
+        this.exception = exception;
+    }
+
+    /**
+     * Errors happening while trying to authenticate a user.
+     *
+     * @param errorCode error code for this type of error.
+     * @param title Title for this type of error.
+     * @param hint a hint for resolving the error.
+     */
+    public ObjectServerError(ErrorCode errorCode, String title, String hint) {
+        this(errorCode, (hint != null) ? title + " : " + hint : title, (Throwable) null);
+    }
+
+    /**
+     * Returns the error code uniquely identifying this type of error.
+     *
+     * @return the error code identifying the type of error.
+     * @see ErrorCode
+     */
+    public ErrorCode getErrorCode() {
+        return error;
+    }
+
+    /**
+     * Returns a more detailed error message about the cause of this error.
+     *
+     * @return a detailed error message or {@code null} if one was not available.
+     */
+    public String getErrorMessage() {
+        return errorMessage;
+    }
+
+    /**
+     * Returns the underlying exception causing this error, if any.
+     *
+     * @return the underlying exception causing this error, or {@code null} if not caused by an exception.
+     */
+    public Throwable getException() {
+        return exception;
+    }
+
+    /**
+     * Returns the {@link ErrorCode.Category} category for this error.
+     * Errors that are {@link ErrorCode.Category#RECOVERABLE} mean that it is still possible for a
+     * given {@link SyncSession} to resume synchronization. {@link ErrorCode.Category#FATAL} errors
+     * means that session has stopped and cannot be recovered.
+     *
+     * @return the error category.
+     */
+    public ErrorCode.Category getCategory() {
+        return error.getCategory();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder(getErrorCode().toString());
+        if (errorMessage != null) {
+            sb.append('\n');
+            sb.append(errorMessage);
+        }
+        if (exception != null) {
+            sb.append('\n');
+            sb.append(Util.getStackTrace(exception));
+        }
+        return sb.toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
new file mode 100644
index 0000000000..0d89455e30
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+
+/**
+ * A User Store backed by a Realm file to store user.
+ */
+public class RealmFileUserStore implements UserStore {
+    protected RealmFileUserStore(String path) {
+        nativeConfigureMetaDataSystem(path);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void put(SyncUser user) {
+        String userJson = user.toJson();
+        // create or update token (userJson) using identity
+        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SyncUser get() {
+        String userJson = nativeGetCurrentUser();
+        if (userJson != null) {
+            return SyncUser.fromJson(userJson);
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void remove() {
+        nativeLogoutCurrentUser();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Collection<SyncUser> allUsers() {
+        String[] allUsers = nativeGetAllUsers();
+        if (allUsers != null && allUsers.length > 0) {
+            ArrayList<SyncUser> users = new ArrayList<SyncUser>(allUsers.length);
+            for (String userJson : allUsers) {
+                users.add(SyncUser.fromJson(userJson));
+            }
+            return users;
+        }
+        return Collections.emptyList();
+    }
+
+    // init and load the Metadata Realm containing SyncUsers
+    protected static native void nativeConfigureMetaDataSystem(String baseFile);
+
+    // return json data (token) of the current logged in user
+    protected static native String nativeGetCurrentUser();
+
+    protected static native String[] nativeGetAllUsers();
+
+    protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
+
+    protected static native void nativeLogoutCurrentUser();
+
+    // Should only be called for tests
+    static native void nativeResetForTesting();
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SessionState.java b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
new file mode 100644
index 0000000000..9ede02c3fc
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Enum describing the various states the Session Finite-State-Machine can be in.
+ */
+@Beta
+public enum SessionState {
+    INITIAL,          // Initial starting state
+    UNBOUND,          // Start done, Realm is unbound.
+    BINDING,          // bind() has been called. Can take a while.
+    AUTHENTICATING,   // Trying to authenticate credentials. Can take a while.
+    BOUND,            // Local realm was successfully bound to the remote Realm. Changes are being synchronized.
+    STOPPED           // Terminal state. Session can no longer be used.
+}
+
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
new file mode 100644
index 0000000000..bc630cf99b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -0,0 +1,656 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+
+import java.io.File;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import io.realm.annotations.Beta;
+import io.realm.annotations.RealmModule;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.syncpolicy.AutomaticSyncPolicy;
+import io.realm.internal.syncpolicy.SyncPolicy;
+import io.realm.rx.RealmObservableFactory;
+import io.realm.rx.RxObservableFactory;
+
+/**
+ * @Beta
+ * An {@link SyncConfiguration} is used to setup a Realm that can be synchronized between devices using the Realm
+ * Object Server.
+ * <p>
+ * A valid {@link SyncUser} is required to create a {@link SyncConfiguration}. See {@link SyncCredentials} and
+ * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)} for more information on
+ * how to get a user object.
+ * <p>
+ * A minimal {@link SyncConfiguration} can be found below.
+ * <pre>
+ * {@code
+ * SyncConfiguration config = new SyncConfiguration.Builder(context)
+ *   .serverUrl("realm://objectserver.realm.io/~/default")
+ *   .user(myUser)
+ *   .build();
+ * }
+ * </pre>
+ *
+ * Synchronized Realms only support additive migrations which can be detected and performed automatically, so
+ * the following builder options are not accessible compared to a normal Realm:
+ *
+ * <ul>
+ *     <li>{@code deleteRealmIfMigrationNeeded()}</li>
+ *     <li>{@code schemaVersion(long version)}</li>
+ *     <li>{@code migration(Migration)}</li>
+ * </ul>
+ *
+ * Synchronized Realms are created by using {@link Realm#getInstance(RealmConfiguration)} and
+ * {@link Realm#getDefaultInstance()} like ordinary unsynchronized Realms.
+ */
+@Beta
+public class SyncConfiguration extends RealmConfiguration {
+
+    public static final int PORT_REALM = 80;
+    public static final int PORT_REALMS = 443;
+
+    // The FAT file system has limitations of length. Also, not all characters are permitted.
+    // https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx
+    public static final int MAX_FULL_PATH_LENGTH = 256;
+    public static final int MAX_FILE_NAME_LENGTH = 255;
+    private static final char[] INVALID_CHARS = {'<', '>', ':', '"', '/', '\\', '|', '?', '*'};
+
+    private final URI serverUrl;
+    private final SyncUser user;
+    private final SyncPolicy syncPolicy;
+    private final SyncSession.ErrorHandler errorHandler;
+    private final boolean deleteRealmOnLogout;
+
+    private SyncConfiguration(File directory,
+                                String filename,
+                                String canonicalPath,
+                                String assetFilePath,
+                                byte[] key,
+                                long schemaVersion,
+                                RealmMigration migration,
+                                boolean deleteRealmIfMigrationNeeded,
+                                SharedRealm.Durability durability,
+                                RealmProxyMediator schemaMediator,
+                                RxObservableFactory rxFactory,
+                                Realm.Transaction initialDataTransaction,
+                                SyncUser user,
+                                URI serverUrl,
+                                SyncPolicy syncPolicy,
+                                SyncSession.ErrorHandler errorHandler,
+                                boolean deleteRealmOnLogout
+    ) {
+        super(directory,
+                filename,
+                canonicalPath,
+                assetFilePath,
+                key,
+                schemaVersion,
+                migration,
+                deleteRealmIfMigrationNeeded,
+                durability,
+                schemaMediator,
+                rxFactory,
+                initialDataTransaction
+        );
+
+        this.user = user;
+        this.serverUrl = serverUrl;
+        this.syncPolicy = syncPolicy;
+        this.errorHandler = errorHandler;
+        this.deleteRealmOnLogout = deleteRealmOnLogout;
+    }
+
+    static URI resolveServerUrl(URI serverUrl, String userIdentifier) {
+        try {
+            return new URI(serverUrl.toString().replace("/~/", "/" + userIdentifier + "/"));
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not replace '/~/' with a valid user ID.", e);
+        }
+    }
+
+    // Extract the full server path, minus the file name
+    private static String getServerPath(URI serverUrl) {
+        String path = serverUrl.getPath();
+        int endIndex = path.lastIndexOf("/");
+        if (endIndex == -1 ) {
+            return path;
+        } else if (endIndex == 0) {
+            return path.substring(1);
+        } else {
+            return path.substring(1, endIndex); // Also strip leading /
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+
+        SyncConfiguration that = (SyncConfiguration) o;
+
+        if (deleteRealmOnLogout != that.deleteRealmOnLogout) return false;
+        if (!serverUrl.equals(that.serverUrl)) return false;
+        if (!user.equals(that.user)) return false;
+        if (!syncPolicy.equals(that.syncPolicy)) return false;
+        if (!errorHandler.equals(that.errorHandler)) return false;
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + serverUrl.hashCode();
+        result = 31 * result + user.hashCode();
+        result = 31 * result + (deleteRealmOnLogout ? 1 : 0);
+        result = 31 * result + syncPolicy.hashCode();
+        result = 31 * result + errorHandler.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder stringBuilder = new StringBuilder(super.toString());
+        stringBuilder.append("\n");
+        stringBuilder.append("serverUrl: " + serverUrl);
+        stringBuilder.append("\n");
+        stringBuilder.append("user: " + user);
+        stringBuilder.append("\n");
+        stringBuilder.append("syncPolicy: " + syncPolicy);
+        stringBuilder.append("\n");
+        stringBuilder.append("errorHandler: " + errorHandler);
+        stringBuilder.append("\n");
+        stringBuilder.append("deleteRealmOnLogout: " + deleteRealmOnLogout);
+        return stringBuilder.toString();
+    }
+
+    // Keeping this package protected for now. The API might still be subject to change.
+    SyncPolicy getSyncPolicy() {
+        return syncPolicy;
+    }
+
+    /**
+     * Returns the user.
+     *
+     * @return the user.
+     */
+    public SyncUser getUser() {
+        return user;
+    }
+
+    /**
+     * Returns the fully disambiguated URI for the remote Realm i.e., the {@code /~/} placeholder has been replaced
+     * by the proper user ID.
+     *
+     * @return {@link URI} identifying the remote Realm this local Realm is synchronized with.
+     */
+    public URI getServerUrl() {
+        return serverUrl;
+    }
+
+    public SyncSession.ErrorHandler getErrorHandler() {
+        return errorHandler;
+    }
+
+    /**
+     * Returns {@code true} if the Realm file must be deleted once the {@link SyncUser} owning it logs out.
+     *
+     * @return {@code true} if the Realm file must be deleted if the {@link SyncUser} logs out. {@code false} if the file
+     *         is allowed to remain behind.
+     */
+    public boolean shouldDeleteRealmOnLogout() {
+        return deleteRealmOnLogout;
+    }
+
+    @Override
+    boolean isSyncConfiguration() {
+        return true;
+    }
+
+    /**
+     * Builder used to construct instances of a SyncConfiguration in a fluent manner.
+     */
+    public static final class Builder  {
+
+        private File directory;
+        private boolean overrideDefaultFolder = false;
+        private String fileName;
+        private boolean overrideDefaultLocalFileName = false;
+        private byte[] key;
+        private HashSet<Object> modules = new HashSet<Object>();
+        private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
+        private RxObservableFactory rxFactory;
+        private Realm.Transaction initialDataTransaction;
+        private URI serverUrl;
+        private SyncUser user = null;
+        private SyncPolicy syncPolicy = new AutomaticSyncPolicy();
+        private SyncSession.ErrorHandler errorHandler = SyncManager.defaultSessionErrorHandler;
+        private File defaultFolder;
+        private String defaultLocalFileName;
+        private SharedRealm.Durability durability = SharedRealm.Durability.FULL;
+        private boolean deleteRealmOnLogout = false;
+        private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
+
+
+        /**
+         * Creates an instance of the Builder for the SyncConfiguration.
+         * <p>
+         * Opening a synchronized Realm requires a valid user and an unique URI that identifies that Realm. In URIs,
+         * {@code /~/} can be used as a placeholder for a user ID in case the Realm should only be available to one
+         * user e.g., {@code "realm://objectserver.realm.io/~/default"}.
+         * <p>
+         * The URL cannot end with {@code .realm}, {@code .realm.lock} or {@code .realm.management}.
+         * <p>
+         * The {@code /~/} will automatically be replaced with the user ID when creating the {@link SyncConfiguration}.
+         * <p>
+         * Moreover, the URI defines the local location on disk. The default location of a synchronized Realm file is
+         * {@code /data/data/<packageName>/files/realm-object-server/<user-id>/<last-path-segment>}, but this behavior
+         * can be overwritten using {@link #name(String)} and {@link #directory(File)}.
+         * <p>
+         * Many Android devices are using FAT32 file systems. FAT32 file systems have a limitation that
+         * file names cannot be longer than 255 characters. Moreover, the entire URI should not exceed 256 characters.
+         * If file name and underlying path are too long to handle for FAT32, a shorter unique name will be generated.
+         * See also @{link https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx}.
+         *
+         * @param user the user for this Realm. An authenticated {@link SyncUser} is required to open any Realm managed
+         *             by a Realm Object Server.
+         * @param uri URI identifying the Realm.
+         *
+         * @see SyncUser#isValid()
+         */
+        public Builder(SyncUser user, String uri) {
+            this(BaseRealm.applicationContext, user, uri);
+        }
+
+        Builder(Context context, SyncUser user, String url) {
+            if (context == null) {
+                throw new IllegalStateException("Call `Realm.init(Context)` before creating a SyncConfiguration");
+            }
+            this.defaultFolder = new File(context.getFilesDir(), "realm-object-server");
+            if (Realm.getDefaultModule() != null) {
+                this.modules.add(Realm.getDefaultModule());
+            }
+
+            validateAndSet(user);
+            validateAndSet(url);
+        }
+
+        private void validateAndSet(SyncUser user) {
+            if (user == null) {
+                throw new IllegalArgumentException("Non-null `user` required.");
+            }
+            if (!user.isValid()) {
+                throw new IllegalArgumentException("User not authenticated or authentication expired.");
+            }
+            this.user = user;
+        }
+
+        private void validateAndSet(String uri) {
+            if (uri == null) {
+                throw new IllegalArgumentException("Non-null 'uri' required.");
+            }
+
+            try {
+                serverUrl = new URI(uri);
+            } catch (URISyntaxException e) {
+                throw new IllegalArgumentException("Invalid URI: " + uri, e);
+            }
+
+            // scheme must be realm or realms
+            String scheme = serverUrl.getScheme();
+            if (!scheme.equals("realm") && !scheme.equals("realms")) {
+                throw new IllegalArgumentException("Invalid scheme: " + scheme);
+            }
+
+            // Detect last path segment as it is the default file name
+            String path = serverUrl.getPath();
+            if (path == null) {
+                throw new IllegalArgumentException("Invalid URI: " + uri);
+            }
+
+            String[] pathSegments = path.split("/");
+            for (int i = 1; i < pathSegments.length; i++) {
+                String segment = pathSegments[i];
+                if (segment.equals("~")) {
+                    continue;
+                }
+                if (segment.equals("..") || segment.equals(".")) {
+                    throw new IllegalArgumentException("The URI has an invalid segment: " + segment);
+                }
+                Matcher m = pattern.matcher(segment);
+                if (!m.matches()) {
+                    throw new IllegalArgumentException("The URI must only contain characters 0-9, a-z, A-Z, ., _, and -: " + segment);
+                }
+            }
+
+            this.defaultLocalFileName = pathSegments[pathSegments.length - 1];
+
+            // Validate filename
+            // TODO Lift this restriction on the Object Server
+            if (defaultLocalFileName.endsWith(".realm")
+                    || defaultLocalFileName.endsWith(".realm.lock")
+                    || defaultLocalFileName.endsWith(".realm.management")) {
+                throw new IllegalArgumentException("The URI must not end with '.realm', '.realm.lock' or '.realm.management: " + uri);
+            }
+        }
+
+        /**
+         * Sets the local file name for the Realm.
+         * This will override the default name defined by the Realm URL.
+         *
+         * @param filename name of the local file on disk.
+         * @throws IllegalArgumentException if file name is {@code null} or empty.
+         */
+        public Builder name(String filename) {
+            if (filename == null || filename.isEmpty()) {
+                throw new IllegalArgumentException("A non-empty filename must be provided");
+            }
+            this.fileName = filename;
+            this.overrideDefaultLocalFileName = true;
+            return this;
+        }
+
+        /**
+         * Sets the local root directory where synchronized Realm files can be saved.
+         * <p>
+         * Synchronized Realms will not be saved directly in the provided directory, but instead in a
+         * subfolder that matches the path defined by Realm URI. As Realm server URIs are unique
+         * this means that multiple users can save their Realms on disk without the risk of them overwriting
+         * each other files.
+         * <p>
+         * The default location is {@code context.getFilesDir()}.
+         *
+         * @param directory directory on disk where the Realm file can be saved.
+         * @throws IllegalArgumentException if the directory is not valid.
+         */
+        public Builder directory(File directory) {
+            if (directory == null) {
+                throw new IllegalArgumentException("Non-null 'directory' required.");
+            }
+            if (directory.isFile()) {
+                throw new IllegalArgumentException("'directory' is a file, not a directory: " +
+                        directory.getAbsolutePath() + ".");
+            }
+            if (!directory.exists() && !directory.mkdirs()) {
+                throw new IllegalArgumentException("Could not create the specified directory: " +
+                        directory.getAbsolutePath() + ".");
+            }
+            if (!directory.canWrite()) {
+                throw new IllegalArgumentException("Realm directory is not writable: " +
+                        directory.getAbsolutePath() + ".");
+            }
+            this.directory = directory;
+            overrideDefaultFolder = true;
+            return this;
+        }
+
+        /**
+         * Sets the {@value io.realm.RealmConfiguration#KEY_LENGTH} bytes key used to encrypt and decrypt the Realm file.
+         *
+         * @param key the encryption key.
+         * @throws IllegalArgumentException if key is invalid.
+         */
+        public Builder encryptionKey(byte[] key) {
+            if (key == null) {
+                throw new IllegalArgumentException("A non-null key must be provided");
+            }
+            if (key.length != KEY_LENGTH) {
+                throw new IllegalArgumentException(String.format("The provided key must be %s bytes. Yours was: %s",
+                        KEY_LENGTH, key.length));
+            }
+            this.key = Arrays.copyOf(key, key.length);
+            return this;
+        }
+
+        /**
+         * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
+         * current schema for this Realm with the schema defined by the provided modules.
+         * <p>
+         * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
+         * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
+         * dependency is thus done using the following code:
+         * <p>
+         * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
+         * <p>
+         * @param baseModule the first Realm module (required).
+         * @param additionalModules the additional Realm modules
+         * @throws IllegalArgumentException if any of the modules don't have the {@link RealmModule} annotation.
+         * @see Realm#getDefaultModule()
+         */
+        public Builder modules(Object baseModule, Object... additionalModules) {
+            modules.clear();
+            addModule(baseModule);
+            if (additionalModules != null) {
+                for (Object module : additionalModules) {
+                    addModule(module);
+                }
+            }
+            return this;
+        }
+
+        /**
+         * Sets the {@link RxObservableFactory} used to create Rx Observables from Realm objects.
+         * The default factory is {@link RealmObservableFactory}.
+         *
+         * @param factory factory to use.
+         */
+        public Builder rxFactory(RxObservableFactory factory) {
+            rxFactory = factory;
+            return this;
+        }
+
+        /**
+         * Sets the initial data in {@link io.realm.Realm}. This transaction will be executed only the first time
+         * the Realm file is opened (created) or while migrating the data if
+         * {@link RealmConfiguration.Builder#deleteRealmIfMigrationNeeded()} is set.
+         *
+         * @param transaction transaction to execute.
+         */
+        public Builder initialData(Realm.Transaction transaction) {
+            initialDataTransaction = transaction;
+            return this;
+        }
+
+        /**
+         * Setting this will create an in-memory Realm instead of saving it to disk. In-memory Realms might still use
+         * disk space if memory is running low, but all files created by an in-memory Realm will be deleted when the
+         * Realm is closed.
+         * <p>
+         * Note that because in-memory Realms are not persisted, you must be sure to hold on to at least one non-closed
+         * reference to the in-memory Realm object with the specific name as long as you want the data to last.
+         */
+        public Builder inMemory() {
+            this.durability = SharedRealm.Durability.MEM_ONLY;
+            return this;
+        }
+
+        /**
+         * Sets the {@link SyncPolicy} used to control when changes should be synchronized with the remote Realm.
+         * The default policy is {@link AutomaticSyncPolicy}.
+         *
+         * @param syncPolicy policy to use.
+         *
+         * @see SyncSession
+         */
+        Builder syncPolicy(SyncPolicy syncPolicy) {
+            // Package protected until SyncPolicy API is more stable.
+            this.syncPolicy = syncPolicy;
+            return this;
+        }
+
+        /**
+         * Sets the error handler used by this configuration. This will override any handler set by calling
+         * {@link SyncManager#setDefaultSessionErrorHandler(SyncSession.ErrorHandler)}.
+         * <p>
+         * Only errors not handled by the defined {@code SyncPolicy} will be reported to this error handler.
+         *
+         * @param errorHandler error handler used to report back errors when communicating with the Realm Object Server.
+         * @throws IllegalArgumentException if {@code null} is given as an error handler.
+         */
+        public Builder errorHandler(SyncSession.ErrorHandler errorHandler) {
+            if (errorHandler == null) {
+                throw new IllegalArgumentException("Non-null 'errorHandler' required.");
+            }
+            this.errorHandler = errorHandler;
+            return this;
+        }
+
+        private String MD5(String in) {
+            try {
+                MessageDigest digest = MessageDigest.getInstance("MD5");
+                byte[] buf = digest.digest(in.getBytes("UTF-8"));
+                StringBuilder builder = new StringBuilder();
+                for (byte b : buf) {
+                    builder.append(String.format("%02X", b));
+                }
+                return builder.toString();
+            } catch (NoSuchAlgorithmException e) {
+                throw new RealmException(e.getMessage());
+            } catch (UnsupportedEncodingException e) {
+                throw new RealmException(e.getMessage());
+            }
+        }
+
+        /**
+         * Setting this will cause the local Realm file used to synchronize changes to be deleted if the {@link SyncUser}
+         * owning this Realm logs out from the device using {@link SyncUser#logout()}.
+         * <p>
+         * The default behavior is that the Realm file is allowed to stay behind, making it possible for users to log
+         * in again and have access to their data faster.
+         */
+        /* FIXME: Disable this API since we cannot support it without https://github.com/realm/realm-core/issues/2165
+        public Builder deleteRealmOnLogout() {
+            this.deleteRealmOnLogout = true;
+            return this;
+        }
+        */
+
+        /**
+         * Creates the RealmConfiguration based on the builder parameters.
+         *
+         * @return the created {@link SyncConfiguration}.
+         * @throws IllegalStateException if the configuration parameters are invalid or inconsistent.
+         */
+        public SyncConfiguration build() {
+            if (serverUrl == null || user == null) {
+                throw new IllegalStateException("serverUrl() and user() are both required.");
+            }
+
+            // Check if the user has an identifier, if not, it cannot use /~/.
+            if (serverUrl.toString().contains("/~/") && user.getIdentity() == null) {
+                throw new IllegalStateException("The serverUrl contains a /~/, but the user does not have an identity." +
+                        " Most likely it hasn't been authenticated yet or has been created directly from an" +
+                        " access token. Use a path without /~/.");
+            }
+
+            if (rxFactory == null && isRxJavaAvailable()) {
+                rxFactory = new RealmObservableFactory();
+            }
+
+            // Determine location on disk
+            // Use the serverUrl + user to create a unique filepath unless it has been explicitly overridden.
+            // <rootDir>/<serverPath>/<serverFileNameOrOverriddenFileName>
+            URI resolvedServerUrl = resolveServerUrl(serverUrl, user.getIdentity());
+            File rootDir = overrideDefaultFolder ? directory : defaultFolder;
+            String realmPathFromRootDir = getServerPath(resolvedServerUrl);
+            File realmFileDirectory = new File(rootDir, realmPathFromRootDir);
+
+            String realmFileName = overrideDefaultLocalFileName ? fileName : defaultLocalFileName;
+            String fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
+            // full path must not exceed 256 characters (on FAT)
+            if (fullPathName.length() > MAX_FULL_PATH_LENGTH) {
+                // path is too long, so we make the file name shorter
+                realmFileName = MD5(realmFileName);
+                fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
+                if (fullPathName.length() > MAX_FULL_PATH_LENGTH) {
+                    // use rootDir/userIdentify as directory instead as it is shorter
+                    realmFileDirectory = new File(rootDir, user.getIdentity());
+                    fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
+                    if (fullPathName.length() > MAX_FULL_PATH_LENGTH) { // we are out of ideas
+                        throw new IllegalStateException(String.format("Full path name must not exceed %d characters: %s",
+                                MAX_FULL_PATH_LENGTH, fullPathName));
+                    }
+                }
+            }
+
+            if (realmFileName.length() > MAX_FILE_NAME_LENGTH) {
+                throw new IllegalStateException(String.format("File name exceed %d characters: %d", MAX_FILE_NAME_LENGTH,
+                        realmFileName.length()));
+            }
+
+            // substitute invalid characters
+            for (char c : INVALID_CHARS) {
+                realmFileName = realmFileName.replace(c, '_');
+            }
+
+            // Create the folder on disk (if needed)
+            if (!realmFileDirectory.exists() && !realmFileDirectory.mkdirs()) {
+                throw new IllegalStateException("Could not create directory for saving the Realm: " + realmFileDirectory);
+            }
+
+            return new SyncConfiguration(
+                    // Realm Configuration options
+                    realmFileDirectory,
+                    realmFileName,
+                    getCanonicalPath(new File(realmFileDirectory, realmFileName)),
+                    null, // assetFile not supported by Sync. See https://github.com/realm/realm-sync/issues/241
+                    key,
+                    0,
+                    null, // Custom migrations not supported
+                    false, // MigrationNeededException is never thrown
+                    durability,
+                    createSchemaMediator(modules, debugSchema),
+                    rxFactory,
+                    initialDataTransaction,
+
+                    // Sync Configuration specific
+                    user,
+                    resolvedServerUrl,
+                    syncPolicy,
+                    errorHandler,
+                    deleteRealmOnLogout
+            );
+        }
+
+        private void addModule(Object module) {
+            if (module != null) {
+                checkModule(module);
+                modules.add(module);
+            }
+        }
+
+        private void checkModule(Object module) {
+            if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
+                throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
+                        "Add @RealmModule to the class definition.");
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
new file mode 100644
index 0000000000..827f1265cf
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm
+ * Object Server to verify the user and grant access.
+ * <p>
+ * Logging into the Realm Object Server consists of the following steps:
+ * <ol>
+ * <li>
+ *     Log in to 3rd party provider (Facebook or Google). The result is usually an Authorization Grant that must be
+ *     saved in a {@link SyncCredentials} object of the proper type e.g., {@link SyncCredentials#facebook(String)} for a
+ *     Facebook login.
+ * </li>
+ * <li>
+ *     Authenticate a {@link SyncUser} through the Object Server using these credentials. Once authenticated,
+ *     an Object Server user is returned. Then this user can be attached to a {@link SyncConfiguration}, which
+ *     will make it possible to synchronize data between the local and remote Realm.
+ *     <p>
+ *     It is possible to persist the user object e.g., using the {@link UserStore}. That means, logging
+ *     into an OAuth2 provider is only required the first time the app is used.
+ * </li>
+ * </ol>
+ *
+ * <pre>
+ * {@code
+ * // Example
+ *
+ * Credentials credentials = Credentials.facebook(getFacebookToken());
+ * User.login(credentials, "http://objectserver.realm.io/auth", new User.Callback() {
+ *     \@Override
+ *     public void onSuccess(User user) {
+ *          // User is now authenticated and be be used to open Realms.
+ *     }
+ *
+ *     \@Override
+ *     public void onError(ObjectServerError error) {
+ *
+ *     }
+ * });
+ * }
+ * </pre>
+ */
+@Beta
+public class SyncCredentials {
+
+    private String identityProvider;
+    private String userIdentifier;
+    private Map<String, Object> userInfo;
+
+    // Factory constructors
+
+    /**
+     * Creates credentials based on a login with username and password. These credentials will only be verified
+     * by the Object Server.
+     *
+     * @param username username of the user.
+     * @param password the users password.
+     * @param createUser {@code true} if the user should be created, {@code false} otherwise. It is not possible to
+     *                   create a user twice when logging in, so this flag should only be set to {@code true} the first
+     *                   time a users log in.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials usernamePassword(String username, String password, boolean createUser) {
+        if (username == null || username.equals("")) {
+            throw new IllegalArgumentException("Non-null 'username' required.");
+        }
+        Map<String, Object> userInfo = new HashMap<String, Object>();
+        userInfo.put("register", createUser);
+        userInfo.put("password", password);
+        return new SyncCredentials(IdentityProvider.USERNAME_PASSWORD, username, userInfo);
+    }
+
+    /**
+     * Creates credentials based on a Facebook login.
+     *
+     * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials facebook(String facebookToken) {
+        if (facebookToken == null || facebookToken.equals("")) {
+            throw new IllegalArgumentException("Non-null 'facebookToken' required.");
+        }
+        return new SyncCredentials(IdentityProvider.FACEBOOK, facebookToken, null);
+    }
+
+    /**
+     * Creates credentials based on a Google login.
+     *
+     * @param googleToken a google userIdentifier acquired by logging into Google.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * @throws IllegalArgumentException if user name is either {@code null} or empty.
+     */
+    public static SyncCredentials google(String googleToken) {
+        if (googleToken == null || googleToken.equals("")) {
+            throw new IllegalArgumentException("Non-null 'googleToken' required.");
+        }
+        return new SyncCredentials(IdentityProvider.GOOGLE, googleToken, null);
+    }
+
+    /**
+     * Creates a custom set of credentials. The behaviour will depend on the type of {@code identityProvider} and
+     * {@code userInfo} used.
+     *
+     * @param identityProvider provider used to verify the credentials.
+     * @param userIdentifier String identifying the user. Usually a username of userIdentifier.
+     * @param userInfo data describing the user further or {@code null} if the user does not have any extra data. The
+     *              data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
+     *              classes will be converted using {@code toString()}.
+     * @return a set of credentials that can be used to log into the Object Server using
+     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * @throws IllegalArgumentException if any parameter is either {@code null} or empty.
+     */
+    public static SyncCredentials custom(String identityProvider, String userIdentifier, Map<String, Object> userInfo) {
+        if (identityProvider == null || identityProvider.equals("")) {
+            throw new IllegalArgumentException("Non-null 'identityProvider' required.");
+        }
+        if (userIdentifier == null || userIdentifier.equals("")) {
+            throw new IllegalArgumentException("Non-null 'userIdentifier' required.");
+        }
+        if (userInfo == null) {
+            userInfo = new HashMap<String, Object>();
+        }
+        return new SyncCredentials(identityProvider, userIdentifier, userInfo);
+    }
+
+    private SyncCredentials(String identityProvider, String token, Map<String, Object> userInfo) {
+        this.identityProvider = identityProvider;
+        this.userIdentifier = token;
+        this.userInfo = (userInfo == null) ? new HashMap<String, Object>() : userInfo;
+    }
+
+    /**
+     * Returns the provider used by the Object Server to validate these credentials.
+     *
+     * @return the login type.
+     */
+    public String getIdentityProvider() {
+        return identityProvider;
+    }
+
+    /**
+     * Returns a String that identifies the user. The value will depend on the type of {@link IdentityProvider} used.
+     *
+     * @return a String identifying the user.
+     */
+    public String getUserIdentifier() {
+        return userIdentifier;
+    }
+
+    /**
+     * Returns any custom user information associated with this credential.
+     * The type of information will depend on the type of {@link SyncCredentials.IdentityProvider}
+     * used.
+     *
+     * @return a map of additional information about the user.
+     */
+    public Map<String, Object> getUserInfo() {
+        return Collections.unmodifiableMap(userInfo);
+    }
+
+    /**
+     * Enumeration of the different types of identity providers. An identity provider is the entity responsible for
+     * verifying that a given credential is valid.
+     */
+    public static final class IdentityProvider {
+        /**
+         * Any credentials verified by the debug identity provider will always be considered valid.
+         * It is only available if configured on the Object Server, and it is disabled by default.
+         */
+        public static final String DEBUG = "debug";
+
+        /**
+         * Credentials will be verified by Facebook.
+         */
+        public static final String FACEBOOK = "facebook";
+
+        /**
+         * Credentials will be verified by Google.
+         */
+        public static final String GOOGLE = "google";
+
+        /**
+         * Credentials will be verified by the Object Server.
+         *
+         * @see #usernamePassword(String, String, boolean)
+         */
+        public static final String USERNAME_PASSWORD = "password";
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
new file mode 100644
index 0000000000..0fd80867e4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Keep;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.OkHttpAuthenticationServer;
+import io.realm.internal.objectserver.SessionStore;
+import io.realm.internal.objectserver.ObjectServerSession;
+import io.realm.log.RealmLog;
+
+/**
+ * @Beta
+ * The SyncManager is the central controller for interacting with the Realm Object Server.
+ * It handles the creation of {@link SyncSession}s and it is possible to configure session defaults and the underlying
+ * network client using this class.
+ * <p>
+ * Through the SyncManager, it is possible to add authentication listeners. An authentication listener will
+ * response to events like user logging in or out.
+ * <p>
+ * Default error handling for any {@link SyncConfiguration} can be added using the SyncManager.
+ *
+ */
+@Keep
+@Beta
+public class SyncManager {
+
+    /**
+     * APP ID sent to the Realm Object Server. Is automatically initialized to the package name for the app.
+     */
+    public static String APP_ID = null;
+
+    // Thread pool used when doing network requests against the Realm Authentication Server.
+    // FIXME Set proper parameters
+    public static final ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(
+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100));
+
+    private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {
+        @Override
+        public void onError(SyncSession session, ObjectServerError error) {
+            String errorMsg = String.format("Session Error[%s]: %s",
+                    session.getConfiguration().getServerUrl(),
+                    error.toString());
+            switch (error.getErrorCode().getCategory()) {
+                case FATAL:
+                    RealmLog.error(errorMsg);
+                    break;
+                case RECOVERABLE:
+                    RealmLog.info(errorMsg);
+                    break;
+                default:
+                    throw new IllegalArgumentException("Unsupported error category: " + error.getErrorCode().getCategory());
+            }
+        }
+    };
+
+    private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
+
+    // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
+    // Right now it just lives and dies together with the process.
+    private static volatile AuthenticationServer authServer = new OkHttpAuthenticationServer();
+    private static volatile UserStore userStore;
+
+    static volatile SyncSession.ErrorHandler defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
+    @SuppressWarnings("FieldCanBeLocal")
+    private static Thread clientThread;
+
+    // Initialize the SyncManager
+    static void init(String appId, UserStore userStore) {
+
+        SyncManager.APP_ID = appId;
+        SyncManager.userStore = userStore;
+
+        // Initialize underlying Sync Network Client
+        nativeInitializeSyncClient();
+
+        // Create the client thread in java to avoid problems when exceptions are being thrown. We need to attach
+        // any thread to the JVM anyway in order to send back log events.
+        SyncManager.clientThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                nativeRunClient();
+            }
+        }, "RealmSyncClient");
+        SyncManager.clientThread.start();
+    }
+
+    /**
+     * Set the {@link UserStore} used by the Realm Object Server to save user information.
+     * If no Userstore is specified {@link SyncUser#currentUser()} will always return {@code null}.
+     *
+     * @param userStore {@link UserStore} to use.
+     * @throws IllegalArgumentException if {@code userStore} is {@code null}.
+     */
+    public static void setUserStore(UserStore userStore) {
+        if (userStore == null) {
+            throw new IllegalArgumentException("Non-null 'userStore' required.");
+        }
+        SyncManager.userStore = userStore;
+    }
+
+    /**
+     * Sets a global authentication listener that will be notified about User events like
+     * login and logout.
+     *
+     * @param listener listener to register.
+     * @throws IllegalArgumentException if {@code listener} is {@code null}.
+     */
+    public static void addAuthenticationListener(AuthenticationListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Non-null 'listener' required.");
+        }
+        authListeners.add(listener);
+    }
+
+    /**
+     * Removes the provided global authentication listener.
+     *
+     * @param listener listener to remove.
+     */
+    public static void removeAuthenticationListener(AuthenticationListener listener) {
+        if (listener == null) {
+            return;
+        }
+        authListeners.remove(listener);
+    }
+
+    /**
+     * Sets the default error handler used by all {@link SyncConfiguration} objects when they are created.
+     *
+     * @param errorHandler the default error handler used when interacting with a Realm managed by a Realm Object Server.
+     */
+    public static void setDefaultSessionErrorHandler(SyncSession.ErrorHandler errorHandler) {
+        if (errorHandler == null) {
+            defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
+        } else {
+            defaultSessionErrorHandler = errorHandler;
+        }
+    }
+
+    /**
+     * Gets any cached {@link SyncSession} for the given {@link SyncConfiguration} or create a new one if
+     * no one exists.
+     *
+     * @param syncConfiguration configuration object for the synchronized Realm.
+     * @return the {@link SyncSession} for the specified Realm.
+     * @throws IllegalArgumentException if syncConfiguration is {@code null}.
+     */
+    public static synchronized SyncSession getSession(SyncConfiguration syncConfiguration) {
+        if (syncConfiguration == null) {
+            throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
+        }
+
+        if (SessionStore.hasSession(syncConfiguration)) {
+            return SessionStore.getPublicSession(syncConfiguration);
+        } else {
+            ObjectServerSession internalSession = new ObjectServerSession(
+                    syncConfiguration,
+                    authServer,
+                    syncConfiguration.getUser().getSyncUser(),
+                    syncConfiguration.getSyncPolicy(),
+                    syncConfiguration.getErrorHandler()
+            );
+            SyncSession publicSession = new SyncSession(internalSession);
+            SessionStore.addSession(publicSession, internalSession);
+            syncConfiguration.getUser().getSyncUser().addSession(publicSession);
+            syncConfiguration.getSyncPolicy().onSessionCreated(internalSession);
+            return publicSession;
+        }
+    }
+
+    public static AuthenticationServer getAuthServer() {
+        return authServer;
+    }
+
+    /**
+     * Sets the auth server implementation used when validating credentials.
+     */
+    static void setAuthServerImpl(AuthenticationServer authServerImpl) {
+        authServer = authServerImpl;
+    }
+
+    // Return the currently configured User store.
+    static UserStore getUserStore() {
+        return userStore;
+    }
+
+    // This is called from SyncManager.cpp from the worker thread the Sync Client is running on
+    // Right now Core doesn't send these errors to the proper session, so instead we need to notify all sessions
+    // from here. This can be removed once better error propagation is implemented in Sync Core.
+    @SuppressWarnings("unused")
+    private static void notifyErrorHandler(int errorCode, String errorMessage) {
+        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
+        for (ObjectServerSession session : SessionStore.getAllSessions()) {
+            session.onError(error);
+        }
+    }
+
+    // Notify listeners that a user logged in
+    static void notifyUserLoggedIn(SyncUser user) {
+        for (AuthenticationListener authListener : authListeners) {
+            authListener.loggedIn(user);
+        }
+    }
+
+    // Notify listeners that a user logged out successfully
+    static void notifyUserLoggedOut(SyncUser user) {
+        for (AuthenticationListener authListener : authListeners) {
+            authListener.loggedOut(user);
+        }
+    }
+
+    private static native void nativeInitializeSyncClient();
+    private static native void nativeRunClient();
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
new file mode 100644
index 0000000000..0aabe1e5d9
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.net.URI;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Keep;
+import io.realm.log.RealmLog;
+import io.realm.internal.objectserver.ObjectServerSession;
+
+/**
+ * @Beta
+ * This class represents the connection to the Realm Object Server for one {@link SyncConfiguration}.
+ * <p>
+ * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
+ * a Realm instance using that configuration. Once a session has been created, it will continue to exist until the app
+ * is closed or the {@link SyncConfiguration} is no longer used.
+ * <p>
+ * A session is fully controlled by Realm, but can provide additional information in case of errors.
+ * It is passed along in all {@link SyncSession.ErrorHandler}s.
+ * <p>
+ * This object is thread safe.
+ *
+ * @see SessionState
+ */
+@Keep
+@Beta
+public class SyncSession {
+
+    private final ObjectServerSession osSession;
+
+    SyncSession(ObjectServerSession osSession) {
+        this.osSession = osSession;
+        osSession.setUserSession(this);
+    }
+
+    /**
+     * Returns the {@link SyncConfiguration} that is responsible for controlling the session.
+     *
+     * @return SyncConfiguration that defines and controls this session.
+     */
+    public SyncConfiguration getConfiguration() {
+        return osSession.getConfiguration();
+    }
+
+    /**
+     * Returns the {@link SyncUser} defined by the {@link SyncConfiguration} that is used to connect to the
+     * Realm Object Server.
+     *
+     * @return {@link SyncUser} used to authenticate the session on the Realm Object Server.
+     */
+    public SyncUser getUser() {
+        return osSession.getConfiguration().getUser();
+    }
+
+    /**
+     * Returns the {@link URI} describing the remote Realm which this session connects to and synchronizes changes with.
+     *
+     * @return {@link URI} describing the remote Realm.
+     */
+    public URI getServerUrl() {
+        return osSession.getConfiguration().getServerUrl();
+    }
+
+    /**
+     * Returns the state of this session.
+     *
+     * @return the current {@link SessionState} for this session.
+     */
+    public SessionState getState() {
+        return osSession.getState();
+    }
+
+    ObjectServerSession getOsSession() {
+        return osSession;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        if (osSession.getState() != SessionState.STOPPED) {
+            RealmLog.warn("Session was not closed before being finalized. This is a potential resource leak.");
+            osSession.stop();
+        }
+    }
+
+    /**
+     * Interface used to report any session errors.
+     *
+     * @see SyncManager#setDefaultSessionErrorHandler(ErrorHandler)
+     * @see SyncConfiguration.Builder#errorHandler(ErrorHandler)
+     */
+    public interface ErrorHandler {
+        /**
+         * Callback for errors on a session object.
+         *
+         * @param session {@link SyncSession} this error happened on.
+         * @param error type of error.
+         */
+        void onError(SyncSession session, ObjectServerError error);
+    }
+}
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
new file mode 100644
index 0000000000..6486bf3c5e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -0,0 +1,430 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.Util;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ExponentialBackoffTask;
+import io.realm.internal.network.LogoutResponse;
+import io.realm.internal.objectserver.ObjectServerUser;
+import io.realm.internal.objectserver.Token;
+import io.realm.log.RealmLog;
+import io.realm.permissions.PermissionChange;
+import io.realm.permissions.PermissionModule;
+
+/**
+ * @Beta
+ * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
+ * providers (Facebook, Google, etc.).
+ * <p>
+ * A user can log in to the Realm Object Server, and if access is granted, it is possible to synchronize the local
+ * and the remote Realm. Moreover, synchronization is halted when the user is logged out.
+ * <p>
+ * It is possible to persist a user. By retrieving a user, there is no need to log in to the 3rd party provider again.
+ * Persisting a user between sessions, the user's credentials are stored locally on the device, and should be treated
+ * as sensitive data.
+ */
+@Beta
+public class SyncUser {
+
+    private SyncConfiguration managementRealmConfig;
+    private final ObjectServerUser syncUser;
+
+    private SyncUser(ObjectServerUser user) {
+        this.syncUser = user;
+    }
+
+    /**
+     * Returns the current user that is logged in and still valid.
+     * A user is invalidated when he/she logs out or the user's access token expires.
+     *
+     * @return current {@link SyncUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has
+     *         expired.
+     * @throws IllegalStateException if multiple users are logged in.
+     */
+    public static SyncUser currentUser() {
+        SyncUser user = SyncManager.getUserStore().get();
+        if (user != null && user.isValid()) {
+            return user;
+        }
+        return null;
+    }
+
+    /**
+     * Returns all valid users known by this device.
+     * A user is invalidated when he/she logs out or the user's access token expires.
+     *
+     * @return a list of all known valid users.
+     */
+    public static Collection<SyncUser> all() {
+        UserStore userStore = SyncManager.getUserStore();
+        Collection<SyncUser> storedUsers = userStore.allUsers();
+        List<SyncUser> result = new ArrayList<SyncUser>(storedUsers.size());
+        for (SyncUser user : storedUsers) {
+            if (user.isValid()) {
+                result.add(user);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Loads a user that has previously been serialized using {@link #toJson()}.
+     *
+     * @param user JSON string representing the user.
+     *
+     * @return the user object.
+     * @throws IllegalArgumentException if the JSON couldn't be converted to a valid {@link SyncUser} object.
+     */
+    public static SyncUser fromJson(String user) {
+        try {
+            JSONObject obj = new JSONObject(user);
+            URL authUrl = new URL(obj.getString("authUrl"));
+            Token userToken = Token.from(obj.getJSONObject("userToken"));//TODO rename to refresh_token
+            ObjectServerUser syncUser = new ObjectServerUser(userToken, authUrl);
+            JSONArray realmTokens = obj.getJSONArray("realms");
+            for (int i = 0; i < realmTokens.length(); i++) {
+                JSONObject token = realmTokens.getJSONObject(i);
+                URI uri = new URI(token.getString("uri"));
+                ObjectServerUser.AccessDescription realmDesc = ObjectServerUser.AccessDescription.fromJson(token.getJSONObject("description"));
+                syncUser.addRealm(uri, realmDesc);
+            }
+            return new SyncUser(syncUser);
+        } catch (JSONException e) {
+            throw new IllegalArgumentException("Could not parse user json: " + user, e);
+        } catch (MalformedURLException e) {
+            throw new IllegalArgumentException("URL in JSON not valid: " + user, e);
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("URI is not valid: " + user, e);
+        }
+    }
+
+    /**
+     * Logs in the user to the Realm Object Server. This is done synchronously, so calling this method on the Android
+     * UI thread will always crash. A logged in user is required to be able to create a {@link SyncConfiguration}.
+     *
+     * @param credentials credentials to use.
+     * @param authenticationUrl server that can authenticate against.
+     * @throws ObjectServerError if the login failed.
+     * @throws IllegalArgumentException if the URL is malformed.
+     */
+    public static SyncUser login(final SyncCredentials credentials, final String authenticationUrl) throws ObjectServerError {
+        final URL authUrl;
+        try {
+            authUrl = new URL(authenticationUrl);
+        } catch (MalformedURLException e) {
+            throw new IllegalArgumentException("Invalid URL " + authenticationUrl + ".", e);
+        }
+
+        final AuthenticationServer server = SyncManager.getAuthServer();
+        ObjectServerError error;
+        try {
+            AuthenticateResponse result = server.loginUser(credentials, authUrl);
+            if (result.isValid()) {
+                ObjectServerUser syncUser = new ObjectServerUser(result.getRefreshToken(), authUrl);
+                SyncUser user = new SyncUser(syncUser);
+                RealmLog.info("Succeeded authenticating user.\n%s", user);
+                SyncManager.getUserStore().put(user);
+                SyncManager.notifyUserLoggedIn(user);
+                return user;
+            } else {
+                RealmLog.info("Failed authenticating user.\n%s", result.getError());
+                error = result.getError();
+            }
+        } catch (Throwable e) {
+            throw new ObjectServerError(ErrorCode.UNKNOWN, e);
+        }
+        throw error;
+    }
+
+    /**
+     * Logs in the user to the Realm Object Server. A logged in user is required to be able to create a
+     * {@link SyncConfiguration}.
+     *
+     * @param credentials credentials to use.
+     * @param authenticationUrl server that the user is authenticated against.
+     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
+     *                 as this this method is called on.
+     * @throws IllegalArgumentException if not on a Looper thread.
+     */
+    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback callback) {
+        if (Looper.myLooper() == null) {
+            throw new IllegalStateException("Asynchronous login is only possible from looper threads.");
+        }
+        final Handler handler = new Handler(Looper.myLooper());
+        ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
+        Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SyncUser user = login(credentials, authenticationUrl);
+                    postSuccess(user);
+                } catch (ObjectServerError e) {
+                    postError(e);
+                }
+            }
+
+            private void postError(final ObjectServerError error) {
+                if (callback != null) {
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onError(error);
+                        }
+                    });
+                }
+            }
+
+            private void postSuccess(final SyncUser user) {
+                if (callback != null) {
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onSuccess(user);
+                        }
+                    });
+                }
+            }
+        });
+
+        return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);
+    }
+
+    /**
+     * Logs out the user from the Realm Object Server. Once the Object Server has confirmed the logout any registered
+     * {@link AuthenticationListener} will be notified and user credentials will be deleted from this device.
+     *
+     * @throws IllegalStateException if any Realms owned by this user is still open. They should be closed before
+     *         logging out.
+     */
+    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
+     <p>
+     Any Realms owned by the user will be deleted if {@link SyncConfiguration.Builder#deleteRealmOnLogout()} is
+     also set.
+     */
+    public void logout() {
+        // Acquire lock to prevent users creating new instances
+        synchronized (Realm.class) {
+            if (!syncUser.isLoggedIn()) {
+                return; // Already logged out
+            }
+
+            // Ensure that we can log out. If any Realm file is still open we should abort before doing anything
+            // else.
+            Collection<SyncSession> sessions = syncUser.getSessions();
+            for (SyncSession session : sessions) {
+                SyncConfiguration config = session.getConfiguration();
+                if (Realm.getGlobalInstanceCount(config) > 0) {
+                    throw new IllegalStateException("A Realm controlled by this user is still open. Close all Realms " +
+                            "before logging out: " + config.getPath());
+                }
+            }
+
+            // Stop all active sessions immediately. If we waited until after talking to the server
+            // there is a high chance errors would be reported from the Sync Client first which would
+            // be confusing.
+            for (SyncSession session : sessions) {
+                session.getOsSession().stop();
+            }
+
+            // Remove all local tokens, preventing further connections.
+            // FIXME We still need to cache the user token so it can be revoked.
+            syncUser.clearTokens();
+
+            SyncManager.getUserStore().remove();
+
+            // Delete all Realms if needed.
+            for (ObjectServerUser.AccessDescription desc : syncUser.getRealms()) {
+                // FIXME: This will always be false since SyncConfiguration.Builder.deleteRealmOnLogout() is
+                // disabled. Make sure this works for Realm opened in the client thread/other processes.
+                if (desc.deleteOnLogout) {
+                    File realmFile = new File(desc.localPath);
+                    if (realmFile.exists() && !Util.deleteRealm(desc.localPath, realmFile.getParentFile(), realmFile.getName())) {
+                        RealmLog.error("Could not delete Realm when user logged out: " + desc.localPath);
+                    }
+                }
+            }
+
+            // Finally revoke server token. The local user is logged out in any case.
+            final AuthenticationServer server = SyncManager.getAuthServer();
+            ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
+            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
+
+                @Override
+                protected LogoutResponse execute() {
+                    return server.logout(SyncUser.this, syncUser.getAuthenticationUrl());
+                }
+
+                @Override
+                protected void onSuccess(LogoutResponse response) {
+                    SyncManager.notifyUserLoggedOut(SyncUser.this);
+                }
+
+                @Override
+                protected void onError(LogoutResponse response) {
+                    RealmLog.error("Failed to log user out.\n" + response.getError().toString());
+                }
+            });
+        }
+    }
+
+    /**
+     * Returns a JSON token representing this user.
+     * <p>
+     * Possession of this JSON token can potentially grant access to data stored on the Realm Object Server, so it
+     * should be treated as sensitive data.
+     *
+     * @return JSON string representing this user. It can be converted back into a real user object using
+     *         {@link #fromJson(String)}.
+     *
+     * @see #fromJson(String)
+     */
+    public String toJson() {
+        return syncUser.toJson();
+    }
+
+    /**
+     * Returns {@code true} if the user is logged into the Realm Object Server. If this method returns {@code true} it
+     * implies that the user has valid credentials that have not expired.
+     * <p>
+     * The user might still be have been logged out by the Realm Object Server which will not be detected before the
+     * user tries to actively synchronize a Realm. If a logged out user tries to synchronize a Realm, an error will be
+     * reported to the {@link SyncSession.ErrorHandler} defined by
+     * {@link SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)}.
+     *
+     * @return {@code true} if the User is logged into the Realm Object Server, {@code false} otherwise.
+     */
+    public boolean isValid() {
+        Token userToken = getSyncUser().getUserToken();
+        return syncUser.isLoggedIn() && userToken != null && userToken.expiresMs() > System.currentTimeMillis();
+    }
+
+    /**
+     * Returns the identity of this user on the Realm Object Server. The identity is a guaranteed to be unique
+     * among all users on the Realm Object Server.
+     *
+     * @return identity of the user on the Realm Object Server. If the user has logged out or the login has expired
+     *         {@code null} is returned.
+     */
+    public String getIdentity() {
+        return syncUser.getIdentity();
+    }
+
+    /**
+     * Returns this user's access token. This is the users credential for accessing the Realm Object Server and should
+     * be treated as sensitive data.
+     *
+     * @return the user's access token. If this user has logged out or the login has expired {@code null} is returned.
+     */
+    public String getAccessToken() {
+        Token userToken = syncUser.getUserToken();
+        return (userToken != null) ? userToken.value() : null;
+    }
+
+    /**
+     * Returns an instance of the Management Realm owned by the user.
+     * <p>
+     * This Realm can be used to control access and permissions for Realms owned by the user. This includes
+     * giving other users access to Realms.
+     *
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">How to control permissions</a>
+     */
+    public Realm getManagementRealm() {
+        synchronized (this) {
+            if (managementRealmConfig == null) {
+                String managementUrl = getManagementRealmUrl(syncUser.getAuthenticationUrl());
+                managementRealmConfig = new SyncConfiguration.Builder(this, managementUrl)
+                        .modules(new PermissionModule())
+                        .build();
+            }
+        }
+
+        return Realm.getInstance(managementRealmConfig);
+    }
+
+    // Creates the URL to the permission Realm based on the authentication URL.
+    private static String getManagementRealmUrl(URL authUrl) {
+        String scheme = "realm";
+        if (authUrl.getProtocol().equalsIgnoreCase("https")) {
+            scheme = "realms";
+        }
+        try {
+            return new URI(scheme, authUrl.getUserInfo(), authUrl.getHost(), authUrl.getPort(),
+                    "/~/__management", null, null).toString();
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not create URL to the management Realm", e);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        SyncUser user = (SyncUser) o;
+
+        return syncUser.equals(user.syncUser);
+
+    }
+
+    @Override
+    public int hashCode() {
+        return syncUser.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder("{");
+        sb.append("UserId: ").append(syncUser.getIdentity());
+        sb.append(", AuthUrl: ").append(syncUser.getAuthenticationUrl());
+        sb.append(", IsValid: ").append(isValid());
+        sb.append(", Sessions: ").append(syncUser.getSessions().size());
+        sb.append("}");
+        return sb.toString();
+    }
+
+    // Expose internal representation for other package protected classes
+    ObjectServerUser getSyncUser() {
+        return syncUser;
+    }
+
+    public interface Callback {
+        void onSuccess(SyncUser user);
+        void onError(ObjectServerError error);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
new file mode 100644
index 0000000000..052f3759b9
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collection;
+
+import io.realm.annotations.Beta;
+
+/**
+ * @Beta
+ * Interface for classes responsible for saving and retrieving Object Server users again.
+ * <p>
+ * Any implementation of a User Store is expected to not perform lengthy blocking operations as it might
+ * be called on the Main Thread. All implementations of this interface should be thread safe.
+ *
+ * @see SyncManager#setUserStore(UserStore)
+ * @see RealmFileUserStore
+ */
+@Beta
+public interface UserStore {
+
+    /**
+     * Saves a {@link SyncUser} object. If another user already exists, it will be replaced.
+     *  {@link SyncUser#getIdentity()} is used as a unique identifier of a given {@link SyncUser}.
+     *
+     * @param user {@link SyncUser} object to store.
+     */
+    void put(SyncUser user);
+
+    /**
+     * Retrieves the current {@link SyncUser}.
+     *
+     * For now, current User cannot be called if more that one valid, logged in user
+     * exists, it will throw an exception.
+     */
+    //TODO when ObjectStore integration of SyncManager is completed & multiple
+    //     users are allowed, consider passing the User identity to lookup apply
+    //     the operation to a particular user.
+    SyncUser get();
+
+    /**
+     * Removes the current user from the store.
+     */
+    //TODO when ObjectStore integration of SyncManager is completed & multiple
+    //     users are allowed, consider passing the User identity to lookup apply
+    //     the operation to a particular user.
+    void remove();
+
+    /**
+     * Returns a collection of all users saved in the User store.
+     *
+     * @return Collection of all users. If no users exist, an empty collection is returned.
+     */
+    Collection<SyncUser> allUsers();
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
new file mode 100644
index 0000000000..cad9ce933a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
@@ -0,0 +1,75 @@
+package io.realm.internal.network;
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+
+/**
+ * Base class for all response types from the Realm Authentication Server.
+ */
+public class AuthServerResponse {
+
+    protected ObjectServerError error;
+
+    /**
+     * Checks if this response was valid.
+     *
+     * @return {@code true} if valid, {@code false} otherwise.
+     */
+    public boolean isValid() {
+        return (error == null);
+    }
+
+    /**
+     * If {@link #isValid()} returns {@code false}, this method will return the error causing this.
+     *
+     * @return the error.
+     */
+    public ObjectServerError getError() {
+        return error;
+    }
+
+    protected void setError(ObjectServerError error) {
+        this.error = error;
+    }
+
+
+
+    /**
+     * Parse an HTTP error from a Realm Authentication Server. The server returns errors following
+     * https://tools.ietf.org/html/rfc7807 with an extra "code" field for Realm specific error codes.
+     *
+     * @param response the server response.
+     * @param httpErrorCode the HTTP error code.
+     * @return an server error.
+     */
+    public static ObjectServerError createError(String response, int httpErrorCode) {
+        try {
+            JSONObject obj = new JSONObject(response);
+            String title = obj.optString("title", null);
+            String hint = obj.optString("hint", null);
+            ErrorCode errorCode = ErrorCode.fromInt(obj.optInt("code", -1));
+            return new ObjectServerError(errorCode, title, hint);
+        } catch (JSONException e) {
+            return new ObjectServerError(ErrorCode.JSON_EXCEPTION, "Server failed with " +
+                    httpErrorCode + ", but could not parse error.", e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
new file mode 100644
index 0000000000..6b27dfc7d7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.util.Collections;
+import java.util.Map;
+
+import io.realm.internal.objectserver.Token;
+import io.realm.SyncCredentials;
+import io.realm.SyncManager;
+
+/**
+ * This class encapsulates a request to authenticate a user on the Realm Authentication Server. It is responsible for
+ * constructing the JSON understood by the Realm Authentication Server.
+ */
+public class AuthenticateRequest {
+
+    private final String provider;
+    private final String data;
+    private final String appId;
+    private final Map<String, Object> userInfo;
+    private final String path;
+
+    /**
+     * Generates a proper login request for a new user.
+     */
+    public static AuthenticateRequest userLogin(SyncCredentials credentials) {
+        if (credentials == null) {
+           throw new IllegalArgumentException("Non-null credentials required.");
+        }
+        String provider = credentials.getIdentityProvider();
+        String data = credentials.getUserIdentifier();
+        Map<String, Object> userInfo = credentials.getUserInfo();
+        String appId = SyncManager.APP_ID;
+        return new AuthenticateRequest(provider, data, appId, null, userInfo);
+    }
+
+    /**
+     * Generates a request for refreshing a user token.
+     */
+    public static AuthenticateRequest userRefresh(Token userToken) {
+        return new AuthenticateRequest("realm",
+                userToken.value(),
+                SyncManager.APP_ID,
+                null,
+                Collections.<String, Object>emptyMap()
+        );
+    }
+
+    /**
+     * Generates a request for accessing a Realm
+     */
+    public static AuthenticateRequest realmLogin(Token userToken, URI serverUrl) {
+        // Authenticate a given Realm path using an already logged in user.
+        return new AuthenticateRequest("realm",
+                userToken.value(),
+                SyncManager.APP_ID,
+                serverUrl.getPath(),
+                Collections.<String, Object>emptyMap()
+        );
+    }
+
+    private AuthenticateRequest(String provider, String data, String appId, String path, Map<String, Object> userInfo) {
+        this.provider = provider;
+        this.data = data;
+        this.appId = appId;
+        this.path = path;
+        this.userInfo = userInfo;
+    }
+
+    /**
+     * Converts the request into a JSON payload.
+     */
+    public String toJson() {
+        JSONObject request = new JSONObject();
+        try {
+            request.put("provider", provider);
+            request.put("data", data);
+            request.put("app_id", appId);
+            if (path != null) {
+                request.put("path", path);
+            }
+            request.put("user_info", new JSONObject(userInfo));
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+
+        return request.toString();
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
new file mode 100644
index 0000000000..75e31a0818
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.internal.objectserver.Token;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * This class represents the response for an authenticate request.
+ */
+public class AuthenticateResponse extends AuthServerResponse {
+
+    private static final String JSON_FIELD_ACCESS_TOKEN = "access_token";
+    private static final String JSON_FIELD_REFRESH_TOKEN = "refresh_token";
+
+    private final Token accessToken;
+    private final Token refreshToken;
+
+    /**
+     * Helper method for creating the proper Authenticate response. This method will set the appropriate error
+     * depending on any HTTP response codes or IO errors.
+     *
+     * @param response the HTTP response.
+     * @return an authenticate response.
+     */
+    public static AuthenticateResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new AuthenticateResponse(error);
+        }
+        if (response.code() != 200) {
+            return new AuthenticateResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new AuthenticateResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating the response from a JSON string.
+     */
+    public static AuthenticateResponse from(String json) {
+        return new AuthenticateResponse(json);
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static AuthenticateResponse from(ObjectServerError error) {
+        return new AuthenticateResponse(error);
+    }
+
+    /**
+     * Creates an unsuccessful authentication response. This should only happen in case of network or I/O related
+     * issues.
+     *
+     * @param error the network or I/O error.
+     */
+    private AuthenticateResponse(ObjectServerError error) {
+        RealmLog.debug("AuthenticateResponse. Error " + error.getErrorMessage());
+        setError(error);
+        this.accessToken = null;
+        this.refreshToken = null;
+    }
+
+    /**
+     * Parses a valid (200) server response. It might still result in an unsuccessful authentication attempt, if the
+     * JSON response could not be parsed correctly.
+     *
+     * @param serverResponse the server response.
+     */
+    private AuthenticateResponse(String serverResponse) {
+        ObjectServerError error;
+        Token accessToken;
+        Token refreshToken;
+        String message;
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            accessToken = obj.has(JSON_FIELD_ACCESS_TOKEN) ?
+                    Token.from(obj.getJSONObject(JSON_FIELD_ACCESS_TOKEN)) : null;
+            refreshToken = obj.has(JSON_FIELD_REFRESH_TOKEN) ?
+                    Token.from(obj.getJSONObject(JSON_FIELD_REFRESH_TOKEN)) : null;
+            error = null;
+            if (accessToken == null) {
+                message = "accessToken = null";
+            } else {
+                message = String.format("Identity %s; Path %s", accessToken.identity(), accessToken.path());
+            }
+        } catch (JSONException ex) {
+            accessToken = null;
+            refreshToken = null;
+            //noinspection ThrowableInstanceNeverThrown
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, ex);
+            message = String.format("Error %s", error.getErrorMessage());
+        }
+        RealmLog.debug("AuthenticateResponse. " + message);
+        setError(error);
+        this.accessToken = accessToken;
+        this.refreshToken = refreshToken;
+    }
+
+    public Token getAccessToken() {
+        return accessToken;
+    }
+
+    public Token getRefreshToken() {
+        return refreshToken;
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
new file mode 100644
index 0000000000..5cde174353
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.net.URI;
+import java.net.URL;
+
+import io.realm.SyncCredentials;
+import io.realm.SyncUser;
+import io.realm.internal.objectserver.Token;
+
+/**
+ * Interface for handling communication with Realm Object Servers.
+ * <p>
+ * Note, no implementation of this class is responsible for handling retries or error handling. It is
+ * only responsible for executing a given network request.
+ */
+public interface AuthenticationServer {
+    /**
+     * Login a User on the Object Server. This will create a "UserToken" (Currently called RefreshToken) that acts as
+     * the users credentials.
+     */
+    AuthenticateResponse loginUser(SyncCredentials credentials, URL authenticationUrl);
+
+    /**
+     * Requests access to a specific Realm. Only users with a valid user token can ask for permission to a remote Realm.
+     * Permission to a Realm is granted through an "AccessToken". Each Realm have their own access token, and all
+     * tokens should be managed by {@link SyncUser}.
+     */
+    AuthenticateResponse loginToRealm(Token userToken, URI serverUrl,  URL authenticationUrl);
+
+    /**
+     * When the Object Server returns the user token, it also sends a timestamp for when the token expires.
+     * Before it expires, the client should try to refresh the token, effectively keeping the user logged in on the
+     * Object Server. Failing to do so will cause a "soft logout", where the User will have limited access rights.
+     */
+    AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl);
+
+    /**
+     * Logs out the user on the Object Server by invalidating the refresh token. Each device should be given their
+     * own refresh token, but if the refresh token for some reason was shared or stolen all these devices will be
+     * logged out as well.
+     */
+    LogoutResponse logout(SyncUser user, URL authenticationUrl);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
new file mode 100644
index 0000000000..aa613c8357
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.util.concurrent.TimeUnit;
+
+import io.realm.ErrorCode;
+
+/**
+ * Abstracts the concept of running an network task with incremental backoff. It will run forever until interrupted.
+ */
+public abstract class ExponentialBackoffTask<T extends AuthServerResponse> implements Runnable {
+
+    // Task to perform
+    protected abstract T execute();
+
+    // Check if the task was successful
+    protected boolean isSuccess(T result) {
+        return result.isValid();
+    }
+
+    // Return true if based on the task result that this task will never complete
+    protected boolean shouldAbortTask(T response) {
+        // Only retry in case of IO exceptions, since that might be network timeouts etc.
+        // All other errors indicate a bigger problem, so just stop the task.
+        if (!response.isValid()) {
+            return response.getError().getErrorCode() != ErrorCode.IO_EXCEPTION;
+        } else {
+            return false;
+        }
+    }
+
+    // Callback when task is have succeeded
+    protected abstract void onSuccess(T response);
+
+    // Callback when task has failed
+    protected abstract void onError(T response);
+
+    @Override
+    public void run() {
+        int attempt = 0;
+        while (true) {
+            attempt++;
+            long sleep = calculateExponentialDelay(attempt - 1, TimeUnit.MINUTES.toMillis(5));
+            if (sleep > 0) {
+                try {
+                    Thread.sleep(sleep);
+                } catch (InterruptedException e) {
+                    return; // Abort if interrupted
+                }
+            }
+            T response = execute();
+
+            if (isSuccess(response)) {
+                onSuccess(response);
+                break;
+            } else {
+                if (shouldAbortTask(response)) {
+                    onError(response);
+                    break;
+                }
+            }
+        }
+    }
+
+    private static long calculateExponentialDelay(int failedAttempts, long maxDelayInMs) {
+        // https://en.wikipedia.org/wiki/Exponential_backoff
+        //Attempt = FailedAttempts + 1
+        //Attempt 1     0s     0s
+        //Attempt 2     2s     2s
+        //Attempt 3     4s     4s
+        //Attempt 4     8s     8s
+        //Attempt 5     16s    16s
+        //Attempt 6     32s    32s
+        //Attempt 7     64s    1m 4s
+        //Attempt 8     128s   2m 8s
+        //Attempt 9     256s   4m 16s
+        //Attempt 10    512    8m 32s
+        //Attempt 11    1024   17m 4s
+        //Attempt 12    2048   34m 8s
+        //Attempt 13    4096   1h 8m 16s
+        //Attempt 14    8192   2h 16m 32s
+        //Attempt 15    16384  4h 33m 4s
+        double SCALE = 1.0D; // Scale the exponential backoff
+        double delayInMs = ((Math.pow(2.0D, failedAttempts) - 1d) / 2.0D) * 1000 * SCALE;
+
+        // Just use maximum back-off value. We are not afraid of many threads using this value
+        // to trigger at once.
+        return maxDelayInMs < delayInMs ? maxDelayInMs : (long) delayInMs;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
new file mode 100644
index 0000000000..c7706c27e5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import io.realm.SyncUser;
+
+/**
+ * This class encapsulates a request to log out a user on the Realm Authentication Server. It is responsible for
+ * constructing the JSON understood by the Realm Authentication Server.
+ */
+public class LogoutRequest {
+    // TODO Endpoint not finished yet
+
+    LogoutRequest fromUser(SyncUser user) {
+        return new LogoutRequest();
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
new file mode 100644
index 0000000000..5439f9f769
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * This class represents the response for a log out request.
+ */
+public class LogoutResponse extends AuthServerResponse {
+
+    private final ObjectServerError error;
+
+    /**
+     * Helper method for creating the proper Authenticate response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the log out response.
+     */
+    static LogoutResponse createFrom(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new LogoutResponse(error);
+        }
+        RealmLog.debug("Authenticate response: " + serverResponse);
+        if (response.code() != 200) {
+            return new LogoutResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new LogoutResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Creates an unsuccessful authentication response. This should only happen in case of network or I/O
+     * related issues.
+     *
+     * @param error an authentication response error.
+     */
+    private LogoutResponse(ObjectServerError error) {
+        this.error = error;
+    }
+
+    /**
+     * Parses a valid (200) server response.
+     *
+     * @param serverResponse the server response.
+     */
+    private LogoutResponse(String serverResponse) {
+        this.error = null;
+        // TODO endpoint not finalized
+    }
+
+    /**
+     * Checks if response was valid.
+     *
+     * @return {@code true} if valid.
+     */
+    public boolean isValid() {
+//        return (error == null);
+        return true;
+    }
+
+    /**
+     * Returns the error.
+     *
+     * @return the error.
+     */
+    public ObjectServerError getError() {
+        return error;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
new file mode 100644
index 0000000000..5fa68176a9
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/NetworkStateReceiver.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import io.realm.internal.Util;
+
+/**
+ * This class is responsible for keeping track of system events related to the network so it can delegate them to
+ * interested parties.
+ */
+public class NetworkStateReceiver extends BroadcastReceiver {
+
+    private static List<ConnectionListener> listeners = new CopyOnWriteArrayList<ConnectionListener>();
+
+    /**
+     * Add a listener to be notified about any network changes.
+     * This method is thread safe.
+     * <p>
+     * IMPORTANT: Not removing it again will result in major leaks.
+     *
+     * @param listener the listener.
+     */
+    public static void addListener(ConnectionListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a network listener.
+     * This method is thread safe.
+     *
+     * @param listener the listener.
+     */
+    public static synchronized void removeListener(ConnectionListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Attempt to detect if a device is online and can transmit or receive data.
+     * This method is thread safe.
+     * <p>
+     * An emulator is always considered online, as `getActiveNetworkInfo()` does not report the correct value.
+     *
+     * @param context an Android context.
+     * @return {@code true} if device is online, otherwise {@code false}.
+     */
+    public static boolean isOnline(Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo networkInfo = cm.getActiveNetworkInfo();
+        return ((networkInfo != null && networkInfo.isConnectedOrConnecting()) || Util.isEmulator());
+    }
+
+
+    public void onReceive(Context context, Intent intent) {
+        boolean connected = isOnline(context);
+        for (ConnectionListener listener : listeners) {
+            listener.onChange(connected);
+        }
+    }
+
+    public interface ConnectionListener {
+        void onChange(boolean connectionAvailable);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
new file mode 100644
index 0000000000..c84d408a12
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.SyncCredentials;
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.SyncUser;
+import io.realm.internal.objectserver.Token;
+import okhttp3.Call;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+public class OkHttpAuthenticationServer implements AuthenticationServer {
+
+    public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
+
+    private final OkHttpClient client = new OkHttpClient.Builder()
+            .connectTimeout(10, TimeUnit.SECONDS)
+            .writeTimeout(10, TimeUnit.SECONDS)
+            .readTimeout(30, TimeUnit.SECONDS)
+            .build();
+
+    /**
+     * Authenticate the given credentials on the specified Realm Authentication Server.
+     */
+    @Override
+    public AuthenticateResponse loginUser(SyncCredentials credentials, URL authenticationUrl) {
+        try {
+            String requestBody = AuthenticateRequest.userLogin(credentials).toJson();
+            return authenticate(authenticationUrl, requestBody);
+        } catch (Exception e) {
+            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    @Override
+    public AuthenticateResponse loginToRealm(Token refreshToken, URI serverUrl, URL authenticationUrl) {
+        try {
+            String requestBody = AuthenticateRequest.realmLogin(refreshToken, serverUrl).toJson();
+            return authenticate(authenticationUrl, requestBody);
+        } catch (Exception e) {
+            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    @Override
+    public AuthenticateResponse refreshUser(Token userToken, URL authenticationUrl) {
+        try {
+            String requestBody = AuthenticateRequest.userRefresh(userToken).toJson();
+            return authenticate(authenticationUrl, requestBody);
+        } catch (Exception e) {
+            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+        }
+    }
+
+    @Override
+    public LogoutResponse logout(SyncUser user, URL authenticationUrl) {
+        throw new UnsupportedOperationException("Not yet implemented");
+    }
+
+    private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
+        Request request = new Request.Builder()
+                .url(authenticationUrl)
+                .addHeader("Content-Type", "application/json")
+                .addHeader("Accept", "application/json")
+                .addHeader("Connection", "close") //  See https://github.com/square/okhttp/issues/2363
+                .post(RequestBody.create(JSON, requestBody))
+                .build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return AuthenticateResponse.from(response);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java
new file mode 100644
index 0000000000..9ca21ecf9e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+import io.realm.SessionState;
+import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.log.RealmLog;
+
+/**
+ * AUTHENTICATING State. This step is needed if the user does not have proper access or credentials to access the
+ * Realm when attempting to bind it. Reasons for not having proper access or invalid credentials include:
+ *
+ * <ol>
+ *     <li>
+ *          <b>Refresh token has expired:</b>
+ *          This effectively means the user has been logged out from the Realm Object Server and credentials have
+ *          to be re-verified by the Authentication Server. Since verification involves creating a new User object,
+ *          this session will be stopped and an error reported.
+ *     </li>
+ *     <li>
+ *          <b>Access token has expired:</b>
+ *          In this case, the token is automatically refreshed and will retry binding the Realm.
+ *     </li>
+ *     <li>
+ *          <b>Access token does not exist:</b>
+ *          This state means the user has logged in, but not yet gained a specific access token for the Realm.
+ *          The access token will automatically be fetched and binding the Realm is retried.
+ *      </li>
+ * </ol>
+ */
+class AuthenticatingState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        if (NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {
+            authenticate(session);
+        } else {
+            // Wait for connection to become available, before trying again.
+            // The Session might potentially stay in this state for the lifetime of the application.
+            // This is acceptable.
+            session.networkListener = new NetworkStateReceiver.ConnectionListener() {
+                @Override
+                public void onChange(boolean connectionAvailable) {
+                    if (connectionAvailable) {
+                        authenticate(session);
+                        NetworkStateReceiver.removeListener(this);
+                    }
+                }
+            };
+            NetworkStateReceiver.addListener(session.networkListener);
+        }
+    }
+
+    @Override
+    public void onExitState() {
+        // Abort any current network request.
+        if (session.networkRequest != null) {
+            session.networkRequest.cancel();
+            session.networkRequest = null;
+        }
+
+        // Release listener if we were waiting for network to become available.
+        if (session.networkListener != null) {
+            NetworkStateReceiver.removeListener(session.networkListener);
+            session.networkListener = null;
+        }
+    }
+
+    @Override
+    public void onBind() {
+        gotoNextState(SessionState.BINDING); // Equivalent to forcing a retry
+    }
+
+    @Override
+    public void onUnbind() {
+        gotoNextState(SessionState.UNBOUND); // Treat this as user wanting to exit a binding in progress.
+    }
+
+    @Override
+    public void onStop() {
+        gotoNextState(SessionState.STOPPED);
+    }
+
+    private synchronized void authenticate(final ObjectServerSession session) {
+        session.authenticateRealm(new Runnable() {
+            @Override
+            public void run() {
+                RealmLog.debug("Session[%s]: Access token acquired", session.getConfiguration().getPath());
+                gotoNextState(SessionState.BINDING);
+            }
+        }, new SyncSession.ErrorHandler() {
+            @Override
+            public void onError(SyncSession s, ObjectServerError error) {
+                RealmLog.debug("Session[%s]: Failed to get access token (%d)", session.getConfiguration().getPath(), error.getErrorCode());
+                session.onError(error);
+            }
+        });
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java
new file mode 100644
index 0000000000..fbd3a14f5b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * BINDING State. After {@code bind()} is called, the state will attempt to bind the local Realm to the remote. This is an
+ * asynchronous operation which must be interruptible.
+ */
+class BindingState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        if (session.isAuthenticated(session.configuration)) {
+            // FIXME How to handle errors?
+            session.bindWithTokens();
+            gotoNextState(SessionState.BOUND);
+        } else {
+            // Not access token available. We need to authenticateUser first.
+            gotoNextState(SessionState.AUTHENTICATING);
+        }
+    }
+
+    @Override
+    public void onExitState() {
+        // TODO Abort any async stuff going on, possible in `session.bindWithTokens()`
+    }
+
+    @Override
+    public void onBind() {
+        gotoNextState(SessionState.BINDING); // Will trigger a retry.
+    }
+
+    @Override
+    public void onUnbind() {
+        gotoNextState(SessionState.UNBOUND);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors. This is just a transient state. We are not bound yet, and any error should not
+        // happen until we are BOUND.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
new file mode 100644
index 0000000000..a941440867
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * BOUND State. In this state the local Realm is bound to the remote Realm and changes are sent in both
+ * directions immediately.
+ */
+class BoundState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        // Do nothing. If everything is setup correctly. We should now be synchronizing any changes
+        // between the local and remote Realm.
+    }
+
+    @Override
+    public void onExitState() {
+        // Do nothing. Entry states will stop the session if needed.
+    }
+
+    @Override
+    public void onUnbind() {
+        gotoNextState(SessionState.UNBOUND);
+    }
+
+    @Override
+    public void onStop() {
+        gotoNextState(SessionState.STOPPED);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // If a Realms access token has expired, trigger a rebind. If the user is still valid it will automatically
+        // refresh it.
+        if (error.getErrorCode() == ErrorCode.TOKEN_EXPIRED) {
+            gotoNextState(SessionState.BINDING);
+        } else {
+            switch (error.getCategory()) {
+                case FATAL: gotoNextState(SessionState.STOPPED); break;
+                case RECOVERABLE: gotoNextState(SessionState.UNBOUND); break;
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
similarity index 52%
rename from realm/realm-library/src/main/java/io/realm/internal/log/Logger.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
index 50eba1905c..a4af906d3b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,20 +14,22 @@
  * limitations under the License.
  */
 
-package io.realm.internal.log;
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
 
 /**
- * Interface for Realm logger implementations.
+ * As {@link SyncSession} is modeled as a state machine, this interface describe all
+ * possible actions in that machine.
+ * <p>
+ * All states should implement this interface so all possible permutations of state/actions are covered.
+ *
  */
-public interface Logger {
-    void v(String message);
-    void v(String message, Throwable t);
-    void d(String message);
-    void d(String message, Throwable t);
-    void i(String message);
-    void i(String message, Throwable t);
-    void w(String message);
-    void w(String message, Throwable t);
-    void e(String message);
-    void e(String message, Throwable t);
+interface FsmAction {
+    void onStart();
+    void onBind();
+    void onUnbind();
+    void onStop();
+    void onError(ObjectServerError error);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java
new file mode 100644
index 0000000000..ee4089a848
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.SyncSession;
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * Abstract class containing shared logic for all {@link SyncSession} states. All states must extend
+ * this class as it contains the logic for entering and leaving states.
+ */
+abstract class FsmState implements FsmAction {
+
+    volatile ObjectServerSession session; // This is non-null when this state is active.
+    private boolean exiting; // TODO: Remind me again what race condition necessitated this.
+
+    /**
+     * Entry into the state. This method is also responsible for executing any asynchronous work
+     * this state might run.
+     *
+     * This should only be called from {@link SyncSession}.
+     */
+    public void entry(ObjectServerSession session) {
+        this.session = session;
+        this.exiting = false;
+        onEnterState();
+    }
+
+    /**
+     * Called just before leaving the state. Once this method is called no more state changes can be triggered from
+     * this state until {@link #entry(ObjectServerSession)} has been called again.
+     * <p>
+     * This should only be called from {@link SyncSession}.
+     */
+    public void exit() {
+        exiting = true;
+        onExitState();
+    }
+
+    public void gotoNextState(SessionState state) {
+        if (!exiting) {
+            session.nextState(state);
+        }
+    }
+
+    protected abstract void onEnterState();
+    protected abstract void onExitState();
+
+    @Override
+    public void onStart() {
+        // Do nothing
+    }
+
+    @Override
+    public void onBind() {
+        // Do nothing
+    }
+
+    @Override
+    public void onUnbind() {
+        // Do nothing
+    }
+
+    @Override
+    public void onStop() {
+        // Do nothing
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        switch(error.getCategory()) {
+            case FATAL:
+                gotoNextState(SessionState.STOPPED);
+                break;
+            case RECOVERABLE:
+                gotoNextState(SessionState.UNBOUND);
+                break;
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java
new file mode 100644
index 0000000000..ed13957250
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * INITIAL State. Starting point for the Session Finite-State-Machine.
+ */
+class InitialState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        // Do nothing. We start here
+    }
+
+    @Override
+    protected void onExitState() {
+        // Do nothing. Right now the underlying Realm Core session cannot bound/unbind multiple times, so instead
+        // we create a new session object each time the Session becomes unbound.
+    }
+
+    @Override
+    public void onStart() {
+        gotoNextState(SessionState.UNBOUND);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors at this state. None of them would have any impact.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
new file mode 100644
index 0000000000..a0e4802df3
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
@@ -0,0 +1,365 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import java.net.URI;
+import java.util.HashMap;
+import java.util.concurrent.Future;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.RealmAsyncTask;
+import io.realm.SyncSession;
+import io.realm.SessionState;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncUser;
+import io.realm.internal.KeepMember;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ExponentialBackoffTask;
+import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.internal.syncpolicy.SyncPolicy;
+import io.realm.log.RealmLog;
+
+/**
+ * Internal class describing a Realm Object Server Session.
+ * There is currently a split between the public {@link SyncSession} and this class.
+ * This class is intended as a wrapper for Object Store's Sync Session, but it is not that yet.
+ * <p>
+ * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
+ * a Realm instance. Once a session has been created, it will continue to exist until explicitly closed or the
+ * underlying Realm file is deleted.
+ * <p>
+ * It is typically not necessary to interact directly with a session. The interaction should be done by the {@code SyncPolicy}
+ * defined using {@code io.realm.SyncConfiguration.Builder#syncPolicy(SyncPolicy)}.
+ * <p>
+ * A session has a lifecycle consisting of the following states:
+ * <p>
+ * <dl>
+ * <li>
+ *     <b>INITIAL</b> Initial state when creating the Session object. No connections to the object server have been
+ *     created yet. At this point it is possible to register any relevant error and event listeners. Calling
+ *     {@link #start()} will cause the session to become <b>UNBOUND</b> and notify the {@code SyncPolicy} that the
+ *     session is ready by calling {@code SyncPolicy#onSessionCreated(Session)}.
+ * </li>
+ * <li>
+ *     <b>UNBOUND</b> When a session is unbound, no synchronization between the local and remote Realm is taking place.
+ *     Call {@link #bind()} to start synchronizing changes.
+ * </li>
+ * <li>
+ *     <b>BINDING</b> A session is in the process of binding a local Realm to a remote one. Calling {@link #unbind()}
+ *     at this stage, will cancel the process. If binding fails, the session will revert to being INBOUND and an error
+ *     will be reported to the error handler.
+ * </li>
+ * <li>
+ *     <b>AUTHENTICATING</b> During binding, if a users access has expired, the session will be <b>AUTHENTICATING</b>.
+ *     During this state, Realm will automatically try to acquire new valid credentials. If it succeed <b>BINDING</b>
+ *     will automatically be resumed, if not, the session will become <b>UNBOUND</b> or <b>STOPPED</b> and an
+ *     appropriate error reported.
+ * </li>
+ * <li>
+ *     <b>BOUND</b> A bound session has an active connection to the remote Realm and will synchronize any changes
+ *     immediately.
+ * </li>
+ * <li>
+ *     <b>STOPPED</b> The session are in an unrecoverable state. Check the error log for additional information, but
+ *     the type of errors is usually wrong credentials for the Realm being accessed or a mismatching Object Server.
+ *     Most problems can be solved by creating a new {@link SyncConfiguration} with a new {@code serverUrl} and
+ *     {@code user}.
+ * </li>
+ * </dl>
+ *
+ * This object is thread safe.
+ */
+@KeepMember
+public final class ObjectServerSession {
+
+    private final HashMap<SessionState, FsmState> FSM = new HashMap<SessionState, FsmState>();
+
+    // Variables used by the FSM
+    final SyncConfiguration configuration;
+    private final AuthenticationServer authServer;
+    private final SyncSession.ErrorHandler errorHandler;
+    private long nativeSessionPointer;
+    private final ObjectServerUser user;
+    RealmAsyncTask networkRequest;
+    NetworkStateReceiver.ConnectionListener networkListener;
+    private SyncPolicy syncPolicy;
+
+    // Keeping track of current FSM state
+    private SessionState currentStateDescription;
+    private FsmState currentState;
+    private SyncSession userSession;
+    private SyncSession publicSession;
+
+    /**
+     * Creates a new Object Server Session.
+     *
+     * @param syncConfiguration Sync configuration defining this session
+     * @param authServer Authentication server used to refresh credentials if needed
+     * @param policy Sync Policy to use by this Session.
+     */
+    public ObjectServerSession(SyncConfiguration syncConfiguration,
+                               AuthenticationServer authServer,
+                               ObjectServerUser user,
+                               SyncPolicy policy,
+                               SyncSession.ErrorHandler errorHandler) {
+        this.configuration = syncConfiguration;
+        this.user = user;
+        this.authServer = authServer;
+        this.errorHandler = errorHandler;
+        this.syncPolicy = policy;
+        setupStateMachine();
+    }
+
+    private void setupStateMachine() {
+        FSM.put(SessionState.INITIAL, new InitialState());
+        FSM.put(SessionState.UNBOUND, new UnboundState());
+        FSM.put(SessionState.BINDING, new BindingState());
+        FSM.put(SessionState.AUTHENTICATING, new AuthenticatingState());
+        FSM.put(SessionState.BOUND, new BoundState());
+        FSM.put(SessionState.STOPPED, new StoppedState());
+        RealmLog.debug("Session started: " + configuration.getServerUrl());
+        currentState = FSM.get(SessionState.INITIAL);
+        currentState.entry(this);
+    }
+
+    // Goto the next state. The FsmState classes are responsible for calling this method as a reaction to a FsmAction
+    // being called or an internal action triggering a state transition.
+    void nextState(SessionState nextStateDescription) {
+        currentState.exit();
+        FsmState nextState = FSM.get(nextStateDescription);
+        if (nextState == null) {
+            throw new IllegalStateException("No state was configured to handle: " + nextStateDescription);
+        }
+        RealmLog.debug("Session[%s]: %s -> %s", configuration.getServerUrl(), currentStateDescription, nextStateDescription);
+        currentStateDescription = nextStateDescription;
+        currentState = nextState;
+        nextState.entry(this);
+    }
+
+    /**
+     * Starts the session. This will cause the session to come <b>UNBOUND</b>. {@link #bind()} must be called to
+     * actually start synchronizing data.
+     */
+    public synchronized void start() {
+        currentState.onStart();
+    }
+
+    /**
+     * Stops the session. The session can no longer be used.
+     */
+    public synchronized void stop() {
+        currentState.onStop();
+    }
+
+    /**
+     * Binds the local Realm to the remote Realm. Once bound, changes to either the local or Remote Realm will be
+     * synchronized immediately.
+     * <p>
+     * While this method will return immediately, binding a Realm is not guaranteed to succeed. Possible reasons for
+     * failure could be if the device is offline or credentials have expired. Binding is an asynchronous
+     * operation and all errors will be sent first to {@code SyncPolicy#onError(Session, ObjectServerError)} and if the
+     * SyncPolicy doesn't handle it, to the {@link SyncSession.ErrorHandler} defined by
+     * {@link SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)}.
+     */
+    public synchronized void bind() {
+        currentState.onBind();
+    }
+
+    /**
+     * Stops a local Realm from synchronizing changes with the remote Realm.
+     * <p>
+     * It is possible to call {@link #bind()} again after a Realm has been unbound.
+     */
+    public synchronized void unbind() {
+        currentState.onUnbind();
+    }
+
+    /**
+     * Notify the session that an error has occurred.
+     *
+     * @param error the kind of err
+     */
+    public synchronized void onError(ObjectServerError error) {
+        currentState.onError(error); // FSM needs to respond to the error first, before notifying the User
+        if (errorHandler != null) {
+            errorHandler.onError(getUserSession(), error);
+        }
+    }
+
+    // Called from JniSession in native code.
+    // This callback will happen on the thread running the Sync Client.
+    @SuppressWarnings("unused")
+    @KeepMember
+    private void notifySessionError(int errorCode, String errorMessage) {
+        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
+        onError(error);
+    }
+
+    /**
+     * Checks if the local Realm is bound to the remote Realm and can synchronize any changes happening on either
+     * sides.
+     *
+     * @return {@code true} if the local Realm is bound to the remote Realm, {@code false} otherwise.
+     */
+    boolean isBound() {
+        return currentStateDescription == SessionState.BOUND;
+    }
+
+    //
+    // Package protected methods used by the FSM states to manipulate session variables.
+    //
+
+    // Create a native session. The session abstraction in Realm Core doesn't support multiple calls to bind()/unbind()
+    // yet, so the Java SyncSession must manually create/and close the native sessions as needed.
+    void createNativeSession() {
+        nativeSessionPointer = nativeCreateSession(configuration.getPath());
+    }
+
+    void stopNativeSession() {
+        if (nativeSessionPointer != 0) {
+            nativeUnbind(nativeSessionPointer);
+            nativeSessionPointer = 0;
+        }
+    }
+
+    // Bind with proper access tokens
+    // Access tokens are presumed to be present and valid at this point
+    void bindWithTokens() {
+        Token accessToken = user.getAccessToken(configuration.getServerUrl());
+        if (accessToken == null) {
+            throw new IllegalStateException("User '" + user.toString() + "' does not have an access token for "
+                    + configuration.getServerUrl());
+        }
+        nativeBind(nativeSessionPointer, configuration.getServerUrl().toString(), accessToken.value());
+    }
+
+    // Authenticate by getting access tokens for the specific Realm
+    void authenticateRealm(final Runnable onSuccess, final SyncSession.ErrorHandler errorHandler) {
+        if (networkRequest != null) {
+            networkRequest.cancel();
+        }
+        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
+        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
+            @Override
+            protected AuthenticateResponse execute() {
+                return authServer.loginToRealm(
+                        user.getUserToken(),
+                        configuration.getServerUrl(),
+                        user.getAuthenticationUrl()
+                );
+            }
+
+            @Override
+            protected void onSuccess(AuthenticateResponse response) {
+                ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
+                        response.getAccessToken(),
+                        configuration.getPath(),
+                        configuration.shouldDeleteRealmOnLogout()
+                );
+                user.addRealm(configuration.getServerUrl(), desc);
+                onSuccess.run();
+            }
+
+            @Override
+            protected void onError(AuthenticateResponse response) {
+                errorHandler.onError(getUserSession(), response.getError());
+            }
+        });
+        networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
+    }
+
+    /**
+     * Checks if a user has valid credentials for accessing this Realm.
+     *
+     * @param configuration the configuration.
+     * @return {@code true} if credentials are valid, {@code false} otherwise.
+     */
+    boolean isAuthenticated(SyncConfiguration configuration) {
+        return user.isAuthenticated(configuration);
+    }
+
+    /**
+     * Returns the {@link SyncConfiguration} that is responsible for controlling this session.
+     *
+     * @return SyncConfiguration that defines and controls this session.
+     */
+    public SyncConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    /**
+     * Returns the {@link SyncUser} defined by the {@link SyncConfiguration} that is used to connect to the
+     * Realm Object Server.
+     *
+     * @return {@link SyncUser} used to authenticate the session on the Realm Object Server.
+     */
+    public SyncUser getUser() {
+        return configuration.getUser();
+    }
+
+    /**
+     * Returns the {@link URI} describing the remote Realm this session connects to and synchronizes changes with.
+     *
+     * @return {@link URI} describing the remote Realm.
+     */
+    public URI getServerUrl() {
+        return configuration.getServerUrl();
+    }
+
+    /**
+     * Returns the state of this session.
+     *
+     * @return The current {@link SessionState} for this session.
+     */
+    public SessionState getState() {
+        return currentStateDescription;
+    }
+
+    /**
+     * Notify session that a commit on the device has happened.
+     *
+     * @param version the commit number/version.
+     */
+    public void notifyCommit(long version) {
+        if (isBound()) {
+            nativeNotifyCommitHappened(nativeSessionPointer, version);
+        }
+    }
+
+    public SyncPolicy getSyncPolicy() {
+        return syncPolicy;
+    }
+
+    public SyncSession getUserSession() {
+        return userSession;
+    }
+
+    public void setUserSession(SyncSession userSession) {
+        this.userSession = userSession;
+    }
+
+    private native long nativeCreateSession(String localRealmPath);
+    private native void nativeBind(long nativeSessionPointer, String remoteRealmUrl, String userToken);
+    private native void nativeUnbind(long nativeSessionPointer);
+    private native void nativeRefresh(long nativeSessionPointer, String userToken);
+    private native void nativeNotifyCommitHappened(long sessionPointer, long version);
+}
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
new file mode 100644
index 0000000000..f74c9dd0a9
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.realm.SyncSession;
+import io.realm.SyncConfiguration;
+
+/**
+ * Internal representation of a user on the Realm Object Server.
+ * The public API is defined by {@link io.realm.SyncUser}.
+ */
+public class ObjectServerUser {
+
+    private final String identity;
+    private Token refreshToken;
+    private URL authenticationUrl;
+    private Map<URI, AccessDescription> realms = new HashMap<URI, AccessDescription>();
+    private List<SyncSession> sessions = new ArrayList<SyncSession>();
+    private boolean loggedIn;
+
+    /**
+     * Create a new Realm Object Server User
+     */
+    public ObjectServerUser(Token refreshToken, URL authenticationUrl) {
+        this.identity = refreshToken.identity();
+        this.authenticationUrl = authenticationUrl;
+        setRefreshToken(refreshToken);
+        this.loggedIn = true;
+    }
+
+    public void setRefreshToken(final Token refreshToken) {
+        this.refreshToken = refreshToken; // Replace any existing token. TODO re-save the user with latest token.
+    }
+
+    /**
+     * Checks if the user has access to the given Realm. Being authenticated means that the
+     * user is know by the Realm Object Server and have been granted access to the given Realm.
+     *
+     * Authenticating will happen automatically as part of opening a Realm.
+     */
+    public boolean isAuthenticated(SyncConfiguration configuration) {
+        Token token = getAccessToken(configuration.getServerUrl());
+        return token != null && token.expiresMs() > System.currentTimeMillis();
+    }
+
+    public String toJson() {
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("authUrl", authenticationUrl);
+            obj.put("userToken", refreshToken.toJson());
+            JSONArray realmList = new JSONArray();
+            for (Map.Entry<URI, AccessDescription> entry : realms.entrySet()) {
+                JSONObject token = new JSONObject();
+                token.put("uri", entry.getKey().toString());
+                token.put("description", entry.getValue().toJson());
+                realmList.put(token);
+            }
+            obj.put("realms", realmList);
+            return obj.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException("Could not convert User to JSON", e);
+        }
+    }
+
+    public String getIdentity() {
+        return identity;
+    }
+
+    public Token getAccessToken(URI serverUrl) {
+        AccessDescription accessDescription = realms.get(serverUrl);
+        return (accessDescription != null) ? accessDescription.accessToken : null;
+    }
+
+    public void addRealm(URI uri, AccessDescription description) {
+        realms.put(uri, description);
+    }
+
+    // When a session is started, add it to the user so it can be tracked
+    public void addSession(SyncSession session) {
+        sessions.add(session);
+    }
+
+    /**
+     * Adds an access token to this user.
+     * <p>
+     * An access token is a token granting access to one remote Realm. Access Tokens are normally fetched transparently
+     * when opening a Realm, but using this method it is possible to add tokens upfront if they have been fetched or
+     * created manually.
+     *
+     * @param uri {@link java.net.URI} pointing to a remote Realm.
+     * @param accessToken
+     */
+    public void addRealm(URI uri, String accessToken, String localPath, boolean deleteOnLogout) {
+        if (uri == null || accessToken == null) {
+            throw new IllegalArgumentException("Non-null 'uri' and 'accessToken' required.");
+        }
+        uri = SyncUtil.getFullServerUrl(uri, identity);
+
+        // Optimistically create a long-lived token with all permissions. If this is incorrect the Object Server
+        // will reject it anyway. If tokens are added manually it is up to the user to ensure they are also used
+        // correctly.
+        Token token = new Token(accessToken, null, uri.toString(), Long.MAX_VALUE, Token.Permission.values());
+        addRealm(uri, new AccessDescription(token, localPath, deleteOnLogout));
+    }
+
+    public URL getAuthenticationUrl() {
+        return authenticationUrl;
+    }
+
+    public Token getUserToken() {
+        return refreshToken;
+    }
+
+    public List<SyncSession> getSessions() {
+        return sessions;
+    }
+
+    public void clearTokens() {
+        realms.clear();
+        refreshToken = null;
+    }
+
+    public boolean isLoggedIn() {
+        return loggedIn;
+    }
+
+    // Local Logout means that the user is no longer able to create new sync configurations,
+    // nor synchronize changes
+    public void localLogout() {
+        loggedIn = false;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ObjectServerUser syncUser = (ObjectServerUser) o;
+
+        if (!identity.equals(syncUser.identity)) return false;
+        if (!refreshToken.equals(syncUser.refreshToken)) return false;
+        if (!authenticationUrl.toString().equals(syncUser.authenticationUrl.toString())) return false;
+        return realms.equals(syncUser.realms);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = identity.hashCode();
+        result = 31 * result + refreshToken.hashCode();
+        result = 31 * result + authenticationUrl.toString().hashCode();
+        result = 31 * result + realms.hashCode();
+        return result;
+    }
+
+    public Collection<AccessDescription> getRealms() {
+        return realms.values();
+    }
+
+    // Wrapper for all Realm data needed by a User that might get serialized.
+    public static class AccessDescription {
+        public Token accessToken;
+        public String localPath;
+        public boolean deleteOnLogout;
+
+        public AccessDescription(Token accessToken, String localPath, boolean deleteOnLogout) {
+            this.accessToken = accessToken;
+            this.localPath = localPath;
+            this.deleteOnLogout = deleteOnLogout;
+        }
+
+        public static AccessDescription fromJson(JSONObject json) {
+            try {
+                Token token = Token.from(json.getJSONObject("accessToken"));
+                String localPath = json.getString("localPath");
+                boolean deleteOnLogout = json.getBoolean("deleteOnLogout");
+                return new AccessDescription(token, localPath, deleteOnLogout);
+            } catch (JSONException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        public JSONObject toJson() {
+            try {
+                JSONObject obj = new JSONObject();
+                obj.put("accessToken", accessToken.toJson());
+                obj.put("localPath", localPath);
+                obj.put("deleteOnLogout", deleteOnLogout);
+                return obj;
+            } catch (JSONException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            AccessDescription that = (AccessDescription) o;
+
+            if (deleteOnLogout != that.deleteOnLogout) return false;
+            if (!accessToken.equals(that.accessToken)) return false;
+            return localPath.equals(that.localPath);
+
+        }
+
+        @Override
+        public int hashCode() {
+            int result = accessToken.hashCode();
+            result = 31 * result + localPath.hashCode();
+            result = 31 * result + (deleteOnLogout ? 1 : 0);
+            return result;
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java
new file mode 100644
index 0000000000..a40fe01fd1
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import io.realm.SyncSession;
+import io.realm.SyncManager;
+import io.realm.SyncConfiguration;
+
+/**
+ * Private class for keeping track of sessions.
+ * If {@link SyncSession} and {@link ObjectServerSession} are combined at some point, this class can
+ * be folded into {@link SyncManager};
+ */
+public class SessionStore {
+
+    // Map of between a local Realm path and any associated sessionInfo
+    private static HashMap<String, SyncSession> sessions = new HashMap<String, SyncSession>();
+    private static HashMap<String, ObjectServerSession> privateSessions = new HashMap<String, ObjectServerSession>();
+
+    static synchronized void removeSession(SyncSession session) {
+        if (session == null) {
+            return;
+        }
+
+        Iterator<Map.Entry<String, SyncSession>> it = sessions.entrySet().iterator();
+        while (it.hasNext()) {
+            Map.Entry<String, SyncSession> entry = it.next();
+            if (entry.getValue().equals(session)) {
+                it.remove();
+                break;
+            }
+        }
+    }
+
+    public static synchronized void addSession(SyncSession publicSession, ObjectServerSession internalSession) {
+        String localPath = publicSession.getConfiguration().getPath();
+        sessions.put(localPath, publicSession);
+        privateSessions.put(localPath, internalSession);
+    }
+
+    public static synchronized boolean hasSession(SyncConfiguration config) {
+        String localPath = config.getPath();
+        return sessions.containsKey(localPath);
+    }
+
+    public static synchronized SyncSession getPublicSession(SyncConfiguration config) {
+        String localPath = config.getPath();
+        return sessions.get(localPath);
+    }
+
+    public static synchronized ObjectServerSession getPrivateSession(SyncSession session) {
+        String localPath = session.getConfiguration().getPath();
+        return privateSessions.get(localPath);
+    }
+
+    public static Collection<ObjectServerSession> getAllSessions() {
+        return privateSessions.values();
+    }
+
+}
+
+
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java
new file mode 100644
index 0000000000..f1b58008b0
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+
+/**
+ * STOPPED State. This is the final state for a {@link SyncSession}. After this, all actions will throw an
+ * {@link IllegalStateException}.
+ */
+class StoppedState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        session.stopNativeSession();
+        session.getSyncPolicy().onSessionStopped(session);
+    }
+
+    @Override
+    protected void onExitState() {
+        // Cannot exit this state
+    }
+
+    @Override
+    public void onStart() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onBind() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onUnbind() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onStop() {
+        // To harsh to to throw here as any SyncPolicy might not have been made aware
+        // that the Session is stopped. Just ignore the call instead.
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors at this state. None of them would have any impact.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java
new file mode 100644
index 0000000000..63e18261d4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import io.realm.RealmConfiguration;
+import io.realm.SyncSession;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.Keep;
+import io.realm.internal.ObjectServerFacade;
+import io.realm.internal.network.NetworkStateReceiver;
+
+@SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
+@Keep
+public class SyncObjectServerFacade extends ObjectServerFacade {
+
+    private static final String WRONG_TYPE_OF_CONFIGURATION =
+            "'configuration' has to be an instance of 'SyncConfiguration'.";
+    @SuppressLint("StaticFieldLeak") //
+    private static Context applicationContext;
+
+    @Override
+    public void init(Context context) {
+        // Trying to keep things out the public API is no fun :/
+        // Just use reflection on init. It is a one-time method call so should be acceptable.
+        //noinspection TryWithIdenticalCatches
+        try {
+            // FIXME: Reflection can be avoided by moving some functions of SyncManager and ObjectServer out of public
+            Class<?> syncManager = Class.forName("io.realm.ObjectServer");
+            Method method = syncManager.getDeclaredMethod("init", Context.class);
+            method.setAccessible(true);
+            method.invoke(null, context);
+        } catch (NoSuchMethodException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        } catch (ClassNotFoundException e) {
+            throw new RealmException("Could not initialize the Realm Object Server", e);
+        }
+        if (applicationContext == null) {
+            applicationContext = context;
+
+            applicationContext.registerReceiver(new NetworkStateReceiver(),
+                    new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
+        }
+    }
+
+    @Override
+    public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
+            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
+            session.notifyCommit(lastSnapshotVersion);
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public void realmClosed(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
+            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
+            session.getSyncPolicy().onRealmClosed(session);
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public void realmOpened(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
+            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
+            session.getSyncPolicy().onRealmOpened(session);
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public String[] getUserAndServerUrl(RealmConfiguration config) {
+        if (config instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) config;
+            String rosServerUrl = syncConfig.getServerUrl().toString();
+            String rosUserToken = syncConfig.getUser().getAccessToken();
+            return new String[]{rosServerUrl, rosUserToken};
+        } else {
+            return new String[2];
+        }
+    }
+
+    static Context getApplicationContext() {
+        return applicationContext;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
new file mode 100644
index 0000000000..9d6b8f1e23
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Helper class for Object Server classes.
+ */
+public class SyncUtil {
+
+    /**
+     * Fully resolve an URL so all placeholder objects are replaced with the user identity.
+     */
+    public static URI getFullServerUrl(URI serverUrl, String userIdentity) {
+        try {
+            return new URI(serverUrl.toString().replace("/~/", "/" + userIdentity + "/"));
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not replace '/~/' with a valid user ID.", e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
new file mode 100644
index 0000000000..78f0acfb04
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Arrays;
+import java.util.Locale;
+
+/**
+ * This class represents a value from the Realm Authentication Server.
+ */
+public class Token {
+
+    private final String value;
+    private final long expiresSec;
+    private final Permission[] permissions;
+    private final String identity;
+    private final String path;
+
+    public static Token from(JSONObject token) throws JSONException {
+        String value = token.getString("token");
+        JSONObject tokenData = token.getJSONObject("token_data");
+        String identity = tokenData.getString("identity");
+        String path = tokenData.optString("path");
+        long expiresSec = tokenData.getLong("expires");
+        Permission[] permissions;
+        JSONArray access = tokenData.getJSONArray("access");
+        if (access != null) {
+            permissions = new Permission[access.length()];
+            for (int i = 0; i < access.length(); i++) {
+                try {
+                    permissions[i] = Permission.valueOf(access.getString(i));
+                } catch (IllegalArgumentException e) {
+                    permissions[i] = Permission.UNKNOWN;
+                }
+            }
+        } else {
+            permissions = new Permission[0];
+        }
+
+        return new Token(value, identity, path, expiresSec, permissions);
+    }
+
+    public Token(String value, String identity, String path, long expiresSec, Permission[] permissions) {
+        this.value = value;
+        this.identity = identity;
+        this.path = path;
+        this.expiresSec = expiresSec;
+        if (permissions != null) {
+            this.permissions = Arrays.copyOf(permissions, permissions.length);
+        } else {
+            this.permissions = new Permission[0];
+        }
+    }
+
+    public String value() {
+        return value;
+    }
+
+    public String identity() { return identity; }
+
+    public String path() { return path; }
+
+    /**
+     * Returns when this token expires. Timestamp is in UTC seconds.
+     */
+    public long expiresSec() {
+        return expiresSec;
+    }
+
+    /**
+     * Returns when this token expires. Timestamp is in UTC milliseconds.
+     */
+    public long expiresMs() {
+        long expiresMs = expiresSec * 1000;
+        if (expiresMs < expiresSec) {
+            return Long.MAX_VALUE; // Prevent overflow
+        } else {
+            return expiresMs;
+        }
+    }
+
+    public Permission[] permissions() {
+        return Arrays.copyOf(permissions, permissions.length);
+    }
+
+    public JSONObject toJson() {
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("token", value);
+            JSONObject tokenData = new JSONObject();
+            tokenData.put("identity", identity);
+            tokenData.put("path", path);
+            tokenData.put("expires", expiresSec);
+            JSONArray perms = new JSONArray();
+            for (int i = 0; i < permissions.length; i++) {
+                perms.put(permissions[i].toString().toLowerCase(Locale.US));
+            }
+            tokenData.put("access", perms);
+            obj.put("token_data", tokenData);
+            return obj;
+        } catch (JSONException e) {
+            throw new RuntimeException("Could not convert Token to JSON.", e);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Token token = (Token) o;
+
+        if (expiresSec != token.expiresSec) return false;
+        if (!value.equals(token.value)) return false;
+        if (!Arrays.equals(permissions, token.permissions)) return false;
+        if (!identity.equals(token.identity)) return false;
+        return path != null ? path.equals(token.path) : token.path == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = value.hashCode();
+        result = 31 * result + (int) (expiresSec ^ (expiresSec >>> 32));
+        result = 31 * result + Arrays.hashCode(permissions);
+        result = 31 * result + identity.hashCode();
+        result = 31 * result + (path != null ? path.hashCode() : 0);
+        return result;
+    }
+
+    public enum Permission {
+        UNKNOWN,
+        UPLOAD,
+        DOWNLOAD,
+        REFRESH,
+        MANAGE;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java
new file mode 100644
index 0000000000..3471357544
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.objectserver;
+
+import io.realm.ObjectServerError;
+import io.realm.SessionState;
+
+/**
+ * UNBOUND State. This is the default state after a session has been started and no attempt at binding the local Realm
+ * has been made.
+ */
+class UnboundState extends FsmState {
+
+    @Override
+    public void onEnterState() {
+        // We can enter this state from multiple states which might have had an active session.
+        // In those cases cleanup any old native session
+        session.stopNativeSession();
+
+        // Create the native session so it is ready to be bound.
+        session.createNativeSession();
+    }
+
+    @Override
+    protected void onExitState() {
+        // Do nothing.
+    }
+
+    @Override
+    public void onBind() {
+        gotoNextState(SessionState.BINDING);
+    }
+
+    @Override
+    public void onError(ObjectServerError error) {
+        // Ignore all errors at this state. None of them would have any impact.
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java
new file mode 100644
index 0000000000..6f4b784181
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.syncpolicy;
+
+import io.realm.ObjectServerError;
+import io.realm.internal.objectserver.ObjectServerSession;
+
+/**
+ * This SyncPolicy will automatically start synchronizing changes to a Realm as soon as it is opened.
+ */
+public class AutomaticSyncPolicy implements SyncPolicy {
+
+    private Long lastError = null;
+    private int recurringErrors = 0;
+
+    @Override
+    public void onRealmOpened(ObjectServerSession session) {
+        session.bind(); // Bind Realm first time it is opened.
+    }
+
+    @Override
+    public void onRealmClosed(ObjectServerSession session) {
+        // TODO In order to preserve resources we should ideally close the session as well, but first
+        // we want to make sure that all local changes have been synchronized to the remote Realm.
+    }
+
+    @Override
+    public void onSessionCreated(ObjectServerSession session) {
+        session.start();
+    }
+
+    @Override
+    public void onSessionStopped(ObjectServerSession session) {
+        // Do nothing
+    }
+
+    @Override
+    public boolean onError(ObjectServerSession session, ObjectServerError error) {
+        switch(error.getCategory()) {
+            case FATAL:
+                return false;   // Report all fatal errors to the user
+            case RECOVERABLE:
+                return rebind(session);
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Returns {@code true} if we decide to rebind, {@code false} if the error was determined to no longer be solvable.
+     */
+    private boolean rebind(ObjectServerSession session) {
+        // Track all calls to rebind(). If some error reported as RECOVERABLE keeps happening, we need to abort to
+        // prevent run-away sessions. Right now we treat an error as recurring if it happens within 3 seconds of each
+        // other. After 5 of such errors we terminate the session.
+        //
+        // Standard IO errors are already handled using incremental backoff by e.g the AUTHENTICATING state, so
+        // re-occurring errors at this level are more serious.
+        long now = System.currentTimeMillis();
+        if (lastError - now < 3000) {
+            recurringErrors++;
+        } else {
+            recurringErrors = 1;
+        }
+        lastError = now;
+
+        if (recurringErrors == 5) {
+            session.stop(); // Abort session, some error that should be temporary keeps happening.
+            return false;
+        } else {
+            session.bind();
+            return true;
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        AutomaticSyncPolicy that = (AutomaticSyncPolicy) o;
+
+        if (recurringErrors != that.recurringErrors) return false;
+        return lastError != null ? lastError.equals(that.lastError) : that.lastError == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = lastError != null ? lastError.hashCode() : 0;
+        result = 31 * result + recurringErrors;
+        return result;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java
new file mode 100644
index 0000000000..ae14b6af3e
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.syncpolicy;
+
+import io.realm.ObjectServerError;
+import io.realm.SyncSession;
+import io.realm.SyncConfiguration;
+import io.realm.internal.objectserver.ObjectServerSession;
+
+/**
+ * Interface describing a given synchronization policy with the Realm Object Server.
+ * <p>
+ * The sole purpose of classes implementing this interface is to call {@link ObjectServerSession#bind()} and
+ * {@link ObjectServerSession#unbind()} as needed, which will control when changes are synchronized between a local and
+ * remote Realm.
+ *
+ * The SyncPolicy is not responsible for managing the lifecycle of the {@link ObjectServerSession} in general. So any
+ * implementation of this class should avoid calling {@link ObjectServerSession#stop()} and
+ * {@link ObjectServerSession#start()}.
+ *
+ * If a session is stopped, {@link ObjectServerSession#unbind()} is automatically called and any further calls to
+ * {@link ObjectServerSession#bind()} and {@link ObjectServerSession#unbind()} are ignored.
+ * {@link #onSessionStopped(ObjectServerSession)} ()} will then be called so the sync policy have a chance to clean up
+ * any resources it might be using.
+ */
+// Internal until we are sure this is the API we want
+public interface SyncPolicy {
+
+    /**
+     * Called when the session object is created. At this point it is possible to register any relevant error and event
+     * listeners in either the Android framework or for the session itself.
+     *
+     * {@link ObjectServerSession#start()} will be automatically called after this method.
+     *
+     * @param session the {@link SyncSession} just created. It has not yet been started.
+     */
+    void onSessionCreated(ObjectServerSession session);
+
+    /**
+     * The {@link ObjectServerSession} has been stopped and will ignore any further calls to
+     * {@link ObjectServerSession#bind()} and {@link ObjectServerSession#unbind()}. All external resources should be
+     * cleaned up.
+     *
+     * @param session {@link ObjectServerSession} that has been stopped.
+     */
+    void onSessionStopped(ObjectServerSession session);
+
+    /**
+     * Called the first time a Realm is opened on any thread.
+     *
+     * @param session {@link ObjectServerSession} associated with this Realm.
+     */
+    void onRealmOpened(ObjectServerSession session);
+
+    /**
+     * Called when the last Realm instance across all threads have been closed.
+     *
+     * @param session {@link ObjectServerSession} associated with this Realm.
+     */
+    void onRealmClosed(ObjectServerSession session);
+
+    /**
+     * Called if an error occurred in the underlying session. In many cases this has caused the session to become
+     * unbound.
+     *
+     * @param error {@link ObjectServerError} object describing the error.
+     * @return {@code true} if the error was handled, or {@code false} if it should be propagated further out to the
+     * SyncConfigurations error handler.
+     *
+     * This method is always called from a background thread, never the UI thread.
+     *
+     * @see SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)
+     */
+    boolean onError(ObjectServerSession session, ObjectServerError error);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
new file mode 100644
index 0000000000..e8d402d259
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.permissions;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+
+/**
+ * This class is used for requesting changes to a Realm's permissions.
+ *
+ * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
+ */
+public class PermissionChange extends RealmObject {
+
+    // Base fields
+    @PrimaryKey
+    @Required
+    private String id = UUID.randomUUID().toString();
+    @Required
+    private Date createdAt = new Date();
+    @Required
+    private Date updatedAt = new Date();
+    private Integer statusCode = null; // null=not processed, 0=success, >0=error
+    private String statusMessage;
+
+    @Required
+    private String realmUrl;
+    @Required
+    private String userId;
+    private Boolean mayRead = false;
+    private Boolean mayWrite = false;
+    private Boolean mayManage = false;
+
+    public PermissionChange() {
+        // Default constructor required by Realm
+    }
+
+    /**
+     * Construct a Permission Change Object.
+     *
+     * @param realmUrl Realm to change permissions for. Use {@code *} to change the permissions of all Realms.
+     * @param userId User or users to effect. Use {@code *} to change the permissions for all users.
+     * @param mayRead Define read access. {@code true} or {@code false} to request this new value. {@code null} to
+     *                keep current value.
+     * @param mayWrite Define write access. {@code true} or {@code false} to request this new value. {@code null} to
+     *                 keep current value.
+     * @param mayManage Define manage access. {@code true} or {@code false} to request this new value. {@code null} to
+     *                  keep current value.
+     *
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
+     */
+    public PermissionChange(String realmUrl, String userId, Boolean mayRead, Boolean mayWrite, Boolean mayManage) {
+        this.realmUrl = realmUrl;
+        this.userId = userId;
+        this.mayRead = mayRead;
+        this.mayWrite = mayWrite;
+        this.mayManage = mayManage;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public Date getCreatedAt() {
+        return createdAt;
+    }
+
+    public Date getUpdatedAt() {
+        return updatedAt;
+    }
+
+    /**
+     * Returns the status code for this change.
+     *
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     */
+    public Integer getStatusCode() {
+        return statusCode;
+    }
+
+    public String getStatusMessage() {
+        return statusMessage;
+    }
+
+    public String getRealmUrl() {
+        return realmUrl;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public Boolean mayRead() {
+        return mayRead;
+    }
+
+    public Boolean mayWrite() {
+        return mayWrite;
+    }
+
+    public Boolean mayManage() {
+        return mayManage;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
new file mode 100644
index 0000000000..5c245e3215
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(library = true, classes = { PermissionChange.class })
+public class PermissionModule {
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
new file mode 100644
index 0000000000..ccf997a3b8
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -0,0 +1,69 @@
+package io.realm.objectserver;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.SyncCredentials;
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.SyncUser;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.HttpUtils;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class AuthTests {
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+
+    @BeforeClass
+    public static void setUp () throws Exception {
+        Realm.init(InstrumentationRegistry.getContext());
+        HttpUtils.startSyncServer();
+    }
+
+    @AfterClass
+    public static void tearDown () throws Exception {
+        HttpUtils.stopSyncServer();
+    }
+
+    @Test
+    public void login_userNotExist() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+        try {
+            SyncUser.login(credentials, Constants.AUTH_URL);
+            fail();
+        } catch (ObjectServerError expected) {
+            assertEquals(ErrorCode.INVALID_CREDENTIALS, expected.getErrorCode());
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void loginAsync_userNotExist() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
new file mode 100644
index 0000000000..6e465f53f9
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmResults;
+import io.realm.SyncConfiguration;
+import io.realm.objectserver.model.ProcessInfo;
+import io.realm.objectserver.model.TestObject;
+import io.realm.objectserver.service.SendOneCommit;
+import io.realm.objectserver.service.SendsALot;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.HttpUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ProcessCommitTests {
+    @BeforeClass
+    public static void setUp () throws Exception {
+        HttpUtils.startSyncServer();
+    }
+
+    @AfterClass
+    public static void tearDown () throws Exception {
+        HttpUtils.stopSyncServer();
+    }
+
+    // FIXME: At least need one method in the test class
+    @Test
+    public void dummy() {
+
+    }
+
+    // FIXME: Disable for now.
+    /*
+    @Test
+    public void expectServerCommit() throws Throwable {
+        final Throwable[] exception = new Throwable[1];
+        final CountDownLatch testFinished = new CountDownLatch(1);
+        ExecutorService service = Executors.newSingleThreadExecutor();
+        service.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Looper.prepare();
+                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+
+                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder()
+                            .name(SendOneCommit.class.getSimpleName())
+                            .serverUrl(Constants.SYNC_SERVER_URL )
+                            .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL, Constants.USER_TOKEN))
+                            .build();
+                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
+                    final Realm realm = Realm.getInstance(syncConfig);
+                    Intent intent = new Intent(targetContext, SendOneCommit.class);
+                    targetContext.startService(intent);
+
+                    final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
+                    all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
+                        @Override
+                        public void onChange(RealmResults<ProcessInfo> element) {
+                            assertEquals(1, all.size());
+                            assertEquals("Background_Process1", all.get(0).getName());
+                            testFinished.countDown();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Throwable e) {
+                    exception[0] = e;
+                    testFinished.countDown();
+                }
+            }
+        });
+        boolean testTimedOut = testFinished.await(300, TimeUnit.SECONDS);
+        if (exception[0] != null) {
+            throw exception[0];
+        } else if (!testTimedOut) {
+            fail("Test timed out ");
+        }
+    }
+    */
+
+    //TODO send string from service and match
+    //     replicate integration tests from Cocoa
+    //     add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process
+    //     check the requirement for the issue again
+    /*
+    @Test
+    public void expectALot() throws Throwable {
+        final Throwable[] exception = new Throwable[1];
+        final CountDownLatch testFinished = new CountDownLatch(1);
+        ExecutorService service = Executors.newSingleThreadExecutor();
+        service.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    Looper.prepare();
+                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+
+                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(targetContext)
+                            .name(SendsALot.class.getSimpleName())
+                            .serverUrl(Constants.SYNC_SERVER_URL_2)
+                            .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL_2, Constants.USER_TOKEN))
+                            .build();
+                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
+                    final Realm realm = Realm.getInstance(syncConfig);
+                    Intent intent = new Intent(targetContext, SendsALot.class);
+                    targetContext.startService(intent);
+
+                    final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
+                    all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
+                        @Override
+                        public void onChange(RealmResults<TestObject> element) {
+                            assertEquals(100, element.size());
+                            for (int i = 0; i < 100; i++) {
+                                assertEquals(i, element.get(i).getIntProp());
+                                assertEquals("property " + i, element.get(i).getStringProp());
+                            }
+
+                            testFinished.countDown();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Throwable e) {
+                    exception[0] = e;
+                    testFinished.countDown();
+                }
+            }
+        });
+        boolean testTimedOut = testFinished.await(30, TimeUnit.SECONDS);
+        if (exception[0] != null) {
+            throw exception[0];
+        } else if (!testTimedOut) {
+            fail("Test timed out ");
+        }
+    }
+    */
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/ProcessInfo.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/ProcessInfo.java
new file mode 100644
index 0000000000..62e8ddcfcc
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/ProcessInfo.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class ProcessInfo extends RealmObject {
+    private String name;
+    private int pid;
+    private long threadId;
+
+    public int getPid() {
+        return pid;
+    }
+
+    public void setPid(int pid) {
+        this.pid = pid;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public long getThreadId() {
+        return threadId;
+    }
+
+    public void setThreadId(long threadId) {
+        this.threadId = threadId;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
similarity index 55%
rename from realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
rename to realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
index 3d59ed049e..2bd27a6ef8 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,29 +14,27 @@
  * limitations under the License.
  */
 
-package io.realm.exceptions;
+package io.realm.objectserver.model;
 
-import io.realm.internal.Keep;
+import io.realm.RealmObject;
 
-/**
- * Class for reporting problems with Realm files.
- */
-@Keep
-public class RealmIOException extends RuntimeException {
+public class TestObject extends RealmObject {
+    private int intProp;
+    private String stringProp;
 
-    public RealmIOException(Throwable cause) {
-        super(cause);
+    public int getIntProp() {
+        return intProp;
     }
 
-    public RealmIOException() {
+    public void setIntProp(int intProp) {
+        this.intProp = intProp;
     }
 
-    public RealmIOException(String message) {
-        super(message);
+    public String getStringProp() {
+        return stringProp;
     }
 
-    public RealmIOException(String message, Throwable cause) {
-        super(message, cause);
+    public void setStringProp(String stringProp) {
+        this.stringProp = stringProp;
     }
-
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
new file mode 100644
index 0000000000..26c4f89de6
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.service;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+
+/**
+ * Open a sync Realm on a different process, then send one commit.
+ */
+public class SendOneCommit extends Service {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // FIXME: Disable for now
+        /*
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(this)
+                .name(SendOneCommit.class.getSimpleName())
+                .serverUrl(Constants.SYNC_SERVER_URL)
+                .user(UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL, Constants.USER_TOKEN))
+                .build();
+        Realm.deleteRealm(syncConfig);
+        Realm realm = Realm.getInstance(syncConfig);
+
+        realm.beginTransaction();
+        ProcessInfo processInfo = realm.createObject(ProcessInfo.class);
+        processInfo.setName("Background_Process1");
+        processInfo.setPid(android.os.Process.myPid());
+        processInfo.setThreadId(Thread.currentThread().getId());
+        realm.commitTransaction();
+
+        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
+        */
+    }
+
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
new file mode 100644
index 0000000000..2bcdd9d717
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.service;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+
+/**
+ * Open a sync Realm on a different process, then send one commit.
+ */
+public class SendsALot extends Service {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // FIXME: Disable for now.
+        /*
+        User user = UserFactory.createDefaultUser(Constants.SYNC_SERVER_URL_2, Constants.USER_TOKEN);
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user)
+                .name(SendsALot.class.getSimpleName())
+                .serverUrl(Constants.SYNC_SERVER_URL_2)
+                .user()
+                .build();
+        Realm.deleteRealm(syncConfig);
+        Realm realm = Realm.getInstance(syncConfig);
+
+        realm.beginTransaction();
+
+        for (int i = 0; i < 100; i++) {
+            TestObject testObject = realm.createObject(TestObject.class);
+            testObject.setIntProp(i);
+            testObject.setStringProp("property " + i);
+        }
+        realm.commitTransaction();
+
+        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
+        */
+    }
+
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
new file mode 100644
index 0000000000..e346c04c3c
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+public class Constants {
+    // to generate a valid token follow the guide in
+    //<root>/integration-tests/sync/test_server/keys/HowToGenerateKey.txt
+    public static String USER_TOKEN = "ewogICJpZGVudGl0eSI6ICJ0ZXN0MiIsCiAgImFjY2VzcyI6IFsKICAgICJkb3dubG9hZCIsCiAgICAidXBsb2FkIgogIF0sCiAgInRpbWVzdGFtcCI6IDE0NTU1MzA2MTQsCiAgImV4cGlyZXMiOiBudWxsLAogICJhcHBfaWQiOiAiaW8ucmVhbG0udGVzdHMuc3luYyIKfQ=="
+            + ":" +
+            "mR0/GMc0b5XHFNJEM4D9fb94oXMjho0jKxopaU1lQW4FqY1QPBa/bPiVCMhAosZVSNhEP6vEZxVjFHAxoPODKoml1Ry78geKt5Iql395HRvO6KCCN0VkMpx2eXy+SzF2pcEjU5jlldbTAcO6nMyVaQ9g2XF2SZPVjBqpkY1cy2IjMHN0HRWy9SfGelwZY/jW72jZM7+89kWpIB0SmNH8kEPKVZlnRMW4KwNAUPA8P0/+qyoRTr/4l7k7N6z5kBxIKB/+m55AeOUDiFsxA53QPlpHGvF7ThZpiv8i+UhyKZcQlXi1utoj8H1CzpeU/YzrrEf3xrr2qCO3/niU5WdnHA==";
+    public static String SYNC_SERVER_URL = "realm://127.0.0.1:7800/tests";
+    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1:7800/tests2";
+
+    public static String AUTH_SERVER_URL = "http://127.0.0.1:8080/";
+    public static String AUTH_URL = AUTH_SERVER_URL + "auth";
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
new file mode 100644
index 0000000000..9b15ae11e3
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import java.io.IOException;
+
+import io.realm.log.RealmLog;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * Start and Stop the node server responsible of creating a
+ * temp directory & start a sync server on it for each unit test.
+ */
+public class HttpUtils {
+    private final static OkHttpClient client = new OkHttpClient();
+    // adb reverse tcp:8888 tcp:8888
+    // will forward this query to the host, running the integration test server on 8888
+    private final static String START_SERVER = "http://127.0.0.1:8888/start";
+    private final static String STOP_SERVER = "http://127.0.0.1:8888/stop";
+
+    public static void startSyncServer() throws Exception {
+        Request request = new Request.Builder()
+                .url(START_SERVER)
+                .build();
+
+        Response response = client.newCall(request).execute();
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0; i < responseHeaders.size(); i++) {
+            RealmLog.debug(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        RealmLog.debug(response.body().string());
+
+        // FIXME: Server ready checking should be done in the control server side!
+        if (!waitAuthServerReady()) {
+            stopSyncServer();
+            throw new RuntimeException("Auth server cannot be started.");
+        }
+    }
+
+    // Checking the server
+    private static boolean waitAuthServerReady() throws InterruptedException {
+        int retryTimes = 50;
+        Request request = new Request.Builder()
+                .url(Constants.AUTH_SERVER_URL)
+                .build();
+
+        while (retryTimes != 0) {
+            try {
+                Response response = client.newCall(request).execute();
+                if (response.isSuccessful()) {
+                    return true;
+                }
+                RealmLog.error("Error response from auth server: %s", response.toString());
+            } catch (IOException e) {
+                RealmLog.error(e);
+                Thread.sleep(100);
+            }
+            retryTimes--;
+        }
+
+        return false;
+    }
+
+    public static void stopSyncServer() throws Exception {
+        Request request = new Request.Builder()
+                .url(STOP_SERVER)
+                .build();
+
+        Response response = client.newCall(request).execute();
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0; i < responseHeaders.size(); i++) {
+            RealmLog.debug(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        RealmLog.debug(response.body().string());
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
new file mode 100644
index 0000000000..1ebb2d6ab5
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import io.realm.SyncUser;
+import io.realm.objectserver.utils.Constants;
+
+// Must be in `io.realm.objectserver` to work around package protected methods.
+public class UserFactory {
+    // FIXME: Not working right now.
+    /*
+    public static User createDefaultUser(String SERVER_URL, String USER_TOKEN) {
+        try {
+            User user = User.createLocal();
+
+            user.addAccessToken(new URI(SERVER_URL), USER_TOKEN);
+            return user;
+        } catch (URISyntaxException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    */
+}
diff --git a/realm/settings.gradle b/realm/settings.gradle
index 82a197b850..4540b8669d 100644
--- a/realm/settings.gradle
+++ b/realm/settings.gradle
@@ -1,4 +1,3 @@
 // Realm projects
 include 'realm-library'
 include 'realm-annotations-processor'
-include 'realm-jni'
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
new file mode 100644
index 0000000000..f733015ca4
--- /dev/null
+++ b/tools/sync_test_server/Dockerfile
@@ -0,0 +1,21 @@
+FROM ubuntu:16.04
+
+ARG ROS_DE_VERSION
+
+# Add realm repo
+RUN apt-get update -qq \
+    && apt-get install -y curl npm \
+    && curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh | bash
+
+# ROS npm dependencies
+RUN npm init -y
+RUN npm install winston temp httpdispatcher@1.0.0
+
+COPY keys/private.pem keys/public.pem configuration.yml /
+COPY ros-testing-server.js /usr/bin/
+# Install realm object server
+RUN apt-get update -qq \
+    && apt-get install -y realm-object-server-developer=$ROS_DE_VERSION \
+    && apt-get clean
+
+CMD /usr/bin/ros-testing-server.js /tmp/ros-testing-server.log
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
new file mode 100644
index 0000000000..6080a3beda
--- /dev/null
+++ b/tools/sync_test_server/configuration.yml
@@ -0,0 +1,227 @@
+# Realm Object Server Configuration
+#
+# For each possible setting, the commented out values are the default values
+# unless another default is mentioned explicitly.
+#
+# Paths specified in this file can be either absolute or relative.
+# Relative paths are relative to the current working directory.
+
+
+## ----------------------------------------------------------------------------
+## The following options are MANDATORY, either by providing them in this file,
+## or as command-line options:
+## - storage: root_path
+## - auth:public_key_path
+## - auth:private_key_path
+## ----------------------------------------------------------------------------
+
+
+storage:
+  ## The directory in which the realm server will store all its data files.
+  ## This configuration option is MANDATORY.
+  root_path: /var/realm/sync-services
+
+## ----------------------------------------------------------------------------
+
+auth:
+  ## The path to the public and private keys (in PEM format) that will be used
+  ## to validate identity tokens sent by clients.
+  ## These configuration options are MANDATORY.
+  public_key_path: /public.pem
+  private_key_path: /private.pem
+
+  database:
+    ## The path for the administration database synchronisation endpoint. Do NOT
+    ## change this unless asked by Realm Support.
+    # sync_uri_path: '/public/admin'
+
+  ttls:
+    ## The validity duration for Refresh Tokens. This should be a fairly high
+    ## value, typically ranging 12 hours - 3 days. This value is represented in
+    ## seconds. Default: 24 hours.
+    # refresh_token: 86400
+
+    ## The validity duration for Access Tokens. This should be a fairly small
+    ## number, especially if you are concerned with revocations being applied
+    ## quickly. This value is represented in seconds. Default: 1 minute.
+    # access_token: 60
+
+## ----------------------------------------------------------------------------
+
+proxy:
+  ## Network settings for the externally accessible proxy module.
+  ## This can be enabled for both HTTP and HTTPS traffic simultaneously, and
+  ## forwards traffic to the sync and services internal modules.
+  ## It is possible to disable and replace the proxy module by another reverse proxy.
+  ##
+  ## Note: The proxy module forwards traffic to the internal modules on the
+  ## addresses and ports they listen on (as configured in the `network' section below).
+  ##
+  ## Shown below is a diagram of the default network configuration:
+  ##
+  ##                                                                     +----------------------+
+  ##                                                                     |                      |
+  ##                                                                     |     Sync module      |
+  ##                                                                     |                      |
+  ##                                                                     |      (internal)      |
+  ##                                                                     |                      |
+  ##                                                                 +-> |  Defaults:           |
+  ## +----------------+             +---------------------------+    |   |   Listen: 127.0.0.1  |
+  ## |                |             |                           |    |   |   Ports:             |
+  ## |  Realm Client  +------+      |        Proxy module       |    |   |    WS: tcp/27800     |
+  ## |                |      |      |                           |    |   |                      |
+  ## +-----------------      |      |  (externally accessible)  |    |   +----------------------+
+  ##                         +----> |                           |    |
+  ##                                |  Defaults:                |    |
+  ##                         +----> |   Listen: 0.0.0.0         +----+
+  ##      +------------      |      |   Ports:                  |    |   +----------------------+
+  ##      |           |      |      |    HTTP & WS: tcp/9080    |    |   |                      |
+  ##      |  Browser  +------+      |    HTTPS & WSS: tcp/9443  |    |   |    Services module   |
+  ##      |           |             |                           |    |   |                      |
+  ##      +-----------+             +---------------------------+    |   |      (internal)      |
+  ##                                                                 +-> |                      |
+  ##                                                                     |  Defaults:           |
+  ##                            Note: The proxy module can be            |   Listen: 127.0.0.1  |
+  ##                                  replaced by NGINX or other         |    Ports:            |
+  ##                                  reverse proxies                    |     HTTP: tcp/27080  |
+  ##                                                                     |                      |
+  ##                                                                     +----------------------+
+
+  http:
+    ## Whether or not to enable the HTTP proxy module. It enables multiplexing requests
+    ## by forwarding incoming requests on a single port to all services.
+    # enable: true
+
+    ## The address/interface on which the HTTP proxy module should listen. This defaults
+    ## to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    listen_address: '0.0.0.0'
+
+    ## The port that the HTTP proxy module should bind to.
+    # listen_port: 9080
+
+  https:
+    ## Whether or not to enable the HTTPS proxy module. It enables multiplexing requests
+    ## by forwarding incoming requests on a single port to all services.
+    ## Note that even if it enabled, the HTTPS proxy will only start if supplied
+    ## with a valid pair of certificates through certificate_path and private_key_path below.
+    # enable: false
+
+    ## The path to the certificate and private keys (in PEM format) that will be used
+    ## to set up the HTTPS server accepting connections.
+    ## These configuration options are MANDATORY to start the HTTPS proxy module.
+    # certificate_path: 'keys/https-proxy.crt'
+    # private_key_path: 'keys/https-proxy.key'
+
+    ## The address/interface on which the HTTPS proxy module should listen. This defaults
+    ## to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    # listen_address: '0.0.0.0'
+
+    ## The port that the HTTPS proxy module should bind to.
+    # listen_port: 9443
+
+## ----------------------------------------------------------------------------
+
+network:
+  ## Network settings for internal modules, to which traffic is forwarded from
+  ## the proxy module. The proxy module will automatically forward traffic to the
+  ## internal modules on the ports they are configured to listen on in this section.
+
+  sync:
+    ## The address/interface on which the server should listen. This defaults
+    ## to 127.0.0.1. If you wish to listen on all available interfaces,
+    ## uncomment the following line.
+    listen_address: '0.0.0.0'
+
+    ## The port on which to listen. The Realm sync server uses port 27800 by
+    ## default. For most deployments, there should not be a need to change this.
+    listen_port: 7800
+
+  http:
+    ## The address/interface on which the server should listen for HTTP
+    ## services. This includes Dashboard and Authentication APIs.
+    ## This defaults to 127.0.0.1. If you wish to listen on all available
+    ## interfaces, uncomment the following line.
+    listen_address: '0.0.0.0'
+
+    ## The port on which to listen for incoming requests to the Dashboard
+    ## and authentication APIs. This defaults to 27080.
+    listen_port: 8080
+
+## ----------------------------------------------------------------------------
+
+  providers:
+    ## Providers of authentication tokens. Each provider has a configuration
+    ## object associated with it. If a provider is included here and its
+    ## configuration is valid, it will be enabled.
+
+    ## Possible providers: cloudkit, debug, facebook, realm, password
+    ## Providers 'realm' and 'password' are always enabled:
+    ## - The 'realm' provider is used to derive access tokens from a refresh token.
+    ## - The 'password' provider is required for the dashboard to work. It supports
+    ##   authentication through username/password and uses a PBKDF2 implementation.
+
+    ## This enables login via CloudKit's user record name.
+    # cloudkit:
+      ## The key ID retrieved when adding the public key derived from the
+      ## specified private_key_path in CloudKit's Server-to-Server Keys,
+      ## available through the API Access settings in the CloudKit dashboard.
+      # key_id: '0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'
+
+      ## The path to the certificate.
+      # private_key_path: 'cloudkit_eckey.pem'
+
+      ## The container identifier in reverse domain name notation.
+      # container: "iCloud.io.realm.exampleApp.ios"
+
+      ## The environment in which CloudKit should be used. The default is
+      ## 'development'. For the production deployment for apps on the AppStore
+      ## you must specify 'production'.
+      # environment: 'development'
+
+    ## This enables authentication via a Google Sign-In access token for a
+    ## specific app.
+    # google:
+      ## The client ID as retrieved when setting up the app in the Google
+      ## Developer Console.
+      # clientId: '012345678901-abcdefghijklmnopqrstvuvwxyz01234.apps.googleusercontent.com'
+
+    ## This enables authentication via a Facebook access token for a specific app.
+    ## This provider needs no configuration (uncommenting the next line enables it).
+    # facebook: {}
+
+## ----------------------------------------------------------------------------
+
+logging:
+  ## The logging level of the server.
+  ##
+  ## Note: This used to be an integer, but has been updated to be more
+  ## descriptive. The integer values are no longer supported.
+  ##
+  ## Possible values (from most to least verbose):
+  ##
+  ##   all: no filtering
+  ##   trace
+  ##   debug
+  ##   detail
+  ##   info: good for production (default)
+  ##   warn
+  ##   error
+  ##   fatal
+  ##   off: all output suppressed
+  level: 'all'
+
+  ## The file to which the synchronisation server should log. This should
+  ## be a writable path from the perspective of the user under which the
+  ## server runs. If no path is specified, the server will log to stdout.
+  path: '/tmp/realm-sync.log'
+
+## ----------------------------------------------------------------------------
+
+performance:
+  ## The maximum number of Realm files that the server will have open
+  ## concurrently (LRU cache). The default is 256.
+  ## Only change this option if directed to by Realm support.
+  # max_open_files: 256
+
diff --git a/tools/sync_test_server/keys/HowToGenerateKey.txt b/tools/sync_test_server/keys/HowToGenerateKey.txt
new file mode 100644
index 0000000000..c3db0e9188
--- /dev/null
+++ b/tools/sync_test_server/keys/HowToGenerateKey.txt
@@ -0,0 +1,18 @@
+// The Base64-encoded user token is generated by the following command:
+//     cat test_token.json | base64
+// The Base64-encoded signature is generated by the following command:
+//     cat test_token.json | openssl dgst -sha256 -binary -sign private.pem | base64
+// The two are concatenated with a ':'.
+// This token does not contain a "path" field, and therefore grants access to
+// all Realms.
+
+// Example:
+g_signed_test_user_token =
+ // cat test_token.json | base64
+"ewogICJpZGVudGl0eSI6ICJ0ZXN0IiwKICAiYWNjZXNzIjogWwogICAgImRvd25sb2FkIiwKICAgICJ1cGxvYWQiCiAgXSwKICAidGltZXN0YW1wIjogMTQ1NTUzMDYxNCwKICAiZXhwaXJlcyI6IG51bGwsCiAgImFwcF9pZCI6ICJpby5yZWFsbS50ZXN0cy5zeW5jIgp9"
++ ":"
+// cat test_token.json | openssl dgst -sha256 -binary -sign private.pem | base64
+"Y5+K3Y+wd+McaZx6rte1MQvKpHgy7NoTqTzgF3CnGKcosMT7PkG1M71rLsq9/Fcldn6G26Bn3kb0vnw93TS2Ox4wa0FMiObK+N7VNdI6p/+dG5bDjBhtW2AFd2P0nOUCvx39EIdLVnGr3JUidJZEZGzFyFOdZVpnmIAnHNDaOIPOXt4vnASJ/dBjUTkOlexOwSRKIK1hvkA1GO9zpvnG5EbnVG6LuVSRM93Hp0tzuFdesns19P827/FsdZATDA9TFlwVTIa7vHz0KbzolSXKvIiOr5XWC2NXyDFEowxwFHyCuXN52jk9kylagFDTBvXu1ddmDZjWxg9SinJzS4lsYA=="
+
+
+Reference https://github.com/realm/realm-sync/blob/master/test/test_sync.cpp#L65
\ No newline at end of file
diff --git a/tools/sync_test_server/keys/private.pem b/tools/sync_test_server/keys/private.pem
new file mode 100644
index 0000000000..e8f1a123c3
--- /dev/null
+++ b/tools/sync_test_server/keys/private.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAo65ZQ8mFIVk0ZB22bHdNuBr4G3K7SwfFlUhmBmjQFb2EdopA
+nmu/XdXn+Zw3pmYlzIxe+3RX9M4eh8luIil0J2Nlb7tHOPZQkQAiuuud8JQ9RTND
+ixUQTGS4YmhyQv+7LA9cjdaczD3Bf3Nw/yZQTQQqw7vsbTUJeAMz+6EFLeMj2Lxn
+ZVLP7ePezxaSpKiQ8mp7eurQrZIqmvEC1xp8a7XvkgtqnMBepauIBiw6Wlpin0lP
+D3P5uMtrP+z5MmQXpP/GOp6XjBlULMQAMH/V03WYMwnevzMWmKhF2apepnjd65nB
+h29iaFuiE8tYvKpJxmrsmoU+aOvMt3ZORxj7LQIDAQABAoIBAGfSlWh8EOgAT00Z
+07alTjTzVmECu25yNY/lZmG2ZhcEKVuPgkF6kt4Qap5XyqzPqjY+65iQSaJMg+0Z
+hbRBmx3I3HSs1BZ7lssCzQTHo10QinS0ealk6Pur/5DcM23wDGd8LvcBJGAg4/XV
+4dzWDqVreTzCnMsAk0r+rSB1GHXr0/jMiivPvUzvxpVRZ+dyGPdxUFBQivPGC7h8
+3VJRLj8zBFlf0az7xeVCGgZMAtiaJhhGtG2QCBKhk3mqlDmhIB6jTai+b+vnL1KK
+tTOOhMsYXIhJXYeE6H2aXNn7z53sKoiRq2Zptzfl9csbQ5yelbtZ05CRC+nzAscr
+XOl2BjkCgYEA0QYexhXsd9OA8vU+kfm1WyLZmGc1biK+RLqV+nhXzy1lRy1DdaOq
+6raNgaZ9xgX5zHLqxk+2s5+dWMfyvbUxDPhl7C6R0yLNuXzW2tjsy3T5AI8ApWrA
+STUOaamLyaqRt0VB8AVSco2bvHCVEjyY+Bc7RD0LHnDfBUSwobr+FrMCgYEAyHd+
+nGsWhqGEabtfZCS8f1f1PnS4jge5VY9PFjgSLT9K6KJv00tmG9PGRhKXgGiLs+DW
+0EHiwWIYpAGHVOvnndWIUsxo14Mg8cRfJlA/a87RrXMNu6I/4rGPRwHqeRauNWmu
+wuNSJZTul09UYo7iHqtiEFOxpSEufC4965QUlp8CgYA/9qZ+KYFWXdPNBX1jQE3e
+GLkLqTGxhVJCR/LTVfZRAOxILrLBEheggcKl1SQR8Aw0I0py6zvWldaZr345zXO4
+K19NOicHvFPGGkzJZa54yE/WeuxQsm0rOeAyN17+lILI2ZnG8Gn9ghYRQUZs8TxC
+VyGczS1U4Gdu/kkrBMTyfwKBgQCRYh//fqZ6gx7Ns2bt8LqHvBmO7wV9c9qUU3du
+zMFZ8UH5Tvy8hz0JR1/PJ+KZ7LgMfy4rIO07hFIMd1NXYjK6w8a3DamnSmEVFW5Q
+Efi8zeRA32UBRB0C4fTf8WLD6I/1Cq0Eh+nmeYlDUPQI+kjBJ1faMWhvMo5M3xhn
+BiCcTwKBgQC/oQ5R6avo15UK7Tituj9TqduLf4leGJwn3ht6GsAPNDENDJZJc30A
+wL+ghnvUieG1fz3OelZPx3Ber5QdNzhM8+24klevCLaCdF8alhg9nIEtWFrGpXEv
+RLZ4jP2FUo1XJDNqXK4l17slzdWzEs1jiB7ePLvpoiA+GVcL3Anmkg==
+-----END RSA PRIVATE KEY-----
diff --git a/tools/sync_test_server/keys/public.pem b/tools/sync_test_server/keys/public.pem
new file mode 100644
index 0000000000..8f81325947
--- /dev/null
+++ b/tools/sync_test_server/keys/public.pem
@@ -0,0 +1,9 @@
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAo65ZQ8mFIVk0ZB22bHdN
+uBr4G3K7SwfFlUhmBmjQFb2EdopAnmu/XdXn+Zw3pmYlzIxe+3RX9M4eh8luIil0
+J2Nlb7tHOPZQkQAiuuud8JQ9RTNDixUQTGS4YmhyQv+7LA9cjdaczD3Bf3Nw/yZQ
+TQQqw7vsbTUJeAMz+6EFLeMj2LxnZVLP7ePezxaSpKiQ8mp7eurQrZIqmvEC1xp8
+a7XvkgtqnMBepauIBiw6Wlpin0lPD3P5uMtrP+z5MmQXpP/GOp6XjBlULMQAMH/V
+03WYMwnevzMWmKhF2apepnjd65nBh29iaFuiE8tYvKpJxmrsmoU+aOvMt3ZORxj7
+LQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tools/sync_test_server/keys/test_token.json b/tools/sync_test_server/keys/test_token.json
new file mode 100644
index 0000000000..8d043f2fb7
--- /dev/null
+++ b/tools/sync_test_server/keys/test_token.json
@@ -0,0 +1,11 @@
+{
+  "identity": "test2",
+  "access": [
+    "download",
+    "upload"
+  ],
+  "timestamp": 1455530614,
+  "expires": null,
+  "app_id": "io.realm.tests.sync"
+}
+
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
new file mode 100755
index 0000000000..c182652c39
--- /dev/null
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -0,0 +1,86 @@
+#!/usr/bin/env nodejs
+
+var winston = require('winston');//logging
+const temp = require('temp');
+const spawn = require('child_process').spawn;
+var http = require('http');
+var dispatcher = require('httpdispatcher');
+
+// Automatically track and cleanup files at exit
+temp.track();
+
+if (process. argv. length <= 2) {
+    console.log("Usage: " + __filename + " somefile.log");
+    process.exit(-1);
+}
+const logFile = process.argv[2];
+winston.level = 'debug';
+winston.add(winston.transports.File, { filename: logFile });
+
+const PORT = 8888;
+
+function handleRequest(request, response) {
+    try {
+        //log the request on console
+        winston.log(request.url);
+        //Disptach
+        dispatcher.dispatch(request, response);
+    } catch(err) {
+        console.log(err);
+    }
+}
+
+var syncServerChildProcess = null;
+
+function startRealmObjectServer() {
+    stopRealmObjectServer();
+    temp.mkdir('ros', function(err, path) {
+        if (!err) {
+            winston.info("Starting sync server in ", path);
+            syncServerChildProcess = spawn('realm-object-server',
+                    ['--root', path,
+                    '--configuration', '/configuration.yml']);
+            // local config:
+            syncServerChildProcess.stdout.on('data', (data) => {
+                winston.info(`stdout: ${data}`);
+            });
+
+            syncServerChildProcess.stderr.on('data', (data) => {
+                winston.info(`stderr: ${data}`);
+            });
+
+            syncServerChildProcess.on('close', (code) => {
+                winston.info(`child process exited with code ${code}`);
+            });
+        }
+    });
+}
+
+function stopRealmObjectServer() {
+    if (syncServerChildProcess) {
+        syncServerChildProcess.kill();
+        syncServerChildProcess = null;
+    }
+}
+
+
+// start sync server
+dispatcher.onGet("/start", function(req, res) {
+    startRealmObjectServer();
+    res.writeHead(200, {'Content-Type': 'text/plain'});
+    res.end('Starting a server');
+});
+
+// stop a previously started sync server
+dispatcher.onGet("/stop", function(req, res) {
+    stopRealmObjectServer();
+    winston.info("Sync server stopped");
+    res.writeHead(200, {'Content-Type': 'text/plain'});
+    res.end('Stopping the server');
+});
+
+//Create and start the Http server
+var server = http.createServer(handleRequest);
+server.listen(PORT, function() {
+    winston.info("Integration test server listening on: 127.0.0.1:%s", PORT);
+});
diff --git a/tools/sync_test_server/start_server.sh b/tools/sync_test_server/start_server.sh
new file mode 100755
index 0000000000..00930f5eb1
--- /dev/null
+++ b/tools/sync_test_server/start_server.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+# Get the script dir which contains the Dockerfile
+DOCKERFILE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+
+ROS_DE_VERSION=$(grep REALM_OBJECT_SERVER_DE_VERSION $DOCKERFILE_DIR/../../dependencies.list | cut -d'=' -f2)
+
+TMP_DIR=$(mktemp -d /tmp/sync-test.XXXX) || { echo "Failed to mktemp $TEST_TEMP_DIR" ; exit 1 ; }
+
+adb reverse tcp:7800 tcp:7800 && \
+adb reverse tcp:8080 tcp:8080 && \
+adb reverse tcp:8888 tcp:8888 || { echo "Failed to reverse adb port." ; exit 1 ; }
+
+docker build $DOCKERFILE_DIR --build-arg ROS_DE_VERSION=$ROS_DE_VERSION -t sync-test-server || { echo "Failed to build Docker image." ; exit 1 ; }
+
+echo "See log files in $TMP_DIR"
+docker run -p 8080:8080 -p 7800:7800 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
diff --git a/tools/sync_test_server/stop_server.sh b/tools/sync_test_server/stop_server.sh
new file mode 100755
index 0000000000..6dd95f1fb4
--- /dev/null
+++ b/tools/sync_test_server/stop_server.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+docker stop sync-test-server -t0
+docker rm sync-test-server
diff --git a/version.txt b/version.txt
index 6753471d56..a9d981d17e 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-2.0.0-SNAPSHOT
+2.3.0-SNAPSHOT
