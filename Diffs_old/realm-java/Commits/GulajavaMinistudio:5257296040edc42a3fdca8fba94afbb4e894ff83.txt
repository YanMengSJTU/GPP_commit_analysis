diff --git a/CHANGELOG.md b/CHANGELOG.md
index 176394b8fd..7528cf2b67 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,6 +9,7 @@
 * Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore` annotation (#4279).
 * Added `Realm.refresh()` and `DynamicRealm.refresh()` (#3476).
 * Added `Realm.getInstanceAsync()` and `DynamicRealm.getInstanceAsync()` (#2299).
+* Added `DynamicRealmObject#linkingObjects(String,String) to support linking objects on `DynamicRealm` (#4492).
 
 ### Bug Fixes
 
@@ -16,13 +17,14 @@
 
 * Use separated locks for different `RealmCache`s ($4551).
 
-## 3.1.4
+## 3.1.4 (2017-05-04)
 
 ## Bug fixes
 
 * Added missing row validation check in certain cases on invalidated/deleted objects (#4540).
 * Initializing Realm is now more resilient if `Context.getFilesDir()` isn't working correctly (#4493).
 * `OrderedRealmCollectionSnapshot.get()` returned a wrong object (#4554).
+* `onSuccess` callback got triggered infinitely if a synced transaction was committed in the async transaction's `onSuccess` callback (#4594).
 
 ## 3.1.3 (2017-04-20)
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 44772ce258..6cb95cc33d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -78,6 +78,9 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.internal.Row");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.SharedRealm");
+        if (!metadata.getBacklinkFields().isEmpty()) {
+            imports.add("io.realm.internal.UncheckedRow");
+        }
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
         imports.add("io.realm.log.RealmLog");
@@ -571,7 +574,7 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
                 .emitStatement("realm.checkIfValid()")
                 .emitStatement("proxyState.getRow$realm().checkIfAttached()")
                 .beginControlFlow("if (" + cacheFieldName + " == null)")
-                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
+                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults((Realm) realm, (UncheckedRow) proxyState.getRow$realm(), %s.class, \"%s\")",
                         backlink.getSourceClass(), backlink.getSourceField())
                 .endControlFlow()
                 .emitStatement("return " + cacheFieldName)
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 8eeb68202c..6a101e7c84 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -14,6 +14,7 @@
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
 import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import java.io.IOException;
@@ -399,7 +400,7 @@ public final AllTypesColumnInfo clone() {
         realm.checkIfValid();
         proxyState.getRow$realm().checkIfAttached();
         if (parentObjectsBacklinks == null) {
-            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
+            parentObjectsBacklinks = RealmResults.createBacklinkResults((Realm) realm, (UncheckedRow) proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
         }
         return parentObjectsBacklinks;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
index 766d85799e..c11178f0eb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -22,22 +22,46 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.util.Locale;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
+import io.realm.entities.Cat;
+import io.realm.entities.Owner;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
 @RunWith(AndroidJUnit4.class)
 public class LinkingObjectsDynamicTests {
 
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
     private Realm realm;
+    private DynamicRealm dynamicRealm;
 
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
+        dynamicRealm = DynamicRealm.getInstance(realmConfig);
     }
 
     @After
@@ -45,6 +69,418 @@ public void tearDown() {
         if (realm != null) {
             realm.close();
         }
+
+        if (dynamicRealm != null) {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void linkingObjects_classIsNull() throws Exception {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(null, AllJavaTypes.FIELD_INT);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(StandardRealmSchema.EMPTY_STRING_MSG, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_fieldIsNull() throws Exception {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Non-null 'srcFieldName' required.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_nonExistentClass() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects("ThisClassDoesNotExist", AllJavaTypes.FIELD_INT);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertTrue(expected.getMessage().startsWith("Class not found"));
+        }
+    }
+
+    @Test
+    public void linkingObjects_nonExistentField() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, "fieldNotExist");
+            fail();
+        } catch (IllegalArgumentException expected) {
+            final String expectedMessage = String.format(Locale.ENGLISH,
+                    "Field name '%s' does not exist on schema for '%s'",
+                    "fieldNotExist", AllJavaTypes.CLASS_NAME);
+            assertEquals(expectedMessage, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_ignoredExistentField() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_IGNORED);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            final String expectedMessage = String.format(Locale.ENGLISH,
+                    "Field name '%s' does not exist on schema for '%s'",
+                    AllJavaTypes.FIELD_IGNORED, AllJavaTypes.CLASS_NAME);
+            assertEquals(expectedMessage, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_linkQueryNotSupported() throws Exception {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_OBJECT);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(DynamicRealmObject.MSG_LINK_QUERY_NOT_SUPPORTED, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_invalidFieldType() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        for (RealmFieldType fieldType : RealmFieldType.values()) {
+            try {
+                switch (fieldType) {
+                    // skip valid types
+                    case OBJECT: // fall-through
+                    case LIST:
+                        continue;
+                        // skip unsupported types
+                    case UNSUPPORTED_TABLE: // fall-through
+                    case UNSUPPORTED_MIXED: // fall-through
+                    case UNSUPPORTED_DATE:
+                        continue;
+                    case INTEGER:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_INT);
+                        break;
+                    case BOOLEAN:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BOOLEAN);
+                        break;
+                    case STRING:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_STRING);
+                        break;
+                    case BINARY:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BINARY);
+                        break;
+                    case DATE:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DATE);
+                        break;
+                    case FLOAT:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_FLOAT);
+                        break;
+                    case DOUBLE:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DOUBLE);
+                        break;
+                    default:
+                        fail("unknown type: " + fieldType);
+                        break;
+                }
+                fail();
+            } catch (IllegalArgumentException expected) {
+                assertTrue(expected.getMessage().startsWith("Unexpected field type"));
+            }
+        }
+    }
+
+    @Test
+    public void linkingObjects_linkedByOBJECT_backlinksDefinedInModel() {
+        final int numSourceOfTarget1 = 3;
+        final int numSourceOfTarget2 = 2;
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                // create sources of target1
+                for (int i = 0; i < numSourceOfTarget1; i++) {
+                    final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                    source.setName("source" + i + "_target1");
+                    source.setChild(target1);
+                }
+
+                final BacklinksTarget target2 = realm.createObject(BacklinksTarget.class);
+                target2.setId(2);
+
+                // create sources of target2
+                for (int i = 0; i < numSourceOfTarget2; i++) {
+                    final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                    source.setName("source" + i + "_target2");
+                    source.setChild(target2);
+                }
+
+                // target3 has no owner
+                final BacklinksTarget target3 = realm.createObject(BacklinksTarget.class);
+                target3.setId(3);
+            }
+        });
+
+        final DynamicRealmObject target1 = dynamicRealm.where(BacklinksTarget.CLASS_NAME).equalTo(BacklinksTarget.FIELD_ID, 1).findFirst();
+        final RealmResults<DynamicRealmObject> target1Sources = target1.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        assertNotNull(target1Sources);
+        assertEquals(numSourceOfTarget1, target1Sources.size());
+        for (DynamicRealmObject target1Source : target1Sources) {
+            assertEquals(BacklinksSource.CLASS_NAME, target1Source.getType());
+            assertTrue(target1Source.getString(BacklinksSource.FIELD_NAME).endsWith("_target1"));
+            assertEquals(target1, target1Source.getObject(BacklinksSource.FIELD_CHILD));
+        }
+
+        final DynamicRealmObject target2 = dynamicRealm.where(BacklinksTarget.CLASS_NAME).equalTo(BacklinksTarget.FIELD_ID, 2).findFirst();
+        final RealmResults<DynamicRealmObject> target2Sources = target2.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        assertNotNull(target2Sources);
+        assertEquals(numSourceOfTarget2, target2Sources.size());
+        for (DynamicRealmObject target2Source : target2Sources) {
+            assertEquals(BacklinksSource.CLASS_NAME, target2Source.getType());
+            assertTrue(target2Source.getString(BacklinksSource.FIELD_NAME).endsWith("_target2"));
+            assertEquals(target2, target2Source.getObject(BacklinksSource.FIELD_CHILD));
+        }
+
+        final DynamicRealmObject target3 = dynamicRealm.where(BacklinksTarget.CLASS_NAME).equalTo(BacklinksTarget.FIELD_ID, 3).findFirst();
+        final RealmResults<DynamicRealmObject> target3Sources = target3.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        assertNotNull(target3Sources);
+        assertTrue(target3Sources.isEmpty());
+    }
+
+    @Test
+    public void linkingObjects_linkedByOBJECT_backlinksNotDefinedInModel() {
+        final int numOwnersOfCat1 = 3;
+        final int numOwnersOfCat2 = 2;
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Cat cat1 = realm.createObject(Cat.class);
+                cat1.setName("cat1");
+
+                // create owners of cat1
+                for (int i = 0; i < numOwnersOfCat1; i++) {
+                    final Owner owner = realm.createObject(Owner.class);
+                    owner.setName("owner" + i + "_cat1");
+                    owner.setCat(cat1);
+                }
+
+                final Cat cat2 = realm.createObject(Cat.class);
+                cat2.setName("cat2");
+
+                // create owners of cat2
+                for (int i = 0; i < numOwnersOfCat2; i++) {
+                    final Owner owner = realm.createObject(Owner.class);
+                    owner.setName("owner" + i + "_cat2");
+                    owner.setCat(cat2);
+                }
+
+                // cat3 has no owner
+                final Cat cat3 = realm.createObject(Cat.class);
+                cat3.setName("cat3");
+            }
+        });
+
+        final DynamicRealmObject cat1 = dynamicRealm.where(Cat.CLASS_NAME).equalTo(Cat.FIELD_NAME, "cat1").findFirst();
+        final RealmResults<DynamicRealmObject> cat1Owners = cat1.linkingObjects(Owner.CLASS_NAME, Owner.FIELD_CAT);
+        assertNotNull(cat1Owners);
+        assertEquals(numOwnersOfCat1, cat1Owners.size());
+        for (DynamicRealmObject cat1Owner : cat1Owners) {
+            assertEquals(Owner.CLASS_NAME, cat1Owner.getType());
+            assertTrue(cat1Owner.getString(Owner.FIELD_NAME).endsWith("_cat1"));
+            assertEquals(cat1, cat1Owner.getObject(Owner.FIELD_CAT));
+        }
+
+        final DynamicRealmObject cat2 = dynamicRealm.where(Cat.CLASS_NAME).equalTo(Cat.FIELD_NAME, "cat2").findFirst();
+        final RealmResults<DynamicRealmObject> cat2Owners = cat2.linkingObjects(Owner.CLASS_NAME, Owner.FIELD_CAT);
+        assertNotNull(cat2Owners);
+        assertEquals(numOwnersOfCat2, cat2Owners.size());
+        for (DynamicRealmObject cat2Owner : cat2Owners) {
+            assertEquals(Owner.CLASS_NAME, cat2Owner.getType());
+            assertTrue(cat2Owner.getString(Owner.FIELD_NAME).endsWith("_cat2"));
+            assertEquals(cat2, cat2Owner.getObject(Owner.FIELD_CAT));
+        }
+
+        final DynamicRealmObject cat3 = dynamicRealm.where(Cat.CLASS_NAME).equalTo(Cat.FIELD_NAME, "cat3").findFirst();
+        final RealmResults<DynamicRealmObject> cat3Owners = cat3.linkingObjects(Owner.CLASS_NAME, Owner.FIELD_CAT);
+        assertNotNull(cat3Owners);
+        assertTrue(cat3Owners.isEmpty());
+    }
+
+    @Test
+    public void linkingObjects_linkedByLIST() {
+        //           source100          source200        source300
+        //            //    \\          \\ || //
+        //        target1   target2     target2
+        //
+        //  // = list ref
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final AllJavaTypes target1 = realm.createObject(AllJavaTypes.class, 1L);
+                final AllJavaTypes target2 = realm.createObject(AllJavaTypes.class, 2L);
+                final AllJavaTypes target3 = realm.createObject(AllJavaTypes.class, 3L);
+
+                final AllJavaTypes source100 = realm.createObject(AllJavaTypes.class, 100L);
+                source100.getFieldList().add(target1);
+                source100.getFieldList().add(target2);
+
+                // list contains three target2s
+                final AllJavaTypes source200 = realm.createObject(AllJavaTypes.class, 200L);
+                source200.getFieldList().add(target2);
+                source200.getFieldList().add(target2);
+                source200.getFieldList().add(target2);
+            }
+        });
+
+        final DynamicRealmObject target1 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 1L).findFirst();
+        final DynamicRealmObject target2 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 2L).findFirst();
+        final DynamicRealmObject target3 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 3L).findFirst();
+
+        // tests sources of target1
+        final RealmResults<DynamicRealmObject> target1Sources = target1.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_LIST);
+        assertNotNull(target1Sources);
+        assertEquals(1, target1Sources.size());
+        assertEquals(AllJavaTypes.CLASS_NAME, target1Sources.first().getType());
+        assertEquals(100L, target1Sources.first().getLong(AllJavaTypes.FIELD_ID));
+        assertTrue(target1Sources.first().getList(AllJavaTypes.FIELD_LIST).contains(target1));
+        assertTrue(target1Sources.first().getList(AllJavaTypes.FIELD_LIST).contains(target2));
+        assertFalse(target1Sources.first().getList(AllJavaTypes.FIELD_LIST).contains(target3));
+
+        // tests sources of target2
+        final RealmResults<DynamicRealmObject> target2Sources = target2.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_LIST);
+        assertNotNull(target2Sources);
+        // if a source (in this test, source200) contains multiple references to a target in one RealmList, those must not be aggregated.
+        assertEquals(4, target2Sources.size());
+        boolean source100Found = false;
+        boolean source200Found = false;
+        for (DynamicRealmObject target2Source : target2Sources) {
+            final long idValue = target2Source.getLong(AllJavaTypes.FIELD_ID);
+            if (idValue == 100L) {
+                source100Found = true;
+            } else if (idValue == 200L) {
+                source200Found = true;
+            } else {
+                fail("unexpected id value: " + idValue);
+            }
+
+            assertEquals(AllJavaTypes.CLASS_NAME, target2Source.getType());
+            assertTrue(target2Source.getList(AllJavaTypes.FIELD_LIST).contains(target2));
+            assertFalse(target2Source.getList(AllJavaTypes.FIELD_LIST).contains(target3));
+        }
+        assertTrue(source100Found);
+        assertTrue(source200Found);
+
+        // tests sources of target3
+        final RealmResults<DynamicRealmObject> target3Sources = target3.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_LIST);
+        assertNotNull(target3Sources);
+        assertTrue(target3Sources.isEmpty());
+
+        dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+            @Override
+            public void execute(DynamicRealm realm) {
+                final DynamicRealmObject source200 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 200L).findFirst();
+                // remove last reference in the list
+                source200.getList(AllJavaTypes.FIELD_LIST).remove(2);
+            }
+        });
+
+        // backlinks are also updated
+        assertEquals(3, target2Sources.size());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void linkingObjects_IllegalStateException_ifNotYetLoaded() {
+        final Realm realm = looperThread.getRealm();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target1);
+            }
+        });
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        try {
+            final DynamicRealmObject targetAsync = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
+                    .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirstAsync();
+            // precondition
+            assertFalse(targetAsync.isLoaded());
+
+            thrown.expect(IllegalStateException.class);
+            targetAsync.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void linkingObjects_IllegalStateException_ifDeleted() {
+        final Realm realm = looperThread.getRealm();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target1);
+            }
+        });
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        try {
+            final DynamicRealmObject target = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
+                    .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
+
+            dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+                @Override
+                public void execute(DynamicRealm realm) {
+                    target.deleteFromRealm();
+                }
+            });
+
+            // precondition
+            assertFalse(target.isValid());
+
+            thrown.expect(IllegalStateException.class);
+            target.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        } finally {
+            dynamicRealm.close();
+        }
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
index 94fc826d44..c89c7666f2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
@@ -65,45 +65,22 @@ public void copyFromRealm() {
         assertEquals(parent, child.getObjectParents().first());
 
         AllJavaTypes unmanagedChild = realm.copyFromRealm(child);
-        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
-    }
-
-    // When managed, an object's backlinks fields get live.
-    @Test
-    public void copyToRealm() {
-        AllJavaTypes unmanagedChild = new AllJavaTypes(1);
-
-        realm.beginTransaction();
-        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
-        realm.commitTransaction();
-        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
-
-        realm.beginTransaction();
-        AllJavaTypes child = realm.copyToRealm(unmanagedChild);
-        parent.setFieldObject(child);
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> parents = child.getObjectParents();
-        assertNotNull(parents);
-        assertEquals(1, parents.size());
-        assertEquals(parent, parents.first());
+        assertNull(unmanagedChild.getObjectParents());
     }
 
     // Test round-trip
     @Test
     public void copyToAndFromRealm() {
         AllJavaTypes unmanagedChild = new AllJavaTypes(1);
+        assertNull(unmanagedChild.getObjectParents());
 
         realm.beginTransaction();
         AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
-        realm.commitTransaction();
-        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
-
-        realm.beginTransaction();
         AllJavaTypes child = realm.copyToRealm(unmanagedChild);
         parent.setFieldObject(child);
         realm.commitTransaction();
 
+        // When managed, an object's backlinks fields get live.
         RealmResults<AllJavaTypes> parents = child.getObjectParents();
         assertNotNull(parents);
         assertEquals(1, parents.size());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index d04ed040bf..6bd6945524 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -406,6 +406,60 @@ public void onError(Throwable error) {
         }
     }
 
+    // https://github.com/realm/realm-java/issues/4595#issuecomment-298830411
+    // onSuccess might commit another transaction which will call didChange. So before calling async transaction
+    // callbacks, the callback should be cleared.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling() {
+        final AtomicInteger callbackCounter = new AtomicInteger(0);
+        final Realm foregroundRealm = looperThread.getRealm();
+
+        // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.
+        // We just disable the auto refresh here then the did_change won't be called.
+        foregroundRealm.setAutoRefresh(false);
+        foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                // This will be called first and only once
+                assertEquals(0, callbackCounter.getAndIncrement());
+
+                // This transaction should never trigger the onSuccess.
+                foregroundRealm.beginTransaction();
+                foregroundRealm.createObject(AllTypes.class);
+                foregroundRealm.commitTransaction();
+            }
+        });
+
+        foregroundRealm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+                // Delay to post this to ensure the async transaction posted callback will arrive first.
+                looperThread.postRunnableDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Manually call refresh, so the did_change will be triggered.
+                        foregroundRealm.sharedRealm.refresh();
+                        foregroundRealm.setAutoRefresh(true);
+                    }
+                }, 50);
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                // This will be called 2nd and only once
+                assertEquals(1, callbackCounter.getAndIncrement());
+                looperThread.testComplete();
+            }
+        });
+    }
+
     // ************************************
     // *** promises based async queries ***
     // ************************************
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
index ece9bca332..1fecbb552d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
@@ -19,10 +19,22 @@
 
 public class BacklinksSource extends RealmObject {
     public static final String CLASS_NAME = "BacklinksSource";
+    public static final String FIELD_NAME = "name";
     public static final String FIELD_CHILD = "child";
 
+
+    private String name;
+
     private BacklinksTarget child;
 
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
     public BacklinksTarget getChild() {
         return child;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
index da3ee95be2..ca20d5d42c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
@@ -26,7 +26,7 @@
 
     private int id;
 
-    @LinkingObjects("child")
+    @LinkingObjects(BacklinksSource.FIELD_CHILD)
     private final RealmResults<BacklinksSource> parents = null;
 
     public int getId() {
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 0d1d518201..e8dcd1b15a 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -35,6 +35,7 @@
  */
 @SuppressWarnings("WeakerAccess")
 public class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
+    static final String MSG_LINK_QUERY_NOT_SUPPORTED = "Queries across relationships are not supported";
 
     private final ProxyState proxyState = new ProxyState(this);
 
@@ -69,7 +70,7 @@ public DynamicRealmObject(RealmModel obj) {
         proxyState.setConstructionFinished();
     }
 
-    // row must not be an instance of UncheckedRow
+    // row must be an instance of CheckedRow or InvalidRow
     DynamicRealmObject(BaseRealm realm, Row row) {
         proxyState.setRealm$realm(realm);
         proxyState.setRow$realm(row);
@@ -925,6 +926,51 @@ public String toString() {
         return sb.toString();
     }
 
+    /**
+     * Returns {@link RealmResults} containing all {@code srcClassName} class objects that have a relationship
+     * to this object from {@code srcFieldName} field.
+     * <p>
+     * An entry is added for each reference, e.g. if the same reference is in a list multiple times,
+     * the src object will show up here multiple times.
+     *
+     * @param srcClassName name of the class returned objects belong to.
+     * @param srcFieldName name of the field in the source class that holds a reference to this object.
+     *                    Field type must be either {@code io.realm.RealmFieldType.OBJECT} or {@code io.realm.RealmFieldType.LIST}.
+     * @return the result.
+     * @throws IllegalArgumentException if the {@code srcClassName} is {@code null} or does not exist,
+     * the {@code srcFieldName} is {@code null} or does not exist,
+     * type of the source field is not supported.
+     */
+    public RealmResults<DynamicRealmObject> linkingObjects(String srcClassName, String srcFieldName) {
+        final DynamicRealm realm = (DynamicRealm) proxyState.getRealm$realm();
+        realm.checkIfValid();
+        proxyState.getRow$realm().checkIfAttached();
+
+        final RealmSchema schema = realm.getSchema();
+        final RealmObjectSchema realmObjectSchema = schema.get(srcClassName);
+        if (realmObjectSchema == null) {
+            throw new IllegalArgumentException("Class not found: " + srcClassName);
+        }
+
+        if (srcFieldName == null) {
+            throw new IllegalArgumentException("Non-null 'srcFieldName' required.");
+        }
+        if (srcFieldName.contains(".")) {
+            throw new IllegalArgumentException(MSG_LINK_QUERY_NOT_SUPPORTED);
+        }
+
+        final RealmFieldType fieldType = realmObjectSchema.getFieldType(srcFieldName); // throws IAE if not found
+        if (fieldType != RealmFieldType.OBJECT && fieldType != RealmFieldType.LIST) {
+            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
+                    "Unexpected field type: %1$s. Field type should be either %2$s.%3$s or %2$s.%4$s.",
+                    fieldType.name(),
+                    RealmFieldType.class.getSimpleName(),
+                    RealmFieldType.OBJECT.name(), RealmFieldType.LIST.name()));
+        }
+
+        return RealmResults.createBacklinkResults(realm, (CheckedRow) proxyState.getRow$realm(), realmObjectSchema.getTable(), srcFieldName);
+    }
+
     @Override
     public void realm$injectObjectContext() {
         // nothing to do for DynamicRealmObject
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 60c8c3b1fa..6eae995442 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -19,6 +19,7 @@
 
 import android.os.Looper;
 
+import io.realm.internal.CheckedRow;
 import io.realm.internal.Collection;
 import io.realm.internal.Row;
 import io.realm.internal.SortDescriptor;
@@ -55,18 +56,21 @@
  * @see Realm#executeTransaction(Realm.Transaction)
  */
 public class RealmResults<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
-    static <T extends RealmModel> RealmResults<T> createBacklinkResults(BaseRealm realm, Row row, Class<T> srcTableType, String srcFieldName) {
-        if (!(row instanceof UncheckedRow)) {
-            throw new IllegalArgumentException("Row is " + row.getClass());
-        }
-        UncheckedRow uncheckedRow = (UncheckedRow) row;
+    static <T extends RealmModel> RealmResults<T> createBacklinkResults(Realm realm, UncheckedRow row, Class<T> srcTableType, String srcFieldName) {
         Table srcTable = realm.getSchema().getTable(srcTableType);
         return new RealmResults<T>(
                 realm,
-                Collection.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
+                Collection.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
                 srcTableType);
     }
 
+    static RealmResults<DynamicRealmObject> createBacklinkResults(DynamicRealm realm, CheckedRow row, Table srcTable, String srcFieldName) {
+        return new RealmResults<>(
+                realm,
+                Collection.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
+                Table.tableNameToClassName(srcTable.getName()));
+    }
+
 
     RealmResults(BaseRealm realm, Collection collection, Class<E> clazz) {
         super(realm, collection, clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
index d46fb453ea..3591817aed 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
@@ -736,7 +736,7 @@ private long getColumnIndex(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
         if (columnIndex == -1) {
             throw new IllegalArgumentException(
-                    String.format("Field name '%s' does not exist on schema for '%s",
+                    String.format("Field name '%s' does not exist on schema for '%s'",
                             fieldName, getClassName()
                     ));
         }
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
index bcec1169fb..280309bb0d 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -36,7 +36,7 @@
 class StandardRealmSchema extends RealmSchema {
 
     static final String TABLE_PREFIX = Table.TABLE_PREFIX;
-    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+    static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
 
     // Caches Dynamic Class objects given as Strings to Realm Tables
     private final Map<String, Table> dynamicClassToTable = new HashMap<>();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
index 3493dd4707..279c559606 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -97,10 +97,16 @@ protected RealmNotifier(SharedRealm sharedRealm) {
     // called from java_binding_context.cpp
     void didChange() {
         realmObserverPairs.foreach(onChangeCallBack);
-        for (Runnable runnable : transactionCallbacks) {
-            runnable.run();
+
+        if (!transactionCallbacks.isEmpty()) {
+            // The callback list needs to be cleared before calling to avoid synchronized transactions in the callback
+            // triggers it recursively.
+            List<Runnable> callbacks = transactionCallbacks;
+            transactionCallbacks = new ArrayList<Runnable>();
+            for (Runnable runnable : callbacks) {
+                runnable.run();
+            }
         }
-        transactionCallbacks.clear();
     }
 
     // Called from JavaBindingContext::before_notify.
diff --git a/tools/release.sh b/tools/release.sh
index 33a01831b7..e355ee2744 100755
--- a/tools/release.sh
+++ b/tools/release.sh
@@ -213,8 +213,9 @@ publish_javadoc() {
         esac
     done
     git clean -xfd ./source/en/docs/java/
+    bundle update
     bundle exec rake generate:java_docs[$VERSION]
-    cp -R "${REALM_JAVA_PATH}/realm/realm-library/build/docs/javadoc/*" ./source/en/docs/java/latest/api/
+    cp -R "${REALM_JAVA_PATH}"/realm/realm-library/build/docs/javadoc/* ./source/en/docs/java/latest/api/
     bundle exec rake generate:inject_ga_latest_java_api
     git add ./source/en/docs/java/
     git commit -m "Release realm-java doc ${VERSION}"
