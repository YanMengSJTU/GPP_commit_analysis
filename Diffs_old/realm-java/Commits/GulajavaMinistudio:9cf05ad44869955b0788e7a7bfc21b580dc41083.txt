diff --git a/CHANGELOG.md b/CHANGELOG.md
index 28ecdd0257..fc898d950f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,6 +11,7 @@
 
 * Added missing `RealmQuery.oneOf()` for Kotlin that accepts non-nullable types (#5717).
 * [ObjectServer] Fixed an issue preventing sync to resume when the network is back (#5677).
+* [ObjectServer] Fixed an issue where login after a logout will not resume Syncing (https://github.com/realm/my-first-realm-app/issues/22).
 
 ## 4.3.3 (2018-01-19)
 
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 152a993251..e4144720b5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -20,6 +20,7 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -39,6 +40,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -75,7 +77,7 @@ public void get_syncValues() {
 
     @Test
     public void addDownloadProgressListener_nullThrows() {
-        SyncSession session = SyncManager.getSession(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
         try {
             session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);
             fail();
@@ -85,7 +87,7 @@ public void addDownloadProgressListener_nullThrows() {
 
     @Test
     public void addUploadProgressListener_nullThrows() {
-        SyncSession session = SyncManager.getSession(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
         try {
             session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);
             fail();
@@ -96,7 +98,7 @@ public void addUploadProgressListener_nullThrows() {
     @Test
     public void removeProgressListener() {
         Realm realm = Realm.getInstance(configuration);
-        SyncSession session = SyncManager.getSession(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
         ProgressListener[] listeners = new ProgressListener[] {
                 null,
                 progress -> {
@@ -143,7 +145,7 @@ public void errorHandler_clientResetReported() {
         looperThread.addTestRealm(realm);
 
         // Trigger error
-        SyncManager.simulateClientReset(SyncManager.getSession(config));
+        SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));
     }
 
     // Check that we can manually execute the Client Reset.
@@ -181,7 +183,7 @@ public void errorHandler_manualExecuteClientReset() {
         looperThread.addTestRealm(realm);
 
         // Trigger error
-        SyncManager.simulateClientReset(SyncManager.getSession(config));
+        SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));
     }
 
     // Check that we can use the backup SyncConfiguration to open the Realm.
@@ -237,7 +239,7 @@ public void errorHandler_useBackupSyncConfigurationForClientReset() {
         looperThread.addTestRealm(realm);
 
         // Trigger error
-        SyncManager.simulateClientReset(SyncManager.getSession(config));
+        SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));
     }
 
     // Check that we can open the backup file without using the provided SyncConfiguration,
@@ -320,7 +322,7 @@ public void errorHandler_useBackupSyncConfigurationAfterClientReset() {
         looperThread.addTestRealm(realm);
 
         // Trigger error
-        SyncManager.simulateClientReset(SyncManager.getSession(config));
+        SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));
     }
 
     // make sure the backup file Realm is encrypted with the same key as the original synced Realm.
@@ -381,7 +383,7 @@ public void errorHandler_useClientResetEncrypted() {
         looperThread.addTestRealm(realm);
 
         // Trigger error
-        SyncManager.simulateClientReset(SyncManager.getSession(config));
+        SyncManager.simulateClientReset(SyncManager.getOrCreateSession(config, null));
     }
 
     @Test
@@ -389,7 +391,7 @@ public void errorHandler_useClientResetEncrypted() {
     public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {
         Realm realm = Realm.getInstance(configuration);
         try {
-            SyncManager.getSession(configuration).uploadAllLocalChanges();
+            SyncManager.getOrCreateSession(configuration, null).uploadAllLocalChanges();
             fail("Should throw an IllegalStateException on Ui Thread");
         } catch (IllegalStateException ignored) {
         } finally {
@@ -402,7 +404,7 @@ public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException
     public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {
         Realm realm = Realm.getInstance(configuration);
         try {
-            SyncManager.getSession(configuration).downloadAllServerChanges();
+            SyncManager.getOrCreateSession(configuration, null).downloadAllServerChanges();
             fail("Should throw an IllegalStateException on Ui Thread");
         } catch (IllegalStateException ignored) {
         } finally {
@@ -424,7 +426,7 @@ public void unrecognizedErrorCode_errorHandler() {
                 })
                 .build();
         Realm realm = Realm.getInstance(configuration);
-        SyncSession session = SyncManager.getSession(configuration);
+        SyncSession session = SyncManager.getOrCreateSession(configuration, null);
 
         TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
         RealmLog.add(testLogger);
@@ -437,4 +439,21 @@ public void unrecognizedErrorCode_errorHandler() {
 
         realm.close();
     }
+
+    @Test
+    public void getSessionThrowsOnNonExistingSession() {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+        assertEquals(configuration, session.getConfiguration());
+
+        // Closing the Realm should remove the session
+        realm.close();
+        try {
+            SyncManager.getSession(configuration);
+            fail("getSession should throw an ISE");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "No SyncSession found using the path : "));
+        }
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 43381058c4..7e022ed57f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -19,6 +19,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.URI;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
 import java.security.cert.CertificateException;
@@ -201,15 +202,43 @@ public static void setDefaultSessionErrorHandler(@Nullable SyncSession.ErrorHand
         }
     }
 
+    /**
+     * Gets a cached {@link SyncSession} for the given {@link SyncConfiguration} or throw if no one exists yet.
+     *
+     * A session should exist after you open a Realm with a {@link SyncConfiguration}.
+     *
+     * @param syncConfiguration configuration object for the synchronized Realm.
+     * @return the {@link SyncSession} for the specified Realm.
+     * @throws IllegalArgumentException if syncConfiguration is {@code null}.
+     * @throws IllegalStateException if the session could not be found using the provided {@code SyncConfiguration}.
+     */
+    public static synchronized SyncSession getSession(SyncConfiguration syncConfiguration) throws IllegalStateException {
+        //noinspection ConstantConditions
+        if (syncConfiguration == null) {
+            throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
+        }
+
+        SyncSession session = sessions.get(syncConfiguration.getPath());
+        if (session == null) {
+            throw new IllegalStateException("No SyncSession found using the path : " + syncConfiguration.getPath()
+            + "\nplease ensure to call this method after you've open the Realm");
+        }
+
+        return session;
+    }
+
     /**
      * Gets any cached {@link SyncSession} for the given {@link SyncConfiguration} or create a new one if
      * no one exists.
      *
+     * Note: This is mainly for internal usage, consider using {@link #getSession(SyncConfiguration)} instead.
+     *
      * @param syncConfiguration configuration object for the synchronized Realm.
+     * @param resolvedRealmURL resolved Realm URL with the user specific part if not a global Realm.
      * @return the {@link SyncSession} for the specified Realm.
      * @throws IllegalArgumentException if syncConfiguration is {@code null}.
      */
-    public static synchronized SyncSession getSession(SyncConfiguration syncConfiguration) {
+    public static synchronized SyncSession getOrCreateSession(SyncConfiguration syncConfiguration, @Nullable URI resolvedRealmURL) {
         // This will not create a new native (Object Store) session, this will only associate a Realm's path
         // with a SyncSession. Object Store's SyncManager is responsible of the life cycle (including creation)
         // of the native session, the provided Java wrap, helps interact with the native session, when reporting error
@@ -228,6 +257,15 @@ public static synchronized SyncSession getSession(SyncConfiguration syncConfigur
                 RealmLog.debug("first session created add network listener");
                 NetworkStateReceiver.addListener(networkListener);
             }
+            if (resolvedRealmURL != null) {
+                session.setResolvedRealmURI(resolvedRealmURL);
+                // Currently when the user login, the Object Store will try to revive it's inactive sessions
+                // (stored previously after a logout). this will cause the OS to call bindSession to obtain an
+                // access token, however since the Realm might not be open yet, the wrapObjectStoreSessionIfRequired
+                // will not be invoked to wrap the OS store session with the Java session, the Sync client to not resume
+                // syncing.
+                session.getAccessToken(authServer, "");
+            }
         }
 
         return session;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 30ff8c8ad2..f05656a86f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -378,7 +378,7 @@ public void uploadAllLocalChanges() throws InterruptedException {
         }
     }
 
-    public void setResolvedRealmURI(URI resolvedRealmURI) {
+    void setResolvedRealmURI(URI resolvedRealmURI) {
         this.resolvedRealmURI = resolvedRealmURI;
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index ce82386309..1fe9941442 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -33,6 +33,7 @@
 
 import javax.annotation.Nullable;
 
+import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.Util;
 import io.realm.internal.android.AndroidCapabilities;
@@ -229,9 +230,13 @@ public void logout() {
 
             // invalidate all pending refresh_token queries
             for (SyncConfiguration syncConfiguration : realms.keySet()) {
-                SyncSession session = SyncManager.getSession(syncConfiguration);
-                if (session != null) {
+                try {
+                    SyncSession session = SyncManager.getSession(syncConfiguration);
                     session.clearScheduledAccessTokenRefresh();
+                } catch (IllegalStateException e) {
+                    if (!e.getMessage().contains("No SyncSession found")) {
+                        throw e;
+                    }// else no session, either the Realm was not opened or session was removed.
                 }
             }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index 2b8616e8d7..e75638e138 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -106,8 +106,7 @@ public static Context getApplicationContext() {
     @Override
     public void wrapObjectStoreSessionIfRequired(OsRealmConfig config) {
         if (config.getRealmConfiguration() instanceof SyncConfiguration) {
-            SyncSession session = SyncManager.getSession((SyncConfiguration) config.getRealmConfiguration());
-            session.setResolvedRealmURI(config.getResolvedRealmURI());
+            SyncManager.getOrCreateSession((SyncConfiguration) config.getRealmConfiguration(), config.getResolvedRealmURI());
         }
     }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index cf3602bfe1..ccaf33d00a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -7,7 +7,6 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Assert;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index 7eaa41f60a..70db449819 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -40,6 +40,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 
@@ -49,6 +50,38 @@
 @RunWith(AndroidJUnit4.class)
 public class SyncedRealmTests extends StandardIntegrationTest {
 
+
+    @Test
+    public void loginLogoutResumeSyncing() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+        SyncManager.getSession(config).uploadAllLocalChanges();
+        user.logout();
+        realm.close();
+        assertTrue(Realm.deleteRealm(config));
+
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        SyncConfiguration config2 = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+
+        Realm realm2 = Realm.getInstance(config2);
+        SyncManager.getSession(config2).downloadAllServerChanges();
+        realm2.refresh();
+        assertEquals(1, realm2.where(StringOnly.class).count());
+        realm2.close();
+    }
+
     @Test
     @UiThreadTest
     public void waitForInitialRemoteData_mainThreadThrows() {
