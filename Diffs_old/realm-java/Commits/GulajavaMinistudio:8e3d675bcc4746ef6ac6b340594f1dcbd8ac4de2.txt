diff --git a/CHANGELOG.md b/CHANGELOG.md
index a0f18f81d7..d8b9721c92 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,17 +17,19 @@
 
 ## 5.8.0 (YYYY-MM-DD)
 
-This release also contains all changes in 5.8.0-BETA1 and 5.8.0-BETA2.
+This release also contains all changes from 5.8.0-BETA1 and 5.8.0-BETA2.
 
 ### Enhancements
 * [ObjectServer] Added Subscription class available to Query-based Realms. This exposes a Subscription more directly. This class is in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
-* [ObjectServer] Added `Realm.getSubscriptions()`, `Realm.getSubscriptions(String pattern)` and `Realm.getSubscription` to make it easier to find existing subscriptions. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
-* [ObjectServer] Added `RealmQuery.subscribe()` and `RealmQuery.subscribe(String name)` to subscribe immediately inside a transaction. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
-* [ObjectServer] Added support for subscribing directly inside `SyncConfiguration.initialData()`. This can be coupled with `SyncConfiguration.waitForInitialRemoteData()` in order to block a Realm from opening until the initial subscriptions are ready and have downloaded data. This API are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
+* [ObjectServer] Added `Realm.getSubscriptions()`, `Realm.getSubscriptions(String pattern)` and `Realm.getSubscription` to make it easier to find existing subscriptions. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231)
+* [ObjectServer] Added `RealmQuery.subscribe()` and `RealmQuery.subscribe(String name)` to subscribe immediately inside a transaction. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231)
+* [ObjectServer] Added support for subscribing directly inside `SyncConfiguration.initialData()`. This can be coupled with `SyncConfiguration.waitForInitialRemoteData()` in order to block a Realm from opening until the initial subscriptions are ready and have downloaded data. This API are in beta. [#6231](https://github.com/realm/realm-java/pull/6231)
 * [ObjectServer] Improved performance when merging changes from the server.
 * [ObjectServer] Added support for timeouts when uploading or downloading data manually using `SyncSession.downloadAllServerChanges(long timeout, TimeUnit unit)` and `SyncSession.uploadAllLocalChanges(long timeout, TimeUnit unit)`. [#6073](https://github.com/realm/realm-java/pull/6073)
 * [ObjectServer] Added support for timing out when downloading initial data for synchronized Realms using `SyncConfiguration.waitForInitialRemoteData(long timeout, TimeUnit unit)`. [#6247](https://github.com/realm/realm-java/issues/6247)
-* Added support for `ImportFlag`s to `Realm.copyToRealm()` and `Realm.copyToRealmOrUpdate()`. This makes it possible to choose a mode so only fields that actually changed are written to disk. This improves notifications and Object Server performance. [#6224](https://github.com/realm/realm-java/pull/6224).
+* [ObjectServer] Added `Realm.init(Context, String)` which defines a custom User-Agent String sent to the Realm Object Server when a session is created. Using this requires Realm Object Server 3.12.4 or later. [#6267](https://github.com/realm/realm-java/issues/6267)
+* Added support for `ImportFlag`s to `Realm.copyToRealm()` and `Realm.copyToRealmOrUpdate()`. This makes it possible to choose a mode so only fields that actually changed are written to disk. This improves notifications and Object Server performance. [#6224](https://github.com/realm/realm-java/pull/6224)
+* Added support for bulk updating the same property in all objects that are part of a query result using `RealmResults.setValue(String fieldName, Object value)` or one of the specialized overrides that have been added for all supported types, e.g. `RealmResults.setString(String fieldName, String value)`. [#762](https://github.com/realm/realm-java/issues/762)
 
 ### Fixed
 * All known bugs introduced in 5.8.0-BETA1 and 5.8.0-BETA2. See the release notes for these releases.
diff --git a/README.md b/README.md
index 231131ca89..72b599d448 100644
--- a/README.md
+++ b/README.md
@@ -24,9 +24,9 @@ The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/j
 
 ## Getting Help
 
-- **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We actively monitor & answer questions on StackOverflow!
-- **Have a bug to report?** [Open an issue](https://github.com/realm/realm-java/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
-- **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new). Tell us what the feature should do, and why you want the feature.
+- **Got a question?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We actively monitor & answer questions on StackOverflow!
+- **Think you found a bug?** [Open an issue](https://github.com/realm/realm-java/issues/new?template=bug_report.md). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
+- **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new?template=feature_request.md). Tell us what the feature should do, and why you want the feature.
 - Sign up for our [**Community Newsletter**](https://go.pardot.com/l/210132/2017-04-26/3j74l) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
 
 ## Using Snapshots
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index cfcc837f6a..bcdc55e3a5 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -29,6 +29,11 @@ android {
             signingConfig signingConfigs.release
         }
     }
+
+    compileOptions {
+        sourceCompatibility 1.8
+        targetCompatibility 1.8
+    }
 }
 
 dependencies {
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
index 13586e83bc..16efd9642e 100644
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
@@ -1,4 +1,3 @@
-/*
  * Copyright 2018 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
index 45c3baf373..8490a274a9 100644
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
@@ -1,4 +1,3 @@
-/*
  * Copyright 2018 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/realm/kotlin-extensions/build.gradle b/realm/kotlin-extensions/build.gradle
index 80430f385b..2a505eed1a 100644
--- a/realm/kotlin-extensions/build.gradle
+++ b/realm/kotlin-extensions/build.gradle
@@ -61,6 +61,12 @@ android {
                 '../realm-library/src/syncTestUtils/java',
         ]
     }
+
+    // Required from Kotlin 1.1.2
+    compileOptions {
+        targetCompatibility 1.8
+        sourceCompatibility 1.8
+    }
 }
 
 dependencies {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 69364eb7a7..741d372d3f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -34,19 +34,26 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
+import io.realm.entities.MappedAllJavaTypes;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
 import io.realm.internal.OsResults;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -54,7 +61,7 @@
 @RunWith(AndroidJUnit4.class)
 public class RealmResultsTests extends CollectionTests {
 
-    private final static int TEST_DATA_SIZE = 2516;
+    private final static int TEST_DATA_SIZE = 100;
     private final static long YEAR_MILLIS = TimeUnit.DAYS.toMillis(365);
     private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
 
@@ -709,4 +716,950 @@ public void getRealm_throwsIfRealmClosed() {
         } catch (IllegalStateException ignore) {
         }
     }
+
+    private void populateMappedAllJavaTypes(int objects) {
+        realm.beginTransaction();
+        realm.deleteAll();
+        for (int i = 0; i < objects; ++i) {
+            MappedAllJavaTypes obj = realm.createObject(MappedAllJavaTypes.class, i);
+            obj.fieldBoolean =  ((i % 2) == 0);
+            obj.fieldBinary = (new byte[]{1, 2, 3});
+            obj.fieldDate = (new Date(YEAR_MILLIS * (i - objects / 2)));
+            obj.fieldDouble = (Math.PI + i);
+            obj.fieldFloat = (1.234567f + i);
+            obj.fieldString = ("test data " + i);
+            obj.fieldLong = i;
+            obj.fieldObject = obj;
+            obj.fieldList.add(obj);
+        }
+        realm.commitTransaction();
+    }
+
+    private void populateAllJavaTypes(int objects) {
+        realm.beginTransaction();
+        realm.deleteAll();
+        for (int i = 0; i < objects; ++i) {
+            AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
+            obj.setFieldBoolean((i % 2) == 0);
+            obj.setFieldBinary(new byte[]{1, 2, 3});
+            obj.setFieldDate(new Date(YEAR_MILLIS * (i - objects / 2)));
+            obj.setFieldDouble(Math.PI + i);
+            obj.setFieldFloat(1.234567f + i);
+            obj.setFieldString("test data " + i);
+            obj.setFieldLong(i);
+            obj.setFieldObject(obj);
+            obj.getFieldList().add(obj);
+        }
+        realm.commitTransaction();
+    }
+
+    enum BulkSetMethods {
+        STRING,
+        BOOLEAN,
+        BYTE,
+        SHORT,
+        INTEGER,
+        LONG,
+        FLOAT,
+        DOUBLE,
+        BINARY,
+        DATE,
+        OBJECT,
+        MODEL_LIST,
+        STRING_VALUE_LIST,
+        BOOLEAN_VALUE_LIST,
+        BYTE_VALUE_LIST,
+        SHORT_VALUE_LIST,
+        INTEGER_VALUE_LIST,
+        LONG_VALUE_LIST,
+        FLOAT_VALUE_LIST,
+        DOUBLE_VALUE_LIST,
+        BINARY_VALUE_LIST,
+        DATE_VALUE_LIST
+    }
+
+    interface ElementValidator<T> {
+        void validate(T obj);
+    }
+
+    private <T extends RealmModel> void assertElements(RealmResults<T> collection, ElementValidator<T> validator) {
+        for (T obj : collection) {
+            validator.validate(obj);
+        }
+    }
+
+    @Test
+    public void setValue() {
+        populateAllJavaTypes(5);
+        RealmResults<AllJavaTypes> collection = realm.where(AllJavaTypes.class).findAll();
+        realm.beginTransaction();
+        for (BulkSetMethods type : BulkSetMethods.values()) {
+            switch(type) {
+                case STRING:
+                    collection.setValue(AllJavaTypes.FIELD_STRING, "foo");
+                    assertElements(collection, obj -> assertEquals("foo", obj.getFieldString()));
+                    collection.setValue(AllJavaTypes.FIELD_STRING, null);
+                    assertElements(collection, obj -> assertEquals(null, obj.getFieldString()));
+                    break;
+                case BOOLEAN:
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN, true);
+                    assertElements(collection, obj -> assertTrue(obj.isFieldBoolean()));
+                    break;
+                case BYTE:
+                    collection.setValue(AllJavaTypes.FIELD_BYTE, (byte) 1);
+                    assertElements(collection, obj -> assertEquals((byte)1, obj.getFieldByte()));
+                    break;
+                case SHORT:
+                    collection.setValue(AllJavaTypes.FIELD_SHORT, (short) 2);
+                    assertElements(collection, obj -> assertEquals((short)2, obj.getFieldShort()));
+                    break;
+                case INTEGER:
+                    collection.setValue(AllJavaTypes.FIELD_INT, 3);
+                    assertElements(collection, obj -> assertEquals(3, obj.getFieldInt()));
+                    break;
+                case LONG:
+                    collection.setValue(AllJavaTypes.FIELD_LONG, 4L);
+                    assertElements(collection, obj -> assertEquals(4L, obj.getFieldLong()));
+                    break;
+                case FLOAT:
+                    collection.setValue(AllJavaTypes.FIELD_FLOAT, 1.23F);
+                    assertElements(collection, obj -> assertEquals(1.23F, obj.getFieldFloat(), 0F));
+                    break;
+                case DOUBLE:
+                    collection.setValue(AllJavaTypes.FIELD_DOUBLE, 1.234);
+                    assertElements(collection, obj -> assertEquals(1.234, obj.getFieldDouble(), 0F));
+                    break;
+                case BINARY:
+                    collection.setValue(AllJavaTypes.FIELD_BINARY, new byte[]{1,2,3});
+                    assertElements(collection, obj -> assertArrayEquals(new byte[]{1,2,3}, obj.getFieldBinary()));
+                    collection.setValue(AllJavaTypes.FIELD_BINARY, null);
+                    assertElements(collection, obj -> assertNull(obj.getFieldBinary()));
+                    break;
+                case DATE:
+                    collection.setValue(AllJavaTypes.FIELD_DATE, new Date(1000));
+                    assertElements(collection, obj -> assertEquals(new Date(1000), obj.getFieldDate()));
+                    collection.setValue(AllJavaTypes.FIELD_DATE, null);
+                    assertElements(collection, obj -> assertEquals(null, obj.getFieldDate()));
+                    break;
+                case OBJECT: {
+                    AllJavaTypes childObj = realm.createObject(AllJavaTypes.class, 42);
+                    collection.setValue(AllJavaTypes.FIELD_OBJECT, childObj);
+                    assertElements(collection, obj -> assertEquals(childObj, obj.getFieldObject()));
+                    collection.setValue(AllJavaTypes.FIELD_OBJECT, null);
+                    assertElements(collection, obj -> assertNull(obj.getFieldObject()));
+                    break;
+                }
+                case MODEL_LIST: {
+                    AllJavaTypes childObj = realm.createObject(AllJavaTypes.class, 43);
+                    collection.setValue(AllJavaTypes.FIELD_LIST, new RealmList<>(childObj));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.getFieldList().size());
+                        assertEquals(childObj, obj.getFieldList().first());
+                    });
+                    break;
+                }
+                case STRING_VALUE_LIST: {
+                    RealmList<String> list = new RealmList<>("Foo", "Bar");
+                    collection.setValue(AllJavaTypes.FIELD_STRING_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals("Foo", obj.getFieldStringList().first());
+                        assertEquals("Bar", obj.getFieldStringList().last());
+                    });
+                    break;
+                }
+                case BOOLEAN_VALUE_LIST: {
+                    RealmList<Boolean> list = new RealmList<>(true, false);
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertTrue(obj.getFieldBooleanList().first());
+                        assertFalse(obj.getFieldBooleanList().last());
+                    });
+                    break;
+                }
+                case BYTE_VALUE_LIST: {
+                    RealmList<Byte> list = new RealmList<>((byte) 1, (byte) 2);
+                    collection.setValue(AllJavaTypes.FIELD_BYTE_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Byte.valueOf((byte) 1), obj.getFieldByteList().first());
+                        assertEquals(Byte.valueOf((byte) 2), obj.getFieldByteList().last());
+                    });
+                    break;
+                }
+                case SHORT_VALUE_LIST: {
+                    RealmList<Short> list = new RealmList<>((short) 1, (short) 2);
+                    collection.setValue(AllJavaTypes.FIELD_SHORT_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Short.valueOf((short) 1), obj.getFieldShortList().first());
+                        assertEquals(Short.valueOf((short) 2), obj.getFieldShortList().last());
+                    });
+                    break;
+                }
+                case INTEGER_VALUE_LIST: {
+                    RealmList<Integer> list = new RealmList<>(1, 2);
+                    collection.setValue(AllJavaTypes.FIELD_INTEGER_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Integer.valueOf(1), obj.getFieldIntegerList().first());
+                        assertEquals(Integer.valueOf(2), obj.getFieldIntegerList().last());
+                    });
+                    break;
+                }
+                case LONG_VALUE_LIST: {
+                    RealmList<Long> list = new RealmList<>(1L, 2L);
+                    collection.setValue(AllJavaTypes.FIELD_LONG_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Long.valueOf(1), obj.getFieldLongList().first());
+                        assertEquals(Long.valueOf(2), obj.getFieldLongList().last());
+                    });
+                    break;
+                }
+                case FLOAT_VALUE_LIST: {
+                    RealmList<Float> list = new RealmList<>(1.1F, 2.2F);
+                    collection.setValue(AllJavaTypes.FIELD_FLOAT_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(1.1F, obj.getFieldFloatList().first(), 0F);
+                        assertEquals(2.2F, obj.getFieldFloatList().last(), 0F);
+                    });
+                    break;
+                }
+                case DOUBLE_VALUE_LIST: {
+                    RealmList<Double> list = new RealmList<>(1.1D, 2.2D);
+                    collection.setValue(AllJavaTypes.FIELD_DOUBLE_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(1.1D, obj.getFieldDoubleList().first(), 0D);
+                        assertEquals(2.2D, obj.getFieldDoubleList().last(), 0D);
+                    });
+                    break;
+                }
+                case BINARY_VALUE_LIST: {
+                    RealmList<byte[]> list = new RealmList<>(new byte[] {1,2,3}, new byte[] {2,3,4});
+                    collection.setValue(AllJavaTypes.FIELD_BINARY_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertArrayEquals(new byte[] {1,2,3}, obj.getFieldBinaryList().first());
+                        assertArrayEquals(new byte[] {2,3,4}, obj.getFieldBinaryList().last());
+                    });
+                    break;
+                }
+                case DATE_VALUE_LIST:  {
+                    RealmList<Date> list = new RealmList<>(new Date(1000), new Date(2000));
+                    collection.setValue(AllJavaTypes.FIELD_DATE_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(new Date(1000), obj.getFieldDateList().first());
+                        assertEquals(new Date(2000), obj.getFieldDateList().last());
+                    });
+                    break;
+                }
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void setValue_implicitConversions() {
+        populateAllJavaTypes(5);
+        RealmResults<AllJavaTypes> collection = realm.where(AllJavaTypes.class).findAll();
+        realm.beginTransaction();
+        for (BulkSetMethods type : BulkSetMethods.values()) {
+            switch(type) {
+                case BOOLEAN:
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN, "true");
+                    assertElements(collection, obj -> assertTrue(obj.isFieldBoolean()));
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN, "FALSE");
+                    assertElements(collection, obj -> assertFalse(obj.isFieldBoolean()));
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN, "True");
+                    assertElements(collection, obj -> assertTrue(obj.isFieldBoolean()));
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN, "false");
+                    assertElements(collection, obj -> assertFalse(obj.isFieldBoolean()));
+                    collection.setValue(AllJavaTypes.FIELD_BOOLEAN, "TRUE");
+                    assertElements(collection, obj -> assertTrue(obj.isFieldBoolean()));
+                    break;
+                case BYTE:
+                    collection.setValue(AllJavaTypes.FIELD_BYTE, "1");
+                    assertElements(collection, obj -> assertEquals((byte)1, obj.getFieldByte()));
+                    break;
+                case SHORT:
+                    collection.setValue(AllJavaTypes.FIELD_SHORT, "2");
+                    assertElements(collection, obj -> assertEquals((short)2, obj.getFieldShort()));
+                    break;
+                case INTEGER:
+                    collection.setValue(AllJavaTypes.FIELD_INT, "3");
+                    assertElements(collection, obj -> assertEquals(3, obj.getFieldInt()));
+                    break;
+                case LONG:
+                    collection.setValue(AllJavaTypes.FIELD_LONG, Long.toString(Long.MAX_VALUE));
+                    assertElements(collection, obj -> assertEquals(Long.MAX_VALUE, obj.getFieldLong()));
+                    break;
+                case FLOAT:
+                    collection.setValue(AllJavaTypes.FIELD_FLOAT, "1.23F");
+                    assertElements(collection, obj -> assertEquals(1.23F, obj.getFieldFloat(), 0F));
+                    break;
+                case DOUBLE:
+                    collection.setValue(AllJavaTypes.FIELD_DOUBLE, "1.234");
+                    assertElements(collection, obj -> assertEquals(1.234, obj.getFieldDouble(), 0F));
+                    break;
+                case DATE:
+                    collection.setValue(AllJavaTypes.FIELD_DATE, "1000");
+                    assertElements(collection, obj -> assertEquals(new Date(1000), obj.getFieldDate()));
+                    collection.setValue(AllJavaTypes.FIELD_DATE, "/Date(2000+0000)/");
+                    assertElements(collection, obj -> assertEquals(new Date(2000), obj.getFieldDate()));
+                    break;
+
+                // These types do not offer any implicit conversion
+                case STRING:
+                case BINARY:
+                case OBJECT:
+                case MODEL_LIST:
+                case STRING_VALUE_LIST:
+                case BOOLEAN_VALUE_LIST:
+                case BYTE_VALUE_LIST:
+                case SHORT_VALUE_LIST:
+                case INTEGER_VALUE_LIST:
+                case LONG_VALUE_LIST:
+                case FLOAT_VALUE_LIST:
+                case DOUBLE_VALUE_LIST:
+                case BINARY_VALUE_LIST:
+                case DATE_VALUE_LIST:
+                    continue;
+
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void setValue_specificType() {
+        populateAllJavaTypes(5);
+        RealmResults<AllJavaTypes> collection = realm.where(AllJavaTypes.class).findAll();
+        realm.beginTransaction();
+        for (BulkSetMethods type : BulkSetMethods.values()) {
+            switch(type) {
+                case STRING:
+                    collection.setString(AllJavaTypes.FIELD_STRING, "foo");
+                    assertElements(collection, obj -> assertEquals("foo", obj.getFieldString()));
+                    collection.setString(AllJavaTypes.FIELD_STRING, null);
+                    assertElements(collection, obj -> assertEquals(null, obj.getFieldString()));
+                    break;
+                case BOOLEAN:
+                    collection.setBoolean(AllJavaTypes.FIELD_BOOLEAN, true);
+                    assertElements(collection, obj -> assertTrue(obj.isFieldBoolean()));
+                    break;
+                case BYTE:
+                    collection.setByte(AllJavaTypes.FIELD_BYTE, (byte) 1);
+                    assertElements(collection, obj -> assertEquals((byte)1, obj.getFieldByte()));
+                    break;
+                case SHORT:
+                    collection.setShort(AllJavaTypes.FIELD_SHORT, (short) 2);
+                    assertElements(collection, obj -> assertEquals((short)2, obj.getFieldShort()));
+                    break;
+                case INTEGER:
+                    collection.setInt(AllJavaTypes.FIELD_INT, 3);
+                    assertElements(collection, obj -> assertEquals(3, obj.getFieldInt()));
+                    break;
+                case LONG:
+                    collection.setLong(AllJavaTypes.FIELD_LONG, 4L);
+                    assertElements(collection, obj -> assertEquals(4L, obj.getFieldLong()));
+                    break;
+                case FLOAT:
+                    collection.setFloat(AllJavaTypes.FIELD_FLOAT, 1.23F);
+                    assertElements(collection, obj -> assertEquals(1.23F, obj.getFieldFloat(), 0F));
+                    break;
+                case DOUBLE:
+                    collection.setDouble(AllJavaTypes.FIELD_DOUBLE, 1.234);
+                    assertElements(collection, obj -> assertEquals(1.234, obj.getFieldDouble(), 0F));
+                    break;
+                case BINARY:
+                    collection.setBlob(AllJavaTypes.FIELD_BINARY, new byte[]{1,2,3});
+                    assertElements(collection, obj -> assertArrayEquals(new byte[]{1,2,3}, obj.getFieldBinary()));
+                    collection.setBlob(AllJavaTypes.FIELD_BINARY, null);
+                    assertElements(collection, obj -> assertNull(obj.getFieldBinary()));
+                    break;
+                case DATE:
+                    collection.setDate(AllJavaTypes.FIELD_DATE, new Date(1000));
+                    assertElements(collection, obj -> assertEquals(new Date(1000), obj.getFieldDate()));
+                    collection.setDate(AllJavaTypes.FIELD_DATE, null);
+                    assertElements(collection, obj -> assertEquals(null, obj.getFieldDate()));
+                    break;
+                case OBJECT: {
+                    AllJavaTypes childObj = realm.createObject(AllJavaTypes.class, 42);
+                    collection.setObject(AllJavaTypes.FIELD_OBJECT, childObj);
+                    assertElements(collection, obj -> assertEquals(childObj, obj.getFieldObject()));
+                    collection.setObject(AllJavaTypes.FIELD_OBJECT, null);
+                    assertElements(collection, obj -> assertNull(obj.getFieldObject()));
+                    break;
+                }
+                case MODEL_LIST: {
+                    AllJavaTypes childObj = realm.createObject(AllJavaTypes.class, 43);
+                    collection.setList(AllJavaTypes.FIELD_LIST, new RealmList<>(childObj));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.getFieldList().size());
+                        assertEquals(childObj, obj.getFieldList().first());
+                    });
+                    break;
+                }
+                case STRING_VALUE_LIST: {
+                    RealmList<String> list = new RealmList<>("Foo", "Bar");
+                    collection.setList(AllJavaTypes.FIELD_STRING_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals("Foo", obj.getFieldStringList().first());
+                        assertEquals("Bar", obj.getFieldStringList().last());
+                    });
+                    break;
+                }
+                case BOOLEAN_VALUE_LIST: {
+                    RealmList<Boolean> list = new RealmList<>(true, false);
+                    collection.setList(AllJavaTypes.FIELD_BOOLEAN_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertTrue(obj.getFieldBooleanList().first());
+                        assertFalse(obj.getFieldBooleanList().last());
+                    });
+                    break;
+                }
+                case BYTE_VALUE_LIST: {
+                    RealmList<Byte> list = new RealmList<>((byte) 1, (byte) 2);
+                    collection.setList(AllJavaTypes.FIELD_BYTE_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Byte.valueOf((byte) 1), obj.getFieldByteList().first());
+                        assertEquals(Byte.valueOf((byte) 2), obj.getFieldByteList().last());
+                    });
+                    break;
+                }
+                case SHORT_VALUE_LIST: {
+                    RealmList<Short> list = new RealmList<>((short) 1, (short) 2);
+                    collection.setList(AllJavaTypes.FIELD_SHORT_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Short.valueOf((short) 1), obj.getFieldShortList().first());
+                        assertEquals(Short.valueOf((short) 2), obj.getFieldShortList().last());
+                    });
+                    break;
+                }
+                case INTEGER_VALUE_LIST: {
+                    RealmList<Integer> list = new RealmList<>(1, 2);
+                    collection.setList(AllJavaTypes.FIELD_INTEGER_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Integer.valueOf(1), obj.getFieldIntegerList().first());
+                        assertEquals(Integer.valueOf(2), obj.getFieldIntegerList().last());
+                    });
+                    break;
+                }
+                case LONG_VALUE_LIST: {
+                    RealmList<Long> list = new RealmList<>(1L, 2L);
+                    collection.setList(AllJavaTypes.FIELD_LONG_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(Long.valueOf(1), obj.getFieldLongList().first());
+                        assertEquals(Long.valueOf(2), obj.getFieldLongList().last());
+                    });
+                    break;
+                }
+                case FLOAT_VALUE_LIST: {
+                    RealmList<Float> list = new RealmList<>(1.1F, 2.2F);
+                    collection.setList(AllJavaTypes.FIELD_FLOAT_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(1.1F, obj.getFieldFloatList().first(), 0F);
+                        assertEquals(2.2F, obj.getFieldFloatList().last(), 0F);
+                    });
+                    break;
+                }
+                case DOUBLE_VALUE_LIST: {
+                    RealmList<Double> list = new RealmList<>(1.1D, 2.2D);
+                    collection.setList(AllJavaTypes.FIELD_DOUBLE_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(1.1D, obj.getFieldDoubleList().first(), 0D);
+                        assertEquals(2.2D, obj.getFieldDoubleList().last(), 0D);
+                    });
+                    break;
+                }
+                case BINARY_VALUE_LIST: {
+                    RealmList<byte[]> list = new RealmList<>(new byte[] {1,2,3}, new byte[] {2,3,4});
+                    collection.setList(AllJavaTypes.FIELD_BINARY_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertArrayEquals(new byte[] {1,2,3}, obj.getFieldBinaryList().first());
+                        assertArrayEquals(new byte[] {2,3,4}, obj.getFieldBinaryList().last());
+                    });
+                    break;
+                }
+                case DATE_VALUE_LIST:  {
+                    RealmList<Date> list = new RealmList<>(new Date(1000), new Date(2000));
+                    collection.setList(AllJavaTypes.FIELD_DATE_LIST, list);
+                    assertElements(collection, obj -> {
+                        assertEquals(new Date(1000), obj.getFieldDateList().first());
+                        assertEquals(new Date(2000), obj.getFieldDateList().last());
+                    });
+                    break;
+                }
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void setObject_unmanagedObjectThrows() {
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        try {
+            collection.setObject(AllTypes.FIELD_REALMOBJECT, new Dog());
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().contains("is not a valid, managed Realm object."));
+        }
+    }
+
+    @Test
+    public void setObject_wrongObjectTypeThrows() {
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        try {
+            collection.setObject(AllTypes.FIELD_REALMOBJECT, realm.createObject(AllTypes.class));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().equals("Type of object is wrong. Was 'AllTypes', expected 'Dog'"));
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        RealmResults<DynamicRealmObject> dynamicCollection = dynamicRealm.where("AllTypes").findAll();
+        dynamicRealm.beginTransaction();
+        try {
+            dynamicCollection.setObject(AllTypes.FIELD_REALMOBJECT, dynamicRealm.createObject("AllTypes"));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().equals("Type of object is wrong. Was 'AllTypes', expected 'Dog'"));
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void setList_unmanagedObjectThrows() {
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        try {
+            collection.setList(AllTypes.FIELD_REALMLIST, new RealmList<>(new Dog()));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().contains("is not a valid, managed Realm object."));
+        }
+    }
+
+    @Test
+    public void setList_wrongObjectTypeThrows() {
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        try {
+            collection.setList(AllTypes.FIELD_REALMLIST, new RealmList<>(realm.createObject(AllTypes.class)));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().equals("Type of object is wrong. Was 'AllTypes', expected 'Dog'"));
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        RealmResults<DynamicRealmObject> dynamicCollection = dynamicRealm.where("AllTypes").findAll();
+        dynamicRealm.beginTransaction();
+        try {
+            dynamicCollection.setList(AllTypes.FIELD_REALMLIST, new RealmList<>(dynamicRealm.createObject("AllTypes")));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue("Wrong error message: " + e.getMessage(), e.getMessage().equals("Type of object is wrong. Was 'AllTypes', expected 'Dog'"));
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void setValue_specificType_wrongFieldNameThrows() {
+        populateAllJavaTypes(5);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        for (BulkSetMethods type : BulkSetMethods.values()) {
+            try {
+                switch(type) {
+                    case STRING: collection.setString("foo", "bar"); break;
+                    case BOOLEAN: collection.setBoolean("foo", true); break;
+                    case BYTE: collection.setByte("foo", (byte) 1); break;
+                    case SHORT: collection.setShort("foo", (short) 2); break;
+                    case INTEGER: collection.setInt("foo", 3); break;
+                    case LONG: collection.setLong("foo", 4L); break;
+                    case FLOAT: collection.setFloat("foo", 1.23F); break;
+                    case DOUBLE: collection.setDouble("foo", 1.234); break;
+                    case BINARY: collection.setBlob("foo", new byte[]{1,2,3}); break;
+                    case DATE: collection.setDate("foo", new Date(1000)); break;
+                    case OBJECT: collection.setObject("foo", realm.createObject(AllTypes.class)); break;
+                    case MODEL_LIST: collection.setList("foo", new RealmList<>()); break;
+                    case STRING_VALUE_LIST: collection.setList("foo", new RealmList<>("Foo")); break;
+                    case BOOLEAN_VALUE_LIST: collection.setList("foo", new RealmList<>(true)); break;
+                    case BYTE_VALUE_LIST: collection.setList("foo", new RealmList<>((byte) 1)); break;
+                    case SHORT_VALUE_LIST: collection.setList("foo", new RealmList<>((short) 1)); break;
+                    case INTEGER_VALUE_LIST: collection.setList("foo", new RealmList<>(1)); break;
+                    case LONG_VALUE_LIST: collection.setList("foo", new RealmList<>(1L)); break;
+                    case FLOAT_VALUE_LIST: collection.setList("foo", new RealmList<>(1.1F)); break;
+                    case DOUBLE_VALUE_LIST: collection.setList("foo", new RealmList<>(1.1D)); break;
+                    case BINARY_VALUE_LIST: collection.setList("foo", new RealmList<>(new byte[] {})); break;
+                    case DATE_VALUE_LIST: collection.setList("foo", new RealmList<>(new Date())); break;
+                    default:
+                        fail("Unknown type: " + type);
+                }
+                fail(type + " should have thrown an exception");
+            } catch (IllegalArgumentException e) {
+                assertTrue(e.getMessage().contains("does not exist"));
+            }
+        }
+    }
+
+    @Test
+    public void setValue_specificType_wrongTypeThrows() {
+        populateAllJavaTypes(5);
+        RealmResults<AllJavaTypes> collection = realm.where(AllJavaTypes.class).findAll();
+        realm.beginTransaction();
+        for (BulkSetMethods type : BulkSetMethods.values()) {
+            try {
+                switch(type) {
+                    case STRING: collection.setString(AllJavaTypes.FIELD_BOOLEAN, "foo"); break;
+                    case BOOLEAN: collection.setBoolean(AllJavaTypes.FIELD_STRING, true); break;
+                    case BYTE: collection.setByte(AllJavaTypes.FIELD_STRING, (byte) 1); break;
+                    case SHORT: collection.setShort(AllJavaTypes.FIELD_STRING, (short) 2); break;
+                    case INTEGER: collection.setInt(AllJavaTypes.FIELD_STRING, 3); break;
+                    case LONG:collection.setLong(AllJavaTypes.FIELD_STRING, 4L); break;
+                    case FLOAT: collection.setFloat(AllJavaTypes.FIELD_STRING, 1.23F); break;
+                    case DOUBLE: collection.setDouble(AllJavaTypes.FIELD_STRING, 1.234); break;
+                    case BINARY: collection.setBlob(AllJavaTypes.FIELD_STRING, new byte[]{1,2,3}); break;
+                    case DATE: collection.setDate(AllJavaTypes.FIELD_STRING, new Date(1000)); break;
+                    case OBJECT: collection.setObject(AllJavaTypes.FIELD_STRING, realm.createObject(AllJavaTypes.class, 42)); break;
+                    case MODEL_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(realm.createObject(AllJavaTypes.class, 43))); break;
+                    case STRING_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>("Foo")); break;
+                    case BOOLEAN_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(true)); break;
+                    case BYTE_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>((byte)1)); break;
+                    case SHORT_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>((short)1)); break;
+                    case INTEGER_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(1)); break;
+                    case LONG_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(1L)); break;
+                    case FLOAT_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(1.1F)); break;
+                    case DOUBLE_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(2.2D)); break;
+                    case BINARY_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(new byte[]{})); break;
+                    case DATE_VALUE_LIST: collection.setList(AllJavaTypes.FIELD_STRING, new RealmList<>(new Date())); break;
+                    default:
+                        fail("Unknown type: " + type);
+                }
+                fail(type + " should have thrown an exception");
+            } catch (IllegalArgumentException e) {
+                RealmLog.error(type + " -> " + e.getMessage());
+                assertTrue(type + " failed", e.getMessage().contains("is not of the expected type")
+                        || e.getMessage().contains("List contained the wrong type of elements")
+                        || e.getMessage().contains("is not a list"));
+            }
+        }
+    }
+
+    @Test
+    public void setValue_specificType_primaryKeyFieldThrows() {
+        populateAllJavaTypes(5);
+        realm.beginTransaction();
+        try {
+            RealmResults<PrimaryKeyAsString> collection = realm.where(PrimaryKeyAsString.class).findAll();
+            collection.setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "foo");
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+
+        try {
+            RealmResults<PrimaryKeyAsLong> collection = realm.where(PrimaryKeyAsLong.class).findAll();
+            collection.setLong(PrimaryKeyAsLong.FIELD_ID, 42);
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
+    @Test
+    public void setValue_specificType_modelClassNameOnTypedRealms() {
+        populateMappedAllJavaTypes(5);
+        RealmResults<MappedAllJavaTypes> collection = realm.where(MappedAllJavaTypes.class).findAll();
+        realm.beginTransaction();
+        for (BulkSetMethods type : BulkSetMethods.values()) {
+            switch(type) {
+                case STRING:
+                    collection.setString("fieldString", "foo");
+                    assertElements(collection, obj -> assertEquals("foo", obj.fieldString));
+                    break;
+                case BOOLEAN:
+                    collection.setBoolean("fieldBoolean", true);
+                    assertElements(collection, obj -> assertTrue(obj.fieldBoolean));
+                    break;
+                case BYTE:
+                    collection.setByte("fieldByte", (byte) 1);
+                    assertElements(collection, obj -> assertEquals((byte) 1, obj.fieldByte));
+                    break;
+                case SHORT:
+                    collection.setShort("fieldShort", (short) 2);
+                    assertElements(collection, obj -> assertEquals((short) 2, obj.fieldShort));
+                    break;
+                case INTEGER:
+                    collection.setInt("fieldInt", 3);
+                    assertElements(collection, obj -> assertEquals(3, obj.fieldInt));
+                    break;
+                case LONG:
+                    collection.setLong("fieldLong", 4L);
+                    assertElements(collection, obj -> assertEquals(4L, obj.fieldLong));
+                    break;
+                case FLOAT:
+                    collection.setFloat("fieldFloat", 1.23F);
+                    assertElements(collection, obj -> assertEquals(1.23F, obj.fieldFloat, 0F));
+                    break;
+                case DOUBLE:
+                    collection.setDouble("fieldDouble", 1.234);
+                    assertElements(collection, obj -> assertEquals(1.234, obj.fieldDouble, 0F));
+                    break;
+                case BINARY:
+                    collection.setBlob("fieldBinary", new byte[]{1,2,3});
+                    assertElements(collection, obj -> assertArrayEquals(new byte[]{1,2,3}, obj.fieldBinary));
+                    break;
+                case DATE:
+                    collection.setDate("fieldDate", new Date(1000));
+                    assertElements(collection, obj -> assertEquals(new Date(1000), obj.fieldDate));
+                    break;
+                case OBJECT: {
+                    MappedAllJavaTypes childObj = realm.createObject(MappedAllJavaTypes.class, 42);
+                    collection.setObject("fieldObject", childObj);
+                    assertElements(collection, obj -> assertEquals(childObj, obj.fieldObject));
+                    break;
+                }
+                case MODEL_LIST: {
+                    MappedAllJavaTypes childObj = realm.createObject(MappedAllJavaTypes.class, 43);
+                    collection.setList("fieldList", new RealmList<>(childObj));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldList.size());
+                        assertEquals(childObj, obj.fieldList.first());
+                    });
+                    break;
+                }
+                case STRING_VALUE_LIST:
+                    collection.setList("fieldStringList", new RealmList<>("Foo"));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldStringList.size());
+                        assertEquals("Foo", obj.fieldStringList.first());
+                    });
+                    break;
+                case BOOLEAN_VALUE_LIST:
+                    collection.setList("fieldBooleanList", new RealmList<>(true));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldBooleanList.size());
+                        assertEquals(true, obj.fieldBooleanList.first());
+                    });
+                    break;
+                case BYTE_VALUE_LIST:
+                    collection.setList("fieldByteList", new RealmList<>((byte)1));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldByteList.size());
+                        assertEquals(Byte.valueOf((byte) 1), obj.fieldByteList.first());
+                    });
+                    break;
+                case SHORT_VALUE_LIST:
+                    collection.setList("fieldShortList", new RealmList<>((short)1));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldShortList.size());
+                        assertEquals(Short.valueOf((short) 1), obj.fieldShortList.first());
+                    });
+                    break;
+                case INTEGER_VALUE_LIST:
+                    collection.setList("fieldIntegerList", new RealmList<>(1));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldIntegerList.size());
+                        assertEquals(Integer.valueOf(1), obj.fieldIntegerList.first());
+                    });
+                    break;
+                case LONG_VALUE_LIST:
+                    collection.setList("fieldLongList", new RealmList<>(1L));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldLongList.size());
+                        assertEquals(Long.valueOf((byte) 1), obj.fieldLongList.first());
+                    });
+                    break;
+                case FLOAT_VALUE_LIST:
+                    collection.setList("fieldFloatList", new RealmList<>(1.1F));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldFloatList.size());
+                        assertEquals(1.1F, obj.fieldFloatList.first(), 0F);
+                    });
+                    break;
+                case DOUBLE_VALUE_LIST:
+                    collection.setList("fieldDoubleList", new RealmList<>(1.1D));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldDoubleList.size());
+                        assertEquals(1.1D, obj.fieldDoubleList.first(), 0F);
+                    });
+                    break;
+                case BINARY_VALUE_LIST:
+                    collection.setList("fieldBinaryList", new RealmList<>(new byte[] {1,2,3}));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldBinaryList.size());
+                        assertArrayEquals(new byte[] {1,2,3}, obj.fieldBinaryList.first());
+                    });
+                    break;
+                case DATE_VALUE_LIST:
+                    collection.setList("fieldDateList", new RealmList<>(new Date(1000)));
+                    assertElements(collection, obj -> {
+                        assertEquals(1, obj.fieldDateList.size());
+                        assertEquals(new Date(1000), obj.fieldDateList.first());
+                    });
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void setValue_specificType_internalNameOnDynamicRealms() {
+        populateMappedAllJavaTypes(5);
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        dynamicRealm.beginTransaction();
+        try {
+            RealmResults<DynamicRealmObject> collection = dynamicRealm.where("MappedAllJavaTypes").findAll();
+            for (BulkSetMethods type : BulkSetMethods.values()) {
+                switch(type) {
+                    case STRING:
+                        collection.setString("field_string", "foo");
+                        assertElements(collection, obj -> assertEquals("foo", obj.getString("field_string")));
+                        break;
+                    case BOOLEAN:
+                        collection.setBoolean("field_boolean", true);
+                        assertElements(collection, obj -> assertTrue(obj.getBoolean("field_boolean")));
+                        break;
+                    case BYTE:
+                        collection.setByte("field_byte", (byte) 1);
+                        assertElements(collection, obj -> assertEquals((byte) 1, obj.getByte("field_byte")));
+                        break;
+                    case SHORT:
+                        collection.setShort("field_short", (short) 2);
+                        assertElements(collection, obj -> assertEquals((short) 2, obj.getShort("field_short")));
+                        break;
+                    case INTEGER:
+                        collection.setInt("field_int", 3);
+                        assertElements(collection, obj -> assertEquals(3, obj.getInt("field_int")));
+                        break;
+                    case LONG:
+                        collection.setLong("field_long", 4L);
+                        assertElements(collection, obj -> assertEquals(4L, obj.getLong("field_long")));
+                        break;
+                    case FLOAT:
+                        collection.setFloat("field_float", 1.23F);
+                        assertElements(collection, obj -> assertEquals(1.23F, obj.getFloat("field_float"), 0F));
+                        break;
+                    case DOUBLE:
+                        collection.setDouble("field_double", 1.234);
+                        assertElements(collection, obj -> assertEquals(1.234, obj.getDouble("field_double"), 0F));
+                        break;
+                    case BINARY:
+                        collection.setBlob("field_binary", new byte[]{1,2,3});
+                        assertElements(collection, obj -> assertArrayEquals(new byte[]{1,2,3}, obj.getBlob("field_binary")));
+                        break;
+                    case DATE:
+                        collection.setDate("field_date", new Date(1000));
+                        assertElements(collection, obj -> assertEquals(new Date(1000), obj.getDate("field_date")));
+                        break;
+                    case OBJECT: {
+                        DynamicRealmObject childObj = dynamicRealm.createObject("MappedAllJavaTypes", 42);
+                        collection.setObject("field_object", childObj);
+                        assertElements(collection, obj -> assertEquals(childObj, obj.getObject("field_object")));
+                        break;
+                    }
+                    case MODEL_LIST: {
+                        DynamicRealmObject childObj = dynamicRealm.createObject("MappedAllJavaTypes", 43);
+                        collection.setList("field_list", new RealmList<>(childObj));
+                        assertElements(collection, obj -> {
+                            RealmList<DynamicRealmObject> list = obj.getList("field_list");
+                            assertEquals(1, list.size());
+                            assertEquals(childObj, list.first());
+                        });
+                        break;
+                    }
+                    case STRING_VALUE_LIST:
+                        collection.setList("field_string_list", new RealmList<>("Foo"));
+                        assertElements(collection, obj -> {
+                            RealmList<String> list = obj.getList("field_string_list", String.class);
+                            assertEquals(1, list.size());
+                            assertEquals("Foo", list.first());
+                        });
+                        break;
+                    case BOOLEAN_VALUE_LIST:
+                        collection.setList("field_boolean_list", new RealmList<>(true));
+                        assertElements(collection, obj -> {
+                            RealmList<Boolean> list = obj.getList("field_boolean_list", Boolean.class);
+                            assertEquals(1, list.size());
+                            assertEquals(true, list.first());
+                        });
+                        break;
+                    case BYTE_VALUE_LIST:
+                        collection.setList("field_byte_list", new RealmList<>((byte)1));
+                        assertElements(collection, obj -> {
+                            RealmList<Byte> list = obj.getList("field_byte_list", Byte.class);
+                            assertEquals(1, list.size());
+                            assertEquals(Byte.valueOf((byte) 1), list.first());
+                        });
+                        break;
+                    case SHORT_VALUE_LIST:
+                        collection.setList("field_short_list", new RealmList<>((short)1));
+                        assertElements(collection, obj -> {
+                            RealmList<Short> list = obj.getList("field_short_list", Short.class);
+                            assertEquals(1, list.size());
+                            assertEquals(Short.valueOf((short) 1), list.first());
+                        });
+                        break;
+                    case INTEGER_VALUE_LIST:
+                        collection.setList("field_integer_list", new RealmList<>(1));
+                        assertElements(collection, obj -> {
+                            RealmList<Integer> list = obj.getList("field_integer_list", Integer.class);
+                            assertEquals(1, list.size());
+                            assertEquals(Integer.valueOf(1), list.first());
+                        });
+                        break;
+                    case LONG_VALUE_LIST:
+                        collection.setList("field_long_list", new RealmList<>(1L));
+                        assertElements(collection, obj -> {
+                            RealmList<Long> list = obj.getList("field_long_list", Long.class);
+                            assertEquals(1, list.size());
+                            assertEquals(Long.valueOf((byte) 1), list.first());
+                        });
+                        break;
+                    case FLOAT_VALUE_LIST:
+                        collection.setList("field_float_list", new RealmList<>(1.1F));
+                        assertElements(collection, obj -> {
+                            RealmList<Float> list = obj.getList("field_float_list", Float.class);
+                            assertEquals(1, list.size());
+                            assertEquals(1.1F, list.first(), 0F);
+                        });
+                        break;
+                    case DOUBLE_VALUE_LIST:
+                        collection.setList("field_double_list", new RealmList<>(1.1D));
+                        assertElements(collection, obj -> {
+                            RealmList<Double> list = obj.getList("field_double_list", Double.class);
+                            assertEquals(1, list.size());
+                            assertEquals(1.1D, list.first(), 0F);
+                        });
+                        break;
+                    case BINARY_VALUE_LIST:
+                        collection.setList("field_binary_list", new RealmList<>(new byte[] {1,2,3}));
+                        assertElements(collection, obj -> {
+                            RealmList<byte[]> list = obj.getList("field_binary_list", byte[].class);
+                            assertEquals(1, list.size());
+                            assertArrayEquals(new byte[] {1,2,3}, list.first());
+                        });
+                        break;
+                    case DATE_VALUE_LIST:
+                        collection.setList("field_date_list", new RealmList<>(new Date(1000)));
+                        assertElements(collection, obj -> {
+                            RealmList<Date> list = obj.getList("field_date_list", Date.class);
+                            assertEquals(1, list.size());
+                            assertEquals(new Date(1000), list.first());
+                        });
+                        break;
+                    default:
+                        fail("Unknown type: " + type);
+                }
+            }
+        } finally {
+            dynamicRealm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/MappedAllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/MappedAllJavaTypes.java
new file mode 100644
index 0000000000..96c9843ad7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/MappedAllJavaTypes.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
+import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmNamingPolicy;
+
+
+@RealmClass(fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
+public class MappedAllJavaTypes extends RealmObject {
+
+    public static final String CLASS_NAME = "MappedAllJavaTypes";
+
+    @Ignore
+    public String fieldIgnored;
+    @Index
+    public String fieldString;
+    @PrimaryKey
+    public long fieldId;
+    public long fieldLong;
+    public short fieldShort;
+    public int fieldInt;
+    public byte fieldByte;
+    public float fieldFloat;
+    public double fieldDouble;
+    public boolean fieldBoolean;
+    public Date fieldDate;
+    public byte[] fieldBinary;
+    public MappedAllJavaTypes fieldObject;
+    public RealmList<MappedAllJavaTypes> fieldList;
+
+    public RealmList<String> fieldStringList;
+    public RealmList<byte[]> fieldBinaryList;
+    public RealmList<Boolean> fieldBooleanList;
+    public RealmList<Long> fieldLongList;
+    public RealmList<Integer> fieldIntegerList;
+    public RealmList<Short> fieldShortList;
+    public RealmList<Byte> fieldByteList;
+    public RealmList<Double> fieldDoubleList;
+    public RealmList<Float> fieldFloatList;
+    public RealmList<Date> fieldDateList;
+
+    public MappedAllJavaTypes() {
+    }
+
+    public MappedAllJavaTypes(long fieldLong) {
+        this.fieldId = fieldLong;
+        this.fieldLong = fieldLong;
+    }
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
index 47254d1d60..b8b4f19ec0 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
@@ -22,6 +22,7 @@
 #include <realm/util/optional.hpp>
 
 #include "java_class_global_def.hpp"
+#include "java_object_accessor.hpp"
 #include "java_query_descriptor.hpp"
 #include "observable_collection_wrapper.hpp"
 #include "util.hpp"
@@ -323,6 +324,92 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeDeleteFirst(JN
     return JNI_FALSE;
 }
 
+static inline void update_objects(JNIEnv* env, jlong results_ptr, jstring& j_field_name, JavaValue& value) {
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(results_ptr);
+        JavaContext ctx(env, wrapper->collection().get_realm(), wrapper->collection().get_object_schema());
+        JStringAccessor prop_name(env, j_field_name);
+        wrapper->collection().set_property_value(ctx, prop_name, value);
+    }
+    CATCH_STD()
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetNull(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name)
+{
+    TR_ENTER_PTR(native_ptr)
+    auto value = JavaValue();
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetBoolean(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jboolean j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    JavaValue value(j_value);
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetInt(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jlong j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    JavaValue value(j_value);
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetFloat(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jfloat j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    JavaValue value(j_value);
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetDouble(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jdouble j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    JavaValue value(j_value);
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetString(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jstring j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    JStringAccessor str(env, j_value);
+    JavaValue value = str.is_null() ? JavaValue() : JavaValue(std::string(str));
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetBinary(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jbyteArray j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    auto data = OwnedBinaryData(JByteArrayAccessor(env, j_value).transform<BinaryData>());
+    JavaValue value(data);
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetTimestamp(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jlong j_value)
+{
+    TR_ENTER_PTR(native_ptr)
+    JavaValue value(from_milliseconds(j_value));
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetObject(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jlong row_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    JavaValue value(reinterpret_cast<RowExpr*>(row_ptr));
+    update_objects(env, native_ptr, j_field_name, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeSetList(JNIEnv* env, jclass, jlong native_ptr, jstring j_field_name, jlong builder_ptr)
+{
+    // OsObjectBuilder has been used to build up the list we want to insert. This means the
+    // fake object described by the OsObjectBuilder only contains one property, namely the list we
+    // want to insert and this list is assumed to be at index = 0.
+    std::vector<JavaValue> builder = *reinterpret_cast<std::vector<JavaValue>*>(builder_ptr);
+    REALM_ASSERT_DEBUG(builder.size() == 1);
+    update_objects(env, native_ptr, j_field_name, builder[0]);
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeDelete(JNIEnv* env, jclass, jlong native_ptr,
                                                                       jlong index)
 {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 0698d6571d..3f80013741 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -16,30 +16,40 @@
 
 package io.realm;
 
-
 import android.annotation.SuppressLint;
 import android.os.Looper;
 
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Locale;
+
 import javax.annotation.Nullable;
 
 import io.reactivex.Flowable;
 import io.reactivex.Observable;
 import io.realm.internal.CheckedRow;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsList;
 import io.realm.internal.OsResults;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
+import io.realm.internal.Util;
+import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import io.realm.rx.CollectionChange;
 
+import static io.realm.RealmFieldType.LIST;
+
 /**
  * This class holds all the matches of a {@link RealmQuery} for a given Realm. The objects are not copied from
  * the Realm to the RealmResults list, but are just referenced from the RealmResult instead. This saves memory and
  * increases speed.
  * <p>
  * RealmResults are live views, which means that if it is on an {@link Looper} thread, it will automatically
- * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#waitForChange()}
- * must be called to update the results.
+ * update its query results after a transaction has been committed. If on a non-looper thread,
+ * {@link Realm#refresh()} must be called to update the results.
  * <p>
  * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the modified objects are
  * persisted to the Realm file during the commit of the transaction.
@@ -136,6 +146,403 @@ public boolean load() {
         return true;
     }
 
+
+    /**
+     * Updates the field given by {@code fieldName} in all objects inside the query result.
+     * <p>
+     * This method will automatically try to convert numbers and booleans that are given as
+     * {@code String} to their appropriate type. For example {@code "10"} will be converted to
+     * {@code 10} if the field type is {@link RealmFieldType#INTEGER}.
+     * <p>
+     * Using the typed setters like {@link #setInt(String, int)} will be faster than using
+     * this method.
+     *
+     * @param fieldName field to update
+     * @param value value to update with.
+     * @throws IllegalArgumentException if the field could not be found, could not be updated or
+     * the argument didn't match the field type or could not be converted to match the underlying
+     * field type.
+     */
+    public void setValue(String fieldName, @Nullable Object value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        boolean isString = (value instanceof String);
+        String strValue = isString ? (String) value : null;
+
+        String className = osResults.getTable().getClassName();
+        RealmObjectSchema schema = getRealm().getSchema().get(className);
+        if (!schema.hasField(fieldName)) {
+            throw new IllegalArgumentException(String.format("Field '%s' could not be found in class '%s'", fieldName, className));
+        }
+
+        // null values exit early
+        if (value == null) {
+            osResults.setNull(fieldName);
+            return;
+        }
+
+        // Does implicit conversion if needed.
+        RealmFieldType type = schema.getFieldType(fieldName);
+        if (isString && type != RealmFieldType.STRING) {
+            switch (type) {
+                case BOOLEAN:
+                    value = Boolean.parseBoolean(strValue);
+                    break;
+                case INTEGER:
+                    value = Long.parseLong(strValue);
+                    break;
+                case FLOAT:
+                    value = Float.parseFloat(strValue);
+                    break;
+                case DOUBLE:
+                    value = Double.parseDouble(strValue);
+                    break;
+                case DATE:
+                    value = JsonUtils.stringToDate(strValue);
+                    break;
+                default:
+                    throw new IllegalArgumentException(String.format(Locale.US,
+                            "Field %s is not a String field, " +
+                                    "and the provide value could not be automatically converted: %s. Use a typed" +
+                                    "setter instead", fieldName, value));
+            }
+        }
+
+        //noinspection ConstantConditions
+        Class<?> valueClass = value.getClass();
+        if (valueClass == Boolean.class) {
+            setBoolean(fieldName, (Boolean) value);
+        } else if (valueClass == Short.class) {
+            setShort(fieldName, (Short) value);
+        } else if (valueClass == Integer.class) {
+            setInt(fieldName, (Integer) value);
+        } else if (valueClass == Long.class) {
+            setLong(fieldName, (Long) value);
+        } else if (valueClass == Byte.class) {
+            setByte(fieldName, (Byte) value);
+        } else if (valueClass == Float.class) {
+            setFloat(fieldName, (Float) value);
+        } else if (valueClass == Double.class) {
+            setDouble(fieldName, (Double) value);
+        } else if (valueClass == String.class) {
+            //noinspection ConstantConditions
+            setString(fieldName, (String) value);
+        } else if (value instanceof Date) {
+            setDate(fieldName, (Date) value);
+        } else if (value instanceof byte[]) {
+            setBlob(fieldName, (byte[]) value);
+        } else if (value instanceof RealmModel) {
+            setObject(fieldName, (RealmModel) value);
+        } else if (valueClass == RealmList.class) {
+            RealmList<?> list = (RealmList<?>) value;
+            setList(fieldName, list);
+        } else {
+            throw new IllegalArgumentException("Value is of a type not supported: " + value.getClass());
+        }
+    }
+
+    /**
+     * Sets the value to {@code null} for the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @throws IllegalArgumentException if field name doesn't exist or is a primary key property.
+     * @throws IllegalStateException if the field cannot hold {@code null} values.
+     */
+    public void setNull(String fieldName) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        osResults.setNull(fieldName);
+    }
+
+    /**
+     * Sets the {@code boolean} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a boolean field.
+     */
+    public void setBoolean(String fieldName, boolean value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.BOOLEAN);
+        osResults.setBoolean(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code byte} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a byte field.
+     */
+    public void setByte(String fieldName, byte value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.INTEGER);
+        osResults.setInt(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code short} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a short field.
+     */
+    public void setShort(String fieldName, short value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.INTEGER);
+        osResults.setInt(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code int} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't an integer field.
+     */
+    public void setInt(String fieldName, int value) {
+        checkNonEmptyFieldName(fieldName);
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.INTEGER);
+        realm.checkIfValidAndInTransaction();
+        osResults.setInt(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code long} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a long field.
+     */
+    public void setLong(String fieldName, long value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.INTEGER);
+        osResults.setInt(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code float} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a float field.
+     */
+    public void setFloat(String fieldName, float value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.FLOAT);
+        osResults.setFloat(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code double} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a double field.
+     */
+    public void setDouble(String fieldName, double value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.DOUBLE);
+        osResults.setDouble(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code String} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a String field.
+     */
+    public void setString(String fieldName, @Nullable String value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.STRING);
+        osResults.setString(fieldName, value);
+    }
+
+    /**
+     * Sets the binary value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a binary field.
+     */
+    public void setBlob(String fieldName, @Nullable byte[] value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.BINARY);
+        osResults.setBlob(fieldName, value);
+    }
+
+    /**
+     * Sets the {@code Date} value of the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't a date field.
+     */
+    public void setDate(String fieldName, @Nullable Date value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.DATE);
+        osResults.setDate(fieldName, value);
+    }
+
+    /**
+     * Sets a reference to another object on the given field in all of the objects in the collection.
+     *
+     * @param fieldName name of the field to update.
+     * @param value new object referenced by this field.
+     * @throws IllegalArgumentException if field name doesn't exist, is a primary key property or isn't an Object reference field.
+     */
+    public void setObject(String fieldName, @Nullable RealmModel value) {
+        checkNonEmptyFieldName(fieldName);
+        realm.checkIfValidAndInTransaction();
+        fieldName = mapFieldNameToInternalName(fieldName);
+        checkType(fieldName, RealmFieldType.OBJECT);
+        Row row = checkRealmObjectConstraints(fieldName, value);
+        osResults.setObject(fieldName, row);
+    }
+
+    private Row checkRealmObjectConstraints(String fieldName, @Nullable RealmModel value) {
+        if (value != null) {
+            if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
+                throw new IllegalArgumentException("'value' is not a valid, managed Realm object.");
+            }
+            ProxyState proxyState = ((RealmObjectProxy) value).realmGet$proxyState();
+            if (!proxyState.getRealm$realm().getPath().equals(realm.getPath())) {
+                throw new IllegalArgumentException("'value' does not belong to the same Realm as the RealmResults.");
+            }
+
+            // Check that type matches the expected one
+            Table currentTable = osResults.getTable();
+            long columnIndex = currentTable.getColumnIndex(fieldName);
+            Table expectedTable = currentTable.getLinkTarget(columnIndex);
+            Table inputTable = proxyState.getRow$realm().getTable();
+            if (!expectedTable.hasSameSchema(inputTable)) {
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "Type of object is wrong. Was '%s', expected '%s'",
+                        inputTable.getClassName(), expectedTable.getClassName()));
+            }
+            return proxyState.getRow$realm();
+        }
+
+        return null;
+    }
+
+    /**
+     * Replaces the RealmList at the given field on all objects in this collection.
+     *
+     *
+     * @param fieldName name of the field to update.
+     * @param list new value for the field.
+     * @throws IllegalArgumentException if field name doesn't exist, isn't a RealmList field , if the
+     * objects in the list are not managed or the type of the objects in the list are wrong.
+     */
+    @SuppressWarnings("unchecked")
+    public <T> void setList(String fieldName, RealmList<T> list) {
+        checkNonEmptyFieldName(fieldName);
+        fieldName = mapFieldNameToInternalName(fieldName);
+        realm.checkIfValidAndInTransaction();
+
+        //noinspection ConstantConditions
+        if (list == null) {
+            throw new IllegalArgumentException("Non-null 'list' required");
+        }
+
+        // Due to type erasure of generics it is not possible to have multiple overloaded methods with the same signature.
+        // So instead we fake  it by checking the first element in the list and verifies that
+        // against the underlying type.
+        RealmFieldType columnType = realm.getSchema().getSchemaForClass(osResults.getTable().getClassName()).getFieldType(fieldName);
+        switch (columnType) {
+            case LIST:
+                checkTypeOfListElements(list, RealmModel.class);
+                checkRealmObjectConstraints(fieldName, (RealmModel) list.first(null));
+                osResults.setModelList(fieldName, (RealmList<? extends RealmModel>) list);
+                break;
+            case INTEGER_LIST:
+                // Integers are a bit annoying as they are all stored as the same type in Core
+                // but the Java type system cannot seamlessly translate between e.g Short and Long.
+                Class<?> listType = getListType(list);
+                if (listType.equals(Integer.class)) {
+                    osResults.setIntegerList(fieldName, (RealmList<Integer>) list);
+                } else if (listType.equals(Long.class)) {
+                    osResults.setLongList(fieldName, (RealmList<Long>) list);
+                } else if (listType.equals(Short.class)) {
+                    osResults.setShortList(fieldName, (RealmList<Short>) list);
+                } else if (listType.equals(Byte.class)) {
+                    osResults.setByteList(fieldName, (RealmList<Byte>) list);
+                } else {
+                    throw new IllegalArgumentException(String.format("List contained the wrong type of elements. " +
+                            "Elements that can be mapped to Integers was expected, but the actual type is '%s'",
+                            listType));
+                }
+                break;
+            case BOOLEAN_LIST:
+                checkTypeOfListElements(list, Boolean.class);
+                osResults.setBooleanList(fieldName, (RealmList<Boolean>) list);
+                break;
+            case STRING_LIST:
+                checkTypeOfListElements(list, String.class);
+                osResults.setStringList(fieldName, (RealmList<String>) list);
+                break;
+            case BINARY_LIST:
+                checkTypeOfListElements(list, byte[].class);
+                osResults.setByteArrayList(fieldName, (RealmList<byte[]>) list);
+                break;
+            case DATE_LIST:
+                checkTypeOfListElements(list, Date.class);
+                osResults.setDateList(fieldName, (RealmList<Date>) list);
+                break;
+            case FLOAT_LIST:
+                checkTypeOfListElements(list, Float.class);
+                osResults.setFloatList(fieldName, (RealmList<Float>) list);
+                break;
+            case DOUBLE_LIST:
+                checkTypeOfListElements(list, Double.class);
+                osResults.setDoubleList(fieldName, (RealmList<Double>) list);
+                break;
+            default:
+                throw new IllegalArgumentException(String.format("Field '%s' is not a list but a %s", fieldName, columnType));
+        }
+    }
+
+    private Class<?> getListType(RealmList list) {
+        if (!list.isEmpty()) {
+            return list.first().getClass();
+        } else {
+            return Long.class; // Any valid type that maps to INTEGER will do.
+        }
+    }
+
+    private <T> void checkTypeOfListElements(RealmList<T> list, Class<?> clazz) {
+        if (!list.isEmpty()) {
+            T element = list.first();
+            Class<?> elementType = element.getClass();
+            if (!(clazz.isAssignableFrom(elementType))) {
+                throw new IllegalArgumentException(String.format("List contained the wrong type of elements. Elements of type '%s' was " +
+                        "expected, but the actual type is '%s'", clazz, elementType));
+            }
+        }
+    }
+
     /**
      * Adds a change listener to this {@link RealmResults}.
      * <p>
@@ -290,7 +697,8 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
      * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
      * instead.
      *
-     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete}
+     * or {@code OnError}.
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
@@ -299,7 +707,9 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
     public Flowable<RealmResults<E>> asFlowable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
-        } else if (realm instanceof DynamicRealm) {
+        }
+
+        if (realm instanceof DynamicRealm) {
             DynamicRealm dynamicRealm = (DynamicRealm) realm;
             RealmResults<DynamicRealmObject> dynamicResults = (RealmResults<DynamicRealmObject>) this;
             @SuppressWarnings("UnnecessaryLocalVariable")
@@ -338,4 +748,39 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
             throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
         }
     }
+
+    private void checkNonEmptyFieldName(String fieldName) {
+        if (Util.isEmptyString(fieldName)) {
+            throw new IllegalArgumentException("Non-empty 'fieldname' required.");
+        }
+    }
+
+    private void checkNotNull(@Nullable Object value) {
+        if (value == null) {
+            throw new IllegalArgumentException("Non-null 'value' required. Use 'setNull(fieldName)' instead.");
+        }
+    }
+
+    private void checkType(String fieldName, RealmFieldType expectedFieldType) {
+        String className = osResults.getTable().getClassName();
+        RealmFieldType fieldType = realm.getSchema().get(className).getFieldType(fieldName);
+        if (fieldType != expectedFieldType) {
+            throw new IllegalArgumentException(String.format("The field '%s.%s' is not of the expected type. " +
+                    "Actual: %s, Expected: %s", className, fieldName, fieldType, expectedFieldType));
+        }
+    }
+
+    private String mapFieldNameToInternalName(String fieldName) {
+        if (realm instanceof Realm) {
+            // We only need to map field names from typed Realms.
+            String className = osResults.getTable().getClassName();
+            String mappedFieldName = realm.getSchema().getColumnInfo(className).getInternalFieldName(fieldName);
+            if (mappedFieldName == null) {
+                throw new IllegalArgumentException(String.format("Field '%s' does not exists.", fieldName));
+            } else {
+                fieldName = mappedFieldName;
+            }
+        }
+        return fieldName;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index 3c88cd5f3b..f682e14c1e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -92,6 +92,7 @@ public String toString() {
 
     private final Map<String, ColumnDetails> indicesFromJavaFieldNames;
     private final Map<String, ColumnDetails> indicesFromColumnNames;
+    private final Map<String, String> javaFieldNameToInternalNames;
     private final boolean mutable;
 
     /**
@@ -120,6 +121,7 @@ protected ColumnInfo(@Nullable ColumnInfo src, boolean mutable) {
     private ColumnInfo(int mapSize, boolean mutable) {
         this.indicesFromJavaFieldNames = new HashMap<>(mapSize);
         this.indicesFromColumnNames = new HashMap<>(mapSize);
+        this.javaFieldNameToInternalNames = new HashMap<>(mapSize);
         this.mutable = mutable;
     }
 
@@ -152,6 +154,16 @@ public ColumnDetails getColumnDetails(String javaFieldName) {
         return indicesFromJavaFieldNames.get(javaFieldName);
     }
 
+    /**
+     * Returns the internal field name that corresponds to the name found in the Java model class.
+     * @param javaFieldName the field name in the Java model class.
+     * @return the internal field name or {@code null} if the java name doesn't exists.
+     */
+    @Nullable
+    public String getInternalFieldName(String javaFieldName) {
+        return javaFieldNameToInternalNames.get(javaFieldName);
+    }
+
     /**
      * Makes this ColumnInfo an exact copy of {@code src}.
      *
@@ -171,6 +183,8 @@ public void copyFrom(ColumnInfo src) {
         indicesFromJavaFieldNames.putAll(src.indicesFromJavaFieldNames);
         indicesFromColumnNames.clear();
         indicesFromColumnNames.putAll(src.indicesFromColumnNames);
+        javaFieldNameToInternalNames.clear();
+        javaFieldNameToInternalNames.putAll(src.javaFieldNameToInternalNames);
         copy(src, this);
     }
 
@@ -238,6 +252,7 @@ protected final long addColumnDetails(String javaFieldName, String internalColum
         ColumnDetails cd = new ColumnDetails(property);
         indicesFromJavaFieldNames.put(javaFieldName, cd);
         indicesFromColumnNames.put(internalColumnName, cd);
+        javaFieldNameToInternalNames.put(javaFieldName, internalColumnName);
         return property.getColumnIndex();
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
index be40d7ac3f..089ffa5e01 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
@@ -30,14 +30,14 @@
     private static final ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
     private static final Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
     // Dummy context which will be used by native objects which's destructors are always thread safe.
-    static final NativeContext dummyContext = new NativeContext();
+    public static final NativeContext dummyContext = new NativeContext();
 
     static {
         finalizingThread.setName("RealmFinalizingDaemon");
         finalizingThread.start();
     }
 
-    void addReference(NativeObject referent) {
+    public void addReference(NativeObject referent) {
         new NativeObjectReference(this, referent, referenceQueue);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
index 56701527d6..590f65dba6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
@@ -16,16 +16,21 @@
 
 package io.realm.internal;
 
+import java.util.Collections;
 import java.util.ConcurrentModificationException;
 import java.util.Date;
 import java.util.NoSuchElementException;
 
 import javax.annotation.Nullable;
 
+import io.realm.MutableRealmInteger;
 import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.RealmChangeListener;
+import io.realm.RealmList;
+import io.realm.RealmModel;
 import io.realm.internal.core.DescriptorOrdering;
 import io.realm.internal.core.QueryDescriptor;
+import io.realm.internal.objectstore.OsObjectBuilder;
 
 
 /**
@@ -395,6 +400,144 @@ public boolean deleteLast() {
         return nativeDeleteLast(nativePtr);
     }
 
+    public void setNull(String fieldName) {
+        nativeSetNull(nativePtr, fieldName);
+    }
+
+    public void setBoolean(String fieldName, boolean value) {
+        nativeSetBoolean(nativePtr, fieldName, value);
+    }
+
+    public void setInt(String fieldName, long value) {
+        nativeSetInt(nativePtr, fieldName, value);
+    }
+
+    public void setFloat(String fieldName, float value) {
+        nativeSetFloat(nativePtr, fieldName, value);
+    }
+
+    public void setDouble(String fieldName, double value) {
+        nativeSetDouble(nativePtr, fieldName, value);
+    }
+
+    public void setString(String fieldName, @Nullable String value) {
+        nativeSetString(nativePtr, fieldName, value);
+    }
+
+    public void setBlob(String fieldName, @Nullable byte[] value) {
+        nativeSetBinary(nativePtr, fieldName, value);
+    }
+
+    public void setDate(String fieldName, @Nullable Date timestamp) {
+        if (timestamp == null) {
+            nativeSetNull(nativePtr, fieldName);
+        } else {
+            nativeSetTimestamp(nativePtr, fieldName, timestamp.getTime());
+        }
+    }
+
+    public void setObject(String fieldName, @Nullable Row row) {
+        if (row == null) {
+            setNull(fieldName);
+        } else {
+            long rowPtr;
+            if (row instanceof UncheckedRow) {
+                // Normal Realms
+                rowPtr = ((UncheckedRow) row).getNativePtr();
+            } else if (row instanceof CheckedRow) {
+                // Dynamic Realms
+                rowPtr = ((CheckedRow) row).getNativePtr();
+            } else {
+                // Should never happen, but just in case.
+                throw new UnsupportedOperationException("Unsupported Row type: " + row.getClass().getCanonicalName());
+            }
+            nativeSetObject(nativePtr, fieldName, rowPtr);
+        }
+    }
+
+    // Interface wrapping adding the specific list type
+    private interface AddListTypeDelegate<T> {
+        void addList(OsObjectBuilder builder, RealmList<T> list);
+    }
+
+    // Helper method for adding specific types of lists.
+    private <T> void addTypeSpecificList(String fieldName, RealmList<T> list, AddListTypeDelegate<T> delegate) {
+        //noinspection unchecked
+        OsObjectBuilder builder = new OsObjectBuilder(getTable(), 0, Collections.EMPTY_SET);
+        delegate.addList(builder, list);
+        try {
+            nativeSetList(nativePtr, fieldName, builder.getNativePtr());
+        } finally {
+            builder.close();
+        }
+    }
+
+    public void setStringList(String fieldName, RealmList<String> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addStringList(0, lst);
+        });
+    }
+
+    public void setByteList(String fieldName, RealmList<Byte> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addByteList(0, lst);
+        });
+    }
+
+    public void setShortList(String fieldName, RealmList<Short> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addShortList(0, lst);
+        });
+    }
+
+    public void setIntegerList(String fieldName, RealmList<Integer> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addIntegerList(0, lst);
+        });
+    }
+
+    public void setLongList(String fieldName, RealmList<Long> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addLongList(0, lst);
+        });
+    }
+
+    public void setBooleanList(String fieldName, RealmList<Boolean> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addBooleanList(0, lst);
+        });
+    }
+
+    public void setByteArrayList(String fieldName, RealmList<byte[]> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addByteArrayList(0, lst);
+        });
+    }
+
+    public void setDateList(String fieldName, RealmList<Date> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addDateList(0, lst);
+        });
+    }
+
+    public void setFloatList(String fieldName, RealmList<Float> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addFloatList(0, lst);
+        });
+    }
+
+    public void setDoubleList(String fieldName, RealmList<Double> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addDoubleList(0, lst);
+        });
+    }
+
+    public void setModelList(String fieldName, RealmList<? extends RealmModel> list) {
+        addTypeSpecificList(fieldName, list, (builder, lst) -> {
+            builder.addObjectList(0, lst);
+        });
+    }
+
     public <T> void addListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
         if (observerPairs.isEmpty()) {
             nativeStartListening(nativePtr);
@@ -503,6 +646,26 @@ public void load() {
 
     private static native void nativeDelete(long nativePtr, long index);
 
+    private static native void nativeSetNull(long nativePtr, String fieldName);
+
+    private static native void nativeSetBoolean(long nativePtr, String fieldName, boolean value);
+
+    private static native void nativeSetInt(long nativePtr, String fieldName, long value);
+
+    private static native void nativeSetFloat(long nativePtr, String fieldName, float value);
+
+    private static native void nativeSetDouble(long nativePtr, String fieldName, double value);
+
+    private static native void nativeSetString(long nativePtr, String fieldName, @Nullable String value);
+
+    private static native void nativeSetBinary(long nativePtr, String fieldName, @Nullable byte[] value);
+
+    private static native void nativeSetTimestamp(long nativePtr, String fieldName, long value);
+
+    private static native void nativeSetObject(long nativePtr, String fieldName, long rowNativePtr);
+
+    private static native void nativeSetList(long nativePtr, String fieldName, long builderNativePtr);
+
     // Non-static, we need this OsResults object in JNI.
     private native void nativeStartListening(long nativePtr);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java b/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java
index a5ed0f3c82..069ad20d85 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/objectstore/OsObjectBuilder.java
@@ -15,6 +15,7 @@
  */
 package io.realm.internal.objectstore;
 
+import java.io.Closeable;
 import java.util.Date;
 import java.util.List;
 import java.util.Set;
@@ -58,7 +59,7 @@
  * that can guide any architectural design and the only way to really find out is to build out each
  * solution and benchmark it.
  */
-public class OsObjectBuilder {
+public class OsObjectBuilder implements Closeable {
 
     private final Table table;
     private final long sharedRealmPtr;
@@ -356,25 +357,50 @@ private void addEmptyList(long columnIndex) {
         nativeStopList(builderPtr, columnIndex, listPtr);
     }
 
+    /**
+     * Updates any existing object if it exists, otherwise creates a new one.
+     *
+     * The builder is automatically closed after calling this method.
+     */
     public void updateExistingObject() {
         try {
             nativeCreateOrUpdate(sharedRealmPtr, tablePtr, builderPtr, true, ignoreFieldsWithSameValue);
         } finally {
-            nativeDestroyBuilder(builderPtr);
+            close();
         }
     }
 
+    /**
+     * Create a new object.
+     *
+     * The builder is automatically closed after calling this method.
+     */
     public UncheckedRow createNewObject() {
         UncheckedRow row;
         try {
             long rowPtr = nativeCreateOrUpdate(sharedRealmPtr, tablePtr, builderPtr, false, false);
             row = new UncheckedRow(context, table, rowPtr);
         } finally {
-            nativeDestroyBuilder(builderPtr);
+            close();
         }
         return row;
     }
 
+    /**
+     * Returns the underlying native pointer representing this builder.
+     */
+    public long getNativePtr() {
+        return builderPtr;
+    }
+
+    /**
+     * Manually closes the underlying Builder
+     */
+    @Override
+    public void close() {
+        nativeDestroyBuilder(builderPtr);
+    }
+
     private interface ItemCallback<T>  {
         void handleItem(long listPtr, T item);
     }
